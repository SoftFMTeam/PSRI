,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,270336,addrs,3,ngx_http_conf_port_t.addrs,,http\ngx_http_core_module.h,addrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1,225281,name,3,ngx_http_ssi_param_t.name,,http\modules\ngx_http_ssi_filter_module.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2,294914,post_handler,3,ngx_http_request_body_t.post_handler,,http\ngx_http_request.h,post_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3,225282,index,3,ngx_http_ssi_param_t.index,,http\modules\ngx_http_ssi_filter_module.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
4,225283,mandatory,3,ngx_http_ssi_param_t.mandatory,,http\modules\ngx_http_ssi_filter_module.h,mandatory:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5,225284,multiple,3,ngx_http_ssi_param_t.multiple,,http\modules\ngx_http_ssi_filter_module.h,multiple:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
6,294920,conf_ctx,3,ngx_http_connection_t.conf_ctx,,http\ngx_http_request.h,*conf_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7,225288,handler,3,ngx_http_ssi_command_t.handler,,http\modules\ngx_http_ssi_filter_module.h,handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8,225289,params,3,ngx_http_ssi_command_t.params,,http\modules\ngx_http_ssi_filter_module.h,*params,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
9,225290,conditional,3,ngx_http_ssi_command_t.conditional,,http\modules\ngx_http_ssi_filter_module.h,conditional:2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
10,385036,ngx_mail_pop3_parse_command,1,ngx_mail_pop3_parse_command,ngx_int_t ngx_mail_pop3_parse_command (ngx_mail_session_t*),mail\ngx_mail_parse.c,"ngx_int_t
ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
{
    u_char      ch, *p, *c, c0, c1, c2, c3;
    ngx_str_t  *arg;
    enum {
        sw_start = 0,
        sw_spaces_before_argument,
        sw_argument,
        sw_almost_done
    } state;

    state = s->state;

    for (p = s->buffer->pos; p < s->buffer->last; p++) {
        ch = *p;

        switch (state) {

        /* POP3 command */
        case sw_start:
            if (ch == ' ' || ch == CR || ch == LF) {
                c = s->buffer->start;

                if (p - c == 4) {

                    c0 = ngx_toupper(c[0]);
                    c1 = ngx_toupper(c[1]);
                    c2 = ngx_toupper(c[2]);
                    c3 = ngx_toupper(c[3]);

                    if (c0 == 'U' && c1 == 'S' && c2 == 'E' && c3 == 'R')
                    {
                        s->command = NGX_POP3_USER;

                    } else if (c0 == 'P' && c1 == 'A' && c2 == 'S' && c3 == 'S')
                    {
             ...",17.0,212.0,1.0,1.0,196.0,110,16,120,24,0,34,38,51,5,2,,0,34,2,1,1,ngx_int_t
11,13,ngx_show_version_info,1,ngx_show_version_info,void ngx_show_version_info (void),core\nginx.c,"static void
ngx_show_version_info(void)
{
    ngx_write_stderr(""nginx version: "" NGINX_VER_BUILD NGX_LINEFEED);

    if (ngx_show_help) {
        ngx_write_stderr(
            ""Usage: nginx [-?hvVtTq] [-s signal] [-c filename] ""
                         ""[-p prefix] [-g directives]"" NGX_LINEFEED
                         NGX_LINEFEED
            ""Options:"" NGX_LINEFEED
            ""  -?,-h         : this help"" NGX_LINEFEED
            ""  -v            : show version and exit"" NGX_LINEFEED
            ""  -V            : show version and configure options then exit""
                               NGX_LINEFEED
            ""  -t            : test configuration and exit"" NGX_LINEFEED
            ""  -T            : test configuration, dump it and exit""
                               NGX_LINEFEED
            ""  -q            : suppress non-error messages ""
                               ""during configuration testing"" NGX_LINEFEED
            ""  -s signal     : send signal to a master proces...",389.0,448.0,1.0,1.0,60.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
12,225291,block,3,ngx_http_ssi_command_t.block,,http\modules\ngx_http_ssi_filter_module.h,block:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
13,294927,proxy_protocol,3,ngx_http_connection_t.proxy_protocol,,http\ngx_http_request.h,proxy_protocol:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
14,225292,flush,3,ngx_http_ssi_command_t.flush,,http\modules\ngx_http_ssi_filter_module.h,flush:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
15,86029,ngx_ssl_trusted_certificate,1,ngx_ssl_trusted_certificate,"ngx_int_t ngx_ssl_trusted_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_int_t depth)
{
    SSL_CTX_set_verify_depth(ssl->ctx, depth);

    if (cert->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_load_verify_locations(\""%s\"") failed"",
                      cert->data);
        return NGX_ERROR;
    }

    /*
     * SSL_CTX_load_verify_locations() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

    return NGX_OK;
}",919.0,950.0,1.0,1.0,32.0,11,4,16,8,0,5,4,4,3,2,,0,4,8,4,4,ngx_int_t
16,18,ngx_add_inherited_sockets,1,ngx_add_inherited_sockets,ngx_int_t ngx_add_inherited_sockets (ngx_cycle_t*),core\nginx.c,"static ngx_int_t
ngx_add_inherited_sockets(ngx_cycle_t *cycle)
{
    u_char           *p, *v, *inherited;
    ngx_int_t         s;
    ngx_listening_t  *ls;

    inherited = (u_char *) getenv(NGINX_VAR);

    if (inherited == NULL) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                  ""using inherited sockets from \""%s\"""", inherited);

    if (ngx_array_init(&cycle->listening, cycle->pool, 10,
                       sizeof(ngx_listening_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (p = inherited, v = p; *p; p++) {
        if (*p == ':' || *p == ';') {
            s = ngx_atoi(v, p - v);
            if (s == NGX_ERROR) {
                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                              ""invalid socket number \""%s\"" in "" NGINX_VAR
                              "" environment variable, ignoring the rest""
                              "" of the variable"", v);
                break;
            }
...",451.0,507.0,1.0,1.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
17,40979,ngx_resolver_lookup_addr,1,ngx_resolver_lookup_addr,"ngx_resolver_node_t* ngx_resolver_lookup_addr (ngx_resolver_t*,in_addr_t)",core\ngx_resolver.c,"static ngx_resolver_node_t *
ngx_resolver_lookup_addr(ngx_resolver_t *r, in_addr_t addr)
{
    ngx_rbtree_node_t  *node, *sentinel;

    node = r->addr_rbtree.root;
    sentinel = r->addr_rbtree.sentinel;

    while (node != sentinel) {

        if (addr < node->key) {
            node = node->left;
            continue;
        }

        if (addr > node->key) {
            node = node->right;
            continue;
        }

        /* addr == node->key */

        return ngx_resolver_node(node);
    }

    /* not found */

    return NULL;
}",3450.0,3478.0,1.0,15.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_resolver_node_t
18,299030,ngx_http_test_predicates,1,ngx_http_test_predicates,"ngx_int_t ngx_http_test_predicates (ngx_http_request_t*,ngx_array_t*)",http\ngx_http_script.c,"ngx_int_t
ngx_http_test_predicates(ngx_http_request_t *r, ngx_array_t *predicates)
{
    ngx_str_t                  val;
    ngx_uint_t                 i;
    ngx_http_complex_value_t  *cv;

    if (predicates == NULL) {
        return NGX_OK;
    }

    cv = predicates->elts;

    for (i = 0; i < predicates->nelts; i++) {
        if (ngx_http_complex_value(r, &cv[i], &val) != NGX_OK) {
            return NGX_ERROR;
        }

        if (val.len && (val.len != 1 || val.data[0] != '0')) {
            return NGX_DECLINED;
        }
    }

    return NGX_OK;
}",308.0,332.0,1.0,1.0,25.0,18,10,19,9,0,6,5,7,5,1,,0,6,4,2,2,ngx_int_t
19,28,ngx_get_options,1,ngx_get_options,"ngx_int_t ngx_get_options (int,char**)",core\nginx.c,"static ngx_int_t
ngx_get_options(int argc, char *const *argv)
{
    u_char     *p;
    ngx_int_t   i;

    for (i = 1; i < argc; i++) {

        p = (u_char *) argv[i];

        if (*p++ != '-') {
            ngx_log_stderr(0, ""invalid option: \""%s\"""", argv[i]);
            return NGX_ERROR;
        }

        while (*p) {

            switch (*p++) {

            case '?':
            case 'h':
                ngx_show_version = 1;
                ngx_show_help = 1;
                break;

            case 'v':
                ngx_show_version = 1;
                break;

            case 'V':
                ngx_show_version = 1;
                ngx_show_configure = 1;
                break;

            case 't':
                ngx_test_config = 1;
                break;

            case 'T':
                ngx_test_config = 1;
                ngx_dump_config = 1;
                break;

            case 'q':
                ngx_quiet_mode = 1;
                break;

        ...",741.0,866.0,1.0,1.0,126.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
20,20509,ngx_hash_keys_array_init,1,ngx_hash_keys_array_init,"ngx_int_t ngx_hash_keys_array_init (ngx_hash_keys_arrays_t*,ngx_uint_t)",core\ngx_hash.c,"ngx_int_t
ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha, ngx_uint_t type)
{
    ngx_uint_t  asize;

    if (type == NGX_HASH_SMALL) {
        asize = 4;
        ha->hsize = 107;

    } else {
        asize = NGX_HASH_LARGE_ASIZE;
        ha->hsize = NGX_HASH_LARGE_HSIZE;
    }

    if (ngx_array_init(&ha->keys, ha->temp_pool, asize, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&ha->dns_wc_head, ha->temp_pool, asize,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&ha->dns_wc_tail, ha->temp_pool, asize,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    ha->keys_hash = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t) * ha->hsize);
    if (ha->keys_hash == NULL) {
        return NGX_ERROR;
    }

    ha->dns_wc_head_hash = ngx_pcalloc(ha->temp_pool,
                                     ...",678.0,730.0,1.0,1.0,53.0,43,7,44,9,2,25,8,8,12,6,,0,25,4,2,2,ngx_int_t
21,69662,ngx_http_cookie_time,1,ngx_http_cookie_time,"u_char ngx_http_cookie_time (u_char*,time_t)",core\ngx_times.c,"u_char *
ngx_http_cookie_time(u_char *buf, time_t t)
{
    ngx_tm_t  tm;

    ngx_gmtime(t, &tm);

    /*
     * Netscape 3.x does not understand 4-digit years at all and
     * 2-digit years more than ""37""
     */

    return ngx_sprintf(buf,
                       (tm.ngx_tm_year > 2037) ?
                                         ""%s, %02d-%s-%d %02d:%02d:%02d GMT"":
                                         ""%s, %02d-%s-%02d %02d:%02d:%02d GMT"",
                       week[tm.ngx_tm_wday],
                       tm.ngx_tm_mday,
                       months[tm.ngx_tm_mon - 1],
                       (tm.ngx_tm_year > 2037) ? tm.ngx_tm_year:
                                                 tm.ngx_tm_year % 100,
                       tm.ngx_tm_hour,
                       tm.ngx_tm_min,
                       tm.ngx_tm_sec);
}",300.0,324.0,1.0,1.0,25.0,19,7,15,5,0,4,1,1,0,2,,0,2,4,2,2,u_char
22,34,ngx_process_options,1,ngx_process_options,ngx_int_t ngx_process_options (ngx_cycle_t*),core\nginx.c,"static ngx_int_t
ngx_process_options(ngx_cycle_t *cycle)
{
    u_char  *p;
    size_t   len;

    if (ngx_prefix) {
        len = ngx_strlen(ngx_prefix);
        p = ngx_prefix;

        if (len && !ngx_path_separator(p[len - 1])) {
            p = ngx_pnalloc(cycle->pool, len + 1);
            if (p == NULL) {
                return NGX_ERROR;
            }

            ngx_memcpy(p, ngx_prefix, len);
            p[len++] = '/';
        }

        cycle->conf_prefix.len = len;
        cycle->conf_prefix.data = p;
        cycle->prefix.len = len;
        cycle->prefix.data = p;

    } else {

#ifndef NGX_PREFIX

        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);
        if (p == NULL) {
            return NGX_ERROR;
        }

        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {
            ngx_log_stderr(ngx_errno, ""[emerg]: "" ngx_getcwd_n "" failed"");
            return NGX_ERROR;
        }

        len = ngx_strlen(p);

        p[len++] = '/';

        cycle->conf_prefix.len = len;
  ...",911.0,1004.0,1.0,1.0,94.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
23,204838,hash,3,ngx_http_referer_conf_t.hash,,http\modules\ngx_http_referer_module.c,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
24,39,ngx_save_argv,1,ngx_save_argv,"ngx_int_t ngx_save_argv (ngx_cycle_t*,int,char**)",core\nginx.c,"static ngx_int_t
ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)
{
#if (NGX_FREEBSD)

    ngx_os_argv = (char **) argv;
    ngx_argc = argc;
    ngx_argv = (char **) argv;

#else
    size_t     len;
    ngx_int_t  i;

    ngx_os_argv = (char **) argv;
    ngx_argc = argc;

    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);
    if (ngx_argv == NULL) {
        return NGX_ERROR;
    }

    for (i = 0; i < argc; i++) {
        len = ngx_strlen(argv[i]) + 1;

        ngx_argv[i] = ngx_alloc(len, cycle->log);
        if (ngx_argv[i] == NULL) {
            return NGX_ERROR;
        }

        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);
    }

    ngx_argv[i] = NULL;

#endif

    ngx_os_environ = environ;

    return NGX_OK;
}",869.0,908.0,1.0,1.0,40.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
25,270293,ctx,3,ngx_http_core_srv_conf_t.ctx,,http\ngx_http_core_module.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
26,41001,ngx_resolver_set_timeout,1,ngx_resolver_set_timeout,"ngx_int_t ngx_resolver_set_timeout (ngx_resolver_t*,ngx_resolver_ctx_t*)",core\ngx_resolver.c,"static ngx_int_t
ngx_resolver_set_timeout(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx)
{
    if (ctx->event || ctx->timeout == 0) {
        return NGX_OK;
    }

    ctx->event = ngx_resolver_calloc(r, sizeof(ngx_event_t));
    if (ctx->event == NULL) {
        return NGX_ERROR;
    }

    ctx->event->handler = ngx_resolver_timeout_handler;
    ctx->event->data = ctx;
    ctx->event->log = r->log;
    ctx->event->cancelable = ctx->cancelable;
    ctx->ident = -1;

    ngx_add_timer(ctx->event, ctx->timeout);

    return NGX_OK;
}",4015.0,4036.0,1.0,1.0,22.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
27,204841,no_referer,3,ngx_http_referer_conf_t.no_referer,,http\modules\ngx_http_referer_module.c,no_referer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
28,204842,blocked_referer,3,ngx_http_referer_conf_t.blocked_referer,,http\modules\ngx_http_referer_module.c,blocked_referer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
29,393264,ngx_mail_smtp_greeting,1,ngx_mail_smtp_greeting,"void ngx_mail_smtp_greeting (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static void
ngx_mail_smtp_greeting(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_msec_t                 timeout;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_smtp_srv_conf_t  *sscf;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""smtp greeting for \""%V\"""", &s->host);

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    timeout = sscf->greeting_delay ? sscf->greeting_delay : cscf->timeout;
    ngx_add_timer(c->read, timeout);

    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
        ngx_mail_close_connection(c);
    }

    if (c->read->ready) {
        ngx_post_event(c->read, &ngx_posted_events);
    }

    if (sscf->greeting_delay) {
         c->read->handler = ngx_mail_smtp_invalid_pipelining;
         return;
    }

    c->read->handler = ngx_mail_smtp_init_protocol;

    s->out = sscf->greeting;

    ngx_mail_send(c->write);
}",280.0,314.0,1.0,1.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
30,262194,ngx_http_weak_etag,1,ngx_http_weak_etag,void ngx_http_weak_etag (ngx_http_request_t*),http\ngx_http_core_module.c,"void
ngx_http_weak_etag(ngx_http_request_t *r)
{
    size_t            len;
    u_char           *p;
    ngx_table_elt_t  *etag;

    etag = r->headers_out.etag;

    if (etag == NULL) {
        return;
    }

    if (etag->value.len > 2
        && etag->value.data[0] == 'W'
        && etag->value.data[1] == '/')
    {
        return;
    }

    if (etag->value.len < 1 || etag->value.data[0] != '""') {
        r->headers_out.etag->hash = 0;
        r->headers_out.etag = NULL;
        return;
    }

    p = ngx_pnalloc(r->pool, etag->value.len + 2);
    if (p == NULL) {
        r->headers_out.etag->hash = 0;
        r->headers_out.etag = NULL;
        return;
    }

    len = ngx_sprintf(p, ""W/%V"", &etag->value) - p;

    etag->value.data = p;
    etag->value.len = len;
}",1692.0,1729.0,1.0,1.0,38.0,55,13,28,5,3,11,5,5,5,2,,0,11,2,1,1,void
31,106549,charsets,3,ngx_http_charset_main_conf_t.charsets,,http\modules\ngx_http_charset_filter_module.c,charsets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
32,258103,bufs,3,ngx_http_copy_filter_conf_t.bufs,,http\ngx_http_copy_filter_module.c,bufs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
33,270296,server_name,3,ngx_http_core_srv_conf_t.server_name,,http\ngx_http_core_module.h,server_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
34,41018,ngx_resolver_alloc,1,ngx_resolver_alloc,"void* ngx_resolver_alloc (ngx_resolver_t*,size_t)",core\ngx_resolver.c,"static void *
ngx_resolver_alloc(ngx_resolver_t *r, size_t size)
{
    u_char  *p;

    /* lock alloc mutex */

    p = ngx_alloc(size, r->log);

    /* unlock alloc mutex */

    return p;
}",4097.0,4109.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
35,393275,ngx_mail_smtp_create_buffer,1,ngx_mail_smtp_create_buffer,"ngx_int_t ngx_mail_smtp_create_buffer (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_create_buffer(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_smtp_srv_conf_t  *sscf;

    if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t)) == NGX_ERROR) {
        ngx_mail_session_internal_server_error(s);
        return NGX_ERROR;
    }

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    s->buffer = ngx_create_temp_buf(c->pool, sscf->client_buffer_size);
    if (s->buffer == NULL) {
        ngx_mail_session_internal_server_error(s);
        return NGX_ERROR;
    }

    return NGX_OK;
}",408.0,427.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
36,16444,ngx_next_temp_number,1,ngx_next_temp_number,ngx_atomic_uint_t ngx_next_temp_number (ngx_uint_t),core\ngx_file.c,"ngx_atomic_uint_t
ngx_next_temp_number(ngx_uint_t collision)
{
    ngx_atomic_uint_t  n, add;

    add = collision ? ngx_random_number : 1;

    n = ngx_atomic_fetch_add(ngx_temp_number, add);

    return n + add;
}",347.0,357.0,1.0,1.0,11.0,4,3,8,5,4,3,1,1,0,1,,0,3,2,1,1,ngx_atomic_uint_t
37,41024,ngx_resolver_calloc,1,ngx_resolver_calloc,"void* ngx_resolver_calloc (ngx_resolver_t*,size_t)",core\ngx_resolver.c,"static void *
ngx_resolver_calloc(ngx_resolver_t *r, size_t size)
{
    u_char  *p;

    p = ngx_resolver_alloc(r, size);

    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",4112.0,4124.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
38,393281,ngx_mail_smtp_helo,1,ngx_mail_smtp_helo,"ngx_int_t ngx_mail_smtp_helo (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_helo(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg;
    ngx_mail_smtp_srv_conf_t  *sscf;

    if (s->args.nelts != 1) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        s->state = 0;
        return NGX_OK;
    }

    arg = s->args.elts;

    s->smtp_helo.len = arg[0].len;

    s->smtp_helo.data = ngx_pnalloc(c->pool, arg[0].len);
    if (s->smtp_helo.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->smtp_helo.data, arg[0].data, arg[0].len);

    ngx_str_null(&s->smtp_from);
    ngx_str_null(&s->smtp_to);

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    if (s->command == NGX_SMTP_HELO) {
        s->out = sscf->server_name;

    } else {
        s->esmtp = 1;

#if (NGX_MAIL_SSL)

        if (c->ssl == NULL) {
            ngx_mail_ssl_conf_t  *sslcf;

            sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

            if (sslcf->starttls == NGX_MAIL_S...",576.0,633.0,1.0,1.0,58.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
39,106561,table,3,ngx_http_charset_ctx_t.table,,http\modules\ngx_http_charset_filter_module.c,*table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
40,106564,busy,3,ngx_http_charset_ctx_t.busy,,http\modules\ngx_http_charset_filter_module.c,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
41,8261,file,3,ngx_conf_file_t.file,,core\ngx_conf_file.h,file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
42,41030,ngx_resolver_free,1,ngx_resolver_free,"void ngx_resolver_free (ngx_resolver_t*,void*)",core\ngx_resolver.c,"static void
ngx_resolver_free(ngx_resolver_t *r, void *p)
{
    /* lock alloc mutex */

    ngx_free(p);

    /* unlock alloc mutex */
}",4127.0,4135.0,1.0,1.0,9.0,0,0,0,0,14,0,1,1,0,0,,0,0,4,2,2,void
43,106565,free_bufs,3,ngx_http_charset_ctx_t.free_bufs,,http\modules\ngx_http_charset_filter_module.c,*free_bufs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
44,393287,ngx_mail_smtp_auth,1,ngx_mail_smtp_auth,"ngx_int_t ngx_mail_smtp_auth (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_smtp_srv_conf_t  *sscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        s->state = 0;
        return NGX_OK;
    }

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, smtp_username);
        s->mail_state = ngx_smtp_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, smtp_password);
        s->mail_state = ngx_smtp_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, smtp_next);
     ...",636.0,716.0,1.0,1.0,81.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
45,106566,free_buffers,3,ngx_http_charset_ctx_t.free_buffers,,http\modules\ngx_http_charset_filter_module.c,*free_buffers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
46,106570,from_utf8,3,ngx_http_charset_ctx_t.from_utf8,,http\modules\ngx_http_charset_filter_module.c,from_utf8:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
47,106571,to_utf8,3,ngx_http_charset_ctx_t.to_utf8,,http\modules\ngx_http_charset_filter_module.c,to_utf8:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
48,41036,ngx_resolver_free_locked,1,ngx_resolver_free_locked,"void ngx_resolver_free_locked (ngx_resolver_t*,void*)",core\ngx_resolver.c,"static void
ngx_resolver_free_locked(ngx_resolver_t *r, void *p)
{
    ngx_free(p);
}",4138.0,4142.0,1.0,1.0,5.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
49,393293,ngx_mail_smtp_mail,1,ngx_mail_smtp_mail,"ngx_int_t ngx_mail_smtp_mail (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_mail(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg, cmd;
    ngx_mail_smtp_srv_conf_t  *sscf;

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    if (!(sscf->auth_methods & NGX_MAIL_AUTH_NONE_ENABLED)) {
        ngx_mail_smtp_log_rejected_command(s, c, ""client was rejected: \""%V\"""");
        ngx_str_set(&s->out, smtp_auth_required);
        return NGX_OK;
    }

    /* auth none */

    if (s->smtp_from.len) {
        ngx_str_set(&s->out, smtp_bad_sequence);
        return NGX_OK;
    }

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        return NGX_OK;
    }

    arg = s->args.elts;
    arg += s->args.nelts - 1;

    cmd.len = arg->data + arg->len - s->cmd.data;
    cmd.data = s->cmd.data;

    s->smtp_from.len = cmd.len;

    s->smtp_from.data = ngx_pnalloc(c->pool, cmd.len);
    if (s->smtp_from.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcp...",719.0,766.0,1.0,1.0,48.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
50,8264,line,3,ngx_conf_file_t.line,,core\ngx_conf_file.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
51,86092,ngx_ssl_crl,1,ngx_ssl_crl,"ngx_int_t ngx_ssl_crl (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl)
{
    X509_STORE   *store;
    X509_LOOKUP  *lookup;

    if (crl->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, crl, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    store = SSL_CTX_get_cert_store(ssl->ctx);

    if (store == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_get_cert_store() failed"");
        return NGX_ERROR;
    }

    lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());

    if (lookup == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""X509_STORE_add_lookup() failed"");
        return NGX_ERROR;
    }

    if (X509_LOOKUP_load_file(lookup, (char *) crl->data, X509_FILETYPE_PEM)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""X509_LOOKUP_load_file(\""%s\"") failed"", crl->data);
        return NGX_ERROR;
    }

    X509_STORE_set_flags(stor...",953.0,995.0,1.0,1.0,43.0,17,6,31,12,0,7,6,6,3,4,,0,4,6,3,3,ngx_int_t
52,16466,ngx_conf_set_path_slot,1,ngx_conf_set_path_slot,"char* ngx_conf_set_path_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_file.c,"char *
ngx_conf_set_path_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ssize_t      level;
    ngx_str_t   *value;
    ngx_uint_t   i, n;
    ngx_path_t  *path, **slot;

    slot = (ngx_path_t **) (p + cmd->offset);

    if (*slot) {
        return ""is duplicate"";
    }

    path = ngx_pcalloc(cf->pool, sizeof(ngx_path_t));
    if (path == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    path->name = value[1];

    if (path->name.data[path->name.len - 1] == '/') {
        path->name.len--;
    }

    if (ngx_conf_full_name(cf->cycle, &path->name, 0) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    path->conf_file = cf->conf_file->file.name.data;
    path->line = cf->conf_file->line;

    for (i = 0, n = 2; n < cf->args->nelts; i++, n++) {
        level = ngx_atoi(value[n].data, value[n].len);
        if (level == NGX_ERROR || level == 0) {
            return ""invalid value"";
        }

        path->level[i] = le...",360.0,417.0,1.0,1.0,58.0,66,18,53,16,0,14,9,10,6,4,,0,14,6,3,3,char*
53,393299,ngx_mail_smtp_starttls,1,ngx_mail_smtp_starttls,"ngx_int_t ngx_mail_smtp_starttls (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {

            /*
             * RFC3207 requires us to discard any knowledge
             * obtained from client before STARTTLS.
             */

            ngx_str_null(&s->smtp_helo);
            ngx_str_null(&s->smtp_from);
            ngx_str_null(&s->smtp_to);

            s->buffer->pos = s->buffer->start;
            s->buffer->last = s->buffer->start;

            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",819.0,849.0,1.0,1.0,31.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
54,41042,ngx_resolver_dup,1,ngx_resolver_dup,"void* ngx_resolver_dup (ngx_resolver_t*,void*,size_t)",core\ngx_resolver.c,"static void *
ngx_resolver_dup(ngx_resolver_t *r, void *src, size_t size)
{
    void  *dst;

    dst = ngx_resolver_alloc(r, size);

    if (dst == NULL) {
        return dst;
    }

    ngx_memcpy(dst, src, size);

    return dst;
}",4145.0,4159.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void*
55,393305,ngx_mail_smtp_rset,1,ngx_mail_smtp_rset,"ngx_int_t ngx_mail_smtp_rset (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_null(&s->smtp_from);
    ngx_str_null(&s->smtp_to);
    ngx_str_set(&s->out, smtp_ok);

    return NGX_OK;
}",808.0,816.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
56,106586,ngx_http_destination_charset,1,ngx_http_destination_charset,"ngx_int_t ngx_http_destination_charset (ngx_http_request_t*,ngx_str_t*)",http\modules\ngx_http_charset_filter_module.c,"static ngx_int_t
ngx_http_destination_charset(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_int_t                      charset;
    ngx_http_charset_t            *charsets;
    ngx_http_variable_value_t     *vv;
    ngx_http_charset_loc_conf_t   *mlcf;
    ngx_http_charset_main_conf_t  *mcf;

    if (r->headers_out.content_type.len == 0) {
        return NGX_DECLINED;
    }

    if (r->headers_out.override_charset
        && r->headers_out.override_charset->len)
    {
        *name = *r->headers_out.override_charset;

        charset = ngx_http_get_charset(r, name);

        if (charset != NGX_HTTP_NO_CHARSET) {
            return charset;
        }

        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""unknown charset \""%V\"" to override"", name);

        return NGX_DECLINED;
    }

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_charset_filter_module);
    charset = mlcf->charset;

    if (charset == NGX_HTTP_CHARSET_OFF) {
        return NGX_DECL...",316.0,381.0,1.0,23.0,66.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
57,217177,enable,3,ngx_http_ssi_loc_conf_t.enable,,http\modules\ngx_http_ssi_filter_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
58,401500,ngx_close_file_mapping,1,ngx_close_file_mapping,void ngx_close_file_mapping (ngx_file_mapping_t*),os\win32\ngx_files.c,"void
ngx_close_file_mapping(ngx_file_mapping_t *fm)
{
    if (UnmapViewOfFile(fm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%s\"" failed"",
                      fm->addr, &fm->name);
    }

    if (CloseHandle(fm->handle) == 0) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ""CloseHandle() of file mapping \""%s\"" failed"",
                      &fm->name);
    }

    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", fm->name);
    }
}",397.0,416.0,1.0,1.0,20.0,9,3,9,4,0,7,3,3,3,1,,0,6,2,1,1,void
59,217178,silent_errors,3,ngx_http_ssi_loc_conf_t.silent_errors,,http\modules\ngx_http_ssi_filter_module.c,silent_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
60,69722,ngx_gmtime,1,ngx_gmtime,"void ngx_gmtime (time_t,ngx_tm_t*)",core\ngx_times.c,"void
ngx_gmtime(time_t t, ngx_tm_t *tp)
{
    ngx_int_t   yday;
    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;

    /* the calculation is valid for positive time_t only */

    if (t < 0) {
        t = 0;
    }

    days = t / 86400;
    sec = t % 86400;

    /*
     * no more than 4 year digits supported,
     * truncate to December 31, 9999, 23:59:59
     */

    if (days > 2932896) {
        days = 2932896;
        sec = 86399;
    }

    /* January 1, 1970 was Thursday */

    wday = (4 + days) % 7;

    hour = sec / 3600;
    sec %= 3600;
    min = sec / 60;
    sec %= 60;

    /*
     * the algorithm based on Gauss' formula,
     * see src/core/ngx_parse_time.c
     */

    /* days since March 1, 1 BC */
    days = days - (31 + 28) + 719527;

    /*
     * The ""days"" should be adjusted to 1 only, however, some March 1st's go
     * to previous year, so we adjust them to 2.  This causes also shift of the
     * last February days to next year, but we catch t...",327.0,429.0,1.0,1.0,103.0,84,17,58,12,4,0,5,5,0,0,,0,0,4,2,2,void
61,393311,ngx_mail_smtp_rcpt,1,ngx_mail_smtp_rcpt,"ngx_int_t ngx_mail_smtp_rcpt (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"static ngx_int_t
ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg, cmd;

    if (s->smtp_from.len == 0) {
        ngx_str_set(&s->out, smtp_bad_sequence);
        return NGX_OK;
    }

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        return NGX_OK;
    }

    arg = s->args.elts;
    arg += s->args.nelts - 1;

    cmd.len = arg->data + arg->len - s->cmd.data;
    cmd.data = s->cmd.data;

    s->smtp_to.len = cmd.len;

    s->smtp_to.data = ngx_pnalloc(c->pool, cmd.len);
    if (s->smtp_to.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->smtp_to.data, cmd.data, cmd.len);

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""smtp rcpt to:\""%V\"""", &s->smtp_to);

    s->auth_method = NGX_MAIL_AUTH_NONE;

    return NGX_DONE;
}",769.0,805.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
62,217180,last_modified,3,ngx_http_ssi_loc_conf_t.last_modified,,http\modules\ngx_http_ssi_filter_module.c,last_modified,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
63,299101,ngx_http_test_required_predicates,1,ngx_http_test_required_predicates,"ngx_int_t ngx_http_test_required_predicates (ngx_http_request_t*,ngx_array_t*)",http\ngx_http_script.c,"ngx_int_t
ngx_http_test_required_predicates(ngx_http_request_t *r,
    ngx_array_t *predicates)
{
    ngx_str_t                  val;
    ngx_uint_t                 i;
    ngx_http_complex_value_t  *cv;

    if (predicates == NULL) {
        return NGX_OK;
    }

    cv = predicates->elts;

    for (i = 0; i < predicates->nelts; i++) {
        if (ngx_http_complex_value(r, &cv[i], &val) != NGX_OK) {
            return NGX_ERROR;
        }

        if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
            return NGX_DECLINED;
        }
    }

    return NGX_OK;
}",335.0,360.0,1.0,1.0,26.0,19,10,19,9,0,6,5,7,5,1,,0,6,4,2,2,ngx_int_t
64,217182,min_file_chunk,3,ngx_http_ssi_loc_conf_t.min_file_chunk,,http\modules\ngx_http_ssi_filter_module.c,min_file_chunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
65,217183,value_len,3,ngx_http_ssi_loc_conf_t.value_len,,http\modules\ngx_http_ssi_filter_module.c,value_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
66,217179,ignore_recycled_buffers,3,ngx_http_ssi_loc_conf_t.ignore_recycled_buffers,,http\modules\ngx_http_ssi_filter_module.c,ignore_recycled_buffers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
67,217181,types,3,ngx_http_ssi_loc_conf_t.types,,http\modules\ngx_http_ssi_filter_module.c,types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
68,106598,ngx_http_source_charset,1,ngx_http_source_charset,"ngx_int_t ngx_http_source_charset (ngx_http_request_t*,ngx_str_t*)",http\modules\ngx_http_charset_filter_module.c,"static ngx_int_t
ngx_http_source_charset(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_int_t                      charset;
    ngx_http_charset_t            *charsets;
    ngx_http_variable_value_t     *vv;
    ngx_http_charset_loc_conf_t   *lcf;
    ngx_http_charset_main_conf_t  *mcf;

    if (r->headers_out.charset.len) {
        *name = r->headers_out.charset;
        return ngx_http_get_charset(r, name);
    }

    lcf = ngx_http_get_module_loc_conf(r, ngx_http_charset_filter_module);

    charset = lcf->source_charset;

    if (charset == NGX_HTTP_CHARSET_OFF) {
        name->len = 0;
        return charset;
    }

    if (charset < NGX_HTTP_CHARSET_VAR) {
        mcf = ngx_http_get_module_main_conf(r, ngx_http_charset_filter_module);
        charsets = mcf->charsets.elts;
        *name = charsets[charset].name;
        return charset;
    }

    vv = ngx_http_get_indexed_variable(r, charset - NGX_HTTP_CHARSET_VAR);

    if (vv == NULL || vv->not_found) {
        return NGX...",421.0,461.0,1.0,19.0,41.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
69,8298,post_handler,3,ngx_conf_post_t.post_handler,,core\ngx_conf_file.h,post_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
70,258155,ngx_http_copy_filter_module,2,http\ngx_http_copy_filter_module.c.ngx_http_copy_filter_module,,http\ngx_http_copy_filter_module.c,ngx_module_t ngx_http_copy_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
71,270446,queue,3,ngx_http_location_queue_t.queue,,http\ngx_http_core_module.h,queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
72,8303,new_name,3,ngx_conf_deprecated_t.new_name,,core\ngx_conf_file.h,*new_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
73,270448,inclusive,3,ngx_http_location_queue_t.inclusive,,http\ngx_http_core_module.h,*inclusive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
74,270449,name,3,ngx_http_location_queue_t.name,,http\ngx_http_core_module.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
75,8302,old_name,3,ngx_conf_deprecated_t.old_name,,core\ngx_conf_file.h,*old_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
76,270451,line,3,ngx_http_location_queue_t.line,,http\ngx_http_core_module.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
77,8308,high,3,ngx_conf_num_bounds_t.high,,core\ngx_conf_file.h,high,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
78,8307,low,3,ngx_conf_num_bounds_t.low,,core\ngx_conf_file.h,low,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
79,270452,list,3,ngx_http_location_queue_t.list,,http\ngx_http_core_module.h,list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
80,270450,file_name,3,ngx_http_location_queue_t.file_name,,http\ngx_http_core_module.h,*file_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
81,270447,exact,3,ngx_http_location_queue_t.exact,,http\ngx_http_core_module.h,*exact,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
82,106611,ngx_http_charset_ctx,1,ngx_http_charset_ctx,"ngx_int_t ngx_http_charset_ctx (ngx_http_request_t*,ngx_http_charset_t*,ngx_int_t,ngx_int_t)",http\modules\ngx_http_charset_filter_module.c,"static ngx_int_t
ngx_http_charset_ctx(ngx_http_request_t *r, ngx_http_charset_t *charsets,
    ngx_int_t charset, ngx_int_t source_charset)
{
    ngx_http_charset_ctx_t  *ctx;

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_charset_filter_module);

    ctx->table = charsets[source_charset].tables[charset];
    ctx->charset = charset;
    ctx->charset_name = charsets[charset].name;
    ctx->length = charsets[charset].length;
    ctx->from_utf8 = charsets[source_charset].utf8;
    ctx->to_utf8 = charsets[charset].utf8;

    r->filter_need_in_memory = 1;

    if ((ctx->to_utf8 || ctx->from_utf8) && r == r->main) {
        ngx_http_clear_content_length(r);

    } else {
        r->filter_need_temporary = 1;
    }

    return ngx_http_next_header_filter(r);
}",513.0,543.0,1.0,1.0,31.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
83,446582,ngx_stream_script_init_arrays,1,ngx_stream_script_init_arrays,ngx_int_t ngx_stream_script_init_arrays (ngx_stream_script_compile_t*),stream\ngx_stream_script.c,"static ngx_int_t
ngx_stream_script_init_arrays(ngx_stream_script_compile_t *sc)
{
    ngx_uint_t   n;

    if (sc->flushes && *sc->flushes == NULL) {
        n = sc->variables ? sc->variables : 1;
        *sc->flushes = ngx_array_create(sc->cf->pool, n, sizeof(ngx_uint_t));
        if (*sc->flushes == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->lengths == NULL) {
        n = sc->variables * (2 * sizeof(ngx_stream_script_copy_code_t)
                             + sizeof(ngx_stream_script_var_code_t))
            + sizeof(uintptr_t);

        *sc->lengths = ngx_array_create(sc->cf->pool, n, 1);
        if (*sc->lengths == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->values == NULL) {
        n = (sc->variables * (2 * sizeof(ngx_stream_script_copy_code_t)
                              + sizeof(ngx_stream_script_var_code_t))
                + sizeof(uintptr_t)
                + sc->source->len
                + sizeof(uintptr_t) - 1)
     ...",519.0,560.0,1.0,1.0,42.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
84,106619,ngx_http_charset_recode,1,ngx_http_charset_recode,"ngx_uint_t ngx_http_charset_recode (ngx_buf_t*,u_char*)",http\modules\ngx_http_charset_filter_module.c,"static ngx_uint_t
ngx_http_charset_recode(ngx_buf_t *b, u_char *table)
{
    u_char  *p, *last;

    last = b->last;

    for (p = b->pos; p < last; p++) {

        if (*p != table[*p]) {
            goto recode;
        }
    }

    return 0;

recode:

    do {
        if (*p != table[*p]) {
            *p = table[*p];
        }

        p++;

    } while (p < last);

    b->in_file = 0;

    return 1;
}",651.0,681.0,1.0,1.0,31.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_uint_t
85,446587,ngx_stream_script_done,1,ngx_stream_script_done,ngx_int_t ngx_stream_script_done (ngx_stream_script_compile_t*),stream\ngx_stream_script.c,"static ngx_int_t
ngx_stream_script_done(ngx_stream_script_compile_t *sc)
{
    ngx_str_t    zero;
    uintptr_t   *code;

    if (sc->zero) {

        zero.len = 1;
        zero.data = (u_char *) ""\0"";

        if (ngx_stream_script_add_copy_code(sc, &zero, 0) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->conf_prefix || sc->root_prefix) {
        if (ngx_stream_script_add_full_name_code(sc) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->complete_lengths) {
        code = ngx_stream_script_add_code(*sc->lengths, sizeof(uintptr_t),
                                          NULL);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    if (sc->complete_values) {
        code = ngx_stream_script_add_code(*sc->values, sizeof(uintptr_t),
                                          &sc->main);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintpt...",563.0,606.0,1.0,1.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
86,258172,ngx_http_next_body_filter,2,http\ngx_http_copy_filter_module.c.ngx_http_next_body_filter,,http\ngx_http_copy_filter_module.c,ngx_http_output_body_filter_pt ngx_http_next_body_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
87,41086,ngx_resolver_create,1,ngx_resolver_create,"ngx_resolver_t ngx_resolver_create (ngx_conf_t*,ngx_str_t*,ngx_uint_t)",core\ngx_resolver.c,"ngx_resolver_t *
ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)
{
    ngx_str_t                   s;
    ngx_url_t                   u;
    ngx_uint_t                  i, j;
    ngx_resolver_t             *r;
    ngx_pool_cleanup_t         *cln;
    ngx_resolver_connection_t  *rec;

    r = ngx_pcalloc(cf->pool, sizeof(ngx_resolver_t));
    if (r == NULL) {
        return NULL;
    }

    r->event = ngx_pcalloc(cf->pool, sizeof(ngx_event_t));
    if (r->event == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_resolver_cleanup;
    cln->data = r;

    ngx_rbtree_init(&r->name_rbtree, &r->name_sentinel,
                    ngx_resolver_rbtree_insert_value);

    ngx_rbtree_init(&r->srv_rbtree, &r->srv_sentinel,
                    ngx_resolver_rbtree_insert_value);

    ngx_rbtree_init(&r->addr_rbtree, &r->addr_sentinel,
                    ngx_rbtree_insert_...",134.0,284.0,1.0,1.0,151.0,152,15,125,22,0,23,15,23,4,10,,0,20,6,3,3,ngx_resolver_t
88,393342,smtp_unavailable,2,mail\ngx_mail_smtp_handler.c.smtp_unavailable,,mail\ngx_mail_smtp_handler.c,ngx_str_t smtp_unavailable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
89,258173,ngx_http_copy_filter,1,ngx_http_copy_filter,"ngx_int_t ngx_http_copy_filter (ngx_http_request_t*,ngx_chain_t*)",http\ngx_http_copy_filter_module.c,"static ngx_int_t
ngx_http_copy_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                     rc;
    ngx_connection_t             *c;
    ngx_output_chain_ctx_t       *ctx;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_copy_filter_conf_t  *conf;

    c = r->connection;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http copy filter: \""%V?%V\"""", &r->uri, &r->args);

    ctx = ngx_http_get_module_ctx(r, ngx_http_copy_filter_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_output_chain_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_copy_filter_module);

        conf = ngx_http_get_module_loc_conf(r, ngx_http_copy_filter_module);
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        ctx->sendfile = c->sendfile;
        ctx->need_in_memory = r->main_filter_need_in_memory
                              || r->filte...",86.0,165.0,1.0,1.0,80.0,59,10,63,16,0,8,5,7,0,2,,0,8,4,2,2,ngx_int_t
90,65968,value,3,ngx_keyval_t.value,,core\ngx_string.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
91,446592,ngx_stream_script_add_copy_code,1,ngx_stream_script_add_copy_code,"ngx_int_t ngx_stream_script_add_copy_code (ngx_stream_script_compile_t*,ngx_str_t*,ngx_uint_t)",stream\ngx_stream_script.c,"static ngx_int_t
ngx_stream_script_add_copy_code(ngx_stream_script_compile_t *sc,
    ngx_str_t *value, ngx_uint_t last)
{
    u_char                         *p;
    size_t                          size, len, zero;
    ngx_stream_script_copy_code_t  *code;

    zero = (sc->zero && last);
    len = value->len + zero;

    code = ngx_stream_script_add_code(*sc->lengths,
                                      sizeof(ngx_stream_script_copy_code_t),
                                      NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_stream_script_code_pt) (void *)
                                               ngx_stream_script_copy_len_code;
    code->len = len;

    size = (sizeof(ngx_stream_script_copy_code_t) + len + sizeof(uintptr_t) - 1)
            & ~(sizeof(uintptr_t) - 1);

    code = ngx_stream_script_add_code(*sc->values, size, &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_stream_script_copy_cod...",633.0,675.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
92,401539,ngx_open_dir,1,ngx_open_dir,"ngx_int_t ngx_open_dir (ngx_str_t*,ngx_dir_t*)",os\win32\ngx_files.c,"ngx_int_t
ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)
{
    u_char     *pattern, *p;
    ngx_err_t   err;

    pattern = malloc(name->len + 3);
    if (pattern == NULL) {
        return NGX_ERROR;
    }

    p = ngx_cpymem(pattern, name->data, name->len);

    *p++ = '/';
    *p++ = '*';
    *p = '\0';

    dir->dir = FindFirstFile((const char *) pattern, &dir->finddata);

    if (dir->dir == INVALID_HANDLE_VALUE) {
        err = ngx_errno;
        ngx_free(pattern);
        ngx_set_errno(err);
        return NGX_ERROR;
    }

    ngx_free(pattern);

    dir->valid_info = 1;
    dir->ready = 1;

    return NGX_OK;
}",427.0,459.0,1.0,1.0,33.0,8,4,7,5,3,4,2,2,1,0,,0,4,4,2,2,ngx_int_t
93,24707,ngx_log_open_default,1,ngx_log_open_default,ngx_int_t ngx_log_open_default (ngx_cycle_t*),core\ngx_log.c,"ngx_int_t
ngx_log_open_default(ngx_cycle_t *cycle)
{
    ngx_log_t         *log;
    static ngx_str_t   error_log = ngx_string(NGX_ERROR_LOG_PATH);

    if (ngx_log_get_file_log(&cycle->new_log) != NULL) {
        return NGX_OK;
    }

    if (cycle->new_log.log_level != 0) {
        /* there are some error logs, but no files */

        log = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t));
        if (log == NULL) {
            return NGX_ERROR;
        }

    } else {
        /* no error logs at all */
        log = &cycle->new_log;
    }

    log->log_level = NGX_LOG_ERR;

    log->file = ngx_conf_open_file(cycle, &error_log);
    if (log->file == NULL) {
        return NGX_ERROR;
    }

    if (log != &cycle->new_log) {
        ngx_log_insert(&cycle->new_log, log);
    }

    return NGX_OK;
}",403.0,438.0,1.0,1.0,36.0,23,7,25,9,1,4,6,7,1,4,,0,3,2,1,1,ngx_int_t
94,446599,ngx_stream_script_add_var_code,1,ngx_stream_script_add_var_code,"ngx_int_t ngx_stream_script_add_var_code (ngx_stream_script_compile_t*,ngx_str_t*)",stream\ngx_stream_script.c,"static ngx_int_t
ngx_stream_script_add_var_code(ngx_stream_script_compile_t *sc, ngx_str_t *name)
{
    ngx_int_t                      index, *p;
    ngx_stream_script_var_code_t  *code;

    index = ngx_stream_get_variable_index(sc->cf, name);

    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (sc->flushes) {
        p = ngx_array_push(*sc->flushes);
        if (p == NULL) {
            return NGX_ERROR;
        }

        *p = index;
    }

    code = ngx_stream_script_add_code(*sc->lengths,
                                      sizeof(ngx_stream_script_var_code_t),
                                      NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_stream_script_code_pt) (void *)
                                           ngx_stream_script_copy_var_len_code;
    code->index = (uintptr_t) index;

    code = ngx_stream_script_add_code(*sc->values,
                                      sizeof(ngx_stream_script_var_code_t),
 ...",714.0,757.0,1.0,1.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
95,393352,ngx_mail_smtp_init_session,1,ngx_mail_smtp_init_session,"void ngx_mail_smtp_init_session (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_smtp_handler.c,"void
ngx_mail_smtp_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_resolver_ctx_t        *ctx;
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    if (cscf->resolver == NULL) {
        s->host = smtp_unavailable;
        ngx_mail_smtp_greeting(s, c);
        return;
    }

#if (NGX_HAVE_UNIX_DOMAIN)
    if (c->sockaddr->sa_family == AF_UNIX) {
        s->host = smtp_tempunavail;
        ngx_mail_smtp_greeting(s, c);
        return;
    }
#endif

    c->log->action = ""in resolving client address"";

    ctx = ngx_resolve_start(cscf->resolver, NULL);
    if (ctx == NULL) {
        ngx_mail_close_connection(c);
        return;
    }

    ctx->addr.sockaddr = c->sockaddr;
    ctx->addr.socklen = c->socklen;
    ctx->handler = ngx_mail_smtp_resolve_addr_handler;
    ctx->data = s;
    ctx->timeout = cscf->resolver_timeout;

    s->resolver_ctx = ctx;
    c->read->handler = ngx_mail_smtp_block_reading;

    if (ngx...",56.0,98.0,1.0,1.0,43.0,32,5,32,9,0,11,4,4,2,5,,0,8,4,2,2,void
96,106632,ngx_http_charset_recode_to_utf8,1,ngx_http_charset_recode_to_utf8,"ngx_chain_t* ngx_http_charset_recode_to_utf8 (ngx_pool_t*,ngx_buf_t*,ngx_http_charset_ctx_t*)",http\modules\ngx_http_charset_filter_module.c,"static ngx_chain_t *
ngx_http_charset_recode_to_utf8(ngx_pool_t *pool, ngx_buf_t *buf,
    ngx_http_charset_ctx_t *ctx)
{
    size_t        len, size;
    u_char       *p, *src, *dst, *table;
    ngx_buf_t    *b;
    ngx_chain_t  *out, *cl, **ll;

    table = ctx->table;

    for (src = buf->pos; src < buf->last; src++) {
        if (table[*src * NGX_UTF_LEN] == '\1') {
            continue;
        }

        goto recode;
    }

    out = ngx_alloc_chain_link(pool);
    if (out == NULL) {
        return NULL;
    }

    out->buf = buf;
    out->next = NULL;

    return out;

recode:

    /*
     * we assume that there are about half of characters to be recoded,
     * so we preallocate ""size / 2 + size / 2 * ctx->length""
     */

    len = src - buf->pos;

    if (len > 512) {
        out = ngx_http_charset_get_buf(pool, ctx);
        if (out == NULL) {
            return NULL;
        }

        b = out->buf;

        b->temporary = buf->temporary;
        b->memory = buf->memory;...",965.0,1089.0,1.0,25.0,125.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_chain_t
97,217225,ngx_http_ssi_output,1,ngx_http_ssi_output,"ngx_int_t ngx_http_ssi_output (ngx_http_request_t*,ngx_http_ssi_ctx_t*)",http\modules\ngx_http_ssi_filter_module.c,"static ngx_int_t
ngx_http_ssi_output(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

#if 1
    b = NULL;
    for (cl = ctx->out; cl; cl = cl->next) {
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""ssi out: %p %p"", cl->buf, cl->buf->pos);
        if (cl->buf == b) {
            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                          ""the same buf was used in ssi"");
            ngx_debug_point();
            return NGX_ERROR;
        }
        b = cl->buf;
    }
#endif

    rc = ngx_http_next_body_filter(r, ctx->out);

    if (ctx->busy == NULL) {
        ctx->busy = ctx->out;

    } else {
        for (cl = ctx->busy; cl->next; cl = cl->next) { /* void */ }
        cl->next = ctx->out;
    }

    ctx->out = NULL;
    ctx->last_out = &ctx->out;

    while (ctx->busy) {

        cl = ctx->busy;
        b = cl->buf;

        if (ngx_buf_size(b) != 0) {
   ...",914.0,975.0,1.0,1.0,62.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
98,90252,ngx_ssl_session_cache_init,1,ngx_ssl_session_cache_init,"ngx_int_t ngx_ssl_session_cache_init (ngx_shm_zone_t*,void*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)
{
    size_t                    len;
    ngx_slab_pool_t          *shpool;
    ngx_ssl_session_cache_t  *cache;

    if (data) {
        shm_zone->data = data;
        return NGX_OK;
    }

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
        shm_zone->data = shpool->data;
        return NGX_OK;
    }

    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_session_cache_t));
    if (cache == NULL) {
        return NGX_ERROR;
    }

    shpool->data = cache;
    shm_zone->data = cache;

    ngx_rbtree_init(&cache->session_rbtree, &cache->sentinel,
                    ngx_ssl_session_rbtree_insert_value);

    ngx_queue_init(&cache->expire_queue);

    len = sizeof("" in SSL session shared cache \""\"""") + shm_zone->shm.name.len;

    shpool->log_ctx = ngx_slab_alloc(shpool, len);
    if (shpool->log_ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_sprintf(shpool->log_ctx...",3310.0,3355.0,1.0,1.0,46.0,40,8,35,9,0,12,5,5,1,3,,0,11,4,2,2,ngx_int_t
99,65971,len,3,ngx_variable_value_t.len,,core\ngx_string.h,len:28,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
100,217231,ngx_http_ssi_buffered,1,ngx_http_ssi_buffered,"void ngx_http_ssi_buffered (ngx_http_request_t*,ngx_http_ssi_ctx_t*)",http\modules\ngx_http_ssi_filter_module.c,"static void
ngx_http_ssi_buffered(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    if (ctx->in || ctx->buf) {
        r->buffered |= NGX_HTTP_SSI_BUFFERED;

    } else {
        r->buffered &= ~NGX_HTTP_SSI_BUFFERED;
    }
}",978.0,987.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
101,204945,ngx_http_referer_module,2,http\modules\ngx_http_referer_module.c.ngx_http_referer_module,,http\modules\ngx_http_referer_module.c,ngx_module_t ngx_http_referer_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
102,217237,ngx_http_ssi_parse,1,ngx_http_ssi_parse,"ngx_int_t ngx_http_ssi_parse (ngx_http_request_t*,ngx_http_ssi_ctx_t*)",http\modules\ngx_http_ssi_filter_module.c,"static ngx_int_t
ngx_http_ssi_parse(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    u_char                *p, *value, *last, *copy_end, ch;
    size_t                 looked;
    ngx_http_ssi_state_e   state;

    state = ctx->state;
    looked = ctx->looked;
    last = ctx->buf->last;
    copy_end = ctx->copy_end;

    for (p = ctx->pos; p < last; p++) {

        ch = *p;

        if (state == ssi_start_state) {

            /* the tight loop */

            for ( ;; ) {
                if (ch == '<') {
                    copy_end = p;
                    looked = 1;
                    state = ssi_tag_state;

                    goto tag_started;
                }

                if (++p == last) {
                    break;
                }

                ch = *p;
            }

            ctx->state = state;
            ctx->pos = p;
            ctx->looked = looked;
            ctx->copy_end = p;

            if (ctx->copy_start == NULL) {
                ctx->copy_...",990.0,1552.0,1.0,23.0,563.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
103,40737,options,3,ngx_regex_compile_t.options,,core\ngx_regex.h,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
104,200865,offset,3,ngx_http_range_filter_ctx_t.offset,,http\modules\ngx_http_range_filter_module.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
105,446626,ngx_stream_script_flush_complex_value,1,ngx_stream_script_flush_complex_value,"void ngx_stream_script_flush_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*)",stream\ngx_stream_script.c,"void
ngx_stream_script_flush_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val)
{
    ngx_uint_t *index;

    index = val->flushes;

    if (index) {
        while (*index != (ngx_uint_t) -1) {

            if (s->variables[*index].no_cacheable) {
                s->variables[*index].valid = 0;
                s->variables[*index].not_found = 0;
            }

            index++;
        }
    }
}",36.0,55.0,1.0,1.0,20.0,20,8,12,4,1,1,4,7,0,0,,0,1,4,2,2,void
106,401571,ngx_read_dir,1,ngx_read_dir,ngx_int_t ngx_read_dir (ngx_dir_t*),os\win32\ngx_files.c,"ngx_int_t
ngx_read_dir(ngx_dir_t *dir)
{
    if (dir->ready) {
        dir->ready = 0;
        return NGX_OK;
    }

    if (FindNextFile(dir->dir, &dir->finddata) != 0) {
        dir->type = 1;
        return NGX_OK;
    }

    return NGX_ERROR;
}",462.0,476.0,1.0,1.0,15.0,6,2,6,3,3,4,2,2,1,0,,0,4,2,1,1,ngx_int_t
107,200867,ranges,3,ngx_http_range_filter_ctx_t.ranges,,http\modules\ngx_http_range_filter_module.c,ranges,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
108,200868,ngx_http_range_filter_ctx_t,2,http\modules\ngx_http_range_filter_module.c.ngx_http_range_filter_ctx_t,,http\modules\ngx_http_range_filter_module.c,struct ngx_http_range_filter_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
109,200869,ngx_http_range_parse,1,ngx_http_range_parse,"ngx_int_t ngx_http_range_parse (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_uint_t)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
    ngx_uint_t ranges)
{
    u_char                       *p;
    off_t                         start, end, size, content_length, cutoff,
                                  cutlim;
    ngx_uint_t                    suffix;
    ngx_http_range_t             *range;
    ngx_http_range_filter_ctx_t  *mctx;

    if (r != r->main) {
        mctx = ngx_http_get_module_ctx(r->main,
                                       ngx_http_range_body_filter_module);
        if (mctx) {
            ctx->ranges = mctx->ranges;
            return NGX_OK;
        }
    }

    if (ngx_array_init(&ctx->ranges, r->pool, 1, sizeof(ngx_http_range_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    p = r->headers_in.range->value.data + 6;
    size = 0;
    content_length = r->headers_out.content_length_n;

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    for ( ;; ) {
    ...",268.0,408.0,1.0,1.0,141.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
110,204967,ngx_http_referer_variable,1,ngx_http_referer_variable,"ngx_int_t ngx_http_referer_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_referer_module.c,"static ngx_int_t
ngx_http_referer_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char                    *p, *ref, *last;
    size_t                     len;
    ngx_str_t                 *uri;
    ngx_uint_t                 i, key;
    ngx_http_referer_conf_t   *rlcf;
    u_char                     buf[256];
#if (NGX_PCRE)
    ngx_int_t                  rc;
    ngx_str_t                  referer;
#endif

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_referer_module);

    if (rlcf->hash.hash.buckets == NULL
        && rlcf->hash.wc_head == NULL
        && rlcf->hash.wc_tail == NULL
#if (NGX_PCRE)
        && rlcf->regex == NULL
        && rlcf->server_name_regex == NULL
#endif
       )
    {
        goto valid;
    }

    if (r->headers_in.referer == NULL) {
        if (rlcf->no_referer) {
            goto valid;
        }

        goto invalid;
    }

    len = r->headers_in.referer->value.len;
    ref = r->headers_in.referer->value.d...",114.0,267.0,1.0,15.0,154.0,74,19,65,16,0,12,27,20,9,2,,0,12,6,3,3,ngx_int_t
111,299174,ngx_http_set_predicate_slot,1,ngx_http_set_predicate_slot,"char* ngx_http_set_predicate_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http_script.c,"char *
ngx_http_set_predicate_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t                          *value;
    ngx_uint_t                          i;
    ngx_array_t                       **a;
    ngx_http_complex_value_t           *cv;
    ngx_http_compile_complex_value_t    ccv;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NGX_CONF_UNSET_PTR) {
        *a = ngx_array_create(cf->pool, 1, sizeof(ngx_http_complex_value_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        cv = ngx_array_push(*a);
        if (cv == NULL) {
            return NGX_CONF_ERROR;
        }

        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

        ccv.cf = cf;
        ccv.value = &value[i];
        ccv.complex_value = cv;

        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
            return NGX_CONF_ERROR;
...",363.0,403.0,1.0,1.0,41.0,35,12,36,16,0,6,6,9,1,3,,0,6,6,3,3,char*
112,40738,regex,3,ngx_regex_compile_t.regex,,core\ngx_regex.h,*regex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
113,200876,ngx_http_range_singlepart_header,1,ngx_http_range_singlepart_header,"ngx_int_t ngx_http_range_singlepart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_singlepart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx)
{
    ngx_table_elt_t   *content_range;
    ngx_http_range_t  *range;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    content_range = ngx_list_push(&r->headers_out.headers);
    if (content_range == NULL) {
        return NGX_ERROR;
    }

    r->headers_out.content_range = content_range;

    content_range->hash = 1;
    ngx_str_set(&content_range->key, ""Content-Range"");

    content_range->value.data = ngx_pnalloc(r->pool,
                                    sizeof(""bytes -/"") - 1 + 3 * NGX_OFF_T_LEN);
    if (content_range->value.data == NULL) {
        content_range->hash = 0;
        r->headers_out.content_range = NULL;
        return NGX_ERROR;
    }

    /* ""Content-Range: bytes SSSS-EEEE/TTTT"" header */

    range = ctx->ranges.elts;

    content_range->value.len = ngx_sprintf(content_range->value.data,
                            ...",411.0,459.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
114,200882,ngx_http_range_multipart_header,1,ngx_http_range_multipart_header,"ngx_int_t ngx_http_range_multipart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_multipart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx)
{
    off_t               len;
    size_t              size;
    ngx_uint_t          i;
    ngx_http_range_t   *range;
    ngx_atomic_uint_t   boundary;

    size = sizeof(CRLF ""--"") - 1 + NGX_ATOMIC_T_LEN
           + sizeof(CRLF ""Content-Type: "") - 1
           + r->headers_out.content_type.len
           + sizeof(CRLF ""Content-Range: bytes "") - 1;

    if (r->headers_out.content_type_len == r->headers_out.content_type.len
        && r->headers_out.charset.len)
    {
        size += sizeof(""; charset="") - 1 + r->headers_out.charset.len;
    }

    ctx->boundary_header.data = ngx_pnalloc(r->pool, size);
    if (ctx->boundary_header.data == NULL) {
        return NGX_ERROR;
    }

    boundary = ngx_next_temp_number(0);

    /*
     * The boundary header of the range:
     * CRLF
     * ""--0123456789"" CRLF
     * ""Content-Type: image/jpeg"" CRLF
     * ""Content-Range: bytes ""...",462.0,584.0,1.0,1.0,123.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
115,20661,ngx_hash_add_key,1,ngx_hash_add_key,"ngx_int_t ngx_hash_add_key (ngx_hash_keys_arrays_t*,ngx_str_t*,void*,ngx_uint_t)",core\ngx_hash.c,"ngx_int_t
ngx_hash_add_key(ngx_hash_keys_arrays_t *ha, ngx_str_t *key, void *value,
    ngx_uint_t flags)
{
    size_t           len;
    u_char          *p;
    ngx_str_t       *name;
    ngx_uint_t       i, k, n, skip, last;
    ngx_array_t     *keys, *hwc;
    ngx_hash_key_t  *hk;

    last = key->len;

    if (flags & NGX_HASH_WILDCARD_KEY) {

        /*
         * supported wildcards:
         *     ""*.example.com"", "".example.com"", and ""www.example.*""
         */

        n = 0;

        for (i = 0; i < key->len; i++) {

            if (key->data[i] == '*') {
                if (++n > 1) {
                    return NGX_DECLINED;
                }
            }

            if (key->data[i] == '.' && key->data[i + 1] == '.') {
                return NGX_DECLINED;
            }

            if (key->data[i] == '\0') {
                return NGX_DECLINED;
            }
        }

        if (key->len > 1 && key->data[0] == '.') {
            skip = 1;
            goto wildcard;
 ...",733.0,1009.0,1.0,1.0,277.0,230,19,222,22,2,72,46,83,21,10,,0,72,8,4,4,ngx_int_t
116,200888,ngx_http_range_not_satisfiable,1,ngx_http_range_not_satisfiable,ngx_int_t ngx_http_range_not_satisfiable (ngx_http_request_t*),http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_not_satisfiable(ngx_http_request_t *r)
{
    ngx_table_elt_t  *content_range;

    r->headers_out.status = NGX_HTTP_RANGE_NOT_SATISFIABLE;

    content_range = ngx_list_push(&r->headers_out.headers);
    if (content_range == NULL) {
        return NGX_ERROR;
    }

    r->headers_out.content_range = content_range;

    content_range->hash = 1;
    ngx_str_set(&content_range->key, ""Content-Range"");

    content_range->value.data = ngx_pnalloc(r->pool,
                                       sizeof(""bytes */"") - 1 + NGX_OFF_T_LEN);
    if (content_range->value.data == NULL) {
        content_range->hash = 0;
        r->headers_out.content_range = NULL;
        return NGX_ERROR;
    }

    content_range->value.len = ngx_sprintf(content_range->value.data,
                                           ""bytes */%O"",
                                           r->headers_out.content_length_n)
                               - content_range->value.data;

    ngx_ht...",587.0,620.0,1.0,1.0,34.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
117,70050,sec,3,ngx_time_t.sec,,core\ngx_times.h,sec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
118,200893,ngx_http_range_test_overlapped,1,ngx_http_range_test_overlapped,"ngx_int_t ngx_http_range_test_overlapped (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_test_overlapped(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    off_t              start, last;
    ngx_buf_t         *buf;
    ngx_uint_t         i;
    ngx_http_range_t  *range;

    if (ctx->offset) {
        goto overlapped;
    }

    buf = in->buf;

    if (!buf->last_buf) {
        start = ctx->offset;
        last = ctx->offset + ngx_buf_size(buf);

        range = ctx->ranges.elts;
        for (i = 0; i < ctx->ranges.nelts; i++) {
            if (start > range[i].start || last < range[i].end) {
                goto overlapped;
            }
        }
    }

    ctx->offset = ngx_buf_size(buf);

    return NGX_OK;

overlapped:

    ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                  ""range in overlapped buffers"");

    return NGX_ERROR;
}",658.0,695.0,1.0,1.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
119,401598,ngx_open_glob,1,ngx_open_glob,ngx_int_t ngx_open_glob (ngx_glob_t*),os\win32\ngx_files.c,"ngx_int_t
ngx_open_glob(ngx_glob_t *gl)
{
    u_char     *p;
    size_t      len;
    ngx_err_t   err;

    gl->dir = FindFirstFile((const char *) gl->pattern, &gl->finddata);

    if (gl->dir == INVALID_HANDLE_VALUE) {

        err = ngx_errno;

        if ((err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)
             && gl->test)
        {
            gl->no_match = 1;
            return NGX_OK;
        }

        return NGX_ERROR;
    }

    for (p = gl->pattern; *p; p++) {
        if (*p == '/') {
            gl->last = p + 1 - gl->pattern;
        }
    }

    len = ngx_strlen(gl->finddata.cFileName);
    gl->name.len = gl->last + len;

    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);
    if (gl->name.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(gl->name.data, gl->pattern, gl->last);
    ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,
                len + 1);

    gl->ready = 1;

    return NGX_OK;
}",490.0,534.0,1.0,1.0,45.0,6,5,7,5,1,2,2,2,0,0,,0,2,2,1,1,ngx_int_t
120,70051,msec,3,ngx_time_t.msec,,core\ngx_times.h,msec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
121,70052,gmtoff,3,ngx_time_t.gmtoff,,core\ngx_times.h,gmtoff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
122,200900,ngx_http_range_singlepart_body,1,ngx_http_range_singlepart_body,"ngx_int_t ngx_http_range_singlepart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_singlepart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    off_t              start, last;
    ngx_int_t          rc;
    ngx_buf_t         *buf;
    ngx_chain_t       *out, *cl, *tl, **ll;
    ngx_http_range_t  *range;

    out = NULL;
    ll = &out;
    range = ctx->ranges.elts;

    for (cl = in; cl; cl = cl->next) {

        buf = cl->buf;

        start = ctx->offset;
        last = ctx->offset + ngx_buf_size(buf);

        ctx->offset = last;

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http range body buf: %O-%O"", start, last);

        if (ngx_buf_special(buf)) {

            if (range->end <= start) {
                continue;
            }

            tl = ngx_alloc_chain_link(r->pool);
            if (tl == NULL) {
                return NGX_ERROR;
            }

            tl->buf = buf;
            tl->next = NULL;

            *ll = tl;
            l...",698.0,818.0,1.0,1.0,121.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
123,262341,ngx_http_send_response,1,ngx_http_send_response,"ngx_int_t ngx_http_send_response (ngx_http_request_t*,ngx_uint_t,ngx_str_t*,ngx_http_complex_value_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,
    ngx_str_t *ct, ngx_http_complex_value_t *cv)
{
    ngx_int_t     rc;
    ngx_str_t     val;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    r->headers_out.status = status;

    if (ngx_http_complex_value(r, cv, &val) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (status == NGX_HTTP_MOVED_PERMANENTLY
        || status == NGX_HTTP_MOVED_TEMPORARILY
        || status == NGX_HTTP_SEE_OTHER
        || status == NGX_HTTP_TEMPORARY_REDIRECT
        || status == NGX_HTTP_PERMANENT_REDIRECT)
    {
        ngx_http_clear_location(r);

        r->headers_out.location = ngx_list_push(&r->headers_out.headers);
        if (r->headers_out.location == NULL) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        r->headers_out.location->hash = 1;
        ngx_str_set(&r->headers_out.lo...",1732.0,1810.0,1.0,1.0,79.0,90,12,76,18,2,13,9,10,2,6,,0,11,8,4,4,ngx_int_t
124,65736,ngx_str_rbtree_lookup,1,ngx_str_rbtree_lookup,"ngx_str_node_t ngx_str_rbtree_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)",core\ngx_string.c,"ngx_str_node_t *
ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree, ngx_str_t *val, uint32_t hash)
{
    ngx_int_t           rc;
    ngx_str_node_t     *n;
    ngx_rbtree_node_t  *node, *sentinel;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        n = (ngx_str_node_t *) node;

        if (hash != node->key) {
            node = (hash < node->key) ? node->left : node->right;
            continue;
        }

        if (val->len != n->str.len) {
            node = (val->len < n->str.len) ? node->left : node->right;
            continue;
        }

        rc = ngx_memcmp(val->data, n->str.data, val->len);

        if (rc < 0) {
            node = node->left;
            continue;
        }

        if (rc > 0) {
            node = node->right;
            continue;
        }

        return n;
    }

    return NULL;
}",1940.0,1980.0,1.0,1.0,41.0,38,8,34,8,0,7,10,10,2,0,,0,7,6,3,3,ngx_str_node_t
125,200907,ngx_http_range_multipart_body,1,ngx_http_range_multipart_body,"ngx_int_t ngx_http_range_multipart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_multipart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    ngx_buf_t         *b, *buf;
    ngx_uint_t         i;
    ngx_chain_t       *out, *hcl, *rcl, *dcl, **ll;
    ngx_http_range_t  *range;

    ll = &out;
    buf = in->buf;
    range = ctx->ranges.elts;

    for (i = 0; i < ctx->ranges.nelts; i++) {

        /*
         * The boundary header of the range:
         * CRLF
         * ""--0123456789"" CRLF
         * ""Content-Type: image/jpeg"" CRLF
         * ""Content-Range: bytes ""
         */

        b = ngx_calloc_buf(r->pool);
        if (b == NULL) {
            return NGX_ERROR;
        }

        b->memory = 1;
        b->pos = ctx->boundary_header.data;
        b->last = ctx->boundary_header.data + ctx->boundary_header.len;

        hcl = ngx_alloc_chain_link(r->pool);
        if (hcl == NULL) {
            return NGX_ERROR;
        }

        hcl->buf = b;


        /* ""SSSS-EEEE/TTTT"" CRLF CRLF */

 ...",821.0,948.0,1.0,1.0,128.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
126,446681,ngx_stream_complex_value,1,ngx_stream_complex_value,"ngx_int_t ngx_stream_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*,ngx_str_t*)",stream\ngx_stream_script.c,"ngx_int_t
ngx_stream_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, ngx_str_t *value)
{
    size_t                         len;
    ngx_stream_script_code_pt      code;
    ngx_stream_script_engine_t     e;
    ngx_stream_script_len_code_pt  lcode;

    if (val->lengths == NULL) {
        *value = val->value;
        return NGX_OK;
    }

    ngx_stream_script_flush_complex_value(s, val);

    ngx_memzero(&e, sizeof(ngx_stream_script_engine_t));

    e.ip = val->lengths;
    e.session = s;
    e.flushed = 1;

    len = 0;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_stream_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }

    value->len = len;
    value->data = ngx_pnalloc(s->connection->pool, len);
    if (value->data == NULL) {
        return NGX_ERROR;
    }

    e.ip = val->values;
    e.pos = value->data;
    e.buf = *value;

    while (*(uintptr_t *) e.ip) {
        code = *(ngx_stream_script_code_pt *) e.ip;
        code((ng...",58.0,105.0,1.0,1.0,48.0,53,9,41,11,6,21,5,5,4,2,,0,20,6,3,3,ngx_int_t
127,401627,ngx_read_glob,1,ngx_read_glob,"ngx_int_t ngx_read_glob (ngx_glob_t*,ngx_str_t*)",os\win32\ngx_files.c,"ngx_int_t
ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)
{
    size_t     len;
    ngx_err_t  err;

    if (gl->no_match) {
        return NGX_DONE;
    }

    if (gl->ready) {
        *name = gl->name;

        gl->ready = 0;
        return NGX_OK;
    }

    ngx_free(gl->name.data);
    gl->name.data = NULL;

    if (FindNextFile(gl->dir, &gl->finddata) != 0) {

        len = ngx_strlen(gl->finddata.cFileName);
        gl->name.len = gl->last + len;

        gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);
        if (gl->name.data == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(gl->name.data, gl->pattern, gl->last);
        ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,
                    len + 1);

        *name = gl->name;

        return NGX_OK;
    }

    err = ngx_errno;

    if (err == NGX_ENOMOREFILES) {
        return NGX_DONE;
    }

    ngx_log_error(NGX_LOG_ALERT, gl->log, err,
                  ""FindNextFile(%s) f...",537.0,586.0,1.0,1.0,50.0,22,7,13,5,1,9,2,2,1,0,,0,9,4,2,2,ngx_int_t
128,24799,ngx_log_redirect_stderr,1,ngx_log_redirect_stderr,ngx_int_t ngx_log_redirect_stderr (ngx_cycle_t*),core\ngx_log.c,"ngx_int_t
ngx_log_redirect_stderr(ngx_cycle_t *cycle)
{
    ngx_fd_t  fd;

    if (cycle->log_use_stderr) {
        return NGX_OK;
    }

    /* file log always exists when we are called */
    fd = ngx_log_get_file_log(cycle->log)->file->fd;

    if (fd != ngx_stderr) {
        if (ngx_set_stderr(fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ngx_set_stderr_n "" failed"");

            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",441.0,463.0,1.0,1.0,23.0,7,4,10,6,3,1,4,5,0,1,,0,1,2,1,1,ngx_int_t
129,4319,num,3,ngx_bufs_t.num,,core\ngx_buf.h,num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
130,4320,size,3,ngx_bufs_t.size,,core\ngx_buf.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
131,237794,ngx_http_upstream_init_least_conn,1,ngx_http_upstream_init_least_conn,"ngx_int_t ngx_http_upstream_init_least_conn (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)",http\modules\ngx_http_upstream_least_conn_module.c,"static ngx_int_t
ngx_http_upstream_init_least_conn(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
                   ""init least conn"");

    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_least_conn_peer;

    return NGX_OK;
}",65.0,79.0,1.0,1.0,15.0,5,4,9,6,0,1,2,2,1,1,,0,1,4,2,2,ngx_int_t
132,188658,ngx_http_test_if_unmodified,1,ngx_http_test_if_unmodified,ngx_uint_t ngx_http_test_if_unmodified (ngx_http_request_t*),http\modules\ngx_http_not_modified_filter_module.c,"static ngx_uint_t
ngx_http_test_if_unmodified(ngx_http_request_t *r)
{
    time_t  iums;

    if (r->headers_out.last_modified_time == (time_t) -1) {
        return 0;
    }

    iums = ngx_parse_http_time(r->headers_in.if_unmodified_since->value.data,
                               r->headers_in.if_unmodified_since->value.len);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                 ""http iums:%T lm:%T"", iums, r->headers_out.last_modified_time);

    if (iums >= r->headers_out.last_modified_time) {
        return 1;
    }

    return 0;
}",112.0,132.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_uint_t
133,188663,ngx_http_test_if_modified,1,ngx_http_test_if_modified,ngx_uint_t ngx_http_test_if_modified (ngx_http_request_t*),http\modules\ngx_http_not_modified_filter_module.c,"static ngx_uint_t
ngx_http_test_if_modified(ngx_http_request_t *r)
{
    time_t                     ims;
    ngx_http_core_loc_conf_t  *clcf;

    if (r->headers_out.last_modified_time == (time_t) -1) {
        return 1;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->if_modified_since == NGX_HTTP_IMS_OFF) {
        return 1;
    }

    ims = ngx_parse_http_time(r->headers_in.if_modified_since->value.data,
                              r->headers_in.if_modified_since->value.len);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http ims:%T lm:%T"", ims, r->headers_out.last_modified_time);

    if (ims == r->headers_out.last_modified_time) {
        return 0;
    }

    if (clcf->if_modified_since == NGX_HTTP_IMS_EXACT
        || ims < r->headers_out.last_modified_time)
    {
        return 1;
    }

    return 0;
}",135.0,168.0,1.0,1.0,34.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_uint_t
134,188668,ngx_http_test_if_match,1,ngx_http_test_if_match,"ngx_uint_t ngx_http_test_if_match (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)",http\modules\ngx_http_not_modified_filter_module.c,"static ngx_uint_t
ngx_http_test_if_match(ngx_http_request_t *r, ngx_table_elt_t *header,
    ngx_uint_t weak)
{
    u_char     *start, *end, ch;
    ngx_str_t   etag, *list;

    list = &header->value;

    if (list->len == 1 && list->data[0] == '*') {
        return 1;
    }

    if (r->headers_out.etag == NULL) {
        return 0;
    }

    etag = r->headers_out.etag->value;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http im:\""%V\"" etag:%V"", list, &etag);

    if (weak
        && etag.len > 2
        && etag.data[0] == 'W'
        && etag.data[1] == '/')
    {
        etag.len -= 2;
        etag.data += 2;
    }

    start = list->data;
    end = list->data + list->len;

    while (start < end) {

        if (weak
            && end - start > 2
            && start[0] == 'W'
            && start[1] == '/')
        {
            start += 2;
        }

        if (etag.len > (size_t) (end - start)) {
            return 0;
        }

        i...",171.0,256.0,1.0,1.0,86.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_uint_t
135,200965,ngx_http_range_body_filter_module,2,http\modules\ngx_http_range_filter_module.c.ngx_http_range_body_filter_module,,http\modules\ngx_http_range_filter_module.c,ngx_module_t ngx_http_range_body_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
136,24838,ngx_log_get_file_log,1,ngx_log_get_file_log,ngx_log_t ngx_log_get_file_log (ngx_log_t*),core\ngx_log.c,"ngx_log_t *
ngx_log_get_file_log(ngx_log_t *head)
{
    ngx_log_t  *log;

    for (log = head; log; log = log->next) {
        if (log->file != NULL) {
            return log;
        }
    }

    return NULL;
}",466.0,478.0,1.0,1.0,13.0,3,3,7,3,2,0,3,4,0,0,,0,0,2,1,1,ngx_log_t
137,209164,upstream,3,ngx_http_scgi_loc_conf_t.upstream,,http\modules\ngx_http_scgi_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
138,160015,ngx_http_limit_req_shctx_t,2,http\modules\ngx_http_limit_req_module.c.ngx_http_limit_req_shctx_t,,http\modules\ngx_http_limit_req_module.c,struct ngx_http_limit_req_shctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
139,209168,scgi_lengths,3,ngx_http_scgi_loc_conf_t.scgi_lengths,,http\modules\ngx_http_scgi_module.c,*scgi_lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
140,160017,sh,3,ngx_http_limit_req_ctx_t.sh,,http\modules\ngx_http_limit_req_module.c,*sh,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
141,160018,shpool,3,ngx_http_limit_req_ctx_t.shpool,,http\modules\ngx_http_limit_req_module.c,*shpool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
142,160020,key,3,ngx_http_limit_req_ctx_t.key,,http\modules\ngx_http_limit_req_module.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
143,209172,ngx_http_scgi_eval,1,ngx_http_scgi_eval,"ngx_int_t ngx_http_scgi_eval (ngx_http_request_t*,ngx_http_scgi_loc_conf_t*)",http\modules\ngx_http_scgi_module.c,"static ngx_int_t
ngx_http_scgi_eval(ngx_http_request_t *r, ngx_http_scgi_loc_conf_t * scf)
{
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, scf->scgi_lengths->elts, 0,
                            scf->scgi_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    url.no_resolve = 1;

    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
        if (url.err) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""%s in upstream \""%V\"""", url.err, &url.url);
        }

        return NGX_ERROR;
    }

    u = r->upstream;

    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
    if (u->resolved == NULL) {
        return NGX_ERROR;
    }

    if (url.addrs) {
        u->resolved->sockaddr = url.addrs[0].sockaddr;
        u->resolved->socklen = url.addrs[0].socklen;
        u->resolved->name = url.addrs[0].name;
        ...",554.0,599.0,1.0,1.0,46.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
144,160021,node,3,ngx_http_limit_req_ctx_t.node,,http\modules\ngx_http_limit_req_module.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
145,200984,ngx_http_range_header_filter,1,ngx_http_range_header_filter,ngx_int_t ngx_http_range_header_filter (ngx_http_request_t*),http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_header_filter(ngx_http_request_t *r)
{
    time_t                        if_range_time;
    ngx_str_t                    *if_range, *etag;
    ngx_uint_t                    ranges;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_range_filter_ctx_t  *ctx;

    if (r->http_version < NGX_HTTP_VERSION_10
        || r->headers_out.status != NGX_HTTP_OK
        || (r != r->main && !r->subrequest_ranges)
        || r->headers_out.content_length_n == -1
        || !r->allow_ranges)
    {
        return ngx_http_next_header_filter(r);
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->max_ranges == 0) {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_in.range == NULL
        || r->headers_in.range->value.len < 7
        || ngx_strncasecmp(r->headers_in.range->value.data,
                           (u_char *) ""bytes="", 6)
           != 0)
    {
        goto next_filter;
    }

    if (r->headers...",146.0,265.0,1.0,1.0,120.0,129,17,88,19,0,22,21,22,11,8,,0,19,2,1,1,ngx_int_t
146,401689,ngx_close_glob,1,ngx_close_glob,void ngx_close_glob (ngx_glob_t*),os\win32\ngx_files.c,"void
ngx_close_glob(ngx_glob_t *gl)
{
    if (gl->name.data) {
        ngx_free(gl->name.data);
    }

    if (gl->dir == INVALID_HANDLE_VALUE) {
        return;
    }

    if (FindClose(gl->dir) == 0) {
        ngx_log_error(NGX_LOG_ALERT, gl->log, ngx_errno,
                      ""FindClose(%s) failed"", gl->pattern);
    }
}",589.0,604.0,1.0,1.0,16.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
147,160024,shm_zone,3,ngx_http_limit_req_limit_t.shm_zone,,http\modules\ngx_http_limit_req_module.c,*shm_zone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
148,319771,ngx_http_upstream_get_round_robin_peer,1,ngx_http_upstream_get_round_robin_peer,"ngx_int_t ngx_http_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)",http\ngx_http_upstream_round_robin.c,"ngx_int_t
ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = data;

    ngx_int_t                      rc;
    ngx_uint_t                     i, n;
    ngx_http_upstream_rr_peer_t   *peer;
    ngx_http_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get rr peer, try: %ui"", pc->tries);

    pc->cached = 0;
    pc->connection = NULL;

    peers = rrp->peers;
    ngx_http_upstream_rr_peers_wlock(peers);

    if (peers->single) {
        peer = peers->peer;

        if (peer->down) {
            goto failed;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
            goto failed;
        }

        rrp->current = peer;

    } else {

        /* there are several peers */

        peer = ngx_http_upstream_get_peer(rrp);

        if (peer == NULL) {
            goto failed;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, ...",416.0,504.0,1.0,1.0,89.0,57,14,55,13,0,5,9,11,0,0,,0,5,4,2,2,ngx_int_t
149,299291,ngx_http_script_variables_count,1,ngx_http_script_variables_count,ngx_uint_t ngx_http_script_variables_count (ngx_str_t*),http\ngx_http_script.c,"ngx_uint_t
ngx_http_script_variables_count(ngx_str_t *value)
{
    ngx_uint_t  i, n;

    for (n = 0, i = 0; i < value->len; i++) {
        if (value->data[i] == '$') {
            n++;
        }
    }

    return n;
}",406.0,418.0,1.0,1.0,13.0,9,7,8,3,0,2,3,4,2,0,,0,2,2,1,1,ngx_uint_t
150,160029,limits,3,ngx_http_limit_req_conf_t.limits,,http\modules\ngx_http_limit_req_module.c,limits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
151,160030,limit_log_level,3,ngx_http_limit_req_conf_t.limit_log_level,,http\modules\ngx_http_limit_req_module.c,limit_log_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
152,160031,delay_log_level,3,ngx_http_limit_req_conf_t.delay_log_level,,http\modules\ngx_http_limit_req_module.c,delay_log_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
153,340256,ngx_http_v2_read_unbuffered_request_body,1,ngx_http_v2_read_unbuffered_request_body,ngx_int_t ngx_http_v2_read_unbuffered_request_body (ngx_http_request_t*),http\v2\ngx_http_v2.c,"ngx_int_t
ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)
{
    size_t                     window;
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_connection_t          *fc;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_connection_t  *h2c;
    ngx_http_core_loc_conf_t  *clcf;

    stream = r->stream;
    fc = r->connection;

    if (fc->read->timedout) {
        if (stream->recv_window) {
            stream->skip_data = 1;
            fc->timedout = 1;

            return NGX_HTTP_REQUEST_TIME_OUT;
        }

        fc->read->timedout = 0;
    }

    if (fc->error) {
        stream->skip_data = 1;
        return NGX_HTTP_BAD_REQUEST;
    }

    rc = ngx_http_v2_filter_request_body(r);

    if (rc != NGX_OK) {
        stream->skip_data = 1;
        return rc;
    }

    if (!r->request_body->rest) {
        return NGX_OK;
    }

    if (r->request_body->busy != NULL) {
        return NGX_AGAIN;
    }

    buf = r->request_body-...",4148.0,4237.0,1.0,1.0,90.0,73,10,68,17,0,4,13,15,2,4,,0,3,2,1,1,ngx_int_t
154,16673,ngx_conf_merge_path_value,1,ngx_conf_merge_path_value,"char* ngx_conf_merge_path_value (ngx_conf_t*,ngx_path_t**,ngx_path_t*,ngx_path_init_t*)",core\ngx_file.c,"char *
ngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev,
    ngx_path_init_t *init)
{
    ngx_uint_t  i;

    if (*path) {
        return NGX_CONF_OK;
    }

    if (prev) {
        *path = prev;
        return NGX_CONF_OK;
    }

    *path = ngx_pcalloc(cf->pool, sizeof(ngx_path_t));
    if (*path == NULL) {
        return NGX_CONF_ERROR;
    }

    (*path)->name = init->name;

    if (ngx_conf_full_name(cf->cycle, &(*path)->name, 0) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    for (i = 0; i < NGX_MAX_PATH_LEVEL; i++) {
        (*path)->level[i] = init->level[i];
        (*path)->len += init->level[i] + (init->level[i] ? 1 : 0);
    }

    if (ngx_add_path(cf, path) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",420.0,456.0,1.0,1.0,37.0,36,12,35,11,0,7,7,7,2,3,,0,7,8,4,4,char*
155,8482,ngx_drain_connections,1,ngx_drain_connections,void ngx_drain_connections (ngx_cycle_t*),core\ngx_connection.c,"static void
ngx_drain_connections(ngx_cycle_t *cycle)
{
    ngx_uint_t         i, n;
    ngx_queue_t       *q;
    ngx_connection_t  *c;

    n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);

    for (i = 0; i < n; i++) {
        if (ngx_queue_empty(&cycle->reusable_connections_queue)) {
            break;
        }

        q = ngx_queue_last(&cycle->reusable_connections_queue);
        c = ngx_queue_data(q, ngx_connection_t, queue);

        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                       ""reusing connection"");

        c->close = 1;
        c->read->handler(c->read);
    }
}",1293.0,1316.0,1.0,1.0,24.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
156,401699,ngx_trylock_fd,1,ngx_trylock_fd,ngx_err_t ngx_trylock_fd (ngx_fd_t),os\unix\ngx_files.c,"ngx_err_t
ngx_trylock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        return ngx_errno;
    }

    return 0;
}",758.0,772.0,1.0,1.0,15.0,9,6,10,7,1,0,2,2,0,0,,0,0,2,1,1,ngx_err_t
157,160032,status_code,3,ngx_http_limit_req_conf_t.status_code,,http\modules\ngx_http_limit_req_module.c,status_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
158,37152,ngx_proxy_protocol_header_t,2,core\ngx_proxy_protocol.c.ngx_proxy_protocol_header_t,,core\ngx_proxy_protocol.c,struct ngx_proxy_protocol_header_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
159,188710,ngx_http_not_modified_header_filter,1,ngx_http_not_modified_header_filter,ngx_int_t ngx_http_not_modified_header_filter (ngx_http_request_t*),http\modules\ngx_http_not_modified_filter_module.c,"static ngx_int_t
ngx_http_not_modified_header_filter(ngx_http_request_t *r)
{
    if (r->headers_out.status != NGX_HTTP_OK
        || r != r->main
        || r->disable_not_modified)
    {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_in.if_unmodified_since
        && !ngx_http_test_if_unmodified(r))
    {
        return ngx_http_filter_finalize_request(r, NULL,
                                                NGX_HTTP_PRECONDITION_FAILED);
    }

    if (r->headers_in.if_match
        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))
    {
        return ngx_http_filter_finalize_request(r, NULL,
                                                NGX_HTTP_PRECONDITION_FAILED);
    }

    if (r->headers_in.if_modified_since || r->headers_in.if_none_match) {

        if (r->headers_in.if_modified_since
            && ngx_http_test_if_modified(r))
        {
            return ngx_http_next_header_filter(r);
        }

        if (r->headers_in.if_none_mat...",54.0,109.0,1.0,1.0,56.0,52,7,38,5,0,6,8,11,4,6,,0,4,2,1,1,ngx_int_t
160,8487,ngx_create_listening,1,ngx_create_listening,"ngx_listening_t ngx_create_listening (ngx_conf_t*,sockaddr*,socklen_t)",core\ngx_connection.c,"ngx_listening_t *
ngx_create_listening(ngx_conf_t *cf, struct sockaddr *sockaddr,
    socklen_t socklen)
{
    size_t            len;
    ngx_listening_t  *ls;
    struct sockaddr  *sa;
    u_char            text[NGX_SOCKADDR_STRLEN];

    ls = ngx_array_push(&cf->cycle->listening);
    if (ls == NULL) {
        return NULL;
    }

    ngx_memzero(ls, sizeof(ngx_listening_t));

    sa = ngx_palloc(cf->pool, socklen);
    if (sa == NULL) {
        return NULL;
    }

    ngx_memcpy(sa, sockaddr, socklen);

    ls->sockaddr = sa;
    ls->socklen = socklen;

    len = ngx_sock_ntop(sa, socklen, text, NGX_SOCKADDR_STRLEN, 1);
    ls->addr_text.len = len;

    switch (ls->sockaddr->sa_family) {
#if (NGX_HAVE_INET6)
    case AF_INET6:
        ls->addr_text_max_len = NGX_INET6_ADDRSTRLEN;
        break;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        ls->addr_text_max_len = NGX_UNIX_ADDRSTRLEN;
        len++;
        break;
#endif
    case AF_INET:
        ls->addr_text_max_len...",19.0,95.0,1.0,1.0,77.0,49,8,54,16,0,4,7,5,0,4,,0,4,6,3,3,ngx_listening_t
161,160033,dry_run,3,ngx_http_limit_req_conf_t.dry_run,,http\modules\ngx_http_limit_req_module.c,dry_run,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
162,4391,ngx_output_chain,1,ngx_output_chain,"ngx_int_t ngx_output_chain (ngx_output_chain_ctx_t*,ngx_chain_t*)",core\ngx_output_chain.c,"ngx_int_t
ngx_output_chain(ngx_output_chain_ctx_t *ctx, ngx_chain_t *in)
{
    off_t         bsize;
    ngx_int_t     rc, last;
    ngx_chain_t  *cl, *out, **last_out;

    if (ctx->in == NULL && ctx->busy == NULL
#if (NGX_HAVE_FILE_AIO || NGX_THREADS)
        && !ctx->aio
#endif
       )
    {
        /*
         * the short path for the case when the ctx->in and ctx->busy chains
         * are empty, the incoming chain is empty too or has the single buf
         * that does not require the copy
         */

        if (in == NULL) {
            return ctx->output_filter(ctx->filter_ctx, in);
        }

        if (in->next == NULL
#if (NGX_SENDFILE_LIMIT)
            && !(in->buf->in_file && in->buf->file_last > NGX_SENDFILE_LIMIT)
#endif
            && ngx_output_chain_as_is(ctx, in->buf))
        {
            return ctx->output_filter(ctx->filter_ctx, in);
        }
    }

    /* add the incoming buf to the chain ctx->in */

    if (in) {
        if (ngx_output_chain_add_copy(c...",45.0,244.0,1.0,11.0,200.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
163,160040,ngx_http_limit_req_lookup,1,ngx_http_limit_req_lookup,"ngx_int_t ngx_http_limit_req_lookup (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_str_t*,ngx_uint_t*,ngx_uint_t)",http\modules\ngx_http_limit_req_module.c,"static ngx_int_t
ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash,
    ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account)
{
    size_t                      size;
    ngx_int_t                   rc, excess;
    ngx_msec_t                  now;
    ngx_msec_int_t              ms;
    ngx_rbtree_node_t          *node, *sentinel;
    ngx_http_limit_req_ctx_t   *ctx;
    ngx_http_limit_req_node_t  *lr;

    now = ngx_current_msec;

    ctx = limit->shm_zone->data;

    node = ctx->sh->rbtree.root;
    sentinel = ctx->sh->rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lr = (ngx_http_limit_req_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lr->data, key->len, (size_t) lr->len);

        if (rc == 0) {
            ...",410.0,538.0,1.0,1.0,129.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,ngx_int_t
164,160049,ngx_http_limit_req_account,1,ngx_http_limit_req_account,"ngx_msec_t ngx_http_limit_req_account (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_uint_t*,ngx_http_limit_req_limit_t**)",http\modules\ngx_http_limit_req_module.c,"static ngx_msec_t
ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
    ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit)
{
    ngx_int_t                   excess;
    ngx_msec_t                  now, delay, max_delay;
    ngx_msec_int_t              ms;
    ngx_http_limit_req_ctx_t   *ctx;
    ngx_http_limit_req_node_t  *lr;

    excess = *ep;

    if ((ngx_uint_t) excess <= (*limit)->delay) {
        max_delay = 0;

    } else {
        ctx = (*limit)->shm_zone->data;
        max_delay = (excess - (*limit)->delay) * 1000 / ctx->rate;
    }

    while (n--) {
        ctx = limits[n].shm_zone->data;
        lr = ctx->node;

        if (lr == NULL) {
            continue;
        }

        ngx_shmtx_lock(&ctx->shpool->mutex);

        now = ngx_current_msec;
        ms = (ngx_msec_int_t) (now - lr->last);

        if (ms < -60000) {
            ms = 1;

        } else if (ms < 0) {
            ms = 0;
        }

        excess = lr->excess - ctx->rate * ...",541.0,612.0,1.0,1.0,72.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_msec_t
165,86322,ngx_ssl_read_password_file,1,ngx_ssl_read_password_file,"ngx_array_t ngx_ssl_read_password_file (ngx_conf_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_array_t *
ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file)
{
    u_char              *p, *last, *end;
    size_t               len;
    ssize_t              n;
    ngx_fd_t             fd;
    ngx_str_t           *pwd;
    ngx_array_t         *passwords;
    ngx_pool_cleanup_t  *cln;
    u_char               buf[NGX_SSL_PASSWORD_BUFFER_SIZE];

    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
        return NULL;
    }

    passwords = ngx_array_create(cf->temp_pool, 4, sizeof(ngx_str_t));
    if (passwords == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->temp_pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_ssl_passwords_cleanup;
    cln->data = passwords;

    fd = ngx_open_file(file->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (fd == NGX_INVALID_FILE) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                           ngx_open_file_n "" \""%s\"" failed"", file->data);
        ...",1112.0,1239.0,1.0,29.0,128.0,71,13,110,23,0,18,24,35,3,10,,0,16,4,2,2,ngx_array_t
166,463157,ngx_stream_add_prefix_variable,1,ngx_stream_add_prefix_variable,"ngx_stream_variable_t* ngx_stream_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)",stream\ngx_stream_variables.c,"static ngx_stream_variable_t *
ngx_stream_add_prefix_variable(ngx_conf_t *cf, ngx_str_t *name,
    ngx_uint_t flags)
{
    ngx_uint_t                    i;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->prefix_variables.elts;
    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {
        if (name->len != v[i].name.len
            || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
        {
            continue;
        }

        v = &v[i];

        if (!(v->flags & NGX_STREAM_VAR_CHANGEABLE)) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""the duplicate \""%V\"" variable"", name);
            return NULL;
        }

        if (!(flags & NGX_STREAM_VAR_WEAK)) {
            v->flags &= ~NGX_STREAM_VAR_WEAK;
        }

        return v;
    }

    v = ngx_array_push(&cmcf->prefix_variables);
    if (v == NULL) {
...",216.0,269.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_stream_variable_t
167,299328,ngx_http_script_compile,1,ngx_http_script_compile,ngx_int_t ngx_http_script_compile (ngx_http_script_compile_t*),http\ngx_http_script.c,"ngx_int_t
ngx_http_script_compile(ngx_http_script_compile_t *sc)
{
    u_char       ch;
    ngx_str_t    name;
    ngx_uint_t   i, bracket;

    if (ngx_http_script_init_arrays(sc) != NGX_OK) {
        return NGX_ERROR;
    }

    for (i = 0; i < sc->source->len; /* void */ ) {

        name.len = 0;

        if (sc->source->data[i] == '$') {

            if (++i == sc->source->len) {
                goto invalid_variable;
            }

            if (sc->source->data[i] >= '1' && sc->source->data[i] <= '9') {
#if (NGX_PCRE)
                ngx_uint_t  n;

                n = sc->source->data[i] - '0';

                if (sc->captures_mask & ((ngx_uint_t) 1 << n)) {
                    sc->dup_capture = 1;
                }

                sc->captures_mask |= (ngx_uint_t) 1 << n;

                if (ngx_http_script_add_capture_code(sc, n) != NGX_OK) {
                    return NGX_ERROR;
                }

                i++;

                continue;
#else
                ...",421.0,573.0,1.0,1.0,153.0,119,15,89,8,1,41,31,57,20,8,,0,37,2,1,1,ngx_int_t
168,69952,ngx_next_time,1,ngx_next_time,time_t ngx_next_time (time_t),core\ngx_times.c,"time_t
ngx_next_time(time_t when)
{
    time_t     now, next;
    struct tm  tm;

    now = ngx_time();

    ngx_libc_localtime(now, &tm);

    tm.tm_hour = (int) (when / 3600);
    when %= 3600;
    tm.tm_min = (int) (when / 60);
    tm.tm_sec = (int) (when % 60);

    next = mktime(&tm);

    if (next == -1) {
        return -1;
    }

    if (next - now > 0) {
        return next;
    }

    tm.tm_mday++;

    /* mktime() should normalize a date (Jan 32, etc) */

    next = mktime(&tm);

    if (next != -1) {
        return next;
    }

    return -1;
}",432.0,468.0,1.0,1.0,37.0,28,12,21,4,0,1,4,4,0,1,,0,0,2,1,1,time_t
169,65859,ngx_sort,1,ngx_sort,"void ngx_sort (void*,size_t,size_t,ngx_int_t)",core\ngx_string.c,"void
ngx_sort(void *base, size_t n, size_t size,
    ngx_int_t (*cmp)(const void *, const void *))
{
    u_char  *p1, *p2, *p;

    p = ngx_alloc(size, ngx_cycle->log);
    if (p == NULL) {
        return;
    }

    for (p1 = (u_char *) base + size;
         p1 < (u_char *) base + n * size;
         p1 += size)
    {
        ngx_memcpy(p, p1, size);

        for (p2 = p1;
             p2 > (u_char *) base && cmp(p2 - size, p) > 0;
             p2 -= size)
        {
            ngx_memcpy(p2, p2 - size, size);
        }

        ngx_memcpy(p2, p, size);
    }

    ngx_free(p);
}",1985.0,2013.0,1.0,1.0,29.0,17,10,30,8,0,1,4,5,0,1,,0,1,8,4,4,void
170,106820,ngx_http_charset_filter_module,2,http\modules\ngx_http_charset_filter_module.c.ngx_http_charset_filter_module,,http\modules\ngx_http_charset_filter_module.c,ngx_module_t ngx_http_charset_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
171,37189,ngx_proxy_protocol_read_addr,1,ngx_proxy_protocol_read_addr,"u_char* ngx_proxy_protocol_read_addr (ngx_connection_t*,u_char*,u_char*,ngx_str_t*)",core\ngx_proxy_protocol.c,"static u_char *
ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p, u_char *last,
    ngx_str_t *addr)
{
    size_t  len;
    u_char  ch, *pos;

    pos = p;

    for ( ;; ) {
        if (p == last) {
            return NULL;
        }

        ch = *p++;

        if (ch == ' ') {
            break;
        }

        if (ch != ':' && ch != '.'
            && (ch < 'a' || ch > 'f')
            && (ch < 'A' || ch > 'F')
            && (ch < '0' || ch > '9'))
        {
            return NULL;
        }
    }

    len = p - pos - 1;

    addr->data = ngx_pnalloc(c->pool, len);
    if (addr->data == NULL) {
        return NULL;
    }

    ngx_memcpy(addr->data, pos, len);
    addr->len = len;

    return p;
}",149.0,189.0,1.0,1.0,41.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,u_char
172,401734,ngx_lock_fd,1,ngx_lock_fd,ngx_err_t ngx_lock_fd (ngx_fd_t),os\unix\ngx_files.c,"ngx_err_t
ngx_lock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLKW, &fl) == -1) {
        return ngx_errno;
    }

    return 0;
}",775.0,789.0,1.0,1.0,15.0,9,6,10,7,1,0,2,2,0,0,,0,0,2,1,1,ngx_err_t
173,37197,ngx_proxy_protocol_read_port,1,ngx_proxy_protocol_read_port,"u_char* ngx_proxy_protocol_read_port (u_char*,u_char*,in_port_t*,u_char)",core\ngx_proxy_protocol.c,"static u_char *
ngx_proxy_protocol_read_port(u_char *p, u_char *last, in_port_t *port,
    u_char sep)
{
    size_t      len;
    u_char     *pos;
    ngx_int_t   n;

    pos = p;

    for ( ;; ) {
        if (p == last) {
            return NULL;
        }

        if (*p++ == sep) {
            break;
        }
    }

    len = p - pos - 1;

    n = ngx_atoi(pos, len);
    if (n < 0 || n > 65535) {
        return NULL;
    }

    *port = (in_port_t) n;

    return p;
}",192.0,222.0,1.0,1.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,u_char
174,434513,ngx_stream_limit_conn_init_zone,1,ngx_stream_limit_conn_init_zone,"ngx_int_t ngx_stream_limit_conn_init_zone (ngx_shm_zone_t*,void*)",stream\ngx_stream_limit_conn_module.c,"static ngx_int_t
ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_stream_limit_conn_ctx_t  *octx = data;

    size_t                        len;
    ngx_stream_limit_conn_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_conn_zone \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists...",417.0,477.0,1.0,1.0,61.0,83,10,48,10,0,30,6,7,7,4,,0,28,4,2,2,ngx_int_t
175,340,ngx_core_module,2,core\nginx.c.ngx_core_module,,core\nginx.c,ngx_module_t ngx_core_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
176,37205,ngx_proxy_protocol_v2_read,1,ngx_proxy_protocol_v2_read,"u_char* ngx_proxy_protocol_v2_read (ngx_connection_t*,u_char*,u_char*)",core\ngx_proxy_protocol.c,"static u_char *
ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)
{
    u_char                             *end;
    size_t                              len;
    socklen_t                           socklen;
    ngx_uint_t                          version, command, family, transport;
    ngx_sockaddr_t                      src_sockaddr, dst_sockaddr;
    ngx_proxy_protocol_t               *pp;
    ngx_proxy_protocol_header_t        *header;
    ngx_proxy_protocol_inet_addrs_t    *in;
#if (NGX_HAVE_INET6)
    ngx_proxy_protocol_inet6_addrs_t   *in6;
#endif

    header = (ngx_proxy_protocol_header_t *) buf;

    buf += sizeof(ngx_proxy_protocol_header_t);

    version = header->version_command >> 4;

    if (version != 2) {
        ngx_log_error(NGX_LOG_ERR, c->log, 0,
                      ""unknown PROXY protocol version: %ui"", version);
        return NULL;
    }

    len = ngx_proxy_protocol_parse_uint16(header->len);

    if ((size_t) (last - buf) < len) {
...",269.0,422.0,1.0,10.0,154.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,u_char
177,106839,ngx_http_charset_header_filter,1,ngx_http_charset_header_filter,ngx_int_t ngx_http_charset_header_filter (ngx_http_request_t*),http\modules\ngx_http_charset_filter_module.c,"static ngx_int_t
ngx_http_charset_header_filter(ngx_http_request_t *r)
{
    ngx_int_t                      charset, source_charset;
    ngx_str_t                      dst, src;
    ngx_http_charset_t            *charsets;
    ngx_http_charset_main_conf_t  *mcf;

    if (r == r->main) {
        charset = ngx_http_destination_charset(r, &dst);

    } else {
        charset = ngx_http_main_request_charset(r, &dst);
    }

    if (charset == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (charset == NGX_DECLINED) {
        return ngx_http_next_header_filter(r);
    }

    /* charset: charset index or NGX_HTTP_NO_CHARSET */

    source_charset = ngx_http_source_charset(r, &src);

    if (source_charset == NGX_ERROR) {
        return NGX_ERROR;
    }

    /*
     * source_charset: charset index, NGX_HTTP_NO_CHARSET,
     *                 or NGX_HTTP_CHARSET_OFF
     */

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""charset: \""%V\"" > \""%V\"""", &sr...",216.0,313.0,1.0,26.0,98.0,66,10,70,13,0,10,13,12,4,5,,0,8,2,1,1,ngx_int_t
178,37212,ngx_proxy_protocol_read,1,ngx_proxy_protocol_read,"u_char ngx_proxy_protocol_read (ngx_connection_t*,u_char*,u_char*)",core\ngx_proxy_protocol.c,"u_char *
ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)
{
    size_t                 len;
    u_char                *p;
    ngx_proxy_protocol_t  *pp;

    static const u_char signature[] = ""\r\n\r\n\0\r\nQUIT\n"";

    p = buf;
    len = last - buf;

    if (len >= sizeof(ngx_proxy_protocol_header_t)
        && memcmp(p, signature, sizeof(signature) - 1) == 0)
    {
        return ngx_proxy_protocol_v2_read(c, buf, last);
    }

    if (len < 8 || ngx_strncmp(p, ""PROXY "", 6) != 0) {
        goto invalid;
    }

    p += 6;
    len -= 6;

    if (len >= 7 && ngx_strncmp(p, ""UNKNOWN"", 7) == 0) {
        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                       ""PROXY protocol unknown protocol"");
        p += 7;
        goto skip;
    }

    if (len < 5 || ngx_strncmp(p, ""TCP"", 3) != 0
        || (p[3] != '4' && p[3] != '6') || p[4] != ' ')
    {
        goto invalid;
    }

    p += 5;

    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));
  ...",51.0,146.0,1.0,1.0,96.0,76,17,88,14,0,8,23,15,1,7,,0,6,6,3,3,u_char
179,4446,ngx_conf_add_dump,1,ngx_conf_add_dump,"ngx_int_t ngx_conf_add_dump (ngx_conf_t*,ngx_str_t*)",core\ngx_conf_file.c,"static ngx_int_t
ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename)
{
    off_t             size;
    u_char           *p;
    uint32_t          hash;
    ngx_buf_t        *buf;
    ngx_str_node_t   *sn;
    ngx_conf_dump_t  *cd;

    hash = ngx_crc32_long(filename->data, filename->len);

    sn = ngx_str_rbtree_lookup(&cf->cycle->config_dump_rbtree, filename, hash);

    if (sn) {
        cf->conf_file->dump = NULL;
        return NGX_OK;
    }

    p = ngx_pstrdup(cf->cycle->pool, filename);
    if (p == NULL) {
        return NGX_ERROR;
    }

    cd = ngx_array_push(&cf->cycle->config_dump);
    if (cd == NULL) {
        return NGX_ERROR;
    }

    size = ngx_file_size(&cf->conf_file->file.info);

    buf = ngx_create_temp_buf(cf->cycle->pool, (size_t) size);
    if (buf == NULL) {
        return NGX_ERROR;
    }

    cd->name.data = p;
    cd->name.len = filename->len;
    cd->buffer = buf;

    cf->conf_file->dump = buf;

    sn = ngx_palloc(cf->temp_pool, sizeof(ngx_str_...",101.0,154.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
180,4452,ngx_conf_handler,1,ngx_conf_handler,"ngx_int_t ngx_conf_handler (ngx_conf_t*,ngx_int_t)",core\ngx_conf_file.c,"static ngx_int_t
ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last)
{
    char           *rv;
    void           *conf, **confp;
    ngx_uint_t      i, found;
    ngx_str_t      *name;
    ngx_command_t  *cmd;

    name = cf->args->elts;

    found = 0;

    for (i = 0; cf->cycle->modules[i]; i++) {

        cmd = cf->cycle->modules[i]->commands;
        if (cmd == NULL) {
            continue;
        }

        for ( /* void */ ; cmd->name.len; cmd++) {

            if (name->len != cmd->name.len) {
                continue;
            }

            if (ngx_strcmp(name->data, cmd->name.data) != 0) {
                continue;
            }

            found = 1;

            if (cf->cycle->modules[i]->type != NGX_CONF_MODULE
                && cf->cycle->modules[i]->type != cf->module_type)
            {
                continue;
            }

            /* is the directive's location right ? */

            if (!(cmd->type & cf->cmd_type)) {
                continue;
          ...",355.0,499.0,1.0,1.0,145.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
181,358,ngx_show_version,2,core\nginx.c.ngx_show_version,,core\nginx.c,ngx_uint_t ngx_show_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
182,360,ngx_prefix,2,core\nginx.c.ngx_prefix,,core\nginx.c,u_char* ngx_prefix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
183,401769,ngx_unlock_fd,1,ngx_unlock_fd,ngx_err_t ngx_unlock_fd (ngx_fd_t),os\unix\ngx_files.c,"ngx_err_t
ngx_unlock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_UNLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        return  ngx_errno;
    }

    return 0;
}",792.0,806.0,1.0,1.0,15.0,9,6,10,7,1,0,2,2,0,0,,0,0,2,1,1,ngx_err_t
184,4458,ngx_conf_read_token,1,ngx_conf_read_token,ngx_int_t ngx_conf_read_token (ngx_conf_t*),core\ngx_conf_file.c,"static ngx_int_t
ngx_conf_read_token(ngx_conf_t *cf)
{
    u_char      *start, ch, *src, *dst;
    off_t        file_size;
    size_t       len;
    ssize_t      n, size;
    ngx_uint_t   found, need_space, last_space, sharp_comment, variable;
    ngx_uint_t   quoted, s_quoted, d_quoted, start_line;
    ngx_str_t   *word;
    ngx_buf_t   *b, *dump;

    found = 0;
    need_space = 0;
    last_space = 1;
    sharp_comment = 0;
    variable = 0;
    quoted = 0;
    s_quoted = 0;
    d_quoted = 0;

    cf->args->nelts = 0;
    b = cf->conf_file->buffer;
    dump = cf->conf_file->dump;
    start = b->pos;
    start_line = cf->conf_file->line;

    file_size = ngx_file_size(&cf->conf_file->file.info);

    for ( ;; ) {

        if (b->pos >= b->last) {

            if (cf->conf_file->file.offset >= file_size) {

                if (cf->args->nelts > 0 || !last_space) {

                    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {
                        ngx_conf_log_error(NGX_LO...",502.0,817.0,1.0,23.0,316.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
185,363,ngx_signal,2,core\nginx.c.ngx_signal,,core\nginx.c,static char* ngx_signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
186,364,ngx_os_environ,2,core\nginx.c.ngx_os_environ,,core\nginx.c,static char** ngx_os_environ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
187,446830,ngx_stream_complex_value_size,1,ngx_stream_complex_value_size,"size_t ngx_stream_complex_value_size (ngx_stream_session_t*,ngx_stream_complex_value_t*,size_t)",stream\ngx_stream_script.c,"size_t
ngx_stream_complex_value_size(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, size_t default_value)
{
    size_t     size;
    ngx_str_t  value;

    if (val == NULL) {
        return default_value;
    }

    if (val->lengths == NULL) {
        return val->u.size;
    }

    if (ngx_stream_complex_value(s, val, &value) != NGX_OK) {
        return default_value;
    }

    size = ngx_parse_size(&value);

    if (size == (size_t) NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""invalid size \""%V\"""", &value);
        return default_value;
    }

    return size;
}",108.0,136.0,1.0,1.0,29.0,14,7,20,9,0,5,5,5,2,3,,0,4,6,3,3,size_t
188,367,main,1,main,"ANY main (int,char**)",core\nginx.c,"main(int argc, char *const *argv)
{
    ngx_buf_t        *b;
    ngx_log_t        *log;
    ngx_uint_t        i;
    ngx_cycle_t      *cycle, init_cycle;
    ngx_conf_dump_t  *cd;
    ngx_core_conf_t  *ccf;

    ngx_debug_init();

    if (ngx_strerror_init() != NGX_OK) {
        return 1;
    }

    if (ngx_get_options(argc, argv) != NGX_OK) {
        return 1;
    }

    if (ngx_show_version) {
        ngx_show_version_info();

        if (!ngx_test_config) {
            return 0;
        }
    }

    /* TODO */ ngx_max_sockets = -1;

    ngx_time_init();

#if (NGX_PCRE)
    ngx_regex_init();
#endif

    ngx_pid = ngx_getpid();
    ngx_parent = ngx_getppid();

    log = ngx_log_init(ngx_prefix);
    if (log == NULL) {
        return 1;
    }

    /* STUB */
#if (NGX_OPENSSL)
    ngx_ssl_init(log);
#endif

    /*
     * init_cycle->log is required for signal handlers and
     * ngx_process_options()
     */

    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
    init_cycle.log = log...",195.0,386.0,1.0,1.0,192.0,89,14,99,33,0,34,30,38,17,26,,0,23,4,2,2,ANY
189,168315,ngx_http_map_cmp_dns_wildcards,1,ngx_http_map_cmp_dns_wildcards,"ANY ngx_http_map_cmp_dns_wildcards (void*,void*)",http\modules\ngx_http_map_module.c,"ngx_http_map_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",369.0,377.0,1.0,1.0,9.0,8,4,6,4,0,3,1,1,0,1,,0,2,4,2,2,ANY
190,401804,ngx_fs_bsize,1,ngx_fs_bsize,size_t ngx_fs_bsize (u_char*),os\win32\ngx_files.c,"size_t
ngx_fs_bsize(u_char *name)
{
    u_char  root[4];
    u_long  sc, bs, nfree, ncl;

    if (name[2] == ':') {
        ngx_cpystrn(root, name, 4);
        name = root;
    }

    if (GetDiskFreeSpace((const char *) name, &sc, &bs, &nfree, &ncl) == 0) {
        return 512;
    }

    return sc * bs;
}",642.0,658.0,1.0,1.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,size_t
191,409998,addr,3,ngx_shm_t.addr,,os\unix\ngx_shmem.h,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
192,409999,size,3,ngx_shm_t.size,,os\unix\ngx_shmem.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
193,410000,name,3,ngx_shm_t.name,,os\unix\ngx_shmem.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
194,410001,log,3,ngx_shm_t.log,,os\unix\ngx_shmem.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
195,410004,ngx_shm_alloc,1,ngx_shm_alloc,ngx_int_t ngx_shm_alloc (ngx_shm_t*),os\win32\ngx_shmem.c,"ngx_int_t
ngx_shm_alloc(ngx_shm_t *shm)
{
    u_char         *name;
    uint64_t        size;
    static u_char  *base = (u_char *) NGX_SHMEM_BASE;

    name = ngx_alloc(shm->name.len + 2 + NGX_INT32_LEN, shm->log);
    if (name == NULL) {
        return NGX_ERROR;
    }

    (void) ngx_sprintf(name, ""%V_%s%Z"", &shm->name, ngx_unique);

    ngx_set_errno(0);

    size = shm->size;

    shm->handle = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                                    (u_long) (size >> 32),
                                    (u_long) (size & 0xffffffff),
                                    (char *) name);

    if (shm->handle == NULL) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""CreateFileMapping(%uz, %s) failed"",
                      shm->size, name);
        ngx_free(name);

        return NGX_ERROR;
    }

    ngx_free(name);

    if (ngx_errno == ERROR_ALREADY_EXISTS) {
        shm->exists = 1;
    }

    shm->a...",44.0,120.0,1.0,38.0,77.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
196,258452,ngx_http_core_auth_delay,1,ngx_http_core_auth_delay,ngx_int_t ngx_http_core_auth_delay (ngx_http_request_t*),http\ngx_http_core_module.c,"static ngx_int_t
ngx_http_core_auth_delay(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->auth_delay == 0) {
        ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  ""delaying unauthorized request"");

    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    r->read_event_handler = ngx_http_test_reading;
    r->write_event_handler = ngx_http_core_auth_delay_handler;

    r->connection->write->delayed = 1;
    ngx_add_timer(r->connection->write, clcf->auth_delay);

    /*
     * trigger an additional event loop iteration
     * to ensure constant-time processing
     */

    ngx_post_event(r->connection->write, &ngx_posted_next_events);

    return NGX_OK;
}",1178.0,1211.0,1.0,1.0,34.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
197,16791,ngx_conf_set_access_slot,1,ngx_conf_set_access_slot,"char* ngx_conf_set_access_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_file.c,"char *
ngx_conf_set_access_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *confp = conf;

    u_char      *p;
    ngx_str_t   *value;
    ngx_uint_t   i, right, shift, *access, user;

    access = (ngx_uint_t *) (confp + cmd->offset);

    if (*access != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *access = 0;
    user = 0600;

    for (i = 1; i < cf->args->nelts; i++) {

        p = value[i].data;

        if (ngx_strncmp(p, ""user:"", sizeof(""user:"") - 1) == 0) {
            shift = 6;
            p += sizeof(""user:"") - 1;
            user = 0;

        } else if (ngx_strncmp(p, ""group:"", sizeof(""group:"") - 1) == 0) {
            shift = 3;
            p += sizeof(""group:"") - 1;

        } else if (ngx_strncmp(p, ""all:"", sizeof(""all:"") - 1) == 0) {
            shift = 0;
            p += sizeof(""all:"") - 1;

        } else {
            goto invalid;
        }

        if (ngx_strcmp(p, ""rw"") == 0) {
            rig...",459.0,522.0,1.0,1.0,64.0,35,15,34,15,0,1,5,7,0,1,,0,0,6,3,3,char*
198,65943,ngx_explicit_memzero,1,ngx_explicit_memzero,"void ngx_explicit_memzero (void*,size_t)",core\ngx_string.c,"void
ngx_explicit_memzero(void *buf, size_t n)
{
    ngx_memzero(buf, n);
    ngx_memory_barrier();
}",2016.0,2021.0,1.0,1.0,6.0,0,0,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
199,410009,ngx_shm_free,1,ngx_shm_free,void ngx_shm_free (ngx_shm_t*),os\win32\ngx_shmem.c,"void
ngx_shm_free(ngx_shm_t *shm)
{
    if (UnmapViewOfFile(shm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%V\"" failed"",
                      shm->addr, &shm->name);
    }

    if (CloseHandle(shm->handle) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""CloseHandle() of file mapping \""%V\"" failed"",
                      &shm->name);
    }
}",147.0,161.0,1.0,1.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
200,270747,ngx_http_file_cache_forced_expire,1,ngx_http_file_cache_forced_expire,time_t ngx_http_file_cache_forced_expire (ngx_http_file_cache_t*),http\ngx_http_file_cache.c,"static time_t
ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache)
{
    u_char                      *name, *p;
    size_t                       len;
    time_t                       wait;
    ngx_uint_t                   tries;
    ngx_path_t                  *path;
    ngx_queue_t                 *q, *sentinel;
    ngx_http_file_cache_node_t  *fcn;
    u_char                       key[2 * NGX_HTTP_CACHE_KEY_LEN];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache forced expire"");

    path = cache->path;
    len = path->name.len + 1 + path->len + 2 * NGX_HTTP_CACHE_KEY_LEN;

    name = ngx_alloc(len + 1, ngx_cycle->log);
    if (name == NULL) {
        return 10;
    }

    ngx_memcpy(name, path->name.data, path->name.len);

    wait = 10;
    tries = 20;
    sentinel = NULL;

    ngx_shmtx_lock(&cache->shpool->mutex);

    for ( ;; ) {
        if (ngx_queue_empty(&cache->sh->queue)) {
            break;
        }

        q =...",1701.0,1792.0,1.0,1.0,92.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,time_t
201,229787,dynamic,3,ngx_http_sub_loc_conf_t.dynamic,,http\modules\ngx_http_sub_filter_module.c,dynamic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
202,229788,pairs,3,ngx_http_sub_loc_conf_t.pairs,,http\modules\ngx_http_sub_filter_module.c,*pairs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
203,229790,types,3,ngx_http_sub_loc_conf_t.types,,http\modules\ngx_http_sub_filter_module.c,types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
204,229791,once,3,ngx_http_sub_loc_conf_t.once,,http\modules\ngx_http_sub_filter_module.c,once,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
205,270752,ngx_http_file_cache_expire,1,ngx_http_file_cache_expire,time_t ngx_http_file_cache_expire (ngx_http_file_cache_t*),http\ngx_http_file_cache.c,"static time_t
ngx_http_file_cache_expire(ngx_http_file_cache_t *cache)
{
    u_char                      *name, *p;
    size_t                       len;
    time_t                       now, wait;
    ngx_path_t                  *path;
    ngx_msec_t                   elapsed;
    ngx_queue_t                 *q;
    ngx_http_file_cache_node_t  *fcn;
    u_char                       key[2 * NGX_HTTP_CACHE_KEY_LEN];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache expire"");

    path = cache->path;
    len = path->name.len + 1 + path->len + 2 * NGX_HTTP_CACHE_KEY_LEN;

    name = ngx_alloc(len + 1, ngx_cycle->log);
    if (name == NULL) {
        return 10;
    }

    ngx_memcpy(name, path->name.data, path->name.len);

    now = ngx_time();

    ngx_shmtx_lock(&cache->shpool->mutex);

    for ( ;; ) {

        if (ngx_quit || ngx_terminate) {
            wait = 1;
            break;
        }

        if (ngx_queue_empty(&cache->sh->queue...",1795.0,1903.0,1.0,1.0,109.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,time_t
206,229792,last_modified,3,ngx_http_sub_loc_conf_t.last_modified,,http\modules\ngx_http_sub_filter_module.c,last_modified,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
207,401826,size,3,ngx_file_mapping_t.size,,os\unix\ngx_files.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
208,401827,addr,3,ngx_file_mapping_t.addr,,os\unix\ngx_files.h,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
209,401828,fd,3,ngx_file_mapping_t.fd,,os\unix\ngx_files.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
210,401829,log,3,ngx_file_mapping_t.log,,os\unix\ngx_files.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
211,229798,looked,3,ngx_http_sub_ctx_t.looked,,http\modules\ngx_http_sub_filter_module.c,looked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
212,229799,once,3,ngx_http_sub_ctx_t.once,,http\modules\ngx_http_sub_filter_module.c,once,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
213,229800,buf,3,ngx_http_sub_ctx_t.buf,,http\modules\ngx_http_sub_filter_module.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
214,229794,matches,3,ngx_http_sub_loc_conf_t.matches,,http\modules\ngx_http_sub_filter_module.c,*matches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
215,401834,de,3,ngx_dir_t.de,,os\unix\ngx_files.h,*de,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
216,65963,len,3,ngx_str_t.len,,core\ngx_string.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,300,0,1,1,0,0,,0,0,0,0,0,
217,65964,data,3,ngx_str_t.data,,core\ngx_string.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,333,0,1,1,0,0,,0,0,0,0,0,
218,401836,info,3,ngx_dir_t.info,,os\unix\ngx_files.h,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
219,410030,ngx_tcp_push,1,ngx_tcp_push,int ngx_tcp_push (ngx_socket_t),os\win32\ngx_socket.c,"int
ngx_tcp_push(ngx_socket_t s)
{
    return 0;
}",45.0,49.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
220,229807,busy,3,ngx_http_sub_ctx_t.busy,,http\modules\ngx_http_sub_filter_module.c,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
221,229808,free,3,ngx_http_sub_ctx_t.free,,http\modules\ngx_http_sub_filter_module.c,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
222,401841,n,3,ngx_glob_t.n,,os\unix\ngx_files.h,n,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
223,401842,pglob,3,ngx_glob_t.pglob,,os\unix\ngx_files.h,pglob,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
224,229810,applied,3,ngx_http_sub_ctx_t.applied,,http\modules\ngx_http_sub_filter_module.c,applied,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
225,65967,key,3,ngx_keyval_t.key,,core\ngx_string.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
226,401844,log,3,ngx_glob_t.log,,os\unix\ngx_files.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
227,229814,matches,3,ngx_http_sub_ctx_t.matches,,http\modules\ngx_http_sub_filter_module.c,*matches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
228,229815,ngx_http_sub_ctx_t,2,http\modules\ngx_http_sub_filter_module.c.ngx_http_sub_ctx_t,,http\modules\ngx_http_sub_filter_module.c,struct ngx_http_sub_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
229,65976,data,3,ngx_variable_value_t.data,,core\ngx_string.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
230,229817,ngx_http_sub_output,1,ngx_http_sub_output,"ngx_int_t ngx_http_sub_output (ngx_http_request_t*,ngx_http_sub_ctx_t*)",http\modules\ngx_http_sub_filter_module.c,"static ngx_int_t
ngx_http_sub_output(ngx_http_request_t *r, ngx_http_sub_ctx_t *ctx)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

#if 1
    b = NULL;
    for (cl = ctx->out; cl; cl = cl->next) {
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""sub out: %p %p"", cl->buf, cl->buf->pos);
        if (cl->buf == b) {
            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                          ""the same buf was used in sub"");
            ngx_debug_point();
            return NGX_ERROR;
        }
        b = cl->buf;
    }
#endif

    rc = ngx_http_next_body_filter(r, ctx->out);

    if (ctx->busy == NULL) {
        ctx->busy = ctx->out;

    } else {
        for (cl = ctx->busy; cl->next; cl = cl->next) { /* void */ }
        cl->next = ctx->out;
    }

    ctx->out = NULL;
    ctx->last_out = &ctx->out;

    while (ctx->busy) {

        cl = ctx->busy;
        b = cl->buf;

        if (ngx_buf_size(b) != 0) {
   ...",537.0,603.0,1.0,1.0,67.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
231,229812,index,3,ngx_http_sub_ctx_t.index,,http\modules\ngx_http_sub_filter_module.c,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
232,229813,tables,3,ngx_http_sub_ctx_t.tables,,http\modules\ngx_http_sub_filter_module.c,*tables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
233,401845,test,3,ngx_glob_t.test,,os\unix\ngx_files.h,test,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
234,463290,ngx_stream_core_variables,2,stream\ngx_stream_variables.c.ngx_stream_core_variables,,stream\ngx_stream_variables.c,static ngx_stream_variable_t[] ngx_stream_core_variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
235,229823,ngx_http_sub_parse,1,ngx_http_sub_parse,"ngx_int_t ngx_http_sub_parse (ngx_http_request_t*,ngx_http_sub_ctx_t*,ngx_uint_t)",http\modules\ngx_http_sub_filter_module.c,"static ngx_int_t
ngx_http_sub_parse(ngx_http_request_t *r, ngx_http_sub_ctx_t *ctx,
    ngx_uint_t flush)
{
    u_char                   *p, c;
    ngx_str_t                *m;
    ngx_int_t                 offset, start, next, end, len, rc;
    ngx_uint_t                shift, i, j;
    ngx_http_sub_match_t     *match;
    ngx_http_sub_tables_t    *tables;
    ngx_http_sub_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_sub_filter_module);
    tables = ctx->tables;
    match = ctx->matches->elts;

    offset = ctx->offset;
    end = ctx->buf->last - ctx->pos;

    if (ctx->once) {
        /* sets start and next to end */
        offset = end + (ngx_int_t) tables->min_match_len - 1;
        goto again;
    }

    while (offset < end) {

        c = offset < 0 ? ctx->looked.data[ctx->looked.len + offset]
                       : ctx->pos[offset];

        c = ngx_tolower(c);

        shift = tables->shift[c];
        if (shift > 0) {
            offset += shif...",606.0,740.0,1.0,1.0,135.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
236,217535,ngx_http_ssi_string,2,http\modules\ngx_http_ssi_filter_module.c.ngx_http_ssi_string,,http\modules\ngx_http_ssi_filter_module.c,static u_char[] ngx_http_ssi_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
237,29126,bytes,3,ngx_md5_t.bytes,,core\ngx_md5.h,bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
238,29127,a,3,ngx_md5_t.a,,core\ngx_md5.h,a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
239,29128,b,3,ngx_md5_t.b,,core\ngx_md5.h,b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
240,29129,c,3,ngx_md5_t.c,,core\ngx_md5.h,c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
241,29130,d,3,ngx_md5_t.d,,core\ngx_md5.h,d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
242,348619,emit,3,ngx_http_v2_huff_decode_code_t.emit,,http\v2\ngx_http_v2_huff_decode.c,emit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
243,29131,buffer,3,ngx_md5_t.buffer,,core\ngx_md5.h,buffer[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
244,348618,next,3,ngx_http_v2_huff_decode_code_t.next,,http\v2\ngx_http_v2_huff_decode.c,next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
245,217544,ngx_http_ssi_timefmt,2,http\modules\ngx_http_ssi_filter_module.c.ngx_http_ssi_timefmt,,http\modules\ngx_http_ssi_filter_module.c,ngx_str_t ngx_http_ssi_timefmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
246,348620,sym,3,ngx_http_v2_huff_decode_code_t.sym,,http\v2\ngx_http_v2_huff_decode.c,sym,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
247,348624,ngx_http_v2_huff_decode_codes,2,http\v2\ngx_http_v2_huff_decode.c.ngx_http_v2_huff_decode_codes,,http\v2\ngx_http_v2_huff_decode.c,static ngx_http_v2_huff_decode_code_t[256] ngx_http_v2_huff_decode_codes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
248,348621,ending,3,ngx_http_v2_huff_decode_code_t.ending,,http\v2\ngx_http_v2_huff_decode.c,ending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
249,8662,ngx_set_inherited_sockets,1,ngx_set_inherited_sockets,ngx_int_t ngx_set_inherited_sockets (ngx_cycle_t*),core\ngx_connection.c,"ngx_int_t
ngx_set_inherited_sockets(ngx_cycle_t *cycle)
{
    size_t                     len;
    ngx_uint_t                 i;
    ngx_listening_t           *ls;
    socklen_t                  olen;
#if (NGX_HAVE_DEFERRED_ACCEPT || NGX_HAVE_TCP_FASTOPEN)
    ngx_err_t                  err;
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
    struct accept_filter_arg   af;
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)
    int                        timeout;
#endif
#if (NGX_HAVE_REUSEPORT)
    int                        reuseport;
#endif

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        ls[i].sockaddr = ngx_palloc(cycle->pool, sizeof(ngx_sockaddr_t));
        if (ls[i].sockaddr == NULL) {
            return NGX_ERROR;
        }

        ls[i].socklen = sizeof(ngx_sockaddr_t);
        if (getsockname(ls[i].fd, ls[i].sockaddr, &ls[i].socklen) == -1) {
            ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_s...",134.0,403.0,1.0,1.0,270.0,143,14,126,21,0,8,17,22,0,8,,0,3,2,1,1,ngx_int_t
250,401880,ngx_write_fd,1,ngx_write_fd,"ANY ngx_write_fd (ngx_fd_t,void*,size_t)",os\win32\ngx_files.c,"ssize_t
ngx_write_fd(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    if (WriteFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",177.0,187.0,1.0,1.0,11.0,0,0,3,3,4,0,1,1,0,0,,0,0,6,3,3,ssize_t
251,405977,ngx_debug_point,1,ngx_debug_point,void ngx_debug_point (void),os\unix\ngx_process.c,"void
ngx_debug_point(void)
{
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,
                                           ngx_core_module);

    switch (ccf->debug_points) {

    case NGX_DEBUG_POINTS_STOP:
        raise(SIGSTOP);
        break;

    case NGX_DEBUG_POINTS_ABORT:
        ngx_abort();
    }
}",611.0,628.0,1.0,1.0,18.0,4,3,7,6,1,1,3,2,1,0,,0,1,2,1,1,void
252,16376,ngx_create_full_path,1,ngx_create_full_path,"ngx_err_t ngx_create_full_path (u_char*,ngx_uint_t)",core\ngx_file.c,"ngx_err_t
ngx_create_full_path(u_char *dir, ngx_uint_t access)
{
    u_char     *p, ch;
    ngx_err_t   err;

    err = 0;

#if (NGX_WIN32)
    p = dir + 3;
#else
    p = dir + 1;
#endif

    for ( /* void */ ; *p; p++) {
        ch = *p;

        if (ch != '/') {
            continue;
        }

        *p = '\0';

        if (ngx_create_dir(dir, access) == NGX_FILE_ERROR) {
            err = ngx_errno;

            switch (err) {
            case NGX_EEXIST:
                err = 0;
            case NGX_EACCES:
                break;

            default:
                return err;
            }
        }

        *p = '/';
    }

    return err;
}",303.0,344.0,1.0,1.0,42.0,14,5,20,9,1,0,7,9,0,0,,0,0,4,2,2,ngx_err_t
253,160227,ngx_http_limit_req_module,2,http\modules\ngx_http_limit_req_module.c.ngx_http_limit_req_module,,http\modules\ngx_http_limit_req_module.c,ngx_module_t ngx_http_limit_req_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
254,29166,ngx_module_index,1,ngx_module_index,ngx_uint_t ngx_module_index (ngx_cycle_t*),core\ngx_module.c,"static ngx_uint_t
ngx_module_index(ngx_cycle_t *cycle)
{
    ngx_uint_t     i, index;
    ngx_module_t  *module;

    index = 0;

again:

    /* find an unused index */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->index == index) {
            index++;
            goto again;
        }
    }

    /* check previous cycle */

    if (cycle->old_cycle && cycle->old_cycle->modules) {

        for (i = 0; cycle->old_cycle->modules[i]; i++) {
            module = cycle->old_cycle->modules[i];

            if (module->index == index) {
                index++;
                goto again;
            }
        }
    }

    return index;
}",279.0,315.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_uint_t
255,29171,ngx_module_ctx_index,1,ngx_module_ctx_index,"ngx_uint_t ngx_module_ctx_index (ngx_cycle_t*,ngx_uint_t,ngx_uint_t)",core\ngx_module.c,"static ngx_uint_t
ngx_module_ctx_index(ngx_cycle_t *cycle, ngx_uint_t type, ngx_uint_t index)
{
    ngx_uint_t     i;
    ngx_module_t  *module;

again:

    /* find an unused ctx_index */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->type != type) {
            continue;
        }

        if (module->ctx_index == index) {
            index++;
            goto again;
        }
    }

    /* check previous cycle */

    if (cycle->old_cycle && cycle->old_cycle->modules) {

        for (i = 0; cycle->old_cycle->modules[i]; i++) {
            module = cycle->old_cycle->modules[i];

            if (module->type != type) {
                continue;
            }

            if (module->ctx_index == index) {
                index++;
                goto again;
            }
        }
    }

    return index;
}",318.0,360.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_uint_t
256,270838,ngx_http_file_cache_init,1,ngx_http_file_cache_init,"ngx_int_t ngx_http_file_cache_init (ngx_shm_zone_t*,void*)",http\ngx_http_file_cache.c,"static ngx_int_t
ngx_http_file_cache_init(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_file_cache_t  *ocache = data;

    size_t                  len;
    ngx_uint_t              n;
    ngx_http_file_cache_t  *cache;

    cache = shm_zone->data;

    if (ocache) {
        if (ngx_strcmp(cache->path->name.data, ocache->path->name.data) != 0) {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""cache \""%V\"" uses the \""%V\"" cache path ""
                          ""while previously it used the \""%V\"" cache path"",
                          &shm_zone->shm.name, &cache->path->name,
                          &ocache->path->name);

            return NGX_ERROR;
        }

        for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
            if (cache->path->level[n] != ocache->path->level[n]) {
                ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                              ""cache \""%V\"" had previously different levels"",
                ...",82.0,172.0,1.0,1.0,91.0,139,15,80,13,0,7,9,14,0,7,,0,4,4,2,2,ngx_int_t
257,25080,ngx_log_set_log,1,ngx_log_set_log,"char* ngx_log_set_log (ngx_conf_t*,ngx_log_t**)",core\ngx_log.c,"char *
ngx_log_set_log(ngx_conf_t *cf, ngx_log_t **head)
{
    ngx_log_t          *new_log;
    ngx_str_t          *value, name;
    ngx_syslog_peer_t  *peer;

    if (*head != NULL && (*head)->log_level == 0) {
        new_log = *head;

    } else {

        new_log = ngx_pcalloc(cf->pool, sizeof(ngx_log_t));
        if (new_log == NULL) {
            return NGX_CONF_ERROR;
        }

        if (*head == NULL) {
            *head = new_log;
        }
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""stderr"") == 0) {
        ngx_str_null(&name);
        cf->cycle->log_use_stderr = 1;

        new_log->file = ngx_conf_open_file(cf->cycle, &name);
        if (new_log->file == NULL) {
            return NGX_CONF_ERROR;
        }

    } else if (ngx_strncmp(value[1].data, ""memory:"", 7) == 0) {

#if (NGX_DEBUG)
        size_t                 size, needed;
        ngx_pool_cleanup_t    *cln;
        ngx_log_memory_buf_t  *buf;

        value[1].len -= 7;
        valu...",555.0,676.0,1.0,1.0,122.0,28,9,25,8,0,3,6,7,1,3,,0,2,4,2,2,char*
258,29178,ngx_max_module,2,core\ngx_module.c.ngx_max_module,,core\ngx_module.c,ngx_uint_t ngx_max_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
259,29179,ngx_modules_n,2,core\ngx_module.c.ngx_modules_n,,core\ngx_module.c,ngx_uint_t ngx_modules_n,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
260,29180,ngx_preinit_modules,1,ngx_preinit_modules,ngx_int_t ngx_preinit_modules (void),core\ngx_module.c,"ngx_int_t
ngx_preinit_modules(void)
{
    ngx_uint_t  i;

    for (i = 0; ngx_modules[i]; i++) {
        ngx_modules[i]->index = i;
        ngx_modules[i]->name = ngx_module_names[i];
    }

    ngx_modules_n = i;
    ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES;

    return NGX_OK;
}",25.0,39.0,1.0,37.0,15.0,12,4,15,6,1,3,2,2,0,0,,0,3,2,1,1,ngx_int_t
261,401922,ngx_de_info,1,ngx_de_info,"ANY ngx_de_info (u_char*,ngx_dir_t*)",os\win32\ngx_files.c,"ngx_int_t
ngx_de_info(u_char *name, ngx_dir_t *dir)
{
    return NGX_OK;
}",607.0,611.0,1.0,1.0,5.0,5,4,3,2,3,2,1,1,0,0,,0,2,4,2,2,ngx_int_t
262,262666,ngx_http_output_filter,1,ngx_http_output_filter,"ngx_int_t ngx_http_output_filter (ngx_http_request_t*,ngx_chain_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_output_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t          rc;
    ngx_connection_t  *c;

    c = r->connection;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http output filter \""%V?%V\"""", &r->uri, &r->args);

    rc = ngx_http_top_body_filter(r, in);

    if (rc == NGX_ERROR) {
        /* NGX_ERROR may be returned by any filter */
        c->error = 1;
    }

    return rc;
}",1835.0,1854.0,1.0,1.0,20.0,11,4,13,6,3,0,2,2,0,0,,0,0,4,2,2,ngx_int_t
263,160271,ngx_http_limit_req_handler,1,ngx_http_limit_req_handler,ngx_int_t ngx_http_limit_req_handler (ngx_http_request_t*),http\modules\ngx_http_limit_req_module.c,"static ngx_int_t
ngx_http_limit_req_handler(ngx_http_request_t *r)
{
    uint32_t                     hash;
    ngx_str_t                    key;
    ngx_int_t                    rc;
    ngx_uint_t                   n, excess;
    ngx_msec_t                   delay;
    ngx_http_limit_req_ctx_t    *ctx;
    ngx_http_limit_req_conf_t   *lrcf;
    ngx_http_limit_req_limit_t  *limit, *limits;

    if (r->main->limit_req_status) {
        return NGX_DECLINED;
    }

    lrcf = ngx_http_get_module_loc_conf(r, ngx_http_limit_req_module);
    limits = lrcf->limits.elts;

    excess = 0;

    rc = NGX_DECLINED;

#if (NGX_SUPPRESS_WARN)
    limit = NULL;
#endif

    for (n = 0; n < lrcf->limits.nelts; n++) {

        limit = &limits[n];

        ctx = limit->shm_zone->data;

        if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (key.len > 65535) ...",192.0,335.0,1.0,40.0,144.0,135,16,111,22,0,39,21,26,9,12,,0,32,2,1,1,ngx_int_t
264,29225,ngx_cycle_modules,1,ngx_cycle_modules,ngx_int_t ngx_cycle_modules (ngx_cycle_t*),core\ngx_module.c,"ngx_int_t
ngx_cycle_modules(ngx_cycle_t *cycle)
{
    /*
     * create a list of modules to be used for this cycle,
     * copy static modules to it
     */

    cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1)
                                              * sizeof(ngx_module_t *));
    if (cycle->modules == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(cycle->modules, ngx_modules,
               ngx_modules_n * sizeof(ngx_module_t *));

    cycle->modules_n = ngx_modules_n;

    return NGX_OK;
}",42.0,62.0,1.0,1.0,21.0,13,6,14,8,1,4,2,2,0,1,,0,4,2,1,1,ngx_int_t
265,115245,sbrk_size,3,ngx_http_degradation_main_conf_t.sbrk_size,,http\modules\ngx_http_degradation_module.c,sbrk_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
266,115248,degrade,3,ngx_http_degradation_loc_conf_t.degrade,,http\modules\ngx_http_degradation_module.c,degrade,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
267,262711,ngx_http_map_uri_to_path,1,ngx_http_map_uri_to_path,"u_char ngx_http_map_uri_to_path (ngx_http_request_t*,ngx_str_t*,size_t*,size_t)",http\ngx_http_core_module.c,"u_char *
ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *path,
    size_t *root_length, size_t reserved)
{
    u_char                    *last;
    size_t                     alias;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    alias = clcf->alias;

    if (alias && !r->valid_location) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""\""alias\"" cannot be used in location \""%V\"" ""
                      ""where URI was rewritten"", &clcf->name);
        return NULL;
    }

    if (clcf->root_lengths == NULL) {

        *root_length = clcf->root.len;

        path->len = clcf->root.len + reserved + r->uri.len - alias + 1;

        path->data = ngx_pnalloc(r->pool, path->len);
        if (path->data == NULL) {
            return NULL;
        }

        last = ngx_copy(path->data, clcf->root.data, clcf->root.len);

    } else {

        if (alias == NGX_MAX_SIZE_T_VALUE) {
        ...",1857.0,1928.0,1.0,1.0,72.0,47,10,38,10,5,8,4,5,1,2,,0,7,8,4,4,u_char
268,229956,ngx_http_sub_filter_module,2,http\modules\ngx_http_sub_filter_module.c.ngx_http_sub_filter_module,,http\modules\ngx_http_sub_filter_module.c,ngx_module_t ngx_http_sub_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
269,254534,ngx_http_add_location,1,ngx_http_add_location,"ngx_int_t ngx_http_add_location (ngx_conf_t*,ngx_queue_t**,ngx_http_core_loc_conf_t*)",http\ngx_http.c,"ngx_int_t
ngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations,
    ngx_http_core_loc_conf_t *clcf)
{
    ngx_http_location_queue_t  *lq;

    if (*locations == NULL) {
        *locations = ngx_palloc(cf->temp_pool,
                                sizeof(ngx_http_location_queue_t));
        if (*locations == NULL) {
            return NGX_ERROR;
        }

        ngx_queue_init(*locations);
    }

    lq = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t));
    if (lq == NULL) {
        return NGX_ERROR;
    }

    if (clcf->exact_match
#if (NGX_PCRE)
        || clcf->regex
#endif
        || clcf->named || clcf->noname)
    {
        lq->exact = clcf;
        lq->inclusive = NULL;

    } else {
        lq->exact = NULL;
        lq->inclusive = clcf;
    }

    lq->name = &clcf->name;
    lq->file_name = cf->conf_file->file.name.data;
    lq->line = cf->conf_file->line;

    ngx_queue_init(&lq->list);

    ngx_queue_insert_tail(*locations, &lq->queue);

    return...",842.0,886.0,1.0,1.0,45.0,41,8,32,8,0,9,5,6,0,2,,0,9,6,3,3,ngx_int_t
270,258638,ngx_http_get_forwarded_addr_internal,1,ngx_http_get_forwarded_addr_internal,"ngx_int_t ngx_http_get_forwarded_addr_internal (ngx_http_request_t*,ngx_addr_t*,u_char*,size_t,ngx_array_t*,int)",http\ngx_http_core_module.c,"static ngx_int_t
ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,
    u_char *xff, size_t xfflen, ngx_array_t *proxies, int recursive)
{
    u_char      *p;
    ngx_addr_t   paddr;
    ngx_uint_t   found;

    found = 0;

    do {

        if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {
            return found ? NGX_DONE : NGX_DECLINED;
        }

        for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {
            if (*p != ' ' && *p != ',') {
                break;
            }
        }

        for ( /* void */ ; p > xff; p--) {
            if (*p == ' ' || *p == ',') {
                p++;
                break;
            }
        }

        if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff))
            != NGX_OK)
        {
            return found ? NGX_DONE : NGX_DECLINED;
        }

        *addr = paddr;
        found = 1;
        xfflen = p - 1 - xff;

    } while (recursive && p > xff);

    return NGX_OK;
}",2743.0,2785.0,1.0,1.0,43.0,0,0,0,0,2,0,1,1,0,0,,0,0,12,6,6,ngx_int_t
271,16981,ngx_add_path,1,ngx_add_path,"ngx_int_t ngx_add_path (ngx_conf_t*,ngx_path_t**)",core\ngx_file.c,"ngx_int_t
ngx_add_path(ngx_conf_t *cf, ngx_path_t **slot)
{
    ngx_uint_t   i, n;
    ngx_path_t  *path, **p;

    path = *slot;

    p = cf->cycle->paths.elts;
    for (i = 0; i < cf->cycle->paths.nelts; i++) {
        if (p[i]->name.len == path->name.len
            && ngx_strcmp(p[i]->name.data, path->name.data) == 0)
        {
            if (p[i]->data != path->data) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""the same path name \""%V\"" ""
                                   ""used in %s:%ui and"",
                                   &p[i]->name, p[i]->conf_file, p[i]->line);
                return NGX_ERROR;
            }

            for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
                if (p[i]->level[n] != path->level[n]) {
                    if (path->conf_file == NULL) {
                        if (p[i]->conf_file == NULL) {
                            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                            ...",525.0,594.0,1.0,1.0,70.0,81,10,76,11,2,10,11,30,5,5,,0,6,4,2,2,ngx_int_t
272,29269,ngx_init_modules,1,ngx_init_modules,ngx_int_t ngx_init_modules (ngx_cycle_t*),core\ngx_module.c,"ngx_int_t
ngx_init_modules(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->init_module) {
            if (cycle->modules[i]->init_module(cycle) != NGX_OK) {
                return NGX_ERROR;
            }
        }
    }

    return NGX_OK;
}",65.0,79.0,1.0,1.0,15.0,10,4,11,4,1,0,4,7,0,0,,0,0,2,1,1,ngx_int_t
273,229975,ngx_http_sub_header_filter,1,ngx_http_sub_header_filter,ngx_int_t ngx_http_sub_header_filter (ngx_http_request_t*),http\modules\ngx_http_sub_filter_module.c,"static ngx_int_t
ngx_http_sub_header_filter(ngx_http_request_t *r)
{
    ngx_str_t                *m;
    ngx_uint_t                i, j, n;
    ngx_http_sub_ctx_t       *ctx;
    ngx_http_sub_pair_t      *pairs;
    ngx_http_sub_match_t     *matches;
    ngx_http_sub_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_sub_filter_module);

    if (slcf->pairs == NULL
        || r->headers_out.content_length_n == 0
        || ngx_http_test_content_type(r, &slcf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_sub_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (slcf->dynamic == 0) {
        ctx->tables = slcf->tables;
        ctx->matches = slcf->matches;

    } else {
        pairs = slcf->pairs->elts;
        n = slcf->pairs->nelts;

        matches = ngx_pcalloc(r->pool, sizeof(ngx_http_sub_match_t) * n);
        if (matches == NULL) {
            return NGX_ERROR...",170.0,281.0,1.0,1.0,112.0,58,9,48,7,0,25,8,9,7,4,,0,25,2,1,1,ngx_int_t
274,340567,ngx_http_v2_close_stream,1,ngx_http_v2_close_stream,"void ngx_http_v2_close_stream (ngx_http_v2_stream_t*,ngx_int_t)",http\v2\ngx_http_v2.c,"void
ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc)
{
    ngx_pool_t                *pool;
    ngx_uint_t                 push;
    ngx_event_t               *ev;
    ngx_connection_t          *fc;
    ngx_http_v2_node_t        *node;
    ngx_http_v2_connection_t  *h2c;

    h2c = stream->connection;
    node = stream->node;

    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 close stream %ui, queued %ui, ""
                   ""processing %ui, pushing %ui"",
                   node->id, stream->queued, h2c->processing, h2c->pushing);

    fc = stream->request->connection;

    if (stream->queued) {
        fc->error = 1;
        fc->write->handler = ngx_http_v2_retry_close_stream_handler;
        fc->read->handler = ngx_http_v2_retry_close_stream_handler;
        return;
    }

    if (!stream->rst_sent && !h2c->connection->error) {

        if (!stream->out_closed) {
            if (ngx_http_v2_send_rst_stream(h2c, node->id...",4270.0,4387.0,1.0,53.0,118.0,91,14,72,13,1,3,13,16,1,3,,0,1,4,2,2,void
275,86619,ngx_ssl_preserve_passwords,1,ngx_ssl_preserve_passwords,"ngx_array_t ngx_ssl_preserve_passwords (ngx_conf_t*,ngx_array_t*)",event\ngx_event_openssl.c,"ngx_array_t *
ngx_ssl_preserve_passwords(ngx_conf_t *cf, ngx_array_t *passwords)
{
    ngx_str_t           *opwd, *pwd;
    ngx_uint_t           i;
    ngx_array_t         *pwds;
    ngx_pool_cleanup_t  *cln;
    static ngx_array_t   empty_passwords;

    if (passwords == NULL) {

        /*
         * If there are no passwords, an empty array is used
         * to make sure OpenSSL's default password callback
         * won't block on reading from stdin.
         */

        return &empty_passwords;
    }

    /*
     * Passwords are normally allocated from the temporary pool
     * and cleared after parsing configuration.  To be used at
     * runtime they have to be copied to the configuration pool.
     */

    pwds = ngx_array_create(cf->pool, passwords->nelts, sizeof(ngx_str_t));
    if (pwds == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_ssl_passwords_cleanup;
    cl...",1242.0,1302.0,1.0,1.0,61.0,38,9,45,11,0,13,7,9,2,4,,0,13,4,2,2,ngx_array_t
276,111200,free,3,ngx_http_chunked_filter_ctx_t.free,,http\modules\ngx_http_chunked_filter_module.c,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
277,111201,busy,3,ngx_http_chunked_filter_ctx_t.busy,,http\modules\ngx_http_chunked_filter_module.c,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
278,111202,ngx_http_chunked_filter_ctx_t,2,http\modules\ngx_http_chunked_filter_module.c.ngx_http_chunked_filter_ctx_t,,http\modules\ngx_http_chunked_filter_module.c,struct ngx_http_chunked_filter_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
279,414307,ngx_close_dir,1,ngx_close_dir,ngx_int_t ngx_close_dir (ngx_dir_t*),os\win32\ngx_files.c,"ngx_int_t
ngx_close_dir(ngx_dir_t *dir)
{
    if (FindClose(dir->dir) == 0) {
        return NGX_ERROR;
    }

    return NGX_OK;
}",479.0,487.0,1.0,1.0,9.0,2,2,3,3,4,1,2,2,1,0,,0,1,2,1,1,ngx_int_t
280,111208,ngx_http_chunked_create_trailers,1,ngx_http_chunked_create_trailers,"ngx_chain_t* ngx_http_chunked_create_trailers (ngx_http_request_t*,ngx_http_chunked_filter_ctx_t*)",http\modules\ngx_http_chunked_filter_module.c,"static ngx_chain_t *
ngx_http_chunked_create_trailers(ngx_http_request_t *r,
    ngx_http_chunked_filter_ctx_t *ctx)
{
    size_t            len;
    ngx_buf_t        *b;
    ngx_uint_t        i;
    ngx_chain_t      *cl;
    ngx_list_part_t  *part;
    ngx_table_elt_t  *header;

    len = 0;

    part = &r->headers_out.trailers.part;
    header = part->elts;

    for (i = 0; /* void */; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            header = part->elts;
            i = 0;
        }

        if (header[i].hash == 0) {
            continue;
        }

        len += header[i].key.len + sizeof("": "") - 1
               + header[i].value.len + sizeof(CRLF) - 1;
    }

    cl = ngx_chain_get_free_buf(r->pool, &ctx->free);
    if (cl == NULL) {
        return NULL;
    }

    b = cl->buf;

    b->tag = (ngx_buf_tag_t) &ngx_http_chunked_filter_module;
    b->temporary = 0;
    b-...",228.0,328.0,1.0,1.0,101.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_chain_t
281,152178,filter,3,ngx_http_image_filter_conf_t.filter,,http\modules\ngx_http_image_filter_module.c,filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
282,463481,ngx_stream_variable_depth,2,stream\ngx_stream_variables.c.ngx_stream_variable_depth,,stream\ngx_stream_variables.c,ngx_uint_t ngx_stream_variable_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
283,111226,ngx_http_chunked_filter_module,2,http\modules\ngx_http_chunked_filter_module.c.ngx_http_chunked_filter_module,,http\modules\ngx_http_chunked_filter_module.c,ngx_module_t ngx_http_chunked_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
284,463485,ngx_stream_add_variable,1,ngx_stream_add_variable,"ngx_stream_variable_t ngx_stream_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)",stream\ngx_stream_variables.c,"ngx_stream_variable_t *
ngx_stream_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_int_t                     rc;
    ngx_uint_t                    i;
    ngx_hash_key_t               *key;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NULL;
    }

    if (flags & NGX_STREAM_VAR_PREFIX) {
        return ngx_stream_add_prefix_variable(cf, name, flags);
    }

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    key = cmcf->variables_keys->keys.elts;
    for (i = 0; i < cmcf->variables_keys->keys.nelts; i++) {
        if (name->len != key[i].key.len
            || ngx_strncasecmp(name->data, key[i].key.data, name->len) != 0)
        {
            continue;
        }

        v = key[i].value;

        if (!(v->flags & NGX_STREAM_VAR_CHANGEABLE)) {
      ...",137.0,213.0,1.0,1.0,77.0,71,13,77,17,1,20,12,14,6,9,,0,15,6,3,3,ngx_stream_variable_t
285,389760,auth_methods,3,ngx_mail_pop3_srv_conf_t.auth_methods,,mail\ngx_mail_pop3_module.h,auth_methods,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
286,152193,buffer_size,3,ngx_http_image_filter_conf_t.buffer_size,,http\modules\ngx_http_image_filter_module.c,buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
287,29314,ngx_count_modules,1,ngx_count_modules,"ngx_int_t ngx_count_modules (ngx_cycle_t*,ngx_uint_t)",core\ngx_module.c,"ngx_int_t
ngx_count_modules(ngx_cycle_t *cycle, ngx_uint_t type)
{
    ngx_uint_t     i, next, max;
    ngx_module_t  *module;

    next = 0;
    max = 0;

    /* count appropriate modules, set up their indices */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->type != type) {
            continue;
        }

        if (module->ctx_index != NGX_MODULE_UNSET_INDEX) {

            /* if ctx_index was assigned, preserve it */

            if (module->ctx_index > max) {
                max = module->ctx_index;
            }

            if (module->ctx_index == next) {
                next++;
            }

            continue;
        }

        /* search for some free index */

        module->ctx_index = ngx_module_ctx_index(cycle, type, next);

        if (module->ctx_index > max) {
            max = module->ctx_index;
        }

        next = module->ctx_index + 1;
    }

    /*
     * make sure the number returned is big enoug...",82.0,153.0,1.0,1.0,72.0,49,9,45,7,0,1,14,23,0,1,,0,1,4,2,2,ngx_int_t
288,152198,length,3,ngx_http_image_filter_ctx_t.length,,http\modules\ngx_http_image_filter_module.c,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
289,406152,ngx_start_worker_processes,1,ngx_start_worker_processes,"void ngx_start_worker_processes (ngx_cycle_t*,ngx_int_t,ngx_int_t)",os\win32\ngx_process_cycle.c,"static ngx_int_t
ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t type)
{
    ngx_int_t         n;
    ngx_core_conf_t  *ccf;

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""start worker processes"");

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    for (n = 0; n < ccf->worker_processes; n++) {
        if (ngx_spawn_process(cycle, ""worker"", type) == NGX_INVALID_PID) {
            break;
        }
    }

    return n;
}",367.0,384.0,1.0,1.0,18.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
290,57993,bytes,3,ngx_sha1_t.bytes,,core\ngx_sha1.h,bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
291,115338,ngx_http_degradation_module,2,http\modules\ngx_http_degradation_module.c.ngx_http_degradation_module,,http\modules\ngx_http_degradation_module.c,ngx_module_t ngx_http_degradation_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
292,57994,a,3,ngx_sha1_t.a,,core\ngx_sha1.h,a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
293,57996,c,3,ngx_sha1_t.c,,core\ngx_sha1.h,c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
294,57997,d,3,ngx_sha1_t.d,,core\ngx_sha1.h,d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
295,57998,e,3,ngx_sha1_t.e,,core\ngx_sha1.h,e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
296,57995,b,3,ngx_sha1_t.b,,core\ngx_sha1.h,b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
297,58000,buffer,3,ngx_sha1_t.buffer,,core\ngx_sha1.h,buffer[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
298,152204,phase,3,ngx_http_image_filter_ctx_t.phase,,http\modules\ngx_http_image_filter_module.c,phase,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
299,111245,ngx_http_chunked_header_filter,1,ngx_http_chunked_header_filter,ngx_int_t ngx_http_chunked_header_filter (ngx_http_request_t*),http\modules\ngx_http_chunked_filter_module.c,"static ngx_int_t
ngx_http_chunked_header_filter(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t       *clcf;
    ngx_http_chunked_filter_ctx_t  *ctx;

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED
        || r->headers_out.status == NGX_HTTP_NO_CONTENT
        || r->headers_out.status < NGX_HTTP_OK
        || r != r->main
        || r->method == NGX_HTTP_HEAD)
    {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_out.content_length_n == -1
        || r->expect_trailers)
    {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (r->http_version >= NGX_HTTP_VERSION_11
            && clcf->chunked_transfer_encoding)
        {
            if (r->expect_trailers) {
                ngx_http_clear_content_length(r);
            }

            r->chunked = 1;

            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));
            if (ctx == NULL) {
                return NGX_ERROR;
            }

     ...",59.0,101.0,1.0,1.0,43.0,35,11,32,13,0,3,6,11,0,1,,0,3,2,1,1,ngx_int_t
300,152205,type,3,ngx_http_image_filter_ctx_t.type,,http\modules\ngx_http_image_filter_module.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
301,406159,ngx_start_cache_manager_processes,1,ngx_start_cache_manager_processes,"void ngx_start_cache_manager_processes (ngx_cycle_t*,ngx_uint_t)",os\unix\ngx_process_cycle.c,"static void
ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)
{
    ngx_uint_t       i, manager, loader;
    ngx_path_t     **path;
    ngx_channel_t    ch;

    manager = 0;
    loader = 0;

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) {

        if (path[i]->manager) {
            manager = 1;
        }

        if (path[i]->loader) {
            loader = 1;
        }
    }

    if (manager == 0) {
        return;
    }

    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,
                      &ngx_cache_manager_ctx, ""cache manager process"",
                      respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_OPEN_CHANNEL;
    ch.pid = ngx_processes[ngx_process_slot].pid;
    ch.slot = ngx_process_slot;
    ch.fd = ngx_processes[ngx_process_slot].channel[0];

    ngx_pass_open_channel(cycle, &ch);

    if (loader == 0) {
      ...",371.0,424.0,1.0,1.0,54.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
302,152207,ngx_http_image_filter_ctx_t,2,http\modules\ngx_http_image_filter_module.c.ngx_http_image_filter_ctx_t,,http\modules\ngx_http_image_filter_module.c,struct ngx_http_image_filter_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
303,152208,ngx_http_image_send,1,ngx_http_image_send,"ngx_int_t ngx_http_image_send (ngx_http_request_t*,ngx_http_image_filter_ctx_t*,ngx_chain_t*)",http\modules\ngx_http_image_filter_module.c,"static ngx_int_t
ngx_http_image_send(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx,
    ngx_chain_t *in)
{
    ngx_int_t  rc;

    rc = ngx_http_next_header_filter(r);

    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
        return NGX_ERROR;
    }

    rc = ngx_http_next_body_filter(r, in);

    if (ctx->phase == NGX_HTTP_IMAGE_DONE) {
        /* NGX_ERROR resets any pending data */
        return (rc == NGX_OK) ? NGX_ERROR : rc;
    }

    return rc;
}",400.0,420.0,1.0,22.0,21.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
304,152215,ngx_http_image_test,1,ngx_http_image_test,"ngx_uint_t ngx_http_image_test (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_image_filter_module.c,"static ngx_uint_t
ngx_http_image_test(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char  *p;

    p = in->buf->pos;

    if (in->buf->last - p < 16) {
        return NGX_HTTP_IMAGE_NONE;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""image filter: \""%c%c\"""", p[0], p[1]);

    if (p[0] == 0xff && p[1] == 0xd8) {

        /* JPEG */

        return NGX_HTTP_IMAGE_JPEG;

    } else if (p[0] == 'G' && p[1] == 'I' && p[2] == 'F' && p[3] == '8'
               && p[5] == 'a')
    {
        if (p[4] == '9' || p[4] == '7') {
            /* GIF */
            return NGX_HTTP_IMAGE_GIF;
        }

    } else if (p[0] == 0x89 && p[1] == 'P' && p[2] == 'N' && p[3] == 'G'
               && p[4] == 0x0d && p[5] == 0x0a && p[6] == 0x1a && p[7] == 0x0a)
    {
        /* PNG */

        return NGX_HTTP_IMAGE_PNG;

    } else if (p[0] == 'R' && p[1] == 'I' && p[2] == 'F' && p[3] == 'F'
               && p[8] == 'W' && p[9] == 'E' && p[10] == 'B' && p[11] ==...",423.0,467.0,1.0,15.0,45.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_uint_t
305,400674,ngx_writev_file,1,ngx_writev_file,"ssize_t ngx_writev_file (ngx_file_t*,ngx_iovec_t*,off_t)",os\unix\ngx_files.c,"static ssize_t
ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec, off_t offset)
{
    ssize_t    n;
    ngx_err_t  err;

    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""writev: %d, %uz, %O"", file->fd, vec->size, offset);

#if (NGX_HAVE_PWRITEV)

eintr:

    n = pwritev(file->fd, vec->iovs, vec->count, offset);

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_EINTR) {
            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
                           ""pwritev() was interrupted"");
            goto eintr;
        }

        ngx_log_error(NGX_LOG_CRIT, file->log, err,
                      ""pwritev() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    if ((size_t) n != vec->size) {
        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
                      ""pwritev() \""%s\"" has written only %z of %uz"",
                      file->name.data, n, vec->size);
        return NGX_ERROR;
    }

#else

    if (file->sys_offset !...",391.0,471.0,1.0,1.0,81.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ssize_t
306,115355,ngx_http_degradation_handler,1,ngx_http_degradation_handler,ngx_int_t ngx_http_degradation_handler (ngx_http_request_t*),http\modules\ngx_http_degradation_module.c,"static ngx_int_t
ngx_http_degradation_handler(ngx_http_request_t *r)
{
    ngx_http_degradation_loc_conf_t  *dlcf;

    dlcf = ngx_http_get_module_loc_conf(r, ngx_http_degradation_module);

    if (dlcf->degrade && ngx_http_degraded(r)) {
        return dlcf->degrade;
    }

    return NGX_DECLINED;
}",90.0,102.0,1.0,1.0,13.0,4,3,7,4,0,4,2,2,2,1,,0,4,2,1,1,ngx_int_t
307,406171,ngx_signal_worker_processes,1,ngx_signal_worker_processes,"void ngx_signal_worker_processes (ngx_cycle_t*,int)",os\unix\ngx_process_cycle.c,"static void
ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo)
{
    ngx_int_t      i;
    ngx_err_t      err;
    ngx_channel_t  ch;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

#if (NGX_BROKEN_SCM_RIGHTS)

    ch.command = 0;

#else

    switch (signo) {

    case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):
        ch.command = NGX_CMD_QUIT;
        break;

    case ngx_signal_value(NGX_TERMINATE_SIGNAL):
        ch.command = NGX_CMD_TERMINATE;
        break;

    case ngx_signal_value(NGX_REOPEN_SIGNAL):
        ch.command = NGX_CMD_REOPEN;
        break;

    default:
        ch.command = 0;
    }

#endif

    ch.fd = -1;


    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""child: %i %P e:%d t:%d d:%d r:%d j:%d"",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                   ...",455.0,554.0,1.0,1.0,100.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,void
308,152221,ngx_http_image_read,1,ngx_http_image_read,"ngx_int_t ngx_http_image_read (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_image_filter_module.c,"static ngx_int_t
ngx_http_image_read(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char                       *p;
    size_t                        size, rest;
    ngx_buf_t                    *b;
    ngx_chain_t                  *cl;
    ngx_http_image_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx->image == NULL) {
        ctx->image = ngx_palloc(r->pool, ctx->length);
        if (ctx->image == NULL) {
            return NGX_ERROR;
        }

        ctx->last = ctx->image;
    }

    p = ctx->last;

    for (cl = in; cl; cl = cl->next) {

        b = cl->buf;
        size = b->last - b->pos;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""image buf: %uz"", size);

        rest = ctx->image + ctx->length - p;

        if (size > rest) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""image filter: too big response"");
            return NGX_ERR...",470.0,521.0,1.0,31.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
309,406177,ngx_reap_children,1,ngx_reap_children,ngx_uint_t ngx_reap_children (ngx_cycle_t*),os\unix\ngx_process_cycle.c,"static ngx_uint_t
ngx_reap_children(ngx_cycle_t *cycle)
{
    ngx_int_t         i, n;
    ngx_uint_t        live;
    ngx_channel_t     ch;
    ngx_core_conf_t  *ccf;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_CLOSE_CHANNEL;
    ch.fd = -1;

    live = 0;
    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""child: %i %P e:%d t:%d d:%d r:%d j:%d"",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                       ngx_processes[i].detached,
                       ngx_processes[i].respawn,
                       ngx_processes[i].just_spawn);

        if (ngx_processes[i].pid == -1) {
            continue;
        }

        if (ngx_processes[i].exited) {

            if (!ngx_processes[i].detached) {
                ngx_close_channel(ngx_processes[i].channel, c...",557.0,681.0,1.0,1.0,125.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_uint_t
310,152227,ngx_http_image_process,1,ngx_http_image_process,ngx_buf_t* ngx_http_image_process (ngx_http_request_t*),http\modules\ngx_http_image_filter_module.c,"static ngx_buf_t *
ngx_http_image_process(ngx_http_request_t *r)
{
    ngx_int_t                      rc;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    r->connection->buffered &= ~NGX_HTTP_IMAGE_BUFFERED;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    rc = ngx_http_image_size(r, ctx);

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf->filter == NGX_HTTP_IMAGE_SIZE) {
        return ngx_http_image_json(r, rc == NGX_OK ? ctx : NULL);
    }

    ctx->angle = ngx_http_image_filter_get_value(r, conf->acv, conf->angle);

    if (conf->filter == NGX_HTTP_IMAGE_ROTATE) {

        if (ctx->angle != 90 && ctx->angle != 180 && ctx->angle != 270) {
            return NULL;
        }

        return ngx_http_image_resize(r, ctx);
    }

    ctx->max_width = ngx_http_image_filter_get_value(r, conf->wcv, conf->width);
    if (ctx->max_width == 0) {
        return NULL;
    }

    ctx->max_heig...",524.0,575.0,1.0,32.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_buf_t
311,406182,ngx_master_process_exit,1,ngx_master_process_exit,void ngx_master_process_exit (ngx_cycle_t*),os\win32\ngx_process_cycle.c,"static void
ngx_master_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    ngx_delete_pidfile(cycle);

    ngx_close_handle(ngx_cache_manager_mutex);
    ngx_close_handle(ngx_stop_event);
    ngx_close_handle(ngx_quit_event);
    ngx_close_handle(ngx_reopen_event);
    ngx_close_handle(ngx_reload_event);
    ngx_close_handle(ngx_master_process_event);

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exit"");

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->exit_master) {
            cycle->modules[i]->exit_master(cycle);
        }
    }

    ngx_destroy_pool(cycle->pool);

    exit(0);
}",541.0,566.0,1.0,1.0,26.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
312,152232,ngx_http_image_json,1,ngx_http_image_json,"ngx_buf_t* ngx_http_image_json (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)",http\modules\ngx_http_image_filter_module.c,"static ngx_buf_t *
ngx_http_image_json(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    size_t      len;
    ngx_buf_t  *b;

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NULL;
    }

    b->memory = 1;
    b->last_buf = 1;

    ngx_http_clean_header(r);

    r->headers_out.status = NGX_HTTP_OK;
    r->headers_out.content_type_len = sizeof(""application/json"") - 1;
    ngx_str_set(&r->headers_out.content_type, ""application/json"");
    r->headers_out.content_type_lowcase = NULL;

    if (ctx == NULL) {
        b->pos = (u_char *) ""{}"" CRLF;
        b->last = b->pos + sizeof(""{}"" CRLF) - 1;

        ngx_http_image_length(r, b);

        return b;
    }

    len = sizeof(""{ \""img\"" : ""
                 ""{ \""width\"": , \""height\"": , \""type\"": \""jpeg\"" } }"" CRLF) - 1
          + 2 * NGX_SIZE_T_LEN;

    b->pos = ngx_pnalloc(r->pool, len);
    if (b->pos == NULL) {
        return NULL;
    }

    b->last = ngx_sprintf(b->pos,
                          ""...",578.0,628.0,1.0,1.0,51.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_buf_t
313,66219,str,3,ngx_str_node_t.str,,core\ngx_string.h,str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
314,58035,ngx_shmtx_create,1,ngx_shmtx_create,"ngx_int_t ngx_shmtx_create (ngx_shmtx_t*,ngx_shmtx_sh_t*,u_char*)",core\ngx_shmtx.c,"ngx_int_t
ngx_shmtx_create(ngx_shmtx_t *mtx, ngx_shmtx_sh_t *addr, u_char *name)
{
    if (mtx->name) {

        if (ngx_strcmp(name, mtx->name) == 0) {
            mtx->name = name;
            return NGX_OK;
        }

        ngx_shmtx_destroy(mtx);
    }

    mtx->fd = ngx_open_file(name, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,
                            NGX_FILE_DEFAULT_ACCESS);

    if (mtx->fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, ngx_cycle->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", name);
        return NGX_ERROR;
    }

    if (ngx_delete_file(name) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", name);
    }

    mtx->name = name;

    return NGX_OK;
}",202.0,232.0,1.0,1.0,31.0,12,3,20,9,0,8,5,6,3,2,,0,7,6,3,3,ngx_int_t
315,115380,ngx_http_degraded,1,ngx_http_degraded,ngx_uint_t ngx_http_degraded (ngx_http_request_t*),http\modules\ngx_http_degradation_module.c,"ngx_uint_t
ngx_http_degraded(ngx_http_request_t *r)
{
    time_t                             now;
    ngx_uint_t                         log;
    static size_t                      sbrk_size;
    static time_t                      sbrk_time;
    ngx_http_degradation_main_conf_t  *dmcf;

    dmcf = ngx_http_get_module_main_conf(r, ngx_http_degradation_module);

    if (dmcf->sbrk_size) {

        log = 0;
        now = ngx_time();

        /* lock mutex */

        if (now != sbrk_time) {

            /*
             * ELF/i386 is loaded at 0x08000000, 128M
             * ELF/amd64 is loaded at 0x00400000, 4M
             *
             * use a function address to subtract the loading address
             */

            sbrk_size = (size_t) sbrk(0) - ((uintptr_t) ngx_palloc & ~0x3FFFFF);
            sbrk_time = now;
            log = 1;
        }

        /* unlock mutex */

        if (sbrk_size >= dmcf->sbrk_size) {
            if (log) {
                ngx_log_error(NGX_LOG_NOTI...",105.0,151.0,1.0,1.0,47.0,19,10,19,9,1,4,5,9,2,1,,0,3,2,1,1,ngx_uint_t
316,299717,ngx_http_script_run,1,ngx_http_script_run,"u_char ngx_http_script_run (ngx_http_request_t*,ngx_str_t*,void*,size_t,void*)",http\ngx_http_script.c,"u_char *
ngx_http_script_run(ngx_http_request_t *r, ngx_str_t *value,
    void *code_lengths, size_t len, void *code_values)
{
    ngx_uint_t                    i;
    ngx_http_script_code_pt       code;
    ngx_http_script_len_code_pt   lcode;
    ngx_http_script_engine_t      e;
    ngx_http_core_main_conf_t    *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    for (i = 0; i < cmcf->variables.nelts; i++) {
        if (r->variables[i].no_cacheable) {
            r->variables[i].valid = 0;
            r->variables[i].not_found = 0;
        }
    }

    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));

    e.ip = code_lengths;
    e.request = r;
    e.flushed = 1;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_http_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }


    value->len = len;
    value->data = ngx_pnalloc(r->pool, len);
    if (value->data == NULL) {
        return NULL;
    }

    e.ip = code_values;
    e.pos = value->d...",576.0,622.0,1.0,1.0,47.0,55,11,41,13,0,16,6,7,4,1,,0,16,10,5,5,u_char
317,4806,ngx_conf_parse,1,ngx_conf_parse,"char* ngx_conf_parse (ngx_conf_t*,ngx_str_t*)",core\ngx_conf_file.c,"char *
ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)
{
    char             *rv;
    ngx_fd_t          fd;
    ngx_int_t         rc;
    ngx_buf_t         buf;
    ngx_conf_file_t  *prev, conf_file;
    enum {
        parse_file = 0,
        parse_block,
        parse_param
    } type;

#if (NGX_SUPPRESS_WARN)
    fd = NGX_INVALID_FILE;
    prev = NULL;
#endif

    if (filename) {

        /* open configuration file */

        fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

        if (fd == NGX_INVALID_FILE) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                               ngx_open_file_n "" \""%s\"" failed"",
                               filename->data);
            return NGX_CONF_ERROR;
        }

        prev = cf->conf_file;

        cf->conf_file = &conf_file;

        if (ngx_fd_info(fd, &cf->conf_file->file.info) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, ngx_errno,
                        ...",157.0,352.0,1.0,30.0,196.0,94,8,103,26,4,13,37,50,1,10,,0,8,4,2,2,char*
318,66254,ngx_syslog_parse_args,1,ngx_syslog_parse_args,"char* ngx_syslog_parse_args (ngx_conf_t*,ngx_syslog_peer_t*)",core\ngx_syslog.c,"static char *
ngx_syslog_parse_args(ngx_conf_t *cf, ngx_syslog_peer_t *peer)
{
    u_char      *p, *comma, c;
    size_t       len;
    ngx_str_t   *value;
    ngx_url_t    u;
    ngx_uint_t   i;

    value = cf->args->elts;

    p = value[1].data + sizeof(""syslog:"") - 1;

    for ( ;; ) {
        comma = (u_char *) ngx_strchr(p, ',');

        if (comma != NULL) {
            len = comma - p;
            *comma = '\0';

        } else {
            len = value[1].data + value[1].len - p;
        }

        if (ngx_strncmp(p, ""server="", 7) == 0) {

            if (peer->server.sockaddr != NULL) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""duplicate syslog \""server\"""");
                return NGX_CONF_ERROR;
            }

            ngx_memzero(&u, sizeof(ngx_url_t));

            u.url.data = p + 7;
            u.url.len = len - 7;
            u.default_port = 514;

            if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
         ...",88.0,230.0,1.0,1.0,143.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
319,320210,ngx_http_upstream_free_round_robin_peer,1,ngx_http_upstream_free_round_robin_peer,"void ngx_http_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)",http\ngx_http_upstream_round_robin.c,"void
ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = data;

    time_t                       now;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""free rr peer %ui %ui"", pc->tries, state);

    /* TODO: NGX_PEER_KEEPALIVE */

    peer = rrp->current;

    ngx_http_upstream_rr_peers_rlock(rrp->peers);
    ngx_http_upstream_rr_peer_lock(rrp->peers, peer);

    if (rrp->peers->single) {

        peer->conns--;

        ngx_http_upstream_rr_peer_unlock(rrp->peers, peer);
        ngx_http_upstream_rr_peers_unlock(rrp->peers);

        pc->tries = 0;
        return;
    }

    if (state & NGX_PEER_FAILED) {
        now = ngx_time();

        peer->fails++;
        peer->accessed = now;
        peer->checked = now;

        if (peer->max_fails) {
            peer->effective_weight -= peer->weight / peer->max_fails;

            i...",585.0,656.0,1.0,1.0,72.0,46,9,45,9,0,9,7,11,1,1,,0,8,6,3,3,void
320,62162,ngx_strcasecmp,1,ngx_strcasecmp,"ngx_int_t ngx_strcasecmp (u_char*,u_char*)",core\ngx_string.c,"ngx_int_t
ngx_strcasecmp(u_char *s1, u_char *s2)
{
    ngx_uint_t  c1, c2;

    for ( ;; ) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                continue;
            }

            return 0;
        }

        return c1 - c2;
    }
}",586.0,609.0,1.0,1.0,24.0,20,10,21,5,5,0,5,7,0,0,,0,0,4,2,2,ngx_int_t
321,66260,ngx_syslog_init_peer,1,ngx_syslog_init_peer,ngx_int_t ngx_syslog_init_peer (ngx_syslog_peer_t*),core\ngx_syslog.c,"static ngx_int_t
ngx_syslog_init_peer(ngx_syslog_peer_t *peer)
{
    ngx_socket_t  fd;

    fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);
    if (fd == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }

    if (ngx_nonblocking(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ngx_nonblocking_n "" failed"");
        goto failed;
    }

    if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ""connect() failed"");
        goto failed;
    }

    peer->conn.fd = fd;

    /* UDP sockets are always ready to write */
    peer->conn.write->ready = 1;

    return NGX_OK;

failed:

    if (ngx_close_socket(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
    ...",320.0,359.0,1.0,1.0,40.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
322,406229,ngx_reap,2,os\unix\ngx_process_cycle.c.ngx_reap,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_reap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
323,406231,ngx_sigalrm,2,os\unix\ngx_process_cycle.c.ngx_sigalrm,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_sigalrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
324,406232,ngx_terminate,2,os\unix\ngx_process_cycle.c.ngx_terminate,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_terminate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
325,406233,ngx_quit,2,os\unix\ngx_process_cycle.c.ngx_quit,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_quit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
326,406236,ngx_reconfigure,2,os\unix\ngx_process_cycle.c.ngx_reconfigure,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_reconfigure,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
327,406237,ngx_reopen,2,os\unix\ngx_process_cycle.c.ngx_reopen,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_reopen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
328,406238,ngx_change_binary,2,os\unix\ngx_process_cycle.c.ngx_change_binary,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_change_binary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
329,406239,ngx_new_binary,2,os\unix\ngx_process_cycle.c.ngx_new_binary,,os\unix\ngx_process_cycle.c,ngx_pid_t ngx_new_binary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
330,406242,ngx_noaccept,2,os\unix\ngx_process_cycle.c.ngx_noaccept,,os\unix\ngx_process_cycle.c,sig_atomic_t ngx_noaccept,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
331,406243,ngx_noaccepting,2,os\unix\ngx_process_cycle.c.ngx_noaccepting,,os\unix\ngx_process_cycle.c,ngx_uint_t ngx_noaccepting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
332,406244,ngx_restart,2,os\unix\ngx_process_cycle.c.ngx_restart,,os\unix\ngx_process_cycle.c,ngx_uint_t ngx_restart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
333,406245,master_process,2,os\unix\ngx_process_cycle.c.master_process,,os\unix\ngx_process_cycle.c,static u_char[] master_process,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
334,217516,ngx_http_ssi_filter_module,2,http\modules\ngx_http_ssi_filter_module.c.ngx_http_ssi_filter_module,,http\modules\ngx_http_ssi_filter_module.c,ngx_module_t ngx_http_ssi_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
335,217840,ngx_http_ssi_header_filter,1,ngx_http_ssi_header_filter,ngx_int_t ngx_http_ssi_header_filter (ngx_http_request_t*),http\modules\ngx_http_ssi_filter_module.c,"static ngx_int_t
ngx_http_ssi_header_filter(ngx_http_request_t *r)
{
    ngx_http_ssi_ctx_t       *ctx;
    ngx_http_ssi_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_ssi_filter_module);

    if (!slcf->enable
        || r->headers_out.content_length_n == 0
        || ngx_http_test_content_type(r, &slcf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_ssi_filter_module);


    ctx->value_len = slcf->value_len;
    ctx->last_out = &ctx->out;

    ctx->encoding = NGX_HTTP_SSI_ENTITY_ENCODING;
    ctx->output = 1;

    ctx->params.elts = ctx->params_array;
    ctx->params.size = sizeof(ngx_table_elt_t);
    ctx->params.nalloc = NGX_HTTP_SSI_PARAMS_N;
    ctx->params.pool = r->pool;

    ctx->timefmt = ngx_http_ssi_timefmt;
    ngx_str_set(&ctx->errmsg,
                ""[an error oc...",329.0,385.0,1.0,1.0,57.0,53,8,46,11,0,21,5,6,4,2,,0,21,2,1,1,ngx_int_t
336,58098,ngx_shmtx_destroy,1,ngx_shmtx_destroy,void ngx_shmtx_destroy (ngx_shmtx_t*),core\ngx_shmtx.c,"void
ngx_shmtx_destroy(ngx_shmtx_t *mtx)
{
    if (ngx_close_file(mtx->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", mtx->name);
    }
}",235.0,242.0,1.0,1.0,8.0,2,2,2,2,1,1,2,2,1,0,,0,1,2,1,1,void
337,99062,before_body,3,ngx_http_addition_conf_t.before_body,,http\modules\ngx_http_addition_filter_module.c,before_body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
338,99063,after_body,3,ngx_http_addition_conf_t.after_body,,http\modules\ngx_http_addition_filter_module.c,after_body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
339,99064,types,3,ngx_http_addition_conf_t.types,,http\modules\ngx_http_addition_filter_module.c,types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
340,406266,ngx_master_process_cycle,1,ngx_master_process_cycle,void ngx_master_process_cycle (ngx_cycle_t*),os\win32\ngx_process_cycle.c,"void
ngx_master_process_cycle(ngx_cycle_t *cycle)
{
    u_long      nev, ev, timeout;
    ngx_err_t   err;
    ngx_int_t   n;
    ngx_msec_t  timer;
    ngx_uint_t  live;
    HANDLE      events[MAXIMUM_WAIT_OBJECTS];

    ngx_sprintf((u_char *) ngx_master_process_event_name,
                ""ngx_master_%s%Z"", ngx_unique);

    if (ngx_process == NGX_PROCESS_WORKER) {
        ngx_worker_process_cycle(cycle, ngx_master_process_event_name);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, ""master started"");

    ngx_console_init(cycle);

    SetEnvironmentVariable(""ngx_unique"", ngx_unique);

    ngx_master_process_event = CreateEvent(NULL, 1, 0,
                                           ngx_master_process_event_name);
    if (ngx_master_process_event == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"",
                      ngx_master_process_event_name);
        exit(2);
    }

    if (n...",63.0,249.0,1.0,1.0,187.0,123,24,178,49,0,58,30,54,12,26,,0,37,2,1,1,void
341,99068,before_body_sent,3,ngx_http_addition_ctx_t.before_body_sent,,http\modules\ngx_http_addition_filter_module.c,before_body_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
342,99069,ngx_http_addition_ctx_t,2,http\modules\ngx_http_addition_filter_module.c.ngx_http_addition_ctx_t,,http\modules\ngx_http_addition_filter_module.c,struct ngx_http_addition_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
343,58112,ngx_shmtx_trylock,1,ngx_shmtx_trylock,ngx_uint_t ngx_shmtx_trylock (ngx_shmtx_t*),core\ngx_shmtx.c,"ngx_uint_t
ngx_shmtx_trylock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_trylock_fd(mtx->fd);

    if (err == 0) {
        return 1;
    }

    if (err == NGX_EAGAIN) {
        return 0;
    }

#if __osf__ /* Tru64 UNIX */

    if (err == NGX_EACCES) {
        return 0;
    }

#endif

    ngx_log_abort(err, ngx_trylock_fd_n "" %s failed"", mtx->name);

    return 0;
}",245.0,271.0,1.0,1.0,27.0,4,3,5,3,0,2,3,3,0,1,,0,2,2,1,1,ngx_uint_t
344,316163,ngx_http_upstream_add,1,ngx_http_upstream_add,"ngx_http_upstream_srv_conf_t ngx_http_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)",http\ngx_http_upstream.c,"ngx_http_upstream_srv_conf_t *
ngx_http_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags)
{
    ngx_uint_t                      i;
    ngx_http_upstream_server_t     *us;
    ngx_http_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_http_upstream_main_conf_t  *umcf;

    if (!(flags & NGX_HTTP_UPSTREAM_CREATE)) {

        if (ngx_parse_url(cf->pool, u) != NGX_OK) {
            if (u->err) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""%s in upstream \""%V\"""", u->err, &u->url);
            }

            return NULL;
        }
    }

    umcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_upstream_module);

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        if (uscfp[i]->host.len != u->host.len
            || ngx_strncasecmp(uscfp[i]->host.data, u->host.data, u->host.len)
               != 0)
        {
            continue;
        }

        if ((flags & NGX_HTTP_UPSTREAM_CREATE)
   ...",5992.0,6100.0,1.0,1.0,109.0,131,14,119,16,0,36,18,27,13,10,,0,32,6,3,3,ngx_http_upstream_srv_conf_t
345,66312,ngx_syslog_dummy_log,2,core\ngx_syslog.c.ngx_syslog_dummy_log,,core\ngx_syslog.c,ngx_log_t ngx_syslog_dummy_log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
346,66313,ngx_syslog_dummy_event,2,core\ngx_syslog.c.ngx_syslog_dummy_event,,core\ngx_syslog.c,ngx_event_t ngx_syslog_dummy_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
347,66314,ngx_syslog_process_conf,1,ngx_syslog_process_conf,"char* ngx_syslog_process_conf (ngx_conf_t*,ngx_syslog_peer_t*)",core\ngx_syslog.c,"char *
ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)
{
    ngx_pool_cleanup_t  *cln;

    peer->facility = NGX_CONF_UNSET_UINT;
    peer->severity = NGX_CONF_UNSET_UINT;

    if (ngx_syslog_parse_args(cf, peer) != NGX_CONF_OK) {
        return NGX_CONF_ERROR;
    }

    if (peer->server.sockaddr == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""no syslog server specified"");
        return NGX_CONF_ERROR;
    }

    if (peer->facility == NGX_CONF_UNSET_UINT) {
        peer->facility = 23; /* local7 */
    }

    if (peer->severity == NGX_CONF_UNSET_UINT) {
        peer->severity = 6; /* info */
    }

    if (peer->tag.data == NULL) {
        ngx_str_set(&peer->tag, ""nginx"");
    }

    peer->conn.fd = (ngx_socket_t) -1;

    peer->conn.read = &ngx_syslog_dummy_event;
    peer->conn.write = &ngx_syslog_dummy_event;

    ngx_syslog_dummy_event.log = &ngx_syslog_dummy_log;

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln...",39.0,85.0,1.0,1.0,47.0,43,7,40,12,0,19,7,7,5,3,,0,18,4,2,2,char*
348,111373,ngx_http_chunked_body_filter,1,ngx_http_chunked_body_filter,"ngx_int_t ngx_http_chunked_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_chunked_filter_module.c,"static ngx_int_t
ngx_http_chunked_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char                         *chunk;
    off_t                           size;
    ngx_int_t                       rc;
    ngx_buf_t                      *b;
    ngx_chain_t                    *out, *cl, *tl, **ll;
    ngx_http_chunked_filter_ctx_t  *ctx;

    if (in == NULL || !r->chunked || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_chunked_filter_module);

    out = NULL;
    ll = &out;

    size = 0;
    cl = in;

    for ( ;; ) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http chunk: %O"", ngx_buf_size(cl->buf));

        size += ngx_buf_size(cl->buf);

        if (cl->buf->flush
            || cl->buf->sync
            || ngx_buf_in_memory(cl->buf)
            || cl->buf->in_file)
        {
            tl = ngx_alloc_chain_link(r->pool);
            if (tl == NULL...",104.0,225.0,1.0,1.0,122.0,88,9,91,16,0,10,14,23,0,4,,0,9,4,2,2,ngx_int_t
349,86799,ngx_ssl_dhparam,1,ngx_ssl_dhparam,"ngx_int_t ngx_ssl_dhparam (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
{
    DH   *dh;
    BIO  *bio;

    if (file->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    bio = BIO_new_file((char *) file->data, ""r"");
    if (bio == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""BIO_new_file(\""%s\"") failed"", file->data);
        return NGX_ERROR;
    }

    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
    if (dh == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""PEM_read_bio_DHparams(\""%s\"") failed"", file->data);
        BIO_free(bio);
        return NGX_ERROR;
    }

    SSL_CTX_set_tmp_dh(ssl->ctx, dh);

    DH_free(dh);
    BIO_free(bio);

    return NGX_OK;
}",1321.0,1356.0,1.0,1.0,36.0,15,5,31,9,0,7,5,5,2,3,,0,5,6,3,3,ngx_int_t
350,90897,ngx_ssl_remove_cached_session,1,ngx_ssl_remove_cached_session,"void ngx_ssl_remove_cached_session (SSL_CTX*,ngx_ssl_session_t*)",event\ngx_event_openssl.c,"void
ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
{
    SSL_CTX_remove_session(ssl, sess);

    ngx_ssl_remove_session(ssl, sess);
}",3617.0,3623.0,1.0,1.0,7.0,0,0,4,2,0,1,1,1,0,1,,0,0,4,2,2,void
351,455442,ngx_stream_upstream_add,1,ngx_stream_upstream_add,"ngx_stream_upstream_srv_conf_t ngx_stream_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)",stream\ngx_stream_upstream.c,"ngx_stream_upstream_srv_conf_t *
ngx_stream_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags)
{
    ngx_uint_t                        i;
    ngx_stream_upstream_server_t     *us;
    ngx_stream_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_stream_upstream_main_conf_t  *umcf;

    if (!(flags & NGX_STREAM_UPSTREAM_CREATE)) {

        if (ngx_parse_url(cf->pool, u) != NGX_OK) {
            if (u->err) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""%s in upstream \""%V\"""", u->err, &u->url);
            }

            return NULL;
        }
    }

    umcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_upstream_module);

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        if (uscfp[i]->host.len != u->host.len
            || ngx_strncasecmp(uscfp[i]->host.data, u->host.data, u->host.len)
               != 0)
        {
            continue;
        }

        if ((flags & NGX_STREAM_...",563.0,668.0,1.0,1.0,106.0,123,14,114,16,0,35,18,27,12,10,,0,31,6,3,3,ngx_stream_upstream_srv_conf_t
352,62228,ngx_strncasecmp,1,ngx_strncasecmp,"ngx_int_t ngx_strncasecmp (u_char*,u_char*,size_t)",core\ngx_string.c,"ngx_int_t
ngx_strncasecmp(u_char *s1, u_char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    while (n) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                n--;
                continue;
            }

            return 0;
        }

        return c1 - c2;
    }

    return 0;
}",612.0,638.0,1.0,1.0,27.0,21,11,23,6,13,0,5,7,0,0,,0,0,6,3,3,ngx_int_t
353,15625,master,3,ngx_core_conf_t.master,,core\ngx_cycle.h,master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
354,58141,ngx_shmtx_lock,1,ngx_shmtx_lock,void ngx_shmtx_lock (ngx_shmtx_t*),core\ngx_shmtx.c,"void
ngx_shmtx_lock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_lock_fd(mtx->fd);

    if (err == 0) {
        return;
    }

    ngx_log_abort(err, ngx_lock_fd_n "" %s failed"", mtx->name);
}",274.0,286.0,1.0,1.0,13.0,3,3,3,2,8,2,2,2,0,1,,0,2,2,1,1,void
355,37666,ngx_proxy_protocol_write,1,ngx_proxy_protocol_write,"u_char ngx_proxy_protocol_write (ngx_connection_t*,u_char*,u_char*)",core\ngx_proxy_protocol.c,"u_char *
ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)
{
    ngx_uint_t  port, lport;

    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {
        return NULL;
    }

    if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
        return NULL;
    }

    switch (c->sockaddr->sa_family) {

    case AF_INET:
        buf = ngx_cpymem(buf, ""PROXY TCP4 "", sizeof(""PROXY TCP4 "") - 1);
        break;

#if (NGX_HAVE_INET6)
    case AF_INET6:
        buf = ngx_cpymem(buf, ""PROXY TCP6 "", sizeof(""PROXY TCP6 "") - 1);
        break;
#endif

    default:
        return ngx_cpymem(buf, ""PROXY UNKNOWN"" CRLF,
                          sizeof(""PROXY UNKNOWN"" CRLF) - 1);
    }

    buf += ngx_sock_ntop(c->sockaddr, c->socklen, buf, last - buf, 0);

    *buf++ = ' ';

    buf += ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, last - buf,
                         0);

    port = ngx_inet_get_port(c->sockaddr);
    lport = ngx_inet_get_port(c->local_sockaddr);

...",225.0,266.0,1.0,1.0,42.0,23,9,29,9,0,5,5,4,1,5,,0,3,6,3,3,u_char
356,15628,worker_processes,3,ngx_core_conf_t.worker_processes,,core\ngx_cycle.h,worker_processes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
357,29478,ngx_add_module,1,ngx_add_module,"ngx_int_t ngx_add_module (ngx_conf_t*,ngx_str_t*,ngx_module_t*,char**)",core\ngx_module.c,"ngx_int_t
ngx_add_module(ngx_conf_t *cf, ngx_str_t *file, ngx_module_t *module,
    char **order)
{
    void               *rv;
    ngx_uint_t          i, m, before;
    ngx_core_module_t  *core_module;

    if (cf->cycle->modules_n >= ngx_max_module) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""too many modules loaded"");
        return NGX_ERROR;
    }

    if (module->version != nginx_version) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""module \""%V\"" version %ui instead of %ui"",
                           file, module->version, (ngx_uint_t) nginx_version);
        return NGX_ERROR;
    }

    if (ngx_strcmp(module->signature, NGX_MODULE_SIGNATURE) != 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""module \""%V\"" is not binary compatible"",
                           file);
        return NGX_ERROR;
    }

    for (m = 0; cf->cycle->modules[m]; m++) {
        if (ngx_strcmp(cf->cycl...",156.0,276.0,1.0,1.0,121.0,87,14,93,20,0,8,20,32,2,6,,0,3,8,4,4,ngx_int_t
358,41769,ngx_resolve_start,1,ngx_resolve_start,"ngx_resolver_ctx_t ngx_resolve_start (ngx_resolver_t*,ngx_resolver_ctx_t*)",core\ngx_resolver.c,"ngx_resolver_ctx_t *
ngx_resolve_start(ngx_resolver_t *r, ngx_resolver_ctx_t *temp)
{
    in_addr_t            addr;
    ngx_resolver_ctx_t  *ctx;

    if (temp) {
        addr = ngx_inet_addr(temp->name.data, temp->name.len);

        if (addr != INADDR_NONE) {
            temp->resolver = r;
            temp->state = NGX_OK;
            temp->naddrs = 1;
            temp->addrs = &temp->addr;
            temp->addr.sockaddr = (struct sockaddr *) &temp->sin;
            temp->addr.socklen = sizeof(struct sockaddr_in);
            ngx_memzero(&temp->sin, sizeof(struct sockaddr_in));
            temp->sin.sin_family = AF_INET;
            temp->sin.sin_addr.s_addr = addr;
            temp->quick = 1;

            return temp;
        }
    }

    if (r->connections.nelts == 0) {
        return NGX_NO_RESOLVER;
    }

    ctx = ngx_resolver_calloc(r, sizeof(ngx_resolver_ctx_t));

    if (ctx) {
        ctx->resolver = r;
    }

    return ctx;
}",368.0,404.0,1.0,1.0,37.0,45,8,34,10,1,2,5,6,0,2,,0,2,4,2,2,ngx_resolver_ctx_t
359,262958,ngx_http_auth_basic_user,1,ngx_http_auth_basic_user,ngx_int_t ngx_http_auth_basic_user (ngx_http_request_t*),http\ngx_http_core_module.c,"ngx_int_t
ngx_http_auth_basic_user(ngx_http_request_t *r)
{
    ngx_str_t   auth, encoded;
    ngx_uint_t  len;

    if (r->headers_in.user.len == 0 && r->headers_in.user.data != NULL) {
        return NGX_DECLINED;
    }

    if (r->headers_in.authorization == NULL) {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    encoded = r->headers_in.authorization->value;

    if (encoded.len < sizeof(""Basic "") - 1
        || ngx_strncasecmp(encoded.data, (u_char *) ""Basic "",
                           sizeof(""Basic "") - 1)
           != 0)
    {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    encoded.len -= sizeof(""Basic "") - 1;
    encoded.data += sizeof(""Basic "") - 1;

    while (encoded.len && encoded.data[0] == ' ') {
        encoded.len--;
        encoded.data++;
    }

    if (encoded.len == 0) {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    auth.len = ngx_base64_...",1931.0,2000.0,1.0,1.0,70.0,121,18,59,8,0,25,12,12,11,3,,0,25,2,1,1,ngx_int_t
360,58160,ngx_shmtx_unlock,1,ngx_shmtx_unlock,void ngx_shmtx_unlock (ngx_shmtx_t*),core\ngx_shmtx.c,"void
ngx_shmtx_unlock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_unlock_fd(mtx->fd);

    if (err == 0) {
        return;
    }

    ngx_log_abort(err, ngx_unlock_fd_n "" %s failed"", mtx->name);
}",289.0,301.0,1.0,1.0,13.0,3,3,3,2,11,2,2,2,0,1,,0,2,2,1,1,void
361,369469,ngx_http_v2_huff_decode_bits,1,ngx_http_v2_huff_decode_bits,"ANY ngx_http_v2_huff_decode_bits (u_char*,u_char*,ngx_uint_t,u_char**)",http\v2\ngx_http_v2_huff_decode.c,"ngx_http_v2_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,
    u_char **dst)
{
    ngx_http_v2_huff_decode_code_t  code;

    code = ngx_http_v2_huff_decode_codes[*state][bits];

    if (code.next == *state) {
        return NGX_ERROR;
    }

    if (code.emit) {
        *(*dst)++ = code.sym;
    }

    *ending = code.ending;
    *state = code.next;

    return NGX_OK;
}",2695.0,2714.0,1.0,1.0,20.0,19,6,15,8,0,6,3,3,2,0,,0,6,8,4,4,ANY
362,447294,ngx_stream_set_complex_value_slot,1,ngx_stream_set_complex_value_slot,"char* ngx_stream_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)",stream\ngx_stream_script.c,"char *
ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_str_t                            *value;
    ngx_stream_complex_value_t          **cv;
    ngx_stream_compile_complex_value_t    ccv;

    cv = (ngx_stream_complex_value_t **) (p + cmd->offset);

    if (*cv != NULL) {
        return ""is duplicate"";
    }

    *cv = ngx_palloc(cf->pool, sizeof(ngx_stream_complex_value_t));
    if (*cv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = *cv;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",243.0,277.0,1.0,1.0,35.0,29,11,27,13,1,5,4,4,1,2,,0,5,6,3,3,char*
363,17233,ngx_create_paths,1,ngx_create_paths,"ngx_int_t ngx_create_paths (ngx_cycle_t*,ngx_uid_t)",core\ngx_file.c,"ngx_int_t
ngx_create_paths(ngx_cycle_t *cycle, ngx_uid_t user)
{
    ngx_err_t         err;
    ngx_uint_t        i;
    ngx_path_t      **path;

    path = cycle->paths.elts;
    for (i = 0; i < cycle->paths.nelts; i++) {

        if (ngx_create_dir(path[i]->name.data, 0700) == NGX_FILE_ERROR) {
            err = ngx_errno;
            if (err != NGX_EEXIST) {
                ngx_log_error(NGX_LOG_EMERG, cycle->log, err,
                              ngx_create_dir_n "" \""%s\"" failed"",
                              path[i]->name.data);
                return NGX_ERROR;
            }
        }

        if (user == (ngx_uid_t) NGX_CONF_UNSET_UINT) {
            continue;
        }

#if !(NGX_WIN32)
        {
        ngx_file_info_t   fi;

        if (ngx_file_info(path[i]->name.data, &fi) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ngx_file_info_n "" \""%s\"" failed"", path[i]->name.data);
            return NGX_ERROR;
   ...",597.0,656.0,1.0,1.0,60.0,54,12,53,16,1,3,11,21,1,3,,0,1,4,2,2,ngx_int_t
364,99155,ngx_http_addition_filter_module,2,http\modules\ngx_http_addition_filter_module.c.ngx_http_addition_filter_module,,http\modules\ngx_http_addition_filter_module.c,ngx_module_t ngx_http_addition_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
365,58205,fd,3,ngx_shmtx_t.fd,,core\ngx_shmtx.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
366,58206,name,3,ngx_shmtx_t.name,,core\ngx_shmtx.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
367,9061,ngx_open_listening_sockets,1,ngx_open_listening_sockets,ngx_int_t ngx_open_listening_sockets (ngx_cycle_t*),core\ngx_connection.c,"ngx_int_t
ngx_open_listening_sockets(ngx_cycle_t *cycle)
{
    int               reuseaddr;
    ngx_uint_t        i, tries, failed;
    ngx_err_t         err;
    ngx_log_t        *log;
    ngx_socket_t      s;
    ngx_listening_t  *ls;

    reuseaddr = 1;
#if (NGX_SUPPRESS_WARN)
    failed = 0;
#endif

    log = cycle->log;

    /* TODO: configurable try number */

    for (tries = 5; tries; tries--) {
        failed = 0;

        /* for each listening socket */

        ls = cycle->listening.elts;
        for (i = 0; i < cycle->listening.nelts; i++) {

            if (ls[i].ignore) {
                continue;
            }

#if (NGX_HAVE_REUSEPORT)

            if (ls[i].add_reuseport) {

                /*
                 * to allow transition from a socket without SO_REUSEPORT
                 * to multiple sockets with SO_REUSEPORT, we have to set
                 * SO_REUSEPORT on the old socket before opening new ones
                 */

                int  reuseport = 1;
...",406.0,709.0,1.0,1.0,304.0,96,15,109,24,1,6,32,79,1,6,,0,1,2,1,1,ngx_int_t
368,99174,ngx_http_addition_header_filter,1,ngx_http_addition_header_filter,ngx_int_t ngx_http_addition_header_filter (ngx_http_request_t*),http\modules\ngx_http_addition_filter_module.c,"static ngx_int_t
ngx_http_addition_header_filter(ngx_http_request_t *r)
{
    ngx_http_addition_ctx_t   *ctx;
    ngx_http_addition_conf_t  *conf;

    if (r->headers_out.status != NGX_HTTP_OK || r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_addition_filter_module);

    if (conf->before_body.len == 0 && conf->after_body.len == 0) {
        return ngx_http_next_header_filter(r);
    }

    if (ngx_http_test_content_type(r, &conf->types) == NULL) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_addition_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_addition_filter_module);

    ngx_http_clear_content_length(r);
    ngx_http_clear_accept_ranges(r);
    ngx_http_weak_etag(r);

    r->preserve_body = 1;

    return ngx_http_next_header_filter(r);
}",95.0,129.0,1.0,1.0,35.0,23,9,29,8,0,9,5,5,4,3,,0,8,2,1,1,ngx_int_t
369,299879,ngx_http_script_flush_no_cacheable_variables,1,ngx_http_script_flush_no_cacheable_variables,"void ngx_http_script_flush_no_cacheable_variables (ngx_http_request_t*,ngx_array_t*)",http\ngx_http_script.c,"void
ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r,
    ngx_array_t *indices)
{
    ngx_uint_t  n, *index;

    if (indices) {
        index = indices->elts;
        for (n = 0; n < indices->nelts; n++) {
            if (r->variables[index[n]].no_cacheable) {
                r->variables[index[n]].valid = 0;
                r->variables[index[n]].not_found = 0;
            }
        }
    }
}",625.0,640.0,1.0,1.0,16.0,19,5,15,4,1,2,4,7,1,0,,0,2,4,2,2,void
370,86892,ngx_ssl_ecdh_curve,1,ngx_ssl_ecdh_curve,"ngx_int_t ngx_ssl_ecdh_curve (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)
{
#ifndef OPENSSL_NO_ECDH

    /*
     * Elliptic-Curve Diffie-Hellman parameters are either ""named curves""
     * from RFC 4492 section 5.1.1, or explicitly described curves over
     * binary fields.  OpenSSL only supports the ""named curves"", which provide
     * maximum interoperability.
     */

#if (defined SSL_CTX_set1_curves_list || defined SSL_CTRL_SET_CURVES_LIST)

    /*
     * OpenSSL 1.0.2+ allows configuring a curve list instead of a single
     * curve previously supported.  By default an internal list is used,
     * with prime256v1 being preferred by server in OpenSSL 1.0.2b+
     * and X25519 in OpenSSL 1.1.0+.
     *
     * By default a curve preferred by the client will be used for
     * key exchange.  The SSL_OP_CIPHER_SERVER_PREFERENCE option can
     * be used to prefer server curves instead, similar to what it
     * does for ciphers.
     */

    SSL_CTX_set_options(ssl->ctx, SSL_O...",1359.0,1438.0,1.0,1.0,80.0,11,3,23,10,0,3,4,4,1,2,,0,1,6,3,3,ngx_int_t
371,394098,ngx_mail_smtp_init_protocol,1,ngx_mail_smtp_init_protocol,void ngx_mail_smtp_init_protocol (ngx_event_t*),mail\ngx_mail_smtp_handler.c,"void
ngx_mail_smtp_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_mail_smtp_create_buffer(s, c) != NGX_OK) {
            return;
        }
    }

    s->mail_state = ngx_smtp_start;
    c->read->handler = ngx_mail_smtp_auth_state;

    ngx_mail_smtp_auth_state(rev);
}",376.0,405.0,1.0,1.0,30.0,19,4,20,8,0,6,4,5,2,4,,0,3,2,1,1,void
372,25464,ngx_md5_body,1,ngx_md5_body,"u_char* ngx_md5_body (ngx_md5_t*,u_char*,size_t)",core\ngx_md5.c,"static const u_char *
ngx_md5_body(ngx_md5_t *ctx, const u_char *data, size_t size)
{
    uint32_t       a, b, c, d;
    uint32_t       saved_a, saved_b, saved_c, saved_d;
    const u_char  *p;
#if !(NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
    uint32_t       block[16];
#endif

    p = data;

    a = ctx->a;
    b = ctx->b;
    c = ctx->c;
    d = ctx->d;

    do {
        saved_a = a;
        saved_b = b;
        saved_c = c;
        saved_d = d;

        /* Round 1 */

        STEP(F, a, b, c, d, SET(0),  0xd76aa478, 7);
        STEP(F, d, a, b, c, SET(1),  0xe8c7b756, 12);
        STEP(F, c, d, a, b, SET(2),  0x242070db, 17);
        STEP(F, b, c, d, a, SET(3),  0xc1bdceee, 22);
        STEP(F, a, b, c, d, SET(4),  0xf57c0faf, 7);
        STEP(F, d, a, b, c, SET(5),  0x4787c62a, 12);
        STEP(F, c, d, a, b, SET(6),  0xa8304613, 17);
        STEP(F, b, c, d, a, SET(7),  0xfd469501, 22);
        STEP(F, a, b, c, d, SET(8),  0x698098d8, 7);
        STEP(F, d, a, b, c, SET(...",169.0,283.0,1.0,8.0,115.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,u_char
373,893,ngx_set_environment,1,ngx_set_environment,"char** ngx_set_environment (ngx_cycle_t*,ngx_uint_t*)",core\nginx.c,"char **
ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)
{
    char                **p, **env;
    ngx_str_t            *var;
    ngx_uint_t            i, n;
    ngx_core_conf_t      *ccf;
    ngx_pool_cleanup_t   *cln;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (last == NULL && ccf->environment) {
        return ccf->environment;
    }

    var = ccf->env.elts;

    for (i = 0; i < ccf->env.nelts; i++) {
        if (ngx_strcmp(var[i].data, ""TZ"") == 0
            || ngx_strncmp(var[i].data, ""TZ="", 3) == 0)
        {
            goto tz_found;
        }
    }

    var = ngx_array_push(&ccf->env);
    if (var == NULL) {
        return NULL;
    }

    var->len = 2;
    var->data = (u_char *) ""TZ"";

    var = ccf->env.elts;

tz_found:

    n = 0;

    for (i = 0; i < ccf->env.nelts; i++) {

        if (var[i].data[var[i].len] == '=') {
            n++;
            continue;
        }

        for (p = ngx_os_environ; *p; p++) {

    ...",510.0,618.0,1.0,1.0,109.0,111,15,93,13,2,16,21,26,4,2,,0,16,4,2,2,char**
374,25471,ngx_md5_init,1,ngx_md5_init,void ngx_md5_init (ngx_md5_t*),core\ngx_md5.c,"void
ngx_md5_init(ngx_md5_t *ctx)
{
    ctx->a = 0x67452301;
    ctx->b = 0xefcdab89;
    ctx->c = 0x98badcfe;
    ctx->d = 0x10325476;

    ctx->bytes = 0;
}",18.0,27.0,1.0,1.0,10.0,10,2,5,1,1,5,1,1,0,0,,0,5,2,1,1,void
375,82818,ngx_close_posted_connection,1,ngx_close_posted_connection,void ngx_close_posted_connection (ngx_connection_t*),event\ngx_event_acceptex.c,"static void
ngx_close_posted_connection(ngx_connection_t *c)
{
    ngx_socket_t  fd;

    ngx_free_connection(c);

    fd = c->fd;
    c->fd = (ngx_socket_t) -1;

    if (ngx_close_socket(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ngx_close_socket_n "" failed"");
    }

    if (c->pool) {
        ngx_destroy_pool(c->pool);
    }
}",202.0,220.0,1.0,1.0,19.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void
376,82823,ngx_event_acceptex,1,ngx_event_acceptex,void ngx_event_acceptex (ngx_event_t*),event\ngx_event_acceptex.c,"void
ngx_event_acceptex(ngx_event_t *rev)
{
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    c = rev->data;
    ls = c->listening;

    c->log->handler = ngx_accept_log_error;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""AcceptEx: %d"", c->fd);

    if (rev->ovlp.error) {
        ngx_log_error(NGX_LOG_CRIT, c->log, rev->ovlp.error,
                      ""AcceptEx() %V failed"", &ls->addr_text);
        return;
    }

    /* SO_UPDATE_ACCEPT_CONTEXT is required for shutdown() to work */

    if (setsockopt(c->fd, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                   (char *) &ls->fd, sizeof(ngx_socket_t))
        == -1)
    {
        ngx_log_error(NGX_LOG_CRIT, c->log, ngx_socket_errno,
                      ""setsockopt(SO_UPDATE_ACCEPT_CONTEXT) failed for %V"",
                      &c->addr_text);
        /* TODO: close socket */
        return;
    }

    ngx_getacceptexsockaddrs(c->buffer->pos,
                             ls->post_accept_buffer_size,
           ...",16.0,87.0,1.0,1.0,72.0,76,10,54,12,0,6,7,9,0,6,,0,3,2,1,1,void
377,58251,ngx_slab_alloc_pages,1,ngx_slab_alloc_pages,"ngx_slab_page_t* ngx_slab_alloc_pages (ngx_slab_pool_t*,ngx_uint_t)",core\ngx_slab.c,"static ngx_slab_page_t *
ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages)
{
    ngx_slab_page_t  *page, *p;

    for (page = pool->free.next; page != &pool->free; page = page->next) {

        if (page->slab >= pages) {

            if (page->slab > pages) {
                page[page->slab - 1].prev = (uintptr_t) &page[pages];

                page[pages].slab = page->slab - pages;
                page[pages].next = page->next;
                page[pages].prev = page->prev;

                p = (ngx_slab_page_t *) page->prev;
                p->next = &page[pages];
                page->next->prev = (uintptr_t) &page[pages];

            } else {
                p = (ngx_slab_page_t *) page->prev;
                p->next = page->next;
                page->next->prev = page->prev;
            }

            page->slab = pages | NGX_SLAB_PAGE_START;
            page->next = NULL;
            page->prev = NGX_SLAB_PAGE;

            pool->pfree -= pages;

            if (...",677.0,730.0,1.0,33.0,54.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_slab_page_t
378,152463,ngx_http_image_filter_module,2,http\modules\ngx_http_image_filter_module.c.ngx_http_image_filter_module,,http\modules\ngx_http_image_filter_module.c,ngx_module_t ngx_http_image_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
379,58257,ngx_slab_free_pages,1,ngx_slab_free_pages,"void ngx_slab_free_pages (ngx_slab_pool_t*,ngx_slab_page_t*,ngx_uint_t)",core\ngx_slab.c,"static void
ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
    ngx_uint_t pages)
{
    ngx_slab_page_t  *prev, *join;

    pool->pfree += pages;

    page->slab = pages--;

    if (pages) {
        ngx_memzero(&page[1], pages * sizeof(ngx_slab_page_t));
    }

    if (page->next) {
        prev = ngx_slab_page_prev(page);
        prev->next = page->next;
        page->next->prev = page->prev;
    }

    join = page + page->slab;

    if (join < pool->last) {

        if (ngx_slab_page_type(join) == NGX_SLAB_PAGE) {

            if (join->next != NULL) {
                pages += join->slab;
                page->slab += join->slab;

                prev = ngx_slab_page_prev(join);
                prev->next = join->next;
                join->next->prev = join->prev;

                join->slab = NGX_SLAB_PAGE_FREE;
                join->next = NULL;
                join->prev = NGX_SLAB_PAGE;
            }
        }
    }

    if (page > pool->pages) {
        joi...",733.0,810.0,1.0,15.0,78.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,void
380,218004,ngx_http_ssi_body_filter,1,ngx_http_ssi_body_filter,"ngx_int_t ngx_http_ssi_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_ssi_filter_module.c,"static ngx_int_t
ngx_http_ssi_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     len;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_uint_t                 i, index;
    ngx_chain_t               *cl, **ll;
    ngx_table_elt_t           *param;
    ngx_http_ssi_ctx_t        *ctx, *mctx;
    ngx_http_ssi_block_t      *bl;
    ngx_http_ssi_param_t      *prm;
    ngx_http_ssi_command_t    *cmd;
    ngx_http_ssi_loc_conf_t   *slcf;
    ngx_http_ssi_main_conf_t  *smcf;
    ngx_str_t                 *params[NGX_HTTP_SSI_MAX_PARAMS + 1];

    ctx = ngx_http_get_module_ctx(r, ngx_http_ssi_filter_module);

    if (ctx == NULL
        || (in == NULL
            && ctx->buf == NULL
            && ctx->in == NULL
            && ctx->busy == NULL))
    {
        return ngx_http_next_body_filter(r, in);
    }

    /* add the incoming chain to the chain ctx->in */

    if (in) {
        if (ngx_chain_add_copy(r->pool, &ctx->in, in) !=...",388.0,911.0,1.0,1.0,524.0,534,19,393,31,0,157,70,208,55,14,,0,149,4,2,2,ngx_int_t
381,58264,ngx_slab_error,1,ngx_slab_error,"void ngx_slab_error (ngx_slab_pool_t*,ngx_uint_t,char*)",core\ngx_slab.c,"static void
ngx_slab_error(ngx_slab_pool_t *pool, ngx_uint_t level, char *text)
{
    ngx_log_error(level, ngx_cycle->log, 0, ""%s%s"", text, pool->log_ctx);
}",813.0,817.0,1.0,1.0,5.0,0,0,0,0,6,0,1,1,0,0,,0,0,6,3,3,void
382,447384,ngx_stream_set_complex_value_size_slot,1,ngx_stream_set_complex_value_size_slot,"char* ngx_stream_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)",stream\ngx_stream_script.c,"char *
ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    char                        *rv;
    ngx_stream_complex_value_t  *cv;

    rv = ngx_stream_set_complex_value_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    cv = *(ngx_stream_complex_value_t **) (p + cmd->offset);

    if (cv->lengths) {
        return NGX_CONF_OK;
    }

    cv->u.size = ngx_parse_size(&cv->value);
    if (cv->u.size == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",280.0,307.0,1.0,1.0,28.0,18,9,19,8,0,6,4,4,2,2,,0,6,6,3,3,char*
383,439194,map,3,ngx_stream_map_ctx_t.map,,stream\ngx_stream_map_module.c,map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
384,439195,value,3,ngx_stream_map_ctx_t.value,,stream\ngx_stream_map_module.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
385,439196,default_value,3,ngx_stream_map_ctx_t.default_value,,stream\ngx_stream_map_module.c,*default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
386,25501,ngx_md5_update,1,ngx_md5_update,"void ngx_md5_update (ngx_md5_t*,void*,size_t)",core\ngx_md5.c,"void
ngx_md5_update(ngx_md5_t *ctx, const void *data, size_t size)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);
    ctx->bytes += size;

    if (used) {
        free = 64 - used;

        if (size < free) {
            ngx_memcpy(&ctx->buffer[used], data, size);
            return;
        }

        ngx_memcpy(&ctx->buffer[used], data, free);
        data = (u_char *) data + free;
        size -= free;
        (void) ngx_md5_body(ctx, ctx->buffer, 64);
    }

    if (size >= 64) {
        data = ngx_md5_body(ctx, data, size & ~(size_t) 0x3f);
        size &= 0x3f;
    }

    ngx_memcpy(ctx->buffer, data, size);
}",30.0,58.0,1.0,1.0,29.0,26,13,33,5,1,8,4,5,0,2,,0,7,6,3,3,void
387,439197,hostnames,3,ngx_stream_map_ctx_t.hostnames,,stream\ngx_stream_map_module.c,hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
388,58271,ngx_slab_max_size,2,core\ngx_slab.c.ngx_slab_max_size,,core\ngx_slab.c,ngx_uint_t ngx_slab_max_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
389,58272,ngx_slab_exact_size,2,core\ngx_slab.c.ngx_slab_exact_size,,core\ngx_slab.c,ngx_uint_t ngx_slab_exact_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
390,58273,ngx_slab_exact_shift,2,core\ngx_slab.c.ngx_slab_exact_shift,,core\ngx_slab.c,ngx_uint_t ngx_slab_exact_shift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
391,58274,ngx_slab_sizes_init,1,ngx_slab_sizes_init,void ngx_slab_sizes_init (void),core\ngx_slab.c,"void
ngx_slab_sizes_init(void)
{
    ngx_uint_t  n;

    ngx_slab_max_size = ngx_pagesize / 2;
    ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));
    for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {
        /* void */
    }
}",85.0,95.0,1.0,1.0,11.0,7,4,8,5,1,3,2,2,0,0,,0,3,2,1,1,void
392,152482,ngx_http_image_types,2,http\modules\ngx_http_image_filter_module.c.ngx_http_image_types,,http\modules\ngx_http_image_filter_module.c,static ngx_str_t[] ngx_http_image_types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
393,209829,ngx_http_scgi_module,2,http\modules\ngx_http_scgi_module.c.ngx_http_scgi_module,,http\modules\ngx_http_scgi_module.c,ngx_module_t ngx_http_scgi_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
394,41898,ngx_resolve_name,1,ngx_resolve_name,ngx_int_t ngx_resolve_name (ngx_resolver_ctx_t*),core\ngx_resolver.c,"ngx_int_t
ngx_resolve_name(ngx_resolver_ctx_t *ctx)
{
    size_t           slen;
    ngx_int_t        rc;
    ngx_str_t        name;
    ngx_resolver_t  *r;

    r = ctx->resolver;

    if (ctx->name.len > 0 && ctx->name.data[ctx->name.len - 1] == '.') {
        ctx->name.len--;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve: \""%V\"""", &ctx->name);

    if (ctx->quick) {
        ctx->handler(ctx);
        return NGX_OK;
    }

    if (ctx->service.len) {
        slen = ctx->service.len;

        if (ngx_strlchr(ctx->service.data,
                        ctx->service.data + ctx->service.len, '.')
            == NULL)
        {
            slen += sizeof(""_._tcp"") - 1;
        }

        name.len = slen + 1 + ctx->name.len;

        name.data = ngx_resolver_alloc(r, name.len);
        if (name.data == NULL) {
            goto failed;
        }

        if (slen == ctx->service.len) {
            ngx_sprintf(name.data, ""%V.%V"", &ctx->service, &ctx->...",407.0,486.0,1.0,1.0,80.0,63,13,52,10,0,12,11,13,1,6,,0,8,2,1,1,ngx_int_t
395,189356,upstream,3,ngx_http_proxy_loc_conf_t.upstream,,http\modules\ngx_http_proxy_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
396,152494,ngx_http_image_header_filter,1,ngx_http_image_header_filter,ngx_int_t ngx_http_image_header_filter (ngx_http_request_t*),http\modules\ngx_http_image_filter_module.c,"static ngx_int_t
ngx_http_image_header_filter(ngx_http_request_t *r)
{
    off_t                          len;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx) {
        ngx_http_set_ctx(r, NULL, ngx_http_image_filter_module);
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf->filter == NGX_HTTP_IMAGE_OFF) {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_out.content_type.len
            >= sizeof(""multipart/x-mixed-replace"") - 1
        && ngx_strncasecmp(r->headers_out.content_type.data,
                           (u_char *) ""multipart/x-mixed-replace"",
                           sizeof(""multipart/x-mixed-replace"") - 1)
           == 0)
    {
...",220.0,288.0,1.0,24.0,69.0,53,12,47,12,0,13,9,9,3,4,,0,11,2,1,1,ngx_int_t
397,189359,body_values,3,ngx_http_proxy_loc_conf_t.body_values,,http\modules\ngx_http_proxy_module.c,*body_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
398,189364,proxy_lengths,3,ngx_http_proxy_loc_conf_t.proxy_lengths,,http\modules\ngx_http_proxy_module.c,*proxy_lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
399,189366,redirects,3,ngx_http_proxy_loc_conf_t.redirects,,http\modules\ngx_http_proxy_module.c,*redirects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
400,189367,cookie_domains,3,ngx_http_proxy_loc_conf_t.cookie_domains,,http\modules\ngx_http_proxy_module.c,*cookie_domains,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
401,320440,config,3,ngx_http_upstream_rr_peer_data_t.config,,http\ngx_http_upstream_round_robin.h,config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
402,320441,peers,3,ngx_http_upstream_rr_peer_data_t.peers,,http\ngx_http_upstream_round_robin.h,*peers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
403,189368,cookie_paths,3,ngx_http_proxy_loc_conf_t.cookie_paths,,http\modules\ngx_http_proxy_module.c,*cookie_paths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
404,320443,tried,3,ngx_http_upstream_rr_peer_data_t.tried,,http\ngx_http_upstream_round_robin.h,*tried,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
405,320444,data,3,ngx_http_upstream_rr_peer_data_t.data,,http\ngx_http_upstream_round_robin.h,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
406,418747,ngx_close_handle,1,ngx_close_handle,void ngx_close_handle (HANDLE),os\win32\ngx_process_cycle.c,"void
ngx_close_handle(HANDLE h)
{
    if (CloseHandle(h) == 0) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ""CloseHandle(%p) failed"", h);
    }
}",1036.0,1043.0,1.0,1.0,8.0,2,2,5,4,0,1,2,2,0,1,,0,0,2,1,1,void
407,320442,current,3,ngx_http_upstream_rr_peer_data_t.current,,http\ngx_http_upstream_round_robin.h,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
408,189375,http_version,3,ngx_http_proxy_loc_conf_t.http_version,,http\modules\ngx_http_proxy_module.c,http_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
409,58304,ngx_slab_init,1,ngx_slab_init,void ngx_slab_init (ngx_slab_pool_t*),core\ngx_slab.c,"void
ngx_slab_init(ngx_slab_pool_t *pool)
{
    u_char           *p;
    size_t            size;
    ngx_int_t         m;
    ngx_uint_t        i, n, pages;
    ngx_slab_page_t  *slots, *page;

    pool->min_size = (size_t) 1 << pool->min_shift;

    slots = ngx_slab_slots(pool);

    p = (u_char *) slots;
    size = pool->end - p;

    ngx_slab_junk(p, size);

    n = ngx_pagesize_shift - pool->min_shift;

    for (i = 0; i < n; i++) {
        /* only ""next"" is used in list head */
        slots[i].slab = 0;
        slots[i].next = &slots[i];
        slots[i].prev = 0;
    }

    p += n * sizeof(ngx_slab_page_t);

    pool->stats = (ngx_slab_stat_t *) p;
    ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));

    p += n * sizeof(ngx_slab_stat_t);

    size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));

    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));

    pool->pages = (ngx_slab_page_t *) p;
    ngx_memzero(pool->pages, pages * sizeof(ng...",98.0,165.0,1.0,12.0,68.0,108,17,86,15,0,24,3,3,0,0,,0,24,2,1,1,void
410,189373,vars,3,ngx_http_proxy_loc_conf_t.vars,,http\modules\ngx_http_proxy_module.c,vars,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
411,86975,ngx_ssl_early_data,1,ngx_ssl_early_data,"ngx_int_t ngx_ssl_early_data (ngx_conf_t*,ngx_ssl_t*,ngx_uint_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)
{
    if (!enable) {
        return NGX_OK;
    }

#ifdef SSL_ERROR_EARLY_DATA_REJECTED

    /* BoringSSL */

    SSL_CTX_set_early_data_enabled(ssl->ctx, 1);

#elif defined SSL_READ_EARLY_DATA_SUCCESS

    /* OpenSSL */

    SSL_CTX_set_max_early_data(ssl->ctx, NGX_SSL_BUFSIZE);

#else
    ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                  ""\""ssl_early_data\"" is not supported on this platform, ""
                  ""ignored"");
#endif

    return NGX_OK;
}",1441.0,1467.0,1.0,1.0,27.0,2,2,5,4,0,1,2,2,0,1,,0,0,6,3,3,ngx_int_t
412,156611,indices,3,ngx_http_index_loc_conf_t.indices,,http\modules\ngx_http_index_module.c,*indices,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
413,156612,max_index_len,3,ngx_http_index_loc_conf_t.max_index_len,,http\modules\ngx_http_index_module.c,max_index_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
414,99270,ngx_http_addition_body_filter,1,ngx_http_addition_body_filter,"ngx_int_t ngx_http_addition_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_addition_filter_module.c,"static ngx_int_t
ngx_http_addition_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                  rc;
    ngx_uint_t                 last;
    ngx_chain_t               *cl;
    ngx_http_request_t        *sr;
    ngx_http_addition_ctx_t   *ctx;
    ngx_http_addition_conf_t  *conf;

    if (in == NULL || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_addition_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_addition_filter_module);

    if (!ctx->before_body_sent) {
        ctx->before_body_sent = 1;

        if (conf->before_body.len) {
            if (ngx_http_subrequest(r, &conf->before_body, NULL, &sr, NULL, 0)
                != NGX_OK)
            {
                return NGX_ERROR;
            }
        }
    }

    if (conf->after_body.len == 0) {
        ngx_http_set_ctx(r, NULL, ngx_...",132.0,197.0,1.0,1.0,66.0,45,8,60,13,0,14,11,15,8,3,,0,13,4,2,2,ngx_int_t
415,156614,ngx_http_index_test_dir,1,ngx_http_index_test_dir,"ngx_int_t ngx_http_index_test_dir (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,u_char*)",http\modules\ngx_http_index_module.c,"static ngx_int_t
ngx_http_index_test_dir(ngx_http_request_t *r, ngx_http_core_loc_conf_t *clcf,
    u_char *path, u_char *last)
{
    u_char                c;
    ngx_str_t             dir;
    ngx_open_file_info_t  of;

    c = *last;
    if (c != '/' || path == last) {
        /* ""alias"" without trailing slash */
        c = *(++last);
    }
    *last = '\0';

    dir.len = last - path;
    dir.data = path;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http index check dir: \""%V\"""", &dir);

    ngx_memzero(&of, sizeof(ngx_open_file_info_t));

    of.test_dir = 1;
    of.test_only = 1;
    of.valid = clcf->open_file_cache_valid;
    of.errors = clcf->open_file_cache_errors;

    if (ngx_http_set_disable_symlinks(r, clcf, &dir, &of) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (ngx_open_cached_file(clcf->open_file_cache, &dir, &of, r->pool)
        != NGX_OK)
    {
        if (of.err) {

#if (NGX_HAVE_OPENAT)
        ...",284.0,364.0,1.0,1.0,81.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
416,62411,ngx_strcasestrn,1,ngx_strcasestrn,"u_char ngx_strcasestrn (u_char*,char*,size_t)",core\ngx_string.c,"u_char *
ngx_strcasestrn(u_char *s1, char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    c2 = (ngx_uint_t) *s2++;
    c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

    do {
        do {
            c1 = (ngx_uint_t) *s1++;

            if (c1 == 0) {
                return NULL;
            }

            c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;

        } while (c1 != c2);

    } while (ngx_strncasecmp(s1, (u_char *) s2, n) != 0);

    return --s1;
}",704.0,727.0,1.0,1.0,24.0,23,12,24,7,0,1,4,7,1,1,,0,1,6,3,3,u_char
417,156622,ngx_http_index_error,1,ngx_http_index_error,"ngx_int_t ngx_http_index_error (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,ngx_err_t)",http\modules\ngx_http_index_module.c,"static ngx_int_t
ngx_http_index_error(ngx_http_request_t *r, ngx_http_core_loc_conf_t  *clcf,
    u_char *file, ngx_err_t err)
{
    if (err == NGX_EACCES) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, err,
                      ""\""%s\"" is forbidden"", file);

        return NGX_HTTP_FORBIDDEN;
    }

    if (clcf->log_not_found) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, err,
                      ""\""%s\"" is not found"", file);
    }

    return NGX_HTTP_NOT_FOUND;
}",367.0,384.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
418,189391,vars,3,ngx_http_proxy_ctx_t.vars,,http\modules\ngx_http_proxy_module.c,vars,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
419,209873,ngx_http_scgi_handler,1,ngx_http_scgi_handler,ngx_int_t ngx_http_scgi_handler (ngx_http_request_t*),http\modules\ngx_http_scgi_module.c,"static ngx_int_t
ngx_http_scgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_status_t          *status;
    ngx_http_upstream_t        *u;
    ngx_http_scgi_loc_conf_t   *scf;
#if (NGX_HTTP_CACHE)
    ngx_http_scgi_main_conf_t  *smcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    status = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t));
    if (status == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, status, ngx_http_scgi_module);

    scf = ngx_http_get_module_loc_conf(r, ngx_http_scgi_module);

    if (scf->scgi_lengths) {
        if (ngx_http_scgi_eval(r, scf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""scgi://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_scgi_module;

    u->conf = &scf->upstream;

#if (NGX_HTTP_CACHE)
    smcf = ngx_http_get_modu...",476.0,551.0,1.0,1.0,76.0,62,11,62,21,0,13,8,9,5,5,,0,13,2,1,1,ngx_int_t
420,189398,ngx_http_proxy_ctx_t,2,http\modules\ngx_http_proxy_module.c.ngx_http_proxy_ctx_t,,http\modules\ngx_http_proxy_module.c,struct ngx_http_proxy_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
421,413764,ngx_file_info,1,ngx_file_info,"ngx_int_t ngx_file_info (u_char*,ngx_file_info_t*)",os\win32\ngx_files.c,"ngx_int_t
ngx_file_info(u_char *file, ngx_file_info_t *sb)
{
    size_t                      len;
    long                        rc;
    u_short                    *u;
    ngx_err_t                   err;
    WIN32_FILE_ATTRIBUTE_DATA   fa;
    u_short                     utf16[NGX_UTF16_BUFLEN];

    len = NGX_UTF16_BUFLEN;

    u = ngx_utf8_to_utf16(utf16, file, &len);

    if (u == NULL) {
        return NGX_FILE_ERROR;
    }

    rc = NGX_FILE_ERROR;

    if (ngx_win32_check_filename(file, u, len) != NGX_OK) {
        goto failed;
    }

    rc = GetFileAttributesExW(u, GetFileExInfoStandard, &fa);

    sb->dwFileAttributes = fa.dwFileAttributes;
    sb->ftCreationTime = fa.ftCreationTime;
    sb->ftLastAccessTime = fa.ftLastAccessTime;
    sb->ftLastWriteTime = fa.ftLastWriteTime;
    sb->nFileSizeHigh = fa.nFileSizeHigh;
    sb->nFileSizeLow = fa.nFileSizeLow;

failed:

    if (u != utf16) {
        err = ngx_errno;
        ngx_free(u);
        ngx_set_errno(err);
    }

    ...",260.0,302.0,1.0,38.0,43.0,28,6,37,13,2,2,5,4,1,2,,0,2,4,2,2,ngx_int_t
422,447453,ngx_stream_script_variables_count,1,ngx_stream_script_variables_count,ngx_uint_t ngx_stream_script_variables_count (ngx_str_t*),stream\ngx_stream_script.c,"ngx_uint_t
ngx_stream_script_variables_count(ngx_str_t *value)
{
    ngx_uint_t  i, n;

    for (n = 0, i = 0; i < value->len; i++) {
        if (value->data[i] == '$') {
            n++;
        }
    }

    return n;
}",310.0,322.0,1.0,1.0,13.0,9,7,8,3,0,2,3,4,2,0,,0,2,2,1,1,ngx_uint_t
423,168926,upstream,3,ngx_http_memcached_loc_conf_t.upstream,,http\modules\ngx_http_memcached_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
424,230369,ngx_http_sub_body_filter,1,ngx_http_sub_body_filter,"ngx_int_t ngx_http_sub_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_sub_filter_module.c,"static ngx_int_t
ngx_http_sub_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_str_t                 *sub;
    ngx_uint_t                 flush, last;
    ngx_chain_t               *cl;
    ngx_http_sub_ctx_t        *ctx;
    ngx_http_sub_match_t      *match;
    ngx_http_sub_loc_conf_t   *slcf;

    ctx = ngx_http_get_module_ctx(r, ngx_http_sub_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if ((in == NULL
         && ctx->buf == NULL
         && ctx->in == NULL
         && ctx->busy == NULL))
    {
        return ngx_http_next_body_filter(r, in);
    }

    if (ctx->once && (ctx->buf == NULL || ctx->in == NULL)) {

        if (ctx->busy) {
            if (ngx_http_sub_output(r, ctx) == NGX_ERROR) {
                return NGX_ERROR;
            }
        }

        return ngx_http_next_body_filter(r, in);
    }

    /* add the incoming chain to the ...",284.0,534.0,1.0,1.0,251.0,318,17,257,19,0,104,35,84,36,12,,0,103,4,2,2,ngx_int_t
425,168932,request,3,ngx_http_memcached_ctx_t.request,,http\modules\ngx_http_memcached_module.c,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
426,168934,ngx_http_memcached_ctx_t,2,http\modules\ngx_http_memcached_module.c.ngx_http_memcached_ctx_t,,http\modules\ngx_http_memcached_module.c,struct ngx_http_memcached_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
427,320490,ngx_http_add_prefix_variable,1,ngx_http_add_prefix_variable,"ngx_http_variable_t* ngx_http_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)",http\ngx_http_variables.c,"static ngx_http_variable_t *
ngx_http_add_prefix_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_uint_t                  i;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->prefix_variables.elts;
    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {
        if (name->len != v[i].name.len
            || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
        {
            continue;
        }

        v = &v[i];

        if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""the duplicate \""%V\"" variable"", name);
            return NULL;
        }

        if (!(flags & NGX_HTTP_VAR_WEAK)) {
            v->flags &= ~NGX_HTTP_VAR_WEAK;
        }

        return v;
    }

    v = ngx_array_push(&cmcf->prefix_variables);
    if (v == NULL) {
        return NULL;
   ...",484.0,536.0,1.0,1.0,53.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_http_variable_t
428,294908,buf,3,ngx_http_request_body_t.buf,,http\ngx_http_request.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
429,115697,ngx_empty_gif,2,http\modules\ngx_http_empty_gif_module.c.ngx_empty_gif,,http\modules\ngx_http_empty_gif_module.c,static u_char[] ngx_empty_gif,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
430,394226,ngx_mail_smtp_auth_state,1,ngx_mail_smtp_auth_state,void ngx_mail_smtp_auth_state (ngx_event_t*),mail\ngx_mail_smtp_handler.c,"void
ngx_mail_smtp_auth_state(ngx_event_t *rev)
{
    ngx_int_t            rc;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""smtp auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""smtp send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    ngx_str_set(&s->out, smtp_ok);

    if (rc == NGX_OK) {
        switch (s->mail_state) {

        case ngx_smtp_start:

            switch (s->command) {

            case NGX_SMTP_HELO:
            case NGX_SMTP_EHLO:
                rc = ngx_mail_smtp_helo(s, c);
             ...",430.0,573.0,1.0,1.0,144.0,84,7,116,32,1,44,26,16,8,17,,0,39,2,1,1,void
431,418807,st,2,os\win32\ngx_service.c.st,,os\win32\ngx_service.c,SERVICE_TABLE_ENTRY[] st,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
432,439287,ngx_stream_map_variable,1,ngx_stream_map_variable,"ngx_int_t ngx_stream_map_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)",stream\ngx_stream_map_module.c,"static ngx_int_t
ngx_stream_map_variable(ngx_stream_session_t *s, ngx_stream_variable_value_t *v,
    uintptr_t data)
{
    ngx_stream_map_ctx_t  *map = (ngx_stream_map_ctx_t *) data;

    ngx_str_t                     val, str;
    ngx_stream_complex_value_t   *cv;
    ngx_stream_variable_value_t  *value;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream map started"");

    if (ngx_stream_complex_value(s, &map->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (map->hostnames && val.len > 0 && val.data[val.len - 1] == '.') {
        val.len--;
    }

    value = ngx_stream_map_find(s, &map->map, &val);

    if (value == NULL) {
        value = map->default_value;
    }

    if (!value->valid) {
        cv = (ngx_stream_complex_value_t *) value->data;

        if (ngx_stream_complex_value(s, cv, &str) != NGX_OK) {
            return NGX_ERROR;
        }

        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found ...",105.0,153.0,1.0,1.0,49.0,49,13,42,12,0,13,6,7,7,3,,0,13,6,3,3,ngx_int_t
433,414712,ngx_de_link_info,1,ngx_de_link_info,"ngx_int_t ngx_de_link_info (u_char*,ngx_dir_t*)",os\win32\ngx_files.c,"ngx_int_t
ngx_de_link_info(u_char *name, ngx_dir_t *dir)
{
    return NGX_OK;
}",614.0,618.0,1.0,1.0,5.0,0,0,1,1,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
434,398329,ngx_alloc,1,ngx_alloc,"void* ngx_alloc (size_t,ngx_log_t*)",os\win32\ngx_alloc.c,"void *ngx_alloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = malloc(size);
    if (p == NULL) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""malloc(%uz) failed"", size);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, ""malloc: %p:%uz"", p, size);

    return p;
}",17.0,30.0,1.0,1.0,14.0,2,2,13,7,15,1,2,2,0,1,,0,0,4,2,2,void*
435,21499,value,3,ngx_hash_elt_t.value,,core\ngx_hash.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
436,21500,len,3,ngx_hash_elt_t.len,,core\ngx_hash.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
437,21501,name,3,ngx_hash_elt_t.name,,core\ngx_hash.h,name[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
438,25598,ngx_md5_final,1,ngx_md5_final,"void ngx_md5_final (u_char[16],ngx_md5_t*)",core\ngx_md5.c,"void
ngx_md5_final(u_char result[16], ngx_md5_t *ctx)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);

    ctx->buffer[used++] = 0x80;

    free = 64 - used;

    if (free < 8) {
        ngx_memzero(&ctx->buffer[used], free);
        (void) ngx_md5_body(ctx, ctx->buffer, 64);
        used = 0;
        free = 64;
    }

    ngx_memzero(&ctx->buffer[used], free - 8);

    ctx->bytes <<= 3;
    ctx->buffer[56] = (u_char) ctx->bytes;
    ctx->buffer[57] = (u_char) (ctx->bytes >> 8);
    ctx->buffer[58] = (u_char) (ctx->bytes >> 16);
    ctx->buffer[59] = (u_char) (ctx->bytes >> 24);
    ctx->buffer[60] = (u_char) (ctx->bytes >> 32);
    ctx->buffer[61] = (u_char) (ctx->bytes >> 40);
    ctx->buffer[62] = (u_char) (ctx->bytes >> 48);
    ctx->buffer[63] = (u_char) (ctx->bytes >> 56);

    (void) ngx_md5_body(ctx, ctx->buffer, 64);

    result[0] = (u_char) ctx->a;
    result[1] = (u_char) (ctx->a >> 8);
    result[2] = (u_char) (ctx->a >> 16);
    result[3] = (u_char)...",61.0,111.0,1.0,1.0,51.0,130,12,70,4,1,41,2,2,0,2,,0,39,4,2,2,void
439,418817,ngx_service,1,ngx_service,ngx_int_t ngx_service (ngx_log_t*),os\win32\ngx_service.c,"ngx_int_t
ngx_service(ngx_log_t *log)
{
    /* primary thread */

    /* StartServiceCtrlDispatcher() should be called within 30 seconds */

    if (StartServiceCtrlDispatcher(st) == 0) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""StartServiceCtrlDispatcher() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",19.0,33.0,1.0,1.0,15.0,1,1,6,6,0,2,2,2,1,1,,0,1,2,1,1,ngx_int_t
440,447490,ngx_stream_script_compile,1,ngx_stream_script_compile,ngx_int_t ngx_stream_script_compile (ngx_stream_script_compile_t*),stream\ngx_stream_script.c,"ngx_int_t
ngx_stream_script_compile(ngx_stream_script_compile_t *sc)
{
    u_char       ch;
    ngx_str_t    name;
    ngx_uint_t   i, bracket;

    if (ngx_stream_script_init_arrays(sc) != NGX_OK) {
        return NGX_ERROR;
    }

    for (i = 0; i < sc->source->len; /* void */ ) {

        name.len = 0;

        if (sc->source->data[i] == '$') {

            if (++i == sc->source->len) {
                goto invalid_variable;
            }

            if (sc->source->data[i] >= '1' && sc->source->data[i] <= '9') {
#if (NGX_PCRE)
                ngx_uint_t  n;

                n = sc->source->data[i] - '0';

                if (ngx_stream_script_add_capture_code(sc, n) != NGX_OK) {
                    return NGX_ERROR;
                }

                i++;

                continue;
#else
                ngx_conf_log_error(NGX_LOG_EMERG, sc->cf, 0,
                                   ""using variable \""$%c\"" requires ""
                                   ""PCRE library"", sc->source...",325.0,449.0,1.0,1.0,125.0,100,15,76,8,1,33,25,45,15,7,,0,29,2,1,1,ngx_int_t
441,21510,buckets,3,ngx_hash_t.buckets,,core\ngx_hash.h,**buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
442,21511,size,3,ngx_hash_t.size,,core\ngx_hash.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
443,21514,hash,3,ngx_hash_wildcard_t.hash,,core\ngx_hash.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
444,17419,ngx_ext_rename_file,1,ngx_ext_rename_file,"ngx_int_t ngx_ext_rename_file (ngx_str_t*,ngx_str_t*,ngx_ext_rename_file_t*)",core\ngx_file.c,"ngx_int_t
ngx_ext_rename_file(ngx_str_t *src, ngx_str_t *to, ngx_ext_rename_file_t *ext)
{
    u_char           *name;
    ngx_err_t         err;
    ngx_copy_file_t   cf;

#if !(NGX_WIN32)

    if (ext->access) {
        if (ngx_change_file_access(src->data, ext->access) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_CRIT, ext->log, ngx_errno,
                          ngx_change_file_access_n "" \""%s\"" failed"", src->data);
            err = 0;
            goto failed;
        }
    }

#endif

    if (ext->time != -1) {
        if (ngx_set_file_time(src->data, ext->fd, ext->time) != NGX_OK) {
            ngx_log_error(NGX_LOG_CRIT, ext->log, ngx_errno,
                          ngx_set_file_time_n "" \""%s\"" failed"", src->data);
            err = 0;
            goto failed;
        }
    }

    if (ngx_rename_file(src->data, to->data) != NGX_FILE_ERROR) {
        return NGX_OK;
    }

    err = ngx_errno;

    if (err == NGX_ENOPATH) {

        if (!ext->create_path) {
       ...",659.0,791.0,1.0,1.0,133.0,66,10,71,13,0,37,23,34,19,6,,0,36,6,3,3,ngx_int_t
445,21515,value,3,ngx_hash_wildcard_t.value,,core\ngx_hash.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
446,156685,ngx_http_index_module,2,http\modules\ngx_http_index_module.c.ngx_http_index_module,,http\modules\ngx_http_index_module.c,ngx_module_t ngx_http_index_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
447,21518,key,3,ngx_hash_key_t.key,,core\ngx_hash.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
448,328719,name,3,ngx_http_v2_parse_header_t.name,,http\v2\ngx_http_v2.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
449,328720,offset,3,ngx_http_v2_parse_header_t.offset,,http\v2\ngx_http_v2.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
450,21519,key_hash,3,ngx_hash_key_t.key_hash,,core\ngx_hash.h,key_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
451,21520,value,3,ngx_hash_key_t.value,,core\ngx_hash.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
452,328724,ngx_http_v2_read_handler,1,ngx_http_v2_read_handler,void ngx_http_v2_read_handler (ngx_event_t*),http\v2\ngx_http_v2.c,"static void
ngx_http_v2_read_handler(ngx_event_t *rev)
{
    u_char                    *p, *end;
    size_t                     available;
    ssize_t                    n;
    ngx_connection_t          *c;
    ngx_http_v2_main_conf_t   *h2mcf;
    ngx_http_v2_connection_t  *h2c;

    c = rev->data;
    h2c = c->data;

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 read handler"");

    h2c->blocked = 1;

    if (c->close) {
        c->close = 0;

        if (c->error) {
            ngx_http_v2_finalize_connection(h2c, 0);
            return;
        }

        if (!h2c->goaway) {
            h2c->goaway = 1;

            if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR)
                == NGX_ERROR)
            {
                ngx_http_v2_finalize_connection(h2c, 0);
...",332.0,459.0,1.0,45.0,128.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
453,418837,service_main,1,service_main,"void service_main (u_int,char**)",os\win32\ngx_service.c,"void
service_main(u_int argc, char **argv)
{
    SERVICE_STATUS         status;
    SERVICE_STATUS_HANDLE  service;

    /* thread spawned by SCM */

    service = RegisterServiceCtrlHandlerEx(""nginx"", service_handler, ctx);
    if (service == INVALID_HANDLE_VALUE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""RegisterServiceCtrlHandlerEx() failed"");
        return;
    }

    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = SERVICE_START_PENDING;
    status.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                |SERVICE_ACCEPT_PARAMCHANGE;
    status.dwWin32ExitCode = NO_ERROR;
    status.dwServiceSpecificExitCode = 0;
    status.dwCheckPoint = 1;
    status.dwWaitHint = 2000;

    /* SetServiceStatus() should be called within 80 seconds */

    if (SetServiceStatus(service, &status) == 0) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""SetServiceStatus() failed"");
        r...",36.0,87.0,1.0,1.0,52.0,27,5,33,13,0,3,4,4,0,3,,0,0,4,2,2,void
454,62485,ngx_strlcasestrn,1,ngx_strlcasestrn,"u_char ngx_strlcasestrn (u_char*,u_char*,u_char*,size_t)",core\ngx_string.c,"u_char *
ngx_strlcasestrn(u_char *s1, u_char *last, u_char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    c2 = (ngx_uint_t) *s2++;
    c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;
    last -= n;

    do {
        do {
            if (s1 >= last) {
                return NULL;
            }

            c1 = (ngx_uint_t) *s1++;

            c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;

        } while (c1 != c2);

    } while (ngx_strncasecmp(s1, s2, n) != 0);

    return --s1;
}",736.0,760.0,1.0,1.0,25.0,23,11,27,8,0,1,4,7,1,1,,0,1,8,4,4,u_char
455,7535,ngx_conf_set_off_slot,1,ngx_conf_set_off_slot,"char* ngx_conf_set_off_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_off_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    off_t            *op;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    op = (off_t *) (p + cmd->offset);
    if (*op != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *op = ngx_parse_offset(&value[1]);
    if (*op == (off_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, op);
    }

    return NGX_CONF_OK;
}",1228.0,1256.0,1.0,1.0,29.0,21,9,21,10,0,2,4,4,0,1,,0,2,6,3,3,char*
456,398360,ngx_calloc,1,ngx_calloc,"void* ngx_calloc (size_t,ngx_log_t*)",os\win32\ngx_alloc.c,"void *ngx_calloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = ngx_alloc(size, log);

    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",33.0,44.0,1.0,1.0,12.0,1,1,7,3,0,1,2,2,0,1,,0,1,4,2,2,void*
457,87065,ngx_ssl_create_connection,1,ngx_ssl_create_connection,"ngx_int_t ngx_ssl_create_connection (ngx_ssl_t*,ngx_connection_t*,ngx_uint_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)
{
    ngx_ssl_connection_t  *sc;

    sc = ngx_pcalloc(c->pool, sizeof(ngx_ssl_connection_t));
    if (sc == NULL) {
        return NGX_ERROR;
    }

    sc->buffer = ((flags & NGX_SSL_BUFFER) != 0);
    sc->buffer_size = ssl->buffer_size;

    sc->session_ctx = ssl->ctx;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (SSL_CTX_get_max_early_data(ssl->ctx)) {
        sc->try_early_data = 1;
    }
#endif

    sc->connection = SSL_new(ssl->ctx);

    if (sc->connection == NULL) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_new() failed"");
        return NGX_ERROR;
    }

    if (SSL_set_fd(sc->connection, c->fd) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_set_fd() failed"");
        return NGX_ERROR;
    }

    if (flags & NGX_SSL_CLIENT) {
        SSL_set_connect_state(sc->connection);

    } else {
        SSL_set_accept_state(sc->connection);

#ifdef SSL_OP_NO_RENEGOTIATIO...",1506.0,1558.0,1.0,1.0,53.0,31,6,37,12,0,5,6,6,1,4,,0,2,6,3,3,ngx_int_t
458,21530,wc_head,3,ngx_hash_combined_t.wc_head,,core\ngx_hash.h,*wc_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
459,21531,wc_tail,3,ngx_hash_combined_t.wc_tail,,core\ngx_hash.h,*wc_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
460,21529,hash,3,ngx_hash_combined_t.hash,,core\ngx_hash.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
461,156702,ngx_http_index_handler,1,ngx_http_index_handler,ngx_int_t ngx_http_index_handler (ngx_http_request_t*),http\modules\ngx_http_index_module.c,"static ngx_int_t
ngx_http_index_handler(ngx_http_request_t *r)
{
    u_char                       *p, *name;
    size_t                        len, root, reserve, allocated;
    ngx_int_t                     rc;
    ngx_str_t                     path, uri;
    ngx_uint_t                    i, dir_tested;
    ngx_http_index_t             *index;
    ngx_open_file_info_t          of;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t      e;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_index_loc_conf_t    *ilcf;
    ngx_http_script_len_code_pt   lcode;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {
        return NGX_DECLINED;
    }

    ilcf = ngx_http_get_module_loc_conf(r, ngx_http_index_module);
    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    allocated = 0;
    root = 0;
    dir_tested = 0;
    name = NULL;
    /* suppress MSVC w...",96.0,281.0,1.0,1.0,186.0,152,16,142,31,0,41,18,38,8,8,,0,37,2,1,1,ngx_int_t
462,229789,tables,3,ngx_http_sub_loc_conf_t.tables,,http\modules\ngx_http_sub_filter_module.c,*tables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
463,21534,hash,3,ngx_hash_init_t.hash,,core\ngx_hash.h,*hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
464,21535,key,3,ngx_hash_init_t.key,,core\ngx_hash.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
465,21536,max_size,3,ngx_hash_init_t.max_size,,core\ngx_hash.h,max_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
466,21537,bucket_size,3,ngx_hash_init_t.bucket_size,,core\ngx_hash.h,bucket_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
467,21538,name,3,ngx_hash_init_t.name,,core\ngx_hash.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
468,250911,perl,3,ngx_http_perl_main_conf_t.perl,,http\modules\perl\ngx_http_perl_module.c,*perl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
469,21540,temp_pool,3,ngx_hash_init_t.temp_pool,,core\ngx_hash.h,*temp_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
470,250917,sub,3,ngx_http_perl_loc_conf_t.sub,,http\modules\perl\ngx_http_perl_module.c,*sub,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
471,21539,pool,3,ngx_hash_init_t.pool,,core\ngx_hash.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
472,21543,hsize,3,ngx_hash_keys_arrays_t.hsize,,core\ngx_hash.h,hsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
473,250918,handler,3,ngx_http_perl_loc_conf_t.handler,,http\modules\perl\ngx_http_perl_module.c,handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
474,21545,temp_pool,3,ngx_hash_keys_arrays_t.temp_pool,,core\ngx_hash.h,*temp_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
475,21546,keys,3,ngx_hash_keys_arrays_t.keys,,core\ngx_hash.h,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
476,21547,keys_hash,3,ngx_hash_keys_arrays_t.keys_hash,,core\ngx_hash.h,*keys_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
477,21548,dns_wc_head,3,ngx_hash_keys_arrays_t.dns_wc_head,,core\ngx_hash.h,dns_wc_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
478,21549,dns_wc_head_hash,3,ngx_hash_keys_arrays_t.dns_wc_head_hash,,core\ngx_hash.h,*dns_wc_head_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
479,21550,dns_wc_tail,3,ngx_hash_keys_arrays_t.dns_wc_tail,,core\ngx_hash.h,dns_wc_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
480,21551,dns_wc_tail_hash,3,ngx_hash_keys_arrays_t.dns_wc_tail_hash,,core\ngx_hash.h,*dns_wc_tail_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
481,21554,hash,3,ngx_table_elt_t.hash,,core\ngx_hash.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
482,242739,upstream,3,ngx_http_uwsgi_loc_conf_t.upstream,,http\modules\ngx_http_uwsgi_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
483,21556,value,3,ngx_table_elt_t.value,,core\ngx_hash.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
484,21555,key,3,ngx_table_elt_t.key,,core\ngx_hash.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
485,242743,uwsgi_lengths,3,ngx_http_uwsgi_loc_conf_t.uwsgi_lengths,,http\modules\ngx_http_uwsgi_module.c,*uwsgi_lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,463929,ngx_stream_get_variable_index,1,ngx_stream_get_variable_index,"ngx_int_t ngx_stream_get_variable_index (ngx_conf_t*,ngx_str_t*)",stream\ngx_stream_variables.c,"ngx_int_t
ngx_stream_get_variable_index(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_uint_t                    i;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NGX_ERROR;
    }

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->variables.elts;

    if (v == NULL) {
        if (ngx_array_init(&cmcf->variables, cf->pool, 4,
                           sizeof(ngx_stream_variable_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }

    } else {
        for (i = 0; i < cmcf->variables.nelts; i++) {
            if (name->len != v[i].name.len
                || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
            {
                continue;
            }

            return i;
        }
    }

    v = ngx_array_push(&cmcf->variab...",272.0,329.0,1.0,1.0,58.0,46,8,41,10,0,14,6,7,3,5,,0,12,4,2,2,ngx_int_t
487,115773,ngx_http_gif_type,2,http\modules\ngx_http_empty_gif_module.c.ngx_http_gif_type,,http\modules\ngx_http_empty_gif_module.c,ngx_str_t ngx_http_gif_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
488,459842,ngx_stream_upstream_init_round_robin,1,ngx_stream_upstream_init_round_robin,"ngx_int_t ngx_stream_upstream_init_round_robin (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)",stream\ngx_stream_upstream_round_robin.c,"ngx_int_t
ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_url_t                        u;
    ngx_uint_t                       i, j, n, w;
    ngx_stream_upstream_server_t    *server;
    ngx_stream_upstream_rr_peer_t   *peer, **peerp;
    ngx_stream_upstream_rr_peers_t  *peers, *backup;

    us->peer.init = ngx_stream_upstream_init_round_robin_peer;

    if (us->servers) {
        server = us->servers->elts;

        n = 0;
        w = 0;

        for (i = 0; i < us->servers->nelts; i++) {
            if (server[i].backup) {
                continue;
            }

            n += server[i].naddrs;
            w += server[i].naddrs * server[i].weight;
        }

        if (n == 0) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                          ""no servers in upstream \""%V\"" in %s:%ui"",
                          &us->host, us->file_name, us->line);
            return NGX_ERROR;
        }

        peers = ngx_p...",36.0,246.0,1.0,1.0,211.0,368,14,310,19,1,19,28,47,3,10,,0,16,4,2,2,ngx_int_t
489,115778,ngx_http_empty_gif_handler,1,ngx_http_empty_gif_handler,ngx_int_t ngx_http_empty_gif_handler (ngx_http_request_t*),http\modules\ngx_http_empty_gif_module.c,"static ngx_int_t
ngx_http_empty_gif_handler(ngx_http_request_t *r)
{
    ngx_http_complex_value_t  cv;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    ngx_memzero(&cv, sizeof(ngx_http_complex_value_t));

    cv.value.len = sizeof(ngx_empty_gif);
    cv.value.data = ngx_empty_gif;
    r->headers_out.last_modified_time = 23349600;

    return ngx_http_send_response(r, NGX_HTTP_OK, &ngx_http_gif_type, &cv);
}",112.0,128.0,1.0,1.0,17.0,18,8,15,9,0,6,2,2,0,1,,0,5,2,1,1,ngx_int_t
490,304198,ngx_http_upstream_init_request,1,ngx_http_upstream_init_request,void ngx_http_upstream_init_request (ngx_http_request_t*),http\ngx_http_upstream.c,"static void
ngx_http_upstream_init_request(ngx_http_request_t *r)
{
    ngx_str_t                      *host;
    ngx_uint_t                      i;
    ngx_resolver_ctx_t             *ctx, temp;
    ngx_http_cleanup_t             *cln;
    ngx_http_upstream_t            *u;
    ngx_http_core_loc_conf_t       *clcf;
    ngx_http_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_http_upstream_main_conf_t  *umcf;

    if (r->aio) {
        return;
    }

    u = r->upstream;

#if (NGX_HTTP_CACHE)

    if (u->conf->cache) {
        ngx_int_t  rc;

        rc = ngx_http_upstream_cache(r, u);

        if (rc == NGX_BUSY) {
            r->write_event_handler = ngx_http_upstream_init_request;
            return;
        }

        r->write_event_handler = ngx_http_request_empty_handler;

        if (rc == NGX_ERROR) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return;
        }

        if (rc == NGX_OK) {
            rc = ngx_http_upstream_cache_send...",549.0,807.0,1.0,1.0,259.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
491,229797,saved,3,ngx_http_sub_ctx_t.saved,,http\modules\ngx_http_sub_filter_module.c,saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
492,189528,ngx_http_proxy_rewrite,1,ngx_http_proxy_rewrite,"ngx_int_t ngx_http_proxy_rewrite (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_str_t*)",http\modules\ngx_http_proxy_module.c,"static ngx_int_t
ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,
    size_t len, ngx_str_t *replacement)
{
    u_char  *p, *data;
    size_t   new_len;

    new_len = replacement->len + h->value.len - len;

    if (replacement->len > len) {

        data = ngx_pnalloc(r->pool, new_len + 1);
        if (data == NULL) {
            return NGX_ERROR;
        }

        p = ngx_copy(data, h->value.data, prefix);
        p = ngx_copy(p, replacement->data, replacement->len);

        ngx_memcpy(p, h->value.data + prefix + len,
                   h->value.len - len - prefix + 1);

        h->value.data = data;

    } else {
        p = ngx_copy(h->value.data + prefix, replacement->data,
                     replacement->len);

        ngx_memmove(p, h->value.data + prefix + len,
                    h->value.len - len - prefix + 1);
    }

    h->value.len = new_len;

    return NGX_OK;
}",2706.0,2741.0,1.0,1.0,36.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,ngx_int_t
493,229801,pos,3,ngx_http_sub_ctx_t.pos,,http\modules\ngx_http_sub_filter_module.c,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
494,229802,copy_start,3,ngx_http_sub_ctx_t.copy_start,,http\modules\ngx_http_sub_filter_module.c,*copy_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
495,398432,ngx_atomic_cmp_set,1,ngx_atomic_cmp_set,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)",os\unix\ngx_sunpro_atomic_sparc64.h,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    set = NGX_CASA(set, old, lock);

    return (set == old);
}",25.0,31.0,1.0,10.0,7.0,4,3,4,3,1,0,2,2,0,0,,0,0,6,3,3,ANY
496,62561,ngx_rstrncmp,1,ngx_rstrncmp,"ngx_int_t ngx_rstrncmp (u_char*,u_char*,size_t)",core\ngx_string.c,"ngx_int_t
ngx_rstrncmp(u_char *s1, u_char *s2, size_t n)
{
    if (n == 0) {
        return 0;
    }

    n--;

    for ( ;; ) {
        if (s1[n] != s2[n]) {
            return s1[n] - s2[n];
        }

        if (n == 0) {
            return 0;
        }

        n--;
    }
}",763.0,783.0,1.0,1.0,21.0,10,5,12,3,1,0,5,7,0,0,,0,0,6,3,3,ngx_int_t
497,229803,copy_end,3,ngx_http_sub_ctx_t.copy_end,,http\modules\ngx_http_sub_filter_module.c,*copy_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
498,229804,in,3,ngx_http_sub_ctx_t.in,,http\modules\ngx_http_sub_filter_module.c,*in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
499,263275,ngx_http_subrequest,1,ngx_http_subrequest,"ngx_int_t ngx_http_subrequest (ngx_http_request_t*,ngx_str_t*,ngx_str_t*,ngx_http_request_t**,ngx_http_post_subrequest_t*,ngx_uint_t)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_subrequest(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,
    ngx_http_post_subrequest_t *ps, ngx_uint_t flags)
{
    ngx_time_t                    *tp;
    ngx_connection_t              *c;
    ngx_http_request_t            *sr;
    ngx_http_core_srv_conf_t      *cscf;
    ngx_http_postponed_request_t  *pr, *p;

    if (r->subrequests == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""subrequests cycle while processing \""%V\"""", uri);
        return NGX_ERROR;
    }

    /*
     * 1000 is reserved for other purposes.
     */
    if (r->main->count >= 65535 - 1000) {
        ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
                      ""request reference counter overflow ""
                      ""while processing \""%V\"""", uri);
        return NGX_ERROR;
    }

    if (r->subrequest_in_memory) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""neste...",2297.0,2478.0,1.0,1.0,182.0,202,16,173,33,2,18,16,21,2,11,,0,12,12,6,6,ngx_int_t
500,229805,out,3,ngx_http_sub_ctx_t.out,,http\modules\ngx_http_sub_filter_module.c,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
501,83058,ngx_event_post_acceptex,1,ngx_event_post_acceptex,"ngx_int_t ngx_event_post_acceptex (ngx_listening_t*,ngx_uint_t)",event\ngx_event_acceptex.c,"ngx_int_t
ngx_event_post_acceptex(ngx_listening_t *ls, ngx_uint_t n)
{
    u_long             rcvd;
    ngx_err_t          err;
    ngx_log_t         *log;
    ngx_uint_t         i;
    ngx_event_t       *rev, *wev;
    ngx_socket_t       s;
    ngx_connection_t  *c;

    for (i = 0; i < n; i++) {

        /* TODO: look up reused sockets */

        s = ngx_socket(ls->sockaddr->sa_family, ls->type, 0);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, &ls->log, 0,
                       ngx_socket_n "" s:%d"", s);

        if (s == (ngx_socket_t) -1) {
            ngx_log_error(NGX_LOG_ALERT, &ls->log, ngx_socket_errno,
                          ngx_socket_n "" failed"");

            return NGX_ERROR;
        }

        c = ngx_get_connection(s, &ls->log);

        if (c == NULL) {
            return NGX_ERROR;
        }

        c->pool = ngx_create_pool(ls->pool_size, &ls->log);
        if (c->pool == NULL) {
            ngx_close_posted_connection(c);
            return NGX_ERROR;
      ...",90.0,199.0,1.0,1.0,110.0,101,13,105,24,2,14,12,23,0,14,,0,6,4,2,2,ngx_int_t
502,152691,ngx_http_image_body_filter,1,ngx_http_image_body_filter,"ngx_int_t ngx_http_image_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_image_filter_module.c,"static ngx_int_t
ngx_http_image_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                      rc;
    ngx_str_t                     *ct;
    ngx_chain_t                    out;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""image filter"");

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    switch (ctx->phase) {

    case NGX_HTTP_IMAGE_START:

        ctx->type = ngx_http_image_test(r, in);

        conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

        if (ctx->type == NGX_HTTP_IMAGE_NONE) {

            if (conf->filter == NGX_HTTP_IMAGE_SIZE) {
                out.buf = ngx_http_image_json(r, NULL);

                if (out.buf) {
                    out.ne...",291.0,397.0,1.0,9.0,107.0,61,9,83,15,0,27,11,21,4,10,,0,21,4,2,2,ngx_int_t
503,229806,last_out,3,ngx_http_sub_ctx_t.last_out,,http\modules\ngx_http_sub_filter_module.c,**last_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
504,398455,ngx_atomic_fetch_add,1,ngx_atomic_fetch_add,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)",os\unix\ngx_sunpro_atomic_sparc64.h,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    ngx_atomic_uint_t  old, res;

    old = *value;

    for ( ;; ) {

        res = old + add;

        res = NGX_CASA(res, old, value);

        if (res == old) {
            return res;
        }

        old = res;
    }
}",35.0,53.0,1.0,14.0,19.0,4,3,5,3,3,0,1,1,0,0,,0,0,4,2,2,ANY
505,418942,service_handler,1,service_handler,"u_int service_handler (u_int,u_int,void*,void*)",os\win32\ngx_service.c,"u_int
service_handler(u_int control, u_int type, void *data, void *ctx)
{
    /* primary thread */

    switch (control) {

    case SERVICE_CONTROL_INTERROGATE:
        status = NGX_IOCP_INTERROGATE;
        break;

    case SERVICE_CONTROL_STOP:
        status = NGX_IOCP_STOP;
        break;

    case SERVICE_CONTROL_PARAMCHANGE:
        status = NGX_IOCP_RECONFIGURE;
        break;

    case NGX_SERVICE_CONTROL_SHUTDOWN:
        status = NGX_IOCP_REOPEN;
        break;

    case NGX_SERVICE_CONTROL_REOPEN:
        status = NGX_IOCP_REOPEN;
        break;

    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (ngx_single) {
        if (PostQueuedCompletionStatus(iocp, ... status, ...) == 0) {
            err = ngx_errno;
            ngx_log_error(NGX_LOG_ALERT, log, err,
                          ""PostQueuedCompletionStatus() failed"");
            return err;
        }

    } else {
        Event
    }

    return NO_ERROR;
}",90.0,134.0,1.0,9.0,45.0,6,1,23,16,0,1,9,5,0,1,,0,0,8,4,4,u_int
506,229809,sub,3,ngx_http_sub_ctx_t.sub,,http\modules\ngx_http_sub_filter_module.c,*sub,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
507,427142,value,3,ngx_stream_geo_range_t.value,,stream\ngx_stream_geo_module.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
508,427143,start,3,ngx_stream_geo_range_t.start,,stream\ngx_stream_geo_module.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
509,427144,end,3,ngx_stream_geo_range_t.end,,stream\ngx_stream_geo_module.c,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
510,229811,offset,3,ngx_http_sub_ctx_t.offset,,http\modules\ngx_http_sub_filter_module.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
511,21645,ngx_parse_unix_domain_url,1,ngx_parse_unix_domain_url,"ngx_int_t ngx_parse_unix_domain_url (ngx_pool_t*,ngx_url_t*)",core\ngx_inet.c,"static ngx_int_t
ngx_parse_unix_domain_url(ngx_pool_t *pool, ngx_url_t *u)
{
#if (NGX_HAVE_UNIX_DOMAIN)
    u_char              *path, *uri, *last;
    size_t               len;
    struct sockaddr_un  *saun;

    len = u->url.len;
    path = u->url.data;

    path += 5;
    len -= 5;

    if (u->uri_part) {

        last = path + len;
        uri = ngx_strlchr(path, last, ':');

        if (uri) {
            len = uri - path;
            uri++;
            u->uri.len = last - uri;
            u->uri.data = uri;
        }
    }

    if (len == 0) {
        u->err = ""no path in the unix domain socket"";
        return NGX_ERROR;
    }

    u->host.len = len++;
    u->host.data = path;

    if (len > sizeof(saun->sun_path)) {
        u->err = ""too long path in the unix domain socket"";
        return NGX_ERROR;
    }

    u->socklen = sizeof(struct sockaddr_un);
    saun = (struct sockaddr_un *) &u->sockaddr;
    saun->sun_family = AF_UNIX;
    (void) ngx_cpystrn((u_char *) saun->sun_p...",704.0,779.0,1.0,1.0,76.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
512,62606,ngx_rstrncasecmp,1,ngx_rstrncasecmp,"ngx_int_t ngx_rstrncasecmp (u_char*,u_char*,size_t)",core\ngx_string.c,"ngx_int_t
ngx_rstrncasecmp(u_char *s1, u_char *s2, size_t n)
{
    u_char  c1, c2;

    if (n == 0) {
        return 0;
    }

    n--;

    for ( ;; ) {
        c1 = s1[n];
        if (c1 >= 'a' && c1 <= 'z') {
            c1 -= 'a' - 'A';
        }

        c2 = s2[n];
        if (c2 >= 'a' && c2 <= 'z') {
            c2 -= 'a' - 'A';
        }

        if (c1 != c2) {
            return c1 - c2;
        }

        if (n == 0) {
            return 0;
        }

        n--;
    }
}",786.0,818.0,1.0,1.0,33.0,20,10,20,5,1,0,7,11,0,0,,0,0,6,3,3,ngx_int_t
513,42128,ngx_resolve_name_done,1,ngx_resolve_name_done,void ngx_resolve_name_done (ngx_resolver_ctx_t*),core\ngx_resolver.c,"void
ngx_resolve_name_done(ngx_resolver_ctx_t *ctx)
{
    ngx_uint_t            i;
    ngx_resolver_t       *r;
    ngx_resolver_ctx_t   *w, **p;
    ngx_resolver_node_t  *rn;

    r = ctx->resolver;

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve name done: %i"", ctx->state);

    if (ctx->quick) {
        return;
    }

    if (ctx->event && ctx->event->timer_set) {
        ngx_del_timer(ctx->event);
    }

    /* lock name mutex */

    if (ctx->nsrvs) {
        for (i = 0; i < ctx->nsrvs; i++) {
            if (ctx->srvs[i].ctx) {
                ngx_resolve_name_done(ctx->srvs[i].ctx);
            }

            if (ctx->srvs[i].addrs) {
                ngx_resolver_free(r, ctx->srvs[i].addrs->sockaddr);
                ngx_resolver_free(r, ctx->srvs[i].addrs);
            }

            ngx_resolver_free(r, ctx->srvs[i].name.data);
        }

        ngx_resolver_free(r, ctx->srvs);
    }

    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOL...",489.0,577.0,1.0,1.0,89.0,71,10,65,10,0,11,15,25,1,9,,0,3,2,1,1,void
514,316559,ngx_http_upstream_bind_set_slot,1,ngx_http_upstream_bind_set_slot,"char* ngx_http_upstream_bind_set_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http_upstream.c,"char *
ngx_http_upstream_bind_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_int_t                           rc;
    ngx_str_t                          *value;
    ngx_http_complex_value_t            cv;
    ngx_http_upstream_local_t         **plocal, *local;
    ngx_http_compile_complex_value_t    ccv;

    plocal = (ngx_http_upstream_local_t **) (p + cmd->offset);

    if (*plocal != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2 && ngx_strcmp(value[1].data, ""off"") == 0) {
        *plocal = NULL;
        return NGX_CONF_OK;
    }

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    local = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_local_t));
    if (local == NULL) {
        re...",6103.0,6200.0,1.0,1.0,98.0,54,13,47,18,0,11,9,11,3,4,,0,10,6,3,3,char*
515,21651,ngx_parse_inet_url,1,ngx_parse_inet_url,"ngx_int_t ngx_parse_inet_url (ngx_pool_t*,ngx_url_t*)",core\ngx_inet.c,"static ngx_int_t
ngx_parse_inet_url(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char              *host, *port, *last, *uri, *args, *dash;
    size_t               len;
    ngx_int_t            n;
    struct sockaddr_in  *sin;

    u->socklen = sizeof(struct sockaddr_in);
    sin = (struct sockaddr_in *) &u->sockaddr;
    sin->sin_family = AF_INET;

    u->family = AF_INET;

    host = u->url.data;

    last = host + u->url.len;

    port = ngx_strlchr(host, last, ':');

    uri = ngx_strlchr(host, last, '/');

    args = ngx_strlchr(host, last, '?');

    if (args) {
        if (uri == NULL || args < uri) {
            uri = args;
        }
    }

    if (uri) {
        if (u->listen || !u->uri_part) {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        u->uri.len = last - uri;
        u->uri.data = uri;

        last = uri;

        if (uri < port) {
            port = NULL;
        }
    }

    if (port) {
        port++;

        len = last - port;
...",782.0,985.0,1.0,1.0,204.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
516,91285,ngx_ssl_session_ticket_keys,1,ngx_ssl_session_ticket_keys,"ngx_int_t ngx_ssl_session_ticket_keys (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)
{
    if (paths) {
        ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                      ""\""ssl_session_ticket_key\"" ignored, not supported"");
    }

    return NGX_OK;
}",4064.0,4073.0,1.0,1.0,10.0,1,1,4,4,0,1,2,2,0,1,,0,0,6,3,3,ngx_int_t
517,21657,ngx_parse_inet6_url,1,ngx_parse_inet6_url,"ngx_int_t ngx_parse_inet6_url (ngx_pool_t*,ngx_url_t*)",core\ngx_inet.c,"static ngx_int_t
ngx_parse_inet6_url(ngx_pool_t *pool, ngx_url_t *u)
{
#if (NGX_HAVE_INET6)
    u_char               *p, *host, *port, *last, *uri, *dash;
    size_t                len;
    ngx_int_t             n;
    struct sockaddr_in6  *sin6;

    u->socklen = sizeof(struct sockaddr_in6);
    sin6 = (struct sockaddr_in6 *) &u->sockaddr;
    sin6->sin6_family = AF_INET6;

    host = u->url.data + 1;

    last = u->url.data + u->url.len;

    p = ngx_strlchr(host, last, ']');

    if (p == NULL) {
        u->err = ""invalid host"";
        return NGX_ERROR;
    }

    port = p + 1;

    uri = ngx_strlchr(port, last, '/');

    if (uri) {
        if (u->listen || !u->uri_part) {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        u->uri.len = last - uri;
        u->uri.data = uri;

        last = uri;
    }

    if (port < last) {
        if (*port != ':') {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        port++;...",988.0,1111.0,1.0,1.0,124.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
518,398490,ngx_write_channel,1,ngx_write_channel,"ngx_int_t ngx_write_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)",os\unix\ngx_channel.c,"ngx_int_t
ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
    ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)

    union {
        struct cmsghdr  cm;
        char            space[CMSG_SPACE(sizeof(int))];
    } cmsg;

    if (ch->fd == -1) {
        msg.msg_control = NULL;
        msg.msg_controllen = 0;

    } else {
        msg.msg_control = (caddr_t) &cmsg;
        msg.msg_controllen = sizeof(cmsg);

        ngx_memzero(&cmsg, sizeof(cmsg));

        cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));
        cmsg.cm.cmsg_level = SOL_SOCKET;
        cmsg.cm.cmsg_type = SCM_RIGHTS;

        /*
         * We have to use ngx_memcpy() instead of simple
         *   *(int *) CMSG_DATA(&cmsg.cm) = ch->fd;
         * because some gcc 4.4 with -O2/3/s optimization issues the warning:
         *   dereferencing type-punned pointer will break strict-aliasing r...",13.0,92.0,1.0,1.0,80.0,28,8,28,15,0,2,4,5,1,1,,0,1,8,4,4,ngx_int_t
519,132255,upstream,3,ngx_http_grpc_loc_conf_t.upstream,,http\modules\ngx_http_grpc_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
520,21663,ngx_inet_add_addr,1,ngx_inet_add_addr,"ngx_int_t ngx_inet_add_addr (ngx_pool_t*,ngx_url_t*,sockaddr*,socklen_t,ngx_uint_t)",core\ngx_inet.c,"static ngx_int_t
ngx_inet_add_addr(ngx_pool_t *pool, ngx_url_t *u, struct sockaddr *sockaddr,
    socklen_t socklen, ngx_uint_t total)
{
    u_char           *p;
    size_t            len;
    ngx_uint_t        i, nports;
    ngx_addr_t       *addr;
    struct sockaddr  *sa;

    nports = u->last_port ? u->last_port - u->port + 1 : 1;

    if (u->addrs == NULL) {
        u->addrs = ngx_palloc(pool, total * nports * sizeof(ngx_addr_t));
        if (u->addrs == NULL) {
            return NGX_ERROR;
        }
    }

    for (i = 0; i < nports; i++) {
        sa = ngx_pcalloc(pool, socklen);
        if (sa == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(sa, sockaddr, socklen);

        ngx_inet_set_port(sa, u->port + i);

        switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            len = NGX_INET6_ADDRSTRLEN + sizeof(""[]:65536"") - 1;
            break;
#endif

        default: /* AF_INET */
            len = NGX_INET_ADDRSTRLEN + sizeo...",1262.0,1320.0,1.0,1.0,59.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,ngx_int_t
521,115873,upstream,3,ngx_http_fastcgi_loc_conf_t.upstream,,http\modules\ngx_http_fastcgi_module.c,upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
522,132258,host,3,ngx_http_grpc_loc_conf_t.host,,http\modules\ngx_http_grpc_module.c,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
523,132260,grpc_lengths,3,ngx_http_grpc_loc_conf_t.grpc_lengths,,http\modules\ngx_http_grpc_module.c,*grpc_lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
524,214181,md5,3,ngx_http_secure_link_conf_t.md5,,http\modules\ngx_http_secure_link_module.c,*md5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
525,214182,secret,3,ngx_http_secure_link_conf_t.secret,,http\modules\ngx_http_secure_link_module.c,secret,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
526,107687,ngx_http_charset_body_filter,1,ngx_http_charset_body_filter,"ngx_int_t ngx_http_charset_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_charset_filter_module.c,"static ngx_int_t
ngx_http_charset_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                rc;
    ngx_buf_t               *b;
    ngx_chain_t             *cl, *out, **ll;
    ngx_http_charset_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_charset_filter_module);

    if (ctx == NULL || ctx->table == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if ((ctx->to_utf8 || ctx->from_utf8) || ctx->busy) {

        out = NULL;
        ll = &out;

        for (cl = in; cl; cl = cl->next) {
            b = cl->buf;

            if (ngx_buf_size(b) == 0) {

                *ll = ngx_alloc_chain_link(r->pool);
                if (*ll == NULL) {
                    return NGX_ERROR;
                }

                (*ll)->buf = b;
                (*ll)->next = NULL;

                ll = &(*ll)->next;

                continue;
            }

            if (ctx->to_utf8) {
                *ll = ngx_http_charset_recode_to_utf8(r->pool...",546.0,648.0,1.0,1.0,103.0,81,9,83,12,0,20,21,41,8,3,,0,19,4,2,2,ngx_int_t
527,91304,ngx_ssl_cleanup_ctx,1,ngx_ssl_cleanup_ctx,void ngx_ssl_cleanup_ctx (void*),event\ngx_event_openssl.c,"void
ngx_ssl_cleanup_ctx(void *data)
{
    ngx_ssl_t  *ssl = data;

    X509  *cert, *next;

    cert = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);

    while (cert) {
        next = X509_get_ex_data(cert, ngx_ssl_next_certificate_index);
        X509_free(cert);
        cert = next;
    }

    SSL_CTX_free(ssl->ctx);
}",4078.0,4094.0,1.0,1.0,17.0,6,2,13,6,0,2,2,2,0,0,,0,2,2,1,1,void
528,214185,expires,3,ngx_http_secure_link_ctx_t.expires,,http\modules\ngx_http_secure_link_module.c,expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
529,214186,ngx_http_secure_link_ctx_t,2,http\modules\ngx_http_secure_link_module.c.ngx_http_secure_link_ctx_t,,http\modules\ngx_http_secure_link_module.c,struct ngx_http_secure_link_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
530,214180,variable,3,ngx_http_secure_link_conf_t.variable,,http\modules\ngx_http_secure_link_module.c,*variable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
531,115879,fastcgi_lengths,3,ngx_http_fastcgi_loc_conf_t.fastcgi_lengths,,http\modules\ngx_http_fastcgi_module.c,*fastcgi_lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
532,214187,ngx_http_secure_link_old_variable,1,ngx_http_secure_link_old_variable,"ngx_int_t ngx_http_secure_link_old_variable (ngx_http_request_t*,ngx_http_secure_link_conf_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_secure_link_module.c,"static ngx_int_t
ngx_http_secure_link_old_variable(ngx_http_request_t *r,
    ngx_http_secure_link_conf_t *conf, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char      *p, *start, *end, *last;
    size_t       len;
    ngx_int_t    n;
    ngx_uint_t   i;
    ngx_md5_t    md5;
    u_char       hash[16];

    p = &r->unparsed_uri.data[1];
    last = r->unparsed_uri.data + r->unparsed_uri.len;

    while (p < last) {
        if (*p++ == '/') {
            start = p;
            goto md5_start;
        }
    }

    goto not_found;

md5_start:

    while (p < last) {
        if (*p++ == '/') {
            end = p - 1;
            goto url_start;
        }
    }

    goto not_found;

url_start:

    len = last - p;

    if (end - start != 32 || len == 0) {
        goto not_found;
    }

    ngx_md5_init(&md5);
    ngx_md5_update(&md5, p, len);
    ngx_md5_update(&md5, conf->secret.data, conf->secret.len);
    ngx_md5_final(hash, &md5);

    for (i = 0; i < 16; i++) {
        ...",198.0,266.0,1.0,1.0,69.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
533,21672,ngx_inet_addr,1,ngx_inet_addr,"in_addr_t ngx_inet_addr (u_char*,size_t)",core\ngx_inet.c,"in_addr_t
ngx_inet_addr(u_char *text, size_t len)
{
    u_char      *p, c;
    in_addr_t    addr;
    ngx_uint_t   octet, n;

    addr = 0;
    octet = 0;
    n = 0;

    for (p = text; p < text + len; p++) {
        c = *p;

        if (c >= '0' && c <= '9') {
            octet = octet * 10 + (c - '0');

            if (octet > 255) {
                return INADDR_NONE;
            }

            continue;
        }

        if (c == '.') {
            addr = (addr << 8) + octet;
            octet = 0;
            n++;
            continue;
        }

        return INADDR_NONE;
    }

    if (n == 3) {
        addr = (addr << 8) + octet;
        return htonl(addr);
    }

    return INADDR_NONE;
}",19.0,59.0,1.0,1.0,41.0,26,13,30,8,4,0,8,10,0,0,,0,0,4,2,2,in_addr_t
534,251054,ngx_http_perl_module,2,http\modules\perl\ngx_http_perl_module.c.ngx_http_perl_module,,http\modules\perl\ngx_http_perl_module.c,ngx_module_t ngx_http_perl_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
535,427185,ngx_stream_geo_addr,1,ngx_stream_geo_addr,"ngx_int_t ngx_stream_geo_addr (ngx_stream_session_t*,ngx_stream_geo_ctx_t*,ngx_addr_t*)",stream\ngx_stream_geo_module.c,"static ngx_int_t
ngx_stream_geo_addr(ngx_stream_session_t *s, ngx_stream_geo_ctx_t *ctx,
    ngx_addr_t *addr)
{
    ngx_stream_variable_value_t  *v;

    if (ctx->index == -1) {
        ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream geo started: %V"", &s->connection->addr_text);

        addr->sockaddr = s->connection->sockaddr;
        addr->socklen = s->connection->socklen;
        /* addr->name = s->connection->addr_text; */

        return NGX_OK;
    }

    v = ngx_stream_get_flushed_variable(s, ctx->index);

    if (v == NULL || v->not_found) {
        ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream geo not found"");

        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream geo started: %v"", v);

    if (ngx_parse_addr(s->connection->pool, addr, v->data, v->len) == NGX_OK) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",317.0,351.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
536,300224,ngx_http_script_start_code,1,ngx_http_script_start_code,"void* ngx_http_script_start_code (ngx_pool_t*,ngx_array_t**,size_t)",http\ngx_http_script.c,"void *
ngx_http_script_start_code(ngx_pool_t *pool, ngx_array_t **codes, size_t size)
{
    if (*codes == NULL) {
        *codes = ngx_array_create(pool, 256, 1);
        if (*codes == NULL) {
            return NULL;
        }
    }

    return ngx_array_push_n(*codes, size);
}",732.0,743.0,1.0,1.0,12.0,7,3,9,4,0,2,3,4,0,2,,0,1,6,3,3,void*
537,87233,ngx_ssl_set_session,1,ngx_ssl_set_session,"ngx_int_t ngx_ssl_set_session (ngx_connection_t*,ngx_ssl_session_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session)
{
    if (session) {
        if (SSL_set_session(c->ssl->connection, session) == 0) {
            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_set_session() failed"");
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1586.0,1597.0,1.0,1.0,12.0,4,2,7,5,0,1,3,4,0,1,,0,0,4,2,2,ngx_int_t
538,251075,nginx_stash,2,http\modules\perl\ngx_http_perl_module.c.nginx_stash,,http\modules\perl\ngx_http_perl_module.c,HV* nginx_stash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
539,251077,ngx_http_perl_xs_init,1,ngx_http_perl_xs_init,void ngx_http_perl_xs_init (ANY),http\modules\perl\ngx_http_perl_module.c,"static void
ngx_http_perl_xs_init(pTHX)
{
    newXS(""DynaLoader::boot_DynaLoader"", boot_DynaLoader, __FILE__);

    nginx_stash = gv_stashpv(""nginx"", TRUE);
}",161.0,167.0,1.0,58.0,7.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
540,91339,ngx_ssl_check_host,1,ngx_ssl_check_host,"ngx_int_t ngx_ssl_check_host (ngx_connection_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name)
{
    X509   *cert;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_ERROR;
    }

#ifdef X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT

    /* X509_check_host() is only available in OpenSSL 1.0.2+ */

    if (name->len == 0) {
        goto failed;
    }

    if (X509_check_host(cert, (char *) name->data, name->len, 0, NULL) != 1) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""X509_check_host(): no match"");
        goto failed;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""X509_check_host(): match"");

    goto found;

#else
    {
    int                      n, i;
    X509_NAME               *sname;
    ASN1_STRING             *str;
    X509_NAME_ENTRY         *entry;
    GENERAL_NAME            *altname;
    STACK_OF(GENERAL_NAME)  *altnames;

    /*
     * As per RFC6125 and RFC2818, we check subjectAltName ...",4097.0,4221.0,1.0,1.0,125.0,31,8,68,18,0,2,16,17,2,2,,0,2,4,2,2,ngx_int_t
541,58573,ngx_slab_alloc,1,ngx_slab_alloc,"void* ngx_slab_alloc (ngx_slab_pool_t*,size_t)",core\ngx_slab.c,"void *
ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_alloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}",168.0,180.0,1.0,1.0,13.0,5,3,6,3,10,5,1,1,0,3,,0,3,4,2,2,void*
542,9421,ngx_configure_listening_sockets,1,ngx_configure_listening_sockets,void ngx_configure_listening_sockets (ngx_cycle_t*),core\ngx_connection.c,"void
ngx_configure_listening_sockets(ngx_cycle_t *cycle)
{
    int                        value;
    ngx_uint_t                 i;
    ngx_listening_t           *ls;

#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
    struct accept_filter_arg   af;
#endif

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        ls[i].log = *ls[i].logp;

        if (ls[i].rcvbuf != -1) {
            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_RCVBUF,
                           (const void *) &ls[i].rcvbuf, sizeof(int))
                == -1)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,
                              ""setsockopt(SO_RCVBUF, %d) %V failed, ignored"",
                              ls[i].rcvbuf, &ls[i].addr_text);
            }
        }

        if (ls[i].sndbuf != -1) {
            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_SNDBUF,
                           (const void *) &ls[i].sndbuf, sizeof(int))
     ...",712.0,1017.0,1.0,1.0,306.0,83,13,71,11,1,4,10,22,0,4,,0,0,2,1,1,void
543,115924,ngx_http_fastcgi_ctx_t,2,http\modules\ngx_http_fastcgi_module.c.ngx_http_fastcgi_ctx_t,,http\modules\ngx_http_fastcgi_module.c,struct ngx_http_fastcgi_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
544,251093,ngx_http_perl_handler,1,ngx_http_perl_handler,ngx_int_t ngx_http_perl_handler (ngx_http_request_t*),http\modules\perl\ngx_http_perl_module.c,"static ngx_int_t
ngx_http_perl_handler(ngx_http_request_t *r)
{
    r->main->count++;

    ngx_http_perl_handle_request(r);

    return NGX_DONE;
}",170.0,178.0,1.0,1.0,9.0,3,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,ngx_int_t
545,87264,ngx_ssl_handshake,1,ngx_ssl_handshake,ngx_int_t ngx_ssl_handshake (ngx_connection_t*),event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_handshake(ngx_connection_t *c)
{
    int        n, sslerr;
    ngx_err_t  err;
    ngx_int_t  rc;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->try_early_data) {
        return ngx_ssl_try_early_data(c);
    }
#endif

    if (c->ssl->in_ocsp) {
        return ngx_ssl_ocsp_validate(c);
    }

    ngx_ssl_clear_error(c->log);

    n = SSL_do_handshake(c->ssl->connection);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_do_handshake: %d"", n);

    if (n == 1) {

        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            return NGX_ERROR;
        }

        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
            return NGX_ERROR;
        }

#if (NGX_DEBUG)
        ngx_ssl_handshake_log(c);
#endif

        c->recv = ngx_ssl_recv;
        c->send = ngx_ssl_write;
        c->recv_chain = ngx_ssl_recv_chain;
        c->send_chain = ngx_ssl_send_chain;

#ifndef SSL_OP_NO_RENEGOTIATION
#if OPENSSL_VERSION_NUMBER < 0x10100000L
#ifdef SSL3_F...",1600.0,1726.0,1.0,1.0,127.0,82,6,84,15,0,11,14,22,6,11,,0,7,2,1,1,ngx_int_t
546,300257,ngx_http_script_add_code,1,ngx_http_script_add_code,"void* ngx_http_script_add_code (ngx_array_t*,size_t,void*)",http\ngx_http_script.c,"void *
ngx_http_script_add_code(ngx_array_t *codes, size_t size, void *code)
{
    u_char  *elts, **p;
    void    *new;

    elts = codes->elts;

    new = ngx_array_push_n(codes, size);
    if (new == NULL) {
        return NULL;
    }

    if (code) {
        if (elts != codes->elts) {
            p = code;
            *p += (u_char *) codes->elts - elts;
        }
    }

    return new;
}",746.0,767.0,1.0,1.0,22.0,12,8,17,7,0,4,4,5,1,1,,0,4,6,3,3,void*
547,144611,enable,3,ngx_http_gunzip_conf_t.enable,,http\modules\ngx_http_gunzip_filter_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
548,251108,ngx_http_perl_handle_request,1,ngx_http_perl_handle_request,void ngx_http_perl_handle_request (ngx_http_request_t*),http\modules\perl\ngx_http_perl_module.c,"void
ngx_http_perl_handle_request(ngx_http_request_t *r)
{
    SV                         *sub;
    ngx_int_t                   rc;
    ngx_str_t                   uri, args, *handler;
    ngx_uint_t                  flags;
    ngx_http_perl_ctx_t        *ctx;
    ngx_http_perl_loc_conf_t   *plcf;
    ngx_http_perl_main_conf_t  *pmcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""perl handler"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_perl_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_perl_ctx_t));
        if (ctx == NULL) {
            ngx_http_finalize_request(r, NGX_ERROR);
            return;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_perl_module);

        ctx->request = r;
    }

    pmcf = ngx_http_get_module_main_conf(r, ngx_http_perl_module);

    {

    dTHXa(pmcf->perl);
    PERL_SET_CONTEXT(pmcf->perl);
    PERL_SET_INTERP(pmcf->perl);

    if (ctx->next == NULL) {
        plcf = ngx_http_get_module...",181.0,285.0,1.0,1.0,105.0,50,9,69,17,2,28,11,13,6,8,,0,21,2,1,1,void
549,58597,ngx_slab_alloc_locked,1,ngx_slab_alloc_locked,"void* ngx_slab_alloc_locked (ngx_slab_pool_t*,size_t)",core\ngx_slab.c,"void *
ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
{
    size_t            s;
    uintptr_t         p, m, mask, *bitmap;
    ngx_uint_t        i, n, slot, shift, map;
    ngx_slab_page_t  *page, *prev, *slots;

    if (size > ngx_slab_max_size) {

        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                       ""slab alloc: %uz"", size);

        page = ngx_slab_alloc_pages(pool, (size >> ngx_pagesize_shift)
                                          + ((size % ngx_pagesize) ? 1 : 0));
        if (page) {
            p = ngx_slab_page_addr(pool, page);

        } else {
            p = 0;
        }

        goto done;
    }

    if (size > pool->min_size) {
        shift = 1;
        for (s = size - 1; s >>= 1; shift++) { /* void */ }
        slot = shift - pool->min_shift;

    } else {
        shift = pool->min_shift;
        slot = 0;
    }

    pool->stats[slot].reqs++;

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                 ...",183.0,417.0,1.0,16.0,235.0,179,25,175,24,4,18,24,61,4,4,,0,16,4,2,2,void*
550,144615,in,3,ngx_http_gunzip_ctx_t.in,,http\modules\ngx_http_gunzip_filter_module.c,*in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
551,144616,free,3,ngx_http_gunzip_ctx_t.free,,http\modules\ngx_http_gunzip_filter_module.c,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
552,144617,busy,3,ngx_http_gunzip_ctx_t.busy,,http\modules\ngx_http_gunzip_filter_module.c,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
553,144618,out,3,ngx_http_gunzip_ctx_t.out,,http\modules\ngx_http_gunzip_filter_module.c,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
554,144619,last_out,3,ngx_http_gunzip_ctx_t.last_out,,http\modules\ngx_http_gunzip_filter_module.c,**last_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
555,144623,started,3,ngx_http_gunzip_ctx_t.started,,http\modules\ngx_http_gunzip_filter_module.c,started:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
556,144626,done,3,ngx_http_gunzip_ctx_t.done,,http\modules\ngx_http_gunzip_filter_module.c,done:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
557,132339,request,3,ngx_http_grpc_ctx_t.request,,http\modules\ngx_http_grpc_module.c,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
558,132340,host,3,ngx_http_grpc_ctx_t.host,,http\modules\ngx_http_grpc_module.c,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
559,144627,nomem,3,ngx_http_gunzip_ctx_t.nomem,,http\modules\ngx_http_gunzip_filter_module.c,nomem:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
560,115958,ngx_http_fastcgi_eval,1,ngx_http_fastcgi_eval,"ngx_int_t ngx_http_fastcgi_eval (ngx_http_request_t*,ngx_http_fastcgi_loc_conf_t*)",http\modules\ngx_http_fastcgi_module.c,"static ngx_int_t
ngx_http_fastcgi_eval(ngx_http_request_t *r, ngx_http_fastcgi_loc_conf_t *flcf)
{
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, flcf->fastcgi_lengths->elts, 0,
                            flcf->fastcgi_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    url.no_resolve = 1;

    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
        if (url.err) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""%s in upstream \""%V\"""", url.err, &url.url);
        }

        return NGX_ERROR;
    }

    u = r->upstream;

    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
    if (u->resolved == NULL) {
        return NGX_ERROR;
    }

    if (url.addrs) {
        u->resolved->sockaddr = url.addrs[0].sockaddr;
        u->resolved->socklen = url.addrs[0].socklen;
        u->resolved->name = url.addrs[0]....",758.0,803.0,1.0,1.0,46.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
561,144629,request,3,ngx_http_gunzip_ctx_t.request,,http\modules\ngx_http_gunzip_filter_module.c,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
562,144630,ngx_http_gunzip_ctx_t,2,http\modules\ngx_http_gunzip_filter_module.c.ngx_http_gunzip_ctx_t,,http\modules\ngx_http_gunzip_filter_module.c,struct ngx_http_gunzip_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
563,144631,ngx_http_gunzip_filter_inflate_start,1,ngx_http_gunzip_filter_inflate_start,"ngx_int_t ngx_http_gunzip_filter_inflate_start (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)",http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_filter_inflate_start(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    int  rc;

    ctx->zstream.next_in = Z_NULL;
    ctx->zstream.avail_in = 0;

    ctx->zstream.zalloc = ngx_http_gunzip_filter_alloc;
    ctx->zstream.zfree = ngx_http_gunzip_filter_free;
    ctx->zstream.opaque = ctx;

    /* windowBits +16 to decode gzip, zlib 1.2.0.4+ */
    rc = inflateInit2(&ctx->zstream, MAX_WBITS + 16);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""inflateInit2() failed: %d"", rc);
        return NGX_ERROR;
    }

    ctx->started = 1;

    ctx->last_out = &ctx->out;
    ctx->flush = Z_NO_FLUSH;

    return NGX_OK;
}",301.0,329.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
564,15720,ngx_test_full_name,1,ngx_test_full_name,ngx_int_t ngx_test_full_name (ngx_str_t*),core\ngx_file.c,"static ngx_int_t
ngx_test_full_name(ngx_str_t *name)
{
#if (NGX_WIN32)
    u_char  c0, c1;

    c0 = name->data[0];

    if (name->len < 2) {
        if (c0 == '/') {
            return 2;
        }

        return NGX_DECLINED;
    }

    c1 = name->data[1];

    if (c1 == ':') {
        c0 |= 0x20;

        if ((c0 >= 'a' && c0 <= 'z')) {
            return NGX_OK;
        }

        return NGX_DECLINED;
    }

    if (c1 == '/') {
        return NGX_OK;
    }

    if (c0 == '/') {
        return 2;
    }

    return NGX_DECLINED;

#else

    if (name->data[0] == '/') {
        return NGX_OK;
    }

    return NGX_DECLINED;

#endif
}",58.0,105.0,1.0,1.0,48.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
565,132347,ngx_http_grpc_ctx_t,2,http\modules\ngx_http_grpc_module.c.ngx_http_grpc_ctx_t,,http\modules\ngx_http_grpc_module.c,struct ngx_http_grpc_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
566,144637,ngx_http_gunzip_filter_add_data,1,ngx_http_gunzip_filter_add_data,"ngx_int_t ngx_http_gunzip_filter_add_data (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)",http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_filter_add_data(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    if (ctx->zstream.avail_in || ctx->flush != Z_NO_FLUSH || ctx->redo) {
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gunzip in: %p"", ctx->in);

    if (ctx->in == NULL) {
        return NGX_DECLINED;
    }

    ctx->in_buf = ctx->in->buf;
    ctx->in = ctx->in->next;

    ctx->zstream.next_in = ctx->in_buf->pos;
    ctx->zstream.avail_in = ctx->in_buf->last - ctx->in_buf->pos;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gunzip in_buf:%p ni:%p ai:%ud"",
                   ctx->in_buf,
                   ctx->zstream.next_in, ctx->zstream.avail_in);

    if (ctx->in_buf->last_buf || ctx->in_buf->last_in_chain) {
        ctx->flush = Z_FINISH;

    } else if (ctx->in_buf->flush) {
        ctx->flush = Z_SYNC_FLUSH;

    } else if (ctx->zstream.avail_in == 0) {
        /* ctx->...",332.0,370.0,1.0,1.0,39.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
567,328959,ngx_http_v2_create_stream,1,ngx_http_v2_create_stream,"ngx_http_v2_stream_t* ngx_http_v2_create_stream (ngx_http_v2_connection_t*,ngx_uint_t)",http\v2\ngx_http_v2.c,"static ngx_http_v2_stream_t *
ngx_http_v2_create_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t push)
{
    ngx_log_t                 *log;
    ngx_event_t               *rev, *wev;
    ngx_connection_t          *fc;
    ngx_http_log_ctx_t        *ctx;
    ngx_http_request_t        *r;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_core_srv_conf_t  *cscf;

    fc = h2c->free_fake_connections;

    if (fc) {
        h2c->free_fake_connections = fc->data;

        rev = fc->read;
        wev = fc->write;
        log = fc->log;
        ctx = log->data;

    } else {
        fc = ngx_palloc(h2c->pool, sizeof(ngx_connection_t));
        if (fc == NULL) {
            return NULL;
        }

        rev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
        if (rev == NULL) {
            return NULL;
        }

        wev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
        if (wev == NULL) {
            return NULL;
        }

        log = ng...",2961.0,3105.0,1.0,1.0,145.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_http_v2_stream_t
568,464130,ngx_stream_get_indexed_variable,1,ngx_stream_get_indexed_variable,"ngx_stream_variable_value_t ngx_stream_get_indexed_variable (ngx_stream_session_t*,ngx_uint_t)",stream\ngx_stream_variables.c,"ngx_stream_variable_value_t *
ngx_stream_get_indexed_variable(ngx_stream_session_t *s, ngx_uint_t index)
{
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    if (cmcf->variables.nelts <= index) {
        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,
                      ""unknown variable index: %ui"", index);
        return NULL;
    }

    if (s->variables[index].not_found || s->variables[index].valid) {
        return &s->variables[index];
    }

    v = cmcf->variables.elts;

    if (ngx_stream_variable_depth == 0) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""cycle while evaluating variable \""%V\"""",
                      &v[index].name);
        return NULL;
    }

    ngx_stream_variable_depth--;

    if (v[index].get_handler(s, &s->variables[index], v[index].data)
        == NGX_OK)
    {
        ngx_stream_variable_depth++;

       ...",332.0,379.0,1.0,1.0,48.0,54,11,46,11,3,8,6,7,2,2,,0,6,4,2,2,ngx_stream_variable_value_t
569,144643,ngx_http_gunzip_filter_get_buf,1,ngx_http_gunzip_filter_get_buf,"ngx_int_t ngx_http_gunzip_filter_get_buf (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)",http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_filter_get_buf(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    ngx_http_gunzip_conf_t  *conf;

    if (ctx->zstream.avail_out) {
        return NGX_OK;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gunzip_filter_module);

    if (ctx->free) {
        ctx->out_buf = ctx->free->buf;
        ctx->free = ctx->free->next;

        ctx->out_buf->flush = 0;

    } else if (ctx->bufs < conf->bufs.num) {

        ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
        if (ctx->out_buf == NULL) {
            return NGX_ERROR;
        }

        ctx->out_buf->tag = (ngx_buf_tag_t) &ngx_http_gunzip_filter_module;
        ctx->out_buf->recycled = 1;
        ctx->bufs++;

    } else {
        ctx->nomem = 1;
        return NGX_DECLINED;
    }

    ctx->zstream.next_out = ctx->out_buf->pos;
    ctx->zstream.avail_out = conf->bufs.size;

    return NGX_OK;
}",373.0,411.0,1.0,1.0,39.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
570,328965,ngx_http_v2_get_node_by_id,1,ngx_http_v2_get_node_by_id,"ngx_http_v2_node_t* ngx_http_v2_get_node_by_id (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)",http\v2\ngx_http_v2.c,"static ngx_http_v2_node_t *
ngx_http_v2_get_node_by_id(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    ngx_uint_t alloc)
{
    ngx_uint_t               index;
    ngx_http_v2_node_t      *node;
    ngx_http_v2_srv_conf_t  *h2scf;

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);

    index = ngx_http_v2_index(h2scf, sid);

    for (node = h2c->streams_index[index]; node; node = node->index) {

        if (node->id == sid) {
            return node;
        }
    }

    if (!alloc) {
        return NULL;
    }

    if (h2c->closed_nodes < 32) {
        node = ngx_pcalloc(h2c->connection->pool, sizeof(ngx_http_v2_node_t));
        if (node == NULL) {
            return NULL;
        }

    } else {
        node = ngx_http_v2_get_closed_node(h2c);
    }

    node->id = sid;

    ngx_queue_init(&node->children);

    node->index = h2c->streams_index[index];
    h2c->streams_index[index] = node;

   ...",3108.0,3150.0,1.0,12.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_http_v2_node_t
571,455941,upstreams,3,ngx_stream_upstream_main_conf_t.upstreams,,stream\ngx_stream_upstream.h,upstreams,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
572,1287,ngx_exec_new_binary,1,ngx_exec_new_binary,"ngx_pid_t ngx_exec_new_binary (ngx_cycle_t*,char**)",core\nginx.c,"ngx_pid_t
ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)
{
    char             **env, *var;
    u_char            *p;
    ngx_uint_t         i, n;
    ngx_pid_t          pid;
    ngx_exec_ctx_t     ctx;
    ngx_core_conf_t   *ccf;
    ngx_listening_t   *ls;

    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));

    ctx.path = argv[0];
    ctx.name = ""new binary process"";
    ctx.argv = argv;

    n = 2;
    env = ngx_set_environment(cycle, &n);
    if (env == NULL) {
        return NGX_INVALID_PID;
    }

    var = ngx_alloc(sizeof(NGINX_VAR)
                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,
                    cycle->log);
    if (var == NULL) {
        ngx_free(env);
        return NGX_INVALID_PID;
    }

    p = ngx_cpymem(var, NGINX_VAR ""="", sizeof(NGINX_VAR));

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {
        p = ngx_sprintf(p, ""%ud;"", ls[i].fd);
    }

    *p = '\0';

    env[n++] = var;

#if (NGX_SETPROCTI...",640.0,738.0,1.0,1.0,99.0,59,13,61,18,1,13,7,8,4,4,,0,13,4,2,2,ngx_pid_t
573,144649,ngx_http_gunzip_filter_inflate,1,ngx_http_gunzip_filter_inflate,"ngx_int_t ngx_http_gunzip_filter_inflate (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)",http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_filter_inflate(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    int           rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""inflate in: ni:%p no:%p ai:%ud ao:%ud fl:%d redo:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
                   ctx->zstream.avail_in, ctx->zstream.avail_out,
                   ctx->flush, ctx->redo);

    rc = inflate(&ctx->zstream, ctx->flush);

    if (rc != Z_OK && rc != Z_STREAM_END && rc != Z_BUF_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""inflate() failed: %d, %d"", ctx->flush, rc);
        return NGX_ERROR;
    }

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""inflate out: ni:%p no:%p ai:%ud ao:%ud rc:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
                   ctx->zstream.avail_in, ctx->zstream...",414.0,563.0,1.0,1.0,150.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
574,169226,ngx_http_memcached_module,2,http\modules\ngx_http_memcached_module.c.ngx_http_memcached_module,,http\modules\ngx_http_memcached_module.c,ngx_module_t ngx_http_memcached_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
575,62731,ngx_dns_strcmp,1,ngx_dns_strcmp,"ngx_int_t ngx_dns_strcmp (u_char*,u_char*)",core\ngx_string.c,"ngx_int_t
ngx_dns_strcmp(u_char *s1, u_char *s2)
{
    ngx_uint_t  c1, c2;

    for ( ;; ) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                continue;
            }

            return 0;
        }

        /* in ASCII '.' > '-', but we need '.' to be the lowest character */

        c1 = (c1 == '.') ? ' ' : c1;
        c2 = (c2 == '.') ? ' ' : c2;

        return c1 - c2;
    }
}",846.0,874.0,1.0,1.0,29.0,26,10,27,5,4,0,5,7,0,0,,0,0,4,2,2,ngx_int_t
576,214284,ngx_http_secure_link_module,2,http\modules\ngx_http_secure_link_module.c.ngx_http_secure_link_module,,http\modules\ngx_http_secure_link_module.c,ngx_module_t ngx_http_secure_link_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
577,21772,ngx_sock_ntop,1,ngx_sock_ntop,"size_t ngx_sock_ntop (sockaddr*,socklen_t,u_char*,size_t,ngx_uint_t)",core\ngx_inet.c,"size_t
ngx_sock_ntop(struct sockaddr *sa, socklen_t socklen, u_char *text, size_t len,
    ngx_uint_t port)
{
    u_char               *p;
#if (NGX_HAVE_INET6 || NGX_HAVE_UNIX_DOMAIN)
    size_t                n;
#endif
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    struct sockaddr_un   *saun;
#endif

    switch (sa->sa_family) {

    case AF_INET:

        sin = (struct sockaddr_in *) sa;
        p = (u_char *) &sin->sin_addr;

        if (port) {
            p = ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud:%d"",
                             p[0], p[1], p[2], p[3], ntohs(sin->sin_port));
        } else {
            p = ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud"",
                             p[0], p[1], p[2], p[3]);
        }

        return (p - text);

#if (NGX_HAVE_INET6)

    case AF_INET6:

        sin6 = (struct sockaddr_in6 *) sa;

        n = 0;

        if (port) {
            text[n++] = '[';
        }

...",182.0,262.0,1.0,1.0,81.0,14,6,17,7,7,1,3,4,0,1,,0,1,10,5,5,size_t
578,398605,ngx_read_channel,1,ngx_read_channel,"ngx_int_t ngx_read_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)",os\unix\ngx_channel.c,"ngx_int_t
ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size, ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    union {
        struct cmsghdr  cm;
        char            space[CMSG_SPACE(sizeof(int))];
    } cmsg;
#else
    int                 fd;
#endif

    iov[0].iov_base = (char *) ch;
    iov[0].iov_len = size;

    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    msg.msg_control = (caddr_t) &cmsg;
    msg.msg_controllen = sizeof(cmsg);
#else
    msg.msg_accrights = (caddr_t) &fd;
    msg.msg_accrightslen = sizeof(int);
#endif

    n = recvmsg(s, &msg, 0);

    if (n == -1) {
        err = ngx_errno;
        if (err == NGX_EAGAIN) {
            return NGX_AGAIN;
        }

        ngx_log_error(NGX_LOG_ALERT, log, err, ""recvmsg() failed"");
        return NGX_E...",95.0,195.0,1.0,1.0,101.0,38,12,48,20,0,5,7,9,1,3,,0,2,8,4,4,ngx_int_t
579,328977,ngx_http_v2_send_settings,1,ngx_http_v2_send_settings,ngx_int_t ngx_http_v2_send_settings (ngx_http_v2_connection_t*),http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_send_settings(ngx_http_v2_connection_t *h2c)
{
    size_t                    len;
    ngx_buf_t                *buf;
    ngx_chain_t              *cl;
    ngx_http_v2_srv_conf_t   *h2scf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send SETTINGS frame"");

    frame = ngx_palloc(h2c->pool, sizeof(ngx_http_v2_out_frame_t));
    if (frame == NULL) {
        return NGX_ERROR;
    }

    cl = ngx_alloc_chain_link(h2c->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    len = NGX_HTTP_V2_SETTINGS_PARAM_SIZE * 3;

    buf = ngx_create_temp_buf(h2c->pool, NGX_HTTP_V2_FRAME_HEADER_SIZE + len);
    if (buf == NULL) {
        return NGX_ERROR;
    }

    buf->last_buf = 1;

    cl->buf = buf;
    cl->next = NULL;

    frame->first = cl;
    frame->last = cl;
    frame->handler = ngx_http_v2_settings_frame_handler;
    frame->stream = NULL;
#if (NGX_DEBUG)
    frame->le...",2691.0,2761.0,1.0,10.0,71.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
580,17682,ngx_copy_file,1,ngx_copy_file,"ngx_int_t ngx_copy_file (u_char*,u_char*,ngx_copy_file_t*)",core\ngx_file.c,"ngx_int_t
ngx_copy_file(u_char *from, u_char *to, ngx_copy_file_t *cf)
{
    char             *buf;
    off_t             size;
    time_t            time;
    size_t            len;
    ssize_t           n;
    ngx_fd_t          fd, nfd;
    ngx_int_t         rc;
    ngx_uint_t        access;
    ngx_file_info_t   fi;

    rc = NGX_ERROR;
    buf = NULL;
    nfd = NGX_INVALID_FILE;

    fd = ngx_open_file(from, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_CRIT, cf->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", from);
        goto failed;
    }

    if (cf->size != -1 && cf->access != 0 && cf->time != -1) {
        size = cf->size;
        access = cf->access;
        time = cf->time;

    } else {
        if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cf->log, ngx_errno,
                          ngx_fd_info_n "" \""%s\"" failed"", from);

            goto failed;
 ...",794.0,924.0,1.0,1.0,131.0,56,10,78,21,1,15,26,25,4,6,,0,15,6,3,3,ngx_int_t
581,304407,ngx_http_upstream_cleanup,1,ngx_http_upstream_cleanup,void ngx_http_upstream_cleanup (void*),http\ngx_http_upstream.c,"static void
ngx_http_upstream_cleanup(void *data)
{
    ngx_http_request_t *r = data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""cleanup http upstream request: \""%V\"""", &r->uri);

    ngx_http_upstream_finalize_request(r, r->upstream, NGX_DONE);
}",4310.0,4319.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
582,328988,ngx_http_v2_send_window_update,1,ngx_http_v2_send_window_update,"ngx_int_t ngx_http_v2_send_window_update (ngx_http_v2_connection_t*,ngx_uint_t,size_t)",http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_send_window_update(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    size_t window)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send WINDOW_UPDATE frame sid:%ui, window:%uz"",
                   sid, window);

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_WINDOW_UPDATE_SIZE,
                                  NGX_HTTP_V2_WINDOW_UPDATE_FRAME,
                                  NGX_HTTP_V2_NO_FLAG, sid);
    if (frame == NULL) {
        return NGX_ERROR;
    }

    buf = frame->first->buf;

    buf->last = ngx_http_v2_write_uint32(buf->last, window);

    ngx_http_v2_queue_blocked_frame(h2c, frame);

    return NGX_OK;
}",2782.0,2807.0,1.0,39.0,26.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
583,406812,ngx_single_process_cycle,1,ngx_single_process_cycle,void ngx_single_process_cycle (ngx_cycle_t*),os\win32\ngx_process_cycle.c,"void
ngx_single_process_cycle(ngx_cycle_t *cycle)
{
    ngx_tid_t  tid;

    ngx_console_init(cycle);

    if (ngx_create_signal_events(cycle) != NGX_OK) {
        exit(2);
    }

    if (ngx_create_thread(&tid, ngx_worker_thread, NULL, cycle->log) != 0) {
        /* fatal */
        exit(2);
    }

    /* STUB */
    WaitForSingleObject(ngx_stop_event, INFINITE);
}",984.0,1002.0,1.0,1.0,19.0,32,7,44,12,1,13,13,25,5,7,,0,8,2,1,1,void
584,455965,naddrs,3,ngx_stream_upstream_server_t.naddrs,,stream\ngx_stream_upstream.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
585,455964,addrs,3,ngx_stream_upstream_server_t.addrs,,stream\ngx_stream_upstream.h,*addrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
586,435488,start,3,ngx_stream_log_buf_t.start,,stream\ngx_stream_log_module.c,*start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
587,435489,pos,3,ngx_stream_log_buf_t.pos,,stream\ngx_stream_log_module.c,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
588,435490,last,3,ngx_stream_log_buf_t.last,,stream\ngx_stream_log_module.c,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
589,328995,ngx_http_v2_send_rst_stream,1,ngx_http_v2_send_rst_stream,"ngx_int_t ngx_http_v2_send_rst_stream (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)",http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_send_rst_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    ngx_uint_t status)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send RST_STREAM frame sid:%ui, status:%ui"",
                   sid, status);

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_RST_STREAM_SIZE,
                                  NGX_HTTP_V2_RST_STREAM_FRAME,
                                  NGX_HTTP_V2_NO_FLAG, sid);
    if (frame == NULL) {
        return NGX_ERROR;
    }

    buf = frame->first->buf;

    buf->last = ngx_http_v2_write_uint32(buf->last, status);

    ngx_http_v2_queue_blocked_frame(h2c, frame);

    return NGX_OK;
}",2810.0,2835.0,1.0,39.0,26.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
590,435491,event,3,ngx_stream_log_buf_t.event,,stream\ngx_stream_log_module.c,*event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
591,435492,flush,3,ngx_stream_log_buf_t.flush,,stream\ngx_stream_log_module.c,flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
592,169249,ngx_http_memcached_handler,1,ngx_http_memcached_handler,ngx_int_t ngx_http_memcached_handler (ngx_http_request_t*),http\modules\ngx_http_memcached_module.c,"static ngx_int_t
ngx_http_memcached_handler(ngx_http_request_t *r)
{
    ngx_int_t                       rc;
    ngx_http_upstream_t            *u;
    ngx_http_memcached_ctx_t       *ctx;
    ngx_http_memcached_loc_conf_t  *mlcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    if (ngx_http_set_content_type(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""memcached://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_memcached_module;

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_memcached_module);

    u->conf = &mlcf->upstream;

    u->create_request = ngx_http_memcached_create_request;
    u->reinit_request = ngx_http_memcached_reinit_request;
    u->proc...",175.0,234.0,1.0,1.0,60.0,46,11,56,22,0,11,6,6,2,5,,0,10,2,1,1,ngx_int_t
593,214311,ngx_http_secure_link_variable,1,ngx_http_secure_link_variable,"ngx_int_t ngx_http_secure_link_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_secure_link_module.c,"static ngx_int_t
ngx_http_secure_link_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                       *p, *last;
    ngx_str_t                     val, hash;
    time_t                        expires;
    ngx_md5_t                     md5;
    ngx_http_secure_link_ctx_t   *ctx;
    ngx_http_secure_link_conf_t  *conf;
    u_char                        hash_buf[18], md5_buf[16];

    conf = ngx_http_get_module_loc_conf(r, ngx_http_secure_link_module);

    if (conf->secret.data) {
        return ngx_http_secure_link_old_variable(r, conf, v, data);
    }

    if (conf->variable == NULL || conf->md5 == NULL) {
        goto not_found;
    }

    if (ngx_http_complex_value(r, conf->variable, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""secure link: \""%V\"""", &val);

    last = val.data + val.len;

    p = ngx_strlchr(val.data, last, ',');
    expires...",100.0,195.0,1.0,1.0,96.0,77,17,83,19,0,29,18,14,10,9,,0,25,6,3,3,ngx_int_t
594,15729,ngx_temp_number,2,core\ngx_file.c.ngx_temp_number,,core\ngx_file.c,ngx_atomic_t* ngx_temp_number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
595,410922,ngx_thread_cond_create,1,ngx_thread_cond_create,"ngx_int_t ngx_thread_cond_create (ngx_thread_cond_t*,ngx_log_t*)",os\unix\ngx_thread_cond.c,"ngx_int_t
ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_init(cond, NULL);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_init() failed"");
    return NGX_ERROR;
}",12.0,24.0,1.0,1.0,13.0,2,2,9,7,0,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
596,206130,ngx_http_cmp_referer_wildcards,1,ngx_http_cmp_referer_wildcards,"ANY ngx_http_cmp_referer_wildcards (void*,void*)",http\modules\ngx_http_referer_module.c,"ngx_http_cmp_referer_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",674.0,682.0,1.0,1.0,9.0,8,4,6,4,0,3,1,1,0,1,,0,2,4,2,2,ANY
597,435509,logs,3,ngx_stream_log_srv_conf_t.logs,,stream\ngx_stream_log_module.c,*logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
598,435513,off,3,ngx_stream_log_srv_conf_t.off,,stream\ngx_stream_log_module.c,off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
599,455995,host,3,ngx_stream_upstream_resolved_t.host,,stream\ngx_stream_upstream.h,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
600,455998,naddrs,3,ngx_stream_upstream_resolved_t.naddrs,,stream\ngx_stream_upstream.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
601,435520,ngx_stream_log_write,1,ngx_stream_log_write,"void ngx_stream_log_write (ngx_stream_session_t*,ngx_stream_log_t*,u_char*,size_t)",stream\ngx_stream_log_module.c,"static void
ngx_stream_log_write(ngx_stream_session_t *s, ngx_stream_log_t *log,
    u_char *buf, size_t len)
{
    u_char                *name;
    time_t                 now;
    ssize_t                n;
    ngx_err_t              err;
#if (NGX_ZLIB)
    ngx_stream_log_buf_t  *buffer;
#endif

    if (log->script == NULL) {
        name = log->file->name.data;

#if (NGX_ZLIB)
        buffer = log->file->data;

        if (buffer && buffer->gzip) {
            n = ngx_stream_log_gzip(log->file->fd, buf, len, buffer->gzip,
                                    s->connection->log);
        } else {
            n = ngx_write_fd(log->file->fd, buf, len);
        }
#else
        n = ngx_write_fd(log->file->fd, buf, len);
#endif

    } else {
        name = NULL;
        n = ngx_stream_log_script_write(s, log->script, &name, buf, len);
    }

    if (n == (ssize_t) len) {
        return;
    }

    now = ngx_time();

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_ENOSP...",353.0,416.0,1.0,1.0,64.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
602,456002,socklen,3,ngx_stream_upstream_resolved_t.socklen,,stream\ngx_stream_upstream.h,socklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
603,456003,name,3,ngx_stream_upstream_resolved_t.name,,stream\ngx_stream_upstream.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
604,410948,ngx_thread_cond_destroy,1,ngx_thread_cond_destroy,"ngx_int_t ngx_thread_cond_destroy (ngx_thread_cond_t*,ngx_log_t*)",os\unix\ngx_thread_cond.c,"ngx_int_t
ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_destroy(cond);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_destroy() failed"");
    return NGX_ERROR;
}",27.0,39.0,1.0,1.0,13.0,2,2,8,6,0,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
605,375574,ngx_mail_auth,1,ngx_mail_auth,"void ngx_mail_auth (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_handler.c,"void
ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    s->args.nelts = 0;

    if (s->buffer->pos == s->buffer->last) {
        s->buffer->pos = s->buffer->start;
        s->buffer->last = s->buffer->start;
    }

    s->state = 0;

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    s->login_attempt++;

    ngx_mail_auth_http_init(s);
}",769.0,788.0,1.0,1.0,20.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
606,66889,ngx_syslog_add_header,1,ngx_syslog_add_header,"u_char ngx_syslog_add_header (ngx_syslog_peer_t*,u_char*)",core\ngx_syslog.c,"u_char *
ngx_syslog_add_header(ngx_syslog_peer_t *peer, u_char *buf)
{
    ngx_uint_t  pri;

    pri = peer->facility * 8 + peer->severity;

    if (peer->nohostname) {
        return ngx_sprintf(buf, ""<%ui>%V %V: "", pri, &ngx_cached_syslog_time,
                           &peer->tag);
    }

    return ngx_sprintf(buf, ""<%ui>%V %V %V: "", pri, &ngx_cached_syslog_time,
                       &ngx_cycle->hostname, &peer->tag);
}",233.0,247.0,1.0,1.0,15.0,14,5,13,5,3,7,2,2,1,2,,0,5,4,2,2,u_char
607,329035,ngx_http_v2_parse_path,1,ngx_http_v2_parse_path,"ngx_int_t ngx_http_v2_parse_path (ngx_http_request_t*,ngx_str_t*)",http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_parse_path(ngx_http_request_t *r, ngx_str_t *value)
{
    if (r->unparsed_uri.len) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent duplicate :path header"");

        return NGX_DECLINED;
    }

    if (value->len == 0) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent empty :path header"");

        return NGX_DECLINED;
    }

    r->uri_start = value->data;
    r->uri_end = value->data + value->len;

    if (ngx_http_parse_uri(r) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid :path header: \""%V\"""", value);

        return NGX_DECLINED;
    }

    if (ngx_http_process_request_uri(r) != NGX_OK) {
        /*
         * request has been finalized already
         * in ngx_http_process_request_uri()
         */
        return NGX_ABORT;
    }

    return NGX_OK;
}",3335.0,3371.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
608,447821,ngx_stream_script_run,1,ngx_stream_script_run,"u_char ngx_stream_script_run (ngx_stream_session_t*,ngx_str_t*,void*,size_t,void*)",stream\ngx_stream_script.c,"u_char *
ngx_stream_script_run(ngx_stream_session_t *s, ngx_str_t *value,
    void *code_lengths, size_t len, void *code_values)
{
    ngx_uint_t                      i;
    ngx_stream_script_code_pt       code;
    ngx_stream_script_engine_t      e;
    ngx_stream_core_main_conf_t    *cmcf;
    ngx_stream_script_len_code_pt   lcode;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    for (i = 0; i < cmcf->variables.nelts; i++) {
        if (s->variables[i].no_cacheable) {
            s->variables[i].valid = 0;
            s->variables[i].not_found = 0;
        }
    }

    ngx_memzero(&e, sizeof(ngx_stream_script_engine_t));

    e.ip = code_lengths;
    e.session = s;
    e.flushed = 1;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_stream_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }


    value->len = len;
    value->data = ngx_pnalloc(s->connection->pool, len);
    if (value->data == NULL) {
        return NULL;
    }

    e.ip =...",452.0,498.0,1.0,1.0,47.0,56,11,41,13,0,16,6,7,4,1,,0,16,10,5,5,u_char
609,15738,ngx_get_full_name,1,ngx_get_full_name,"ngx_int_t ngx_get_full_name (ngx_pool_t*,ngx_str_t*,ngx_str_t*)",core\ngx_file.c,"ngx_int_t
ngx_get_full_name(ngx_pool_t *pool, ngx_str_t *prefix, ngx_str_t *name)
{
    size_t      len;
    u_char     *p, *n;
    ngx_int_t   rc;

    rc = ngx_test_full_name(name);

    if (rc == NGX_OK) {
        return rc;
    }

    len = prefix->len;

#if (NGX_WIN32)

    if (rc == 2) {
        len = rc;
    }

#endif

    n = ngx_pnalloc(pool, len + name->len + 1);
    if (n == NULL) {
        return NGX_ERROR;
    }

    p = ngx_cpymem(n, prefix->data, len);
    ngx_cpystrn(p, name->data, name->len + 1);

    name->len += len;
    name->data = n;

    return NGX_OK;
}",20.0,55.0,1.0,1.0,36.0,18,5,26,10,1,10,3,3,0,3,,0,9,6,3,3,ngx_int_t
610,255316,ngx_http_add_listen,1,ngx_http_add_listen,"ngx_int_t ngx_http_add_listen (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_listen_opt_t*)",http\ngx_http.c,"ngx_int_t
ngx_http_add_listen(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_listen_opt_t *lsopt)
{
    in_port_t                   p;
    ngx_uint_t                  i;
    struct sockaddr            *sa;
    ngx_http_conf_port_t       *port;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    if (cmcf->ports == NULL) {
        cmcf->ports = ngx_array_create(cf->temp_pool, 2,
                                       sizeof(ngx_http_conf_port_t));
        if (cmcf->ports == NULL) {
            return NGX_ERROR;
        }
    }

    sa = lsopt->sockaddr;
    p = ngx_inet_get_port(sa);

    port = cmcf->ports->elts;
    for (i = 0; i < cmcf->ports->nelts; i++) {

        if (p != port[i].port || sa->sa_family != port[i].family) {
            continue;
        }

        /* a port is already in the port list */

        return ngx_http_add_addresses(cf, cscf, &port[i], lsopt);
    }

    /* add a port to the p...",1140.0,1187.0,1.0,1.0,48.0,40,10,46,12,0,14,7,8,3,5,,0,12,6,3,3,ngx_int_t
611,206172,codes,3,ngx_http_rewrite_loc_conf_t.codes,,http\modules\ngx_http_rewrite_module.c,*codes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
612,206173,stack_size,3,ngx_http_rewrite_loc_conf_t.stack_size,,http\modules\ngx_http_rewrite_module.c,stack_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
613,206174,log,3,ngx_http_rewrite_loc_conf_t.log,,http\modules\ngx_http_rewrite_module.c,log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
614,427359,ngx_stream_geo_cidr_variable,1,ngx_stream_geo_cidr_variable,"ngx_int_t ngx_stream_geo_cidr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)",stream\ngx_stream_geo_module.c,"static ngx_int_t
ngx_stream_geo_cidr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_geo_ctx_t *ctx = (ngx_stream_geo_ctx_t *) data;

    in_addr_t                     inaddr;
    ngx_addr_t                    addr;
    struct sockaddr_in           *sin;
    ngx_stream_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                       *p;
    struct in6_addr              *inaddr6;
#endif

    if (ngx_stream_geo_addr(s, ctx, &addr) != NGX_OK) {
        vv = (ngx_stream_variable_value_t *)
                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);
        goto done;
    }

    switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;
        p = inaddr6->s6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
          ...",164.0,234.0,1.0,1.0,71.0,27,7,23,11,0,3,5,3,1,3,,0,3,6,3,3,ngx_int_t
615,410973,ngx_thread_cond_signal,1,ngx_thread_cond_signal,"ngx_int_t ngx_thread_cond_signal (ngx_thread_cond_t*,ngx_log_t*)",os\unix\ngx_thread_cond.c,"ngx_int_t
ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_signal(cond);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_signal() failed"");
    return NGX_ERROR;
}",42.0,54.0,1.0,1.0,13.0,2,2,8,6,1,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
616,206175,uninitialized_variable_warn,3,ngx_http_rewrite_loc_conf_t.uninitialized_variable_warn,,http\modules\ngx_http_rewrite_module.c,uninitialized_variable_warn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
617,21855,ngx_inet_ntop,1,ngx_inet_ntop,"size_t ngx_inet_ntop (int,void*,u_char*,size_t)",core\ngx_inet.c,"size_t
ngx_inet_ntop(int family, void *addr, u_char *text, size_t len)
{
    u_char  *p;

    switch (family) {

    case AF_INET:

        p = addr;

        return ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud"",
                            p[0], p[1], p[2], p[3])
               - text;

#if (NGX_HAVE_INET6)

    case AF_INET6:
        return ngx_inet6_ntop(addr, text, len);

#endif

    default:
        return 0;
    }
}",265.0,290.0,1.0,1.0,26.0,6,3,11,6,0,1,2,2,0,1,,0,0,8,4,4,size_t
618,329059,ngx_http_v2_parse_header,1,ngx_http_v2_parse_header,"ngx_int_t ngx_http_v2_parse_header (ngx_http_request_t*,ngx_http_v2_parse_header_t*,ngx_str_t*)",http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_parse_header(ngx_http_request_t *r,
    ngx_http_v2_parse_header_t *header, ngx_str_t *value)
{
    ngx_table_elt_t            *h;
    ngx_http_core_main_conf_t  *cmcf;

    h = ngx_list_push(&r->headers_in.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h->key.len = header->name.len;
    h->key.data = header->name.data;
    h->lowcase_key = header->name.data;

    if (header->hh == NULL) {
        header->hash = ngx_hash_key(header->name.data, header->name.len);

        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

        header->hh = ngx_hash_find(&cmcf->headers_in_hash, header->hash,
                                   h->lowcase_key, h->key.len);
        if (header->hh == NULL) {
            return NGX_ERROR;
        }
    }

    h->hash = header->hash;

    h->value.len = value->len;
    h->value.data = value->data;

    if (header->hh->handler(r, h, header->hh->offset) != NGX_OK) {
        /* header handler ha...",3522.0,3561.0,1.0,1.0,40.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
619,144740,ngx_http_gunzip_filter_module,2,http\modules\ngx_http_gunzip_filter_module.c.ngx_http_gunzip_filter_module,,http\modules\ngx_http_gunzip_filter_module.c,ngx_module_t ngx_http_gunzip_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
620,410998,ngx_thread_cond_wait,1,ngx_thread_cond_wait,"ngx_int_t ngx_thread_cond_wait (ngx_thread_cond_t*,ngx_thread_mutex_t*,ngx_log_t*)",os\unix\ngx_thread_cond.c,"ngx_int_t
ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,
    ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_wait(cond, mtx);

#if 0
    ngx_time_update();
#endif

    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_cond_wait() failed"");

    return NGX_ERROR;
}",57.0,76.0,1.0,1.0,20.0,2,2,9,7,0,1,2,2,0,1,,0,0,6,3,3,ngx_int_t
621,144759,ngx_http_gunzip_header_filter,1,ngx_http_gunzip_header_filter,ngx_int_t ngx_http_gunzip_header_filter (ngx_http_request_t*),http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_header_filter(ngx_http_request_t *r)
{
    ngx_http_gunzip_ctx_t   *ctx;
    ngx_http_gunzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gunzip_filter_module);

    /* TODO support multiple content-codings */
    /* TODO always gunzip - due to configuration or module request */
    /* TODO ignore content encoding? */

    if (!conf->enable
        || r->headers_out.content_encoding == NULL
        || r->headers_out.content_encoding->value.len != 4
        || ngx_strncasecmp(r->headers_out.content_encoding->value.data,
                           (u_char *) ""gzip"", 4) != 0)
    {
        return ngx_http_next_header_filter(r);
    }

    r->gzip_vary = 1;

    if (!r->gzip_tested) {
        if (ngx_http_gzip_ok(r) == NGX_OK) {
            return ngx_http_next_header_filter(r);
        }

    } else if (r->gzip_ok) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_gunzip_ctx_t))...",120.0,171.0,1.0,1.0,52.0,40,9,33,8,0,8,5,6,2,3,,0,7,2,1,1,ngx_int_t
622,66938,ngx_syslog_writer,1,ngx_syslog_writer,"void ngx_syslog_writer (ngx_log_t*,ngx_uint_t,u_char*,size_t)",core\ngx_syslog.c,"void
ngx_syslog_writer(ngx_log_t *log, ngx_uint_t level, u_char *buf,
    size_t len)
{
    u_char             *p, msg[NGX_SYSLOG_MAX_STR];
    ngx_uint_t          head_len;
    ngx_syslog_peer_t  *peer;

    peer = log->wdata;

    if (peer->busy) {
        return;
    }

    peer->busy = 1;
    peer->severity = level - 1;

    p = ngx_syslog_add_header(peer, msg);
    head_len = p - msg;

    len -= NGX_LINEFEED_SIZE;

    if (len > NGX_SYSLOG_MAX_STR - head_len) {
        len = NGX_SYSLOG_MAX_STR - head_len;
    }

    p = ngx_snprintf(p, len, ""%s"", buf);

    (void) ngx_syslog_send(peer, msg, p - msg);

    peer->busy = 0;
}",250.0,281.0,1.0,31.0,32.0,37,8,31,11,0,7,3,3,1,3,,0,6,8,4,4,void
623,320897,ngx_http_core_variables,2,http\ngx_http_variables.c.ngx_http_core_variables,,http\ngx_http_variables.c,static ngx_http_variable_t[] ngx_http_core_variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
624,329092,ngx_http_v2_process_request_body,1,ngx_http_v2_process_request_body,"ngx_int_t ngx_http_v2_process_request_body (ngx_http_request_t*,u_char*,size_t,ngx_uint_t)",http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,
    size_t size, ngx_uint_t last)
{
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_connection_t          *fc;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    fc = r->connection;
    rb = r->request_body;
    buf = rb->buf;

    if (size) {
        if (buf->sync) {
            buf->pos = buf->start = pos;
            buf->last = buf->end = pos + size;

            r->request_body_in_file_only = 1;

        } else {
            if (size > (size_t) (buf->end - buf->last)) {
                ngx_log_error(NGX_LOG_INFO, fc->log, 0,
                              ""client intended to send body data ""
                              ""larger than declared"");

                return NGX_HTTP_BAD_REQUEST;
            }

            buf->last = ngx_cpymem(buf->last, pos, size);
        }
    }

    if (last) {
        rb->rest = 0;

        if (fc->read-...",3938.0,4022.0,1.0,1.0,85.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
625,21894,ngx_ptocidr,1,ngx_ptocidr,"ngx_int_t ngx_ptocidr (ngx_str_t*,ngx_cidr_t*)",core\ngx_inet.c,"ngx_int_t
ngx_ptocidr(ngx_str_t *text, ngx_cidr_t *cidr)
{
    u_char      *addr, *mask, *last;
    size_t       len;
    ngx_int_t    shift;
#if (NGX_HAVE_INET6)
    ngx_int_t    rc;
    ngx_uint_t   s, i;
#endif

    addr = text->data;
    last = addr + text->len;

    mask = ngx_strlchr(addr, last, '/');
    len = (mask ? mask : last) - addr;

    cidr->u.in.addr = ngx_inet_addr(addr, len);

    if (cidr->u.in.addr != INADDR_NONE) {
        cidr->family = AF_INET;

        if (mask == NULL) {
            cidr->u.in.mask = 0xffffffff;
            return NGX_OK;
        }

#if (NGX_HAVE_INET6)
    } else if (ngx_inet6_addr(addr, len, cidr->u.in6.addr.s6_addr) == NGX_OK) {
        cidr->family = AF_INET6;

        if (mask == NULL) {
            ngx_memset(cidr->u.in6.mask.s6_addr, 0xff, 16);
            return NGX_OK;
        }

#endif
    } else {
        return NGX_ERROR;
    }

    mask++;

    shift = ngx_atoi(mask, last - mask);
    if (shift == NGX_ERROR) {
        return NGX...",374.0,471.0,1.0,1.0,98.0,53,12,45,13,0,6,8,12,1,2,,0,6,4,2,2,ngx_int_t
626,329100,ngx_http_v2_filter_request_body,1,ngx_http_v2_filter_request_body,ngx_int_t ngx_http_v2_filter_request_body (ngx_http_request_t*),http\v2\ngx_http_v2.c,"static ngx_int_t
ngx_http_v2_filter_request_body(ngx_http_request_t *r)
{
    ngx_buf_t                 *b, *buf;
    ngx_int_t                  rc;
    ngx_chain_t               *cl;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    rb = r->request_body;
    buf = rb->buf;

    if (buf->pos == buf->last && rb->rest) {
        cl = NULL;
        goto update;
    }

    cl = ngx_chain_get_free_buf(r->pool, &rb->free);
    if (cl == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    b = cl->buf;

    ngx_memzero(b, sizeof(ngx_buf_t));

    if (buf->pos != buf->last) {
        r->request_length += buf->last - buf->pos;
        rb->received += buf->last - buf->pos;

        if (r->headers_in.content_length_n != -1) {
            if (rb->received > r->headers_in.content_length_n) {
                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                              ""client intended to send body data ""
                              ""la...",4025.0,4113.0,1.0,1.0,89.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
627,300441,ngx_http_script_copy_len_code,1,ngx_http_script_copy_len_code,size_t ngx_http_script_copy_len_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"size_t
ngx_http_script_copy_len_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_copy_code_t  *code;

    code = (ngx_http_script_copy_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_copy_code_t);

    return code->len;
}",814.0,824.0,1.0,1.0,11.0,7,5,5,3,0,3,1,1,0,0,,0,3,2,1,1,size_t
628,419227,ngx_shm_remap,1,ngx_shm_remap,"ngx_int_t ngx_shm_remap (ngx_shm_t*,u_char*)",os\win32\ngx_shmem.c,"ngx_int_t
ngx_shm_remap(ngx_shm_t *shm, u_char *addr)
{
    if (UnmapViewOfFile(shm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%V\"" failed"",
                      shm->addr, &shm->name);
        return NGX_ERROR;
    }

    shm->addr = MapViewOfFileEx(shm->handle, FILE_MAP_WRITE, 0, 0, 0, addr);

    if (shm->addr != NULL) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                  ""MapViewOfFileEx(%uz, %p) of file mapping \""%V\"" failed"",
                  shm->size, addr, &shm->name);

    return NGX_ERROR;
}",123.0,144.0,1.0,1.0,22.0,15,5,21,8,0,12,3,3,2,2,,0,10,4,2,2,ngx_int_t
629,398754,ngx_add_channel_event,1,ngx_add_channel_event,"ngx_int_t ngx_add_channel_event (ngx_cycle_t*,ngx_fd_t,ngx_int_t,ngx_event_handler_pt)",os\unix\ngx_channel.c,"ngx_int_t
ngx_add_channel_event(ngx_cycle_t *cycle, ngx_fd_t fd, ngx_int_t event,
    ngx_event_handler_pt handler)
{
    ngx_event_t       *ev, *rev, *wev;
    ngx_connection_t  *c;

    c = ngx_get_connection(fd, cycle->log);

    if (c == NULL) {
        return NGX_ERROR;
    }

    c->pool = cycle->pool;

    rev = c->read;
    wev = c->write;

    rev->log = cycle->log;
    wev->log = cycle->log;

    rev->channel = 1;
    wev->channel = 1;

    ev = (event == NGX_READ_EVENT) ? rev : wev;

    ev->handler = handler;

    if (ngx_add_conn && (ngx_event_flags & NGX_USE_EPOLL_EVENT) == 0) {
        if (ngx_add_conn(c) == NGX_ERROR) {
            ngx_free_connection(c);
            return NGX_ERROR;
        }

    } else {
        if (ngx_add_event(ev, event, 0) == NGX_ERROR) {
            ngx_free_connection(c);
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",198.0,240.0,1.0,1.0,43.0,29,6,33,15,0,2,4,5,0,2,,0,1,8,4,4,ngx_int_t
630,464290,ngx_stream_get_flushed_variable,1,ngx_stream_get_flushed_variable,"ngx_stream_variable_value_t ngx_stream_get_flushed_variable (ngx_stream_session_t*,ngx_uint_t)",stream\ngx_stream_variables.c,"ngx_stream_variable_value_t *
ngx_stream_get_flushed_variable(ngx_stream_session_t *s, ngx_uint_t index)
{
    ngx_stream_variable_value_t  *v;

    v = &s->variables[index];

    if (v->valid || v->not_found) {
        if (!v->no_cacheable) {
            return v;
        }

        v->valid = 0;
        v->not_found = 0;
    }

    return ngx_stream_get_indexed_variable(s, index);
}",382.0,399.0,1.0,1.0,18.0,13,6,11,3,1,1,3,4,0,1,,0,0,4,2,2,ngx_stream_variable_value_t
631,62885,ngx_atoi,1,ngx_atoi,"ngx_int_t ngx_atoi (u_char*,size_t)",core\ngx_string.c,"ngx_int_t
ngx_atoi(u_char *line, size_t n)
{
    ngx_int_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",917.0,942.0,1.0,1.0,26.0,24,14,22,7,6,0,5,7,0,0,,0,0,4,2,2,ngx_int_t
632,30118,ngx_murmur_hash2,1,ngx_murmur_hash2,"uint32_t ngx_murmur_hash2 (u_char*,size_t)",core\ngx_murmurhash.c,"uint32_t
ngx_murmur_hash2(u_char *data, size_t len)
{
    uint32_t  h, k;

    h = 0 ^ len;

    while (len >= 4) {
        k  = data[0];
        k |= data[1] << 8;
        k |= data[2] << 16;
        k |= data[3] << 24;

        k *= 0x5bd1e995;
        k ^= k >> 24;
        k *= 0x5bd1e995;

        h *= 0x5bd1e995;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch (len) {
    case 3:
        h ^= data[2] << 16;
        /* fall through */
    case 2:
        h ^= data[1] << 8;
        /* fall through */
    case 1:
        h ^= data[0];
        h *= 0x5bd1e995;
    }

    h ^= h >> 13;
    h *= 0x5bd1e995;
    h ^= h >> 15;

    return h;
}",11.0,52.0,1.0,1.0,42.0,26,9,34,4,2,0,3,3,0,0,,0,0,4,2,2,uint32_t
633,300464,ngx_http_script_copy_code,1,ngx_http_script_copy_code,void ngx_http_script_copy_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_copy_code(ngx_http_script_engine_t *e)
{
    u_char                       *p;
    ngx_http_script_copy_code_t  *code;

    code = (ngx_http_script_copy_code_t *) e->ip;

    p = e->pos;

    if (!e->skip) {
        e->pos = ngx_copy(p, e->ip + sizeof(ngx_http_script_copy_code_t),
                          code->len);
    }

    e->ip += sizeof(ngx_http_script_copy_code_t)
          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script copy: \""%*s\"""", e->pos - p, p);
}",827.0,847.0,1.0,1.0,21.0,30,10,20,6,0,10,2,2,1,0,,0,10,2,1,1,void
634,411058,ngx_thread_mutex_create,1,ngx_thread_mutex_create,"ngx_int_t ngx_thread_mutex_create (ngx_thread_mutex_t*,ngx_log_t*)",os\unix\ngx_thread_mutex.c,"ngx_int_t
ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t            err;
    pthread_mutexattr_t  attr;

    err = pthread_mutexattr_init(&attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutexattr_init() failed"");
        return NGX_ERROR;
    }

    err = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutexattr_settype""
                      ""(PTHREAD_MUTEX_ERRORCHECK) failed"");
        return NGX_ERROR;
    }

    err = pthread_mutex_init(mtx, &attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutex_init() failed"");
        return NGX_ERROR;
    }

    err = pthread_mutexattr_destroy(&attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_ALERT, log, err,
                      ""pthread_mutexattr_destroy() failed"");
    }

    ...",77.0,112.0,1.0,1.0,36.0,12,3,30,9,0,4,5,5,0,4,,0,0,4,2,2,ngx_int_t
635,9659,ngx_close_listening_sockets,1,ngx_close_listening_sockets,void ngx_close_listening_sockets (ngx_cycle_t*),core\ngx_connection.c,"void
ngx_close_listening_sockets(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    if (ngx_event_flags & NGX_USE_IOCP_EVENT) {
        return;
    }

    ngx_accept_mutex_held = 0;
    ngx_use_accept_mutex = 0;

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        c = ls[i].connection;

        if (c) {
            if (c->read->active) {
                if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {

                    /*
                     * it seems that Linux-2.6.x OpenVZ sends events
                     * for closed shared listening sockets unless
                     * the events was explicitly deleted
                     */

                    ngx_del_event(c->read, NGX_READ_EVENT, 0);

                } else {
                    ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
                }
            }

            ngx_free_connection(c);

            c->fd = (ngx...",1020.0,1089.0,1.0,1.0,70.0,37,10,33,12,0,1,7,14,0,1,,0,0,2,1,1,void
636,329149,ngx_http_v2_set_dependency,1,ngx_http_v2_set_dependency,"void ngx_http_v2_set_dependency (ngx_http_v2_connection_t*,ngx_http_v2_node_t*,ngx_uint_t,ngx_uint_t)",http\v2\ngx_http_v2.c,"static void
ngx_http_v2_set_dependency(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_node_t *node, ngx_uint_t depend, ngx_uint_t exclusive)
{
    ngx_queue_t         *children, *q;
    ngx_http_v2_node_t  *parent, *child, *next;

    parent = depend ? ngx_http_v2_get_node_by_id(h2c, depend, 0) : NULL;

    if (parent == NULL) {
        parent = NGX_HTTP_V2_ROOT;

        if (depend != 0) {
            exclusive = 0;
        }

        node->rank = 1;
        node->rel_weight = (1.0 / 256) * node->weight;

        children = &h2c->dependencies;

    } else {
        if (node->parent != NULL) {

            for (next = parent->parent;
                 next != NGX_HTTP_V2_ROOT && next->rank >= node->rank;
                 next = next->parent)
            {
                if (next != node) {
                    continue;
                }

                ngx_queue_remove(&parent->queue);
                ngx_queue_insert_after(&node->queue, &parent->queue);

                parent->pa...",4670.0,4758.0,1.0,17.0,89.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
637,427454,ngx_stream_geo_range_variable,1,ngx_stream_geo_range_variable,"ngx_int_t ngx_stream_geo_range_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)",stream\ngx_stream_geo_module.c,"static ngx_int_t
ngx_stream_geo_range_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_geo_ctx_t *ctx = (ngx_stream_geo_ctx_t *) data;

    in_addr_t                inaddr;
    ngx_addr_t               addr;
    ngx_uint_t               n;
    struct sockaddr_in      *sin;
    ngx_stream_geo_range_t  *range;
#if (NGX_HAVE_INET6)
    u_char                  *p;
    struct in6_addr         *inaddr6;
#endif

    *v = *ctx->u.high.default_value;

    if (ngx_stream_geo_addr(s, ctx, &addr) == NGX_OK) {

        switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

            if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
                p = inaddr6->s6_addr;

                inaddr = p[12] << 24;
                inaddr += p[13] << 16;
                inaddr += p[14] << 8;
                inaddr += p[15];

            } else {
                ...",237.0,314.0,1.0,1.0,78.0,44,14,31,11,0,4,9,14,3,1,,0,4,6,3,3,ngx_int_t
638,464336,ngx_stream_get_variable,1,ngx_stream_get_variable,"ngx_stream_variable_value_t ngx_stream_get_variable (ngx_stream_session_t*,ngx_str_t*,ngx_uint_t)",stream\ngx_stream_variables.c,"ngx_stream_variable_value_t *
ngx_stream_get_variable(ngx_stream_session_t *s, ngx_str_t *name,
    ngx_uint_t key)
{
    size_t                        len;
    ngx_uint_t                    i, n;
    ngx_stream_variable_t        *v;
    ngx_stream_variable_value_t  *vv;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    v = ngx_hash_find(&cmcf->variables_hash, key, name->data, name->len);

    if (v) {
        if (v->flags & NGX_STREAM_VAR_INDEXED) {
            return ngx_stream_get_flushed_variable(s, v->index);
        }

        if (ngx_stream_variable_depth == 0) {
            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                          ""cycle while evaluating variable \""%V\"""", name);
            return NULL;
        }

        ngx_stream_variable_depth--;

        vv = ngx_palloc(s->connection->pool,
                        sizeof(ngx_stream_variable_value_t));

        if (vv && v->get_handler(s...",402.0,471.0,1.0,1.0,70.0,70,16,73,16,0,19,10,15,6,5,,0,17,6,3,3,ngx_stream_variable_value_t
639,329181,ngx_http_v2_parse_headers,2,http\v2\ngx_http_v2.c.ngx_http_v2_parse_headers,,http\v2\ngx_http_v2.c,static ngx_http_v2_parse_header_t[] ngx_http_v2_parse_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
640,431586,ngx_stream_geoip_addr,1,ngx_stream_geoip_addr,"u_long ngx_stream_geoip_addr (ngx_stream_session_t*,ngx_stream_geoip_conf_t*)",stream\ngx_stream_geoip_module.c,"static u_long
ngx_stream_geoip_addr(ngx_stream_session_t *s, ngx_stream_geoip_conf_t *gcf)
{
    ngx_addr_t           addr;
    struct sockaddr_in  *sin;

    addr.sockaddr = s->connection->sockaddr;
    addr.socklen = s->connection->socklen;
    /* addr.name = s->connection->addr_text; */

#if (NGX_HAVE_INET6)

    if (addr.sockaddr->sa_family == AF_INET6) {
        u_char           *p;
        in_addr_t         inaddr;
        struct in6_addr  *inaddr6;

        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

            return inaddr;
        }
    }

#endif

    if (addr.sockaddr->sa_family != AF_INET) {
        return INADDR_NONE;
    }

    sin = (struct sockaddr_in *) addr.sockaddr;
    return ntohl(sin->sin_addr.s_addr);
}",217.0,256.0,1.0,1.0,40.0,16,5,10,5,0,1,2,2,0,0,,0,1,4,2,2,u_long
641,38371,ngx_radix_alloc,1,ngx_radix_alloc,ngx_radix_node_t* ngx_radix_alloc (ngx_radix_tree_t*),core\ngx_radix_tree.c,"static ngx_radix_node_t *
ngx_radix_alloc(ngx_radix_tree_t *tree)
{
    ngx_radix_node_t  *p;

    if (tree->free) {
        p = tree->free;
        tree->free = tree->free->right;
        return p;
    }

    if (tree->size < sizeof(ngx_radix_node_t)) {
        tree->start = ngx_pmemalign(tree->pool, ngx_pagesize, ngx_pagesize);
        if (tree->start == NULL) {
            return NULL;
        }

        tree->size = ngx_pagesize;
    }

    p = (ngx_radix_node_t *) tree->start;
    tree->start += sizeof(ngx_radix_node_t);
    tree->size -= sizeof(ngx_radix_node_t);

    return p;
}",463.0,488.0,1.0,1.0,26.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,ngx_radix_node_t
642,38376,ngx_radix_tree_create,1,ngx_radix_tree_create,"ngx_radix_tree_t ngx_radix_tree_create (ngx_pool_t*,ngx_int_t)",core\ngx_radix_tree.c,"ngx_radix_tree_t *
ngx_radix_tree_create(ngx_pool_t *pool, ngx_int_t preallocate)
{
    uint32_t           key, mask, inc;
    ngx_radix_tree_t  *tree;

    tree = ngx_palloc(pool, sizeof(ngx_radix_tree_t));
    if (tree == NULL) {
        return NULL;
    }

    tree->pool = pool;
    tree->free = NULL;
    tree->start = NULL;
    tree->size = 0;

    tree->root = ngx_radix_alloc(tree);
    if (tree->root == NULL) {
        return NULL;
    }

    tree->root->right = NULL;
    tree->root->left = NULL;
    tree->root->parent = NULL;
    tree->root->value = NGX_RADIX_NO_VALUE;

    if (preallocate == 0) {
        return tree;
    }

    /*
     * Preallocation of first nodes : 0, 1, 00, 01, 10, 11, 000, 001, etc.
     * increases TLB hits even if for first lookup iterations.
     * On 32-bit platforms the 7 preallocated bits takes continuous 4K,
     * 8 - 8K, 9 - 16K, etc.  On 64-bit platforms the 6 preallocated bits
     * takes continuous 4K, 7 - 8K, 8 - 16K, etc.  There is no sen...",15.0,105.0,1.0,1.0,91.0,41,9,51,12,0,13,11,13,2,3,,0,13,4,2,2,ngx_radix_tree_t
643,83433,ngx_acceptex_log_error,1,ngx_acceptex_log_error,"u_char ngx_acceptex_log_error (ngx_log_t*,u_char*,size_t)",event\ngx_event_acceptex.c,"u_char *
ngx_acceptex_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    return ngx_snprintf(buf, len, "" while posting AcceptEx() on %V"", log->data);
}",223.0,227.0,1.0,1.0,5.0,1,1,3,3,0,1,1,1,0,1,,0,0,6,3,3,u_char
644,251370,ngx_http_perl_sleep_handler,1,ngx_http_perl_sleep_handler,void ngx_http_perl_sleep_handler (ngx_http_request_t*),http\modules\perl\ngx_http_perl_module.c,"void
ngx_http_perl_sleep_handler(ngx_http_request_t *r)
{
    ngx_event_t  *wev;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""perl sleep handler"");

    wev = r->connection->write;

    if (wev->delayed) {

        if (ngx_handle_write_event(wev, 0) != NGX_OK) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        }

        return;
    }

    ngx_http_perl_handle_request(r);
}",288.0,308.0,1.0,1.0,21.0,7,3,10,5,0,3,3,4,1,3,,0,1,2,1,1,void
645,79338,ngx_timer_resolution,2,event\ngx_event.c.ngx_timer_resolution,,event\ngx_event.c,ngx_uint_t ngx_timer_resolution,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
646,67052,ngx_syslog_send,1,ngx_syslog_send,"ssize_t ngx_syslog_send (ngx_syslog_peer_t*,u_char*,size_t)",core\ngx_syslog.c,"ssize_t
ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)
{
    ssize_t  n;

    if (peer->conn.fd == (ngx_socket_t) -1) {
        if (ngx_syslog_init_peer(peer) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    /* log syslog socket events with valid log */
    peer->conn.log = ngx_cycle->log;

    if (ngx_send) {
        n = ngx_send(&peer->conn, buf, len);

    } else {
        /* event module has not yet set ngx_io */
        n = ngx_os_io.send(&peer->conn, buf, len);
    }

    if (n == NGX_ERROR) {

        if (ngx_close_socket(peer->conn.fd) == -1) {
            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                          ngx_close_socket_n "" failed"");
        }

        peer->conn.fd = (ngx_socket_t) -1;
    }

    return n;
}",284.0,317.0,1.0,1.0,34.0,21,8,18,9,3,6,6,8,3,1,,0,6,6,3,3,ssize_t
647,79339,ngx_event_timer_alarm,2,event\ngx_event.c.ngx_event_timer_alarm,,event\ngx_event.c,sig_atomic_t ngx_event_timer_alarm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
648,79341,ngx_event_flags,2,event\ngx_event.c.ngx_event_flags,,event\ngx_event.c,ngx_uint_t ngx_event_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
649,447985,ngx_stream_script_flush_no_cacheable_variables,1,ngx_stream_script_flush_no_cacheable_variables,"void ngx_stream_script_flush_no_cacheable_variables (ngx_stream_session_t*,ngx_array_t*)",stream\ngx_stream_script.c,"void
ngx_stream_script_flush_no_cacheable_variables(ngx_stream_session_t *s,
    ngx_array_t *indices)
{
    ngx_uint_t  n, *index;

    if (indices) {
        index = indices->elts;
        for (n = 0; n < indices->nelts; n++) {
            if (s->variables[index[n]].no_cacheable) {
                s->variables[index[n]].valid = 0;
                s->variables[index[n]].not_found = 0;
            }
        }
    }
}",501.0,516.0,1.0,1.0,16.0,19,5,15,4,1,2,4,7,1,0,,0,2,4,2,2,void
650,435703,ngx_stream_log_module,2,stream\ngx_stream_log_module.c.ngx_stream_log_module,,stream\ngx_stream_log_module.c,ngx_module_t ngx_stream_log_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
651,91641,ngx_ssl_get_protocol,1,ngx_ssl_get_protocol,"ngx_int_t ngx_ssl_get_protocol (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->data = (u_char *) SSL_get_version(c->ssl->connection);
    return NGX_OK;
}",4266.0,4271.0,1.0,1.0,6.0,5,3,3,3,0,1,1,1,0,0,,0,1,6,3,3,ngx_int_t
652,79353,ngx_accept_mutex,2,event\ngx_event.c.ngx_accept_mutex,,event\ngx_event.c,ngx_shmtx_t ngx_accept_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
653,79354,ngx_use_accept_mutex,2,event\ngx_event.c.ngx_use_accept_mutex,,event\ngx_event.c,ngx_uint_t ngx_use_accept_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
654,79356,ngx_accept_mutex_held,2,event\ngx_event.c.ngx_accept_mutex_held,,event\ngx_event.c,ngx_uint_t ngx_accept_mutex_held,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
655,23913,last,3,ngx_list_t.last,,core\ngx_list.h,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
656,79358,ngx_accept_disabled,2,event\ngx_event.c.ngx_accept_disabled,,event\ngx_event.c,ngx_int_t ngx_accept_disabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
657,23914,part,3,ngx_list_t.part,,core\ngx_list.h,part,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
658,411136,ngx_thread_mutex_destroy,1,ngx_thread_mutex_destroy,"ngx_int_t ngx_thread_mutex_destroy (ngx_thread_mutex_t*,ngx_log_t*)",os\unix\ngx_thread_mutex.c,"ngx_int_t
ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_destroy(mtx);
    if (err != 0) {
        ngx_log_error(NGX_LOG_ALERT, log, err,
                      ""pthread_mutex_destroy() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",115.0,128.0,1.0,1.0,14.0,2,2,8,6,0,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
659,83461,ngx_event_connect_peer,1,ngx_event_connect_peer,ngx_int_t ngx_event_connect_peer (ngx_peer_connection_t*),event\ngx_event_connect.c,"ngx_int_t
ngx_event_connect_peer(ngx_peer_connection_t *pc)
{
    int                rc, type, value;
#if (NGX_HAVE_IP_BIND_ADDRESS_NO_PORT || NGX_LINUX)
    in_port_t          port;
#endif
    ngx_int_t          event;
    ngx_err_t          err;
    ngx_uint_t         level;
    ngx_socket_t       s;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    rc = pc->get(pc, pc->data);
    if (rc != NGX_OK) {
        return rc;
    }

    type = (pc->type ? pc->type : SOCK_STREAM);

    s = ngx_socket(pc->sockaddr->sa_family, type, 0);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, pc->log, 0, ""%s socket %d"",
                   (type == SOCK_STREAM) ? ""stream"" : ""dgram"", s);

    if (s == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, pc->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }


    c = ngx_get_connection(s, pc->log);

    if (c == NULL) {
        if (ngx_close_socket(s) == -1) {
            ngx_log_error(NG...",20.0,327.0,1.0,1.0,308.0,138,12,168,49,0,10,34,39,2,10,,0,4,2,1,1,ngx_int_t
660,329222,ngx_http_v2_init,1,ngx_http_v2_init,void ngx_http_v2_init (ngx_event_t*),http\v2\ngx_http_v2.c,"void
ngx_http_v2_init(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_pool_cleanup_t        *cln;
    ngx_http_connection_t     *hc;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_v2_main_conf_t   *h2mcf;
    ngx_http_v2_connection_t  *h2c;

    c = rev->data;
    hc = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""init http2 connection"");

    c->log->action = ""processing HTTP/2 connection"";

    h2mcf = ngx_http_get_module_main_conf(hc->conf_ctx, ngx_http_v2_module);

    if (h2mcf->recv_buffer == NULL) {
        h2mcf->recv_buffer = ngx_palloc(ngx_cycle->pool,
                                        h2mcf->recv_buffer_size);
        if (h2mcf->recv_buffer == NULL) {
            ngx_http_close_connection(c);
            return;
        }
    }

    h2c = ngx_pcalloc(c->pool, sizeof(ngx_http_v2_connection_t));
    if (h2c == NULL) {
        ngx_http_close_connection(c);
        return;
    }

    h2c->connection = c;
    h2c->http_connection = hc;

 ...",230.0,329.0,1.0,46.0,100.0,88,10,87,20,0,26,9,10,4,15,,0,18,2,1,1,void
661,144901,ngx_http_gunzip_body_filter,1,ngx_http_gunzip_body_filter,"ngx_int_t ngx_http_gunzip_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_gunzip_filter_module.c,"static ngx_int_t
ngx_http_gunzip_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                     rc;
    ngx_uint_t              flush;
    ngx_chain_t            *cl;
    ngx_http_gunzip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_gunzip_filter_module);

    if (ctx == NULL || ctx->done) {
        return ngx_http_next_body_filter(r, in);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http gunzip filter"");

    if (!ctx->started) {
        if (ngx_http_gunzip_filter_inflate_start(r, ctx) != NGX_OK) {
            goto failed;
        }
    }

    if (in) {
        if (ngx_chain_add_copy(r->pool, &ctx->in, in) != NGX_OK) {
            goto failed;
        }
    }

    if (ctx->nomem) {

        /* flush busy buffers */

        if (ngx_http_next_body_filter(r, NULL) == NGX_ERROR) {
            goto failed;
        }

        cl = NULL;

        ngx_chain_update_chains(r->pool, &ctx->free, &ctx->busy, &cl,
    ...",174.0,298.0,1.0,1.0,125.0,65,10,82,14,0,29,29,38,8,7,,0,27,4,2,2,ngx_int_t
662,435720,ngx_stream_log_handler,1,ngx_stream_log_handler,ngx_int_t ngx_stream_log_handler (ngx_stream_session_t*),stream\ngx_stream_log_module.c,"static ngx_int_t
ngx_stream_log_handler(ngx_stream_session_t *s)
{
    u_char                     *line, *p;
    size_t                      len, size;
    ssize_t                     n;
    ngx_str_t                   val;
    ngx_uint_t                  i, l;
    ngx_stream_log_t           *log;
    ngx_stream_log_op_t        *op;
    ngx_stream_log_buf_t       *buffer;
    ngx_stream_log_srv_conf_t  *lscf;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream log handler"");

    lscf = ngx_stream_get_module_srv_conf(s, ngx_stream_log_module);

    if (lscf->off || lscf->logs == NULL) {
        return NGX_OK;
    }

    log = lscf->logs->elts;
    for (l = 0; l < lscf->logs->nelts; l++) {

        if (log[l].filter) {
            if (ngx_stream_complex_value(s, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }

            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
    ...",200.0,350.0,1.0,1.0,151.0,155,17,145,21,0,34,26,50,15,8,,0,30,2,1,1,ngx_int_t
663,23917,pool,3,ngx_list_t.pool,,core\ngx_list.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
664,91662,ngx_ssl_get_cipher_name,1,ngx_ssl_get_cipher_name,"ngx_int_t ngx_ssl_get_cipher_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->data = (u_char *) SSL_get_cipher_name(c->ssl->connection);
    return NGX_OK;
}",4274.0,4279.0,1.0,1.0,6.0,5,3,3,3,0,1,1,1,0,0,,0,1,6,3,3,ngx_int_t
665,251410,ngx_http_perl_variable,1,ngx_http_perl_variable,"ngx_int_t ngx_http_perl_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\perl\ngx_http_perl_module.c,"static ngx_int_t
ngx_http_perl_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_perl_variable_t *pv = (ngx_http_perl_variable_t *) data;

    ngx_int_t                   rc;
    ngx_str_t                   value;
    ngx_uint_t                  saved;
    ngx_http_perl_ctx_t        *ctx;
    ngx_http_perl_main_conf_t  *pmcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""perl variable handler"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_perl_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_perl_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_perl_module);

        ctx->request = r;
    }

    saved = ctx->variable;
    ctx->variable = 1;

    pmcf = ngx_http_get_module_main_conf(r, ngx_http_perl_module);

    value.data = NULL;

    {

    dTHXa(pmcf->perl);
    PERL_SET_CONTEXT(pmcf->perl);...",311.0,376.0,1.0,1.0,66.0,45,6,47,14,0,17,4,5,1,1,,0,17,6,3,3,ngx_int_t
666,316947,ngx_http_upstream_param_set_slot,1,ngx_http_upstream_param_set_slot,"char* ngx_http_upstream_param_set_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http_upstream.c,"char *
ngx_http_upstream_param_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_str_t                   *value;
    ngx_array_t                **a;
    ngx_http_upstream_param_t   *param;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NULL) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_http_upstream_param_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    param = ngx_array_push(*a);
    if (param == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    param->key = value[1];
    param->value = value[2];
    param->skip_empty = 0;

    if (cf->args->nelts == 4) {
        if (ngx_strcmp(value[3].data, ""if_not_empty"") != 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[3]);
            return NGX_CONF_ERROR;
        }

        param->skip_empty = 1;
    }

    return NGX_CONF_OK;
}",6256.0,6297.0,1.0,1.0,42.0,37,11,33,12,0,7,6,8,0,3,,0,6,6,3,3,char*
667,398869,ngx_close_channel,1,ngx_close_channel,"void ngx_close_channel (ngx_fd_t*,ngx_log_t*)",os\unix\ngx_channel.c,"void
ngx_close_channel(ngx_fd_t *fd, ngx_log_t *log)
{
    if (close(fd[0]) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, ""close() channel failed"");
    }

    if (close(fd[1]) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, ""close() channel failed"");
    }
}",243.0,253.0,1.0,1.0,11.0,6,3,8,4,7,2,3,3,0,2,,0,0,4,2,2,void
668,411161,ngx_thread_mutex_lock,1,ngx_thread_mutex_lock,"ngx_int_t ngx_thread_mutex_lock (ngx_thread_mutex_t*,ngx_log_t*)",os\unix\ngx_thread_mutex.c,"ngx_int_t
ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_lock(mtx);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_mutex_lock() failed"");

    return NGX_ERROR;
}",131.0,144.0,1.0,1.0,14.0,2,2,8,6,1,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
669,419355,handle,3,ngx_shm_t.handle,,os\win32\ngx_shmem.h,handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
670,91683,ngx_ssl_get_ciphers,1,ngx_ssl_get_ciphers,"ngx_int_t ngx_ssl_get_ciphers (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_GET_RAW_CIPHERLIST

    int                n, i, bytes;
    size_t             len;
    u_char            *ciphers, *p;
    const SSL_CIPHER  *cipher;

    bytes = SSL_get0_raw_cipherlist(c->ssl->connection, NULL);
    n = SSL_get0_raw_cipherlist(c->ssl->connection, &ciphers);

    if (n <= 0) {
        s->len = 0;
        return NGX_OK;
    }

    len = 0;
    n /= bytes;

    for (i = 0; i < n; i++) {
        cipher = SSL_CIPHER_find(c->ssl->connection, ciphers + i * bytes);

        if (cipher) {
            len += ngx_strlen(SSL_CIPHER_get_name(cipher));

        } else {
            len += sizeof(""0x"") - 1 + bytes * (sizeof(""00"") - 1);
        }

        len += sizeof("":"") - 1;
    }

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < n; i++) {
        cipher = SSL_CIPHER_find(c->ssl->connection...",4282.0,4363.0,1.0,1.0,82.0,15,4,17,7,0,8,3,3,1,1,,0,8,6,3,3,ngx_int_t
671,206384,ngx_http_rewrite_module,2,http\modules\ngx_http_rewrite_module.c.ngx_http_rewrite_module,,http\modules\ngx_http_rewrite_module.c,ngx_module_t ngx_http_rewrite_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
672,411186,ngx_thread_mutex_unlock,1,ngx_thread_mutex_unlock,"ngx_int_t ngx_thread_mutex_unlock (ngx_thread_mutex_t*,ngx_log_t*)",os\unix\ngx_thread_mutex.c,"ngx_int_t
ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_unlock(mtx);

#if 0
    ngx_time_update();
#endif

    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_mutex_unlock() failed"");

    return NGX_ERROR;
}",147.0,165.0,1.0,1.0,19.0,2,2,8,6,3,1,2,2,0,1,,0,0,4,2,2,ngx_int_t
673,17972,ngx_walk_tree,1,ngx_walk_tree,"ngx_int_t ngx_walk_tree (ngx_tree_ctx_t*,ngx_str_t*)",core\ngx_file.c,"ngx_int_t
ngx_walk_tree(ngx_tree_ctx_t *ctx, ngx_str_t *tree)
{
    void       *data, *prev;
    u_char     *p, *name;
    size_t      len;
    ngx_int_t   rc;
    ngx_err_t   err;
    ngx_str_t   file, buf;
    ngx_dir_t   dir;

    ngx_str_null(&buf);

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,
                   ""walk tree \""%V\"""", tree);

    if (ngx_open_dir(tree, &dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,
                      ngx_open_dir_n "" \""%s\"" failed"", tree->data);
        return NGX_ERROR;
    }

    prev = ctx->data;

    if (ctx->alloc) {
        data = ngx_alloc(ctx->alloc, ctx->log);
        if (data == NULL) {
            goto failed;
        }

        if (ctx->init_handler(data, prev) == NGX_ABORT) {
            goto failed;
        }

        ctx->data = data;

    } else {
        data = NULL;
    }

    for ( ;; ) {

        ngx_set_errno(0);

        if (ngx_read_dir(&dir) == NGX_ERROR) {
            err = ngx_err...",945.0,1128.0,1.0,1.0,184.0,101,12,102,20,1,28,28,38,11,6,,0,28,4,2,2,ngx_int_t
674,419385,ngx_nonblocking,1,ngx_nonblocking,int ngx_nonblocking (ngx_socket_t),os\win32\ngx_socket.c,"int
ngx_nonblocking(ngx_socket_t s)
{
    unsigned long  nb = 1;

    return ioctlsocket(s, FIONBIO, &nb);
}",12.0,18.0,1.0,1.0,7.0,2,2,4,3,4,0,1,1,0,0,,0,0,2,1,1,int
675,415289,dir,3,ngx_dir_t.dir,,os\win32\ngx_files.h,dir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
676,415291,valid_info,3,ngx_dir_t.valid_info,,os\win32\ngx_files.h,valid_info:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
677,415292,type,3,ngx_dir_t.type,,os\win32\ngx_files.h,type:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
678,302352,flushes,3,ngx_http_script_compile_t.flushes,,http\ngx_http_script.h,**flushes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
679,87614,ngx_ssl_recv_chain,1,ngx_ssl_recv_chain,"ssize_t ngx_ssl_recv_chain (ngx_connection_t*,ngx_chain_t*,off_t)",event\ngx_event_openssl.c,"ssize_t
ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl, off_t limit)
{
    u_char     *last;
    ssize_t     n, bytes, size;
    ngx_buf_t  *b;

    bytes = 0;

    b = cl->buf;
    last = b->last;

    for ( ;; ) {
        size = b->end - last;

        if (limit) {
            if (bytes >= limit) {
                return bytes;
            }

            if (bytes + size > limit) {
                size = (ssize_t) (limit - bytes);
            }
        }

        n = ngx_ssl_recv(c, last, size);

        if (n > 0) {
            last += n;
            bytes += n;

            if (!c->read->ready) {
                return bytes;
            }

            if (last == b->end) {
                cl = cl->next;

                if (cl == NULL) {
                    return bytes;
                }

                b = cl->buf;
                last = b->last;
            }

            continue;
        }

        if (bytes) {

            if (n == 0 || n == NGX_ERROR) {
       ...",1933.0,1993.0,1.0,1.0,61.0,35,10,47,10,0,1,12,27,0,1,,0,1,6,3,3,ssize_t
680,9792,ngx_get_connection,1,ngx_get_connection,"ngx_connection_t ngx_get_connection (ngx_socket_t,ngx_log_t*)",core\ngx_connection.c,"ngx_connection_t *
ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
{
    ngx_uint_t         instance;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */

    if (ngx_cycle->files && (ngx_uint_t) s >= ngx_cycle->files_n) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ""the new socket has number %d, ""
                      ""but only %ui files are available"",
                      s, ngx_cycle->files_n);
        return NULL;
    }

    c = ngx_cycle->free_connections;

    if (c == NULL) {
        ngx_drain_connections((ngx_cycle_t *) ngx_cycle);
        c = ngx_cycle->free_connections;
    }

    if (c == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ""%ui worker_connections are not enough"",
                      ngx_cycle->connection_n);

        return NULL;
    }

    ngx_cycle->free_connections = c->data;
    ngx_cycle->free_connection_n--;

    i...",1092.0,1158.0,1.0,1.0,67.0,60,10,65,12,3,3,5,5,0,3,,0,0,4,2,2,ngx_connection_t
681,206401,ngx_http_rewrite_handler,1,ngx_http_rewrite_handler,ngx_int_t ngx_http_rewrite_handler (ngx_http_request_t*),http\modules\ngx_http_rewrite_module.c,"static ngx_int_t
ngx_http_rewrite_handler(ngx_http_request_t *r)
{
    ngx_int_t                     index;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t     *e;
    ngx_http_core_srv_conf_t     *cscf;
    ngx_http_core_main_conf_t    *cmcf;
    ngx_http_rewrite_loc_conf_t  *rlcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    index = cmcf->phase_engine.location_rewrite_index;

    if (r->phase_handler == index && r->loc_conf == cscf->ctx->loc_conf) {
        /* skipping location rewrite phase for server null location */
        return NGX_DECLINED;
    }

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);

    if (rlcf->codes == NULL) {
        return NGX_DECLINED;
    }

    e = ngx_pcalloc(r->pool, sizeof(ngx_http_script_engine_t));
    if (e == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    e->sp = ngx_pcalloc(r->pool,
           ...",136.0,184.0,1.0,1.0,49.0,48,9,46,14,0,19,6,6,4,2,,0,19,2,1,1,ngx_int_t
682,30272,ngx_file_info_wrapper,1,ngx_file_info_wrapper,"ngx_int_t ngx_file_info_wrapper (ngx_str_t*,ngx_open_file_info_t*,ngx_file_info_t*,ngx_log_t*)",core\ngx_open_file_cache.c,"static ngx_int_t
ngx_file_info_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,
    ngx_file_info_t *fi, ngx_log_t *log)
{
    ngx_int_t  rc;

#if !(NGX_HAVE_OPENAT)

    rc = ngx_file_info(name->data, fi);

    if (rc == NGX_FILE_ERROR) {
        of->err = ngx_errno;
        of->failed = ngx_file_info_n;
        return NGX_FILE_ERROR;
    }

    return rc;

#else

    ngx_fd_t  fd;

    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {

        rc = ngx_file_info(name->data, fi);

        if (rc == NGX_FILE_ERROR) {
            of->err = ngx_errno;
            of->failed = ngx_file_info_n;
            return NGX_FILE_ERROR;
        }

        return rc;
    }

    fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,
                               NGX_FILE_OPEN, 0, log);

    if (fd == NGX_INVALID_FILE) {
        return NGX_FILE_ERROR;
    }

    rc = ngx_fd_info(fd, fi);

    if (rc == NGX_FILE_ERROR) {
        of->err = ngx_errno;
        of->failed = ng...",780.0,836.0,1.0,1.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
683,22080,ngx_cidr_match,1,ngx_cidr_match,"ngx_int_t ngx_cidr_match (sockaddr*,ngx_array_t*)",core\ngx_inet.c,"ngx_int_t
ngx_cidr_match(struct sockaddr *sa, ngx_array_t *cidrs)
{
#if (NGX_HAVE_INET6)
    u_char           *p;
#endif
    in_addr_t         inaddr;
    ngx_cidr_t       *cidr;
    ngx_uint_t        family, i;
#if (NGX_HAVE_INET6)
    ngx_uint_t        n;
    struct in6_addr  *inaddr6;
#endif

#if (NGX_SUPPRESS_WARN)
    inaddr = 0;
#if (NGX_HAVE_INET6)
    inaddr6 = NULL;
#endif
#endif

    family = sa->sa_family;

    if (family == AF_INET) {
        inaddr = ((struct sockaddr_in *) sa)->sin_addr.s_addr;
    }

#if (NGX_HAVE_INET6)
    else if (family == AF_INET6) {
        inaddr6 = &((struct sockaddr_in6 *) sa)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            family = AF_INET;

            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

            inaddr = htonl(inaddr);
        }
    }
#endif

    for (cidr = cidrs->elts, i = 0; i < cidrs->nelts; i...",474.0,558.0,1.0,1.0,85.0,26,10,22,9,0,2,10,10,1,0,,0,2,4,2,2,ngx_int_t
684,398915,command,3,ngx_channel_t.command,,os\unix\ngx_channel.h,command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
685,23928,ngx_list_init,1,ngx_list_init,"ANY ngx_list_init (ngx_list_t*,ngx_pool_t*,ngx_uint_t,size_t)",core\ngx_list.h,"ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    list->part.elts = ngx_palloc(pool, n * size);
    if (list->part.elts == NULL) {
        return NGX_ERROR;
    }

    list->part.nelts = 0;
    list->part.next = NULL;
    list->last = &list->part;
    list->size = size;
    list->nalloc = n;
    list->pool = pool;

    return NGX_OK;
}",37.0,52.0,1.0,1.0,16.0,23,6,19,7,5,10,2,2,1,1,,0,10,8,4,4,ANY
686,398918,fd,3,ngx_channel_t.fd,,os\unix\ngx_channel.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
687,419400,ngx_blocking,1,ngx_blocking,int ngx_blocking (ngx_socket_t),os\win32\ngx_socket.c,"int
ngx_blocking(ngx_socket_t s)
{
    unsigned long  nb = 0;

    return ioctlsocket(s, FIONBIO, &nb);
}",21.0,27.0,1.0,1.0,7.0,2,2,4,3,1,0,1,1,0,0,,0,0,2,1,1,int
688,30280,ngx_open_and_stat_file,1,ngx_open_and_stat_file,"ngx_int_t ngx_open_and_stat_file (ngx_str_t*,ngx_open_file_info_t*,ngx_log_t*)",core\ngx_open_file_cache.c,"static ngx_int_t
ngx_open_and_stat_file(ngx_str_t *name, ngx_open_file_info_t *of,
    ngx_log_t *log)
{
    ngx_fd_t         fd;
    ngx_file_info_t  fi;

    if (of->fd != NGX_INVALID_FILE) {

        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {
            of->fd = NGX_INVALID_FILE;
            return NGX_ERROR;
        }

        if (of->uniq == ngx_file_uniq(&fi)) {
            goto done;
        }

    } else if (of->test_dir) {

        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {
            of->fd = NGX_INVALID_FILE;
            return NGX_ERROR;
        }

        if (ngx_is_dir(&fi)) {
            goto done;
        }
    }

    if (!of->log) {

        /*
         * Use non-blocking open() not to hang on FIFO files, etc.
         * This flag has no effect on a regular files.
         */

        fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,
                                   NGX_FILE_OPEN, 0, log);

  ...",839.0,945.0,1.0,51.0,107.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
689,30287,ngx_open_file_add_event,1,ngx_open_file_add_event,"void ngx_open_file_add_event (ngx_open_file_cache_t*,ngx_cached_open_file_t*,ngx_open_file_info_t*,ngx_log_t*)",core\ngx_open_file_cache.c,"static void
ngx_open_file_add_event(ngx_open_file_cache_t *cache,
    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log)
{
    ngx_open_file_cache_event_t  *fev;

    if (!(ngx_event_flags & NGX_USE_VNODE_EVENT)
        || !of->events
        || file->event
        || of->fd == NGX_INVALID_FILE
        || file->uses < of->min_uses)
    {
        return;
    }

    file->use_event = 0;

    file->event = ngx_calloc(sizeof(ngx_event_t), log);
    if (file->event== NULL) {
        return;
    }

    fev = ngx_alloc(sizeof(ngx_open_file_cache_event_t), log);
    if (fev == NULL) {
        ngx_free(file->event);
        file->event = NULL;
        return;
    }

    fev->fd = of->fd;
    fev->file = file;
    fev->cache = cache;

    file->event->handler = ngx_open_file_cache_remove;
    file->event->data = fev;

    /*
     * although vnode event may be called while ngx_cycle->poll
     * destruction, however, cleanup procedures are run before any
     * memory free...",953.0,1014.0,1.0,1.0,62.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
690,411220,ngx_timezone_update,1,ngx_timezone_update,void ngx_timezone_update (void),os\unix\ngx_time.c,"void
ngx_timezone_update(void)
{
#if (NGX_FREEBSD)

    if (getenv(""TZ"")) {
        return;
    }

    putenv(""TZ=UTC"");

    tzset();

    unsetenv(""TZ"");

    tzset();

#elif (NGX_LINUX)
    time_t      s;
    struct tm  *t;
    char        buf[4];

    s = time(0);

    t = localtime(&s);

    strftime(buf, 4, ""%H"", t);

#endif
}",24.0,53.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
691,411225,ngx_localtime,1,ngx_localtime,"void ngx_localtime (time_t,ngx_tm_t*)",os\unix\ngx_time.c,"void
ngx_localtime(time_t s, ngx_tm_t *tm)
{
#if (NGX_HAVE_LOCALTIME_R)
    (void) localtime_r(&s, tm);

#else
    ngx_tm_t  *t;

    t = localtime(&s);
    *tm = *t;

#endif

    tm->ngx_tm_mon++;
    tm->ngx_tm_year += 1900;
}",56.0,72.0,1.0,1.0,17.0,9,6,6,3,1,0,1,1,0,0,,0,0,4,2,2,void
692,91746,ngx_ssl_get_curves,1,ngx_ssl_get_curves,"ngx_int_t ngx_ssl_get_curves (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_GET_CURVES

    int         *curves, n, i, nid;
    u_char      *p;
    size_t       len;

    n = SSL_get1_curves(c->ssl->connection, NULL);

    if (n <= 0) {
        s->len = 0;
        return NGX_OK;
    }

    curves = ngx_palloc(pool, n * sizeof(int));

    n = SSL_get1_curves(c->ssl->connection, curves);
    len = 0;

    for (i = 0; i < n; i++) {
        nid = curves[i];

        if (nid & TLSEXT_nid_unknown) {
            len += sizeof(""0x0000"") - 1;

        } else {
            len += ngx_strlen(OBJ_nid2sn(nid));
        }

        len += sizeof("":"") - 1;
    }

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < n; i++) {
        nid = curves[i];

        if (nid & TLSEXT_nid_unknown) {
            p = ngx_sprintf(p, ""0x%04xd"", nid & 0xffff);

        } else {
            p = ngx_sprintf(p,...",4366.0,4431.0,1.0,1.0,66.0,2,2,2,2,0,1,1,1,0,0,,0,1,6,3,3,ngx_int_t
693,30308,ngx_open_file_del_event,1,ngx_open_file_del_event,void ngx_open_file_del_event (ngx_cached_open_file_t*),core\ngx_open_file_cache.c,"static void
ngx_open_file_del_event(ngx_cached_open_file_t *file)
{
    if (file->event == NULL) {
        return;
    }

    (void) ngx_del_event(file->event, NGX_VNODE_EVENT,
                         file->count ? NGX_FLUSH_EVENT : NGX_CLOSE_EVENT);

    ngx_free(file->event->data);
    ngx_free(file->event);
    file->event = NULL;
    file->use_event = 0;
}",1077.0,1091.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
694,302361,complete_lengths,3,ngx_http_script_compile_t.complete_lengths,,http\ngx_http_script.h,complete_lengths:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
695,30313,ngx_expire_old_cached_files,1,ngx_expire_old_cached_files,"void ngx_expire_old_cached_files (ngx_open_file_cache_t*,ngx_uint_t,ngx_log_t*)",core\ngx_open_file_cache.c,"static void
ngx_expire_old_cached_files(ngx_open_file_cache_t *cache, ngx_uint_t n,
    ngx_log_t *log)
{
    time_t                   now;
    ngx_queue_t             *q;
    ngx_cached_open_file_t  *file;

    now = ngx_time();

    /*
     * n == 1 deletes one or two inactive files
     * n == 0 deletes least recently used file by force
     *        and one or two inactive files
     */

    while (n < 3) {

        if (ngx_queue_empty(&cache->expire_queue)) {
            return;
        }

        q = ngx_queue_last(&cache->expire_queue);

        file = ngx_queue_data(q, ngx_cached_open_file_t, queue);

        if (n++ != 0 && now - file->accessed <= cache->inactive) {
            return;
        }

        ngx_queue_remove(q);

        ngx_rbtree_delete(&cache->rbtree, &file->node);

        cache->current--;

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
                       ""expire cached open file: %s"", file->name);

        if (!file->err && !file->is_dir) {
      ...",1094.0,1142.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
696,300655,ngx_http_script_copy_var_len_code,1,ngx_http_script_copy_var_len_code,size_t ngx_http_script_copy_var_len_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"size_t
ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    if (e->flushed) {
        value = ngx_http_get_indexed_variable(e->request, code->index);

    } else {
        value = ngx_http_get_flushed_variable(e->request, code->index);
    }

    if (value && !value->not_found) {
        return value->len;
    }

    return 0;
}",895.0,917.0,1.0,1.0,23.0,14,7,11,4,0,6,3,3,1,1,,0,6,2,1,1,size_t
697,91760,ngx_ssl_get_session_id,1,ngx_ssl_get_session_id,"ngx_int_t ngx_ssl_get_session_id (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    u_char        *buf;
    SSL_SESSION   *sess;
    unsigned int   len;

    sess = SSL_get0_session(c->ssl->connection);
    if (sess == NULL) {
        s->len = 0;
        return NGX_OK;
    }

    buf = (u_char *) SSL_SESSION_get_id(sess, &len);

    s->len = 2 * len;
    s->data = ngx_pnalloc(pool, 2 * len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    ngx_hex_dump(s->data, buf, len);

    return NGX_OK;
}",4434.0,4458.0,1.0,1.0,25.0,18,6,21,9,0,7,3,3,1,2,,0,6,6,3,3,ngx_int_t
698,398959,ngx_daemon,1,ngx_daemon,ngx_int_t ngx_daemon (ngx_log_t*),os\unix\ngx_daemon.c,"ngx_int_t
ngx_daemon(ngx_log_t *log)
{
    int  fd;

    switch (fork()) {
    case -1:
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""fork() failed"");
        return NGX_ERROR;

    case 0:
        break;

    default:
        exit(0);
    }

    ngx_parent = ngx_pid;
    ngx_pid = ngx_getpid();

    if (setsid() == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""setsid() failed"");
        return NGX_ERROR;
    }

    umask(0);

    fd = open(""/dev/null"", O_RDWR);
    if (fd == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""open(\""/dev/null\"") failed"");
        return NGX_ERROR;
    }

    if (dup2(fd, STDIN_FILENO) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""dup2(STDIN) failed"");
        return NGX_ERROR;
    }

    if (dup2(fd, STDOUT_FILENO) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""dup2(STDOUT) failed"");
        return NGX_ERROR;
    }

#if 0
    if (dup2(fd, STDERR_FILENO) == -1) {
  ...",12.0,71.0,1.0,1.0,60.0,15,4,38,12,1,6,9,9,0,6,,0,0,2,1,1,ngx_int_t
699,63089,ngx_atosz,1,ngx_atosz,"ssize_t ngx_atosz (u_char*,size_t)",core\ngx_string.c,"ssize_t
ngx_atosz(u_char *line, size_t n)
{
    ssize_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_SIZE_T_VALUE / 10;
    cutlim = NGX_MAX_SIZE_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1001.0,1026.0,1.0,1.0,26.0,24,14,22,7,1,0,5,7,0,0,,0,0,4,2,2,ssize_t
700,411251,ngx_libc_localtime,1,ngx_libc_localtime,"void ngx_libc_localtime (time_t,tm*)",os\win32\ngx_time.c,"void
ngx_libc_localtime(time_t s, struct tm *tm)
{
    struct tm  *t;

    t = localtime(&s);
    *tm = *t;
}",41.0,48.0,1.0,1.0,8.0,5,3,4,3,1,0,1,1,0,0,,0,0,4,2,2,void
701,302363,zero,3,ngx_http_script_compile_t.zero,,http\ngx_http_script.h,zero:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
702,30327,ngx_open_file_lookup,1,ngx_open_file_lookup,"ngx_cached_open_file_t* ngx_open_file_lookup (ngx_open_file_cache_t*,ngx_str_t*,uint32_t)",core\ngx_open_file_cache.c,"static ngx_cached_open_file_t *
ngx_open_file_lookup(ngx_open_file_cache_t *cache, ngx_str_t *name,
    uint32_t hash)
{
    ngx_int_t                rc;
    ngx_rbtree_node_t       *node, *sentinel;
    ngx_cached_open_file_t  *file;

    node = cache->rbtree.root;
    sentinel = cache->rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        file = (ngx_cached_open_file_t *) node;

        rc = ngx_strcmp(name->data, file->name);

        if (rc == 0) {
            return file;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",1186.0,1223.0,1.0,1.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_cached_open_file_t
703,30339,ngx_open_file_cache_init,1,ngx_open_file_cache_init,"ngx_open_file_cache_t ngx_open_file_cache_init (ngx_pool_t*,ngx_uint_t,time_t)",core\ngx_open_file_cache.c,"ngx_open_file_cache_t *
ngx_open_file_cache_init(ngx_pool_t *pool, ngx_uint_t max, time_t inactive)
{
    ngx_pool_cleanup_t     *cln;
    ngx_open_file_cache_t  *cache;

    cache = ngx_palloc(pool, sizeof(ngx_open_file_cache_t));
    if (cache == NULL) {
        return NULL;
    }

    ngx_rbtree_init(&cache->rbtree, &cache->sentinel,
                    ngx_open_file_cache_rbtree_insert_value);

    ngx_queue_init(&cache->expire_queue);

    cache->current = 0;
    cache->max = max;
    cache->inactive = inactive;

    cln = ngx_pool_cleanup_add(pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_open_file_cache_cleanup;
    cln->data = cache;

    return cache;
}",56.0,85.0,1.0,1.0,30.0,21,5,24,8,0,8,3,3,0,2,,0,8,6,3,3,ngx_open_file_cache_t
704,38538,ngx_radix32tree_insert,1,ngx_radix32tree_insert,"ngx_int_t ngx_radix32tree_insert (ngx_radix_tree_t*,uint32_t,uint32_t,uintptr_t)",core\ngx_radix_tree.c,"ngx_int_t
ngx_radix32tree_insert(ngx_radix_tree_t *tree, uint32_t key, uint32_t mask,
    uintptr_t value)
{
    uint32_t           bit;
    ngx_radix_node_t  *node, *next;

    bit = 0x80000000;

    node = tree->root;
    next = tree->root;

    while (bit & mask) {
        if (key & bit) {
            next = node->right;

        } else {
            next = node->left;
        }

        if (next == NULL) {
            break;
        }

        bit >>= 1;
        node = next;
    }

    if (next) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            return NGX_BUSY;
        }

        node->value = value;
        return NGX_OK;
    }

    while (bit & mask) {
        next = ngx_radix_alloc(tree);
        if (next == NULL) {
            return NGX_ERROR;
        }

        next->right = NULL;
        next->left = NULL;
        next->parent = node;
        next->value = NGX_RADIX_NO_VALUE;

        if (key & bit) {
            node->right = next;

        } else {
        ...",108.0,170.0,1.0,1.0,63.0,32,5,48,12,1,3,10,14,0,1,,0,3,8,4,4,ngx_int_t
705,317070,ngx_http_upstream_hide_headers_hash,1,ngx_http_upstream_hide_headers_hash,"ngx_int_t ngx_http_upstream_hide_headers_hash (ngx_conf_t*,ngx_http_upstream_conf_t*,ngx_http_upstream_conf_t*,ngx_str_t*,ngx_hash_init_t*)",http\ngx_http_upstream.c,"ngx_int_t
ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf,
    ngx_http_upstream_conf_t *conf, ngx_http_upstream_conf_t *prev,
    ngx_str_t *default_hide_headers, ngx_hash_init_t *hash)
{
    ngx_str_t       *h;
    ngx_uint_t       i, j;
    ngx_array_t      hide_headers;
    ngx_hash_key_t  *hk;

    if (conf->hide_headers == NGX_CONF_UNSET_PTR
        && conf->pass_headers == NGX_CONF_UNSET_PTR)
    {
        conf->hide_headers = prev->hide_headers;
        conf->pass_headers = prev->pass_headers;

        conf->hide_headers_hash = prev->hide_headers_hash;

        if (conf->hide_headers_hash.buckets) {
            return NGX_OK;
        }

    } else {
        if (conf->hide_headers == NGX_CONF_UNSET_PTR) {
            conf->hide_headers = prev->hide_headers;
        }

        if (conf->pass_headers == NGX_CONF_UNSET_PTR) {
            conf->pass_headers = prev->pass_headers;
        }
    }

    if (ngx_array_init(&hide_headers, cf->temp_pool, 4, sizeof(ngx_hash_key_t))
  ...",6300.0,6420.0,1.0,1.0,121.0,126,12,105,16,0,50,22,37,21,8,,0,50,10,5,5,ngx_int_t
706,79513,ngx_process_events_and_timers,1,ngx_process_events_and_timers,void ngx_process_events_and_timers (ngx_cycle_t*),event\ngx_event.c,"void
ngx_process_events_and_timers(ngx_cycle_t *cycle)
{
    ngx_uint_t  flags;
    ngx_msec_t  timer, delta;

    if (ngx_timer_resolution) {
        timer = NGX_TIMER_INFINITE;
        flags = 0;

    } else {
        timer = ngx_event_find_timer();
        flags = NGX_UPDATE_TIME;

#if (NGX_WIN32)

        /* handle signals from master in case of network inactivity */

        if (timer == NGX_TIMER_INFINITE || timer > 500) {
            timer = 500;
        }

#endif
    }

    if (ngx_use_accept_mutex) {
        if (ngx_accept_disabled > 0) {
            ngx_accept_disabled--;

        } else {
            if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {
                return;
            }

            if (ngx_accept_mutex_held) {
                flags |= NGX_POST_EVENTS;

            } else {
                if (timer == NGX_TIMER_INFINITE
                    || timer > ngx_accept_mutex_delay)
                {
                    timer = ngx_accept_mutex_delay;
         ...",193.0,265.0,1.0,1.0,73.0,15,8,28,15,1,11,7,8,4,5,,0,6,2,1,1,void
707,302371,flushes,3,ngx_http_complex_value_t.flushes,,http\ngx_http_script.h,*flushes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
708,22173,ngx_parse_addr,1,ngx_parse_addr,"ngx_int_t ngx_parse_addr (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)",core\ngx_inet.c,"ngx_int_t
ngx_parse_addr(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text, size_t len)
{
    in_addr_t             inaddr;
    ngx_uint_t            family;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct in6_addr       inaddr6;
    struct sockaddr_in6  *sin6;

    /*
     * prevent MSVC8 warning:
     *    potentially uninitialized local variable 'inaddr6' used
     */
    ngx_memzero(&inaddr6, sizeof(struct in6_addr));
#endif

    inaddr = ngx_inet_addr(text, len);

    if (inaddr != INADDR_NONE) {
        family = AF_INET;
        len = sizeof(struct sockaddr_in);

#if (NGX_HAVE_INET6)
    } else if (ngx_inet6_addr(text, len, inaddr6.s6_addr) == NGX_OK) {
        family = AF_INET6;
        len = sizeof(struct sockaddr_in6);

#endif
    } else {
        return NGX_DECLINED;
    }

    addr->sockaddr = ngx_pcalloc(pool, len);
    if (addr->sockaddr == NULL) {
        return NGX_ERROR;
    }

    addr->sockaddr->sa_family = (u_char) family;
    addr->socklen = len;

 ...",561.0,618.0,1.0,1.0,58.0,21,7,25,13,2,3,5,4,0,2,,0,3,8,4,4,ngx_int_t
709,202401,ngx_http_range_body_filter,1,ngx_http_range_body_filter,"ngx_int_t ngx_http_range_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_range_filter_module.c,"static ngx_int_t
ngx_http_range_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_http_range_filter_ctx_t  *ctx;

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_range_body_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if (ctx->ranges.nelts == 1) {
        return ngx_http_range_singlepart_body(r, ctx, in);
    }

    /*
     * multipart ranges are supported only if whole body is in a single buffer
     */

    if (ngx_buf_special(in->buf)) {
        return ngx_http_next_body_filter(r, in);
    }

    if (ngx_http_range_test_overlapped(r, ctx, in) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_range_multipart_body(r, ctx, in);
}",623.0,655.0,1.0,1.0,33.0,8,5,26,7,0,5,6,6,2,3,,0,3,4,2,2,ngx_int_t
710,300714,ngx_http_script_copy_var_code,1,ngx_http_script_copy_var_code,void ngx_http_script_copy_var_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_copy_var_code(ngx_http_script_engine_t *e)
{
    u_char                      *p;
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    if (!e->skip) {

        if (e->flushed) {
            value = ngx_http_get_indexed_variable(e->request, code->index);

        } else {
            value = ngx_http_get_flushed_variable(e->request, code->index);
        }

        if (value && !value->not_found) {
            p = e->pos;
            e->pos = ngx_copy(p, value->data, value->len);

            ngx_log_debug2(NGX_LOG_DEBUG_HTTP,
                           e->request->connection->log, 0,
                           ""http script var: \""%*s\"""", e->pos - p, p);
        }
    }
}",920.0,949.0,1.0,1.0,30.0,26,8,22,6,0,11,4,6,2,1,,0,11,2,1,1,void
711,263869,ngx_http_internal_redirect,1,ngx_http_internal_redirect,"ngx_int_t ngx_http_internal_redirect (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_internal_redirect(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args)
{
    ngx_http_core_srv_conf_t  *cscf;

    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while internally redirecting to \""%V\"""", uri);

        r->main->count++;
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    r->uri = *uri;

    if (args) {
        r->args = *args;

    } else {
        ngx_str_null(&r->args);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""internal redirect: \""%V?%V\"""", uri, &r->args);

    ngx_http_set_exten(r);

    /* clear the modules contexts */
    ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    r->loc_conf = cscf->ctx->loc_conf;

    ngx...",2481.0,2533.0,1.0,1.0,53.0,36,9,34,11,3,7,3,3,0,5,,0,2,6,3,3,ngx_int_t
712,63168,ngx_atoof,1,ngx_atoof,"off_t ngx_atoof (u_char*,size_t)",core\ngx_string.c,"off_t
ngx_atoof(u_char *line, size_t n)
{
    off_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1029.0,1054.0,1.0,1.0,26.0,24,14,22,7,2,0,5,7,0,0,,0,0,4,2,2,off_t
713,87752,ngx_ssl_recv,1,ngx_ssl_recv,"ssize_t ngx_ssl_recv (ngx_connection_t*,u_char*,size_t)",event\ngx_event_openssl.c,"ssize_t
ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int  n, bytes;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->in_early) {
        return ngx_ssl_recv_early(c, buf, size);
    }
#endif

    if (c->ssl->last == NGX_ERROR) {
        c->read->error = 1;
        return NGX_ERROR;
    }

    if (c->ssl->last == NGX_DONE) {
        c->read->ready = 0;
        c->read->eof = 1;
        return 0;
    }

    bytes = 0;

    ngx_ssl_clear_error(c->log);

    /*
     * SSL_read() may return data in parts, so try to read
     * until SSL_read() would return no data
     */

    for ( ;; ) {

        n = SSL_read(c->ssl->connection, buf, size);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_read: %d"", n);

        if (n > 0) {
            bytes += n;
        }

        c->ssl->last = ngx_ssl_handle_recv(c, n);

        if (c->ssl->last == NGX_OK) {

            size -= n;

            if (size == 0) {
                c->read->ready = 1;

              ...",1996.0,2118.0,1.0,1.0,123.0,77,10,58,11,1,2,14,33,0,2,,0,1,6,3,3,ssize_t
714,34505,ngx_palloc_large,1,ngx_palloc_large,"void* ngx_palloc_large (ngx_pool_t*,size_t)",core\ngx_palloc.c,"static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    p = ngx_alloc(size, pool->log);
    if (p == NULL) {
        return NULL;
    }

    n = 0;

    for (large = pool->large; large; large = large->next) {
        if (large->alloc == NULL) {
            large->alloc = p;
            return p;
        }

        if (n++ > 3) {
            break;
        }
    }

    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    large->alloc = p;
    large->next = pool->large;
    pool->large = large;

    return p;
}",213.0,249.0,1.0,1.0,37.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void*
715,67277,facility,3,ngx_syslog_peer_t.facility,,core\ngx_syslog.h,facility,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
716,67278,severity,3,ngx_syslog_peer_t.severity,,core\ngx_syslog.h,severity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
717,34511,ngx_create_pool,1,ngx_create_pool,"ngx_pool_t ngx_create_pool (size_t,ngx_log_t*)",core\ngx_palloc.c,"ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p->d.last = (u_char *) p + sizeof(ngx_pool_t);
    p->d.end = (u_char *) p + size;
    p->d.next = NULL;
    p->d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    p->max = (size < NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p->current = p;
    p->chain = NULL;
    p->large = NULL;
    p->cleanup = NULL;
    p->log = log;

    return p;
}",18.0,43.0,1.0,1.0,26.0,36,10,35,7,7,0,2,2,0,0,,0,0,4,2,2,ngx_pool_t
718,91856,ngx_ssl_get_early_data,1,ngx_ssl_get_early_data,"ngx_int_t ngx_ssl_get_early_data (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->len = 0;

#ifdef SSL_ERROR_EARLY_DATA_REJECTED

    /* BoringSSL */

    if (SSL_in_early_data(c->ssl->connection)) {
        ngx_str_set(s, ""1"");
    }

#elif defined SSL_READ_EARLY_DATA_SUCCESS

    /* OpenSSL */

    if (!SSL_is_init_finished(c->ssl->connection)) {
        ngx_str_set(s, ""1"");
    }

#endif

    return NGX_OK;
}",4475.0,4499.0,1.0,1.0,25.0,2,2,2,2,0,1,1,1,0,0,,0,1,6,3,3,ngx_int_t
719,67281,conn,3,ngx_syslog_peer_t.conn,,core\ngx_syslog.h,conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
720,67282,busy,3,ngx_syslog_peer_t.busy,,core\ngx_syslog.h,busy:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
721,67283,nohostname,3,ngx_syslog_peer_t.nohostname,,core\ngx_syslog.h,nohostname:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
722,67279,tag,3,ngx_syslog_peer_t.tag,,core\ngx_syslog.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
723,67280,server,3,ngx_syslog_peer_t.server,,core\ngx_syslog.h,server,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
724,419536,ngx_create_thread,1,ngx_create_thread,"ngx_err_t ngx_create_thread (ngx_tid_t*,ngx_thread_value_t,void*,ngx_log_t*)",os\win32\ngx_thread.c,"ngx_err_t
ngx_create_thread(ngx_tid_t *tid,
    ngx_thread_value_t (__stdcall *func)(void *arg), void *arg, ngx_log_t *log)
{
    u_long     id;
    ngx_err_t  err;

    *tid = CreateThread(NULL, 0, func, arg, 0, &id);

    if (*tid != NULL) {
        ngx_log_error(NGX_LOG_NOTICE, log, 0,
                      ""create thread "" NGX_TID_T_FMT, id);
        return 0;
    }

    err = ngx_errno;
    ngx_log_error(NGX_LOG_ALERT, log, err, ""CreateThread() failed"");
    return err;
}",12.0,30.0,1.0,24.0,19.0,6,4,13,9,0,1,2,2,0,1,,0,0,8,4,4,ngx_err_t
725,206553,ngx_http_rewrite_var,1,ngx_http_rewrite_var,"ngx_int_t ngx_http_rewrite_var (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_rewrite_module.c,"static ngx_int_t
ngx_http_rewrite_var(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_variable_t          *var;
    ngx_http_core_main_conf_t    *cmcf;
    ngx_http_rewrite_loc_conf_t  *rlcf;

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);

    if (rlcf->uninitialized_variable_warn == 0) {
        *v = ngx_http_variable_null_value;
        return NGX_OK;
    }

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    var = cmcf->variables.elts;

    /*
     * the ngx_http_rewrite_module sets variables directly in r->variables,
     * and they should be handled by ngx_http_get_indexed_variable(),
     * so the handler is called only if the variable is not initialized
     */

    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
                  ""using uninitialized \""%V\"" variable"", &var[data].name);

    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",187.0,218.0,1.0,1.0,32.0,16,7,19,11,0,4,2,2,1,1,,0,3,6,3,3,ngx_int_t
726,91870,ngx_ssl_get_server_name,1,ngx_ssl_get_server_name,"ngx_int_t ngx_ssl_get_server_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME

    size_t       len;
    const char  *name;

    name = SSL_get_servername(c->ssl->connection, TLSEXT_NAMETYPE_host_name);

    if (name) {
        len = ngx_strlen(name);

        s->len = len;
        s->data = ngx_pnalloc(pool, len);
        if (s->data == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(s->data, name, len);

        return NGX_OK;
    }

#endif

    s->len = 0;
    return NGX_OK;
}",4502.0,4530.0,1.0,1.0,29.0,2,2,2,2,0,1,1,1,0,0,,0,1,6,3,3,ngx_int_t
727,399079,ngx_debug_init,1,ngx_debug_init,void ngx_debug_init (void),os\unix\ngx_freebsd_init.c,"void
ngx_debug_init(void)
{
#if (NGX_DEBUG_MALLOC)

#if __FreeBSD_version >= 500014 && __FreeBSD_version < 1000011
    _malloc_options = ""J"";
#elif __FreeBSD_version < 500014
    malloc_options = ""J"";
#endif

    ngx_debug_malloc = 1;

#else
    char  *mo;

    mo = getenv(""MALLOC_OPTIONS"");

    if (mo && ngx_strchr(mo, 'J')) {
        ngx_debug_malloc = 1;
    }
#endif
}",76.0,98.0,1.0,1.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
728,91884,ngx_ssl_get_raw_certificate,1,ngx_ssl_get_raw_certificate,"ngx_int_t ngx_ssl_get_raw_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    size_t   len;
    BIO     *bio;
    X509    *cert;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""BIO_new() failed"");
        X509_free(cert);
        return NGX_ERROR;
    }

    if (PEM_write_bio_X509(bio, cert) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""PEM_write_bio_X509() failed"");
        goto failed;
    }

    len = BIO_pending(bio);
    s->len = len;

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",4533.0,4580.0,1.0,1.0,48.0,19,3,35,10,2,8,7,5,1,3,,0,6,6,3,3,ngx_int_t
729,22256,ngx_parse_addr_port,1,ngx_parse_addr_port,"ngx_int_t ngx_parse_addr_port (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)",core\ngx_inet.c,"ngx_int_t
ngx_parse_addr_port(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text,
    size_t len)
{
    u_char     *p, *last;
    size_t      plen;
    ngx_int_t   rc, port;

    rc = ngx_parse_addr(pool, addr, text, len);

    if (rc != NGX_DECLINED) {
        return rc;
    }

    last = text + len;

#if (NGX_HAVE_INET6)
    if (len && text[0] == '[') {

        p = ngx_strlchr(text, last, ']');

        if (p == NULL || p == last - 1 || *++p != ':') {
            return NGX_DECLINED;
        }

        text++;
        len -= 2;

    } else
#endif

    {
        p = ngx_strlchr(text, last, ':');

        if (p == NULL) {
            return NGX_DECLINED;
        }
    }

    p++;
    plen = last - p;

    port = ngx_atoi(p, plen);

    if (port < 1 || port > 65535) {
        return NGX_DECLINED;
    }

    len -= plen + 1;

    rc = ngx_parse_addr(pool, addr, text, len);

    if (rc != NGX_OK) {
        return rc;
    }

    ngx_inet_set_port(addr->sockaddr, (in_port_t) port);

    r...",621.0,680.0,1.0,1.0,60.0,19,12,40,12,0,4,5,5,0,4,,0,3,8,4,4,ngx_int_t
730,440056,ngx_stream_map_cmp_dns_wildcards,1,ngx_stream_map_cmp_dns_wildcards,"ANY ngx_stream_map_cmp_dns_wildcards (void*,void*)",stream\ngx_stream_map_module.c,"ngx_stream_map_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",368.0,376.0,1.0,1.0,9.0,8,4,6,4,0,3,1,1,0,1,,0,2,4,2,2,ANY
731,9977,ngx_free_connection,1,ngx_free_connection,void ngx_free_connection (ngx_connection_t*),core\ngx_connection.c,"void
ngx_free_connection(ngx_connection_t *c)
{
    c->data = ngx_cycle->free_connections;
    ngx_cycle->free_connections = c;
    ngx_cycle->free_connection_n++;

    if (ngx_cycle->files && ngx_cycle->files[c->fd] == c) {
        ngx_cycle->files[c->fd] = NULL;
    }
}",1161.0,1171.0,1.0,1.0,11.0,17,6,12,3,3,0,2,2,0,0,,0,0,2,1,1,void
732,67324,pools,3,ngx_thread_pool_conf_t.pools,,core\ngx_thread_pool.c,pools,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
733,79628,ngx_handle_read_event,1,ngx_handle_read_event,"ngx_int_t ngx_handle_read_event (ngx_event_t*,ngx_uint_t)",event\ngx_event.c,"ngx_int_t
ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags)
{
    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        /* kqueue, epoll */

        if (!rev->active && !rev->ready) {
            if (ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }
        }

        return NGX_OK;

    } else if (ngx_event_flags & NGX_USE_LEVEL_EVENT) {

        /* select, poll, /dev/poll */

        if (!rev->active && !rev->ready) {
            if (ngx_add_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

        if (rev->active && (rev->ready || (flags & NGX_CLOSE_EVENT))) {
            if (ngx_del_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT | flags)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
    ...",268.0,333.0,1.0,1.0,66.0,7,5,11,7,11,1,4,7,1,0,,0,1,4,2,2,ngx_int_t
734,386831,ngx_mail_smtp_parse_command,1,ngx_mail_smtp_parse_command,ngx_int_t ngx_mail_smtp_parse_command (ngx_mail_session_t*),mail\ngx_mail_parse.c,"ngx_int_t
ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
{
    u_char      ch, *p, *c, c0, c1, c2, c3;
    ngx_str_t  *arg;
    enum {
        sw_start = 0,
        sw_command,
        sw_invalid,
        sw_spaces_before_argument,
        sw_argument,
        sw_almost_done
    } state;

    state = s->state;

    for (p = s->buffer->pos; p < s->buffer->last; p++) {
        ch = *p;

        switch (state) {

        /* SMTP command */
        case sw_start:
            s->cmd_start = p;
            state = sw_command;

            /* fall through */

        case sw_command:
            if (ch == ' ' || ch == CR || ch == LF) {
                c = s->cmd_start;

                if (p - c == 4) {

                    c0 = ngx_toupper(c[0]);
                    c1 = ngx_toupper(c[1]);
                    c2 = ngx_toupper(c[2]);
                    c3 = ngx_toupper(c[3]);

                    if (c0 == 'H' && c1 == 'E' && c2 == 'L' && c3 == 'O')
                    {
             ...",622.0,857.0,1.0,1.0,236.0,130,17,138,25,0,41,40,50,4,2,,0,41,2,1,1,ngx_int_t
735,63247,ngx_atotm,1,ngx_atotm,"time_t ngx_atotm (u_char*,size_t)",core\ngx_string.c,"time_t
ngx_atotm(u_char *line, size_t n)
{
    time_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_TIME_T_VALUE / 10;
    cutlim = NGX_MAX_TIME_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1057.0,1082.0,1.0,1.0,26.0,24,14,22,7,1,0,5,7,0,0,,0,0,4,2,2,time_t
736,243473,ngx_http_uwsgi_module,2,http\modules\ngx_http_uwsgi_module.c.ngx_http_uwsgi_module,,http\modules\ngx_http_uwsgi_module.c,ngx_module_t ngx_http_uwsgi_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
737,419604,ngx_gettimeofday,1,ngx_gettimeofday,void ngx_gettimeofday (timeval*),os\win32\ngx_time.c,"void
ngx_gettimeofday(struct timeval *tp)
{
    uint64_t  intervals;
    FILETIME  ft;

    GetSystemTimeAsFileTime(&ft);

    /*
     * A file time is a 64-bit value that represents the number
     * of 100-nanosecond intervals that have elapsed since
     * January 1, 1601 12:00 A.M. UTC.
     *
     * Between January 1, 1970 (Epoch) and January 1, 1601 there were
     * 134774 days,
     * 11644473600 seconds or
     * 11644473600,000,000,0 100-nanosecond intervals.
     *
     * See also MSKB Q167296.
     */

    intervals = ((uint64_t) ft.dwHighDateTime << 32) | ft.dwLowDateTime;
    intervals -= 116444736000000000;

    tp->tv_sec = (long) (intervals / 10000000);
    tp->tv_usec = (long) ((intervals % 10000000) / 10);
}",12.0,38.0,1.0,1.0,27.0,17,10,9,3,2,0,1,1,0,0,,0,0,2,1,1,void
738,38681,ngx_radix32tree_delete,1,ngx_radix32tree_delete,"ngx_int_t ngx_radix32tree_delete (ngx_radix_tree_t*,uint32_t,uint32_t)",core\ngx_radix_tree.c,"ngx_int_t
ngx_radix32tree_delete(ngx_radix_tree_t *tree, uint32_t key, uint32_t mask)
{
    uint32_t           bit;
    ngx_radix_node_t  *node;

    bit = 0x80000000;
    node = tree->root;

    while (node && (bit & mask)) {
        if (key & bit) {
            node = node->right;

        } else {
            node = node->left;
        }

        bit >>= 1;
    }

    if (node == NULL) {
        return NGX_ERROR;
    }

    if (node->right || node->left) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            node->value = NGX_RADIX_NO_VALUE;
            return NGX_OK;
        }

        return NGX_ERROR;
    }

    for ( ;; ) {
        if (node->parent->right == node) {
            node->parent->right = NULL;

        } else {
            node->parent->left = NULL;
        }

        node->right = tree->free;
        tree->free = node;

        node = node->parent;

        if (node->right || node->left) {
            break;
        }

        if (node->value != NGX_RADIX...",173.0,233.0,1.0,1.0,61.0,36,7,39,9,0,3,14,17,0,0,,0,3,6,3,3,ngx_int_t
739,132893,ngx_http_grpc_module,2,http\modules\ngx_http_grpc_module.c.ngx_http_grpc_module,,http\modules\ngx_http_grpc_module.c,ngx_module_t ngx_http_grpc_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
740,10022,ngx_close_connection,1,ngx_close_connection,void ngx_close_connection (ngx_connection_t*),core\ngx_connection.c,"void
ngx_close_connection(ngx_connection_t *c)
{
    ngx_err_t     err;
    ngx_uint_t    log_error, level;
    ngx_socket_t  fd;

    if (c->fd == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, 0, ""connection already closed"");
        return;
    }

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    if (c->write->timer_set) {
        ngx_del_timer(c->write);
    }

    if (!c->shared) {
        if (ngx_del_conn) {
            ngx_del_conn(c, NGX_CLOSE_EVENT);

        } else {
            if (c->read->active || c->read->disabled) {
                ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
            }

            if (c->write->active || c->write->disabled) {
                ngx_del_event(c->write, NGX_WRITE_EVENT, NGX_CLOSE_EVENT);
            }
        }
    }

    if (c->read->posted) {
        ngx_delete_posted_event(c->read);
    }

    if (c->write->posted) {
        ngx_delete_posted_event(c->write);
    }

    c->read...",1174.0,1259.0,1.0,1.0,86.0,41,7,43,17,2,3,14,16,0,3,,0,0,2,1,1,void
741,34611,ngx_destroy_pool,1,ngx_destroy_pool,void ngx_destroy_pool (ngx_pool_t*),core\ngx_palloc.c,"void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    for (c = pool->cleanup; c; c = c->next) {
        if (c->handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           ""run cleanup: %p"", c);
            c->handler(c->data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool->log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool->large; l; l = l->next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0, ""free: %p"", l->alloc);
    }

    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                       ""free: %p, unused: %uz"", p, p->d.end - p->d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    for (l = pool->large; l; l = l->next) {
        if (l->alloc) {
            ...",46.0,96.0,1.0,1.0,51.0,21,5,25,7,22,0,8,10,0,0,,0,0,2,1,1,void
742,304953,ngx_http_upstream_module,2,http\ngx_http_upstream.c.ngx_http_upstream_module,,http\ngx_http_upstream.c,ngx_module_t ngx_http_upstream_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
743,243515,ngx_http_uwsgi_handler,1,ngx_http_uwsgi_handler,ngx_int_t ngx_http_uwsgi_handler (ngx_http_request_t*),http\modules\ngx_http_uwsgi_module.c,"static ngx_int_t
ngx_http_uwsgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                    rc;
    ngx_http_status_t           *status;
    ngx_http_upstream_t         *u;
    ngx_http_uwsgi_loc_conf_t   *uwcf;
#if (NGX_HTTP_CACHE)
    ngx_http_uwsgi_main_conf_t  *uwmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    status = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t));
    if (status == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, status, ngx_http_uwsgi_module);

    uwcf = ngx_http_get_module_loc_conf(r, ngx_http_uwsgi_module);

    u = r->upstream;

    if (uwcf->uwsgi_lengths == NULL) {

#if (NGX_HTTP_SSL)
        u->ssl = (uwcf->upstream.ssl != NULL);

        if (u->ssl) {
            ngx_str_set(&u->schema, ""suwsgi://"");

        } else {
            ngx_str_set(&u->schema, ""uwsgi://"");
        }
#else
        ngx_str_set(&u->schema, ""uwsgi://"");
#endif

   ...",631.0,720.0,1.0,1.0,90.0,62,11,59,21,0,12,7,7,4,4,,0,12,2,1,1,ngx_int_t
744,263996,ngx_http_named_location,1,ngx_http_named_location,"ngx_int_t ngx_http_named_location (ngx_http_request_t*,ngx_str_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_named_location(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_http_core_srv_conf_t    *cscf;
    ngx_http_core_loc_conf_t   **clcfp;
    ngx_http_core_main_conf_t   *cmcf;

    r->main->count++;
    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while redirect to named location \""%V\"""", name);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    if (r->uri.len == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""empty URI in redirect to named location \""%V\"""", name);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    if (cscf->named_locations) {

        for (clcfp = cscf->named_locations; *clcfp; clcfp++) {...",2536.0,2609.0,1.0,1.0,74.0,64,12,60,13,1,16,7,9,4,8,,0,8,4,2,2,ngx_int_t
745,300865,ngx_http_script_mark_args_code,1,ngx_http_script_mark_args_code,size_t ngx_http_script_mark_args_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"size_t
ngx_http_script_mark_args_code(ngx_http_script_engine_t *e)
{
    e->is_args = 1;
    e->ip += sizeof(uintptr_t);

    return 1;
}",975.0,982.0,1.0,1.0,8.0,5,4,3,2,0,2,1,1,0,0,,0,2,2,1,1,size_t
746,161609,ngx_http_limit_req_init_zone,1,ngx_http_limit_req_init_zone,"ngx_int_t ngx_http_limit_req_init_zone (ngx_shm_zone_t*,void*)",http\modules\ngx_http_limit_req_module.c,"static ngx_int_t
ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_limit_req_ctx_t  *octx = data;

    size_t                     len;
    ngx_http_limit_req_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_req \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
        ctx->s...",681.0,744.0,1.0,1.0,64.0,89,10,50,10,0,32,6,7,7,4,,0,30,4,2,2,ngx_int_t
747,448330,ngx_stream_script_add_code,1,ngx_stream_script_add_code,"void* ngx_stream_script_add_code (ngx_array_t*,size_t,void*)",stream\ngx_stream_script.c,"void *
ngx_stream_script_add_code(ngx_array_t *codes, size_t size, void *code)
{
    u_char  *elts, **p;
    void    *new;

    elts = codes->elts;

    new = ngx_array_push_n(codes, size);
    if (new == NULL) {
        return NULL;
    }

    if (code) {
        if (elts != codes->elts) {
            p = code;
            *p += (u_char *) codes->elts - elts;
        }
    }

    return new;
}",609.0,630.0,1.0,1.0,22.0,12,8,17,7,0,4,4,5,1,1,,0,4,6,3,3,void*
748,163193,ngx_http_log_module,2,http\modules\ngx_http_log_module.c.ngx_http_log_module,,http\modules\ngx_http_log_module.c,ngx_module_t ngx_http_log_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
749,22353,ngx_parse_url,1,ngx_parse_url,"ngx_int_t ngx_parse_url (ngx_pool_t*,ngx_url_t*)",core\ngx_inet.c,"ngx_int_t
ngx_parse_url(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char  *p;
    size_t   len;

    p = u->url.data;
    len = u->url.len;

    if (len >= 5 && ngx_strncasecmp(p, (u_char *) ""unix:"", 5) == 0) {
        return ngx_parse_unix_domain_url(pool, u);
    }

    if (len && p[0] == '[') {
        return ngx_parse_inet6_url(pool, u);
    }

    return ngx_parse_inet_url(pool, u);
}",683.0,701.0,1.0,1.0,19.0,13,8,14,4,3,6,3,3,1,4,,0,3,4,2,2,ngx_int_t
750,300883,ngx_http_script_start_args_code,1,ngx_http_script_start_args_code,void ngx_http_script_start_args_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_start_args_code(ngx_http_script_engine_t *e)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script args"");

    e->is_args = 1;
    e->args = e->pos;
    e->ip += sizeof(uintptr_t);
}",985.0,994.0,1.0,1.0,10.0,11,4,7,3,0,5,1,1,0,0,,0,5,2,1,1,void
751,399188,ngx_darwin_kern_ostype,2,os\unix\ngx_darwin_init.c.ngx_darwin_kern_ostype,,os\unix\ngx_darwin_init.c,char[16] ngx_darwin_kern_ostype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
752,399191,ngx_darwin_kern_osrelease,2,os\unix\ngx_darwin_init.c.ngx_darwin_kern_osrelease,,os\unix\ngx_darwin_init.c,char[128] ngx_darwin_kern_osrelease,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
753,91992,ngx_ssl_get_certificate,1,ngx_ssl_get_certificate,"ngx_int_t ngx_ssl_get_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    u_char      *p;
    size_t       len;
    ngx_uint_t   i;
    ngx_str_t    cert;

    if (ngx_ssl_get_raw_certificate(c, pool, &cert) != NGX_OK) {
        return NGX_ERROR;
    }

    if (cert.len == 0) {
        s->len = 0;
        return NGX_OK;
    }

    len = cert.len - 1;

    for (i = 0; i < cert.len - 1; i++) {
        if (cert.data[i] == LF) {
            len++;
        }
    }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < cert.len - 1; i++) {
        *p++ = cert.data[i];
        if (cert.data[i] == LF) {
            *p++ = '\t';
        }
    }

    return NGX_OK;
}",4583.0,4624.0,1.0,1.0,42.0,40,11,38,11,0,14,8,10,7,2,,0,14,6,3,3,ngx_int_t
754,30553,ngx_open_cached_file,1,ngx_open_cached_file,"ngx_int_t ngx_open_cached_file (ngx_open_file_cache_t*,ngx_str_t*,ngx_open_file_info_t*,ngx_pool_t*)",core\ngx_open_file_cache.c,"ngx_int_t
ngx_open_cached_file(ngx_open_file_cache_t *cache, ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_pool_t *pool)
{
    time_t                          now;
    uint32_t                        hash;
    ngx_int_t                       rc;
    ngx_file_info_t                 fi;
    ngx_pool_cleanup_t             *cln;
    ngx_cached_open_file_t         *file;
    ngx_pool_cleanup_file_t        *clnf;
    ngx_open_file_cache_cleanup_t  *ofcln;

    of->fd = NGX_INVALID_FILE;
    of->err = 0;

    if (cache == NULL) {

        if (of->test_only) {

            if (ngx_file_info_wrapper(name, of, &fi, pool->log)
                == NGX_FILE_ERROR)
            {
                return NGX_ERROR;
            }

            of->uniq = ngx_file_uniq(&fi);
            of->mtime = ngx_file_mtime(&fi);
            of->size = ngx_file_size(&fi);
            of->fs_size = ngx_file_fs_size(&fi);
            of->is_dir = ngx_is_dir(&fi);
            of->is_file = ngx_is_file(&fi);
    ...",143.0,486.0,1.0,1.0,344.0,307,16,258,23,3,93,43,64,21,19,,0,85,8,4,4,ngx_int_t
755,399194,ngx_darwin_hw_ncpu,2,os\unix\ngx_darwin_init.c.ngx_darwin_hw_ncpu,,os\unix\ngx_darwin_init.c,int ngx_darwin_hw_ncpu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
756,399195,ngx_darwin_kern_ipc_somaxconn,2,os\unix\ngx_darwin_init.c.ngx_darwin_kern_ipc_somaxconn,,os\unix\ngx_darwin_init.c,int ngx_darwin_kern_ipc_somaxconn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
757,67422,ngx_thread_pool_module,2,core\ngx_thread_pool.c.ngx_thread_pool_module,,core\ngx_thread_pool.c,ngx_module_t ngx_thread_pool_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
758,399198,ngx_darwin_io,2,os\unix\ngx_darwin_init.c.ngx_darwin_io,,os\unix\ngx_darwin_init.c,ngx_os_io_t ngx_darwin_io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
759,400918,ngx_open_tempfile,1,ngx_open_tempfile,"ngx_fd_t ngx_open_tempfile (u_char*,ngx_uint_t,ngx_uint_t)",os\unix\ngx_files.c,"ngx_fd_t
ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)
{
    ngx_fd_t  fd;

    fd = open((const char *) name, O_CREAT|O_EXCL|O_RDWR,
              access ? access : 0600);

    if (fd != -1 && !persistent) {
        (void) unlink((const char *) name);
    }

    return fd;
}",276.0,289.0,1.0,1.0,14.0,11,8,11,7,1,0,2,2,0,0,,0,0,6,3,3,ngx_fd_t
760,67439,ngx_thread_pool_default,2,core\ngx_thread_pool.c.ngx_thread_pool_default,,core\ngx_thread_pool.c,ngx_str_t ngx_thread_pool_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
761,399216,sysctls,2,os\unix\ngx_darwin_init.c.sysctls,,os\unix\ngx_darwin_init.c,sysctl_t[] sysctls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
762,67444,ngx_thread_pool_task_id,2,core\ngx_thread_pool.c.ngx_thread_pool_task_id,,core\ngx_thread_pool.c,ngx_uint_t ngx_thread_pool_task_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
763,132995,ngx_http_grpc_handler,1,ngx_http_grpc_handler,ngx_int_t ngx_http_grpc_handler (ngx_http_request_t*),http\modules\ngx_http_grpc_module.c,"static ngx_int_t
ngx_http_grpc_handler(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_http_upstream_t       *u;
    ngx_http_grpc_ctx_t       *ctx;
    ngx_http_grpc_loc_conf_t  *glcf;

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));
    if (ctx == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx->request = r;

    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);

    glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);

    u = r->upstream;

    if (glcf->grpc_lengths == NULL) {
        ctx->host = glcf->host;

#if (NGX_HTTP_SSL)
        u->ssl = (glcf->upstream.ssl != NULL);

        if (u->ssl) {
            ngx_str_set(&u->schema, ""grpcs://"");

        } else {
            ngx_str_set(&u->schema, ""grpc://"");
        }
#else
        ngx_str_set(&u->schema, ""grpc://"");
#endif

    } else {
        if (ngx_http_grpc_ev...",523.0,593.0,1.0,1.0,71.0,45,9,53,21,0,12,5,5,2,3,,0,12,2,1,1,ngx_int_t
764,259987,ngx_http_core_module,2,http\ngx_http_core_module.c.ngx_http_core_module,,http\ngx_http_core_module.c,ngx_module_t ngx_http_core_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
765,399258,ngx_os_specific_init,1,ngx_os_specific_init,ngx_int_t ngx_os_specific_init (ngx_log_t*),os\unix\ngx_solaris_init.c,"ngx_int_t
ngx_os_specific_init(ngx_log_t *log)
{
    if (sysinfo(SI_SYSNAME, ngx_solaris_sysname, sizeof(ngx_solaris_sysname))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_SYSNAME) failed"");
        return NGX_ERROR;
    }

    if (sysinfo(SI_RELEASE, ngx_solaris_release, sizeof(ngx_solaris_release))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_RELEASE) failed"");
        return NGX_ERROR;
    }

    if (sysinfo(SI_VERSION, ngx_solaris_version, sizeof(ngx_solaris_version))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_SYSNAME) failed"");
        return NGX_ERROR;
    }


    ngx_os_io = ngx_solaris_io;

    return NGX_OK;
}",34.0,65.0,1.0,1.0,32.0,45,10,68,20,0,19,13,19,6,4,,0,15,2,1,1,ngx_int_t
766,79773,ngx_handle_write_event,1,ngx_handle_write_event,"ngx_int_t ngx_handle_write_event (ngx_event_t*,size_t)",event\ngx_event.c,"ngx_int_t
ngx_handle_write_event(ngx_event_t *wev, size_t lowat)
{
    ngx_connection_t  *c;

    if (lowat) {
        c = wev->data;

        if (ngx_send_lowat(c, lowat) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        /* kqueue, epoll */

        if (!wev->active && !wev->ready) {
            if (ngx_add_event(wev, NGX_WRITE_EVENT,
                              NGX_CLEAR_EVENT | (lowat ? NGX_LOWAT_EVENT : 0))
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }
        }

        return NGX_OK;

    } else if (ngx_event_flags & NGX_USE_LEVEL_EVENT) {

        /* select, poll, /dev/poll */

        if (!wev->active && !wev->ready) {
            if (ngx_add_event(wev, NGX_WRITE_EVENT, NGX_LEVEL_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

        if (wev->active && wev->ready) {
  ...",336.0,412.0,1.0,1.0,77.0,12,8,20,10,7,2,6,10,2,1,,0,2,4,2,2,ngx_int_t
767,258462,ngx_http_core_find_location,1,ngx_http_core_find_location,ngx_int_t ngx_http_core_find_location (ngx_http_request_t*),http\ngx_http_core_module.c,"static ngx_int_t
ngx_http_core_find_location(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *pclcf;
#if (NGX_PCRE)
    ngx_int_t                  n;
    ngx_uint_t                 noregex;
    ngx_http_core_loc_conf_t  *clcf, **clcfp;

    noregex = 0;
#endif

    pclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    rc = ngx_http_core_find_static_location(r, pclcf->static_locations);

    if (rc == NGX_AGAIN) {

#if (NGX_PCRE)
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        noregex = clcf->noregex;
#endif

        /* look up nested locations */

        rc = ngx_http_core_find_location(r);
    }

    if (rc == NGX_OK || rc == NGX_DONE) {
        return rc;
    }

    /* rc == NGX_DECLINED or rc == NGX_AGAIN in nested location */

#if (NGX_PCRE)

    if (noregex == 0 && pclcf->regex_locations) {

        for (clcfp = pclcf->regex_locations; *clcfp; clcfp++) {

            ngx_log_debug1(NGX_LOG_D...",1376.0,1443.0,1.0,1.0,68.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
768,260004,ngx_http_core_get_method,2,http\ngx_http_core_module.c.ngx_http_core_get_method,,http\ngx_http_core_module.c,ngx_str_t ngx_http_core_get_method,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
769,190376,ngx_http_proxy_module,2,http\modules\ngx_http_proxy_module.c.ngx_http_proxy_module,,http\modules\ngx_http_proxy_module.c,ngx_module_t ngx_http_proxy_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
770,276395,ngx_http_file_cache_manager,1,ngx_http_file_cache_manager,ngx_msec_t ngx_http_file_cache_manager (void*),http\ngx_http_file_cache.c,"static ngx_msec_t
ngx_http_file_cache_manager(void *data)
{
    ngx_http_file_cache_t  *cache = data;

    off_t       size;
    time_t      wait;
    ngx_msec_t  elapsed, next;
    ngx_uint_t  count, watermark;

    cache->last = ngx_current_msec;
    cache->files = 0;

    next = (ngx_msec_t) ngx_http_file_cache_expire(cache) * 1000;

    if (next == 0) {
        next = cache->manager_sleep;
        goto done;
    }

    for ( ;; ) {
        ngx_shmtx_lock(&cache->shpool->mutex);

        size = cache->sh->size;
        count = cache->sh->count;
        watermark = cache->sh->watermark;

        ngx_shmtx_unlock(&cache->shpool->mutex);

        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                       ""http file cache size: %O c:%ui w:%i"",
                       size, count, (ngx_int_t) watermark);

        if (size < cache->max_size && count < watermark) {
            break;
        }

        wait = ngx_http_file_cache_forced_expire(cache);

        if (wait >...",1957.0,2029.0,1.0,1.0,73.0,56,13,54,13,0,5,14,13,0,5,,0,2,2,1,1,ngx_msec_t
771,38830,ngx_radix32tree_find,1,ngx_radix32tree_find,"uintptr_t ngx_radix32tree_find (ngx_radix_tree_t*,uint32_t)",core\ngx_radix_tree.c,"uintptr_t
ngx_radix32tree_find(ngx_radix_tree_t *tree, uint32_t key)
{
    uint32_t           bit;
    uintptr_t          value;
    ngx_radix_node_t  *node;

    bit = 0x80000000;
    value = NGX_RADIX_NO_VALUE;
    node = tree->root;

    while (node) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            value = node->value;
        }

        if (key & bit) {
            node = node->right;

        } else {
            node = node->left;
        }

        bit >>= 1;
    }

    return value;
}",236.0,263.0,1.0,1.0,28.0,11,4,16,6,4,1,4,6,0,0,,0,1,4,2,2,uintptr_t
772,63419,ngx_hex_dump,1,ngx_hex_dump,"u_char ngx_hex_dump (u_char*,u_char*,size_t)",core\ngx_string.c,"u_char *
ngx_hex_dump(u_char *dst, u_char *src, size_t len)
{
    static u_char  hex[] = ""0123456789abcdef"";

    while (len--) {
        *dst++ = hex[*src >> 4];
        *dst++ = hex[*src++ & 0xf];
    }

    return dst;
}",1123.0,1134.0,1.0,1.0,12.0,15,7,9,4,2,0,2,2,0,0,,0,0,6,3,3,u_char
773,321488,ngx_http_variable_depth,2,http\ngx_http_variables.c.ngx_http_variable_depth,,http\ngx_http_variables.c,ngx_uint_t ngx_http_variable_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
774,321492,ngx_http_add_variable,1,ngx_http_add_variable,"ngx_http_variable_t ngx_http_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)",http\ngx_http_variables.c,"ngx_http_variable_t *
ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_int_t                   rc;
    ngx_uint_t                  i;
    ngx_hash_key_t             *key;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NULL;
    }

    if (flags & NGX_HTTP_VAR_PREFIX) {
        return ngx_http_add_prefix_variable(cf, name, flags);
    }

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    key = cmcf->variables_keys->keys.elts;
    for (i = 0; i < cmcf->variables_keys->keys.nelts; i++) {
        if (name->len != key[i].key.len
            || ngx_strncasecmp(name->data, key[i].key.data, name->len) != 0)
        {
            continue;
        }

        v = key[i].value;

        if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
            ngx_conf_log_error...",405.0,481.0,1.0,1.0,77.0,71,13,77,17,1,20,12,14,6,9,,0,15,6,3,3,ngx_http_variable_t
775,92127,ngx_ssl_get_escaped_certificate,1,ngx_ssl_get_escaped_certificate,"ngx_int_t ngx_ssl_get_escaped_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_escaped_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    ngx_str_t  cert;
    uintptr_t  n;

    if (ngx_ssl_get_raw_certificate(c, pool, &cert) != NGX_OK) {
        return NGX_ERROR;
    }

    if (cert.len == 0) {
        s->len = 0;
        return NGX_OK;
    }

    n = ngx_escape_uri(NULL, cert.data, cert.len, NGX_ESCAPE_URI_COMPONENT);

    s->len = cert.len + n * 2;
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    ngx_escape_uri(s->data, cert.data, cert.len, NGX_ESCAPE_URI_COMPONENT);

    return NGX_OK;
}",4627.0,4654.0,1.0,1.0,28.0,22,8,27,9,0,16,4,4,3,4,,0,15,6,3,3,ngx_int_t
776,63457,ngx_encode_base64,1,ngx_encode_base64,"void ngx_encode_base64 (ngx_str_t*,ngx_str_t*)",core\ngx_string.c,"void
ngx_encode_base64(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] =
            ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    ngx_encode_base64_internal(dst, src, basis64, 1);
}",1137.0,1144.0,1.0,1.0,8.0,1,1,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
777,34788,ngx_palloc,1,ngx_palloc,"void* ngx_palloc (ngx_pool_t*,size_t)",core\ngx_palloc.c,"void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 1);
    }
#endif

    return ngx_palloc_large(pool, size);
}",122.0,132.0,1.0,1.0,11.0,2,2,6,2,44,1,2,2,0,1,,0,0,4,2,2,void*
778,63472,ngx_encode_base64url,1,ngx_encode_base64url,"void ngx_encode_base64url (ngx_str_t*,ngx_str_t*)",core\ngx_string.c,"void
ngx_encode_base64url(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] =
            ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"";

    ngx_encode_base64_internal(dst, src, basis64, 0);
}",1147.0,1154.0,1.0,1.0,8.0,1,1,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
779,10230,ngx_reusable_connection,1,ngx_reusable_connection,"void ngx_reusable_connection (ngx_connection_t*,ngx_uint_t)",core\ngx_connection.c,"void
ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable)
{
    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,
                   ""reusable connection: %ui"", reusable);

    if (c->reusable) {
        ngx_queue_remove(&c->queue);
        ngx_cycle->reusable_connections_n--;

#if (NGX_STAT_STUB)
        (void) ngx_atomic_fetch_add(ngx_stat_waiting, -1);
#endif
    }

    c->reusable = reusable;

    if (reusable) {
        /* need cast as ngx_cycle is volatile */

        ngx_queue_insert_head(
            (ngx_queue_t *) &ngx_cycle->reusable_connections_queue, &c->queue);
        ngx_cycle->reusable_connections_n++;

#if (NGX_STAT_STUB)
        (void) ngx_atomic_fetch_add(ngx_stat_waiting, 1);
#endif
    }
}",1262.0,1290.0,1.0,1.0,29.0,15,6,12,4,1,0,3,3,0,0,,0,0,4,2,2,void
780,302441,op,3,ngx_http_script_file_code_t.op,,http\ngx_http_script.h,op,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
781,34810,ngx_pnalloc,1,ngx_pnalloc,"void* ngx_pnalloc (ngx_pool_t*,size_t)",core\ngx_palloc.c,"void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 0);
    }
#endif

    return ngx_palloc_large(pool, size);
}",135.0,145.0,1.0,1.0,11.0,2,2,6,2,62,1,2,2,0,1,,0,0,4,2,2,void*
782,448514,ngx_stream_script_copy_len_code,1,ngx_stream_script_copy_len_code,size_t ngx_stream_script_copy_len_code (ngx_stream_script_engine_t*),stream\ngx_stream_script.c,"size_t
ngx_stream_script_copy_len_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_script_copy_code_t  *code;

    code = (ngx_stream_script_copy_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_copy_code_t);

    return code->len;
}",678.0,688.0,1.0,1.0,11.0,7,5,5,3,0,3,1,1,0,0,,0,3,2,1,1,size_t
783,305159,ngx_http_upstream_create,1,ngx_http_upstream_create,ngx_int_t ngx_http_upstream_create (ngx_http_request_t*),http\ngx_http_upstream.c,"ngx_int_t
ngx_http_upstream_create(ngx_http_request_t *r)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;

    if (u && u->cleanup) {
        r->main->count++;
        ngx_http_upstream_cleanup(r);
    }

    u = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_t));
    if (u == NULL) {
        return NGX_ERROR;
    }

    r->upstream = u;

    u->peer.log = r->connection->log;
    u->peer.log_error = NGX_ERROR_ERR;

#if (NGX_HTTP_CACHE)
    r->cache = NULL;
#endif

    u->headers_in.content_length_n = -1;
    u->headers_in.last_modified_time = -1;

    return NGX_OK;
}",479.0,509.0,1.0,1.0,31.0,29,8,21,7,6,2,3,3,0,2,,0,1,2,1,1,ngx_int_t
784,460812,ngx_stream_upstream_init_round_robin_peer,1,ngx_stream_upstream_init_round_robin_peer,"ngx_int_t ngx_stream_upstream_init_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)",stream\ngx_stream_upstream_round_robin.c,"ngx_int_t
ngx_stream_upstream_init_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_uint_t                           n;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    rrp = s->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(s->connection->pool,
                         sizeof(ngx_stream_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        s->upstream->peer.data = rrp;
    }

    rrp->peers = us->peer.data;
    rrp->current = NULL;
    rrp->config = 0;

    n = rrp->peers->number;

    if (rrp->peers->next && rrp->peers->next->number > n) {
        n = rrp->peers->next->number;
    }

    if (n <= 8 * sizeof(uintptr_t)) {
        rrp->tried = &rrp->data;
        rrp->data = 0;

    } else {
        n = (n + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t));

        rrp->tried = ngx_pcalloc(s->connection->pool, n * sizeof(uintptr_t));
        if (rrp->tried == N...",249.0,303.0,1.0,30.0,55.0,71,12,39,10,0,15,5,6,2,1,,0,15,4,2,2,ngx_int_t
785,14353,ngx_create_pidfile,1,ngx_create_pidfile,"ngx_int_t ngx_create_pidfile (ngx_str_t*,ngx_log_t*)",core\ngx_cycle.c,"ngx_int_t
ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)
{
    size_t      len;
    ngx_uint_t  create;
    ngx_file_t  file;
    u_char      pid[NGX_INT64_LEN + 2];

    if (ngx_process > NGX_PROCESS_MASTER) {
        return NGX_OK;
    }

    ngx_memzero(&file, sizeof(ngx_file_t));

    file.name = *name;
    file.log = log;

    create = ngx_test_config ? NGX_FILE_CREATE_OR_OPEN : NGX_FILE_TRUNCATE;

    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDWR,
                            create, NGX_FILE_DEFAULT_ACCESS);

    if (file.fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file.name.data);
        return NGX_ERROR;
    }

    if (!ngx_test_config) {
        len = ngx_snprintf(pid, NGX_INT64_LEN + 2, ""%P%N"", ngx_pid) - pid;

        if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) ...",1007.0,1049.0,1.0,1.0,43.0,24,11,35,20,2,5,6,7,2,3,,0,5,4,2,2,ngx_int_t
786,302446,loc_conf,3,ngx_http_script_if_code_t.loc_conf,,http\ngx_http_script.h,**loc_conf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
787,260118,ngx_http_core_run_phases,1,ngx_http_core_run_phases,void ngx_http_core_run_phases (ngx_http_request_t*),http\ngx_http_core_module.c,"void
ngx_http_core_run_phases(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_phase_handler_t   *ph;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    ph = cmcf->phase_engine.handlers;

    while (ph[r->phase_handler].checker) {

        rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);

        if (rc == NGX_OK) {
            return;
        }
    }
}",855.0,874.0,1.0,1.0,20.0,15,6,15,6,1,2,3,4,0,0,,0,2,2,1,1,void
788,264215,ngx_http_cleanup_add,1,ngx_http_cleanup_add,"ngx_http_cleanup_t ngx_http_cleanup_add (ngx_http_request_t*,size_t)",http\ngx_http_core_module.c,"ngx_http_cleanup_t *
ngx_http_cleanup_add(ngx_http_request_t *r, size_t size)
{
    ngx_http_cleanup_t  *cln;

    r = r->main;

    cln = ngx_palloc(r->pool, sizeof(ngx_http_cleanup_t));
    if (cln == NULL) {
        return NULL;
    }

    if (size) {
        cln->data = ngx_palloc(r->pool, size);
        if (cln->data == NULL) {
            return NULL;
        }

    } else {
        cln->data = NULL;
    }

    cln->handler = NULL;
    cln->next = r->cleanup;

    r->cleanup = cln;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http cleanup add: %p"", cln);

    return cln;
}",2612.0,2643.0,1.0,1.0,32.0,20,4,25,6,1,2,4,5,0,2,,0,2,4,2,2,ngx_http_cleanup_t
789,448537,ngx_stream_script_copy_code,1,ngx_stream_script_copy_code,void ngx_stream_script_copy_code (ngx_stream_script_engine_t*),stream\ngx_stream_script.c,"void
ngx_stream_script_copy_code(ngx_stream_script_engine_t *e)
{
    u_char                         *p;
    ngx_stream_script_copy_code_t  *code;

    code = (ngx_stream_script_copy_code_t *) e->ip;

    p = e->pos;

    if (!e->skip) {
        e->pos = ngx_copy(p, e->ip + sizeof(ngx_stream_script_copy_code_t),
                          code->len);
    }

    e->ip += sizeof(ngx_stream_script_copy_code_t)
          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));

    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, e->session->connection->log, 0,
                   ""stream script copy: \""%*s\"""", e->pos - p, p);
}",691.0,711.0,1.0,1.0,21.0,30,10,20,6,0,10,2,2,1,0,,0,10,2,1,1,void
790,116764,ngx_http_fastcgi_module,2,http\modules\ngx_http_fastcgi_module.c.ngx_http_fastcgi_module,,http\modules\ngx_http_fastcgi_module.c,ngx_module_t ngx_http_fastcgi_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
791,302450,lengths,3,ngx_http_script_complex_value_code_t.lengths,,http\ngx_http_script.h,*lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
792,92214,ngx_ssl_get_subject_dn,1,ngx_ssl_get_subject_dn,"ngx_int_t ngx_ssl_get_subject_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO        *bio;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_subject_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {
        goto failed;
    }

    s->len = BIO_pending(bio);
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, s->len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",4657.0,4706.0,1.0,1.0,50.0,20,4,36,10,0,8,8,6,1,1,,0,8,6,3,3,ngx_int_t
793,190530,ngx_http_proxy_handler,1,ngx_http_proxy_handler,ngx_int_t ngx_http_proxy_handler (ngx_http_request_t*),http\modules\ngx_http_proxy_module.c,"static ngx_int_t
ngx_http_proxy_handler(ngx_http_request_t *r)
{
    ngx_int_t                    rc;
    ngx_http_upstream_t         *u;
    ngx_http_proxy_ctx_t        *ctx;
    ngx_http_proxy_loc_conf_t   *plcf;
#if (NGX_HTTP_CACHE)
    ngx_http_proxy_main_conf_t  *pmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_ctx_t));
    if (ctx == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_proxy_module);

    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);

    u = r->upstream;

    if (plcf->proxy_lengths == NULL) {
        ctx->vars = plcf->vars;
        u->schema = plcf->vars.schema;
#if (NGX_HTTP_SSL)
        u->ssl = (plcf->upstream.ssl != NULL);
#endif

    } else {
        if (ngx_http_proxy_eval(r, ctx, plcf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    ...",848.0,944.0,1.0,1.0,97.0,89,12,80,26,0,21,9,9,9,4,,0,21,2,1,1,ngx_int_t
794,302456,text_data,3,ngx_http_script_value_code_t.text_data,,http\ngx_http_script.h,text_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
795,38984,root,3,ngx_radix_tree_t.root,,core\ngx_radix_tree.h,*root,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
796,38985,pool,3,ngx_radix_tree_t.pool,,core\ngx_radix_tree.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
797,38986,free,3,ngx_radix_tree_t.free,,core\ngx_radix_tree.h,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
798,18507,name,3,ngx_path_t.name,,core\ngx_file.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
799,18508,len,3,ngx_path_t.len,,core\ngx_file.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
800,18509,level,3,ngx_path_t.level,,core\ngx_file.h,level[NGX_MAX_PATH_LEVEL],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
801,96331,ngx_event_pipe_copy_input_filter,1,ngx_event_pipe_copy_input_filter,"ngx_int_t ngx_event_pipe_copy_input_filter (ngx_event_pipe_t*,ngx_buf_t*)",event\ngx_event_pipe.c,"ngx_int_t
ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)
{
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    if (buf->pos == buf->last) {
        return NGX_OK;
    }

    cl = ngx_chain_get_free_buf(p->pool, &p->free);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    b = cl->buf;

    ngx_memcpy(b, buf, sizeof(ngx_buf_t));
    b->shadow = buf;
    b->tag = p->tag;
    b->last_shadow = 1;
    b->recycled = 1;
    buf->shadow = b;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0, ""input buf #%d"", b->num);

    if (p->in) {
        *p->last_in = cl;
    } else {
        p->in = cl;
    }
    p->last_in = &cl->next;

    if (p->length == -1) {
        return NGX_OK;
    }

    p->length -= b->last - b->pos;

    return NGX_OK;
}",953.0,993.0,1.0,1.0,41.0,40,9,36,9,0,1,5,5,0,1,,0,1,4,2,2,ngx_int_t
802,301132,ngx_http_script_return_code,1,ngx_http_script_return_code,void ngx_http_script_return_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_return_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_return_code_t  *code;

    code = (ngx_http_script_return_code_t *) e->ip;

    if (code->status < NGX_HTTP_BAD_REQUEST
        || code->text.value.len
        || code->text.lengths)
    {
        e->status = ngx_http_send_response(e->request, code->status, NULL,
                                           &code->text);
    } else {
        e->status = code->status;
    }

    e->ip = ngx_http_script_exit;
}",1449.0,1467.0,1.0,12.0,19.0,22,7,13,5,0,11,2,2,3,1,,0,11,2,1,1,void
803,38987,start,3,ngx_radix_tree_t.start,,core\ngx_radix_tree.h,*start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
804,18513,data,3,ngx_path_t.data,,core\ngx_file.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
805,18514,conf_file,3,ngx_path_t.conf_file,,core\ngx_file.h,*conf_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
806,18515,line,3,ngx_path_t.line,,core\ngx_file.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
807,38988,size,3,ngx_radix_tree_t.size,,core\ngx_radix_tree.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
808,399443,ngx_os_specific_status,1,ngx_os_specific_status,void ngx_os_specific_status (ngx_log_t*),os\unix\ngx_solaris_init.c,"void
ngx_os_specific_status(ngx_log_t *log)
{

    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""OS: %s %s"",
                  ngx_solaris_sysname, ngx_solaris_release);

    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""version: %s"",
                  ngx_solaris_version);
}",68.0,77.0,1.0,1.0,10.0,17,7,21,8,0,10,5,8,4,2,,0,8,2,1,1,void
809,305241,ngx_http_upstream_init,1,ngx_http_upstream_init,void ngx_http_upstream_init (ngx_http_request_t*),http\ngx_http_upstream.c,"void
ngx_http_upstream_init(ngx_http_request_t *r)
{
    ngx_connection_t     *c;

    c = r->connection;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http init upstream, client timer: %d"", c->read->timer_set);

#if (NGX_HTTP_V2)
    if (r->stream) {
        ngx_http_upstream_init_request(r);
        return;
    }
#endif

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        if (!c->write->active) {
            if (ngx_add_event(c->write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT)
                == NGX_ERROR)
            {
                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                return;
            }
        }
    }

    ngx_http_upstream_init_request(r);
}",512.0,546.0,1.0,1.0,35.0,14,5,17,9,1,2,5,8,0,2,,0,0,2,1,1,void
810,18526,name,3,ngx_path_init_t.name,,core\ngx_file.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
811,18527,level,3,ngx_path_init_t.level,,core\ngx_file.h,level[NGX_MAX_PATH_LEVEL],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
812,18538,file,3,ngx_temp_file_t.file,,core\ngx_file.h,file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
813,264299,ngx_http_set_disable_symlinks,1,ngx_http_set_disable_symlinks,"ngx_int_t ngx_http_set_disable_symlinks (ngx_http_request_t*,ngx_http_core_loc_conf_t*,ngx_str_t*,ngx_open_file_info_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_set_disable_symlinks(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of)
{
#if (NGX_HAVE_OPENAT)
    u_char     *p;
    ngx_str_t   from;

    of->disable_symlinks = clcf->disable_symlinks;

    if (clcf->disable_symlinks_from == NULL) {
        return NGX_OK;
    }

    if (ngx_http_complex_value(r, clcf->disable_symlinks_from, &from)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (from.len == 0
        || from.len > path->len
        || ngx_memcmp(path->data, from.data, from.len) != 0)
    {
        return NGX_OK;
    }

    if (from.len == path->len) {
        of->disable_symlinks = NGX_DISABLE_SYMLINKS_OFF;
        return NGX_OK;
    }

    p = path->data + from.len;

    if (*p == '/') {
        of->disable_symlinks_from = from.len;
        return NGX_OK;
    }

    p--;

    if (*p == '/') {
        of->disable_symlinks_from = from.len - 1;
    }
#endif

    return NGX_OK;
}",2646.0,2693.0,1.0,1.0,48.0,0,0,1,1,3,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
814,18540,path,3,ngx_temp_file_t.path,,core\ngx_file.h,*path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
815,18539,offset,3,ngx_temp_file_t.offset,,core\ngx_file.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
816,18542,warn,3,ngx_temp_file_t.warn,,core\ngx_file.h,*warn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
817,18541,pool,3,ngx_temp_file_t.pool,,core\ngx_file.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
818,18544,log_level,3,ngx_temp_file_t.log_level,,core\ngx_file.h,log_level:8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
819,18543,access,3,ngx_temp_file_t.access,,core\ngx_file.h,access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
820,18546,clean,3,ngx_temp_file_t.clean,,core\ngx_file.h,clean:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
821,18545,persistent,3,ngx_temp_file_t.persistent,,core\ngx_file.h,persistent:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
822,276587,ngx_http_file_cache_loader,1,ngx_http_file_cache_loader,void ngx_http_file_cache_loader (void*),http\ngx_http_file_cache.c,"static void
ngx_http_file_cache_loader(void *data)
{
    ngx_http_file_cache_t  *cache = data;

    ngx_tree_ctx_t  tree;

    if (!cache->sh->cold || cache->sh->loading) {
        return;
    }

    if (!ngx_atomic_cmp_set(&cache->sh->loading, 0, ngx_pid)) {
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache loader"");

    tree.init_handler = NULL;
    tree.file_handler = ngx_http_file_cache_manage_file;
    tree.pre_tree_handler = ngx_http_file_cache_manage_directory;
    tree.post_tree_handler = ngx_http_file_cache_noop;
    tree.spec_handler = ngx_http_file_cache_delete_file;
    tree.data = cache;
    tree.alloc = 0;
    tree.log = ngx_cycle->log;

    cache->last = ngx_current_msec;
    cache->files = 0;

    if (ngx_walk_tree(&tree, &cache->path->name) == NGX_ABORT) {
        cache->sh->loading = 0;
        return;
    }

    cache->sh->cold = 0;
    cache->sh->loading = 0;

    ngx_log_error(NGX_LOG_NOTICE, ng...",2032.0,2075.0,1.0,1.0,44.0,59,10,38,14,0,3,4,4,2,3,,0,2,2,1,1,void
823,264309,ngx_http_get_forwarded_addr,1,ngx_http_get_forwarded_addr,"ngx_int_t ngx_http_get_forwarded_addr (ngx_http_request_t*,ngx_addr_t*,ngx_array_t*,ngx_str_t*,ngx_array_t*,int)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,
    int recursive)
{
    ngx_int_t          rc;
    ngx_uint_t         i, found;
    ngx_table_elt_t  **h;

    if (headers == NULL) {
        return ngx_http_get_forwarded_addr_internal(r, addr, value->data,
                                                    value->len, proxies,
                                                    recursive);
    }

    i = headers->nelts;
    h = headers->elts;

    rc = NGX_DECLINED;

    found = 0;

    while (i-- > 0) {
        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,
                                                  h[i]->value.len, proxies,
                                                  recursive);

        if (!recursive) {
            break;
        }

        if (rc == NGX_DECLINED && found) {
            rc = NGX_DONE;
            break;
        }

        if (rc !=...",2696.0,2740.0,1.0,1.0,45.0,24,10,35,14,1,6,9,9,0,2,,0,5,12,6,6,ngx_int_t
824,18550,access,3,ngx_ext_rename_file_t.access,,core\ngx_file.h,access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
825,18551,path_access,3,ngx_ext_rename_file_t.path_access,,core\ngx_file.h,path_access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
826,18552,time,3,ngx_ext_rename_file_t.time,,core\ngx_file.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
827,18553,fd,3,ngx_ext_rename_file_t.fd,,core\ngx_file.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
828,18554,create_path,3,ngx_ext_rename_file_t.create_path,,core\ngx_file.h,create_path:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
829,18555,delete_file,3,ngx_ext_rename_file_t.delete_file,,core\ngx_file.h,delete_file:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
830,18556,log,3,ngx_ext_rename_file_t.log,,core\ngx_file.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
831,67703,ngx_thread_task_alloc,1,ngx_thread_task_alloc,"ngx_thread_task_t ngx_thread_task_alloc (ngx_pool_t*,size_t)",core\ngx_thread_pool.c,"ngx_thread_task_t *
ngx_thread_task_alloc(ngx_pool_t *pool, size_t size)
{
    ngx_thread_task_t  *task;

    task = ngx_pcalloc(pool, sizeof(ngx_thread_task_t) + size);
    if (task == NULL) {
        return NULL;
    }

    task->ctx = task + 1;

    return task;
}",214.0,227.0,1.0,1.0,14.0,7,5,10,5,0,1,2,2,0,1,,0,1,4,2,2,ngx_thread_task_t
832,14453,ngx_delete_pidfile,1,ngx_delete_pidfile,void ngx_delete_pidfile (ngx_cycle_t*),core\ngx_cycle.c,"void
ngx_delete_pidfile(ngx_cycle_t *cycle)
{
    u_char           *name;
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    name = ngx_new_binary ? ccf->oldpid.data : ccf->pid.data;

    if (ngx_delete_file(name) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", name);
    }
}",1052.0,1066.0,1.0,1.0,15.0,10,6,9,6,0,2,2,2,0,0,,0,2,2,1,1,void
833,18559,size,3,ngx_copy_file_t.size,,core\ngx_file.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
834,18560,buf_size,3,ngx_copy_file_t.buf_size,,core\ngx_file.h,buf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
835,18561,access,3,ngx_copy_file_t.access,,core\ngx_file.h,access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
836,18562,time,3,ngx_copy_file_t.time,,core\ngx_file.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
837,84099,connect_lock,2,event\ngx_event_connectex.c.connect_lock,,event\ngx_event_connectex.c,CRITICAL_SECTION connect_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
838,116868,ngx_http_fastcgi_handler,1,ngx_http_fastcgi_handler,ngx_int_t ngx_http_fastcgi_handler (ngx_http_request_t*),http\modules\ngx_http_fastcgi_module.c,"static ngx_int_t
ngx_http_fastcgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                      rc;
    ngx_http_upstream_t           *u;
    ngx_http_fastcgi_ctx_t        *f;
    ngx_http_fastcgi_loc_conf_t   *flcf;
#if (NGX_HTTP_CACHE)
    ngx_http_fastcgi_main_conf_t  *fmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    f = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t));
    if (f == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, f, ngx_http_fastcgi_module);

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    if (flcf->fastcgi_lengths) {
        if (ngx_http_fastcgi_eval(r, flcf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""fastcgi://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_fastcgi_module;

    u->conf = &flcf->upstream;

#if (NGX_HTTP_CACHE)
  ...",677.0,755.0,1.0,1.0,79.0,64,11,67,23,0,14,8,9,5,5,,0,14,2,1,1,ngx_int_t
839,84100,nconnects,2,event\ngx_event_connectex.c.nconnects,,event\ngx_event_connectex.c,static int nconnects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
840,84101,pending_connects,2,event\ngx_event_connectex.c.pending_connects,,event\ngx_event_connectex.c,static ngx_connection_t[10] pending_connects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
841,18563,log,3,ngx_copy_file_t.log,,core\ngx_file.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
842,84106,pending_connect_event,2,event\ngx_event_connectex.c.pending_connect_event,,event\ngx_event_connectex.c,HANDLE pending_connect_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
843,84107,nevents,2,event\ngx_event_connectex.c.nevents,,event\ngx_event_connectex.c,int nevents,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
844,260237,ngx_http_core_rewrite_phase,1,ngx_http_core_rewrite_phase,"ngx_int_t ngx_http_core_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""rewrite phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_DONE) {
        return NGX_OK;
    }

    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc);

    return NGX_OK;
}",914.0,938.0,1.0,1.0,25.0,9,4,16,8,0,1,3,3,0,1,,0,0,4,2,2,ngx_int_t
845,84111,events,2,event\ngx_event_connectex.c.events,,event\ngx_event_connectex.c,WSAEVENT[] events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
846,301201,ngx_http_script_break_code,1,ngx_http_script_break_code,void ngx_http_script_break_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_break_code(ngx_http_script_engine_t *e)
{
    ngx_http_request_t  *r;

    r = e->request;

    if (r->uri_changed) {
        r->valid_location = 0;
        r->uri_changed = 0;
    }

    e->ip = ngx_http_script_exit;
}",1470.0,1483.0,1.0,12.0,14.0,11,4,7,3,0,3,2,2,0,0,,0,3,2,1,1,void
847,84116,conn,2,event\ngx_event_connectex.c.conn,,event\ngx_event_connectex.c,ngx_connection_t ** [] conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
848,67734,ngx_thread_task_post,1,ngx_thread_task_post,"ngx_int_t ngx_thread_task_post (ngx_thread_pool_t*,ngx_thread_task_t*)",core\ngx_thread_pool.c,"ngx_int_t
ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task)
{
    if (task->event.active) {
        ngx_log_error(NGX_LOG_ALERT, tp->log, 0,
                      ""task #%ui already active"", task->id);
        return NGX_ERROR;
    }

    if (ngx_thread_mutex_lock(&tp->mtx, tp->log) != NGX_OK) {
        return NGX_ERROR;
    }

    if (tp->waiting >= tp->max_queue) {
        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);

        ngx_log_error(NGX_LOG_ERR, tp->log, 0,
                      ""thread pool \""%V\"" queue overflow: %i tasks waiting"",
                      &tp->name, tp->waiting);
        return NGX_ERROR;
    }

    task->event.active = 1;

    task->id = ngx_thread_pool_task_id++;
    task->next = NULL;

    if (ngx_thread_cond_signal(&tp->cond, tp->log) != NGX_OK) {
        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
        return NGX_ERROR;
    }

    *tp->queue.last = task;
    tp->queue.last = &task->next;

    tp->waiting++;

    (void)...",230.0,274.0,1.0,1.0,45.0,54,9,41,9,0,8,5,5,2,7,,0,3,4,2,2,ngx_int_t
849,326896,ngx_http_map_find,1,ngx_http_map_find,"void* ngx_http_map_find (ngx_http_request_t*,ngx_http_map_t*,ngx_str_t*)",http\ngx_http_variables.c,"void *
ngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)
{
    void        *value;
    u_char      *low;
    size_t       len;
    ngx_uint_t   key;

    len = match->len;

    if (len) {
        low = ngx_pnalloc(r->pool, len);
        if (low == NULL) {
            return NULL;
        }

    } else {
        low = NULL;
    }

    key = ngx_hash_strlow(low, match->data, len);

    value = ngx_hash_find_combined(&map->hash, key, low, len);
    if (value) {
        return value;
    }

#if (NGX_PCRE)

    if (len && map->nregex) {
        ngx_int_t              n;
        ngx_uint_t             i;
        ngx_http_map_regex_t  *reg;

        reg = map->regex;

        for (i = 0; i < map->nregex; i++) {

            n = ngx_http_regex_exec(r, reg[i].regex, match);

            if (n == NGX_OK) {
                return reg[i].value;
            }

            if (n == NGX_DECLINED) {
                continue;
            }

            /* NGX_ERROR */

...",2375.0,2432.0,1.0,1.0,58.0,10,4,21,8,1,6,4,5,0,3,,0,6,6,3,3,void*
850,84121,ngx_iocp_wait_connect,1,ngx_iocp_wait_connect,int ngx_iocp_wait_connect (ngx_connection_t*),event\ngx_event_connectex.c,"int ngx_iocp_wait_connect(ngx_connection_t *c)
{
    for ( ;; ) {
        EnterCriticalSection(&connect_lock);

        if (nconnects < NGX_MAX_PENDING_CONN) {
            pending_connects[--nconnects] = c;
            LeaveCriticalSection(&connect_lock);

            if (SetEvent(pending_connect_event) == 0) {
                ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                              ""SetEvent() failed"");
                return NGX_ERROR;

            break;
        }

        LeaveCriticalSection(&connect_lock);
        ngx_log_error(NGX_LOG_NOTICE, c->log, 0,
                      ""max number of pending connect()s is %d"",
                      NGX_MAX_PENDING_CONN);
        msleep(100);
    }

    if (!started) {
        if (ngx_iocp_new_thread(1) == NGX_ERROR) {
            return NGX_ERROR;
        }
        started = 1;
    }

    return NGX_OK;
}


int ngx_iocp_new_thread(int main)
{
    u_int  id;

    if (main) {
        pending_connect_event = CreateEven...",28.0,118.0,1.0,24.0,91.0,38,10,70,21,0,29,7,12,2,7,,0,22,2,1,1,int
851,14490,ngx_signal_process,1,ngx_signal_process,"ngx_int_t ngx_signal_process (ngx_cycle_t*,char*)",core\ngx_cycle.c,"ngx_int_t
ngx_signal_process(ngx_cycle_t *cycle, char *sig)
{
    ssize_t           n;
    ngx_pid_t         pid;
    ngx_file_t        file;
    ngx_core_conf_t  *ccf;
    u_char            buf[NGX_INT64_LEN + 2];

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""signal process started"");

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    ngx_memzero(&file, sizeof(ngx_file_t));

    file.name = ccf->pid;
    file.log = cycle->log;

    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY,
                            NGX_FILE_OPEN, NGX_FILE_DEFAULT_ACCESS);

    if (file.fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file.name.data);
        return 1;
    }

    n = ngx_read_file(&file, buf, NGX_INT64_LEN + 2, 0);

    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ngx_clo...",1069.0,1120.0,1.0,1.0,52.0,38,13,46,20,1,7,6,6,0,6,,0,4,4,2,2,ngx_int_t
852,92324,ngx_ssl_get_issuer_dn,1,ngx_ssl_get_issuer_dn,"ngx_int_t ngx_ssl_get_issuer_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO        *bio;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_issuer_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {
        goto failed;
    }

    s->len = BIO_pending(bio);
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, s->len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",4709.0,4758.0,1.0,1.0,50.0,20,4,36,10,0,8,8,6,1,1,,0,8,6,3,3,ngx_int_t
853,4511,ngx_conf_param,1,ngx_conf_param,char* ngx_conf_param (ngx_conf_t*),core\ngx_conf_file.c,"char *
ngx_conf_param(ngx_conf_t *cf)
{
    char             *rv;
    ngx_str_t        *param;
    ngx_buf_t         b;
    ngx_conf_file_t   conf_file;

    param = &cf->cycle->conf_param;

    if (param->len == 0) {
        return NGX_CONF_OK;
    }

    ngx_memzero(&conf_file, sizeof(ngx_conf_file_t));

    ngx_memzero(&b, sizeof(ngx_buf_t));

    b.start = param->data;
    b.pos = param->data;
    b.last = param->data + param->len;
    b.end = b.last;
    b.temporary = 1;

    conf_file.file.fd = NGX_INVALID_FILE;
    conf_file.file.name.data = NULL;
    conf_file.line = 0;

    cf->conf_file = &conf_file;
    cf->conf_file->buffer = &b;

    rv = ngx_conf_parse(cf, NULL);

    cf->conf_file = NULL;

    return rv;
}",62.0,98.0,1.0,1.0,37.0,45,7,33,10,1,9,2,2,1,1,,0,9,2,1,1,char*
854,383151,ngx_mail_imap_login,1,ngx_mail_imap_login,"ngx_int_t ngx_mail_imap_login (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_imap_handler.c,"static ngx_int_t
ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    arg = s->args.elts;

    if (s->args.nelts != 2 || arg[0].len == 0) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    s->passwd.len = arg[1].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""imap login:\""%V\"" passwd:\""%V\"""",
                   &s->login, &s->passwd);
#else
    ngx_log_debug1(NGX_LOG_DEBUG_...",300.0,343.0,1.0,1.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
855,10416,ngx_connection_local_sockaddr,1,ngx_connection_local_sockaddr,"ngx_int_t ngx_connection_local_sockaddr (ngx_connection_t*,ngx_str_t*,ngx_uint_t)",core\ngx_connection.c,"ngx_int_t
ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,
    ngx_uint_t port)
{
    socklen_t             len;
    ngx_uint_t            addr;
    ngx_sockaddr_t        sa;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    ngx_uint_t            i;
    struct sockaddr_in6  *sin6;
#endif

    addr = 0;

    if (c->local_socklen) {
        switch (c->local_sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;

            for (i = 0; addr == 0 && i < 16; i++) {
                addr |= sin6->sin6_addr.s6_addr[i];
            }

            break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
        case AF_UNIX:
            addr = 1;
            break;
#endif

        default: /* AF_INET */
            sin = (struct sockaddr_in *) c->local_sockaddr;
            addr = sin->sin_addr.s_addr;
            break;
        }
    }

    if (addr == 0) {

        len = sizeof(ngx_sockaddr_t);

        if (g...",1339.0,1408.0,1.0,1.0,70.0,35,8,37,12,1,6,8,10,0,3,,0,5,6,3,3,ngx_int_t
856,301237,ngx_http_script_if_code,1,ngx_http_script_if_code,void ngx_http_script_if_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_if_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_if_code_t  *code;

    code = (ngx_http_script_if_code_t *) e->ip;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script if"");

    e->sp--;

    if (e->sp->len && (e->sp->len != 1 || e->sp->data[0] != '0')) {
        if (code->loc_conf) {
            e->request->loc_conf = code->loc_conf;
            ngx_http_update_location_config(e->request);
        }

        e->ip += sizeof(ngx_http_script_if_code_t);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script if: false"");

    e->ip += code->next;
}",1486.0,1512.0,1.0,1.0,27.0,34,10,18,4,0,15,3,4,4,1,,0,14,2,1,1,void
857,383157,ngx_mail_imap_authenticate,1,ngx_mail_imap_authenticate,"ngx_int_t ngx_mail_imap_authenticate (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_imap_handler.c,"static ngx_int_t
ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_imap_srv_conf_t  *iscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, imap_username);
        s->mail_state = ngx_imap_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, imap_password);
        s->mail_state = ngx_imap_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, imap_plain_next);
        s->mail_state = ngx_imap_auth_plain;

        return NGX_OK;

    case NGX_MAIL_AUTH_CRAM_MD5:

        if (!(iscf->au...",346.0,420.0,1.0,1.0,75.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
858,383163,ngx_mail_imap_capability,1,ngx_mail_imap_capability,"ngx_int_t ngx_mail_imap_capability (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_imap_handler.c,"static ngx_int_t
ngx_mail_imap_capability(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_imap_srv_conf_t  *iscf;

    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

#if (NGX_MAIL_SSL)

    if (c->ssl == NULL) {
        ngx_mail_ssl_conf_t  *sslcf;

        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {
            s->text = iscf->starttls_capability;
            return NGX_OK;
        }

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {
            s->text = iscf->starttls_only_capability;
            return NGX_OK;
        }
    }
#endif

    s->text = iscf->capability;

    return NGX_OK;
}",423.0,452.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
859,260286,ngx_http_core_find_config_phase,1,ngx_http_core_find_config_phase,"ngx_int_t ngx_http_core_find_config_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_find_config_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    u_char                    *p;
    size_t                     len;
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    r->content_handler = NULL;
    r->uri_changed = 0;

    rc = ngx_http_core_find_location(r);

    if (rc == NGX_ERROR) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!r->internal && clcf->internal) {
        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""using configuration \""%s%V\"""",
                   (clcf->noname ? ""*"" : (clcf->exact_match ? ""="" : """")),
                   &clcf->name);

    ngx_http_update_location_config(r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
       ...",941.0,1032.0,1.0,1.0,92.0,73,13,61,15,0,11,7,9,0,10,,0,3,4,2,2,ngx_int_t
860,63679,ngx_decode_base64,1,ngx_decode_base64,"ngx_int_t ngx_decode_base64 (ngx_str_t*,ngx_str_t*)",core\ngx_string.c,"ngx_int_t
ngx_decode_base64(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] = {
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77, 77, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,
        77,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 77,
        77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,

        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, ...",1201.0,1225.0,1.0,1.0,25.0,2,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,ngx_int_t
861,383169,ngx_mail_imap_starttls,1,ngx_mail_imap_starttls,"ngx_int_t ngx_mail_imap_starttls (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_imap_handler.c,"static ngx_int_t
ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {
            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",455.0,472.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
862,104643,ngx_http_autoindex_cmp_entries,1,ngx_http_autoindex_cmp_entries,"ANY ngx_http_autoindex_cmp_entries (void*,void*)",http\modules\ngx_http_autoindex_module.c,"ngx_http_autoindex_cmp_entries(const void *one, const void *two)
{
    ngx_http_autoindex_entry_t *first = (ngx_http_autoindex_entry_t *) one;
    ngx_http_autoindex_entry_t *second = (ngx_http_autoindex_entry_t *) two;

    if (first->dir && !second->dir) {
        /* move the directories to the start */
        return -1;
    }

    if (!first->dir && second->dir) {
        /* move the directories to the start */
        return 1;
    }

    return (int) ngx_strcmp(first->name.data, second->name.data);
}",952.0,968.0,1.0,1.0,17.0,18,7,10,4,0,6,3,3,4,0,,0,6,4,2,2,ANY
863,59591,ngx_slab_calloc,1,ngx_slab_calloc,"void* ngx_slab_calloc (ngx_slab_pool_t*,size_t)",core\ngx_slab.c,"void *
ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_calloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}",420.0,432.0,1.0,1.0,13.0,5,3,6,3,0,5,1,1,0,3,,0,3,4,2,2,void*
864,383176,imap_star,2,mail\ngx_mail_imap_handler.c.imap_star,,mail\ngx_mail_imap_handler.c,static u_char[] imap_star,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
865,96464,ngx_event_pipe_add_free_buf,1,ngx_event_pipe_add_free_buf,"ngx_int_t ngx_event_pipe_add_free_buf (ngx_event_pipe_t*,ngx_buf_t*)",event\ngx_event_pipe.c,"ngx_int_t
ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p, ngx_buf_t *b)
{
    ngx_chain_t  *cl;

    cl = ngx_alloc_chain_link(p->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    if (p->buf_to_file && b->start == p->buf_to_file->start) {
        b->pos = p->buf_to_file->last;
        b->last = p->buf_to_file->last;

    } else {
        b->pos = b->start;
        b->last = b->start;
    }

    b->shadow = NULL;

    cl->buf = b;

    if (p->free_raw_bufs == NULL) {
        p->free_raw_bufs = cl;
        cl->next = NULL;

        return NGX_OK;
    }

    if (p->free_raw_bufs->buf->pos == p->free_raw_bufs->buf->last) {

        /* add the free buf to the list start */

        cl->next = p->free_raw_bufs;
        p->free_raw_bufs = cl;

        return NGX_OK;
    }

    /* the first free buf is partially filled, thus add the free buf after it */

    cl->next = p->free_raw_bufs->next;
    p->free_raw_bufs->next = cl;

    return NGX_OK;
}",1027.0,1073.0,1.0,1.0,47.0,46,4,35,6,0,1,5,5,0,1,,0,1,4,2,2,ngx_int_t
866,383187,ngx_mail_imap_init_session,1,ngx_mail_imap_init_session,"void ngx_mail_imap_init_session (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_imap_handler.c,"void
ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    ngx_str_set(&s->out, imap_greeting);

    c->read->handler = ngx_mail_imap_init_protocol;

    ngx_add_timer(c->read, cscf->timeout);

    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
        ngx_mail_close_connection(c);
    }

    ngx_mail_send(c->write);
}",36.0,54.0,1.0,1.0,19.0,11,4,12,6,0,5,2,2,1,3,,0,3,4,2,2,void
867,329944,ngx_http_v2_send_output_queue,1,ngx_http_v2_send_output_queue,ngx_int_t ngx_http_v2_send_output_queue (ngx_http_v2_connection_t*),http\v2\ngx_http_v2.c,"ngx_int_t
ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c)
{
    int                        tcp_nodelay;
    ngx_chain_t               *cl;
    ngx_event_t               *wev;
    ngx_connection_t          *c;
    ngx_http_v2_out_frame_t   *out, *frame, *fn;
    ngx_http_core_loc_conf_t  *clcf;

    c = h2c->connection;
    wev = c->write;

    if (c->error) {
        goto error;
    }

    if (!wev->ready) {
        return NGX_AGAIN;
    }

    cl = NULL;
    out = NULL;

    for (frame = h2c->last_out; frame; frame = fn) {
        frame->last->next = cl;
        cl = frame->first;

        fn = frame->next;
        frame->next = out;
        out = frame;

        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
                       ""http2 frame out: %p sid:%ui bl:%d len:%uz"",
                       out, out->stream ? out->stream->node->id : 0,
                       out->blocked, out->length);
    }

    cl = c->send_chain(c, cl, 0);

    if (cl == NGX_CHAIN_ERROR) {
  ...",511.0,623.0,1.0,1.0,113.0,81,9,92,20,3,3,21,17,3,3,,0,3,2,1,1,ngx_int_t
868,448728,ngx_stream_script_copy_var_len_code,1,ngx_stream_script_copy_var_len_code,size_t ngx_stream_script_copy_var_len_code (ngx_stream_script_engine_t*),stream\ngx_stream_script.c,"size_t
ngx_stream_script_copy_var_len_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_variable_value_t   *value;
    ngx_stream_script_var_code_t  *code;

    code = (ngx_stream_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_var_code_t);

    if (e->flushed) {
        value = ngx_stream_get_indexed_variable(e->session, code->index);

    } else {
        value = ngx_stream_get_flushed_variable(e->session, code->index);
    }

    if (value && !value->not_found) {
        return value->len;
    }

    return 0;
}",760.0,782.0,1.0,1.0,23.0,14,7,11,4,0,6,3,3,1,1,,0,6,2,1,1,size_t
869,342377,ngx_http_v2_create_headers_frame,1,ngx_http_v2_create_headers_frame,"ngx_http_v2_out_frame_t* ngx_http_v2_create_headers_frame (ngx_http_request_t*,u_char*,u_char*,ngx_uint_t)",http\v2\ngx_http_v2_filter_module.c,"static ngx_http_v2_out_frame_t *
ngx_http_v2_create_headers_frame(ngx_http_request_t *r, u_char *pos,
    u_char *end, ngx_uint_t fin)
{
    u_char                    type, flags;
    size_t                    rest, frame_size;
    ngx_buf_t                *b;
    ngx_chain_t              *cl, **ll;
    ngx_http_v2_stream_t     *stream;
    ngx_http_v2_out_frame_t  *frame;

    stream = r->stream;
    rest = end - pos;

    frame = ngx_palloc(r->pool, sizeof(ngx_http_v2_out_frame_t));
    if (frame == NULL) {
        return NULL;
    }

    frame->handler = ngx_http_v2_headers_frame_handler;
    frame->stream = stream;
    frame->length = rest;
    frame->blocked = 1;
    frame->fin = fin;

    ll = &frame->first;

    type = NGX_HTTP_V2_HEADERS_FRAME;
    flags = fin ? NGX_HTTP_V2_END_STREAM_FLAG : NGX_HTTP_V2_NO_FLAG;
    frame_size = stream->connection->frame_size;

    for ( ;; ) {
        if (rest <= frame_size) {
            frame_size = rest;
            flags |= NGX_HTTP_V2_...",1078.0,1180.0,1.0,1.0,103.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_http_v2_out_frame_t
870,59615,ngx_slab_calloc_locked,1,ngx_slab_calloc_locked,"void* ngx_slab_calloc_locked (ngx_slab_pool_t*,size_t)",core\ngx_slab.c,"void *
ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    p = ngx_slab_alloc_locked(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",435.0,446.0,1.0,1.0,12.0,1,1,7,3,1,1,2,2,0,1,,0,1,4,2,2,void*
871,84194,ngx_iocp_new_thread,1,ngx_iocp_wait_connect.ngx_iocp_new_thread,int ngx_iocp_wait_connect.ngx_iocp_new_thread (int),event\ngx_event_connectex.c,"int ngx_iocp_new_thread(int main)
{
    u_int  id;

    if (main) {
        pending_connect_event = CreateEvent(NULL, 0, 1, NULL);
        if (pending_connect_event == INVALID_HANDLE_VALUE) {
            ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                          ""CreateThread() failed"");
            return NGX_ERROR;
        }
    }

    if (CreateThread(NULL, 0, ngx_iocp_wait_events, main, 0, &id)
                                                       == INVALID_HANDLE_VALUE)
    {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""CreateThread() failed"");
        return NGX_ERROR;
    }

    SetEvent(event) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""SetEvent() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",63.0,91.0,1.0,1.0,29.0,7,4,24,11,0,5,4,5,1,3,,0,2,2,1,1,int
872,461035,ngx_stream_upstream_create_round_robin_peer,1,ngx_stream_upstream_create_round_robin_peer,"ngx_int_t ngx_stream_upstream_create_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_resolved_t*)",stream\ngx_stream_upstream_round_robin.c,"ngx_int_t
ngx_stream_upstream_create_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_resolved_t *ur)
{
    u_char                              *p;
    size_t                               len;
    socklen_t                            socklen;
    ngx_uint_t                           i, n;
    struct sockaddr                     *sockaddr;
    ngx_stream_upstream_rr_peer_t       *peer, **peerp;
    ngx_stream_upstream_rr_peers_t      *peers;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    rrp = s->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(s->connection->pool,
                         sizeof(ngx_stream_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        s->upstream->peer.data = rrp;
    }

    peers = ngx_pcalloc(s->connection->pool,
                        sizeof(ngx_stream_upstream_rr_peers_t));
    if (peers == NULL) {
        return NGX_ERROR;
    }

    peer = ngx_pcalloc(s->connec...",306.0,423.0,1.0,30.0,118.0,109,11,64,12,0,20,7,8,1,3,,0,20,4,2,2,ngx_int_t
873,59635,ngx_slab_free,1,ngx_slab_free,"void ngx_slab_free (ngx_slab_pool_t*,void*)",core\ngx_slab.c,"void
ngx_slab_free(ngx_slab_pool_t *pool, void *p)
{
    ngx_shmtx_lock(&pool->mutex);

    ngx_slab_free_locked(pool, p);

    ngx_shmtx_unlock(&pool->mutex);
}",449.0,457.0,1.0,1.0,9.0,4,2,4,2,0,5,1,1,0,3,,0,2,4,2,2,void
874,383234,ngx_mail_imap_init_protocol,1,ngx_mail_imap_init_protocol,void ngx_mail_imap_init_protocol (ngx_event_t*),mail\ngx_mail_imap_handler.c,"void
ngx_mail_imap_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_imap_srv_conf_t  *iscf;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))
            == NGX_ERROR)
        {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

        s->buffer = ngx_create_temp_buf(c->pool, iscf->client_buffer_size);
        if (s->buffer == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }
    }

    s->mail_state = ngx_imap_start;
    c->read->handler = ngx_mail_imap_auth_s...",57.0,98.0,1.0,1.0,42.0,30,5,31,11,0,13,5,7,4,7,,0,8,2,1,1,void
875,59654,ngx_slab_free_locked,1,ngx_slab_free_locked,"void ngx_slab_free_locked (ngx_slab_pool_t*,void*)",core\ngx_slab.c,"void
ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
{
    size_t            size;
    uintptr_t         slab, m, *bitmap;
    ngx_uint_t        i, n, type, slot, shift, map;
    ngx_slab_page_t  *slots, *page;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0, ""slab free: %p"", p);

    if ((u_char *) p < pool->start || (u_char *) p > pool->end) {
        ngx_slab_error(pool, NGX_LOG_ALERT, ""ngx_slab_free(): outside of pool"");
        goto fail;
    }

    n = ((u_char *) p - pool->start) >> ngx_pagesize_shift;
    page = &pool->pages[n];
    slab = page->slab;
    type = ngx_slab_page_type(page);

    switch (type) {

    case NGX_SLAB_SMALL:

        shift = slab & NGX_SLAB_SHIFT_MASK;
        size = (size_t) 1 << shift;

        if ((uintptr_t) p & (size - 1)) {
            goto wrong_chunk;
        }

        n = ((uintptr_t) p & (ngx_pagesize - 1)) >> shift;
        m = (uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)));
        n /= 8 * sizeof(uintptr_t);
        bit...",460.0,674.0,1.0,11.0,215.0,231,25,198,24,1,23,39,49,2,9,,0,14,4,2,2,void
876,88330,ngx_ssl_send_chain,1,ngx_ssl_send_chain,"ngx_chain_t ngx_ssl_send_chain (ngx_connection_t*,ngx_chain_t*,off_t)",event\ngx_event_openssl.c,"ngx_chain_t *
ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int          n;
    ngx_uint_t   flush;
    ssize_t      send, size;
    ngx_buf_t   *buf;

    if (!c->ssl->buffer) {

        while (in) {
            if (ngx_buf_special(in->buf)) {
                in = in->next;
                continue;
            }

            n = ngx_ssl_write(c, in->buf->pos, in->buf->last - in->buf->pos);

            if (n == NGX_ERROR) {
                return NGX_CHAIN_ERROR;
            }

            if (n == NGX_AGAIN) {
                return in;
            }

            in->buf->pos += n;

            if (in->buf->pos == in->buf->last) {
                in = in->next;
            }
        }

        return in;
    }


    /* the maximum limit size is the maximum int32_t value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_INT32_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_INT32_VALUE - ngx_pagesize;
    }

    buf = c->ssl->buf;

  ...",2376.0,2528.0,1.0,1.0,153.0,162,13,148,16,0,4,32,54,0,4,,0,4,6,3,3,ngx_chain_t
877,18704,ngx_hash_find,1,ngx_hash_find,"void* ngx_hash_find (ngx_hash_t*,ngx_uint_t,u_char*,size_t)",core\ngx_hash.c,"void *
ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len)
{
    ngx_uint_t       i;
    ngx_hash_elt_t  *elt;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""hf:\""%*s\"""", len, name);
#endif

    elt = hash->buckets[key % hash->size];

    if (elt == NULL) {
        return NULL;
    }

    while (elt->value) {
        if (len != (size_t) elt->len) {
            goto next;
        }

        for (i = 0; i < len; i++) {
            if (name[i] != elt->name[i]) {
                goto next;
            }
        }

        return elt->value;

    next:

        elt = (ngx_hash_elt_t *) ngx_align_ptr(&elt->name[0] + elt->len,
                                               sizeof(void *));
        continue;
    }

    return NULL;
}",12.0,49.0,1.0,1.0,38.0,25,11,23,8,8,8,9,10,3,0,,0,8,8,4,4,void*
878,92434,ngx_ssl_get_subject_dn_legacy,1,ngx_ssl_get_subject_dn_legacy,"ngx_int_t ngx_ssl_get_subject_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    char       *p;
    size_t      len;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_subject_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    p = X509_NAME_oneline(name, NULL, 0);

    for (len = 0; p[len]; len++) { /* void */ }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        OPENSSL_free(p);
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_memcpy(s->data, p, len);

    OPENSSL_free(p);
    X509_free(cert);

    return NGX_OK;
}",4761.0,4801.0,1.0,1.0,41.0,18,4,34,10,0,6,5,5,1,1,,0,6,6,3,3,ngx_int_t
879,448787,ngx_stream_script_copy_var_code,1,ngx_stream_script_copy_var_code,void ngx_stream_script_copy_var_code (ngx_stream_script_engine_t*),stream\ngx_stream_script.c,"void
ngx_stream_script_copy_var_code(ngx_stream_script_engine_t *e)
{
    u_char                        *p;
    ngx_stream_variable_value_t   *value;
    ngx_stream_script_var_code_t  *code;

    code = (ngx_stream_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_var_code_t);

    if (!e->skip) {

        if (e->flushed) {
            value = ngx_stream_get_indexed_variable(e->session, code->index);

        } else {
            value = ngx_stream_get_flushed_variable(e->session, code->index);
        }

        if (value && !value->not_found) {
            p = e->pos;
            e->pos = ngx_copy(p, value->data, value->len);

            ngx_log_debug2(NGX_LOG_DEBUG_STREAM,
                           e->session->connection->log, 0,
                           ""stream script var: \""%*s\"""", e->pos - p, p);
        }
    }
}",785.0,814.0,1.0,1.0,30.0,26,8,22,6,0,11,4,6,2,1,,0,11,2,1,1,void
880,301333,ngx_http_script_equal_code,1,ngx_http_script_equal_code,void ngx_http_script_equal_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_equal_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t  *val, *res;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script equal"");

    e->sp--;
    val = e->sp;
    res = e->sp - 1;

    e->ip += sizeof(uintptr_t);

    if (val->len == res->len
        && ngx_strncmp(val->data, res->data, res->len) == 0)
    {
        *res = ngx_http_variable_true_value;
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script equal: no"");

    *res = ngx_http_variable_null_value;
}",1515.0,1540.0,1.0,1.0,26.0,28,9,20,7,0,6,2,2,0,0,,0,6,2,1,1,void
881,43295,ngx_resolve_addr,1,ngx_resolve_addr,ngx_int_t ngx_resolve_addr (ngx_resolver_ctx_t*),core\ngx_resolver.c,"ngx_int_t
ngx_resolve_addr(ngx_resolver_ctx_t *ctx)
{
    u_char               *name;
    in_addr_t             addr;
    ngx_queue_t          *resend_queue, *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_t       *r;
    struct sockaddr_in   *sin;
    ngx_resolver_node_t  *rn;
#if (NGX_HAVE_INET6)
    uint32_t              hash;
    struct sockaddr_in6  *sin6;
#endif

#if (NGX_SUPPRESS_WARN)
    addr = 0;
#if (NGX_HAVE_INET6)
    hash = 0;
    sin6 = NULL;
#endif
#endif

    r = ctx->resolver;

    switch (ctx->addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) ctx->addr.sockaddr;
        hash = ngx_crc32_short(sin6->sin6_addr.s6_addr, 16);

        /* lock addr mutex */

        rn = ngx_resolver_lookup_addr6(r, &sin6->sin6_addr, hash);

        tree = &r->addr6_rbtree;
        resend_queue = &r->addr6_resend_queue;
        expire_queue = &r->addr6_expire_queue;

        break;
#endif

    default: /* AF_INET...",905.0,1123.0,1.0,1.0,219.0,134,12,129,16,1,49,18,24,9,16,,0,40,2,1,1,ngx_int_t
882,84260,ngx_iocp_new_connect,1,ngx_iocp_wait_connect.ngx_iocp_new_connect,int ngx_iocp_wait_connect.ngx_iocp_new_connect (),event\ngx_event_connectex.c,"int ngx_iocp_new_connect()
{
    EnterCriticalSection(&connect_lock);
    c = pending_connects[--nconnects];
    LeaveCriticalSection(&connect_lock);

    conn[nevents] = c;

    events[nevents] = WSACreateEvent();
    if (events[nevents] == INVALID_HANDLE_VALUE) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ""WSACreateEvent() failed"");
        return NGX_ERROR;
    }

    if (WSAEventSelect(c->fd, events[nevents], FD_CONNECT) == -1)
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ""WSAEventSelect() failed"");
        return NGX_ERROR;
    }",94.0,113.0,1.0,5.0,20.0,17,7,25,12,0,14,3,3,4,2,,0,12,0,0,0,int
883,6443,ngx_conf_include,1,ngx_conf_include,"char* ngx_conf_include (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_include(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char        *rv;
    ngx_int_t    n;
    ngx_str_t   *value, file, name;
    ngx_glob_t   gl;

    value = cf->args->elts;
    file = value[1];

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

    if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (strpbrk((char *) file.data, ""*?["") == NULL) {

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

        return ngx_conf_parse(cf, &file);
    }

    ngx_memzero(&gl, sizeof(ngx_glob_t));

    gl.pattern = file.data;
    gl.log = cf->log;
    gl.test = 1;

    if (ngx_open_glob(&gl) != NGX_OK) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                           ngx_open_glob_n "" \""%s\"" failed"", file.data);
        return NGX_CONF_ERROR;
    }

    rv = NGX_CONF_OK;

    for ( ;; ) {
        n = ngx_read_glob(&gl, &name);

        if (...",820.0,883.0,1.0,1.0,64.0,49,10,53,13,0,19,10,11,4,7,,0,17,6,3,3,char*
884,24076,err_levels,2,core\ngx_log.c.err_levels,,core\ngx_log.c,static ngx_str_t[] err_levels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
885,35119,ngx_pfree,1,ngx_pfree,"ngx_int_t ngx_pfree (ngx_pool_t*,void*)",core\ngx_palloc.c,"ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    for (l = pool->large; l; l = l->next) {
        if (p == l->alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           ""free: %p"", l->alloc);
            ngx_free(l->alloc);
            l->alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}",277.0,294.0,1.0,1.0,18.0,9,3,13,7,4,0,3,4,0,0,,0,0,4,2,2,ngx_int_t
886,10545,ngx_tcp_nodelay,1,ngx_tcp_nodelay,ngx_int_t ngx_tcp_nodelay (ngx_connection_t*),core\ngx_connection.c,"ngx_int_t
ngx_tcp_nodelay(ngx_connection_t *c)
{
    int  tcp_nodelay;

    if (c->tcp_nodelay != NGX_TCP_NODELAY_UNSET) {
        return NGX_OK;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0, ""tcp_nodelay"");

    tcp_nodelay = 1;

    if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
                   (const void *) &tcp_nodelay, sizeof(int))
        == -1)
    {
#if (NGX_SOLARIS)
        if (c->log_error == NGX_ERROR_INFO) {

            /* Solaris returns EINVAL if a socket has been shut down */
            c->log_error = NGX_ERROR_IGNORE_EINVAL;

            ngx_connection_error(c, ngx_socket_errno,
                                 ""setsockopt(TCP_NODELAY) failed"");

            c->log_error = NGX_ERROR_INFO;

            return NGX_ERROR;
        }
#endif

        ngx_connection_error(c, ngx_socket_errno,
                             ""setsockopt(TCP_NODELAY) failed"");
        return NGX_ERROR;
    }

    c->tcp_nodelay = NGX_TCP_NODELAY_SET;

    return NGX_OK;
}",1411.0,1451.0,1.0,1.0,41.0,12,8,17,11,1,1,3,3,0,1,,0,0,2,1,1,ngx_int_t
887,401825,name,3,ngx_file_mapping_t.name,,os\unix\ngx_files.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
888,260170,ngx_http_core_generic_phase,1,ngx_http_core_generic_phase,"ngx_int_t ngx_http_core_generic_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    /*
     * generic phase checker,
     * used by the post read and pre-access phases
     */

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""generic phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_OK) {
        r->phase_handler = ph->next;
        return NGX_AGAIN;
    }

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK;
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc);

    return NGX_OK;
}",877.0,911.0,1.0,1.0,35.0,15,5,23,8,0,1,4,4,0,1,,0,0,4,2,2,ngx_int_t
889,317750,upstreams,3,ngx_http_upstream_main_conf_t.upstreams,,http\ngx_http_upstream.h,upstreams,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
890,317773,addrs,3,ngx_http_upstream_server_t.addrs,,http\ngx_http_upstream.h,*addrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
891,317774,naddrs,3,ngx_http_upstream_server_t.naddrs,,http\ngx_http_upstream.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
892,14673,ngx_reopen_files,1,ngx_reopen_files,"void ngx_reopen_files (ngx_cycle_t*,ngx_uid_t)",core\ngx_cycle.c,"void
ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)
{
    ngx_fd_t          fd;
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_open_file_t  *file;

    part = &cycle->open_files.part;
    file = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            file = part->elts;
            i = 0;
        }

        if (file[i].name.len == 0) {
            continue;
        }

        if (file[i].flush) {
            file[i].flush(&file[i], cycle->log);
        }

        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,
                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);

        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""reopen file \""%s\"", old:%d new:%d"",
                       file[i].name.data, file[i].fd, fd);

        if (fd == NGX_INVALID_FILE) {
            ngx...",1154.0,1275.0,1.0,1.0,122.0,94,13,95,21,2,6,26,53,1,6,,0,2,4,2,2,void
893,342365,ngx_http_v2_push_resources,1,ngx_http_v2_push_resources,ngx_int_t ngx_http_v2_push_resources (ngx_http_request_t*),http\v2\ngx_http_v2_filter_module.c,"static ngx_int_t
ngx_http_v2_push_resources(ngx_http_request_t *r)
{
    u_char                     *start, *end, *last;
    ngx_int_t                   rc;
    ngx_str_t                   path;
    ngx_uint_t                  i, push;
    ngx_table_elt_t           **h;
    ngx_http_v2_loc_conf_t     *h2lcf;
    ngx_http_complex_value_t   *pushes;
    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http2 push resources"");

    ngx_memzero(binary, NGX_HTTP_V2_PUSH_HEADERS * sizeof(ngx_str_t));

    h2lcf = ngx_http_get_module_loc_conf(r, ngx_http_v2_module);

    if (h2lcf->pushes) {
        pushes = h2lcf->pushes->elts;

        for (i = 0; i < h2lcf->pushes->nelts; i++) {

            if (ngx_http_complex_value(r, &pushes[i], &path) != NGX_OK) {
                return NGX_ERROR;
            }

            if (path.len == 0) {
                continue;
            }

            if (path...",673.0,894.0,1.0,39.0,222.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
894,35170,ngx_pcalloc,1,ngx_pcalloc,"void* ngx_pcalloc (ngx_pool_t*,size_t)",core\ngx_palloc.c,"void *
ngx_pcalloc(ngx_pool_t *pool, size_t size)
{
    void *p;

    p = ngx_palloc(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",297.0,308.0,1.0,1.0,12.0,1,1,7,3,72,1,2,2,0,1,,0,1,4,2,2,void*
895,317797,value,3,ngx_http_upstream_local_t.value,,http\ngx_http_upstream.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
896,248166,sheets,3,ngx_http_xslt_filter_loc_conf_t.sheets,,http\modules\ngx_http_xslt_filter_module.c,sheets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
897,248167,types,3,ngx_http_xslt_filter_loc_conf_t.types,,http\modules\ngx_http_xslt_filter_module.c,types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
898,10600,ngx_connection_error,1,ngx_connection_error,"ngx_int_t ngx_connection_error (ngx_connection_t*,ngx_err_t,char*)",core\ngx_connection.c,"ngx_int_t
ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text)
{
    ngx_uint_t  level;

    /* Winsock may return NGX_ECONNABORTED instead of NGX_ECONNRESET */

    if ((err == NGX_ECONNRESET
#if (NGX_WIN32)
         || err == NGX_ECONNABORTED
#endif
        ) && c->log_error == NGX_ERROR_IGNORE_ECONNRESET)
    {
        return 0;
    }

#if (NGX_SOLARIS)
    if (err == NGX_EINVAL && c->log_error == NGX_ERROR_IGNORE_EINVAL) {
        return 0;
    }
#endif

    if (err == 0
        || err == NGX_ECONNRESET
#if (NGX_WIN32)
        || err == NGX_ECONNABORTED
#else
        || err == NGX_EPIPE
#endif
        || err == NGX_ENOTCONN
        || err == NGX_ETIMEDOUT
        || err == NGX_ECONNREFUSED
        || err == NGX_ENETDOWN
        || err == NGX_ENETUNREACH
        || err == NGX_EHOSTDOWN
        || err == NGX_EHOSTUNREACH)
    {
        switch (c->log_error) {

        case NGX_ERROR_IGNORE_EINVAL:
        case NGX_ERROR_IGNORE_ECONNRESET:
        case NGX_ERROR_INF...",1454.0,1510.0,1.0,1.0,57.0,27,5,36,19,4,1,5,5,0,1,,0,0,6,3,3,ngx_int_t
899,301415,ngx_http_script_not_equal_code,1,ngx_http_script_not_equal_code,void ngx_http_script_not_equal_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_not_equal_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t  *val, *res;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script not equal"");

    e->sp--;
    val = e->sp;
    res = e->sp - 1;

    e->ip += sizeof(uintptr_t);

    if (val->len == res->len
        && ngx_strncmp(val->data, res->data, res->len) == 0)
    {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                       ""http script not equal: no"");

        *res = ngx_http_variable_null_value;
        return;
    }

    *res = ngx_http_variable_true_value;
}",1543.0,1568.0,1.0,1.0,26.0,28,9,20,7,0,6,2,2,0,0,,0,6,2,1,1,void
900,84330,ngx_iocp_wait_events,1,ngx_iocp_wait_events,void ngx_iocp_wait_events (int),event\ngx_event_connectex.c,"void ngx_iocp_wait_events(int main)
{
    WSANETWORKEVENTS  ne;

    nevents = 1;
    events[0] = pending_connect_event;
    conn[0] = NULL;

    for ( ;; ) {
        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1: 0;
        timeout = (nevents == 1 && !first) ? 60000: INFINITE;

        n = WSAWaitForMultipleEvents(nevents - offset, events[offset],
                                     0, timeout, 0);
        if (n == WAIT_FAILED) {
            ngx_log_error(NGX_LOG_ALERT, log, ngx_socket_errno,
                          ""WSAWaitForMultipleEvents() failed"");
            continue;
        }

        if (n == WAIT_TIMEOUT) {
            if (nevents == 2 && !main) {
                ExitThread(0);
            }

            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ""WSAWaitForMultipleEvents() ""
                          ""returned unexpected WAIT_TIMEOUT"");
            continue;
        }

        n -= WSA_WAIT_EVENT_0;

        if (events[n] == NULL) {

     ...",121.0,206.0,1.0,1.0,86.0,61,16,76,25,0,29,19,26,6,6,,0,23,2,1,1,void
901,158058,len,3,ngx_http_limit_conn_node_t.len,,http\modules\ngx_http_limit_conn_module.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
902,18795,ngx_hash_find_wc_head,1,ngx_hash_find_wc_head,"void* ngx_hash_find_wc_head (ngx_hash_wildcard_t*,u_char*,size_t)",core\ngx_hash.c,"void *
ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
{
    void        *value;
    ngx_uint_t   i, n, key;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""wch:\""%*s\"""", len, name);
#endif

    n = len;

    while (n) {
        if (name[n - 1] == '.') {
            break;
        }

        n--;
    }

    key = 0;

    for (i = n; i < len; i++) {
        key = ngx_hash(key, name[i]);
    }

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""key:\""%ui\"""", key);
#endif

    value = ngx_hash_find(&hwc->hash, key, &name[n], len - n);

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""value:\""%p\"""", value);
#endif

    if (value) {

        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer for both ""example.com""
         *          and ""*.example.com"";
         *     01 - value is data pointer for ""*.example.com"" only;
         *     10 - value is pointer to wildcard hash allo...",52.0,143.0,1.0,1.0,92.0,46,11,45,8,1,5,12,23,0,1,,0,5,6,3,3,void*
903,248173,doc,3,ngx_http_xslt_filter_ctx_t.doc,,http\modules\ngx_http_xslt_filter_module.c,doc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
904,248174,ctxt,3,ngx_http_xslt_filter_ctx_t.ctxt,,http\modules\ngx_http_xslt_filter_module.c,ctxt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
905,158059,conn,3,ngx_http_limit_conn_node_t.conn,,http\modules\ngx_http_limit_conn_module.c,conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
906,158060,data,3,ngx_http_limit_conn_node_t.data,,http\modules\ngx_http_limit_conn_module.c,data[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
907,248176,request,3,ngx_http_xslt_filter_ctx_t.request,,http\modules\ngx_http_xslt_filter_module.c,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
908,248178,done,3,ngx_http_xslt_filter_ctx_t.done,,http\modules\ngx_http_xslt_filter_module.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
909,248179,ngx_http_xslt_filter_ctx_t,2,http\modules\ngx_http_xslt_filter_module.c.ngx_http_xslt_filter_ctx_t,,http\modules\ngx_http_xslt_filter_module.c,struct ngx_http_xslt_filter_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
910,248180,ngx_http_xslt_send,1,ngx_http_xslt_send,"ngx_int_t ngx_http_xslt_send (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)",http\modules\ngx_http_xslt_filter_module.c,"static ngx_int_t
ngx_http_xslt_send(ngx_http_request_t *r, ngx_http_xslt_filter_ctx_t *ctx,
    ngx_buf_t *b)
{
    ngx_int_t                         rc;
    ngx_chain_t                       out;
    ngx_pool_cleanup_t               *cln;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    ctx->done = 1;

    if (b == NULL) {
        return ngx_http_filter_finalize_request(r, &ngx_http_xslt_filter_module,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
    }

    cln = ngx_pool_cleanup_add(r->pool, 0);

    if (cln == NULL) {
        ngx_free(b->pos);
        return ngx_http_filter_finalize_request(r, &ngx_http_xslt_filter_module,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
    }

    if (r == r->main) {
        r->headers_out.content_length_n = b->last - b->pos;

        if (r->headers_out.content_length) {
            r->headers_out.content_length->hash = 0;
            r->headers_out.content_length = NULL;
        ...",308.0,365.0,1.0,1.0,58.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
911,158069,shm_zone,3,ngx_http_limit_conn_cleanup_t.shm_zone,,http\modules\ngx_http_limit_conn_module.c,*shm_zone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
912,35190,ngx_pool_cleanup_add,1,ngx_pool_cleanup_add,"ngx_pool_cleanup_t ngx_pool_cleanup_add (ngx_pool_t*,size_t)",core\ngx_palloc.c,"ngx_pool_cleanup_t *
ngx_pool_cleanup_add(ngx_pool_t *p, size_t size)
{
    ngx_pool_cleanup_t  *c;

    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));
    if (c == NULL) {
        return NULL;
    }

    if (size) {
        c->data = ngx_palloc(p, size);
        if (c->data == NULL) {
            return NULL;
        }

    } else {
        c->data = NULL;
    }

    c->handler = NULL;
    c->next = p->cleanup;

    p->cleanup = c;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p->log, 0, ""add cleanup: %p"", c);

    return c;
}",311.0,339.0,1.0,1.0,29.0,15,4,23,6,11,2,4,5,0,2,,0,2,4,2,2,ngx_pool_cleanup_t
913,158071,ngx_http_limit_conn_cleanup_t,2,http\modules\ngx_http_limit_conn_module.c.ngx_http_limit_conn_cleanup_t,,http\modules\ngx_http_limit_conn_module.c,struct ngx_http_limit_conn_cleanup_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
914,92532,ngx_ssl_get_issuer_dn_legacy,1,ngx_ssl_get_issuer_dn_legacy,"ngx_int_t ngx_ssl_get_issuer_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    char       *p;
    size_t      len;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_issuer_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    p = X509_NAME_oneline(name, NULL, 0);

    for (len = 0; p[len]; len++) { /* void */ }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        OPENSSL_free(p);
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_memcpy(s->data, p, len);

    OPENSSL_free(p);
    X509_free(cert);

    return NGX_OK;
}",4804.0,4844.0,1.0,1.0,41.0,18,4,34,10,0,6,5,5,1,1,,0,6,6,3,3,ngx_int_t
915,158067,ngx_http_limit_conn_node_t,2,http\modules\ngx_http_limit_conn_module.c.ngx_http_limit_conn_node_t,,http\modules\ngx_http_limit_conn_module.c,struct ngx_http_limit_conn_node_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
916,158070,node,3,ngx_http_limit_conn_cleanup_t.node,,http\modules\ngx_http_limit_conn_module.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
917,248187,ngx_http_xslt_add_chunk,1,ngx_http_xslt_add_chunk,"ngx_int_t ngx_http_xslt_add_chunk (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)",http\modules\ngx_http_xslt_filter_module.c,"static ngx_int_t
ngx_http_xslt_add_chunk(ngx_http_request_t *r, ngx_http_xslt_filter_ctx_t *ctx,
    ngx_buf_t *b)
{
    int               err;
    xmlParserCtxtPtr  ctxt;

    if (ctx->ctxt == NULL) {

        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL);
        if (ctxt == NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""xmlCreatePushParserCtxt() failed"");
            return NGX_ERROR;
        }
        xmlCtxtUseOptions(ctxt, XML_PARSE_NOENT|XML_PARSE_DTDLOAD
                                               |XML_PARSE_NOWARNING);

        ctxt->sax->externalSubset = ngx_http_xslt_sax_external_subset;
        ctxt->sax->setDocumentLocator = NULL;
        ctxt->sax->error = ngx_http_xslt_sax_error;
        ctxt->sax->fatalError = ngx_http_xslt_sax_error;
        ctxt->sax->_private = ctx;

        ctx->ctxt = ctxt;
        ctx->request = r;
    }

    err = xmlParseChunk(ctx->ctxt, (char *) b->pos, (int) (b->last - b->pos)...",368.0,408.0,1.0,1.0,41.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
918,158075,ngx_http_limit_conn_shctx_t,2,http\modules\ngx_http_limit_conn_module.c.ngx_http_limit_conn_shctx_t,,http\modules\ngx_http_limit_conn_module.c,struct ngx_http_limit_conn_shctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
919,158077,sh,3,ngx_http_limit_conn_ctx_t.sh,,http\modules\ngx_http_limit_conn_module.c,*sh,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
920,158078,shpool,3,ngx_http_limit_conn_ctx_t.shpool,,http\modules\ngx_http_limit_conn_module.c,*shpool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
921,158079,key,3,ngx_http_limit_conn_ctx_t.key,,http\modules\ngx_http_limit_conn_module.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
922,80258,ngx_timer_signal_handler,1,ngx_timer_signal_handler,void ngx_timer_signal_handler (int),event\ngx_event.c,"static void
ngx_timer_signal_handler(int signo)
{
    ngx_event_timer_alarm = 1;

#if 1
    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0, ""timer signal"");
#endif
}",599.0,607.0,1.0,1.0,9.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
923,317829,hide_headers_hash,3,ngx_http_upstream_conf_t.hide_headers_hash,,http\ngx_http_upstream.h,hide_headers_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
924,158086,limits,3,ngx_http_limit_conn_conf_t.limits,,http\modules\ngx_http_limit_conn_module.c,limits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
925,317830,hide_headers,3,ngx_http_upstream_conf_t.hide_headers,,http\ngx_http_upstream.h,*hide_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
926,158088,status_code,3,ngx_http_limit_conn_conf_t.status_code,,http\modules\ngx_http_limit_conn_module.c,status_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
927,158089,dry_run,3,ngx_http_limit_conn_conf_t.dry_run,,http\modules\ngx_http_limit_conn_module.c,dry_run,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
928,317831,pass_headers,3,ngx_http_upstream_conf_t.pass_headers,,http\ngx_http_upstream.h,*pass_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
929,158091,ngx_http_limit_conn_lookup,1,ngx_http_limit_conn_lookup,"ngx_rbtree_node_t* ngx_http_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)",http\modules\ngx_http_limit_conn_module.c,"static ngx_rbtree_node_t *
ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree, ngx_str_t *key, uint32_t hash)
{
    ngx_int_t                    rc;
    ngx_rbtree_node_t           *node, *sentinel;
    ngx_http_limit_conn_node_t  *lcn;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lcn = (ngx_http_limit_conn_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t) lcn->len);

        if (rc == 0) {
            return node;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",352.0,388.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_rbtree_node_t
930,248203,ngx_http_xslt_apply_stylesheet,1,ngx_http_xslt_apply_stylesheet,"ngx_buf_t* ngx_http_xslt_apply_stylesheet (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*)",http\modules\ngx_http_xslt_filter_module.c,"static ngx_buf_t *
ngx_http_xslt_apply_stylesheet(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx)
{
    int                               len, rc, doc_type;
    u_char                           *type, *encoding;
    ngx_buf_t                        *b;
    ngx_uint_t                        i;
    xmlChar                          *buf;
    xmlDocPtr                         doc, res;
    ngx_http_xslt_sheet_t            *sheet;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_xslt_filter_module);
    sheet = conf->sheets.elts;
    doc = ctx->doc;

    /* preallocate array for 4 params */

    if (ngx_array_init(&ctx->params, r->pool, 4 * 2 + 1, sizeof(char *))
        != NGX_OK)
    {
        xmlFreeDoc(doc);
        return NULL;
    }

    for (i = 0; i < conf->sheets.nelts; i++) {

        ctx->transform = xsltNewTransformContext(sheet[i].stylesheet, doc);
        if (ctx->transform == NULL) {
            xmlFreeDoc(doc);
 ...",487.0,624.0,1.0,1.0,138.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_buf_t
931,401843,pattern,3,ngx_glob_t.pattern,,os\unix\ngx_files.h,*pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
932,321936,ngx_http_get_variable_index,1,ngx_http_get_variable_index,"ngx_int_t ngx_http_get_variable_index (ngx_conf_t*,ngx_str_t*)",http\ngx_http_variables.c,"ngx_int_t
ngx_http_get_variable_index(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_uint_t                  i;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NGX_ERROR;
    }

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->variables.elts;

    if (v == NULL) {
        if (ngx_array_init(&cmcf->variables, cf->pool, 4,
                           sizeof(ngx_http_variable_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }

    } else {
        for (i = 0; i < cmcf->variables.nelts; i++) {
            if (name->len != v[i].name.len
                || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
            {
                continue;
            }

            return i;
        }
    }

    v = ngx_array_push(&cmcf->variables);
    if (...",539.0,596.0,1.0,1.0,58.0,46,8,41,10,0,14,6,7,3,5,,0,12,4,2,2,ngx_int_t
933,342421,ngx_http_v2_waiting_queue,1,ngx_http_v2_waiting_queue,"void ngx_http_v2_waiting_queue (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*)",http\v2\ngx_http_v2_filter_module.c,"static void
ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream)
{
    ngx_queue_t           *q;
    ngx_http_v2_stream_t  *s;

    if (stream->waiting) {
        return;
    }

    stream->waiting = 1;

    for (q = ngx_queue_last(&h2c->waiting);
         q != ngx_queue_sentinel(&h2c->waiting);
         q = ngx_queue_prev(q))
    {
        s = ngx_queue_data(q, ngx_http_v2_stream_t, queue);

        if (s->node->rank < stream->node->rank
            || (s->node->rank == stream->node->rank
                && s->node->rel_weight >= stream->node->rel_weight))
        {
            break;
        }
    }

    ngx_queue_insert_after(q, &stream->queue);
}",1778.0,1806.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
934,256420,ngx_http_cmp_dns_wildcards,1,ngx_http_cmp_dns_wildcards,"ANY ngx_http_cmp_dns_wildcards (void*,void*)",http\ngx_http.c,"ngx_http_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",1615.0,1623.0,1.0,1.0,9.0,8,4,6,4,0,3,1,1,0,1,,0,2,4,2,2,ANY
935,104878,skip,3,ngx_http_modern_browser_t.skip,,http\modules\ngx_http_browser_module.c,skip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
936,301497,ngx_http_script_file_code,1,ngx_http_script_file_code,void ngx_http_script_file_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_file_code(ngx_http_script_engine_t *e)
{
    ngx_str_t                     path;
    ngx_http_request_t           *r;
    ngx_open_file_info_t          of;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_variable_value_t    *value;
    ngx_http_script_file_code_t  *code;

    value = e->sp - 1;

    code = (ngx_http_script_file_code_t *) e->ip;
    e->ip += sizeof(ngx_http_script_file_code_t);

    path.len = value->len - 1;
    path.data = value->data;

    r = e->request;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http script file op %p \""%V\"""", (void *) code->op, &path);

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    ngx_memzero(&of, sizeof(ngx_open_file_info_t));

    of.read_ahead = clcf->read_ahead;
    of.directio = clcf->directio;
    of.valid = clcf->open_file_cache_valid;
    of.min_uses = clcf->open_file_cache_min_uses;
    of.test_only = 1;
    of.errors = clcf->open_file_cache_err...",1571.0,1709.0,1.0,16.0,139.0,105,13,100,28,0,43,34,26,20,3,,0,42,2,1,1,void
937,35263,ngx_pool_run_cleanup_file,1,ngx_pool_run_cleanup_file,"void ngx_pool_run_cleanup_file (ngx_pool_t*,ngx_fd_t)",core\ngx_palloc.c,"void
ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd)
{
    ngx_pool_cleanup_t       *c;
    ngx_pool_cleanup_file_t  *cf;

    for (c = p->cleanup; c; c = c->next) {
        if (c->handler == ngx_pool_cleanup_file) {

            cf = c->data;

            if (cf->fd == fd) {
                c->handler(cf);
                c->handler = NULL;
                return;
            }
        }
    }
}",342.0,360.0,1.0,1.0,19.0,11,3,12,5,0,1,4,7,1,0,,0,1,4,2,2,void
938,424396,variables_hash,3,ngx_stream_core_main_conf_t.variables_hash,,stream\ngx_stream.h,variables_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
939,424397,variables,3,ngx_stream_core_main_conf_t.variables,,stream\ngx_stream.h,variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
940,63950,ngx_decode_base64url,1,ngx_decode_base64url,"ngx_int_t ngx_decode_base64url (ngx_str_t*,ngx_str_t*)",core\ngx_string.c,"ngx_int_t
ngx_decode_base64url(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] = {
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,
        77,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 63,
        77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,

        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 7...",1228.0,1252.0,1.0,1.0,25.0,2,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,ngx_int_t
941,424398,prefix_variables,3,ngx_stream_core_main_conf_t.prefix_variables,,stream\ngx_stream.h,prefix_variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
942,424400,variables_hash_max_size,3,ngx_stream_core_main_conf_t.variables_hash_max_size,,stream\ngx_stream.h,variables_hash_max_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
943,317905,host,3,ngx_http_upstream_resolved_t.host,,http\ngx_http_upstream.h,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
944,424402,variables_keys,3,ngx_stream_core_main_conf_t.variables_keys,,stream\ngx_stream.h,*variables_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
945,39378,ngx_rbtree_delete,1,ngx_rbtree_delete,"void ngx_rbtree_delete (ngx_rbtree_t*,ngx_rbtree_node_t*)",core\ngx_rbtree.c,"void
ngx_rbtree_delete(ngx_rbtree_t *tree, ngx_rbtree_node_t *node)
{
    ngx_uint_t           red;
    ngx_rbtree_node_t  **root, *sentinel, *subst, *temp, *w;

    /* a binary tree delete */

    root = &tree->root;
    sentinel = tree->sentinel;

    if (node->left == sentinel) {
        temp = node->right;
        subst = node;

    } else if (node->right == sentinel) {
        temp = node->left;
        subst = node;

    } else {
        subst = ngx_rbtree_min(node->right, sentinel);
        temp = subst->right;
    }

    if (subst == *root) {
        *root = temp;
        ngx_rbt_black(temp);

        /* DEBUG stuff */
        node->left = NULL;
        node->right = NULL;
        node->parent = NULL;
        node->key = 0;

        return;
    }

    red = ngx_rbt_is_red(subst);

    if (subst == subst->parent->left) {
        subst->parent->left = temp;

    } else {
        subst->parent->right = temp;
    }

    if (subst == node) {

        temp->parent = subst->parent;...",156.0,315.0,1.0,1.0,160.0,60,7,61,9,4,0,10,15,0,0,,0,0,4,2,2,void
946,317908,naddrs,3,ngx_http_upstream_resolved_t.naddrs,,http\ngx_http_upstream.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
947,424401,variables_hash_bucket_size,3,ngx_stream_core_main_conf_t.variables_hash_bucket_size,,stream\ngx_stream.h,variables_hash_bucket_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
948,92630,ngx_ssl_get_serial_number,1,ngx_ssl_get_serial_number,"ngx_int_t ngx_ssl_get_serial_number (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    size_t   len;
    X509    *cert;
    BIO     *bio;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    i2a_ASN1_INTEGER(bio, X509_get_serialNumber(cert));
    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",4847.0,4883.0,1.0,1.0,37.0,16,3,31,9,0,6,4,4,1,1,,0,6,6,3,3,ngx_int_t
949,342488,ngx_http_v2_header_filter,1,ngx_http_v2_header_filter,ngx_int_t ngx_http_v2_header_filter (ngx_http_request_t*),http\v2\ngx_http_v2_filter_module.c,"static ngx_int_t
ngx_http_v2_header_filter(ngx_http_request_t *r)
{
    u_char                     status, *pos, *start, *p, *tmp;
    size_t                     len, tmp_len;
    ngx_str_t                  host, location;
    ngx_uint_t                 i, port, fin;
    ngx_list_part_t           *part;
    ngx_table_elt_t           *header;
    ngx_connection_t          *fc;
    ngx_http_cleanup_t        *cln;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_out_frame_t   *frame;
    ngx_http_v2_connection_t  *h2c;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_core_srv_conf_t  *cscf;
    u_char                     addr[NGX_SOCKADDR_STRLEN];

    static const u_char nginx[5] = ""\x84\xaa\x63\x55\xe7"";
#if (NGX_HTTP_GZIP)
    static const u_char accept_encoding[12] =
        ""\x8b\x84\x84\x2d\x69\x5b\x05\x44\x3c\x86\xaa\x6f"";
#endif

    static size_t nginx_ver_len = ngx_http_v2_literal_size(NGINX_VER);
    static u_char nginx_ver[ngx_http_v2_literal_size(NGINX_VER)];

    s...",133.0,670.0,1.0,34.0,538.0,593,25,425,63,0,26,63,86,2,14,,0,22,2,1,1,ngx_int_t
950,317912,socklen,3,ngx_http_upstream_resolved_t.socklen,,http\ngx_http_upstream.h,socklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
951,317913,name,3,ngx_http_upstream_resolved_t.name,,http\ngx_http_upstream.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
952,6624,ngx_conf_full_name,1,ngx_conf_full_name,"ngx_int_t ngx_conf_full_name (ngx_cycle_t*,ngx_str_t*,ngx_uint_t)",core\ngx_conf_file.c,"ngx_int_t
ngx_conf_full_name(ngx_cycle_t *cycle, ngx_str_t *name, ngx_uint_t conf_prefix)
{
    ngx_str_t  *prefix;

    prefix = conf_prefix ? &cycle->conf_prefix : &cycle->prefix;

    return ngx_get_full_name(cycle->pool, prefix, name);
}",886.0,894.0,1.0,1.0,9.0,7,4,7,4,11,1,1,1,0,1,,0,0,6,3,3,ngx_int_t
953,236005,ngx_http_upstream_init_ip_hash,1,ngx_http_upstream_init_ip_hash,"ngx_int_t ngx_http_upstream_init_ip_hash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)",http\modules\ngx_http_upstream_ip_hash_module.c,"static ngx_int_t
ngx_http_upstream_init_ip_hash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_ip_hash_peer;

    return NGX_OK;
}",83.0,93.0,1.0,1.0,11.0,4,4,7,5,0,1,2,2,1,1,,0,1,4,2,2,ngx_int_t
954,149999,expires,3,ngx_http_headers_conf_t.expires,,http\modules\ngx_http_headers_filter_module.c,expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
955,150002,headers,3,ngx_http_headers_conf_t.headers,,http\modules\ngx_http_headers_filter_module.c,*headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
956,150003,trailers,3,ngx_http_headers_conf_t.trailers,,http\modules\ngx_http_headers_filter_module.c,*trailers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
957,35315,ngx_pool_cleanup_file,1,ngx_pool_cleanup_file,void ngx_pool_cleanup_file (void*),core\ngx_palloc.c,"void
ngx_pool_cleanup_file(void *data)
{
    ngx_pool_cleanup_file_t  *c = data;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c->log, 0, ""file cleanup: fd:%d"",
                   c->fd);

    if (ngx_close_file(c->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", c->name);
    }
}",363.0,375.0,1.0,1.0,13.0,5,3,7,4,0,3,2,2,1,0,,0,3,2,1,1,void
958,150005,ngx_http_set_expires,1,ngx_http_set_expires,"ngx_int_t ngx_http_set_expires (ngx_http_request_t*,ngx_http_headers_conf_t*)",http\modules\ngx_http_headers_filter_module.c,"static ngx_int_t
ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)
{
    char                *err;
    size_t               len;
    time_t               now, expires_time, max_age;
    ngx_str_t            value;
    ngx_int_t            rc;
    ngx_uint_t           i;
    ngx_table_elt_t     *e, *cc, **ccp;
    ngx_http_expires_t   expires;

    expires = conf->expires;
    expires_time = conf->expires_time;

    if (conf->expires_value != NULL) {

        if (ngx_http_complex_value(r, conf->expires_value, &value) != NGX_OK) {
            return NGX_ERROR;
        }

        rc = ngx_http_parse_expires(&value, &expires, &expires_time, &err);

        if (rc != NGX_OK) {
            return NGX_OK;
        }

        if (expires == NGX_HTTP_EXPIRES_OFF) {
            return NGX_OK;
        }
    }

    e = r->headers_out.expires;

    if (e == NULL) {

        e = ngx_list_push(&r->headers_out.headers);
        if (e == NULL) {
            return NGX_ERROR;
...",324.0,467.0,1.0,1.0,144.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
959,6651,ngx_conf_open_file,1,ngx_conf_open_file,"ngx_open_file_t ngx_conf_open_file (ngx_cycle_t*,ngx_str_t*)",core\ngx_conf_file.c,"ngx_open_file_t *
ngx_conf_open_file(ngx_cycle_t *cycle, ngx_str_t *name)
{
    ngx_str_t         full;
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_open_file_t  *file;

#if (NGX_SUPPRESS_WARN)
    ngx_str_null(&full);
#endif

    if (name->len) {
        full = *name;

        if (ngx_conf_full_name(cycle, &full, 0) != NGX_OK) {
            return NULL;
        }

        part = &cycle->open_files.part;
        file = part->elts;

        for (i = 0; /* void */ ; i++) {

            if (i >= part->nelts) {
                if (part->next == NULL) {
                    break;
                }
                part = part->next;
                file = part->elts;
                i = 0;
            }

            if (full.len != file[i].name.len) {
                continue;
            }

            if (ngx_strcmp(full.data, file[i].name.data) == 0) {
                return &file[i];
            }
        }
    }

    file = ngx_list_push(&cycle->open_files);
    if (f...",897.0,958.0,1.0,1.0,62.0,47,10,45,9,2,6,12,21,5,2,,0,6,4,2,2,ngx_open_file_t
960,260613,ngx_http_core_post_rewrite_phase,1,ngx_http_core_post_rewrite_phase,"ngx_int_t ngx_http_core_post_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_post_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_http_core_srv_conf_t  *cscf;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""post rewrite phase: %ui"", r->phase_handler);

    if (!r->uri_changed) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""uri changes: %d"", r->uri_changes);

    /*
     * gcc before 3.3 compiles the broken code for
     *     if (r->uri_changes-- == 0)
     * if the r->uri_changes is defined as
     *     unsigned  uri_changes:4
     */

    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while processing \""%V\"""", &r->uri);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    r...",1035.0,1076.0,1.0,1.0,42.0,26,7,25,9,0,4,3,3,0,2,,0,2,4,2,2,ngx_int_t
961,416270,path,3,ngx_exec_ctx_t.path,,os\win32\ngx_process.h,*path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
962,35343,ngx_pool_delete_file,1,ngx_pool_delete_file,void ngx_pool_delete_file (void*),core\ngx_palloc.c,"void
ngx_pool_delete_file(void *data)
{
    ngx_pool_cleanup_file_t  *c = data;

    ngx_err_t  err;

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c->log, 0, ""file cleanup: fd:%d %s"",
                   c->fd, c->name);

    if (ngx_delete_file(c->name) == NGX_FILE_ERROR) {
        err = ngx_errno;

        if (err != NGX_ENOENT) {
            ngx_log_error(NGX_LOG_CRIT, c->log, err,
                          ngx_delete_file_n "" \""%s\"" failed"", c->name);
        }
    }

    if (ngx_close_file(c->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", c->name);
    }
}",378.0,401.0,1.0,1.0,24.0,10,4,14,7,0,5,4,5,2,0,,0,5,2,1,1,void
963,18960,ngx_hash_find_wc_tail,1,ngx_hash_find_wc_tail,"void* ngx_hash_find_wc_tail (ngx_hash_wildcard_t*,u_char*,size_t)",core\ngx_hash.c,"void *
ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
{
    void        *value;
    ngx_uint_t   i, key;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""wct:\""%*s\"""", len, name);
#endif

    key = 0;

    for (i = 0; i < len; i++) {
        if (name[i] == '.') {
            break;
        }

        key = ngx_hash(key, name[i]);
    }

    if (i == len) {
        return NULL;
    }

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""key:\""%ui\"""", key);
#endif

    value = ngx_hash_find(&hwc->hash, key, name, i);

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""value:\""%p\"""", value);
#endif

    if (value) {

        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer;
         *     11 - value is pointer to wildcard hash allowing ""example.*"".
         */

        if ((uintptr_t) value & 2) {

            i++;

            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & ...",146.0,207.0,1.0,1.0,62.0,26,11,34,7,1,4,8,11,0,1,,0,4,6,3,3,void*
964,416271,name,3,ngx_exec_ctx_t.name,,os\win32\ngx_process.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
965,416273,argv,3,ngx_exec_ctx_t.argv,,os\win32\ngx_process.h,*const            *argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
966,416274,envp,3,ngx_exec_ctx_t.envp,,os\win32\ngx_process.h,*const            *envp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
967,375322,timeout,3,ngx_mail_core_srv_conf_t.timeout,,mail\ngx_mail.h,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
968,375323,resolver_timeout,3,ngx_mail_core_srv_conf_t.resolver_timeout,,mail\ngx_mail.h,resolver_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
969,375327,resolver,3,ngx_mail_core_srv_conf_t.resolver,,mail\ngx_mail.h,*resolver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
970,92718,ngx_ssl_get_fingerprint,1,ngx_ssl_get_fingerprint,"ngx_int_t ngx_ssl_get_fingerprint (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509          *cert;
    unsigned int   len;
    u_char         buf[EVP_MAX_MD_SIZE];

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    if (!X509_digest(cert, EVP_sha1(), buf, &len)) {
        X509_free(cert);
        return NGX_ERROR;
    }

    s->len = 2 * len;
    s->data = ngx_pnalloc(pool, 2 * len);
    if (s->data == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_hex_dump(s->data, buf, len);

    X509_free(cert);

    return NGX_OK;
}",4886.0,4917.0,1.0,1.0,32.0,17,6,25,9,0,7,4,4,1,2,,0,6,6,3,3,ngx_int_t
971,158268,ngx_http_limit_conn_module,2,http\modules\ngx_http_limit_conn_module.c.ngx_http_limit_conn_module,,http\modules\ngx_http_limit_conn_module.c,ngx_module_t ngx_http_limit_conn_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
972,23108,ngx_inet_resolve_host,1,ngx_inet_resolve_host,"ngx_int_t ngx_inet_resolve_host (ngx_pool_t*,ngx_url_t*)",core\ngx_inet.c,"ngx_int_t
ngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char              *host;
    ngx_uint_t           i, n;
    struct hostent      *h;
    struct sockaddr_in   sin;

    /* AF_INET only */

    ngx_memzero(&sin, sizeof(struct sockaddr_in));

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ngx_inet_addr(u->host.data, u->host.len);

    if (sin.sin_addr.s_addr == INADDR_NONE) {
        host = ngx_alloc(u->host.len + 1, pool->log);
        if (host == NULL) {
            return NGX_ERROR;
        }

        (void) ngx_cpystrn(host, u->host.data, u->host.len + 1);

        h = gethostbyname((char *) host);

        ngx_free(host);

        if (h == NULL || h->h_addr_list[0] == NULL) {
            u->err = ""host not found"";
            return NGX_ERROR;
        }

        for (n = 0; h->h_addr_list[n] != NULL; n++) { /* void */ }

        /* MP: ngx_shared_palloc() */

        for (i = 0; i < n; i++) {
            sin.sin_addr.s_addr = *(in_addr_t *) (h->h_ad...",1197.0,1257.0,1.0,1.0,61.0,52,13,45,13,2,10,7,13,1,4,,0,9,4,2,2,ngx_int_t
973,318021,key,3,ngx_http_upstream_param_t.key,,http\ngx_http_upstream.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
974,318022,value,3,ngx_http_upstream_param_t.value,,http\ngx_http_upstream.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
975,318023,skip_empty,3,ngx_http_upstream_param_t.skip_empty,,http\ngx_http_upstream.h,skip_empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
976,96840,ngx_posted_next_events,2,event\ngx_event_posted.c.ngx_posted_next_events,,event\ngx_event_posted.c,ngx_queue_t ngx_posted_next_events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
977,96841,ngx_posted_events,2,event\ngx_event_posted.c.ngx_posted_events,,event\ngx_event_posted.c,ngx_queue_t ngx_posted_events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
978,96842,ngx_event_process_posted,1,ngx_event_process_posted,"void ngx_event_process_posted (ngx_cycle_t*,ngx_queue_t*)",event\ngx_event_posted.c,"void
ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)
{
    ngx_queue_t  *q;
    ngx_event_t  *ev;

    while (!ngx_queue_empty(posted)) {

        q = ngx_queue_head(posted);
        ev = ngx_queue_data(q, ngx_event_t, queue);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                      ""posted event %p"", ev);

        ngx_delete_posted_event(ev);

        ev->handler(ev);
    }
}",18.0,36.0,1.0,1.0,19.0,5,3,13,7,2,0,2,2,0,0,,0,0,4,2,2,void
979,252491,request,3,ngx_http_perl_ctx_t.request,,http\modules\perl\ngx_http_perl_module.h,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
980,252492,filename,3,ngx_http_perl_ctx_t.filename,,http\modules\perl\ngx_http_perl_module.h,filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
981,252493,redirect_uri,3,ngx_http_perl_ctx_t.redirect_uri,,http\modules\perl\ngx_http_perl_module.h,redirect_uri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
982,252494,next,3,ngx_http_perl_ctx_t.next,,http\modules\perl\ngx_http_perl_module.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
983,252496,done,3,ngx_http_perl_ctx_t.done,,http\modules\perl\ngx_http_perl_module.h,done:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
984,449105,ip,3,ngx_stream_script_engine_t.ip,,stream\ngx_stream_script.h,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
985,252498,variable,3,ngx_http_perl_ctx_t.variable,,http\modules\perl\ngx_http_perl_module.h,variable:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
986,449106,pos,3,ngx_stream_script_engine_t.pos,,stream\ngx_stream_script.h,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
987,449108,buf,3,ngx_stream_script_engine_t.buf,,stream\ngx_stream_script.h,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
988,449110,flushed,3,ngx_stream_script_engine_t.flushed,,stream\ngx_stream_script.h,flushed:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
989,449111,skip,3,ngx_stream_script_engine_t.skip,,stream\ngx_stream_script.h,skip:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
990,84568,ngx_ssl_load_certificate_key,1,ngx_ssl_load_certificate_key,"EVP_PKEY* ngx_ssl_load_certificate_key (ngx_pool_t*,char**,ngx_str_t*,ngx_array_t*)",event\ngx_event_openssl.c,"static EVP_PKEY *
ngx_ssl_load_certificate_key(ngx_pool_t *pool, char **err,
    ngx_str_t *key, ngx_array_t *passwords)
{
    BIO              *bio;
    EVP_PKEY         *pkey;
    ngx_str_t        *pwd;
    ngx_uint_t        tries;
    pem_password_cb  *cb;

    if (ngx_strncmp(key->data, ""engine:"", sizeof(""engine:"") - 1) == 0) {

#ifndef OPENSSL_NO_ENGINE

        u_char  *p, *last;
        ENGINE  *engine;

        p = key->data + sizeof(""engine:"") - 1;
        last = (u_char *) ngx_strchr(p, ':');

        if (last == NULL) {
            *err = ""invalid syntax"";
            return NULL;
        }

        *last = '\0';

        engine = ENGINE_by_id((char *) p);

        if (engine == NULL) {
            *err = ""ENGINE_by_id() failed"";
            return NULL;
        }

        *last++ = ':';

        pkey = ENGINE_load_private_key(engine, (char *) last, 0, 0);

        if (pkey == NULL) {
            *err = ""ENGINE_load_private_key() failed"";
            ENGINE_free(engine);
...",702.0,816.0,1.0,1.0,115.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,EVP_PKEY
991,322137,ngx_http_get_indexed_variable,1,ngx_http_get_indexed_variable,"ngx_http_variable_value_t ngx_http_get_indexed_variable (ngx_http_request_t*,ngx_uint_t)",http\ngx_http_variables.c,"ngx_http_variable_value_t *
ngx_http_get_indexed_variable(ngx_http_request_t *r, ngx_uint_t index)
{
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    if (cmcf->variables.nelts <= index) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""unknown variable index: %ui"", index);
        return NULL;
    }

    if (r->variables[index].not_found || r->variables[index].valid) {
        return &r->variables[index];
    }

    v = cmcf->variables.elts;

    if (ngx_http_variable_depth == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""cycle while evaluating variable \""%V\"""",
                      &v[index].name);
        return NULL;
    }

    ngx_http_variable_depth--;

    if (v[index].get_handler(r, &r->variables[index], v[index].data)
        == NGX_OK)
    {
        ngx_http_variable_depth++;

        if (v[index].flags ...",599.0,646.0,1.0,1.0,48.0,54,11,46,11,3,8,6,7,2,2,,0,6,4,2,2,ngx_http_variable_value_t
992,248408,ngx_http_xslt_filter_module,2,http\modules\ngx_http_xslt_filter_module.c.ngx_http_xslt_filter_module,,http\modules\ngx_http_xslt_filter_module.c,ngx_module_t ngx_http_xslt_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
993,449112,session,3,ngx_stream_script_engine_t.session,,stream\ngx_stream_script.h,*session,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
994,449115,cf,3,ngx_stream_script_compile_t.cf,,stream\ngx_stream_script.h,*cf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
995,449116,source,3,ngx_stream_script_compile_t.source,,stream\ngx_stream_script.h,*source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
996,449117,flushes,3,ngx_stream_script_compile_t.flushes,,stream\ngx_stream_script.h,**flushes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
997,449118,lengths,3,ngx_stream_script_compile_t.lengths,,stream\ngx_stream_script.h,**lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
998,449119,values,3,ngx_stream_script_compile_t.values,,stream\ngx_stream_script.h,**values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
999,449120,variables,3,ngx_stream_script_compile_t.variables,,stream\ngx_stream_script.h,variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1000,449122,size,3,ngx_stream_script_compile_t.size,,stream\ngx_stream_script.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1001,158308,ngx_http_limit_conn_handler,1,ngx_http_limit_conn_handler,ngx_int_t ngx_http_limit_conn_handler (ngx_http_request_t*),http\modules\ngx_http_limit_conn_module.c,"static ngx_int_t
ngx_http_limit_conn_handler(ngx_http_request_t *r)
{
    size_t                          n;
    uint32_t                        hash;
    ngx_str_t                       key;
    ngx_uint_t                      i;
    ngx_rbtree_node_t              *node;
    ngx_pool_cleanup_t             *cln;
    ngx_http_limit_conn_ctx_t      *ctx;
    ngx_http_limit_conn_node_t     *lc;
    ngx_http_limit_conn_conf_t     *lccf;
    ngx_http_limit_conn_limit_t    *limits;
    ngx_http_limit_conn_cleanup_t  *lccln;

    if (r->main->limit_conn_status) {
        return NGX_DECLINED;
    }

    lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module);
    limits = lccf->limits.elts;

    for (i = 0; i < lccf->limits.nelts; i++) {
        ctx = limits[i].shm_zone->data;

        if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (ke...",179.0,308.0,1.0,37.0,130.0,101,12,86,25,0,39,12,20,6,10,,0,34,2,1,1,ngx_int_t
1002,260708,ngx_http_core_access_phase,1,ngx_http_core_access_phase,"ngx_int_t ngx_http_core_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    if (r != r->main) {
        r->phase_handler = ph->next;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""access phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->satisfy == NGX_HTTP_SATISFY_ALL) {

        if (rc == NGX_OK) {
            r->phase_handler++;
            return NGX_AGAIN;
        }

    } else {
        if (rc == NGX_OK) {
            r->access_code = 0;

            if (r->headers_out.www_authenticate) {
                r->headers_out.www_authenticate->hash = 0;
            }

       ...",1079.0,1143.0,1.0,1.0,65.0,23,6,35,12,0,3,7,8,0,2,,0,1,4,2,2,ngx_int_t
1003,399974,ngx_unknown_error,2,os\unix\ngx_errno.c.ngx_unknown_error,,os\unix\ngx_errno.c,ngx_str_t ngx_unknown_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1004,125543,ngx_flv_header,2,http\modules\ngx_http_flv_module.c.ngx_flv_header,,http\modules\ngx_http_flv_module.c,static u_char[] ngx_flv_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1005,35432,fd,3,ngx_pool_cleanup_file_t.fd,,core\ngx_palloc.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1006,35433,name,3,ngx_pool_cleanup_file_t.name,,core\ngx_palloc.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1007,35434,log,3,ngx_pool_cleanup_file_t.log,,core\ngx_palloc.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1008,248427,ngx_http_xslt_header_filter,1,ngx_http_xslt_header_filter,ngx_int_t ngx_http_xslt_header_filter (ngx_http_request_t*),http\modules\ngx_http_xslt_filter_module.c,"static ngx_int_t
ngx_http_xslt_header_filter(ngx_http_request_t *r)
{
    ngx_http_xslt_filter_ctx_t       *ctx;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""xslt filter header"");

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_xslt_filter_module);

    if (conf->sheets.nelts == 0
        || ngx_http_test_content_type(r, &conf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_xslt_filter_module);

    if (ctx) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_xslt_filter_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_xslt_filter_module);

    r->main_filter_need_in_memory = 1;

    return NGX_OK;
}",201.0,238.0,1.0,1.0,38.0,20,7,29,10,0,8,5,5,3,2,,0,8,2,1,1,ngx_int_t
1009,399973,ngx_sys_errlist,2,os\unix\ngx_errno.c.ngx_sys_errlist,,os\unix\ngx_errno.c,ngx_str_t* ngx_sys_errlist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1010,375397,out,3,ngx_mail_session_t.out,,mail\ngx_mail.h,out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
1011,375398,buffer,3,ngx_mail_session_t.buffer,,mail\ngx_mail.h,*buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1012,449127,conf_prefix,3,ngx_stream_script_compile_t.conf_prefix,,stream\ngx_stream_script.h,conf_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1013,449128,root_prefix,3,ngx_stream_script_compile_t.root_prefix,,stream\ngx_stream_script.h,root_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1014,375402,resolver_ctx,3,ngx_mail_session_t.resolver_ctx,,mail\ngx_mail.h,*resolver_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1015,399979,ngx_strerror,1,ngx_strerror,"u_char ngx_strerror (ngx_err_t,u_char*,size_t)",os\win32\ngx_errno.c,"u_char *
ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
{
    u_int          len;
    static u_long  lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

    if (size == 0) {
        return errstr;
    }

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, err, lang, (char *) errstr, size, NULL);

    if (len == 0 && lang) {

        /*
         * Try to use English messages first and fallback to a language,
         * based on locale: non-English Windows have no English messages
         * at all.  This way allows to use English messages at least on
         * Windows with MUI.
         */

        lang = 0;

        len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL, err, lang, (char *) errstr, size, NULL);
    }

    if (len == 0) {
        return ngx_snprintf(errstr, size,
                            ""FormatMessage() error:(%d)"", GetLastError());
    }

    /* remove "".\r\n\0"" */
    while (errstr[len] == '\0...",12.0,53.0,1.0,1.0,42.0,10,7,12,7,2,4,1,1,0,0,,0,4,6,3,3,u_char
1016,375404,mail_state,3,ngx_mail_session_t.mail_state,,mail\ngx_mail.h,mail_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1017,449133,lengths,3,ngx_stream_complex_value_t.lengths,,stream\ngx_stream_script.h,*lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1018,375406,blocked,3,ngx_mail_session_t.blocked,,mail\ngx_mail.h,blocked:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1019,375407,quit,3,ngx_mail_session_t.quit,,mail\ngx_mail.h,quit:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1020,96880,ngx_event_move_posted_next,1,ngx_event_move_posted_next,void ngx_event_move_posted_next (ngx_cycle_t*),event\ngx_event_posted.c,"void
ngx_event_move_posted_next(ngx_cycle_t *cycle)
{
    ngx_queue_t  *q;
    ngx_event_t  *ev;

    for (q = ngx_queue_head(&ngx_posted_next_events);
         q != ngx_queue_sentinel(&ngx_posted_next_events);
         q = ngx_queue_next(q))
    {
        ev = ngx_queue_data(q, ngx_event_t, queue);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                      ""posted next event %p"", ev);

        ev->ready = 1;
        ev->available = -1;
    }

    ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);
    ngx_queue_init(&ngx_posted_next_events);
}",39.0,60.0,1.0,1.0,22.0,14,5,16,8,1,5,2,2,1,0,,0,5,2,1,1,void
1021,449137,u,3,ngx_stream_complex_value_t.u,,stream\ngx_stream_script.h,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1022,375409,backslash,3,ngx_mail_session_t.backslash,,mail\ngx_mail.h,backslash:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1023,19066,ngx_hash_find_combined,1,ngx_hash_find_combined,"void* ngx_hash_find_combined (ngx_hash_combined_t*,ngx_uint_t,u_char*,size_t)",core\ngx_hash.c,"void *
ngx_hash_find_combined(ngx_hash_combined_t *hash, ngx_uint_t key, u_char *name,
    size_t len)
{
    void  *value;

    if (hash->hash.buckets) {
        value = ngx_hash_find(&hash->hash, key, name, len);

        if (value) {
            return value;
        }
    }

    if (len == 0) {
        return NULL;
    }

    if (hash->wc_head && hash->wc_head->hash.buckets) {
        value = ngx_hash_find_wc_head(hash->wc_head, name, len);

        if (value) {
            return value;
        }
    }

    if (hash->wc_tail && hash->wc_tail->hash.buckets) {
        value = ngx_hash_find_wc_tail(hash->wc_tail, name, len);

        if (value) {
            return value;
        }
    }

    return NULL;
}",210.0,245.0,1.0,1.0,36.0,20,6,27,6,3,11,8,11,5,3,,0,11,8,4,4,void*
1024,449140,cf,3,ngx_stream_compile_complex_value_t.cf,,stream\ngx_stream_script.h,*cf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1025,449142,complex_value,3,ngx_stream_compile_complex_value_t.complex_value,,stream\ngx_stream_script.h,*complex_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1026,449143,zero,3,ngx_stream_compile_complex_value_t.zero,,stream\ngx_stream_script.h,zero:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1027,92798,ngx_ssl_get_client_verify,1,ngx_ssl_get_client_verify,"ngx_int_t ngx_ssl_get_client_verify (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509        *cert;
    long         rc;
    const char  *str;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        ngx_str_set(s, ""NONE"");
        return NGX_OK;
    }

    X509_free(cert);

    rc = SSL_get_verify_result(c->ssl->connection);

    if (rc == X509_V_OK) {
        if (ngx_ssl_ocsp_get_status(c, &str) == NGX_OK) {
            ngx_str_set(s, ""SUCCESS"");
            return NGX_OK;
        }

    } else {
        str = X509_verify_cert_error_string(rc);
    }

    s->data = ngx_pnalloc(pool, sizeof(""FAILED:"") - 1 + ngx_strlen(str));
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    s->len = ngx_sprintf(s->data, ""FAILED:%s"", str) - s->data;

    return NGX_OK;
}",4920.0,4955.0,1.0,1.0,36.0,22,7,27,10,0,8,5,6,2,3,,0,8,6,3,3,ngx_int_t
1028,375417,salt,3,ngx_mail_session_t.salt,,mail\ngx_mail.h,salt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1029,375418,tag,3,ngx_mail_session_t.tag,,mail\ngx_mail.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1030,375419,tagged_line,3,ngx_mail_session_t.tagged_line,,mail\ngx_mail.h,tagged_line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1031,375420,text,3,ngx_mail_session_t.text,,mail\ngx_mail.h,text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1032,375422,host,3,ngx_mail_session_t.host,,mail\ngx_mail.h,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1033,375426,cmd,3,ngx_mail_session_t.cmd,,mail\ngx_mail.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1034,84613,ngx_ssl_handle_recv,1,ngx_ssl_handle_recv,"ngx_int_t ngx_ssl_handle_recv (ngx_connection_t*,int)",event\ngx_event_openssl.c,"static ngx_int_t
ngx_ssl_handle_recv(ngx_connection_t *c, int n)
{
    int        sslerr;
    ngx_err_t  err;

#ifndef SSL_OP_NO_RENEGOTIATION

    if (c->ssl->renegotiation) {
        /*
         * disable renegotiation (CVE-2009-3555):
         * OpenSSL (at least up to 0.9.8l) does not handle disabled
         * renegotiation gracefully, so drop connection here
         */

        ngx_log_error(NGX_LOG_NOTICE, c->log, 0, ""SSL renegotiation disabled"");

        while (ERR_peek_error()) {
            ngx_ssl_error(NGX_LOG_DEBUG, c->log, 0,
                          ""ignoring stale global SSL error"");
        }

        ERR_clear_error();

        c->ssl->no_wait_shutdown = 1;
        c->ssl->no_send_shutdown = 1;

        return NGX_ERROR;
    }

#endif

    if (n > 0) {

        if (c->ssl->saved_write_handler) {

            c->write->handler = c->ssl->saved_write_handler;
            c->ssl->saved_write_handler = NULL;
            c->write->ready = 1;

            if (ngx_handl...",2242.0,2352.0,1.0,1.0,111.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1035,375427,command,3,ngx_mail_session_t.command,,mail\ngx_mail.h,command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1036,375428,args,3,ngx_mail_session_t.args,,mail\ngx_mail.h,args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1037,125576,ngx_http_flv_handler,1,ngx_http_flv_handler,ngx_int_t ngx_http_flv_handler (ngx_http_request_t*),http\modules\ngx_http_flv_module.c,"static ngx_int_t
ngx_http_flv_handler(ngx_http_request_t *r)
{
    u_char                    *last;
    off_t                      start, len;
    size_t                     root;
    ngx_int_t                  rc;
    ngx_uint_t                 level, i;
    ngx_str_t                  path, value;
    ngx_log_t                 *log;
    ngx_buf_t                 *b;
    ngx_chain_t                out[2];
    ngx_open_file_info_t       of;
    ngx_http_core_loc_conf_t  *clcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    if (r->uri.data[r->uri.len - 1] == '/') {
        return NGX_DECLINED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    last = ngx_http_map_uri_to_path(r, &path, &root, 0);
    if (last == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    log = r->connection->log;

    path.len = last - path.data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, l...",61.0,254.0,1.0,1.0,194.0,187,18,184,38,0,37,25,31,8,12,,0,35,2,1,1,ngx_int_t
1038,375430,state,3,ngx_mail_session_t.state,,mail\ngx_mail.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1039,318086,ngx_http_upstream_init_round_robin,1,ngx_http_upstream_init_round_robin,"ngx_int_t ngx_http_upstream_init_round_robin (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)",http\ngx_http_upstream_round_robin.c,"ngx_int_t
ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_url_t                      u;
    ngx_uint_t                     i, j, n, w;
    ngx_http_upstream_server_t    *server;
    ngx_http_upstream_rr_peer_t   *peer, **peerp;
    ngx_http_upstream_rr_peers_t  *peers, *backup;

    us->peer.init = ngx_http_upstream_init_round_robin_peer;

    if (us->servers) {
        server = us->servers->elts;

        n = 0;
        w = 0;

        for (i = 0; i < us->servers->nelts; i++) {
            if (server[i].backup) {
                continue;
            }

            n += server[i].naddrs;
            w += server[i].naddrs * server[i].weight;
        }

        if (n == 0) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                          ""no servers in upstream \""%V\"" in %s:%ui"",
                          &us->host, us->file_name, us->line);
            return NGX_ERROR;
        }

        peers = ngx_pcalloc(cf->pool,...",30.0,240.0,1.0,1.0,211.0,368,14,310,19,2,19,28,47,3,10,,0,16,4,2,2,ngx_int_t
1040,375431,cmd_start,3,ngx_mail_session_t.cmd_start,,mail\ngx_mail.h,*cmd_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1041,375432,arg_start,3,ngx_mail_session_t.arg_start,,mail\ngx_mail.h,*arg_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
1042,449159,len,3,ngx_stream_script_copy_code_t.len,,stream\ngx_stream_script.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1043,449163,index,3,ngx_stream_script_var_code_t.index,,stream\ngx_stream_script.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1044,375433,arg_end,3,ngx_mail_session_t.arg_end,,mail\ngx_mail.h,*arg_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1045,252556,ngx_http_add_addresses,1,ngx_http_add_addresses,"ngx_int_t ngx_http_add_addresses (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)",http\ngx_http.c,"static ngx_int_t
ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ngx_uint_t             i, default_server, proxy_protocol;
    ngx_http_conf_addr_t  *addr;
#if (NGX_HTTP_SSL)
    ngx_uint_t             ssl;
#endif
#if (NGX_HTTP_V2)
    ngx_uint_t             http2;
#endif

    /*
     * we cannot compare whole sockaddr struct's as kernel
     * may fill some fields in inherited sockaddr struct's
     */

    addr = port->addrs.elts;

    for (i = 0; i < port->addrs.nelts; i++) {

        if (ngx_cmp_sockaddr(lsopt->sockaddr, lsopt->socklen,
                             addr[i].opt.sockaddr,
                             addr[i].opt.socklen, 0)
            != NGX_OK)
        {
            continue;
        }

        /* the address is already in the address list */

        if (ngx_http_add_server(cf, cscf, &addr[i]) != NGX_OK) {
            return NGX_ERROR;
        }

        /* preserve defau...",1190.0,1280.0,1.0,1.0,91.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
1046,400015,ngx_strerror_init,1,ngx_strerror_init,ngx_int_t ngx_strerror_init (void),os\win32\ngx_errno.c,"ngx_int_t
ngx_strerror_init(void)
{
    return NGX_OK;
}",56.0,60.0,1.0,1.0,5.0,18,7,34,11,1,5,6,5,1,1,,0,4,2,1,1,ngx_int_t
1047,387732,ngx_mail_pop3_user,1,ngx_mail_pop3_user,"ngx_int_t ngx_mail_pop3_user (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts != 1) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;
    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""pop3 login: \""%V\"""", &s->login);

    s->mail_state = ngx_pop3_user;

    return NGX_OK;
}",282.0,312.0,1.0,1.0,31.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1048,14996,ngx_shared_memory_add,1,ngx_shared_memory_add,"ngx_shm_zone_t ngx_shared_memory_add (ngx_conf_t*,ngx_str_t*,size_t,void*)",core\ngx_cycle.c,"ngx_shm_zone_t *
ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name, size_t size, void *tag)
{
    ngx_uint_t        i;
    ngx_shm_zone_t   *shm_zone;
    ngx_list_part_t  *part;

    part = &cf->cycle->shared_memory.part;
    shm_zone = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            shm_zone = part->elts;
            i = 0;
        }

        if (name->len != shm_zone[i].shm.name.len) {
            continue;
        }

        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)
            != 0)
        {
            continue;
        }

        if (tag != shm_zone[i].tag) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                            ""the shared memory zone \""%V\"" is ""
                            ""already declared for a different use"",
                            &shm_zone[i].shm.name);
      ...",1278.0,1349.0,1.0,1.0,72.0,91,11,71,9,0,6,13,18,3,3,,0,4,8,4,4,ngx_shm_zone_t
1049,252564,ngx_http_add_address,1,ngx_http_add_address,"ngx_int_t ngx_http_add_address (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)",http\ngx_http.c,"static ngx_int_t
ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ngx_http_conf_addr_t  *addr;

    if (port->addrs.elts == NULL) {
        if (ngx_array_init(&port->addrs, cf->temp_pool, 4,
                           sizeof(ngx_http_conf_addr_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

#if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \
     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \
     && !defined TLSEXT_TYPE_next_proto_neg)

    if (lsopt->http2 && lsopt->ssl) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""nginx was built with OpenSSL that lacks ALPN ""
                           ""and NPN support, HTTP/2 is not enabled for %V"",
                           &lsopt->addr_text);
    }

#endif

    addr = ngx_array_push(&port->addrs);
    if (addr == NULL) {
        ret...",1288.0,1334.0,1.0,1.0,47.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
1050,387738,ngx_mail_pop3_pass,1,ngx_mail_pop3_pass,"ngx_int_t ngx_mail_pop3_pass (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

    if (s->args.nelts != 1) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;
    s->passwd.len = arg[0].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[0].data, s->passwd.len);

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""pop3 passwd: \""%V\"""", &s->passwd);
#endif

    return NGX_DONE;
}",315.0,339.0,1.0,1.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1051,84634,ngx_ssl_connection_error,1,ngx_ssl_connection_error,"void ngx_ssl_connection_error (ngx_connection_t*,int,ngx_err_t,char*)",event\ngx_event_openssl.c,"static void
ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,
    char *text)
{
    int         n;
    ngx_uint_t  level;

    level = NGX_LOG_CRIT;

    if (sslerr == SSL_ERROR_SYSCALL) {

        if (err == NGX_ECONNRESET
#if (NGX_WIN32)
            || err == NGX_ECONNABORTED
#endif
            || err == NGX_EPIPE
            || err == NGX_ENOTCONN
            || err == NGX_ETIMEDOUT
            || err == NGX_ECONNREFUSED
            || err == NGX_ENETDOWN
            || err == NGX_ENETUNREACH
            || err == NGX_EHOSTDOWN
            || err == NGX_EHOSTUNREACH)
        {
            switch (c->log_error) {

            case NGX_ERROR_IGNORE_ECONNRESET:
            case NGX_ERROR_INFO:
                level = NGX_LOG_INFO;
                break;

            case NGX_ERROR_ERR:
                level = NGX_LOG_ERR;
                break;

            default:
                break;
            }
        }

    } else if (sslerr == SSL_ERROR_SSL) {

    ...",2891.0,3045.0,1.0,1.0,155.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,void
1052,387744,ngx_mail_pop3_capa,1,ngx_mail_pop3_capa,"ngx_int_t ngx_mail_pop3_capa (ngx_mail_session_t*,ngx_connection_t*,ngx_int_t)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c, ngx_int_t stls)
{
    ngx_mail_pop3_srv_conf_t  *pscf;

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

#if (NGX_MAIL_SSL)

    if (stls && c->ssl == NULL) {
        ngx_mail_ssl_conf_t  *sslcf;

        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {
            s->out = pscf->starttls_capability;
            return NGX_OK;
        }

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {
            s->out = pscf->starttls_only_capability;
            return NGX_OK;
        }
    }

#endif

    s->out = pscf->capability;
    return NGX_OK;
}",342.0,371.0,1.0,1.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1053,84642,ngx_ssl_clear_error,1,ngx_ssl_clear_error,void ngx_ssl_clear_error (ngx_log_t*),event\ngx_event_openssl.c,"static void
ngx_ssl_clear_error(ngx_log_t *log)
{
    while (ERR_peek_error()) {
        ngx_ssl_error(NGX_LOG_ALERT, log, 0, ""ignoring stale global SSL error"");
    }

    ERR_clear_error();
}",3048.0,3056.0,1.0,1.0,9.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
1054,150183,ngx_http_headers_filter_module,2,http\modules\ngx_http_headers_filter_module.c.ngx_http_headers_filter_module,,http\modules\ngx_http_headers_filter_module.c,ngx_module_t ngx_http_headers_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1055,387751,ngx_mail_pop3_stls,1,ngx_mail_pop3_stls,"ngx_int_t ngx_mail_pop3_stls (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {
            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",374.0,391.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1056,84647,ngx_ssl_session_id_context,1,ngx_ssl_session_id_context,"ngx_int_t ngx_ssl_session_id_context (ngx_ssl_t*,ngx_str_t*,ngx_array_t*)",event\ngx_event_openssl.c,"static ngx_int_t
ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ngx_array_t *certificates)
{
    int                   n, i;
    X509                 *cert;
    X509_NAME            *name;
    ngx_str_t            *certs;
    ngx_uint_t            k;
    EVP_MD_CTX           *md;
    unsigned int          len;
    STACK_OF(X509_NAME)  *list;
    u_char                buf[EVP_MAX_MD_SIZE];

    /*
     * Session ID context is set based on the string provided,
     * the server certificates, and the client CA list.
     */

    md = EVP_MD_CTX_create();
    if (md == NULL) {
        return NGX_ERROR;
    }

    if (EVP_DigestInit_ex(md, EVP_sha1(), NULL) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""EVP_DigestInit_ex() failed"");
        goto failed;
    }

    if (EVP_DigestUpdate(md, sess_ctx->data, sess_ctx->len) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""EVP_DigestUpdate() failed"");
      ...",3193.0,3307.0,1.0,1.0,115.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1057,387757,ngx_mail_pop3_apop,1,ngx_mail_pop3_apop,"ngx_int_t ngx_mail_pop3_apop (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg;
    ngx_mail_pop3_srv_conf_t  *pscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts != 2) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

    if (!(pscf->auth_methods & NGX_MAIL_AUTH_APOP_ENABLED)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;

    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    s->passwd.len = arg[1].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);
...",394.0,440.0,1.0,1.0,47.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1058,387763,ngx_mail_pop3_auth,1,ngx_mail_pop3_auth,"ngx_int_t ngx_mail_pop3_auth (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"static ngx_int_t
ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_pop3_srv_conf_t  *pscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

    if (s->args.nelts == 0) {
        s->out = pscf->auth_capability;
        s->state = 0;

        return NGX_OK;
    }

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, pop3_username);
        s->mail_state = ngx_pop3_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, pop3_password);
        s->mail_state = ngx_pop3_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, pop3_next);
        s->mail_state = ngx_pop3_auth_plain;

        ...",443.0,515.0,1.0,1.0,73.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1059,35514,ngx_parse_size,1,ngx_parse_size,ssize_t ngx_parse_size (ngx_str_t*),core\ngx_parse.c,"ssize_t
ngx_parse_size(ngx_str_t *line)
{
    u_char   unit;
    size_t   len;
    ssize_t  size, scale, max;

    len = line->len;

    if (len == 0) {
        return NGX_ERROR;
    }

    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        max = NGX_MAX_SIZE_T_VALUE / 1024;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        max = NGX_MAX_SIZE_T_VALUE / (1024 * 1024);
        scale = 1024 * 1024;
        break;

    default:
        max = NGX_MAX_SIZE_T_VALUE;
        scale = 1;
    }

    size = ngx_atosz(line->data, len);
    if (size == NGX_ERROR || size > max) {
        return NGX_ERROR;
    }

    size *= scale;

    return size;
}",12.0,55.0,1.0,1.0,44.0,25,11,30,8,6,4,6,4,0,1,,0,4,2,1,1,ssize_t
1060,150202,ngx_http_headers_filter,1,ngx_http_headers_filter,ngx_int_t ngx_http_headers_filter (ngx_http_request_t*),http\modules\ngx_http_headers_filter_module.c,"static ngx_int_t
ngx_http_headers_filter(ngx_http_request_t *r)
{
    ngx_str_t                 value;
    ngx_uint_t                i, safe_status;
    ngx_http_header_val_t    *h;
    ngx_http_headers_conf_t  *conf;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module);

    if (conf->expires == NGX_HTTP_EXPIRES_OFF
        && conf->headers == NULL
        && conf->trailers == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    switch (r->headers_out.status) {

    case NGX_HTTP_OK:
    case NGX_HTTP_CREATED:
    case NGX_HTTP_NO_CONTENT:
    case NGX_HTTP_PARTIAL_CONTENT:
    case NGX_HTTP_MOVED_PERMANENTLY:
    case NGX_HTTP_MOVED_TEMPORARILY:
    case NGX_HTTP_SEE_OTHER:
    case NGX_HTTP_NOT_MODIFIED:
    case NGX_HTTP_TEMPORARY_REDIRECT:
    case NGX_HTTP_PERMANENT_REDIRECT:
        safe_status = 1;
        break;

    default:
        safe_status = 0;
       ...",165.0,244.0,1.0,1.0,80.0,58,10,67,21,0,13,19,25,10,2,,0,13,2,1,1,ngx_int_t
1061,84668,ngx_ssl_remove_session,1,ngx_ssl_remove_session,"void ngx_ssl_remove_session (SSL_CTX*,ngx_ssl_session_t*)",event\ngx_event_openssl.c,"static void
ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
{
    u_char                   *id;
    uint32_t                  hash;
    ngx_int_t                 rc;
    unsigned int              len;
    ngx_shm_zone_t           *shm_zone;
    ngx_slab_pool_t          *shpool;
    ngx_rbtree_node_t        *node, *sentinel;
    ngx_ssl_sess_id_t        *sess_id;
    ngx_ssl_session_cache_t  *cache;

    shm_zone = SSL_CTX_get_ex_data(ssl, ngx_ssl_session_cache_index);

    if (shm_zone == NULL) {
        return;
    }

    cache = shm_zone->data;

    id = (u_char *) SSL_SESSION_get_id(sess, &len);

    hash = ngx_crc32_short(id, len);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
                   ""ssl remove session: %08XD:%ud"", hash, len);

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    ngx_shmtx_lock(&shpool->mutex);

    node = cache->session_rbtree.root;
    sentinel = cache->session_rbtree.sentinel;

    while (node != sentinel) {

    ...",3626.0,3700.0,1.0,1.0,75.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1062,387775,ngx_mail_pop3_init_session,1,ngx_mail_pop3_init_session,"void ngx_mail_pop3_init_session (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_pop3_handler.c,"void
ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    u_char                    *p;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_pop3_srv_conf_t  *pscf;

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    if (pscf->auth_methods
        & (NGX_MAIL_AUTH_APOP_ENABLED|NGX_MAIL_AUTH_CRAM_MD5_ENABLED))
    {
        if (ngx_mail_salt(s, c, cscf) != NGX_OK) {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_greeting) + s->salt.len);
        if (s->out.data == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        p = ngx_cpymem(s->out.data, pop3_greeting, sizeof(pop3_greeting) - 3);
        *p++ = ' ';
        p = ngx_cpymem(p, s->salt.data, s->salt.len);

        s->out.len = p - s->out.data;

    } else {
        ngx_str_set(&s->out,...",32.0,75.0,1.0,1.0,44.0,44,12,40,12,0,17,5,7,4,7,,0,13,4,2,2,void
1063,248518,ngx_http_xslt_body_filter,1,ngx_http_xslt_body_filter,"ngx_int_t ngx_http_xslt_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_xslt_filter_module.c,"static ngx_int_t
ngx_http_xslt_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                          wellFormed;
    ngx_chain_t                 *cl;
    ngx_http_xslt_filter_ctx_t  *ctx;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""xslt filter body"");

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_xslt_filter_module);

    if (ctx == NULL || ctx->done) {
        return ngx_http_next_body_filter(r, in);
    }

    for (cl = in; cl; cl = cl->next) {

        if (ngx_http_xslt_add_chunk(r, ctx, cl->buf) != NGX_OK) {

            if (ctx->ctxt->myDoc) {

#if (NGX_HTTP_XSLT_REUSE_DTD)
                ctx->ctxt->myDoc->extSubset = NULL;
#endif
                xmlFreeDoc(ctx->ctxt->myDoc);
            }

            xmlFreeParserCtxt(ctx->ctxt);

            return ngx_http_xslt_send(r, ctx, NULL);
        }

        if (cl->buf->last_buf || cl->buf->last_in...",241.0,305.0,1.0,5.0,65.0,38,5,50,10,0,18,8,14,3,6,,0,14,4,2,2,ngx_int_t
1064,449124,complete_lengths,3,ngx_stream_script_compile_t.complete_lengths,,stream\ngx_stream_script.h,complete_lengths:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1065,96973,ngx_event_timer_rbtree,2,event\ngx_event_timer.c.ngx_event_timer_rbtree,,event\ngx_event_timer.c,ngx_rbtree_t ngx_event_timer_rbtree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1066,96974,ngx_event_timer_sentinel,2,event\ngx_event_timer.c.ngx_event_timer_sentinel,,event\ngx_event_timer.c,ngx_rbtree_node_t ngx_event_timer_sentinel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1067,96975,ngx_event_timer_init,1,ngx_event_timer_init,ngx_int_t ngx_event_timer_init (ngx_log_t*),event\ngx_event_timer.c,"ngx_int_t
ngx_event_timer_init(ngx_log_t *log)
{
    ngx_rbtree_init(&ngx_event_timer_rbtree, &ngx_event_timer_sentinel,
                    ngx_rbtree_insert_timer_value);

    return NGX_OK;
}",22.0,29.0,1.0,1.0,8.0,2,1,4,4,0,2,1,1,0,0,,0,2,2,1,1,ngx_int_t
1068,84688,ngx_ssl_check_name,1,ngx_ssl_check_name,"ngx_int_t ngx_ssl_check_name (ngx_str_t*,ASN1_STRING*)",event\ngx_event_openssl.c,"static ngx_int_t
ngx_ssl_check_name(ngx_str_t *name, ASN1_STRING *pattern)
{
    u_char  *s, *p, *end;
    size_t   slen, plen;

    s = name->data;
    slen = name->len;

    p = ASN1_STRING_data(pattern);
    plen = ASN1_STRING_length(pattern);

    if (slen == plen && ngx_strncasecmp(s, p, plen) == 0) {
        return NGX_OK;
    }

    if (plen > 2 && p[0] == '*' && p[1] == '.') {
        plen -= 1;
        p += 1;

        end = s + slen;
        s = ngx_strlchr(s, end, '.');

        if (s == NULL) {
            return NGX_ERROR;
        }

        slen = end - s;

        if (plen == slen && ngx_strncasecmp(s, p, plen) == 0) {
            return NGX_OK;
        }
    }

    return NGX_ERROR;
}",4226.0,4261.0,1.0,1.0,36.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1069,449125,complete_values,3,ngx_stream_script_compile_t.complete_values,,stream\ngx_stream_script.h,complete_values:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1070,449126,zero,3,ngx_stream_script_compile_t.zero,,stream\ngx_stream_script.h,zero:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1071,375509,ngx_mail_salt,1,ngx_mail_salt,"ngx_int_t ngx_mail_salt (ngx_mail_session_t*,ngx_connection_t*,ngx_mail_core_srv_conf_t*)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_mail_core_srv_conf_t *cscf)
{
    s->salt.data = ngx_pnalloc(c->pool,
                               sizeof("" <18446744073709551616.@>"" CRLF) - 1
                               + NGX_TIME_T_LEN
                               + cscf->server_name.len);
    if (s->salt.data == NULL) {
        return NGX_ERROR;
    }

    s->salt.len = ngx_sprintf(s->salt.data, ""<%ul.%T@%V>"" CRLF,
                              ngx_random(), ngx_time(), &cscf->server_name)
                  - s->salt.data;

    return NGX_OK;
}",357.0,374.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1072,19158,ngx_hash_init,1,ngx_hash_init,"ngx_int_t ngx_hash_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)",core\ngx_hash.c,"ngx_int_t
ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts)
{
    u_char          *elts;
    size_t           len;
    u_short         *test;
    ngx_uint_t       i, n, key, size, start, bucket_size;
    ngx_hash_elt_t  *elt, **buckets;

    if (hinit->max_size == 0) {
        ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,
                      ""could not build %s, you should ""
                      ""increase %s_max_size: %i"",
                      hinit->name, hinit->name, hinit->max_size);
        return NGX_ERROR;
    }

    if (hinit->bucket_size > 65536 - ngx_cacheline_size) {
        ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,
                      ""could not build %s, too large ""
                      ""%s_bucket_size: %i"",
                      hinit->name, hinit->name, hinit->bucket_size);
        return NGX_ERROR;
    }

    for (n = 0; n < nelts; n++) {
        if (hinit->bucket_size < NGX_HASH_ELT_SIZE(&names[n]) + sizeof(void *))
   ...",251.0,482.0,1.0,33.0,232.0,256,19,245,24,6,55,36,40,8,9,,0,49,6,3,3,ngx_int_t
1073,84694,ngx_ssl_parse_time,1,ngx_ssl_parse_time,time_t ngx_ssl_parse_time (ASN1_TIME*),event\ngx_event_openssl.c,"static time_t
ngx_ssl_parse_time(
#if OPENSSL_VERSION_NUMBER > 0x10100000L
    const
#endif
    ASN1_TIME *asn1time)
{
    BIO     *bio;
    char    *value;
    size_t   len;
    time_t   time;

    /*
     * OpenSSL doesn't provide a way to convert ASN1_TIME
     * into time_t.  To do this, we use ASN1_TIME_print(),
     * which uses the ""MMM DD HH:MM:SS YYYY [GMT]"" format (e.g.,
     * ""Feb  3 00:55:52 2015 GMT""), and parse the result.
     */

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        return NGX_ERROR;
    }

    /* fake weekday prepended to match C asctime() format */

    BIO_write(bio, ""Tue "", sizeof(""Tue "") - 1);
    ASN1_TIME_print(bio, asn1time);
    len = BIO_get_mem_data(bio, &value);

    time = ngx_parse_http_time((u_char *) value, len);

    BIO_free(bio);

    return time;
}",5092.0,5127.0,1.0,1.0,36.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,time_t
1074,96988,ngx_event_find_timer,1,ngx_event_find_timer,ngx_msec_t ngx_event_find_timer (void),event\ngx_event_timer.c,"ngx_msec_t
ngx_event_find_timer(void)
{
    ngx_msec_int_t      timer;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    if (ngx_event_timer_rbtree.root == &ngx_event_timer_sentinel) {
        return NGX_TIMER_INFINITE;
    }

    root = ngx_event_timer_rbtree.root;
    sentinel = ngx_event_timer_rbtree.sentinel;

    node = ngx_rbtree_min(root, sentinel);

    timer = (ngx_msec_int_t) (node->key - ngx_current_msec);

    return (ngx_msec_t) (timer > 0 ? timer : 0);
}",32.0,50.0,1.0,1.0,19.0,13,8,15,8,0,4,2,2,2,0,,0,4,2,1,1,ngx_msec_t
1075,375516,ngx_mail_auth_plain,1,ngx_mail_auth_plain,"ngx_int_t ngx_mail_auth_plain (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
{
    u_char     *p, *last;
    ngx_str_t  *arg, plain;

    arg = s->args.elts;

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth plain: \""%V\"""", &arg[n]);
#endif

    plain.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (plain.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&plain, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH PLAIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    p = plain.data;
    last = p + plain.len;

    while (p < last && *p++) { /* void */ }

    if (p == last) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
                      ""client sent invalid login in AUTH PLAIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.data = p;

 ...",400.0,456.0,1.0,1.0,57.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1076,92898,ngx_ssl_get_client_v_start,1,ngx_ssl_get_client_v_start,"ngx_int_t ngx_ssl_get_client_v_start (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO     *bio;
    X509    *cert;
    size_t   len;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    ASN1_TIME_print(bio, X509_get0_notBefore(cert));
#else
    ASN1_TIME_print(bio, X509_get_notBefore(cert));
#endif

    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",4958.0,4999.0,1.0,1.0,42.0,16,3,31,9,0,6,4,4,1,1,,0,6,6,3,3,ngx_int_t
1077,375523,ngx_mail_auth_login_username,1,ngx_mail_auth_login_username,"ngx_int_t ngx_mail_auth_login_username (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_auth_login_username(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n)
{
    ngx_str_t  *arg;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login username: \""%V\"""", &arg[n]);

    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->login, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH LOGIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login username: \""%V\"""", &s->login);

    return NGX_OK;
}",459.0,485.0,1.0,1.0,27.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1078,461543,ngx_stream_upstream_get_round_robin_peer,1,ngx_stream_upstream_get_round_robin_peer,"ngx_int_t ngx_stream_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)",stream\ngx_stream_upstream_round_robin.c,"ngx_int_t
ngx_stream_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_rr_peer_data_t *rrp = data;

    ngx_int_t                        rc;
    ngx_uint_t                       i, n;
    ngx_stream_upstream_rr_peer_t   *peer;
    ngx_stream_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get rr peer, try: %ui"", pc->tries);

    pc->connection = NULL;

    peers = rrp->peers;
    ngx_stream_upstream_rr_peers_wlock(peers);

    if (peers->single) {
        peer = peers->peer;

        if (peer->down) {
            goto failed;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
            goto failed;
        }

        rrp->current = peer;

    } else {

        /* there are several peers */

        peer = ngx_stream_upstream_get_peer(rrp);

        if (peer == NULL) {
            goto failed;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, pc->log, 0...",426.0,513.0,1.0,1.0,88.0,55,14,54,13,0,5,9,11,0,0,,0,5,4,2,2,ngx_int_t
1079,375530,ngx_mail_auth_login_password,1,ngx_mail_auth_login_password,"ngx_int_t ngx_mail_auth_login_password (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_auth_login_password(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

    arg = s->args.elts;

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login password: \""%V\"""", &arg[0]);
#endif

    s->passwd.data = ngx_pnalloc(c->pool,
                                 ngx_base64_decoded_length(arg[0].len));
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->passwd, &arg[0]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH LOGIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login password: \""%V\"""", &s->passwd);
#endif

    return NGX_DONE;
}",488.0,518.0,1.0,1.0,31.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1080,449131,value,3,ngx_stream_complex_value_t.value,,stream\ngx_stream_script.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1081,449132,flushes,3,ngx_stream_complex_value_t.flushes,,stream\ngx_stream_script.h,*flushes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1082,6904,ngx_conf_log_error,1,ngx_conf_log_error,"ANY ngx_conf_log_error (ngx_uint_t,ngx_conf_t*,ngx_err_t,char*...)",core\ngx_conf_file.c,"ngx_conf_log_error(ngx_uint_t level, ngx_conf_t *cf, ngx_err_t err,
    const char *fmt, ...)
{
    u_char   errstr[NGX_MAX_CONF_ERRSTR], *p, *last;
    va_list  args;

    last = errstr + NGX_MAX_CONF_ERRSTR;

    va_start(args, fmt);
    p = ngx_vslprintf(errstr, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (cf->conf_file == NULL) {
        ngx_log_error(level, cf->log, 0, ""%*s"", p - errstr, errstr);
        return;
    }

    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {
        ngx_log_error(level, cf->log, 0, ""%*s in command line"",
                      p - errstr, errstr);
        return;
    }

    ngx_log_error(level, cf->log, 0, ""%*s in %s:%ui"",
                  p - errstr, errstr,
                  cf->conf_file->file.name.data, cf->conf_file->line);
}",992.0,1022.0,1.0,1.0,31.0,22,6,37,11,49,5,4,4,0,5,,0,2,8,4,4,ANY
1083,322297,ngx_http_get_flushed_variable,1,ngx_http_get_flushed_variable,"ngx_http_variable_value_t ngx_http_get_flushed_variable (ngx_http_request_t*,ngx_uint_t)",http\ngx_http_variables.c,"ngx_http_variable_value_t *
ngx_http_get_flushed_variable(ngx_http_request_t *r, ngx_uint_t index)
{
    ngx_http_variable_value_t  *v;

    v = &r->variables[index];

    if (v->valid || v->not_found) {
        if (!v->no_cacheable) {
            return v;
        }

        v->valid = 0;
        v->not_found = 0;
    }

    return ngx_http_get_indexed_variable(r, index);
}",649.0,666.0,1.0,1.0,18.0,13,6,11,3,2,1,3,4,0,1,,0,0,4,2,2,ngx_http_variable_value_t
1084,43770,ngx_resolve_addr_done,1,ngx_resolve_addr_done,void ngx_resolve_addr_done (ngx_resolver_ctx_t*),core\ngx_resolver.c,"void
ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx)
{
    ngx_queue_t          *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_t       *r;
    ngx_resolver_ctx_t   *w, **p;
    ngx_resolver_node_t  *rn;

    r = ctx->resolver;

    switch (ctx->addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        tree = &r->addr6_rbtree;
        expire_queue = &r->addr6_expire_queue;
        break;
#endif

    default: /* AF_INET */
        tree = &r->addr_rbtree;
        expire_queue = &r->addr_expire_queue;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve addr done: %i"", ctx->state);

    if (ctx->event && ctx->event->timer_set) {
        ngx_del_timer(ctx->event);
    }

    /* lock addr mutex */

    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) {

        rn = ctx->node;

        if (rn) {
            p = &rn->waiting;
            w = rn->waiting;

            while (w) {
                if (w == ct...",1126.0,1212.0,1.0,1.0,87.0,55,8,54,14,0,10,10,15,1,6,,0,6,2,1,1,void
1085,375544,ngx_mail_auth_cram_md5,1,ngx_mail_auth_cram_md5,"ngx_int_t ngx_mail_auth_cram_md5 (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c)
{
    u_char     *p, *last;
    ngx_str_t  *arg;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth cram-md5: \""%V\"""", &arg[0]);

    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[0].len));
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->login, &arg[0]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH CRAM-MD5 command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    p = s->login.data;
    last = p + s->login.len;

    while (p < last) {
        if (*p++ == ' ') {
            s->login.len = p - s->login.data - 1;
            s->passwd.len = last - p;
            s->passwd.data = p;
            break;
        }
    }

    if (s->passwd.len != 32) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""c...",550.0,596.0,1.0,1.0,47.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1086,449134,values,3,ngx_stream_complex_value_t.values,,stream\ngx_stream_script.h,*values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1087,88830,ngx_ssl_write,1,ngx_ssl_write,"ssize_t ngx_ssl_write (ngx_connection_t*,u_char*,size_t)",event\ngx_event_openssl.c,"ssize_t
ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
{
    int        n, sslerr;
    ngx_err_t  err;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->in_early) {
        return ngx_ssl_write_early(c, data, size);
    }
#endif

    ngx_ssl_clear_error(c->log);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL to write: %uz"", size);

    n = SSL_write(c->ssl->connection, data, size);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_write: %d"", n);

    if (n > 0) {

        if (c->ssl->saved_read_handler) {

            c->read->handler = c->ssl->saved_read_handler;
            c->ssl->saved_read_handler = NULL;
            c->read->ready = 1;

            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
                return NGX_ERROR;
            }

            ngx_post_event(c->read, &ngx_posted_events);
        }

        c->sent += n;

        return n;
    }

    sslerr = SSL_get_error(c->ssl->connection, n);

    err = (sslerr == SSL_ERROR_...",2531.0,2627.0,1.0,1.0,97.0,81,8,73,17,2,5,10,18,3,5,,0,3,6,3,3,ssize_t
1088,375550,ngx_mail_auth_external,1,ngx_mail_auth_external,"ngx_int_t ngx_mail_auth_external (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n)
{
    ngx_str_t  *arg, external;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth external: \""%V\"""", &arg[n]);

    external.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (external.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&external, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH EXTERNAL command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.len = external.len;
    s->login.data = external.data;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth external: \""%V\"""", &s->login);

    s->auth_method = NGX_MAIL_AUTH_EXTERNAL;

    return NGX_DONE;
}",599.0,630.0,1.0,1.0,32.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1089,400136,ngx_file_aio_result,1,ngx_file_aio_result,"ssize_t ngx_file_aio_result (ngx_file_t*,ngx_event_aio_t*,ngx_event_t*)",os\unix\ngx_file_aio_read.c,"static ssize_t
ngx_file_aio_result(ngx_file_t *file, ngx_event_aio_t *aio, ngx_event_t *ev)
{
    int        n;
    ngx_err_t  err;

    n = aio_error(&aio->aiocb);

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""aio_error: fd:%d %d"", file->fd, n);

    if (n == -1) {
        err = ngx_errno;
        aio->err = err;

        ngx_log_error(NGX_LOG_ALERT, file->log, err,
                      ""aio_error(\""%V\"") failed"", &file->name);
        return NGX_ERROR;
    }

    if (n == NGX_EINPROGRESS) {
        if (ev->ready) {
            ev->ready = 0;
            ngx_log_error(NGX_LOG_ALERT, file->log, n,
                          ""aio_read(\""%V\"") still in progress"",
                          &file->name);
        }

        return NGX_AGAIN;
    }

    n = aio_return(&aio->aiocb);

    if (n == -1) {
        err = ngx_errno;
        aio->err = err;
        ev->ready = 1;

        ngx_log_error(NGX_LOG_CRIT, file->log, err,
                      ""aio_return(\""%...",148.0,200.0,1.0,1.0,53.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ssize_t
1090,260873,ngx_http_core_post_access_phase,1,ngx_http_core_post_access_phase,"ngx_int_t ngx_http_core_post_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_post_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_int_t  access_code;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""post access phase: %ui"", r->phase_handler);

    access_code = r->access_code;

    if (access_code) {
        r->access_code = 0;

        if (access_code == NGX_HTTP_FORBIDDEN) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""access forbidden by rule"");
        }

        if (access_code == NGX_HTTP_UNAUTHORIZED) {
            return ngx_http_core_auth_delay(r);
        }

        ngx_http_finalize_request(r, access_code);
        return NGX_OK;
    }

    r->phase_handler++;
    return NGX_AGAIN;
}",1146.0,1175.0,1.0,1.0,30.0,13,4,19,8,0,3,4,6,0,3,,0,0,4,2,2,ngx_int_t
1091,449290,value,3,ngx_stream_split_clients_ctx_t.value,,stream\ngx_stream_split_clients_module.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1092,375563,ngx_mail_send,1,ngx_mail_send,void ngx_mail_send (ngx_event_t*),mail\ngx_mail_handler.c,"void
ngx_mail_send(ngx_event_t *wev)
{
    ngx_int_t                  n;
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_core_srv_conf_t  *cscf;

    c = wev->data;
    s = c->data;

    if (wev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len == 0) {
        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
            ngx_mail_close_connection(c);
        }

        return;
    }

    n = c->send(c, s->out.data, s->out.len);

    if (n > 0) {
        s->out.data += n;
        s->out.len -= n;

        if (s->out.len != 0) {
            goto again;
        }

        if (wev->timer_set) {
            ngx_del_timer(wev);
        }

        if (s->quit) {
            ngx_mail_close_connection(c);
            return;
        }

        if (s->blocked) {
            c->read->handler(c->read);
        }

...",633.0,702.0,1.0,1.0,70.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
1093,449291,parts,3,ngx_stream_split_clients_ctx_t.parts,,stream\ngx_stream_split_clients_module.c,parts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1094,97038,ngx_event_expire_timers,1,ngx_event_expire_timers,void ngx_event_expire_timers (void),event\ngx_event_timer.c,"void
ngx_event_expire_timers(void)
{
    ngx_event_t        *ev;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    sentinel = ngx_event_timer_rbtree.sentinel;

    for ( ;; ) {
        root = ngx_event_timer_rbtree.root;

        if (root == sentinel) {
            return;
        }

        node = ngx_rbtree_min(root, sentinel);

        /* node->key > ngx_current_msec */

        if ((ngx_msec_int_t) (node->key - ngx_current_msec) > 0) {
            return;
        }

        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));

        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                       ""event timer del: %d: %M"",
                       ngx_event_ident(ev->data), ev->timer.key);

        ngx_rbtree_delete(&ngx_event_timer_rbtree, &ev->timer);

#if (NGX_DEBUG)
        ev->timer.left = NULL;
        ev->timer.right = NULL;
        ev->timer.parent = NULL;
#endif

        ev->timer_set = 0;

        ev->timedout = 1;

        ev->handler(ev);
   ...",53.0,96.0,1.0,1.0,44.0,25,8,25,9,1,4,4,6,0,1,,0,3,2,1,1,void
1095,375568,ngx_mail_read_command,1,ngx_mail_read_command,"ngx_int_t ngx_mail_read_command (ngx_mail_session_t*,ngx_connection_t*)",mail\ngx_mail_handler.c,"ngx_int_t
ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ssize_t                    n;
    ngx_int_t                  rc;
    ngx_str_t                  l;
    ngx_mail_core_srv_conf_t  *cscf;

    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);

    if (n == NGX_ERROR || n == 0) {
        ngx_mail_close_connection(c);
        return NGX_ERROR;
    }

    if (n > 0) {
        s->buffer->last += n;
    }

    if (n == NGX_AGAIN) {
        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            ngx_mail_session_internal_server_error(s);
            return NGX_ERROR;
        }

        if (s->buffer->pos == s->buffer->last) {
            return NGX_AGAIN;
        }
    }

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    rc = cscf->protocol->parse_command(s);

    if (rc == NGX_AGAIN) {

        if (s->buffer->last < s->buffer->end) {
            return rc;
        }

        l.len = s->buffer->last - s->buffer->st...",705.0,766.0,1.0,1.0,62.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1096,400148,ngx_file_aio_init,1,ngx_file_aio_init,"ngx_int_t ngx_file_aio_init (ngx_file_t*,ngx_pool_t*)",os\unix\ngx_linux_aio_read.c,"ngx_int_t
ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool)
{
    ngx_event_aio_t  *aio;

    aio = ngx_pcalloc(pool, sizeof(ngx_event_aio_t));
    if (aio == NULL) {
        return NGX_ERROR;
    }

    aio->file = file;
    aio->fd = file->fd;
    aio->event.data = aio;
    aio->event.ready = 1;
    aio->event.log = file->log;

    file->aio = aio;

    return NGX_OK;
}",27.0,46.0,1.0,1.0,20.0,20,5,18,7,1,1,2,2,0,1,,0,1,4,2,2,ngx_int_t
1097,84758,ngx_ssl_connection_index,2,event\ngx_event_openssl.c.ngx_ssl_connection_index,,event\ngx_event_openssl.c,int ngx_ssl_connection_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1098,84759,ngx_ssl_server_conf_index,2,event\ngx_event_openssl.c.ngx_ssl_server_conf_index,,event\ngx_event_openssl.c,int ngx_ssl_server_conf_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1099,84760,ngx_ssl_session_cache_index,2,event\ngx_event_openssl.c.ngx_ssl_session_cache_index,,event\ngx_event_openssl.c,int ngx_ssl_session_cache_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1100,84761,ngx_ssl_session_ticket_keys_index,2,event\ngx_event_openssl.c.ngx_ssl_session_ticket_keys_index,,event\ngx_event_openssl.c,int ngx_ssl_session_ticket_keys_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1101,84762,ngx_ssl_ocsp_index,2,event\ngx_event_openssl.c.ngx_ssl_ocsp_index,,event\ngx_event_openssl.c,int ngx_ssl_ocsp_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1102,84763,ngx_ssl_certificate_index,2,event\ngx_event_openssl.c.ngx_ssl_certificate_index,,event\ngx_event_openssl.c,int ngx_ssl_certificate_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1103,84764,ngx_ssl_next_certificate_index,2,event\ngx_event_openssl.c.ngx_ssl_next_certificate_index,,event\ngx_event_openssl.c,int ngx_ssl_next_certificate_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1104,35612,ngx_parse_offset,1,ngx_parse_offset,off_t ngx_parse_offset (ngx_str_t*),core\ngx_parse.c,"off_t
ngx_parse_offset(ngx_str_t *line)
{
    u_char  unit;
    off_t   offset, scale, max;
    size_t  len;

    len = line->len;

    if (len == 0) {
        return NGX_ERROR;
    }

    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        max = NGX_MAX_OFF_T_VALUE / 1024;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        max = NGX_MAX_OFF_T_VALUE / (1024 * 1024);
        scale = 1024 * 1024;
        break;

    case 'G':
    case 'g':
        len--;
        max = NGX_MAX_OFF_T_VALUE / (1024 * 1024 * 1024);
        scale = 1024 * 1024 * 1024;
        break;

    default:
        max = NGX_MAX_OFF_T_VALUE;
        scale = 1;
    }

    offset = ngx_atoof(line->data, len);
    if (offset == NGX_ERROR || offset > max) {
        return NGX_ERROR;
    }

    offset *= scale;

    return offset;
}",58.0,108.0,1.0,1.0,51.0,33,11,34,8,1,4,7,4,0,1,,0,4,2,1,1,off_t
1105,84766,ngx_ssl_stapling_index,2,event\ngx_event_openssl.c.ngx_ssl_stapling_index,,event\ngx_event_openssl.c,int ngx_ssl_stapling_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1106,84767,ngx_ssl_init,1,ngx_ssl_init,ngx_int_t ngx_ssl_init (ngx_log_t*),event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_init(ngx_log_t *log)
{
#if OPENSSL_VERSION_NUMBER >= 0x10100003L

    if (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, NULL) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, log, 0, ""OPENSSL_init_ssl() failed"");
        return NGX_ERROR;
    }

    /*
     * OPENSSL_init_ssl() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

#else

    OPENSSL_config(NULL);

    SSL_library_init();
    SSL_load_error_strings();

    OpenSSL_add_all_algorithms();

#endif

#ifndef SSL_OP_NO_COMPRESSION
    {
    /*
     * Disable gzip compression in OpenSSL prior to 1.0.0 version,
     * this saves about 522K per connection.
     */
    int                  n;
    STACK_OF(SSL_COMP)  *ssl_comp_methods;

    ssl_comp_methods = SSL_COMP_get_compression_methods();
    n = sk_SSL_COMP_num(ssl_comp_methods);

    while (n--) {
        (void) sk_SSL_COMP_pop(ssl_comp_methods);
    }
    }
#endif

    ngx_ssl_connection_index = SSL_get_ex_new_ind...",140.0,255.0,1.0,1.0,116.0,32,6,90,17,0,27,11,11,9,9,,0,18,2,1,1,ngx_int_t
1107,84765,ngx_ssl_certificate_name_index,2,event\ngx_event_openssl.c.ngx_ssl_certificate_name_index,,event\ngx_event_openssl.c,int ngx_ssl_certificate_name_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1108,449141,value,3,ngx_stream_compile_complex_value_t.value,,stream\ngx_stream_script.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1109,375580,ngx_mail_close_connection,1,ngx_mail_close_connection,void ngx_mail_close_connection (ngx_connection_t*),mail\ngx_mail_handler.c,"void
ngx_mail_close_connection(ngx_connection_t *c)
{
    ngx_pool_t  *pool;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""close mail connection: %d"", c->fd);

#if (NGX_MAIL_SSL)

    if (c->ssl) {
        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_mail_close_connection;
            return;
        }
    }

#endif

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif

    c->destroyed = 1;

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}",805.0,835.0,1.0,1.0,31.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
1110,375585,ngx_mail_session_internal_server_error,1,ngx_mail_session_internal_server_error,void ngx_mail_session_internal_server_error (ngx_mail_session_t*),mail\ngx_mail_handler.c,"void
ngx_mail_session_internal_server_error(ngx_mail_session_t *s)
{
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    s->out = cscf->protocol->internal_server_error;
    s->quit = 1;

    ngx_mail_send(s->connection->write);
}",791.0,802.0,1.0,1.0,12.0,0,0,0,0,9,0,1,1,0,0,,0,0,2,1,1,void
1111,301861,ngx_http_script_complex_value_code,1,ngx_http_script_complex_value_code,void ngx_http_script_complex_value_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_complex_value_code(ngx_http_script_engine_t *e)
{
    size_t                                 len;
    ngx_http_script_engine_t               le;
    ngx_http_script_len_code_pt            lcode;
    ngx_http_script_complex_value_code_t  *code;

    code = (ngx_http_script_complex_value_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_complex_value_code_t);

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script complex value"");

    ngx_memzero(&le, sizeof(ngx_http_script_engine_t));

    le.ip = code->lengths->elts;
    le.line = e->line;
    le.request = e->request;
    le.quote = e->quote;

    for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) {
        lcode = *(ngx_http_script_len_code_pt *) le.ip;
    }

    e->buf.len = len;
    e->buf.data = ngx_pnalloc(e->request->pool, len);
    if (e->buf.data == NULL) {
        e->ip = ngx_http_script_exit;
        e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;
 ...",1712.0,1751.0,1.0,16.0,40.0,65,10,38,11,0,28,3,3,2,1,,0,28,2,1,1,void
1112,322343,ngx_http_get_variable,1,ngx_http_get_variable,"ngx_http_variable_value_t ngx_http_get_variable (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)",http\ngx_http_variables.c,"ngx_http_variable_value_t *
ngx_http_get_variable(ngx_http_request_t *r, ngx_str_t *name, ngx_uint_t key)
{
    size_t                      len;
    ngx_uint_t                  i, n;
    ngx_http_variable_t        *v;
    ngx_http_variable_value_t  *vv;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    v = ngx_hash_find(&cmcf->variables_hash, key, name->data, name->len);

    if (v) {
        if (v->flags & NGX_HTTP_VAR_INDEXED) {
            return ngx_http_get_flushed_variable(r, v->index);
        }

        if (ngx_http_variable_depth == 0) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""cycle while evaluating variable \""%V\"""", name);
            return NULL;
        }

        ngx_http_variable_depth--;

        vv = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t));

        if (vv && v->get_handler(r, vv, v->data) == NGX_OK) {
            ngx_http_variable_depth++;
   ...",669.0,736.0,1.0,1.0,68.0,68,16,73,16,0,19,10,15,6,5,,0,17,6,3,3,ngx_http_variable_value_t
1113,449144,conf_prefix,3,ngx_stream_compile_complex_value_t.conf_prefix,,stream\ngx_stream_script.h,conf_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1114,449145,root_prefix,3,ngx_stream_compile_complex_value_t.root_prefix,,stream\ngx_stream_script.h,root_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1115,92986,ngx_ssl_get_client_v_end,1,ngx_ssl_get_client_v_end,"ngx_int_t ngx_ssl_get_client_v_end (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO     *bio;
    X509    *cert;
    size_t   len;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    ASN1_TIME_print(bio, X509_get0_notAfter(cert));
#else
    ASN1_TIME_print(bio, X509_get_notAfter(cert));
#endif

    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",5002.0,5043.0,1.0,1.0,42.0,16,3,31,9,0,6,4,4,1,1,,0,6,6,3,3,ngx_int_t
1116,240449,enable,3,ngx_http_userid_conf_t.enable,,http\modules\ngx_http_userid_filter_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1117,240451,name,3,ngx_http_userid_conf_t.name,,http\modules\ngx_http_userid_filter_module.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1118,449351,ngx_stream_split_clients_variable,1,ngx_stream_split_clients_variable,"ngx_int_t ngx_stream_split_clients_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)",stream\ngx_stream_split_clients_module.c,"static ngx_int_t
ngx_stream_split_clients_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_split_clients_ctx_t *ctx =
                                       (ngx_stream_split_clients_ctx_t *) data;

    uint32_t                          hash;
    ngx_str_t                         val;
    ngx_uint_t                        i;
    ngx_stream_split_clients_part_t  *part;

    *v = ngx_stream_variable_null_value;

    if (ngx_stream_complex_value(s, &ctx->value, &val) != NGX_OK) {
        return NGX_OK;
    }

    hash = ngx_murmur_hash2(val.data, val.len);

    part = ctx->parts.elts;

    for (i = 0; i < ctx->parts.nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream split: %uD %uD"", hash, part[i].percent);

        if (hash < part[i].percent || part[i].percent == 0) {
            *v = part[i].value;
            return NGX_OK;
        }
    }

    return NGX_OK;
}",71.0,105.0,1.0,1.0,35.0,33,11,32,11,0,7,4,5,3,2,,0,7,6,3,3,ngx_int_t
1119,240459,uid_got,3,ngx_http_userid_ctx_t.uid_got,,http\modules\ngx_http_userid_filter_module.c,uid_got[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1120,240460,uid_set,3,ngx_http_userid_ctx_t.uid_set,,http\modules\ngx_http_userid_filter_module.c,uid_set[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1121,400210,ngx_file_aio_read,1,ngx_file_aio_read,"ssize_t ngx_file_aio_read (ngx_file_t*,u_char*,size_t,off_t,ngx_pool_t*)",os\unix\ngx_linux_aio_read.c,"ssize_t
ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,
    ngx_pool_t *pool)
{
    ngx_err_t         err;
    struct iocb      *piocb[1];
    ngx_event_t      *ev;
    ngx_event_aio_t  *aio;

    if (!ngx_file_aio) {
        return ngx_read_file(file, buf, size, offset);
    }

    if (file->aio == NULL && ngx_file_aio_init(file, pool) != NGX_OK) {
        return NGX_ERROR;
    }

    aio = file->aio;
    ev = &aio->event;

    if (!ev->ready) {
        ngx_log_error(NGX_LOG_ALERT, file->log, 0,
                      ""second aio post for \""%V\"""", &file->name);
        return NGX_AGAIN;
    }

    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""aio complete:%d @%O:%uz %V"",
                   ev->complete, offset, size, &file->name);

    if (ev->complete) {
        ev->active = 0;
        ev->complete = 0;

        if (aio->res >= 0) {
            ngx_set_errno(0);
            return aio->res;
        }

        ngx_set_errno(-aio->re...",49.0,134.0,1.0,1.0,86.0,68,10,81,21,0,8,9,12,1,8,,0,1,10,5,5,ssize_t
1122,387926,ngx_mail_pop3_init_protocol,1,ngx_mail_pop3_init_protocol,void ngx_mail_pop3_init_protocol (ngx_event_t*),mail\ngx_mail_pop3_handler.c,"void
ngx_mail_pop3_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))
            == NGX_ERROR)
        {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        s->buffer = ngx_create_temp_buf(c->pool, 128);
        if (s->buffer == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }
    }

    s->mail_state = ngx_pop3_start;
    c->read->handler = ngx_mail_pop3_auth_state;

    ngx_mail_pop3_auth_state(rev);
}",78.0,116.0,1.0,1.0,39.0,28,5,27,9,0,12,5,7,4,7,,0,7,2,1,1,void
1123,404310,ngx_os_init,1,ngx_os_init,ngx_int_t ngx_os_init (ngx_log_t*),os\win32\ngx_win32_init.c,"ngx_int_t
ngx_os_init(ngx_log_t *log)
{
    DWORD         bytes;
    SOCKET        s;
    WSADATA       wsd;
    ngx_err_t     err;
    ngx_time_t   *tp;
    ngx_uint_t    n;
    SYSTEM_INFO   si;

    /* get Windows version */

    ngx_memzero(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

#ifdef _MSC_VER
#pragma warning(disable:4996)
#endif

    osviex = GetVersionEx((OSVERSIONINFO *) &osvi);

    if (osviex == 0) {
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (GetVersionEx((OSVERSIONINFO *) &osvi) == 0) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ""GetVersionEx() failed"");
            return NGX_ERROR;
        }
    }

#ifdef _MSC_VER
#pragma warning(default:4996)
#endif

    /*
     *  Windows 3.1 Win32s   0xxxxx
     *
     *  Windows 95           140000
     *  Windows 98           141000
     *  Windows ME           149000
     *  Windows NT 3.51      235100
     *  Wi...",67.0,279.0,1.0,1.0,213.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1124,240472,ngx_http_userid_get_uid,1,ngx_http_userid_get_uid,"ngx_http_userid_ctx_t* ngx_http_userid_get_uid (ngx_http_request_t*,ngx_http_userid_conf_t*)",http\modules\ngx_http_userid_filter_module.c,"static ngx_http_userid_ctx_t *
ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)
{
    ngx_int_t                n;
    ngx_str_t                src, dst;
    ngx_table_elt_t        **cookies;
    ngx_http_userid_ctx_t   *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);

    if (ctx) {
        return ctx;
    }

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));
        if (ctx == NULL) {
            return NULL;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);
    }

    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,
                                          &ctx->cookie);
    if (n == NGX_DECLINED) {
        return ctx;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""uid cookie: \""%V\"""", &ctx->cookie);

    if (ctx->cookie.len < 22) {
        cookies = r->headers_in.cookies.elts;
        ngx_log_e...",289.0,356.0,1.0,1.0,68.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,ngx_http_userid_ctx_t
1125,404315,ngx_os_status,1,ngx_os_status,void ngx_os_status (ngx_log_t*),os\win32\ngx_win32_init.c,"void
ngx_os_status(ngx_log_t *log)
{
    ngx_osviex_stub_t  *osviex_stub;

    ngx_log_error(NGX_LOG_NOTICE, log, 0, NGINX_VER_BUILD);

    if (osviex) {

        /*
         * the MSVC 6.0 SP2 defines wSuiteMask and wProductType
         * as WORD wReserved[2]
         */
        osviex_stub = (ngx_osviex_stub_t *) &osvi.wServicePackMinor;

        ngx_log_error(NGX_LOG_INFO, log, 0,
                      ""OS: %ud build:%ud, \""%s\"", suite:%Xd, type:%ud"",
                      ngx_win32_version, osvi.dwBuildNumber, osvi.szCSDVersion,
                      osviex_stub->wSuiteMask, osviex_stub->wProductType);

    } else {
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {

            /* Win9x build */

            ngx_log_error(NGX_LOG_INFO, log, 0,
                          ""OS: %u build:%ud.%ud.%ud, \""%s\"""",
                          ngx_win32_version,
                          osvi.dwBuildNumber >> 24,
                          (osvi.dwBuildNumber >> 16) & 0xff,
     ...",282.0,329.0,1.0,1.0,48.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1126,240478,ngx_http_userid_variable,1,ngx_http_userid_variable,"ngx_int_t ngx_http_userid_variable (ngx_http_request_t*,ngx_http_variable_value_t*,ngx_str_t*,uint32_t*)",http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    ngx_str_t *name, uint32_t *uid)
{
    v->len = name->len + sizeof(""=00001111222233334444555566667777"") - 1;
    v->data = ngx_pnalloc(r->pool, v->len);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    ngx_sprintf(v->data, ""%V=%08XD%08XD%08XD%08XD"",
                name, uid[0], uid[1], uid[2], uid[3]);

    return NGX_OK;
}",578.0,596.0,1.0,1.0,19.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
1127,7009,ngx_conf_set_flag_slot,1,ngx_conf_set_flag_slot,"char* ngx_conf_set_flag_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_flag_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t        *value;
    ngx_flag_t       *fp;
    ngx_conf_post_t  *post;

    fp = (ngx_flag_t *) (p + cmd->offset);

    if (*fp != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcasecmp(value[1].data, (u_char *) ""on"") == 0) {
        *fp = 1;

    } else if (ngx_strcasecmp(value[1].data, (u_char *) ""off"") == 0) {
        *fp = 0;

    } else {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                     ""invalid value \""%s\"" in \""%s\"" directive, ""
                     ""it must be \""on\"" or \""off\"""",
                     value[1].data, cmd->name.data);
        return NGX_CONF_ERROR;
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, fp);
    }

    return NGX_CONF_OK;
}",1025.0,1062.0,1.0,1.0,38.0,20,9,19,9,0,2,4,4,1,1,,0,2,6,3,3,char*
1128,240486,ngx_http_userid_set_uid,1,ngx_http_userid_set_uid,"ngx_int_t ngx_http_userid_set_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)",http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,
    ngx_http_userid_conf_t *conf)
{
    u_char           *cookie, *p;
    size_t            len;
    ngx_str_t         src, dst;
    ngx_table_elt_t  *set_cookie, *p3p;

    if (ngx_http_userid_create_uid(r, ctx, conf) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ctx->uid_set[3] == 0) {
        return NGX_OK;
    }

    len = conf->name.len + 1 + ngx_base64_encoded_length(16) + conf->path.len;

    if (conf->expires) {
        len += sizeof(expires) - 1 + 2;
    }

    if (conf->domain.len) {
        len += conf->domain.len;
    }

    cookie = ngx_pnalloc(r->pool, len);
    if (cookie == NULL) {
        return NGX_ERROR;
    }

    p = ngx_copy(cookie, conf->name.data, conf->name.len);
    *p++ = '=';

    if (ctx->uid_got[3] == 0 || ctx->reset) {
        src.len = 16;
        src.data = (u_char *) ctx->uid_set;
        dst.data = p;

        ngx_encode_base64(&dst, &src);

        ...",359.0,452.0,1.0,25.0,94.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1129,97131,ngx_event_no_timers_left,1,ngx_event_no_timers_left,ngx_int_t ngx_event_no_timers_left (void),event\ngx_event_timer.c,"ngx_int_t
ngx_event_no_timers_left(void)
{
    ngx_event_t        *ev;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    sentinel = ngx_event_timer_rbtree.sentinel;
    root = ngx_event_timer_rbtree.root;

    if (root == sentinel) {
        return NGX_OK;
    }

    for (node = ngx_rbtree_min(root, sentinel);
         node;
         node = ngx_rbtree_next(&ngx_event_timer_rbtree, node))
    {
        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));

        if (!ev->cancelable) {
            return NGX_AGAIN;
        }
    }

    /* only cancelable timers left */

    return NGX_OK;
}",99.0,126.0,1.0,1.0,28.0,12,7,18,9,0,2,4,5,0,0,,0,2,2,1,1,ngx_int_t
1130,240493,ngx_http_userid_create_uid,1,ngx_http_userid_create_uid,"ngx_int_t ngx_http_userid_create_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)",http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_create_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,
    ngx_http_userid_conf_t *conf)
{
    ngx_connection_t           *c;
    struct sockaddr_in         *sin;
    ngx_http_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                     *p;
    struct sockaddr_in6        *sin6;
#endif

    if (ctx->uid_set[3] != 0) {
        return NGX_OK;
    }

    if (ctx->uid_got[3] != 0) {

        vv = ngx_http_get_indexed_variable(r, ngx_http_userid_reset_index);

        if (vv == NULL || vv->not_found) {
            return NGX_ERROR;
        }

        if (vv->len == 0 || (vv->len == 1 && vv->data[0] == '0')) {

            if (conf->mark == '\0'
                || (ctx->cookie.len > 23
                    && ctx->cookie.data[22] == conf->mark
                    && ctx->cookie.data[23] == '='))
            {
                return NGX_OK;
            }

            ctx->uid_set[0] = ctx->uid_got[0];
            ctx->uid_set[1] = ctx->ui...",455.0,575.0,1.0,24.0,121.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1131,404335,ngx_os_signal_process,1,ngx_os_signal_process,"ngx_int_t ngx_os_signal_process (ngx_cycle_t*,char*,ngx_pid_t)",os\win32\ngx_process_cycle.c,"ngx_int_t
ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid)
{
    HANDLE     ev;
    ngx_int_t  rc;
    char       evn[NGX_PROCESS_SYNC_NAME];

    ngx_sprintf((u_char *) evn, ""Global\\ngx_%s_%P%Z"", sig, pid);

    ev = OpenEvent(EVENT_MODIFY_STATE, 0, evn);
    if (ev == NULL) {
        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,
                      ""OpenEvent(\""%s\"") failed"", evn);
        return 1;
    }

    if (SetEvent(ev) == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""SetEvent(\""%s\"") failed"", evn);
        rc = 1;

    } else {
        rc = 0;
    }

    ngx_close_handle(ev);

    return rc;
}",1005.0,1033.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1132,11124,ngx_crc32_table16,2,core\ngx_crc32.c.ngx_crc32_table16,,core\ngx_crc32.c,static uint32_t[] ngx_crc32_table16,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1133,465795,ngx_stream_map_find,1,ngx_stream_map_find,"void* ngx_stream_map_find (ngx_stream_session_t*,ngx_stream_map_t*,ngx_str_t*)",stream\ngx_stream_variables.c,"void *
ngx_stream_map_find(ngx_stream_session_t *s, ngx_stream_map_t *map,
    ngx_str_t *match)
{
    void        *value;
    u_char      *low;
    size_t       len;
    ngx_uint_t   key;

    len = match->len;

    if (len) {
        low = ngx_pnalloc(s->connection->pool, len);
        if (low == NULL) {
            return NULL;
        }

    } else {
        low = NULL;
    }

    key = ngx_hash_strlow(low, match->data, len);

    value = ngx_hash_find_combined(&map->hash, key, low, len);
    if (value) {
        return value;
    }

#if (NGX_PCRE)

    if (len && map->nregex) {
        ngx_int_t                n;
        ngx_uint_t               i;
        ngx_stream_map_regex_t  *reg;

        reg = map->regex;

        for (i = 0; i < map->nregex; i++) {

            n = ngx_stream_regex_exec(s, reg[i].regex, match);

            if (n == NGX_OK) {
                return reg[i].value;
            }

            if (n == NGX_DECLINED) {
                continue;
            }
...",914.0,972.0,1.0,1.0,59.0,11,4,21,8,1,6,4,5,0,3,,0,6,6,3,3,void*
1134,146311,enable,3,ngx_http_gzip_conf_t.enable,,http\modules\ngx_http_gzip_filter_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1135,146313,types,3,ngx_http_gzip_conf_t.types,,http\modules\ngx_http_gzip_filter_module.c,types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1136,146315,postpone_gzipping,3,ngx_http_gzip_conf_t.postpone_gzipping,,http\modules\ngx_http_gzip_filter_module.c,postpone_gzipping,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1137,146319,min_length,3,ngx_http_gzip_conf_t.min_length,,http\modules\ngx_http_gzip_filter_module.c,min_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1138,93074,ngx_ssl_get_client_v_remain,1,ngx_ssl_get_client_v_remain,"ngx_int_t ngx_ssl_get_client_v_remain (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509    *cert;
    time_t   now, end;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    end = ngx_ssl_parse_time(X509_get0_notAfter(cert));
#else
    end = ngx_ssl_parse_time(X509_get_notAfter(cert));
#endif

    if (end == (time_t) NGX_ERROR) {
        X509_free(cert);
        return NGX_OK;
    }

    now = ngx_time();

    if (end < now + 86400) {
        ngx_str_set(s, ""0"");
        X509_free(cert);
        return NGX_OK;
    }

    s->data = ngx_pnalloc(pool, NGX_TIME_T_LEN);
    if (s->data == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    s->len = ngx_sprintf(s->data, ""%T"", (end - now) / 86400) - s->data;

    X509_free(cert);

    return NGX_OK;
}",5046.0,5089.0,1.0,1.0,44.0,23,8,32,10,0,9,5,5,1,3,,0,9,6,3,3,ngx_int_t
1139,146323,in,3,ngx_http_gzip_ctx_t.in,,http\modules\ngx_http_gzip_filter_module.c,*in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1140,146324,free,3,ngx_http_gzip_ctx_t.free,,http\modules\ngx_http_gzip_filter_module.c,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1141,35733,ngx_parse_time,1,ngx_parse_time,"ngx_int_t ngx_parse_time (ngx_str_t*,ngx_uint_t)",core\ngx_parse.c,"ngx_int_t
ngx_parse_time(ngx_str_t *line, ngx_uint_t is_sec)
{
    u_char      *p, *last;
    ngx_int_t    value, total, scale;
    ngx_int_t    max, cutoff, cutlim;
    ngx_uint_t   valid;
    enum {
        st_start = 0,
        st_year,
        st_month,
        st_week,
        st_day,
        st_hour,
        st_min,
        st_sec,
        st_msec,
        st_last
    } step;

    valid = 0;
    value = 0;
    total = 0;
    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;
    step = is_sec ? st_start : st_month;

    p = line->data;
    last = p + line->len;

    while (p < last) {

        if (*p >= '0' && *p <= '9') {
            if (value >= cutoff && (value > cutoff || *p - '0' > cutlim)) {
                return NGX_ERROR;
            }

            value = value * 10 + (*p++ - '0');
            valid = 1;
            continue;
        }

        switch (*p++) {

        case 'y':
            if (step > st_start) {
                return NGX_ERRO...",111.0,283.0,1.0,1.0,173.0,132,22,144,24,3,2,33,53,0,0,,0,2,4,2,2,ngx_int_t
1142,146325,busy,3,ngx_http_gzip_ctx_t.busy,,http\modules\ngx_http_gzip_filter_module.c,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1143,146326,out,3,ngx_http_gzip_ctx_t.out,,http\modules\ngx_http_gzip_filter_module.c,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1144,146327,last_out,3,ngx_http_gzip_ctx_t.last_out,,http\modules\ngx_http_gzip_filter_module.c,**last_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1145,150425,ngx_http_trailers_filter,1,ngx_http_trailers_filter,"ngx_int_t ngx_http_trailers_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_headers_filter_module.c,"static ngx_int_t
ngx_http_trailers_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_str_t                 value;
    ngx_uint_t                i, safe_status;
    ngx_chain_t              *cl;
    ngx_table_elt_t          *t;
    ngx_http_header_val_t    *h;
    ngx_http_headers_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module);

    if (in == NULL
        || conf->trailers == NULL
        || !r->expect_trailers
        || r->header_only)
    {
        return ngx_http_next_body_filter(r, in);
    }

    for (cl = in; cl; cl = cl->next) {
        if (cl->buf->last_buf) {
            break;
        }
    }

    if (cl == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    switch (r->headers_out.status) {

    case NGX_HTTP_OK:
    case NGX_HTTP_CREATED:
    case NGX_HTTP_NO_CONTENT:
    case NGX_HTTP_PARTIAL_CONTENT:
    case NGX_HTTP_MOVED_PERMANENTLY:
    case NGX_HTTP_MOVED_TEMPORARILY:
    case NGX_HTTP_SEE_OTHER:
  ...",247.0,321.0,1.0,1.0,75.0,49,11,60,23,0,10,15,17,4,2,,0,10,4,2,2,ngx_int_t
1146,146333,preallocated,3,ngx_http_gzip_ctx_t.preallocated,,http\modules\ngx_http_gzip_filter_module.c,*preallocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1147,64416,ngx_utf8_decode,1,ngx_utf8_decode,"uint32_t ngx_utf8_decode (u_char**,size_t)",core\ngx_string.c,"uint32_t
ngx_utf8_decode(u_char **p, size_t n)
{
    size_t    len;
    uint32_t  u, i, valid;

    u = **p;

    if (u >= 0xf0) {

        u &= 0x07;
        valid = 0xffff;
        len = 3;

    } else if (u >= 0xe0) {

        u &= 0x0f;
        valid = 0x7ff;
        len = 2;

    } else if (u >= 0xc2) {

        u &= 0x1f;
        valid = 0x7f;
        len = 1;

    } else {
        (*p)++;
        return 0xffffffff;
    }

    if (n - 1 < len) {
        return 0xfffffffe;
    }

    (*p)++;

    while (len) {
        i = *(*p)++;

        if (i < 0x80) {
            return 0xffffffff;
        }

        u = (u << 6) | (i & 0x3f);

        len--;
    }

    if (u > valid) {
        return u;
    }

    return 0xffffffff;
}",1310.0,1364.0,1.0,1.0,55.0,21,11,20,6,2,0,6,7,0,0,,0,0,4,2,2,uint32_t
1148,23459,ngx_cmp_sockaddr,1,ngx_cmp_sockaddr,"ngx_int_t ngx_cmp_sockaddr (sockaddr*,socklen_t,sockaddr*,socklen_t,ngx_uint_t)",core\ngx_inet.c,"ngx_int_t
ngx_cmp_sockaddr(struct sockaddr *sa1, socklen_t slen1,
    struct sockaddr *sa2, socklen_t slen2, ngx_uint_t cmp_port)
{
    struct sockaddr_in   *sin1, *sin2;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin61, *sin62;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    size_t                len;
    struct sockaddr_un   *saun1, *saun2;
#endif

    if (sa1->sa_family != sa2->sa_family) {
        return NGX_DECLINED;
    }

    switch (sa1->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:

        sin61 = (struct sockaddr_in6 *) sa1;
        sin62 = (struct sockaddr_in6 *) sa2;

        if (cmp_port && sin61->sin6_port != sin62->sin6_port) {
            return NGX_DECLINED;
        }

        if (ngx_memcmp(&sin61->sin6_addr, &sin62->sin6_addr, 16) != 0) {
            return NGX_DECLINED;
        }

        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:

        saun1 = (struct sockaddr_un *) sa1;
        saun2 = (struct sockaddr_un *) sa2;

        if (slen1 < slen...",1323.0,1400.0,1.0,1.0,78.0,17,6,16,7,1,0,6,7,0,0,,0,0,10,5,5,ngx_int_t
1149,146340,done,3,ngx_http_gzip_ctx_t.done,,http\modules\ngx_http_gzip_filter_module.c,done:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1150,146341,nomem,3,ngx_http_gzip_ctx_t.nomem,,http\modules\ngx_http_gzip_filter_module.c,nomem:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1151,146342,buffering,3,ngx_http_gzip_ctx_t.buffering,,http\modules\ngx_http_gzip_filter_module.c,buffering:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1152,404393,iovs,3,ngx_iovec_t.iovs,,os\unix\ngx_os.h,*iovs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1153,404394,count,3,ngx_iovec_t.count,,os\unix\ngx_os.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1154,146346,zstream,3,ngx_http_gzip_ctx_t.zstream,,http\modules\ngx_http_gzip_filter_module.c,zstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1155,404396,nalloc,3,ngx_iovec_t.nalloc,,os\unix\ngx_os.h,nalloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1156,256941,ngx_http_types_slot,1,ngx_http_types_slot,"char* ngx_http_types_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http.c,"char *
ngx_http_types_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_array_t     **types;
    ngx_str_t        *value, *default_type;
    ngx_uint_t        i, n, hash;
    ngx_hash_key_t   *type;

    types = (ngx_array_t **) (p + cmd->offset);

    if (*types == (void *) -1) {
        return NGX_CONF_OK;
    }

    default_type = cmd->post;

    if (*types == NULL) {
        *types = ngx_array_create(cf->temp_pool, 1, sizeof(ngx_hash_key_t));
        if (*types == NULL) {
            return NGX_CONF_ERROR;
        }

        if (default_type) {
            type = ngx_array_push(*types);
            if (type == NULL) {
                return NGX_CONF_ERROR;
            }

            type->key = *default_type;
            type->key_hash = ngx_hash_key(default_type->data,
                                          default_type->len);
            type->value = (void *) 4;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->n...",1907.0,1981.0,1.0,1.0,75.0,90,13,76,16,0,14,13,20,0,6,,0,13,6,3,3,char*
1157,146347,request,3,ngx_http_gzip_ctx_t.request,,http\modules\ngx_http_gzip_filter_module.c,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1158,146348,ngx_http_gzip_ctx_t,2,http\modules\ngx_http_gzip_filter_module.c.ngx_http_gzip_ctx_t,,http\modules\ngx_http_gzip_filter_module.c,struct ngx_http_gzip_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1159,146349,ngx_http_gzip_filter_memory,1,ngx_http_gzip_filter_memory,"void ngx_http_gzip_filter_memory (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static void
ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    int                    wbits, memlevel;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    wbits = conf->wbits;
    memlevel = conf->memlevel;

    if (r->headers_out.content_length_n > 0) {

        /* the actual zlib window size is smaller by 262 bytes */

        while (r->headers_out.content_length_n < ((1 << (wbits - 1)) - 262)) {
            wbits--;
            memlevel--;
        }

        if (memlevel < 1) {
            memlevel = 1;
        }
    }

    ctx->wbits = wbits;
    ctx->memlevel = memlevel;

    /*
     * We preallocate a memory for zlib in one buffer (200K-400K), this
     * decreases a number of malloc() and free() calls and also probably
     * decreases a number of syscalls (sbrk()/mmap() and so on).
     * Besides we free the memory as soon as a gzipping will complete
     * and do not wait while a who...",466.0,527.0,1.0,1.0,62.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1160,146355,ngx_http_gzip_filter_buffer,1,ngx_http_gzip_filter_buffer,"ngx_int_t ngx_http_gzip_filter_buffer (ngx_http_gzip_ctx_t*,ngx_chain_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx, ngx_chain_t *in)
{
    size_t                 size, buffered;
    ngx_buf_t             *b, *buf;
    ngx_chain_t           *cl, **ll;
    ngx_http_request_t    *r;
    ngx_http_gzip_conf_t  *conf;

    r = ctx->request;

    r->connection->buffered |= NGX_HTTP_GZIP_BUFFERED;

    buffered = 0;
    ll = &ctx->in;

    for (cl = ctx->in; cl; cl = cl->next) {
        buffered += cl->buf->last - cl->buf->pos;
        ll = &cl->next;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    while (in) {
        cl = ngx_alloc_chain_link(r->pool);
        if (cl == NULL) {
            return NGX_ERROR;
        }

        b = in->buf;

        size = b->last - b->pos;
        buffered += size;

        if (b->flush || b->last_buf || buffered > conf->postpone_gzipping) {
            ctx->buffering = 0;
        }

        if (ctx->buffering && size) {

            buf = ngx_create_temp_buf(r->p...",530.0,595.0,1.0,1.0,66.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1161,52149,node,3,ngx_resolver_node_t.node,,core\ngx_resolver.h,node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1162,52150,queue,3,ngx_resolver_node_t.queue,,core\ngx_resolver.h,queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1163,52151,name,3,ngx_resolver_node_t.name,,core\ngx_resolver.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1164,146361,ngx_http_gzip_filter_deflate_start,1,ngx_http_gzip_filter_deflate_start,"ngx_int_t ngx_http_gzip_filter_deflate_start (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx)
{
    int                    rc;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    ctx->preallocated = ngx_palloc(r->pool, ctx->allocated);
    if (ctx->preallocated == NULL) {
        return NGX_ERROR;
    }

    ctx->free_mem = ctx->preallocated;

    ctx->zstream.zalloc = ngx_http_gzip_filter_alloc;
    ctx->zstream.zfree = ngx_http_gzip_filter_free;
    ctx->zstream.opaque = ctx;

    rc = deflateInit2(&ctx->zstream, (int) conf->level, Z_DEFLATED,
                      ctx->wbits + 16, ctx->memlevel, Z_DEFAULT_STRATEGY);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""deflateInit2() failed: %d"", rc);
        return NGX_ERROR;
    }

    ctx->last_out = &ctx->out;
    ctx->flush = Z_NO_FLUSH;

    return NGX_OK;
}",598.0,631.0,1.0,1.0,34.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1165,52154,nlen,3,ngx_resolver_node_t.nlen,,core\ngx_resolver.h,nlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1166,388028,ngx_mail_pop3_auth_state,1,ngx_mail_pop3_auth_state,void ngx_mail_pop3_auth_state (ngx_event_t*),mail\ngx_mail_pop3_handler.c,"void
ngx_mail_pop3_auth_state(ngx_event_t *rev)
{
    ngx_int_t            rc;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""pop3 auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""pop3 send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    ngx_str_set(&s->out, pop3_ok);

    if (rc == NGX_OK) {
        switch (s->mail_state) {

        case ngx_pop3_start:

            switch (s->command) {

            case NGX_POP3_USER:
                rc = ngx_mail_pop3_user(s, c);
                break;

            case NGX_...",119.0,280.0,1.0,1.0,162.0,73,6,118,31,1,40,31,16,5,18,,0,35,2,1,1,void
1167,52156,query,3,ngx_resolver_node_t.query,,core\ngx_resolver.h,*query,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1168,146367,ngx_http_gzip_filter_add_data,1,ngx_http_gzip_filter_add_data,"ngx_int_t ngx_http_gzip_filter_add_data (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_filter_add_data(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t  *cl;

    if (ctx->zstream.avail_in || ctx->flush != Z_NO_FLUSH || ctx->redo) {
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gzip in: %p"", ctx->in);

    if (ctx->in == NULL) {
        return NGX_DECLINED;
    }

    if (ctx->copy_buf) {

        /*
         * to avoid CPU cache trashing we do not free() just quit buf,
         * but postpone free()ing after zlib compressing and data output
         */

        ctx->copy_buf->next = ctx->copied;
        ctx->copied = ctx->copy_buf;
        ctx->copy_buf = NULL;
    }

    cl = ctx->in;
    ctx->in_buf = cl->buf;
    ctx->in = cl->next;

    if (ctx->in_buf->tag == (ngx_buf_tag_t) &ngx_http_gzip_filter_module) {
        ctx->copy_buf = cl;

    } else {
        ngx_free_chain(r->pool, cl);
    }

    ctx->zstream.next_in = ctx->in_buf->pos;
    ctx->zstre...",634.0,693.0,1.0,1.0,60.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1169,52164,code,3,ngx_resolver_node_t.code,,core\ngx_resolver.h,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1170,52165,naddrs,3,ngx_resolver_node_t.naddrs,,core\ngx_resolver.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1171,306118,ngx_http_upstream_handler,1,ngx_http_upstream_handler,void ngx_http_upstream_handler (ngx_event_t*),http\ngx_http_upstream.c,"static void
ngx_http_upstream_handler(ngx_event_t *ev)
{
    ngx_connection_t     *c;
    ngx_http_request_t   *r;
    ngx_http_upstream_t  *u;

    c = ev->data;
    r = c->data;

    u = r->upstream;
    c = r->connection;

    ngx_http_set_log_request(c->log, r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream request: \""%V?%V\"""", &r->uri, &r->args);

    if (ev->delayed && ev->timedout) {
        ev->delayed = 0;
        ev->timedout = 0;
    }

    if (ev->write) {
        u->write_event_handler(r, u);

    } else {
        u->read_event_handler(r, u);
    }

    ngx_http_run_posted_requests(c);
}",1259.0,1290.0,1.0,1.0,32.0,23,4,23,5,0,1,3,3,0,1,,0,0,2,1,1,void
1172,52166,nsrvs,3,ngx_resolver_node_t.nsrvs,,core\ngx_resolver.h,nsrvs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1173,52167,cnlen,3,ngx_resolver_node_t.cnlen,,core\ngx_resolver.h,cnlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1174,465860,ngx_stream_variables_add_core_vars,1,ngx_stream_variables_add_core_vars,ngx_int_t ngx_stream_variables_add_core_vars (ngx_conf_t*),stream\ngx_stream_variables.c,"ngx_int_t
ngx_stream_variables_add_core_vars(ngx_conf_t *cf)
{
    ngx_stream_variable_t        *cv, *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    cmcf->variables_keys = ngx_pcalloc(cf->temp_pool,
                                       sizeof(ngx_hash_keys_arrays_t));
    if (cmcf->variables_keys == NULL) {
        return NGX_ERROR;
    }

    cmcf->variables_keys->pool = cf->pool;
    cmcf->variables_keys->temp_pool = cf->pool;

    if (ngx_hash_keys_array_init(cmcf->variables_keys, NGX_HASH_SMALL)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->prefix_variables, cf->pool, 8,
                       sizeof(ngx_stream_variable_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (cv = ngx_stream_core_variables; cv->name.len; cv++) {
        v = ngx_stream_add_variable(cf, &cv->name, cv->flags);
        if (v == NULL) {
            return NGX_ERROR;...",1130.0,1170.0,1.0,1.0,41.0,33,8,35,12,0,11,6,7,5,4,,0,11,2,1,1,ngx_int_t
1175,146373,ngx_http_gzip_filter_get_buf,1,ngx_http_gzip_filter_get_buf,"ngx_int_t ngx_http_gzip_filter_get_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_filter_get_buf(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t           *cl;
    ngx_http_gzip_conf_t  *conf;

    if (ctx->zstream.avail_out) {
        return NGX_OK;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    if (ctx->free) {

        cl = ctx->free;
        ctx->out_buf = cl->buf;
        ctx->free = cl->next;

        ngx_free_chain(r->pool, cl);

    } else if (ctx->bufs < conf->bufs.num) {

        ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
        if (ctx->out_buf == NULL) {
            return NGX_ERROR;
        }

        ctx->out_buf->tag = (ngx_buf_tag_t) &ngx_http_gzip_filter_module;
        ctx->out_buf->recycled = 1;
        ctx->bufs++;

    } else {
        ctx->nomem = 1;
        return NGX_DECLINED;
    }

    ctx->zstream.next_out = ctx->out_buf->pos;
    ctx->zstream.avail_out = conf->bufs.size;

    return NGX_OK;
}",696.0,736.0,1.0,1.0,41.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1176,261062,ngx_http_core_content_phase,1,ngx_http_core_content_phase,"ngx_int_t ngx_http_core_content_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)",http\ngx_http_core_module.c,"ngx_int_t
ngx_http_core_content_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    size_t     root;
    ngx_int_t  rc;
    ngx_str_t  path;

    if (r->content_handler) {
        r->write_event_handler = ngx_http_request_empty_handler;
        ngx_http_finalize_request(r, r->content_handler(r));
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""content phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc != NGX_DECLINED) {
        ngx_http_finalize_request(r, rc);
        return NGX_OK;
    }

    /* rc == NGX_DECLINED */

    ph++;

    if (ph->checker) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    /* no content handler was found */

    if (r->uri.data[r->uri.len - 1] == '/') {

        if (ngx_http_map_uri_to_path(r, &path, &root, 0) != NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""directory index of \""%s\"" is for...",1237.0,1287.0,1.0,1.0,51.0,29,9,39,14,0,8,6,7,1,7,,0,2,4,2,2,ngx_int_t
1177,146379,ngx_http_gzip_filter_deflate,1,ngx_http_gzip_filter_deflate,"ngx_int_t ngx_http_gzip_filter_deflate (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_filter_deflate(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    int                    rc;
    ngx_buf_t             *b;
    ngx_chain_t           *cl;
    ngx_http_gzip_conf_t  *conf;

    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                 ""deflate in: ni:%p no:%p ai:%ud ao:%ud fl:%d redo:%d"",
                 ctx->zstream.next_in, ctx->zstream.next_out,
                 ctx->zstream.avail_in, ctx->zstream.avail_out,
                 ctx->flush, ctx->redo);

    rc = deflate(&ctx->zstream, ctx->flush);

    if (rc != Z_OK && rc != Z_STREAM_END && rc != Z_BUF_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""deflate() failed: %d, %d"", ctx->flush, rc);
        return NGX_ERROR;
    }

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""deflate out: ni:%p no:%p ai:%ud ao:%ud rc:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
        ...",739.0,863.0,1.0,1.0,125.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1178,52175,expire,3,ngx_resolver_node_t.expire,,core\ngx_resolver.h,expire,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1179,52176,valid,3,ngx_resolver_node_t.valid,,core\ngx_resolver.h,valid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1180,52177,ttl,3,ngx_resolver_node_t.ttl,,core\ngx_resolver.h,ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1181,52178,tcp,3,ngx_resolver_node_t.tcp,,core\ngx_resolver.h,tcp:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1182,302034,ngx_http_script_value_code,1,ngx_http_script_value_code,void ngx_http_script_value_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_value_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_value_code_t  *code;

    code = (ngx_http_script_value_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_value_code_t);

    e->sp->len = code->text_len;
    e->sp->data = (u_char *) code->text_data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script value: \""%v\"""", e->sp);

    e->sp++;
}",1754.0,1770.0,1.0,1.0,17.0,21,6,12,4,0,9,1,1,0,0,,0,9,2,1,1,void
1183,52180,last_connection,3,ngx_resolver_node_t.last_connection,,core\ngx_resolver.h,last_connection,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1184,52181,waiting,3,ngx_resolver_node_t.waiting,,core\ngx_resolver.h,*waiting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1185,7122,ngx_conf_set_str_slot,1,ngx_conf_set_str_slot,"char* ngx_conf_set_str_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_str_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t        *field, *value;
    ngx_conf_post_t  *post;

    field = (ngx_str_t *) (p + cmd->offset);

    if (field->data) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *field = value[1];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, field);
    }

    return NGX_CONF_OK;
}",1065.0,1089.0,1.0,1.0,25.0,16,6,18,8,0,2,3,3,1,0,,0,2,6,3,3,char*
1186,68568,ngx_thread_pool_add,1,ngx_thread_pool_add,"ngx_thread_pool_t ngx_thread_pool_add (ngx_conf_t*,ngx_str_t*)",core\ngx_thread_pool.c,"ngx_thread_pool_t *
ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_thread_pool_t       *tp, **tpp;
    ngx_thread_pool_conf_t  *tcf;

    if (name == NULL) {
        name = &ngx_thread_pool_default;
    }

    tp = ngx_thread_pool_get(cf->cycle, name);

    if (tp) {
        return tp;
    }

    tp = ngx_pcalloc(cf->pool, sizeof(ngx_thread_pool_t));
    if (tp == NULL) {
        return NULL;
    }

    tp->name = *name;
    tp->file = cf->conf_file->file.name.data;
    tp->line = cf->conf_file->line;

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cf->cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    tpp = ngx_array_push(&tcf->pools);
    if (tpp == NULL) {
        return NULL;
    }

    *tpp = tp;

    return tp;
}",518.0,554.0,1.0,1.0,37.0,32,8,32,9,0,6,5,5,0,3,,0,6,4,2,2,ngx_thread_pool_t
1187,146404,ngx_http_gzip_filter_free_copy_buf,1,ngx_http_gzip_filter_free_copy_buf,"void ngx_http_gzip_filter_free_copy_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)",http\modules\ngx_http_gzip_filter_module.c,"static void
ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t  *cl;

    for (cl = ctx->copied; cl; cl = cl->next) {
        ngx_pfree(r->pool, cl->buf->start);
    }

    ctx->copied = NULL;
}",975.0,986.0,1.0,1.0,12.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
1188,23528,ngx_inet_get_port,1,ngx_inet_get_port,in_port_t ngx_inet_get_port (sockaddr*),core\ngx_inet.c,"in_port_t
ngx_inet_get_port(struct sockaddr *sa)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) sa;
        return ntohs(sin6->sin6_port);
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        return 0;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) sa;
        return ntohs(sin->sin_port);
    }
}",1403.0,1428.0,1.0,1.0,26.0,4,3,4,2,4,0,2,2,0,0,,0,0,2,1,1,in_port_t
1189,3049,ngx_array_create,1,ngx_array_create,"ngx_array_t ngx_array_create (ngx_pool_t*,ngx_uint_t,size_t)",core\ngx_array.c,"ngx_array_t *
ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size)
{
    ngx_array_t *a;

    a = ngx_palloc(p, sizeof(ngx_array_t));
    if (a == NULL) {
        return NULL;
    }

    if (ngx_array_init(a, p, n, size) != NGX_OK) {
        return NULL;
    }

    return a;
}",12.0,27.0,1.0,1.0,16.0,4,4,13,7,13,2,3,3,1,2,,0,2,6,3,3,ngx_array_t
1190,84989,ngx_ssl_create,1,ngx_ssl_create,"ngx_int_t ngx_ssl_create (ngx_ssl_t*,ngx_uint_t,void*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)
{
    ssl->ctx = SSL_CTX_new(SSLv23_method());

    if (ssl->ctx == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, ""SSL_CTX_new() failed"");
        return NGX_ERROR;
    }

    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_server_conf_index, data) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_ex_data() failed"");
        return NGX_ERROR;
    }

    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, NULL) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_ex_data() failed"");
        return NGX_ERROR;
    }

    ssl->buffer_size = NGX_SSL_BUFSIZE;

    /* client side options */

#ifdef SSL_OP_MICROSOFT_SESS_ID_BUG
    SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_SESS_ID_BUG);
#endif

#ifdef SSL_OP_NETSCAPE_CHALLENGE_BUG
    SSL_CTX_set_options(ssl->ctx, SSL_OP_NETSCAPE_CHALLENGE_BUG);
#endif

    /* serve...",258.0,394.0,1.0,1.0,137.0,25,5,38,18,0,5,7,7,2,3,,0,2,6,3,3,ngx_int_t
1191,23550,ngx_inet_set_port,1,ngx_inet_set_port,"void ngx_inet_set_port (sockaddr*,in_port_t)",core\ngx_inet.c,"void
ngx_inet_set_port(struct sockaddr *sa, in_port_t port)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) sa;
        sin6->sin6_port = htons(port);
        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        break;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) sa;
        sin->sin_port = htons(port);
        break;
    }
}",1431.0,1458.0,1.0,1.0,28.0,5,3,5,3,1,0,3,2,0,0,,0,0,4,2,2,void
1192,3083,ngx_array_destroy,1,ngx_array_destroy,void ngx_array_destroy (ngx_array_t*),core\ngx_array.c,"void
ngx_array_destroy(ngx_array_t *a)
{
    ngx_pool_t  *p;

    p = a->pool;

    if ((u_char *) a->elts + a->size * a->nalloc == p->d.last) {
        p->d.last -= a->size * a->nalloc;
    }

    if ((u_char *) a + sizeof(ngx_array_t) == p->d.last) {
        p->d.last = (u_char *) a;
    }
}",30.0,44.0,1.0,1.0,15.0,27,9,14,3,0,6,3,3,3,0,,0,6,2,1,1,void
1193,302091,ngx_http_script_set_var_code,1,ngx_http_script_set_var_code,void ngx_http_script_set_var_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_set_var_code(ngx_http_script_engine_t *e)
{
    ngx_http_request_t          *r;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    r = e->request;

    e->sp--;

    r->variables[code->index].len = e->sp->len;
    r->variables[code->index].valid = 1;
    r->variables[code->index].no_cacheable = 0;
    r->variables[code->index].not_found = 0;
    r->variables[code->index].data = e->sp->data;

#if (NGX_DEBUG)
    {
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    v = cmcf->variables.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script set $%V"", &v[code->index].name);
    }
#endif
}",1773.0,1806.0,1.0,1.0,34.0,39,8,19,4,0,11,1,1,0,0,,0,11,2,1,1,void
1194,7185,ngx_conf_set_str_array_slot,1,ngx_conf_set_str_array_slot,"char* ngx_conf_set_str_array_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_str_array_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t         *value, *s;
    ngx_array_t      **a;
    ngx_conf_post_t   *post;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NGX_CONF_UNSET_PTR) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    s = ngx_array_push(*a);
    if (s == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    *s = value[1];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, s);
    }

    return NGX_CONF_OK;
}",1092.0,1125.0,1.0,1.0,34.0,26,8,30,13,0,3,5,6,0,2,,0,3,6,3,3,char*
1195,64532,ngx_utf8_length,1,ngx_utf8_length,"size_t ngx_utf8_length (u_char*,size_t)",core\ngx_string.c,"size_t
ngx_utf8_length(u_char *p, size_t n)
{
    u_char  c, *last;
    size_t  len;

    last = p + n;

    for (len = 0; p < last; len++) {

        c = *p;

        if (c < 0x80) {
            p++;
            continue;
        }

        if (ngx_utf8_decode(&p, last - p) > 0x10ffff) {
            /* invalid UTF-8 */
            return n;
        }
    }

    return len;
}",1367.0,1391.0,1.0,1.0,25.0,11,8,15,5,0,1,5,6,1,1,,0,1,4,2,2,size_t
1196,236584,max_cached,3,ngx_http_upstream_keepalive_srv_conf_t.max_cached,,http\modules\ngx_http_upstream_keepalive_module.c,max_cached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1197,80937,ngx_send_lowat,1,ngx_send_lowat,"ngx_int_t ngx_send_lowat (ngx_connection_t*,size_t)",event\ngx_event.c,"ngx_int_t
ngx_send_lowat(ngx_connection_t *c, size_t lowat)
{
    int  sndlowat;

#if (NGX_HAVE_LOWAT_EVENT)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        c->write->available = lowat;
        return NGX_OK;
    }

#endif

    if (lowat == 0 || c->sndlowat) {
        return NGX_OK;
    }

    sndlowat = (int) lowat;

    if (setsockopt(c->fd, SOL_SOCKET, SO_SNDLOWAT,
                   (const void *) &sndlowat, sizeof(int))
        == -1)
    {
        ngx_connection_error(c, ngx_socket_errno,
                             ""setsockopt(SO_SNDLOWAT) failed"");
        return NGX_ERROR;
    }

    c->sndlowat = 1;

    return NGX_OK;
}",914.0,946.0,1.0,1.0,33.0,13,8,15,9,1,1,3,3,0,1,,0,0,4,2,2,ngx_int_t
1198,236586,timeout,3,ngx_http_upstream_keepalive_srv_conf_t.timeout,,http\modules\ngx_http_upstream_keepalive_module.c,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1199,236587,cache,3,ngx_http_upstream_keepalive_srv_conf_t.cache,,http\modules\ngx_http_upstream_keepalive_module.c,cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1200,15404,ngx_set_shutdown_timer,1,ngx_set_shutdown_timer,void ngx_set_shutdown_timer (ngx_cycle_t*),core\ngx_cycle.c,"void
ngx_set_shutdown_timer(ngx_cycle_t *cycle)
{
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (ccf->shutdown_timeout) {
        ngx_shutdown_event.handler = ngx_shutdown_timer_handler;
        ngx_shutdown_event.data = cycle;
        ngx_shutdown_event.log = cycle->log;
        ngx_shutdown_event.cancelable = 1;

        ngx_add_timer(&ngx_shutdown_event, ccf->shutdown_timeout);
    }
}",1409.0,1424.0,1.0,1.0,16.0,15,5,13,5,0,7,2,2,1,0,,0,7,2,1,1,void
1201,236588,free,3,ngx_http_upstream_keepalive_srv_conf_t.free,,http\modules\ngx_http_upstream_keepalive_module.c,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1202,236589,original_init_upstream,3,ngx_http_upstream_keepalive_srv_conf_t.original_init_upstream,,http\modules\ngx_http_upstream_keepalive_module.c,original_init_upstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1203,89133,ngx_ssl_free_buffer,1,ngx_ssl_free_buffer,void ngx_ssl_free_buffer (ngx_connection_t*),event\ngx_event_openssl.c,"void
ngx_ssl_free_buffer(ngx_connection_t *c)
{
    if (c->ssl->buf && c->ssl->buf->start) {
        if (ngx_pfree(c->pool, c->ssl->buf->start) == NGX_OK) {
            c->ssl->buf->start = NULL;
        }
    }
}",2760.0,2768.0,1.0,1.0,9.0,15,4,7,3,0,1,3,4,1,1,,0,1,2,1,1,void
1204,236590,original_init_peer,3,ngx_http_upstream_keepalive_srv_conf_t.original_init_peer,,http\modules\ngx_http_upstream_keepalive_module.c,original_init_peer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1205,236585,requests,3,ngx_http_upstream_keepalive_srv_conf_t.requests,,http\modules\ngx_http_upstream_keepalive_module.c,requests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1206,236598,ngx_http_upstream_keepalive_cache_t,2,http\modules\ngx_http_upstream_keepalive_module.c.ngx_http_upstream_keepalive_cache_t,,http\modules\ngx_http_upstream_keepalive_module.c,struct ngx_http_upstream_keepalive_cache_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1207,465976,ngx_stream_variables_init_vars,1,ngx_stream_variables_init_vars,ngx_int_t ngx_stream_variables_init_vars (ngx_conf_t*),stream\ngx_stream_variables.c,"ngx_int_t
ngx_stream_variables_init_vars(ngx_conf_t *cf)
{
    size_t                        len;
    ngx_uint_t                    i, n;
    ngx_hash_key_t               *key;
    ngx_hash_init_t               hash;
    ngx_stream_variable_t        *v, *av, *pv;
    ngx_stream_core_main_conf_t  *cmcf;

    /* set the handlers for the indexed stream variables */

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->variables.elts;
    pv = cmcf->prefix_variables.elts;
    key = cmcf->variables_keys->keys.elts;

    for (i = 0; i < cmcf->variables.nelts; i++) {

        for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {

            av = key[n].value;

            if (v[i].name.len == key[n].key.len
                && ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len)
                   == 0)
            {
                v[i].get_handler = av->get_handler;
                v[i].data = av->data;

                av->flags |= NGX_ST...",1173.0,1278.0,1.0,1.0,106.0,161,13,122,20,0,22,16,24,7,2,,0,21,2,1,1,ngx_int_t
1208,68672,ngx_thread_pool_get,1,ngx_thread_pool_get,"ngx_thread_pool_t ngx_thread_pool_get (ngx_cycle_t*,ngx_str_t*)",core\ngx_thread_pool.c,"ngx_thread_pool_t *
ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name)
{
    ngx_uint_t                i;
    ngx_thread_pool_t       **tpp;
    ngx_thread_pool_conf_t   *tcf;

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    tpp = tcf->pools.elts;

    for (i = 0; i < tcf->pools.nelts; i++) {

        if (tpp[i]->name.len == name->len
            && ngx_strncmp(tpp[i]->name.data, name->data, name->len) == 0)
        {
            return tpp[i];
        }
    }

    return NULL;
}",557.0,579.0,1.0,1.0,23.0,23,8,18,7,1,6,3,4,4,0,,0,6,4,2,2,ngx_thread_pool_t
1209,64583,ngx_utf8_cpystrn,1,ngx_utf8_cpystrn,"u_char ngx_utf8_cpystrn (u_char*,u_char*,size_t,size_t)",core\ngx_string.c,"u_char *
ngx_utf8_cpystrn(u_char *dst, u_char *src, size_t n, size_t len)
{
    u_char  c, *next;

    if (n == 0) {
        return dst;
    }

    while (--n) {

        c = *src;
        *dst = c;

        if (c < 0x80) {

            if (c != '\0') {
                dst++;
                src++;
                len--;

                continue;
            }

            return dst;
        }

        next = src;

        if (ngx_utf8_decode(&next, len) > 0x10ffff) {
            /* invalid UTF-8 */
            break;
        }

        while (src < next) {
            *dst++ = *src++;
            len--;
        }
    }

    *dst = '\0';

    return dst;
}",1394.0,1437.0,1.0,1.0,44.0,23,10,24,6,0,1,9,12,1,1,,0,1,8,4,4,u_char
1210,3151,ngx_array_push,1,ngx_array_push,void* ngx_array_push (ngx_array_t*),core\ngx_array.c,"void *
ngx_array_push(ngx_array_t *a)
{
    void        *elt, *new;
    size_t       size;
    ngx_pool_t  *p;

    if (a->nelts == a->nalloc) {

        /* the array is full */

        size = a->size * a->nalloc;

        p = a->pool;

        if ((u_char *) a->elts + size == p->d.last
            && p->d.last + a->size <= p->d.end)
        {
            /*
             * the array allocation is the last in the pool
             * and there is space for new allocation
             */

            p->d.last += a->size;
            a->nalloc++;

        } else {
            /* allocate a new array */

            new = ngx_palloc(p, 2 * size);
            if (new == NULL) {
                return NULL;
            }

            ngx_memcpy(new, a->elts, size);
            a->elts = new;
            a->nalloc *= 2;
        }
    }

    elt = (u_char *) a->elts + a->size * a->nelts;
    a->nelts++;

    return elt;
}",47.0,91.0,1.0,1.0,45.0,38,11,22,4,38,13,3,4,4,0,,0,13,2,1,1,void*
1211,23631,family,3,ngx_cidr_t.family,,core\ngx_inet.h,family,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1212,23640,socklen,3,ngx_addr_t.socklen,,core\ngx_inet.h,socklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1213,162905,start,3,ngx_http_log_buf_t.start,,http\modules\ngx_http_log_module.c,*start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1214,89177,ngx_ssl_shutdown,1,ngx_ssl_shutdown,ngx_int_t ngx_ssl_shutdown (ngx_connection_t*),event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_shutdown(ngx_connection_t *c)
{
    int        n, sslerr, mode;
    ngx_err_t  err;

    ngx_ssl_ocsp_cleanup(c);

    if (SSL_in_init(c->ssl->connection)) {
        /*
         * OpenSSL 1.0.2f complains if SSL_shutdown() is called during
         * an SSL handshake, while previous versions always return 0.
         * Avoid calling SSL_shutdown() if handshake wasn't completed.
         */

        SSL_free(c->ssl->connection);
        c->ssl = NULL;

        return NGX_OK;
    }

    if (c->timedout) {
        mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;
        SSL_set_quiet_shutdown(c->ssl->connection, 1);

    } else {
        mode = SSL_get_shutdown(c->ssl->connection);

        if (c->ssl->no_wait_shutdown) {
            mode |= SSL_RECEIVED_SHUTDOWN;
        }

        if (c->ssl->no_send_shutdown) {
            mode |= SSL_SENT_SHUTDOWN;
        }

        if (c->ssl->no_wait_shutdown && c->ssl->no_send_shutdown) {
            SSL_set_quiet_shutdown(c->s...",2771.0,2865.0,1.0,1.0,95.0,56,8,64,18,0,5,9,12,2,5,,0,2,2,1,1,ngx_int_t
1215,162907,last,3,ngx_http_log_buf_t.last,,http\modules\ngx_http_log_module.c,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1216,162908,event,3,ngx_http_log_buf_t.event,,http\modules\ngx_http_log_module.c,*event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1217,23645,host,3,ngx_url_t.host,,core\ngx_inet.h,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
1218,23644,url,3,ngx_url_t.url,,core\ngx_inet.h,url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1219,162909,flush,3,ngx_http_log_buf_t.flush,,http\modules\ngx_http_log_module.c,flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1220,23648,port,3,ngx_url_t.port,,core\ngx_inet.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1221,162906,pos,3,ngx_http_log_buf_t.pos,,http\modules\ngx_http_log_module.c,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1222,23649,default_port,3,ngx_url_t.default_port,,core\ngx_inet.h,default_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1223,23651,family,3,ngx_url_t.family,,core\ngx_inet.h,family,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1224,52324,ngx_sha1_body,1,ngx_sha1_body,"u_char* ngx_sha1_body (ngx_sha1_t*,u_char*,size_t)",core\ngx_sha1.c,"static const u_char *
ngx_sha1_body(ngx_sha1_t *ctx, const u_char *data, size_t size)
{
    uint32_t       a, b, c, d, e, temp;
    uint32_t       saved_a, saved_b, saved_c, saved_d, saved_e;
    uint32_t       words[80];
    ngx_uint_t     i;
    const u_char  *p;

    p = data;

    a = ctx->a;
    b = ctx->b;
    c = ctx->c;
    d = ctx->d;
    e = ctx->e;

    do {
        saved_a = a;
        saved_b = b;
        saved_c = c;
        saved_d = d;
        saved_e = e;

        /* Load data block into the words array */

        for (i = 0; i < 16; i++) {
            words[i] = GET(i);
        }

        for (i = 16; i < 80; i++) {
            words[i] = ROTATE(1, words[i - 3] ^ words[i - 8] ^ words[i - 14]
                                 ^ words[i - 16]);
        }

        /* Transformations */

        STEP(F1, a, b, c, d, e, words[0],  0x5a827999);
        STEP(F1, a, b, c, d, e, words[1],  0x5a827999);
        STEP(F1, a, b, c, d, e, words[2],  0x5a827999);
        STEP(F1,...",156.0,294.0,1.0,23.0,139.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,u_char
1225,302183,ngx_http_script_var_set_handler_code,1,ngx_http_script_var_set_handler_code,void ngx_http_script_var_set_handler_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_var_handler_code_t  *code;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script set var handler"");

    code = (ngx_http_script_var_handler_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_handler_code_t);

    e->sp--;

    code->handler(e->request, e->sp, code->data);
}",1809.0,1824.0,1.0,1.0,16.0,15,6,11,4,0,8,1,1,0,0,,0,8,2,1,1,void
1226,23655,no_port,3,ngx_url_t.no_port,,core\ngx_inet.h,no_port:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1227,52331,ngx_sha1_init,1,ngx_sha1_init,void ngx_sha1_init (ngx_sha1_t*),core\ngx_sha1.c,"void
ngx_sha1_init(ngx_sha1_t *ctx)
{
    ctx->a = 0x67452301;
    ctx->b = 0xefcdab89;
    ctx->c = 0x98badcfe;
    ctx->d = 0x10325476;
    ctx->e = 0xc3d2e1f0;

    ctx->bytes = 0;
}",19.0,29.0,1.0,1.0,11.0,12,2,6,1,0,6,1,1,0,0,,0,6,2,1,1,void
1228,23659,addrs,3,ngx_url_t.addrs,,core\ngx_inet.h,*addrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1229,23660,naddrs,3,ngx_url_t.naddrs,,core\ngx_inet.h,naddrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1230,23661,err,3,ngx_url_t.err,,core\ngx_inet.h,*err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1231,7278,ngx_conf_set_keyval_slot,1,ngx_conf_set_keyval_slot,"char* ngx_conf_set_keyval_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t         *value;
    ngx_array_t      **a;
    ngx_keyval_t      *kv;
    ngx_conf_post_t   *post;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NULL) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_keyval_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    kv = ngx_array_push(*a);
    if (kv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    kv->key = value[1];
    kv->value = value[2];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, kv);
    }

    return NGX_CONF_OK;
}",1128.0,1163.0,1.0,1.0,36.0,29,8,32,12,0,5,5,6,0,2,,0,5,6,3,3,char*
1232,162926,logs,3,ngx_http_log_loc_conf_t.logs,,http\modules\ngx_http_log_module.c,*logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1233,412785,ngx_dlerror,1,ngx_dlerror,char* ngx_dlerror (void),os\win32\ngx_dlopen.c,"char *
ngx_dlerror(void)
{
    u_char         *p;
    static u_char   errstr[NGX_MAX_ERROR_STR];

    p = ngx_strerror(ngx_errno, errstr, NGX_MAX_ERROR_STR);
    *p = '\0';

    return (char *) errstr;
}",12.0,22.0,1.0,1.0,11.0,4,3,6,4,0,1,1,1,0,1,,0,1,2,1,1,char*
1234,162930,off,3,ngx_http_log_loc_conf_t.off,,http\modules\ngx_http_log_module.c,off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1235,85111,ngx_ssl_certificates,1,ngx_ssl_certificates,"ngx_int_t ngx_ssl_certificates (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *certs,
    ngx_array_t *keys, ngx_array_t *passwords)
{
    ngx_str_t   *cert, *key;
    ngx_uint_t   i;

    cert = certs->elts;
    key = keys->elts;

    for (i = 0; i < certs->nelts; i++) {

        if (ngx_ssl_certificate(cf, ssl, &cert[i], &key[i], passwords)
            != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",397.0,417.0,1.0,1.0,21.0,12,6,17,10,0,4,3,4,2,1,,0,4,10,5,5,ngx_int_t
1236,162937,ngx_http_log_write,1,ngx_http_log_write,"void ngx_http_log_write (ngx_http_request_t*,ngx_http_log_t*,u_char*,size_t)",http\modules\ngx_http_log_module.c,"static void
ngx_http_log_write(ngx_http_request_t *r, ngx_http_log_t *log, u_char *buf,
    size_t len)
{
    u_char              *name;
    time_t               now;
    ssize_t              n;
    ngx_err_t            err;
#if (NGX_ZLIB)
    ngx_http_log_buf_t  *buffer;
#endif

    if (log->script == NULL) {
        name = log->file->name.data;

#if (NGX_ZLIB)
        buffer = log->file->data;

        if (buffer && buffer->gzip) {
            n = ngx_http_log_gzip(log->file->fd, buf, len, buffer->gzip,
                                  r->connection->log);
        } else {
            n = ngx_write_fd(log->file->fd, buf, len);
        }
#else
        n = ngx_write_fd(log->file->fd, buf, len);
#endif

    } else {
        name = NULL;
        n = ngx_http_log_script_write(r, log->script, &name, buf, len);
    }

    if (n == (ssize_t) len) {
        return;
    }

    now = ngx_time();

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_ENOSPC) {
            log->...",405.0,468.0,1.0,1.0,64.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
1237,240763,ngx_http_userid_filter_module,2,http\modules\ngx_http_userid_filter_module.c.ngx_http_userid_filter_module,,http\modules\ngx_http_userid_filter_module.c,ngx_module_t ngx_http_userid_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1238,11404,ngx_crc32_table_short,2,core\ngx_crc32.c.ngx_crc32_table_short,,core\ngx_crc32.c,uint32_t* ngx_crc32_table_short,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1239,52366,ngx_sha1_update,1,ngx_sha1_update,"void ngx_sha1_update (ngx_sha1_t*,void*,size_t)",core\ngx_sha1.c,"void
ngx_sha1_update(ngx_sha1_t *ctx, const void *data, size_t size)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);
    ctx->bytes += size;

    if (used) {
        free = 64 - used;

        if (size < free) {
            ngx_memcpy(&ctx->buffer[used], data, size);
            return;
        }

        ngx_memcpy(&ctx->buffer[used], data, free);
        data = (u_char *) data + free;
        size -= free;
        (void) ngx_sha1_body(ctx, ctx->buffer, 64);
    }

    if (size >= 64) {
        data = ngx_sha1_body(ctx, data, size & ~(size_t) 0x3f);
        size &= 0x3f;
    }

    ngx_memcpy(ctx->buffer, data, size);
}",32.0,60.0,1.0,1.0,29.0,26,13,33,5,0,8,4,5,0,2,,0,7,6,3,3,void
1240,11408,ngx_crc32_table_init,1,ngx_crc32_table_init,ngx_int_t ngx_crc32_table_init (void),core\ngx_crc32.c,"ngx_int_t
ngx_crc32_table_init(void)
{
    void  *p;

    if (((uintptr_t) ngx_crc32_table_short
          & ~((uintptr_t) ngx_cacheline_size - 1))
        == (uintptr_t) ngx_crc32_table_short)
    {
        return NGX_OK;
    }

    p = ngx_alloc(16 * sizeof(uint32_t) + ngx_cacheline_size, ngx_cycle->log);
    if (p == NULL) {
        return NGX_ERROR;
    }

    p = ngx_align_ptr(p, ngx_cacheline_size);

    ngx_memcpy(p, ngx_crc32_table16, 16 * sizeof(uint32_t));

    ngx_crc32_table_short = p;

    return NGX_OK;
}",105.0,129.0,1.0,1.0,25.0,17,10,20,9,1,5,3,3,2,1,,0,5,2,1,1,ngx_int_t
1241,40085,ngx_pcre_pool,2,core\ngx_regex.c.ngx_pcre_pool,,core\ngx_regex.c,ngx_pool_t* ngx_pcre_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1242,302230,ngx_http_script_var_code,1,ngx_http_script_var_code,void ngx_http_script_var_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_var_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script var"");

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    value = ngx_http_get_flushed_variable(e->request, code->index);

    if (value && !value->not_found) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                       ""http script var: \""%v\"""", value);

        *e->sp = *value;
        e->sp++;

        return;
    }

    *e->sp = ngx_http_variable_null_value;
    e->sp++;
}",1827.0,1854.0,1.0,1.0,28.0,29,9,20,6,0,11,2,2,0,1,,0,11,2,1,1,void
1243,64663,ngx_escape_uri,1,ngx_escape_uri,"uintptr_t ngx_escape_uri (u_char*,u_char*,size_t,ngx_uint_t)",core\ngx_string.c,"uintptr_t
ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)
{
    ngx_uint_t      n;
    uint32_t       *escape;
    static u_char   hex[] = ""0123456789ABCDEF"";

                    /* "" "", ""#"", ""%"", ""?"", %00-%1F, %7F-%FF */

    static uint32_t   uri[] = {
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */

                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #""!  */
        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */

                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */

                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */

        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff  /* 1111 1111 1111 1111  ...",1440.0,1606.0,1.0,1.0,167.0,55,11,43,15,2,0,6,10,0,0,,0,0,8,4,4,uintptr_t
1244,40086,ngx_pcre_studies,2,core\ngx_regex.c.ngx_pcre_studies,,core\ngx_regex.c,ngx_list_t* ngx_pcre_studies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1245,461977,ngx_stream_upstream_free_round_robin_peer,1,ngx_stream_upstream_free_round_robin_peer,"void ngx_stream_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)",stream\ngx_stream_upstream_round_robin.c,"void
ngx_stream_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state)
{
    ngx_stream_upstream_rr_peer_data_t  *rrp = data;

    time_t                          now;
    ngx_stream_upstream_rr_peer_t  *peer;

    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""free rr peer %ui %ui"", pc->tries, state);

    peer = rrp->current;

    ngx_stream_upstream_rr_peers_rlock(rrp->peers);
    ngx_stream_upstream_rr_peer_lock(rrp->peers, peer);

    if (rrp->peers->single) {
        peer->conns--;

        ngx_stream_upstream_rr_peer_unlock(rrp->peers, peer);
        ngx_stream_upstream_rr_peers_unlock(rrp->peers);

        pc->tries = 0;
        return;
    }

    if (state & NGX_PEER_FAILED) {
        now = ngx_time();

        peer->fails++;
        peer->accessed = now;
        peer->checked = now;

        if (peer->max_fails) {
            peer->effective_weight -= peer->weight / peer->max_fails;

            if (peer->fails >= ...",594.0,662.0,1.0,1.0,69.0,46,9,45,9,0,9,7,11,1,1,,0,8,6,3,3,void
1246,240796,ngx_http_userid_filter,1,ngx_http_userid_filter,ngx_int_t ngx_http_userid_filter (ngx_http_request_t*),http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_filter(ngx_http_request_t *r)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_userid_filter_module);

    if (conf->enable < NGX_HTTP_USERID_V1) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_userid_get_uid(r, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ngx_http_userid_set_uid(r, ctx, conf) == NGX_OK) {
        return ngx_http_next_header_filter(r);
    }

    return NGX_ERROR;
}",196.0,223.0,1.0,23.0,28.0,8,5,20,7,0,4,5,5,2,2,,0,4,2,1,1,ngx_int_t
1247,236705,ngx_http_upstream_keepalive_module,2,http\modules\ngx_http_upstream_keepalive_module.c.ngx_http_upstream_keepalive_module,,http\modules\ngx_http_upstream_keepalive_module.c,ngx_module_t ngx_http_upstream_keepalive_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1248,40100,ngx_regex_compile,1,ngx_regex_compile,ngx_int_t ngx_regex_compile (ngx_regex_compile_t*),core\ngx_regex.c,"ngx_int_t
ngx_regex_compile(ngx_regex_compile_t *rc)
{
    int               n, erroff;
    char             *p;
    pcre             *re;
    const char       *errstr;
    ngx_regex_elt_t  *elt;

    ngx_regex_malloc_init(rc->pool);

    re = pcre_compile((const char *) rc->pattern.data, (int) rc->options,
                      &errstr, &erroff, NULL);

    /* ensure that there is no current pool */
    ngx_regex_malloc_done();

    if (re == NULL) {
        if ((size_t) erroff == rc->pattern.len) {
           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
                              ""pcre_compile() failed: %s in \""%V\"""",
                               errstr, &rc->pattern)
                      - rc->err.data;

        } else {
           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
                              ""pcre_compile() failed: %s in \""%V\"" at \""%s\"""",
                               errstr, &rc->pattern, rc->pattern.data + erroff)
                      - ...",94.0,194.0,1.0,1.0,101.0,93,10,82,16,0,40,18,14,5,5,,0,40,2,1,1,ngx_int_t
1249,298156,ngx_http_script_init_arrays,1,ngx_http_script_init_arrays,ngx_int_t ngx_http_script_init_arrays (ngx_http_script_compile_t*),http\ngx_http_script.c,"static ngx_int_t
ngx_http_script_init_arrays(ngx_http_script_compile_t *sc)
{
    ngx_uint_t   n;

    if (sc->flushes && *sc->flushes == NULL) {
        n = sc->variables ? sc->variables : 1;
        *sc->flushes = ngx_array_create(sc->cf->pool, n, sizeof(ngx_uint_t));
        if (*sc->flushes == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->lengths == NULL) {
        n = sc->variables * (2 * sizeof(ngx_http_script_copy_code_t)
                             + sizeof(ngx_http_script_var_code_t))
            + sizeof(uintptr_t);

        *sc->lengths = ngx_array_create(sc->cf->pool, n, 1);
        if (*sc->lengths == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->values == NULL) {
        n = (sc->variables * (2 * sizeof(ngx_http_script_copy_code_t)
                              + sizeof(ngx_http_script_var_code_t))
                + sizeof(uintptr_t)
                + sc->source->len
                + sizeof(uintptr_t) - 1)
            & ~(s...",643.0,684.0,1.0,1.0,42.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1250,85166,ngx_ssl_certificate,1,ngx_ssl_certificate,"ngx_int_t ngx_ssl_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_str_t *key, ngx_array_t *passwords)
{
    char            *err;
    X509            *x509;
    EVP_PKEY        *pkey;
    STACK_OF(X509)  *chain;

    x509 = ngx_ssl_load_certificate(cf->pool, &err, cert, &chain);
    if (x509 == NULL) {
        if (err != NULL) {
            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                          ""cannot load certificate \""%s\"": %s"",
                          cert->data, err);
        }

        return NGX_ERROR;
    }

    if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_use_certificate(\""%s\"") failed"", cert->data);
        X509_free(x509);
        sk_X509_pop_free(chain, X509_free);
        return NGX_ERROR;
    }

    if (X509_set_ex_data(x509, ngx_ssl_certificate_name_index, cert->data)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, ""X509_set...",420.0,538.0,1.0,1.0,119.0,40,7,90,19,1,19,12,15,5,9,,0,11,10,5,5,ngx_int_t
1251,298161,ngx_http_script_done,1,ngx_http_script_done,ngx_int_t ngx_http_script_done (ngx_http_script_compile_t*),http\ngx_http_script.c,"static ngx_int_t
ngx_http_script_done(ngx_http_script_compile_t *sc)
{
    ngx_str_t    zero;
    uintptr_t   *code;

    if (sc->zero) {

        zero.len = 1;
        zero.data = (u_char *) ""\0"";

        if (ngx_http_script_add_copy_code(sc, &zero, 0) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->conf_prefix || sc->root_prefix) {
        if (ngx_http_script_add_full_name_code(sc) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->complete_lengths) {
        code = ngx_http_script_add_code(*sc->lengths, sizeof(uintptr_t), NULL);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    if (sc->complete_values) {
        code = ngx_http_script_add_code(*sc->values, sizeof(uintptr_t),
                                        &sc->main);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    return NGX_OK;
}",687.0,729.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1252,236722,ngx_http_upstream_init_keepalive,1,ngx_http_upstream_init_keepalive,"ngx_int_t ngx_http_upstream_init_keepalive (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)",http\modules\ngx_http_upstream_keepalive_module.c,"static ngx_int_t
ngx_http_upstream_init_keepalive(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_uint_t                               i;
    ngx_http_upstream_keepalive_srv_conf_t  *kcf;
    ngx_http_upstream_keepalive_cache_t     *cached;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
                   ""init keepalive"");

    kcf = ngx_http_conf_upstream_srv_conf(us,
                                          ngx_http_upstream_keepalive_module);

    ngx_conf_init_msec_value(kcf->timeout, 60000);
    ngx_conf_init_uint_value(kcf->requests, 100);

    if (kcf->original_init_upstream(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    kcf->original_init_peer = us->peer.init;

    us->peer.init = ngx_http_upstream_init_keepalive_peer;

    /* allocate cache items and add to free queue */

    cached = ngx_pcalloc(cf->pool,
                sizeof(ngx_http_upstream_keepalive_cache_t) * kcf->max_cached);
    if (cached == NULL) {
        return NGX_ERROR;
    ...",138.0,180.0,1.0,1.0,43.0,34,10,35,12,0,12,4,4,2,1,,0,12,4,2,2,ngx_int_t
1253,298166,ngx_http_script_add_copy_code,1,ngx_http_script_add_copy_code,"ngx_int_t ngx_http_script_add_copy_code (ngx_http_script_compile_t*,ngx_str_t*,ngx_uint_t)",http\ngx_http_script.c,"static ngx_int_t
ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc, ngx_str_t *value,
    ngx_uint_t last)
{
    u_char                       *p;
    size_t                        size, len, zero;
    ngx_http_script_copy_code_t  *code;

    zero = (sc->zero && last);
    len = value->len + zero;

    code = ngx_http_script_add_code(*sc->lengths,
                                    sizeof(ngx_http_script_copy_code_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_http_script_code_pt) (void *)
                                                 ngx_http_script_copy_len_code;
    code->len = len;

    size = (sizeof(ngx_http_script_copy_code_t) + len + sizeof(uintptr_t) - 1)
            & ~(sizeof(uintptr_t) - 1);

    code = ngx_http_script_add_code(*sc->values, size, &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_http_script_copy_code;
    code->len = len;

    p = ngx_cpymem((u_char *) code + ...",770.0,811.0,1.0,1.0,42.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1254,404665,signo,3,ngx_signal_t.signo,,os\unix\ngx_process.c,signo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1255,257210,ngx_http_merge_types,1,ngx_http_merge_types,"char* ngx_http_merge_types (ngx_conf_t*,ngx_array_t**,ngx_hash_t*,ngx_array_t**,ngx_hash_t*,ngx_str_t*)",http\ngx_http.c,"char *
ngx_http_merge_types(ngx_conf_t *cf, ngx_array_t **keys, ngx_hash_t *types_hash,
    ngx_array_t **prev_keys, ngx_hash_t *prev_types_hash,
    ngx_str_t *default_types)
{
    ngx_hash_init_t  hash;

    if (*keys) {

        if (*keys == (void *) -1) {
            return NGX_CONF_OK;
        }

        hash.hash = types_hash;
        hash.key = NULL;
        hash.max_size = 2048;
        hash.bucket_size = 64;
        hash.name = ""test_types_hash"";
        hash.pool = cf->pool;
        hash.temp_pool = NULL;

        if (ngx_hash_init(&hash, (*keys)->elts, (*keys)->nelts) != NGX_OK) {
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    if (prev_types_hash->buckets == NULL) {

        if (*prev_keys == NULL) {

            if (ngx_http_set_default_types(cf, prev_keys, default_types)
                != NGX_OK)
            {
                return NGX_CONF_ERROR;
            }

        } else if (*prev_keys == (void *) -1) {
            *keys = *...",1984.0,2046.0,1.0,1.0,63.0,55,9,48,11,0,18,8,14,4,3,,0,18,12,6,6,char*
1256,404666,signame,3,ngx_signal_t.signame,,os\unix\ngx_process.c,*signame,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1257,298173,ngx_http_script_add_var_code,1,ngx_http_script_add_var_code,"ngx_int_t ngx_http_script_add_var_code (ngx_http_script_compile_t*,ngx_str_t*)",http\ngx_http_script.c,"static ngx_int_t
ngx_http_script_add_var_code(ngx_http_script_compile_t *sc, ngx_str_t *name)
{
    ngx_int_t                    index, *p;
    ngx_http_script_var_code_t  *code;

    index = ngx_http_get_variable_index(sc->cf, name);

    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (sc->flushes) {
        p = ngx_array_push(*sc->flushes);
        if (p == NULL) {
            return NGX_ERROR;
        }

        *p = index;
    }

    code = ngx_http_script_add_code(*sc->lengths,
                                    sizeof(ngx_http_script_var_code_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_http_script_code_pt) (void *)
                                             ngx_http_script_copy_var_len_code;
    code->index = (uintptr_t) index;

    code = ngx_http_script_add_code(*sc->values,
                                    sizeof(ngx_http_script_var_code_t),
                                    &sc->main);
    if (code ==...",850.0,892.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1258,298179,ngx_http_script_add_args_code,1,ngx_http_script_add_args_code,ngx_int_t ngx_http_script_add_args_code (ngx_http_script_compile_t*),http\ngx_http_script.c,"static ngx_int_t
ngx_http_script_add_args_code(ngx_http_script_compile_t *sc)
{
    uintptr_t   *code;

    code = ngx_http_script_add_code(*sc->lengths, sizeof(uintptr_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    *code = (uintptr_t) ngx_http_script_mark_args_code;

    code = ngx_http_script_add_code(*sc->values, sizeof(uintptr_t), &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    *code = (uintptr_t) ngx_http_script_start_args_code;

    return NGX_OK;
}",952.0,972.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1259,146637,ngx_http_gzip_filter_module,2,http\modules\ngx_http_gzip_filter_module.c.ngx_http_gzip_filter_module,,http\modules\ngx_http_gzip_filter_module.c,ngx_module_t ngx_http_gzip_filter_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1260,3280,ngx_array_push_n,1,ngx_array_push_n,"void* ngx_array_push_n (ngx_array_t*,ngx_uint_t)",core\ngx_array.c,"void *
ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)
{
    void        *elt, *new;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *p;

    size = n * a->size;

    if (a->nelts + n > a->nalloc) {

        /* the array is full */

        p = a->pool;

        if ((u_char *) a->elts + a->size * a->nalloc == p->d.last
            && p->d.last + size <= p->d.end)
        {
            /*
             * the array allocation is the last in the pool
             * and there is space for new allocation
             */

            p->d.last += size;
            a->nalloc += n;

        } else {
            /* allocate a new array */

            nalloc = 2 * ((n >= a->nalloc) ? n : a->nalloc);

            new = ngx_palloc(p, nalloc * a->size);
            if (new == NULL) {
                return NULL;
            }

            ngx_memcpy(new, a->elts, a->nelts * a->size);
            a->elts = new;
            a->nalloc = nalloc;
        }
    }

    elt = (u_char *) a...",94.0,141.0,1.0,1.0,48.0,39,11,26,5,4,12,3,4,5,0,,0,12,4,2,2,void*
1261,23760,ngx_list_create,1,ngx_list_create,"ngx_list_t ngx_list_create (ngx_pool_t*,ngx_uint_t,size_t)",core\ngx_list.c,"ngx_list_t *
ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    ngx_list_t  *list;

    list = ngx_palloc(pool, sizeof(ngx_list_t));
    if (list == NULL) {
        return NULL;
    }

    if (ngx_list_init(list, pool, n, size) != NGX_OK) {
        return NULL;
    }

    return list;
}",12.0,27.0,1.0,1.0,16.0,4,4,13,7,0,2,3,3,1,2,,0,2,6,3,3,ngx_list_t
1262,7379,ngx_conf_set_num_slot,1,ngx_conf_set_num_slot,"char* ngx_conf_set_num_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_int_t        *np;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    np = (ngx_int_t *) (p + cmd->offset);

    if (*np != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;
    *np = ngx_atoi(value[1].data, value[1].len);
    if (*np == NGX_ERROR) {
        return ""invalid number"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, np);
    }

    return NGX_CONF_OK;
}",1166.0,1194.0,1.0,1.0,29.0,22,9,22,10,0,2,4,4,0,1,,0,2,6,3,3,char*
1263,11477,ngx_crc32_table_short,2,core\ngx_crc32.h.ngx_crc32_table_short,,core\ngx_crc32.h,uint32_t* ngx_crc32_table_short,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1264,11478,ngx_crc32_table256,2,core\ngx_crc32.h.ngx_crc32_table256,,core\ngx_crc32.h,extern uint32_t[] ngx_crc32_table256,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1265,240855,ngx_http_userid_got_variable,1,ngx_http_userid_got_variable,"ngx_int_t ngx_http_userid_got_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_got_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r->main, ngx_http_userid_filter_module);

    if (conf->enable == NGX_HTTP_USERID_OFF) {
        v->not_found = 1;
        return NGX_OK;
    }

    ctx = ngx_http_userid_get_uid(r->main, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ctx->uid_got[3] != 0) {
        return ngx_http_userid_variable(r->main, v, &conf->name, ctx->uid_got);
    }

    v->not_found = 1;

    return NGX_OK;
}",226.0,253.0,1.0,24.0,28.0,18,6,19,8,0,7,4,4,2,2,,0,6,6,3,3,ngx_int_t
1266,298199,ngx_http_script_exit_code,2,http\ngx_http_script.c.ngx_http_script_exit_code,,http\ngx_http_script.c,uintptr_t ngx_http_script_exit_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1267,11482,ngx_crc32_short,1,ngx_crc32_short,"ANY ngx_crc32_short (u_char*,size_t)",core\ngx_crc32.h,"ngx_crc32_short(u_char *p, size_t len)
{
    u_char    c;
    uint32_t  crc;

    crc = 0xffffffff;

    while (len--) {
        c = *p++;
        crc = ngx_crc32_table_short[(crc ^ (c & 0xf)) & 0xf] ^ (crc >> 4);
        crc = ngx_crc32_table_short[(crc ^ (c >> 4)) & 0xf] ^ (crc >> 4);
    }

    return crc ^ 0xffffffff;
}",21.0,35.0,1.0,1.0,15.0,20,8,15,5,3,2,2,2,0,0,,0,2,4,2,2,ANY
1268,298205,ngx_http_script_flush_complex_value,1,ngx_http_script_flush_complex_value,"void ngx_http_script_flush_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*)",http\ngx_http_script.c,"void
ngx_http_script_flush_complex_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *val)
{
    ngx_uint_t *index;

    index = val->flushes;

    if (index) {
        while (*index != (ngx_uint_t) -1) {

            if (r->variables[*index].no_cacheable) {
                r->variables[*index].valid = 0;
                r->variables[*index].not_found = 0;
            }

            index++;
        }
    }
}",35.0,54.0,1.0,1.0,20.0,20,8,12,4,1,1,4,7,0,0,,0,1,4,2,2,void
1269,404702,ngx_process_slot,2,os\unix\ngx_process.c.ngx_process_slot,,os\unix\ngx_process.c,ngx_int_t ngx_process_slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1270,404703,ngx_channel,2,os\unix\ngx_process.c.ngx_channel,,os\unix\ngx_process.c,ngx_socket_t ngx_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1271,404704,ngx_last_process,2,os\unix\ngx_process.c.ngx_last_process,,os\unix\ngx_process.c,ngx_int_t ngx_last_process,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1272,404705,ngx_processes,2,os\unix\ngx_process.c.ngx_processes,,os\unix\ngx_process.c,ngx_process_t[] ngx_processes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
1273,101606,name,3,ngx_http_autoindex_entry_t.name,,http\modules\ngx_http_autoindex_module.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1274,146662,ngx_http_gzip_header_filter,1,ngx_http_gzip_header_filter,ngx_int_t ngx_http_gzip_header_filter (ngx_http_request_t*),http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_header_filter(ngx_http_request_t *r)
{
    ngx_table_elt_t       *h;
    ngx_http_gzip_ctx_t   *ctx;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    if (!conf->enable
        || (r->headers_out.status != NGX_HTTP_OK
            && r->headers_out.status != NGX_HTTP_FORBIDDEN
            && r->headers_out.status != NGX_HTTP_NOT_FOUND)
        || (r->headers_out.content_encoding
            && r->headers_out.content_encoding->value.len)
        || (r->headers_out.content_length_n != -1
            && r->headers_out.content_length_n < conf->min_length)
        || ngx_http_test_content_type(r, &conf->types) == NULL
        || r->header_only)
    {
        return ngx_http_next_header_filter(r);
    }

    r->gzip_vary = 1;

#if (NGX_HTTP_DEGRADATION)
    {
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->gzip_disable_degradati...",219.0,294.0,1.0,1.0,76.0,70,12,55,12,0,17,6,7,4,5,,0,15,2,1,1,ngx_int_t
1275,302312,ngx_http_script_nop_code,1,ngx_http_script_nop_code,void ngx_http_script_nop_code (ngx_http_script_engine_t*),http\ngx_http_script.c,"void
ngx_http_script_nop_code(ngx_http_script_engine_t *e)
{
    e->ip += sizeof(uintptr_t);
}",1857.0,1861.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1276,101610,dir,3,ngx_http_autoindex_entry_t.dir,,http\modules\ngx_http_autoindex_module.c,dir:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1277,101611,file,3,ngx_http_autoindex_entry_t.file,,http\modules\ngx_http_autoindex_module.c,file:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1278,101612,mtime,3,ngx_http_autoindex_entry_t.mtime,,http\modules\ngx_http_autoindex_module.c,mtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1279,101613,size,3,ngx_http_autoindex_entry_t.size,,http\modules\ngx_http_autoindex_module.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1280,101614,ngx_http_autoindex_entry_t,2,http\modules\ngx_http_autoindex_module.c.ngx_http_autoindex_entry_t,,http\modules\ngx_http_autoindex_module.c,struct ngx_http_autoindex_entry_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1281,52463,ngx_sha1_final,1,ngx_sha1_final,"void ngx_sha1_final (u_char[20],ngx_sha1_t*)",core\ngx_sha1.c,"void
ngx_sha1_final(u_char result[20], ngx_sha1_t *ctx)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);

    ctx->buffer[used++] = 0x80;

    free = 64 - used;

    if (free < 8) {
        ngx_memzero(&ctx->buffer[used], free);
        (void) ngx_sha1_body(ctx, ctx->buffer, 64);
        used = 0;
        free = 64;
    }

    ngx_memzero(&ctx->buffer[used], free - 8);

    ctx->bytes <<= 3;
    ctx->buffer[56] = (u_char) (ctx->bytes >> 56);
    ctx->buffer[57] = (u_char) (ctx->bytes >> 48);
    ctx->buffer[58] = (u_char) (ctx->bytes >> 40);
    ctx->buffer[59] = (u_char) (ctx->bytes >> 32);
    ctx->buffer[60] = (u_char) (ctx->bytes >> 24);
    ctx->buffer[61] = (u_char) (ctx->bytes >> 16);
    ctx->buffer[62] = (u_char) (ctx->bytes >> 8);
    ctx->buffer[63] = (u_char) ctx->bytes;

    (void) ngx_sha1_body(ctx, ctx->buffer, 64);

    result[0] = (u_char) (ctx->a >> 24);
    result[1] = (u_char) (ctx->a >> 16);
    result[2] = (u_char) (ctx->a >> 8);
    result[3...",63.0,117.0,1.0,1.0,55.0,146,12,78,4,0,45,2,2,0,2,,0,43,4,2,2,void
1282,126192,end,3,ngx_http_geo_range_t.end,,http\modules\ngx_http_geo_module.c,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1283,126191,start,3,ngx_http_geo_range_t.start,,http\modules\ngx_http_geo_module.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1284,101616,enable,3,ngx_http_autoindex_loc_conf_t.enable,,http\modules\ngx_http_autoindex_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1285,404723,ngx_spawn_process,1,ngx_spawn_process,"ngx_pid_t ngx_spawn_process (ngx_cycle_t*,ngx_spawn_proc_pt,void*,char*,ngx_int_t)",os\win32\ngx_process.c,"ngx_pid_t
ngx_spawn_process(ngx_cycle_t *cycle, char *name, ngx_int_t respawn)
{
    u_long          rc, n, code;
    ngx_int_t       s;
    ngx_pid_t       pid;
    ngx_exec_ctx_t  ctx;
    HANDLE          events[2];
    char            file[MAX_PATH + 1];

    if (respawn >= 0) {
        s = respawn;

    } else {
        for (s = 0; s < ngx_last_process; s++) {
            if (ngx_processes[s].handle == NULL) {
                break;
            }
        }

        if (s == NGX_MAX_PROCESSES) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                          ""no more than %d processes can be spawned"",
                          NGX_MAX_PROCESSES);
            return NGX_INVALID_PID;
        }
    }

    n = GetModuleFileName(NULL, file, MAX_PATH);

    if (n == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""GetModuleFileName() failed"");
        return NGX_INVALID_PID;
    }

    file[n] = '\0';

    ngx_log_debug1(NGX_LOG_...",20.0,203.0,1.0,1.0,184.0,149,10,163,30,1,58,21,21,10,16,,0,44,6,3,3,ngx_pid_t
1286,93427,expire_queue,3,ngx_ssl_session_cache_t.expire_queue,,event\ngx_event_openssl.h,expire_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1287,101621,ngx_http_autoindex_html,1,ngx_http_autoindex_html,"ngx_buf_t* ngx_http_autoindex_html (ngx_http_request_t*,ngx_array_t*)",http\modules\ngx_http_autoindex_module.c,"static ngx_buf_t *
ngx_http_autoindex_html(ngx_http_request_t *r, ngx_array_t *entries)
{
    u_char                         *last, scale;
    off_t                           length;
    size_t                          len, entry_len, char_len, escape_html;
    ngx_tm_t                        tm;
    ngx_buf_t                      *b;
    ngx_int_t                       size;
    ngx_uint_t                      i, utf8;
    ngx_time_t                     *tp;
    ngx_http_autoindex_entry_t     *entry;
    ngx_http_autoindex_loc_conf_t  *alcf;

    static u_char  title[] =
        ""<html>"" CRLF
        ""<head><title>Index of ""
    ;

    static u_char  header[] =
        ""</title></head>"" CRLF
        ""<body>"" CRLF
        ""<h1>Index of ""
    ;

    static u_char  tail[] =
        ""</body>"" CRLF
        ""</html>"" CRLF
    ;

    static char  *months[] = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
                               ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };

    if (r->h...",432.0,699.0,1.0,20.0,268.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_buf_t
1288,93425,session_rbtree,3,ngx_ssl_session_cache_t.session_rbtree,,event\ngx_event_openssl.h,session_rbtree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1289,126190,value,3,ngx_http_geo_range_t.value,,http\modules\ngx_http_geo_module.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1290,101617,format,3,ngx_http_autoindex_loc_conf_t.format,,http\modules\ngx_http_autoindex_module.c,format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1291,93426,sentinel,3,ngx_ssl_session_cache_t.sentinel,,event\ngx_event_openssl.h,sentinel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1292,23794,ngx_list_push,1,ngx_list_push,void* ngx_list_push (ngx_list_t*),core\ngx_list.c,"void *
ngx_list_push(ngx_list_t *l)
{
    void             *elt;
    ngx_list_part_t  *last;

    last = l->last;

    if (last->nelts == l->nalloc) {

        /* the last part is full, allocate a new list part */

        last = ngx_palloc(l->pool, sizeof(ngx_list_part_t));
        if (last == NULL) {
            return NULL;
        }

        last->elts = ngx_palloc(l->pool, l->nalloc * l->size);
        if (last->elts == NULL) {
            return NULL;
        }

        last->nelts = 0;
        last->next = NULL;

        l->last->next = last;
        l->last = last;
    }

    elt = (char *) last->elts + l->size * last->nelts;
    last->nelts++;

    return elt;
}",30.0,63.0,1.0,1.0,34.0,35,8,30,5,9,11,4,6,1,2,,0,11,2,1,1,void*
1293,101627,ngx_http_autoindex_json,1,ngx_http_autoindex_json,"ngx_buf_t* ngx_http_autoindex_json (ngx_http_request_t*,ngx_array_t*,ngx_str_t*)",http\modules\ngx_http_autoindex_module.c,"static ngx_buf_t *
ngx_http_autoindex_json(ngx_http_request_t *r, ngx_array_t *entries,
    ngx_str_t *callback)
{
    size_t                       len, entry_len;
    ngx_buf_t                   *b;
    ngx_uint_t                   i;
    ngx_http_autoindex_entry_t  *entry;

    len = sizeof(""["" CRLF CRLF ""]"") - 1;

    if (callback) {
        len += sizeof(""/* callback */"" CRLF ""();"") - 1 + callback->len;
    }

    entry = entries->elts;

    for (i = 0; i < entries->nelts; i++) {
        entry[i].escape = ngx_escape_json(NULL, entry[i].name.data,
                                          entry[i].name.len);

        entry_len = sizeof(""{  },"" CRLF) - 1
                  + sizeof(""\""name\"":\""\"""") - 1
                  + entry[i].name.len + entry[i].escape
                  + sizeof("", \""type\"":\""directory\"""") - 1
                  + sizeof("", \""mtime\"":\""Wed, 31 Dec 1986 10:00:00 GMT\"""") - 1;

        if (entry[i].file) {
            entry_len += sizeof("", \""size\"":"") - 1 + NGX_O...",702.0,809.0,1.0,1.0,108.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_buf_t
1294,302335,ip,3,ngx_http_script_engine_t.ip,,http\ngx_http_script.h,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,53,0,1,1,0,0,,0,0,0,0,0,
1295,302336,pos,3,ngx_http_script_engine_t.pos,,http\ngx_http_script.h,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1296,302337,sp,3,ngx_http_script_engine_t.sp,,http\ngx_http_script.h,*sp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
1297,101634,ngx_http_autoindex_jsonp_callback,1,ngx_http_autoindex_jsonp_callback,"ngx_int_t ngx_http_autoindex_jsonp_callback (ngx_http_request_t*,ngx_str_t*)",http\modules\ngx_http_autoindex_module.c,"static ngx_int_t
ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r, ngx_str_t *callback)
{
    u_char      *p, c, ch;
    ngx_uint_t   i;

    if (ngx_http_arg(r, (u_char *) ""callback"", 8, callback) != NGX_OK) {
        callback->len = 0;
        return NGX_OK;
    }

    if (callback->len > 128) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent too long callback name: \""%V\"""", callback);
        return NGX_DECLINED;
    }

    p = callback->data;

    for (i = 0; i < callback->len; i++) {
        ch = p[i];

        c = (u_char) (ch | 0x20);
        if (c >= 'a' && c <= 'z') {
            continue;
        }

        if ((ch >= '0' && ch <= '9') || ch == '_' || ch == '.') {
            continue;
        }

        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid callback name: \""%V\"""", callback);

        return NGX_DECLINED;
    }

    return NGX_OK;
}",812.0,850.0,1.0,1.0,39.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1298,302338,buf,3,ngx_http_script_engine_t.buf,,http\ngx_http_script.h,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1299,302339,line,3,ngx_http_script_engine_t.line,,http\ngx_http_script.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1300,302340,args,3,ngx_http_script_engine_t.args,,http\ngx_http_script.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1301,302341,flushed,3,ngx_http_script_engine_t.flushed,,http\ngx_http_script.h,flushed:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1302,302342,skip,3,ngx_http_script_engine_t.skip,,http\ngx_http_script.h,skip:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1303,101640,ngx_http_autoindex_xml,1,ngx_http_autoindex_xml,"ngx_buf_t* ngx_http_autoindex_xml (ngx_http_request_t*,ngx_array_t*)",http\modules\ngx_http_autoindex_module.c,"static ngx_buf_t *
ngx_http_autoindex_xml(ngx_http_request_t *r, ngx_array_t *entries)
{
    size_t                          len, entry_len;
    ngx_tm_t                        tm;
    ngx_buf_t                      *b;
    ngx_str_t                       type;
    ngx_uint_t                      i;
    ngx_http_autoindex_entry_t     *entry;

    static u_char  head[] = ""<?xml version=\""1.0\""?>"" CRLF ""<list>"" CRLF;
    static u_char  tail[] = ""</list>"" CRLF;

    len = sizeof(head) - 1 + sizeof(tail) - 1;

    entry = entries->elts;

    for (i = 0; i < entries->nelts; i++) {
        entry[i].escape = ngx_escape_html(NULL, entry[i].name.data,
                                          entry[i].name.len);

        entry_len = sizeof(""<directory></directory>"" CRLF) - 1
                  + entry[i].name.len + entry[i].escape
                  + sizeof("" mtime=\""1986-12-31T10:00:00Z\"""") - 1;

        if (entry[i].file) {
            entry_len += sizeof("" size=\""\"""") - 1 + NGX_OFF_T_LEN;
...",853.0,948.0,1.0,1.0,96.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_buf_t
1304,302345,log,3,ngx_http_script_engine_t.log,,http\ngx_http_script.h,log:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1305,302343,quote,3,ngx_http_script_engine_t.quote,,http\ngx_http_script.h,quote:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1306,15624,daemon,3,ngx_core_conf_t.daemon,,core\ngx_cycle.h,daemon,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1307,302344,is_args,3,ngx_http_script_engine_t.is_args,,http\ngx_http_script.h,is_args:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1308,302346,status,3,ngx_http_script_engine_t.status,,http\ngx_http_script.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1309,15627,shutdown_timeout,3,ngx_core_conf_t.shutdown_timeout,,core\ngx_cycle.h,shutdown_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1310,101647,ngx_http_autoindex_error,1,ngx_http_autoindex_error,"ngx_int_t ngx_http_autoindex_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)",http\modules\ngx_http_autoindex_module.c,"static ngx_int_t
ngx_http_autoindex_error(ngx_http_request_t *r, ngx_dir_t *dir, ngx_str_t *name)
{
    if (ngx_close_dir(dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,
                      ngx_close_dir_n "" \""%V\"" failed"", name);
    }

    return r->header_sent ? NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR;
}",1009.0,1018.0,1.0,1.0,10.0,0,0,0,0,7,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1311,302347,request,3,ngx_http_script_engine_t.request,,http\ngx_http_script.h,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
1312,15629,debug_points,3,ngx_core_conf_t.debug_points,,core\ngx_cycle.h,debug_points,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1313,11538,ngx_crc32_long,1,ngx_crc32_long,"ANY ngx_crc32_long (u_char*,size_t)",core\ngx_crc32.h,"ngx_crc32_long(u_char *p, size_t len)
{
    uint32_t  crc;

    crc = 0xffffffff;

    while (len--) {
        crc = ngx_crc32_table256[(crc ^ *p++) & 0xff] ^ (crc >> 8);
    }

    return crc ^ 0xffffffff;
}",39.0,50.0,1.0,1.0,12.0,11,8,8,4,1,1,2,2,0,0,,0,1,4,2,2,ANY
1314,302350,cf,3,ngx_http_script_compile_t.cf,,http\ngx_http_script.h,*cf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1315,298260,ngx_http_complex_value,1,ngx_http_complex_value,"ngx_int_t ngx_http_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*,ngx_str_t*)",http\ngx_http_script.c,"ngx_int_t
ngx_http_complex_value(ngx_http_request_t *r, ngx_http_complex_value_t *val,
    ngx_str_t *value)
{
    size_t                        len;
    ngx_http_script_code_pt       code;
    ngx_http_script_len_code_pt   lcode;
    ngx_http_script_engine_t      e;

    if (val->lengths == NULL) {
        *value = val->value;
        return NGX_OK;
    }

    ngx_http_script_flush_complex_value(r, val);

    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));

    e.ip = val->lengths;
    e.request = r;
    e.flushed = 1;

    len = 0;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_http_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }

    value->len = len;
    value->data = ngx_pnalloc(r->pool, len);
    if (value->data == NULL) {
        return NGX_ERROR;
    }

    e.ip = val->values;
    e.pos = value->data;
    e.buf = *value;

    while (*(uintptr_t *) e.ip) {
        code = *(ngx_http_script_code_pt *) e.ip;
        code((ngx_http_script_engine_t *) &e);...",57.0,104.0,1.0,1.0,48.0,52,9,41,11,19,21,5,5,4,2,,0,20,6,3,3,ngx_int_t
1316,302351,source,3,ngx_http_script_compile_t.source,,http\ngx_http_script.h,*source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1317,302353,lengths,3,ngx_http_script_compile_t.lengths,,http\ngx_http_script.h,**lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1318,302355,variables,3,ngx_http_script_compile_t.variables,,http\ngx_http_script.h,variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1319,302354,values,3,ngx_http_script_compile_t.values,,http\ngx_http_script.h,**values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1320,15637,user,3,ngx_core_conf_t.user,,core\ngx_cycle.h,user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1321,302362,complete_values,3,ngx_http_script_compile_t.complete_values,,http\ngx_http_script.h,complete_values:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1322,302358,size,3,ngx_http_script_compile_t.size,,http\ngx_http_script.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1323,302364,conf_prefix,3,ngx_http_script_compile_t.conf_prefix,,http\ngx_http_script.h,conf_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1324,126237,ngx_http_geo_addr,1,ngx_http_geo_addr,"ngx_int_t ngx_http_geo_addr (ngx_http_request_t*,ngx_http_geo_ctx_t*,ngx_addr_t*)",http\modules\ngx_http_geo_module.c,"static ngx_int_t
ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,
    ngx_addr_t *addr)
{
    ngx_array_t  *xfwd;

    if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {
        return NGX_ERROR;
    }

    xfwd = &r->headers_in.x_forwarded_for;

    if (xfwd->nelts > 0 && ctx->proxies != NULL) {
        (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,
                                           ctx->proxies, ctx->proxy_recursive);
    }

    return NGX_OK;
}",326.0,344.0,1.0,1.0,19.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1325,302360,compile_args,3,ngx_http_script_compile_t.compile_args,,http\ngx_http_script.h,compile_args:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1326,15641,pid,3,ngx_core_conf_t.pid,,core\ngx_cycle.h,pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1327,15642,oldpid,3,ngx_core_conf_t.oldpid,,core\ngx_cycle.h,oldpid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1328,15643,env,3,ngx_core_conf_t.env,,core\ngx_cycle.h,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1329,240930,ngx_http_userid_set_variable,1,ngx_http_userid_set_variable,"ngx_int_t ngx_http_userid_set_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_userid_filter_module.c,"static ngx_int_t
ngx_http_userid_set_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r->main, ngx_http_userid_filter_module);

    if (conf->enable < NGX_HTTP_USERID_V1) {
        v->not_found = 1;
        return NGX_OK;
    }

    ctx = ngx_http_userid_get_uid(r->main, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ngx_http_userid_create_uid(r->main, ctx, conf) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ctx->uid_set[3] == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    return ngx_http_userid_variable(r->main, v, &conf->name, ctx->uid_set);
}",256.0,286.0,1.0,23.0,31.0,20,7,24,8,0,8,5,5,3,3,,0,7,6,3,3,ngx_int_t
1330,400668,ngx_chain_to_iovec,1,ngx_chain_to_iovec,"ngx_chain_t* ngx_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*)",os\unix\ngx_files.c,"static ngx_chain_t *
ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl)
{
    size_t         total, size;
    u_char        *prev;
    ngx_uint_t     n;
    struct iovec  *iov;

    iov = NULL;
    prev = NULL;
    total = 0;
    n = 0;

    for ( /* void */ ; cl; cl = cl->next) {

        if (ngx_buf_special(cl->buf)) {
            continue;
        }

        size = cl->buf->last - cl->buf->pos;

        if (prev == cl->buf->pos) {
            iov->iov_len += size;

        } else {
            if (n == vec->nalloc) {
                break;
            }

            iov = &vec->iovs[n++];

            iov->iov_base = (void *) cl->buf->pos;
            iov->iov_len = size;
        }

        prev = cl->buf->pos + size;
        total += size;
    }

    vec->count = n;
    vec->size = total;

    return cl;
}",345.0,388.0,1.0,1.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_chain_t
1331,302365,root_prefix,3,ngx_http_script_compile_t.root_prefix,,http\ngx_http_script.h,root_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1332,15644,environment,3,ngx_core_conf_t.environment,,core\ngx_cycle.h,**environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1333,302367,args,3,ngx_http_script_compile_t.args,,http\ngx_http_script.h,args:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1334,302370,value,3,ngx_http_complex_value_t.value,,http\ngx_http_script.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1335,412968,ngx_event_log,1,ngx_event_log,"ANY ngx_event_log (ngx_err_t,char*...)",os\win32\ngx_event_log.c,"ngx_event_log(ngx_err_t err, const char *fmt, ...)
{
    u_char         *p, *last;
    long            types;
    HKEY            key;
    HANDLE          ev;
    va_list         args;
    u_char          text[NGX_MAX_ERROR_STR];
    const char     *msgarg[9];
    static u_char   netmsg[] = ""%SystemRoot%\\System32\\netmsg.dll"";

    last = text + NGX_MAX_ERROR_STR;
    p = text + GetModuleFileName(NULL, (char *) text, NGX_MAX_ERROR_STR - 50);

    *p++ = ':';
    ngx_linefeed(p);

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (p > last - NGX_LINEFEED_SIZE - 1) {
        p = last - NGX_LINEFEED_SIZE - 1;
    }

    ngx_linefeed(p);

    *p = '\0';

    /*
     * we do not log errors here since we use
     * Event Log only to log our own logs open errors
     */

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
           ""SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\...",15.0,99.0,1.0,25.0,85.0,50,11,74,20,0,2,6,6,0,2,,0,2,4,2,2,ANY
1336,7459,ngx_conf_set_size_slot,1,ngx_conf_set_size_slot,"char* ngx_conf_set_size_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_size_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    size_t           *sp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    sp = (size_t *) (p + cmd->offset);
    if (*sp != NGX_CONF_UNSET_SIZE) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *sp = ngx_parse_size(&value[1]);
    if (*sp == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, sp);
    }

    return NGX_CONF_OK;
}",1197.0,1225.0,1.0,1.0,29.0,21,9,21,10,0,2,4,4,0,1,,0,2,6,3,3,char*
1337,302372,lengths,3,ngx_http_complex_value_t.lengths,,http\ngx_http_script.h,*lengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1338,302373,values,3,ngx_http_complex_value_t.values,,http\ngx_http_script.h,*values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1339,458021,ngx_stream_upstream_init_least_conn,1,ngx_stream_upstream_init_least_conn,"ngx_int_t ngx_stream_upstream_init_least_conn (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)",stream\ngx_stream_upstream_least_conn_module.c,"static ngx_int_t
ngx_stream_upstream_init_least_conn(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, cf->log, 0,
                   ""init least conn"");

    if (ngx_stream_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_stream_upstream_init_least_conn_peer;

    return NGX_OK;
}",62.0,76.0,1.0,1.0,15.0,5,4,9,6,0,1,2,2,1,1,,0,1,4,2,2,ngx_int_t
1340,400681,ngx_read_file,1,ngx_read_file,"ssize_t ngx_read_file (ngx_file_t*,u_char*,size_t,off_t)",os\win32\ngx_files.c,"ssize_t
ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    u_long      n;
    ngx_err_t   err;
    OVERLAPPED  ovlp, *povlp;

    ovlp.Internal = 0;
    ovlp.InternalHigh = 0;
    ovlp.Offset = (u_long) offset;
    ovlp.OffsetHigh = (u_long) (offset >> 32);
    ovlp.hEvent = NULL;

    povlp = &ovlp;

    if (ReadFile(file->fd, buf, size, &n, povlp) == 0) {
        err = ngx_errno;

        if (err == ERROR_HANDLE_EOF) {
            return 0;
        }

        ngx_log_error(NGX_LOG_ERR, file->log, err,
                      ""ReadFile() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    file->offset += n;

    return n;
}",61.0,91.0,1.0,1.0,31.0,23,7,33,10,4,2,4,5,0,2,,0,0,8,4,4,ssize_t
1341,302379,cf,3,ngx_http_compile_complex_value_t.cf,,http\ngx_http_script.h,*cf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1342,302380,value,3,ngx_http_compile_complex_value_t.value,,http\ngx_http_script.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1343,302381,complex_value,3,ngx_http_compile_complex_value_t.complex_value,,http\ngx_http_script.h,*complex_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1344,302382,zero,3,ngx_http_compile_complex_value_t.zero,,http\ngx_http_script.h,zero:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1345,326959,ngx_http_variables_add_core_vars,1,ngx_http_variables_add_core_vars,ngx_int_t ngx_http_variables_add_core_vars (ngx_conf_t*),http\ngx_http_variables.c,"ngx_int_t
ngx_http_variables_add_core_vars(ngx_conf_t *cf)
{
    ngx_http_variable_t        *cv, *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    cmcf->variables_keys = ngx_pcalloc(cf->temp_pool,
                                       sizeof(ngx_hash_keys_arrays_t));
    if (cmcf->variables_keys == NULL) {
        return NGX_ERROR;
    }

    cmcf->variables_keys->pool = cf->pool;
    cmcf->variables_keys->temp_pool = cf->pool;

    if (ngx_hash_keys_array_init(cmcf->variables_keys, NGX_HASH_SMALL)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->prefix_variables, cf->pool, 8,
                       sizeof(ngx_http_variable_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (cv = ngx_http_core_variables; cv->name.len; cv++) {
        v = ngx_http_add_variable(cf, &cv->name, cv->flags);
        if (v == NULL) {
            return NGX_ERROR;
        }

    ...",2591.0,2631.0,1.0,1.0,41.0,33,8,35,12,0,11,6,7,5,4,,0,11,2,1,1,ngx_int_t
1346,302384,root_prefix,3,ngx_http_compile_complex_value_t.root_prefix,,http\ngx_http_script.h,root_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1347,302383,conf_prefix,3,ngx_http_compile_complex_value_t.conf_prefix,,http\ngx_http_script.h,conf_prefix:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1348,159032,ngx_http_limit_conn_init_zone,1,ngx_http_limit_conn_init_zone,"ngx_int_t ngx_http_limit_conn_init_zone (ngx_shm_zone_t*,void*)",http\modules\ngx_http_limit_conn_module.c,"static ngx_int_t
ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_limit_conn_ctx_t  *octx = data;

    size_t                      len;
    ngx_http_limit_conn_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_conn_zone \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
    ...",436.0,495.0,1.0,1.0,60.0,83,10,48,10,0,30,6,7,7,4,,0,28,4,2,2,ngx_int_t
1349,302398,len,3,ngx_http_script_copy_code_t.len,,http\ngx_http_script.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1350,302402,index,3,ngx_http_script_var_code_t.index,,http\ngx_http_script.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1351,302406,handler,3,ngx_http_script_var_handler_code_t.handler,,http\ngx_http_script.h,handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1352,302407,data,3,ngx_http_script_var_handler_code_t.data,,http\ngx_http_script.h,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1353,302419,status,3,ngx_http_script_return_code_t.status,,http\ngx_http_script.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1354,302420,text,3,ngx_http_script_return_code_t.text,,http\ngx_http_script.h,text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1355,93533,ngx_ssl_ocsp_validate,1,ngx_ssl_ocsp_validate,ngx_int_t ngx_ssl_ocsp_validate (ngx_connection_t*),event\ngx_event_openssl_stapling.c,"ngx_int_t
ngx_ssl_ocsp_validate(ngx_connection_t *c)
{
    return NGX_OK;
}",2751.0,2755.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1356,339294,ngx_http_v2_read_request_body,1,ngx_http_v2_read_request_body,ngx_int_t ngx_http_v2_read_request_body (ngx_http_request_t*),http\v2\ngx_http_v2.c,"ngx_int_t
ngx_http_v2_read_request_body(ngx_http_request_t *r)
{
    off_t                      len;
    size_t                     size;
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_v2_connection_t  *h2c;

    stream = r->stream;
    rb = r->request_body;

    if (stream->skip_data) {
        r->request_body_no_buffering = 0;
        rb->post_handler(r);
        return NGX_OK;
    }

    h2scf = ngx_http_get_module_srv_conf(r, ngx_http_v2_module);
    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    len = r->headers_in.content_length_n;

    if (r->request_body_no_buffering && !stream->in_closed) {

        if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {
            len = clcf->client_body_buffer_size;
        }

        /*
         * We need a room to store data up...",3803.0,3935.0,1.0,1.0,133.0,91,13,95,20,0,15,17,26,4,8,,0,12,2,1,1,ngx_int_t
1357,68959,ngx_monotonic_time,1,ngx_monotonic_time,"ngx_msec_t ngx_monotonic_time (time_t,ngx_uint_t)",core\ngx_times.c,"static ngx_msec_t
ngx_monotonic_time(time_t sec, ngx_uint_t msec)
{
#if (NGX_HAVE_CLOCK_MONOTONIC)
    struct timespec  ts;

#if defined(CLOCK_MONOTONIC_FAST)
    clock_gettime(CLOCK_MONOTONIC_FAST, &ts);

#elif defined(CLOCK_MONOTONIC_COARSE)
    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);

#else
    clock_gettime(CLOCK_MONOTONIC, &ts);
#endif

    sec = ts.tv_sec;
    msec = ts.tv_nsec / 1000000;

#endif

    return (ngx_msec_t) sec * 1000 + msec;
}",195.0,217.0,1.0,1.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_msec_t
1358,93538,ngx_ssl_ocsp_get_status,1,ngx_ssl_ocsp_get_status,"ngx_int_t ngx_ssl_ocsp_get_status (ngx_connection_t*,char**)",event\ngx_event_openssl_stapling.c,"ngx_int_t
ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)
{
    return NGX_OK;
}",2758.0,2762.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1359,11620,ngx_destroy_cycle_pools,1,ngx_destroy_cycle_pools,void ngx_destroy_cycle_pools (ngx_conf_t*),core\ngx_cycle.c,"static void
ngx_destroy_cycle_pools(ngx_conf_t *conf)
{
    ngx_destroy_pool(conf->temp_pool);
    ngx_destroy_pool(conf->pool);
}",933.0,938.0,1.0,1.0,6.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
1360,68965,slot,2,core\ngx_times.c.slot,,core\ngx_times.c,ngx_uint_t slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1361,68966,ngx_time_lock,2,core\ngx_times.c.ngx_time_lock,,core\ngx_times.c,ngx_atomic_t ngx_time_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1362,68967,ngx_current_msec,2,core\ngx_times.c.ngx_current_msec,,core\ngx_times.c,volatile ngx_msec_t ngx_current_msec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1363,68968,ngx_cached_time,2,core\ngx_times.c.ngx_cached_time,,core\ngx_times.c,volatile ngx_time_t* ngx_cached_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1364,68969,ngx_cached_err_log_time,2,core\ngx_times.c.ngx_cached_err_log_time,,core\ngx_times.c,volatile ngx_str_t ngx_cached_err_log_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1365,68970,ngx_cached_http_time,2,core\ngx_times.c.ngx_cached_http_time,,core\ngx_times.c,volatile ngx_str_t ngx_cached_http_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1366,68971,ngx_cached_http_log_time,2,core\ngx_times.c.ngx_cached_http_log_time,,core\ngx_times.c,volatile ngx_str_t ngx_cached_http_log_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1367,11625,ngx_init_zone_pool,1,ngx_init_zone_pool,"ngx_int_t ngx_init_zone_pool (ngx_cycle_t*,ngx_shm_zone_t*)",core\ngx_cycle.c,"static ngx_int_t
ngx_init_zone_pool(ngx_cycle_t *cycle, ngx_shm_zone_t *zn)
{
    u_char           *file;
    ngx_slab_pool_t  *sp;

    sp = (ngx_slab_pool_t *) zn->shm.addr;

    if (zn->shm.exists) {

        if (sp == sp->addr) {
            return NGX_OK;
        }

#if (NGX_WIN32)

        /* remap at the required address */

        if (ngx_shm_remap(&zn->shm, sp->addr) != NGX_OK) {
            return NGX_ERROR;
        }

        sp = (ngx_slab_pool_t *) zn->shm.addr;

        if (sp == sp->addr) {
            return NGX_OK;
        }

#endif

        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""shared zone \""%V\"" has no equal addresses: %p vs %p"",
                      &zn->shm.name, sp->addr, sp);
        return NGX_ERROR;
    }

    sp->end = zn->shm.addr + zn->shm.size;
    sp->min_shift = 3;
    sp->addr = zn->shm.addr;

#if (NGX_HAVE_ATOMIC_OPS)

    file = NULL;

#else

    file = ngx_pnalloc(cycle->pool,
                       cycle->lock_file.l...",941.0,1004.0,1.0,1.0,64.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1368,68973,ngx_cached_syslog_time,2,core\ngx_times.c.ngx_cached_syslog_time,,core\ngx_times.c,volatile ngx_str_t ngx_cached_syslog_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1369,68974,cached_gmtoff,2,core\ngx_times.c.cached_gmtoff,,core\ngx_times.c,ngx_int_t cached_gmtoff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1370,11631,ngx_test_lockfile,1,ngx_test_lockfile,"ngx_int_t ngx_test_lockfile (u_char*,ngx_log_t*)",core\ngx_cycle.c,"static ngx_int_t
ngx_test_lockfile(u_char *file, ngx_log_t *log)
{
#if !(NGX_HAVE_ATOMIC_OPS)
    ngx_fd_t  fd;

    fd = ngx_open_file(file, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,
                       NGX_FILE_DEFAULT_ACCESS);

    if (fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file);
        return NGX_ERROR;
    }

    if (ngx_close_file(fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", file);
    }

    if (ngx_delete_file(file) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", file);
    }

#endif

    return NGX_OK;
}",1123.0,1151.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1371,68975,cached_time,2,core\ngx_times.c.cached_time,,core\ngx_times.c,static ngx_time_t[64] cached_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1372,68972,ngx_cached_http_log_iso8601,2,core\ngx_times.c.ngx_cached_http_log_iso8601,,core\ngx_times.c,volatile ngx_str_t ngx_cached_http_log_iso8601,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1373,257394,ngx_http_set_default_types,1,ngx_http_set_default_types,"ngx_int_t ngx_http_set_default_types (ngx_conf_t*,ngx_array_t**,ngx_str_t*)",http\ngx_http.c,"ngx_int_t
ngx_http_set_default_types(ngx_conf_t *cf, ngx_array_t **types,
    ngx_str_t *default_type)
{
    ngx_hash_key_t  *type;

    *types = ngx_array_create(cf->temp_pool, 1, sizeof(ngx_hash_key_t));
    if (*types == NULL) {
        return NGX_ERROR;
    }

    while (default_type->len) {

        type = ngx_array_push(*types);
        if (type == NULL) {
            return NGX_ERROR;
        }

        type->key = *default_type;
        type->key_hash = ngx_hash_key(default_type->data,
                                      default_type->len);
        type->value = (void *) 4;

        default_type++;
    }

    return NGX_OK;
}",2049.0,2076.0,1.0,1.0,28.0,21,7,20,8,1,9,4,5,1,3,,0,9,6,3,3,ngx_int_t
1374,23915,size,3,ngx_list_t.size,,core\ngx_list.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1375,68980,cached_err_log_time,2,core\ngx_times.c.cached_err_log_time,,core\ngx_times.c,static u_char[64][] cached_err_log_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1376,23916,nalloc,3,ngx_list_t.nalloc,,core\ngx_list.h,nalloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1377,302445,next,3,ngx_http_script_if_code_t.next,,http\ngx_http_script.h,next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1378,3447,elts,3,ngx_array_t.elts,,core\ngx_array.h,*elts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
1379,3448,nelts,3,ngx_array_t.nelts,,core\ngx_array.h,nelts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1380,3449,size,3,ngx_array_t.size,,core\ngx_array.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1381,3450,nalloc,3,ngx_array_t.nalloc,,core\ngx_array.h,nalloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1382,3451,pool,3,ngx_array_t.pool,,core\ngx_array.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1383,68987,cached_http_time,2,core\ngx_times.c.cached_http_time,,core\ngx_times.c,static u_char[64][] cached_http_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1384,15734,ngx_random_number,2,core\ngx_file.c.ngx_random_number,,core\ngx_file.c,ngx_atomic_int_t ngx_random_number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1385,36222,ngx_parse_http_time,1,ngx_parse_http_time,"time_t ngx_parse_http_time (u_char*,size_t)",core\ngx_parse_time.c,"time_t
ngx_parse_http_time(u_char *value, size_t len)
{
    u_char      *p, *end;
    ngx_int_t    month;
    ngx_uint_t   day, year, hour, min, sec;
    uint64_t     time;
    enum {
        no = 0,
        rfc822,   /* Tue, 10 Nov 2002 23:50:13   */
        rfc850,   /* Tuesday, 10-Dec-02 23:50:13 */
        isoc      /* Tue Dec 10 23:50:13 2002    */
    } fmt;

    fmt = 0;
    end = value + len;

#if (NGX_SUPPRESS_WARN)
    day = 32;
    year = 2038;
#endif

    for (p = value; p < end; p++) {
        if (*p == ',') {
            break;
        }

        if (*p == ' ') {
            fmt = isoc;
            break;
        }
    }

    for (p++; p < end; p++) {
        if (*p != ' ') {
            break;
        }
    }

    if (end - p < 18) {
        return NGX_ERROR;
    }

    if (fmt != isoc) {
        if (*p < '0' || *p > '9' || *(p + 1) < '0' || *(p + 1) > '9') {
            return NGX_ERROR;
        }

        day = (*p - '0') * 10 + (*(p + 1) - '0');
        p += 2;

  ...",14.0,277.0,1.0,1.0,264.0,328,21,173,16,1,0,46,52,0,0,,0,0,4,2,2,time_t
1386,302455,text_len,3,ngx_http_script_value_code_t.text_len,,http\ngx_http_script.h,text_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1387,11648,ngx_old_cycles,2,core\ngx_cycle.c.ngx_old_cycles,,core\ngx_cycle.c,ngx_array_t ngx_old_cycles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1388,11649,ngx_temp_pool,2,core\ngx_cycle.c.ngx_temp_pool,,core\ngx_cycle.c,ngx_pool_t* ngx_temp_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1389,11650,ngx_cleaner_event,2,core\ngx_cycle.c.ngx_cleaner_event,,core\ngx_cycle.c,ngx_event_t ngx_cleaner_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1390,11651,ngx_shutdown_event,2,core\ngx_cycle.c.ngx_shutdown_event,,core\ngx_cycle.c,ngx_event_t ngx_shutdown_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1391,11652,ngx_test_config,2,core\ngx_cycle.c.ngx_test_config,,core\ngx_cycle.c,ngx_uint_t ngx_test_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1392,68994,cached_http_log_time,2,core\ngx_times.c.cached_http_log_time,,core\ngx_times.c,static u_char[64][] cached_http_log_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1393,11654,ngx_quiet_mode,2,core\ngx_cycle.c.ngx_quiet_mode,,core\ngx_cycle.c,ngx_uint_t ngx_quiet_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1394,11655,dumb,2,core\ngx_cycle.c.dumb,,core\ngx_cycle.c,ngx_connection_t dumb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1395,11656,ngx_init_cycle,1,ngx_init_cycle,ngx_cycle_t ngx_init_cycle (ngx_cycle_t*),core\ngx_cycle.c,"ngx_cycle_t *
ngx_init_cycle(ngx_cycle_t *old_cycle)
{
    void                *rv;
    char               **senv;
    ngx_uint_t           i, n;
    ngx_log_t           *log;
    ngx_time_t          *tp;
    ngx_conf_t           conf;
    ngx_pool_t          *pool;
    ngx_cycle_t         *cycle, **old;
    ngx_shm_zone_t      *shm_zone, *oshm_zone;
    ngx_list_part_t     *part, *opart;
    ngx_open_file_t     *file;
    ngx_listening_t     *ls, *nls;
    ngx_core_conf_t     *ccf, *old_ccf;
    ngx_core_module_t   *module;
    char                 hostname[NGX_MAXHOSTNAMELEN];

    ngx_timezone_update();

    /* force localtime update with a new timezone */

    tp = ngx_timeofday();
    tp->sec = 0;

    ngx_time_update();


    log = old_cycle->log;

    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
    if (pool == NULL) {
        return NULL;
    }
    pool->log = log;

    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
    if (cycle == NULL) {
        ngx_destroy_pool(poo...",38.0,930.0,1.0,1.0,893.0,811,22,699,66,3,95,165,226,31,68,,0,58,2,1,1,ngx_cycle_t
1396,69001,cached_http_log_iso8601,2,core\ngx_times.c.cached_http_log_iso8601,,core\ngx_times.c,static u_char[64][] cached_http_log_iso8601,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1397,400780,ngx_write_file,1,ngx_write_file,"ssize_t ngx_write_file (ngx_file_t*,u_char*,size_t,off_t)",os\win32\ngx_files.c,"ssize_t
ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    u_long      n;
    OVERLAPPED  ovlp, *povlp;

    ovlp.Internal = 0;
    ovlp.InternalHigh = 0;
    ovlp.Offset = (u_long) offset;
    ovlp.OffsetHigh = (u_long) (offset >> 32);
    ovlp.hEvent = NULL;

    povlp = &ovlp;

    if (WriteFile(file->fd, buf, size, &n, povlp) == 0) {
        ngx_log_error(NGX_LOG_ERR, file->log, ngx_errno,
                      ""WriteFile() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    if (n != size) {
        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
                      ""WriteFile() \""%s\"" has written only %ul of %uz"",
                      file->name.data, n, size);
        return NGX_ERROR;
    }

    file->offset += n;

    return n;
}",94.0,124.0,1.0,1.0,31.0,32,10,48,13,3,2,8,12,0,2,,0,0,8,4,4,ssize_t
1398,69008,cached_syslog_time,2,core\ngx_times.c.cached_syslog_time,,core\ngx_times.c,static u_char[64][] cached_syslog_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1399,3478,ngx_array_init,1,ngx_array_init,"ANY ngx_array_init (ngx_array_t*,ngx_pool_t*,ngx_uint_t,size_t)",core\ngx_array.h,"ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    /*
     * set ""array->nelts"" before ""array->elts"", otherwise MSVC thinks
     * that ""array->nelts"" may be used without having been initialized
     */

    array->nelts = 0;
    array->size = size;
    array->nalloc = n;
    array->pool = pool;

    array->elts = ngx_palloc(pool, n * size);
    if (array->elts == NULL) {
        return NGX_ERROR;
    }

    return NGX_OK;
}",32.0,50.0,1.0,1.0,19.0,13,4,15,7,26,7,2,2,1,1,,0,7,8,4,4,ANY
1400,69015,week,2,core\ngx_times.c.week,,core\ngx_times.c,char*[] week,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1401,101784,ngx_http_autoindex_module,2,http\modules\ngx_http_autoindex_module.c.ngx_http_autoindex_module,,http\modules\ngx_http_autoindex_module.c,ngx_module_t ngx_http_autoindex_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1402,69026,months,2,core\ngx_times.c.months,,core\ngx_times.c,char*[] months,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1403,327075,ngx_http_variables_init_vars,1,ngx_http_variables_init_vars,ngx_int_t ngx_http_variables_init_vars (ngx_conf_t*),http\ngx_http_variables.c,"ngx_int_t
ngx_http_variables_init_vars(ngx_conf_t *cf)
{
    size_t                      len;
    ngx_uint_t                  i, n;
    ngx_hash_key_t             *key;
    ngx_hash_init_t             hash;
    ngx_http_variable_t        *v, *av, *pv;
    ngx_http_core_main_conf_t  *cmcf;

    /* set the handlers for the indexed http variables */

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->variables.elts;
    pv = cmcf->prefix_variables.elts;
    key = cmcf->variables_keys->keys.elts;

    for (i = 0; i < cmcf->variables.nelts; i++) {

        for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {

            av = key[n].value;

            if (v[i].name.len == key[n].key.len
                && ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len)
                   == 0)
            {
                v[i].get_handler = av->get_handler;
                v[i].data = av->data;

                av->flags |= NGX_HTTP_VAR_INDEXED;
    ...",2634.0,2740.0,1.0,1.0,107.0,161,13,122,20,0,22,16,24,7,2,,0,21,2,1,1,ngx_int_t
1404,298407,ngx_http_complex_value_size,1,ngx_http_complex_value_size,"size_t ngx_http_complex_value_size (ngx_http_request_t*,ngx_http_complex_value_t*,size_t)",http\ngx_http_script.c,"size_t
ngx_http_complex_value_size(ngx_http_request_t *r,
    ngx_http_complex_value_t *val, size_t default_value)
{
    size_t     size;
    ngx_str_t  value;

    if (val == NULL) {
        return default_value;
    }

    if (val->lengths == NULL) {
        return val->u.size;
    }

    if (ngx_http_complex_value(r, val, &value) != NGX_OK) {
        return default_value;
    }

    size = ngx_parse_size(&value);

    if (size == (size_t) NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""invalid size \""%V\"""", &value);
        return default_value;
    }

    return size;
}",107.0,135.0,1.0,1.0,29.0,14,7,20,9,0,4,5,5,2,3,,0,3,6,3,3,size_t
1405,85416,ngx_ssl_connection_certificate,1,ngx_ssl_connection_certificate,"ngx_int_t ngx_ssl_connection_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_connection_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *cert, ngx_str_t *key, ngx_array_t *passwords)
{
    char            *err;
    X509            *x509;
    EVP_PKEY        *pkey;
    STACK_OF(X509)  *chain;

    x509 = ngx_ssl_load_certificate(pool, &err, cert, &chain);
    if (x509 == NULL) {
        if (err != NULL) {
            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,
                          ""cannot load certificate \""%s\"": %s"",
                          cert->data, err);
        }

        return NGX_ERROR;
    }

    if (SSL_use_certificate(c->ssl->connection, x509) == 0) {
        ngx_ssl_error(NGX_LOG_ERR, c->log, 0,
                      ""SSL_use_certificate(\""%s\"") failed"", cert->data);
        X509_free(x509);
        sk_X509_pop_free(chain, X509_free);
        return NGX_ERROR;
    }

    X509_free(x509);

#ifdef SSL_set0_chain

    /*
     * SSL_set0_chain() is only available in OpenSSL 1.0.2+,
     * but this function is only ...",541.0,609.0,1.0,1.0,69.0,24,6,49,15,0,9,7,9,0,5,,0,5,10,5,5,ngx_int_t
1406,101801,ngx_http_autoindex_handler,1,ngx_http_autoindex_handler,ngx_int_t ngx_http_autoindex_handler (ngx_http_request_t*),http\modules\ngx_http_autoindex_module.c,"static ngx_int_t
ngx_http_autoindex_handler(ngx_http_request_t *r)
{
    u_char                         *last, *filename;
    size_t                          len, allocated, root;
    ngx_err_t                       err;
    ngx_buf_t                      *b;
    ngx_int_t                       rc;
    ngx_str_t                       path, callback;
    ngx_dir_t                       dir;
    ngx_uint_t                      level, format;
    ngx_pool_t                     *pool;
    ngx_chain_t                     out;
    ngx_array_t                     entries;
    ngx_http_autoindex_entry_t     *entry;
    ngx_http_autoindex_loc_conf_t  *alcf;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_DECLINED;
    }

    alcf = ngx_http_get_module_loc_conf(r, ngx_http_autoindex_module);

    if (!alcf->enable) {
        return NGX_DECLINED;
    }

    rc = ngx_http_discard_request...",152.0,429.0,1.0,36.0,278.0,218,20,216,41,0,61,45,62,16,29,,0,51,2,1,1,ngx_int_t
1407,196010,ngx_http_proxy_rewrite_complex_handler,1,ngx_http_proxy_rewrite_complex_handler,"ngx_int_t ngx_http_proxy_rewrite_complex_handler (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_http_proxy_rewrite_t*)",http\modules\ngx_http_proxy_module.c,"static ngx_int_t
ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)
{
    ngx_str_t  pattern, replacement;

    if (ngx_http_complex_value(r, &pr->pattern.complex, &pattern) != NGX_OK) {
        return NGX_ERROR;
    }

    if (pattern.len > len
        || ngx_rstrncmp(h->value.data + prefix, pattern.data,
                        pattern.len) != 0)
    {
        return NGX_DECLINED;
    }

    if (ngx_http_complex_value(r, &pr->replacement, &replacement) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_proxy_rewrite(r, h, prefix, pattern.len, &replacement);
}",2620.0,2642.0,1.0,1.0,23.0,20,7,22,10,0,9,4,4,7,4,,0,8,10,5,5,ngx_int_t
1408,69042,ngx_time_init,1,ngx_time_init,void ngx_time_init (void),core\ngx_times.c,"void
ngx_time_init(void)
{
    ngx_cached_err_log_time.len = sizeof(""1970/09/28 12:00:00"") - 1;
    ngx_cached_http_time.len = sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1;
    ngx_cached_http_log_time.len = sizeof(""28/Sep/1970:12:00:00 +0600"") - 1;
    ngx_cached_http_log_iso8601.len = sizeof(""1970-09-28T12:00:00+06:00"") - 1;
    ngx_cached_syslog_time.len = sizeof(""Sep 28 12:00:00"") - 1;

    ngx_cached_time = &cached_time[0];

    ngx_time_update();
}",65.0,77.0,1.0,1.0,13.0,23,6,7,7,1,13,1,1,0,1,,0,12,2,1,1,void
1409,200114,enable,3,ngx_http_random_index_loc_conf_t.enable,,http\modules\ngx_http_random_index_module.c,enable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1410,200116,ngx_http_random_index_error,1,ngx_http_random_index_error,"ngx_int_t ngx_http_random_index_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)",http\modules\ngx_http_random_index_module.c,"static ngx_int_t
ngx_http_random_index_error(ngx_http_request_t *r, ngx_dir_t *dir,
    ngx_str_t *name)
{
    if (ngx_close_dir(dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,
                      ngx_close_dir_n "" \""%V\"" failed"", name);
    }

    return NGX_HTTP_INTERNAL_SERVER_ERROR;
}",260.0,270.0,1.0,1.0,11.0,0,0,0,0,7,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1411,454069,ngx_stream_upstream_module,2,stream\ngx_stream_upstream.c.ngx_stream_upstream_module,,stream\ngx_stream_upstream.c,ngx_module_t ngx_stream_upstream_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1412,433589,len,3,ngx_stream_limit_conn_node_t.len,,stream\ngx_stream_limit_conn_module.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1413,433590,conn,3,ngx_stream_limit_conn_node_t.conn,,stream\ngx_stream_limit_conn_module.c,conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1414,433591,data,3,ngx_stream_limit_conn_node_t.data,,stream\ngx_stream_limit_conn_module.c,data[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1415,7611,ngx_conf_set_msec_slot,1,ngx_conf_set_msec_slot,"char* ngx_conf_set_msec_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_msec_t       *msp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    msp = (ngx_msec_t *) (p + cmd->offset);
    if (*msp != NGX_CONF_UNSET_MSEC) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *msp = ngx_parse_time(&value[1], 0);
    if (*msp == (ngx_msec_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, msp);
    }

    return NGX_CONF_OK;
}",1259.0,1287.0,1.0,1.0,29.0,21,9,21,10,0,2,4,4,0,1,,0,2,6,3,3,char*
1416,462269,config,3,ngx_stream_upstream_rr_peer_data_t.config,,stream\ngx_stream_upstream_round_robin.h,config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1417,462270,peers,3,ngx_stream_upstream_rr_peer_data_t.peers,,stream\ngx_stream_upstream_round_robin.h,*peers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1418,462271,current,3,ngx_stream_upstream_rr_peer_data_t.current,,stream\ngx_stream_upstream_round_robin.h,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1419,462272,tried,3,ngx_stream_upstream_rr_peer_data_t.tried,,stream\ngx_stream_upstream_round_robin.h,*tried,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1420,462273,data,3,ngx_stream_upstream_rr_peer_data_t.data,,stream\ngx_stream_upstream_round_robin.h,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1421,146877,ngx_http_gzip_body_filter,1,ngx_http_gzip_body_filter,"ngx_int_t ngx_http_gzip_body_filter (ngx_http_request_t*,ngx_chain_t*)",http\modules\ngx_http_gzip_filter_module.c,"static ngx_int_t
ngx_http_gzip_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                   rc;
    ngx_uint_t            flush;
    ngx_chain_t          *cl;
    ngx_http_gzip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_gzip_filter_module);

    if (ctx == NULL || ctx->done || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http gzip filter"");

    if (ctx->buffering) {

        /*
         * With default memory settings zlib starts to output gzipped data
         * only after it has got about 90K, so it makes sense to allocate
         * zlib memory (200-400K) only after we have enough data to compress.
         * Although we copy buffers, nevertheless for not big responses
         * this allows to allocate zlib memory, to compress and to output
         * the response in one step using hot CPU cache.
         */

        if (in) {
       ...",297.0,463.0,1.0,1.0,167.0,73,10,102,16,0,37,35,45,11,12,,0,31,4,2,2,ngx_int_t
1422,433598,ngx_stream_limit_conn_node_t,2,stream\ngx_stream_limit_conn_module.c.ngx_stream_limit_conn_node_t,,stream\ngx_stream_limit_conn_module.c,struct ngx_stream_limit_conn_node_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1423,433600,shm_zone,3,ngx_stream_limit_conn_cleanup_t.shm_zone,,stream\ngx_stream_limit_conn_module.c,*shm_zone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1424,433601,node,3,ngx_stream_limit_conn_cleanup_t.node,,stream\ngx_stream_limit_conn_module.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1425,60945,pfree,3,ngx_slab_pool_t.pfree,,core\ngx_slab.h,pfree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1426,433602,ngx_stream_limit_conn_cleanup_t,2,stream\ngx_stream_limit_conn_module.c.ngx_stream_limit_conn_cleanup_t,,stream\ngx_stream_limit_conn_module.c,struct ngx_stream_limit_conn_cleanup_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1427,433606,ngx_stream_limit_conn_shctx_t,2,stream\ngx_stream_limit_conn_module.c.ngx_stream_limit_conn_shctx_t,,stream\ngx_stream_limit_conn_module.c,struct ngx_stream_limit_conn_shctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1428,433608,sh,3,ngx_stream_limit_conn_ctx_t.sh,,stream\ngx_stream_limit_conn_module.c,*sh,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1429,433609,shpool,3,ngx_stream_limit_conn_ctx_t.shpool,,stream\ngx_stream_limit_conn_module.c,*shpool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1430,130505,proxies,3,ngx_http_geoip_conf_t.proxies,,http\modules\ngx_http_geoip_module.c,*proxies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1431,433610,key,3,ngx_stream_limit_conn_ctx_t.key,,stream\ngx_stream_limit_conn_module.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1432,130506,proxy_recursive,3,ngx_http_geoip_conf_t.proxy_recursive,,http\modules\ngx_http_geoip_module.c,proxy_recursive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1433,3535,ngx_create_temp_buf,1,ngx_create_temp_buf,"ngx_buf_t ngx_create_temp_buf (ngx_pool_t*,size_t)",core\ngx_buf.c,"ngx_buf_t *
ngx_create_temp_buf(ngx_pool_t *pool, size_t size)
{
    ngx_buf_t *b;

    b = ngx_calloc_buf(pool);
    if (b == NULL) {
        return NULL;
    }

    b->start = ngx_palloc(pool, size);
    if (b->start == NULL) {
        return NULL;
    }

    /*
     * set by ngx_calloc_buf():
     *
     *     b->file_pos = 0;
     *     b->file_last = 0;
     *     b->file = NULL;
     *     b->shadow = NULL;
     *     b->tag = 0;
     *     and flags
     */

    b->pos = b->start;
    b->last = b->start;
    b->end = b->last + size;
    b->temporary = 1;

    return b;
}",12.0,44.0,1.0,1.0,33.0,18,4,20,4,6,1,3,3,0,1,,0,1,4,2,2,ngx_buf_t
1434,433617,limits,3,ngx_stream_limit_conn_conf_t.limits,,stream\ngx_stream_limit_conn_module.c,limits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1435,24018,ngx_log_set_levels,1,ngx_log_set_levels,"char* ngx_log_set_levels (ngx_conf_t*,ngx_log_t*)",core\ngx_log.c,"static char *
ngx_log_set_levels(ngx_conf_t *cf, ngx_log_t *log)
{
    ngx_uint_t   i, n, d, found;
    ngx_str_t   *value;

    if (cf->args->nelts == 2) {
        log->log_level = NGX_LOG_ERR;
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    for (i = 2; i < cf->args->nelts; i++) {
        found = 0;

        for (n = 1; n <= NGX_LOG_DEBUG; n++) {
            if (ngx_strcmp(value[i].data, err_levels[n].data) == 0) {

                if (log->log_level != 0) {
                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                       ""duplicate log level \""%V\"""",
                                       &value[i]);
                    return NGX_CONF_ERROR;
                }

                log->log_level = n;
                found = 1;
                break;
            }
        }

        for (n = 0, d = NGX_LOG_DEBUG_FIRST; d <= NGX_LOG_DEBUG_LAST; d <<= 1) {
            if (ngx_strcmp(value[i].data, debug_levels[n++]) == 0) {
         ...",481.0,541.0,1.0,1.0,61.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
1436,163283,ngx_http_log_handler,1,ngx_http_log_handler,ngx_int_t ngx_http_log_handler (ngx_http_request_t*),http\modules\ngx_http_log_module.c,"static ngx_int_t
ngx_http_log_handler(ngx_http_request_t *r)
{
    u_char                   *line, *p;
    size_t                    len, size;
    ssize_t                   n;
    ngx_str_t                 val;
    ngx_uint_t                i, l;
    ngx_http_log_t           *log;
    ngx_http_log_op_t        *op;
    ngx_http_log_buf_t       *buffer;
    ngx_http_log_loc_conf_t  *lcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http log handler"");

    lcf = ngx_http_get_module_loc_conf(r, ngx_http_log_module);

    if (lcf->off) {
        return NGX_OK;
    }

    log = lcf->logs->elts;
    for (l = 0; l < lcf->logs->nelts; l++) {

        if (log[l].filter) {
            if (ngx_http_complex_value(r, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }

            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
            }
        }

        if (ngx_time() == log[l].disk_...",253.0,402.0,1.0,1.0,150.0,151,17,143,21,0,33,26,50,14,8,,0,29,2,1,1,ngx_int_t
1437,433619,dry_run,3,ngx_stream_limit_conn_conf_t.dry_run,,stream\ngx_stream_limit_conn_module.c,dry_run,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1438,433621,ngx_stream_limit_conn_lookup,1,ngx_stream_limit_conn_lookup,"ngx_rbtree_node_t* ngx_stream_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)",stream\ngx_stream_limit_conn_module.c,"static ngx_rbtree_node_t *
ngx_stream_limit_conn_lookup(ngx_rbtree_t *rbtree, ngx_str_t *key,
    uint32_t hash)
{
    ngx_int_t                      rc;
    ngx_rbtree_node_t             *node, *sentinel;
    ngx_stream_limit_conn_node_t  *lcn;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lcn = (ngx_stream_limit_conn_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t) lcn->len);

        if (rc == 0) {
            return node;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",332.0,369.0,1.0,1.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_rbtree_node_t
1439,15831,ngx_write_chain_to_temp_file,1,ngx_write_chain_to_temp_file,"ssize_t ngx_write_chain_to_temp_file (ngx_temp_file_t*,ngx_chain_t*)",core\ngx_file.c,"ssize_t
ngx_write_chain_to_temp_file(ngx_temp_file_t *tf, ngx_chain_t *chain)
{
    ngx_int_t  rc;

    if (tf->file.fd == NGX_INVALID_FILE) {
        rc = ngx_create_temp_file(&tf->file, tf->path, tf->pool,
                                  tf->persistent, tf->clean, tf->access);

        if (rc != NGX_OK) {
            return rc;
        }

        if (tf->log_level) {
            ngx_log_error(tf->log_level, tf->file.log, 0, ""%s %V"",
                          tf->warn, &tf->file.name);
        }
    }

#if (NGX_THREADS && NGX_HAVE_PWRITEV)

    if (tf->thread_write) {
        return ngx_thread_write_chain_to_file(&tf->file, chain, tf->offset,
                                              tf->pool);
    }

#endif

    return ngx_write_chain_to_file(&tf->file, chain, tf->offset, tf->pool);
}",108.0,137.0,1.0,1.0,30.0,24,6,21,5,0,18,4,6,2,3,,0,16,4,2,2,ssize_t
1440,24024,ngx_log_insert,1,ngx_log_insert,"void ngx_log_insert (ngx_log_t*,ngx_log_t*)",core\ngx_log.c,"static void
ngx_log_insert(ngx_log_t *log, ngx_log_t *new_log)
{
    ngx_log_t  tmp;

    if (new_log->log_level > log->log_level) {

        /*
         * list head address is permanent, insert new log after
         * head and swap its contents with head
         */

        tmp = *log;
        *log = *new_log;
        *new_log = tmp;

        log->next = new_log;
        return;
    }

    while (log->next) {
        if (new_log->log_level > log->next->log_level) {
            new_log->next = log->next;
            log->next = new_log;
            return;
        }

        log = log->next;
    }

    log->next = new_log;
}",679.0,710.0,1.0,1.0,32.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1441,126427,ngx_http_geo_cidr_variable,1,ngx_http_geo_cidr_variable,"ngx_int_t ngx_http_geo_cidr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_geo_module.c,"static ngx_int_t
ngx_http_geo_cidr_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;

    in_addr_t                   inaddr;
    ngx_addr_t                  addr;
    struct sockaddr_in         *sin;
    ngx_http_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                     *p;
    struct in6_addr            *inaddr6;
#endif

    if (ngx_http_geo_addr(r, ctx, &addr) != NGX_OK) {
        vv = (ngx_http_variable_value_t *)
                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);
        goto done;
    }

    switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;
        p = inaddr6->s6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

      ...",173.0,243.0,1.0,1.0,71.0,27,7,23,11,0,3,5,3,1,3,,0,3,6,3,3,ngx_int_t
1442,216544,value,3,ngx_http_split_clients_ctx_t.value,,http\modules\ngx_http_split_clients_module.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1443,216545,parts,3,ngx_http_split_clients_ctx_t.parts,,http\modules\ngx_http_split_clients_module.c,parts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1444,69094,ngx_time_update,1,ngx_time_update,void ngx_time_update (void),core\ngx_times.c,"void
ngx_time_update(void)
{
    u_char          *p0, *p1, *p2, *p3, *p4;
    ngx_tm_t         tm, gmt;
    time_t           sec;
    ngx_uint_t       msec;
    ngx_time_t      *tp;
    struct timeval   tv;

    if (!ngx_trylock(&ngx_time_lock)) {
        return;
    }

    ngx_gettimeofday(&tv);

    sec = tv.tv_sec;
    msec = tv.tv_usec / 1000;

    ngx_current_msec = ngx_monotonic_time(sec, msec);

    tp = &cached_time[slot];

    if (tp->sec == sec) {
        tp->msec = msec;
        ngx_unlock(&ngx_time_lock);
        return;
    }

    if (slot == NGX_TIME_SLOTS - 1) {
        slot = 0;
    } else {
        slot++;
    }

    tp = &cached_time[slot];

    tp->sec = sec;
    tp->msec = msec;

    ngx_gmtime(sec, &gmt);


    p0 = &cached_http_time[slot][0];

    (void) ngx_sprintf(p0, ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,
                       months[gmt.ngx_tm_mon - 1], gmt.ngx_tm_year,
                       gm...",80.0,192.0,1.0,16.0,113.0,121,13,107,29,4,57,4,4,3,9,,0,49,2,1,1,void
1445,200169,ngx_http_random_index_module,2,http\modules\ngx_http_random_index_module.c.ngx_http_random_index_module,,http\modules\ngx_http_random_index_module.c,ngx_module_t ngx_http_random_index_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1446,298474,ngx_http_compile_complex_value,1,ngx_http_compile_complex_value,ngx_int_t ngx_http_compile_complex_value (ngx_http_compile_complex_value_t*),http\ngx_http_script.c,"ngx_int_t
ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv)
{
    ngx_str_t                  *v;
    ngx_uint_t                  i, n, nv, nc;
    ngx_array_t                 flushes, lengths, values, *pf, *pl, *pv;
    ngx_http_script_compile_t   sc;

    v = ccv->value;

    nv = 0;
    nc = 0;

    for (i = 0; i < v->len; i++) {
        if (v->data[i] == '$') {
            if (v->data[i + 1] >= '1' && v->data[i + 1] <= '9') {
                nc++;

            } else {
                nv++;
            }
        }
    }

    if ((v->len == 0 || v->data[0] != '$')
        && (ccv->conf_prefix || ccv->root_prefix))
    {
        if (ngx_conf_full_name(ccv->cf->cycle, v, ccv->conf_prefix) != NGX_OK) {
            return NGX_ERROR;
        }

        ccv->conf_prefix = 0;
        ccv->root_prefix = 0;
    }

    ccv->complex_value->value = *v;
    ccv->complex_value->flushes = NULL;
    ccv->complex_value->lengths = NULL;
    ccv->complex_value->values = NULL;

  ...",138.0,239.0,1.0,1.0,102.0,150,20,107,21,3,49,12,16,19,5,,0,49,2,1,1,ngx_int_t
1447,19950,ngx_hash_wildcard_init,1,ngx_hash_wildcard_init,"ngx_int_t ngx_hash_wildcard_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)",core\ngx_hash.c,"ngx_int_t
ngx_hash_wildcard_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,
    ngx_uint_t nelts)
{
    size_t                len, dot_len;
    ngx_uint_t            i, n, dot;
    ngx_array_t           curr_names, next_names;
    ngx_hash_key_t       *name, *next_name;
    ngx_hash_init_t       h;
    ngx_hash_wildcard_t  *wdc;

    if (ngx_array_init(&curr_names, hinit->temp_pool, nelts,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&next_names, hinit->temp_pool, nelts,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (n = 0; n < nelts; n = i) {

#if 0
        ngx_log_error(NGX_LOG_ALERT, hinit->pool->log, 0,
                      ""wc0: \""%V\"""", &names[n].key);
#endif

        dot = 0;

        for (len = 0; len < names[n].key.len; len++) {
            if (names[n].key.data[len] == '.') {
                dot = 1;
                brea...",485.0,627.0,1.0,1.0,143.0,153,19,126,18,0,33,21,38,10,6,,0,33,6,3,3,ngx_int_t
1448,40436,ngx_regex_exec_array,1,ngx_regex_exec_array,"ngx_int_t ngx_regex_exec_array (ngx_array_t*,ngx_str_t*,ngx_log_t*)",core\ngx_regex.c,"ngx_int_t
ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)
{
    ngx_int_t         n;
    ngx_uint_t        i;
    ngx_regex_elt_t  *re;

    re = a->elts;

    for (i = 0; i < a->nelts; i++) {

        n = ngx_regex_exec(re[i].regex, s, NULL, 0);

        if (n == NGX_REGEX_NO_MATCHED) {
            continue;
        }

        if (n < 0) {
            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ngx_regex_exec_n "" failed: %i on \""%V\"" using \""%s\"""",
                          n, s, re[i].name);
            return NGX_ERROR;
        }

        /* match */

        return NGX_OK;
    }

    return NGX_DECLINED;
}",197.0,227.0,1.0,1.0,31.0,10,6,16,10,0,2,5,6,1,0,,0,2,6,3,3,ngx_int_t
1449,196087,ngx_http_proxy_rewrite_domain_handler,1,ngx_http_proxy_rewrite_domain_handler,"ngx_int_t ngx_http_proxy_rewrite_domain_handler (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_http_proxy_rewrite_t*)",http\modules\ngx_http_proxy_module.c,"static ngx_int_t
ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)
{
    u_char     *p;
    ngx_str_t   pattern, replacement;

    if (ngx_http_complex_value(r, &pr->pattern.complex, &pattern) != NGX_OK) {
        return NGX_ERROR;
    }

    p = h->value.data + prefix;

    if (p[0] == '.') {
        p++;
        prefix++;
        len--;
    }

    if (pattern.len != len || ngx_rstrncasecmp(pattern.data, p, len) != 0) {
        return NGX_DECLINED;
    }

    if (ngx_http_complex_value(r, &pr->replacement, &replacement) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);
}",2675.0,2703.0,1.0,1.0,29.0,24,11,28,11,0,7,5,5,5,4,,0,6,10,5,5,ngx_int_t
1450,347640,ngx_http_v2_flow_control,1,ngx_http_v2_flow_control,"ANY ngx_http_v2_flow_control (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*)",http\v2\ngx_http_v2_filter_module.c,"ngx_http_v2_flow_control(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream)
{
    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2:%ui windows: conn:%uz stream:%z"",
                   stream->node->id, h2c->send_window, stream->send_window);

    if (stream->send_window <= 0) {
        stream->exhausted = 1;
        return NGX_DECLINED;
    }

    if (h2c->send_window == 0) {
        ngx_http_v2_waiting_queue(h2c, stream);
        return NGX_DECLINED;
    }

    return NGX_OK;
}",1757.0,1775.0,1.0,1.0,19.0,12,4,13,5,0,1,3,3,0,1,,0,0,4,2,2,ANY
1451,200186,ngx_http_random_index_handler,1,ngx_http_random_index_handler,ngx_int_t ngx_http_random_index_handler (ngx_http_request_t*),http\modules\ngx_http_random_index_module.c,"static ngx_int_t
ngx_http_random_index_handler(ngx_http_request_t *r)
{
    u_char                            *last, *filename;
    size_t                             len, allocated, root;
    ngx_err_t                          err;
    ngx_int_t                          rc;
    ngx_str_t                          path, uri, *name;
    ngx_dir_t                          dir;
    ngx_uint_t                         n, level;
    ngx_array_t                        names;
    ngx_http_random_index_loc_conf_t  *rlcf;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {
        return NGX_DECLINED;
    }

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_random_index_module);

    if (!rlcf->enable) {
        return NGX_DECLINED;
    }

#if (NGX_HAVE_D_TYPE)
    len = 0;
#else
    len = NGX_HTTP_RANDOM_INDEX_PREALLOCATE;
#endif

    last = ngx_http_map_uri_to_path(r, &path, &root, len);
   ...",73.0,257.0,1.0,10.0,185.0,164,20,167,35,0,47,27,46,11,21,,0,38,2,1,1,ngx_int_t
1452,383344,ngx_mail_imap_auth_state,1,ngx_mail_imap_auth_state,void ngx_mail_imap_auth_state (ngx_event_t*),mail\ngx_mail_imap_handler.c,"void
ngx_mail_imap_auth_state(ngx_event_t *rev)
{
    u_char              *p, *dst, *src, *end;
    ngx_str_t           *arg;
    ngx_int_t            rc;
    ngx_uint_t           tag, i;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    tag = 1;
    s->text.len = 0;
    ngx_str_set(&s->out, imap_ok);

    if (rc == NGX_OK) {

        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap auth command: %i"",
...",101.0,297.0,1.0,1.0,197.0,185,13,177,38,1,73,33,38,13,17,,0,67,2,1,1,void
1453,413182,ngx_win32_check_filename,1,ngx_win32_check_filename,"ngx_int_t ngx_win32_check_filename (u_char*,u_short*,size_t)",os\win32\ngx_files.c,"static ngx_int_t
ngx_win32_check_filename(u_char *name, u_short *u, size_t len)
{
    u_char     *p, ch;
    u_long      n;
    u_short    *lu;
    ngx_err_t   err;
    enum {
        sw_start = 0,
        sw_normal,
        sw_after_slash,
        sw_after_colon,
        sw_after_dot
    } state;

    /* check for NTFS streams ("":""), trailing dots and spaces */

    lu = NULL;
    state = sw_start;

    for (p = name; *p; p++) {
        ch = *p;

        switch (state) {

        case sw_start:

            /*
             * skip till first ""/"" to allow paths starting with drive and
             * relative path, like ""c:html/""
             */

            if (ch == '/' || ch == '\\') {
                state = sw_after_slash;
            }

            break;

        case sw_normal:

            if (ch == ':') {
                state = sw_after_colon;
                break;
            }

            if (ch == '.' || ch == ' ') {
                state = sw_after_dot;
              ...",661.0,802.0,1.0,1.0,142.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1454,323075,ngx_http_variable_unknown_header,1,ngx_http_variable_unknown_header,"ngx_int_t ngx_http_variable_unknown_header (ngx_http_variable_value_t*,ngx_str_t*,ngx_list_part_t*,size_t)",http\ngx_http_variables.c,"ngx_int_t
ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,
    ngx_list_part_t *part, size_t prefix)
{
    u_char            ch;
    ngx_uint_t        i, n;
    ngx_table_elt_t  *header;

    header = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            header = part->elts;
            i = 0;
        }

        if (header[i].hash == 0) {
            continue;
        }

        for (n = 0; n + prefix < var->len && n < header[i].key.len; n++) {
            ch = header[i].key.data[n];

            if (ch >= 'A' && ch <= 'Z') {
                ch |= 0x20;

            } else if (ch == '-') {
                ch = '_';
            }

            if (var->data[n + prefix] != ch) {
                break;
            }
        }

        if (n + prefix == var->len && n == header[i].key.len) {
            v->len = he...",943.0,998.0,1.0,1.0,56.0,63,12,51,10,0,3,12,19,3,0,,0,3,8,4,4,ngx_int_t
1455,105987,ngx_http_modern_browser_sort,1,ngx_http_modern_browser_sort,"ANY ngx_http_modern_browser_sort (void*,void*)",http\modules\ngx_http_browser_module.c,"ngx_http_modern_browser_sort(const void *one, const void *two)
{
    ngx_http_modern_browser_t *first = (ngx_http_modern_browser_t *) one;
    ngx_http_modern_browser_t *second = (ngx_http_modern_browser_t *) two;

    return (first->skip - second->skip);
}",528.0,534.0,1.0,1.0,7.0,7,4,6,4,0,2,1,1,0,0,,0,2,4,2,2,ANY
1456,413189,ngx_utf8_to_utf16,1,ngx_utf8_to_utf16,"u_short* ngx_utf8_to_utf16 (u_short*,u_char*,size_t*)",os\win32\ngx_files.c,"static u_short *
ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)
{
    u_char    *p;
    u_short   *u, *last;
    uint32_t   n;

    p = utf8;
    u = utf16;
    last = utf16 + *len;

    while (u < last) {

        if (*p < 0x80) {
            *u++ = (u_short) *p;

            if (*p == 0) {
                *len = u - utf16;
                return utf16;
            }

            p++;

            continue;
        }

        if (u + 1 == last) {
            *len = u - utf16;
            break;
        }

        n = ngx_utf8_decode(&p, 4);

        if (n > 0x10ffff) {
            ngx_set_errno(NGX_EILSEQ);
            return NULL;
        }

        if (n > 0xffff) {
            n -= 0x10000;
            *u++ = (u_short) (0xd800 + (n >> 10));
            *u++ = (u_short) (0xdc00 + (n & 0x03ff));
            continue;
        }

        *u++ = (u_short) n;
    }

    /* the given buffer is not enough, allocate a new one */

    u = malloc(((p - utf8) + ngx_strlen(p) +...",805.0,899.0,1.0,1.0,95.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,u_short
1457,24070,ngx_log,2,core\ngx_log.c.ngx_log,,core\ngx_log.c,ngx_log_t ngx_log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1458,24071,ngx_log_file,2,core\ngx_log.c.ngx_log_file,,core\ngx_log.c,ngx_open_file_t ngx_log_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1459,24072,ngx_use_stderr,2,core\ngx_log.c.ngx_use_stderr,,core\ngx_log.c,ngx_uint_t ngx_use_stderr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1460,7688,ngx_conf_set_sec_slot,1,ngx_conf_set_sec_slot,"char* ngx_conf_set_sec_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    time_t           *sp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    sp = (time_t *) (p + cmd->offset);
    if (*sp != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *sp = ngx_parse_time(&value[1], 1);
    if (*sp == (time_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, sp);
    }

    return NGX_CONF_OK;
}",1290.0,1318.0,1.0,1.0,29.0,21,9,21,10,0,2,4,4,0,1,,0,2,6,3,3,char*
1461,60939,min_size,3,ngx_slab_pool_t.min_size,,core\ngx_slab.h,min_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1462,413196,ngx_open_file,1,ngx_open_file,"ngx_fd_t ngx_open_file (u_char*,u_long,u_long,u_long)",os\win32\ngx_files.c,"ngx_fd_t
ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)
{
    size_t      len;
    u_short    *u;
    ngx_fd_t    fd;
    ngx_err_t   err;
    u_short     utf16[NGX_UTF16_BUFLEN];

    len = NGX_UTF16_BUFLEN;
    u = ngx_utf8_to_utf16(utf16, name, &len);

    if (u == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    fd = INVALID_HANDLE_VALUE;

    if (create == NGX_FILE_OPEN
        && ngx_win32_check_filename(name, u, len) != NGX_OK)
    {
        goto failed;
    }

    fd = CreateFileW(u, mode,
                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                     NULL, create, FILE_FLAG_BACKUP_SEMANTICS, NULL);

failed:

    if (u != utf16) {
        err = ngx_errno;
        ngx_free(u);
        ngx_set_errno(err);
    }

    return fd;
}",21.0,58.0,1.0,22.0,38.0,13,6,33,17,11,2,5,4,1,2,,0,2,8,4,4,ngx_fd_t
1463,60941,pages,3,ngx_slab_pool_t.pages,,core\ngx_slab.h,*pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1464,60942,last,3,ngx_slab_pool_t.last,,core\ngx_slab.h,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1465,60940,min_shift,3,ngx_slab_pool_t.min_shift,,core\ngx_slab.h,min_shift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1466,60943,free,3,ngx_slab_pool_t.free,,core\ngx_slab.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1467,3599,ngx_alloc_chain_link,1,ngx_alloc_chain_link,ngx_chain_t ngx_alloc_chain_link (ngx_pool_t*),core\ngx_buf.c,"ngx_chain_t *
ngx_alloc_chain_link(ngx_pool_t *pool)
{
    ngx_chain_t  *cl;

    cl = pool->chain;

    if (cl) {
        pool->chain = cl->next;
        return cl;
    }

    cl = ngx_palloc(pool, sizeof(ngx_chain_t));
    if (cl == NULL) {
        return NULL;
    }

    return cl;
}",47.0,65.0,1.0,1.0,19.0,8,4,13,4,7,1,3,3,0,1,,0,1,2,1,1,ngx_chain_t
1468,60944,stats,3,ngx_slab_pool_t.stats,,core\ngx_slab.h,*stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1469,60946,start,3,ngx_slab_pool_t.start,,core\ngx_slab.h,*start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1470,60947,end,3,ngx_slab_pool_t.end,,core\ngx_slab.h,*end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1471,60948,mutex,3,ngx_slab_pool_t.mutex,,core\ngx_slab.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1472,60949,log_ctx,3,ngx_slab_pool_t.log_ctx,,core\ngx_slab.h,*log_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1473,60950,zero,3,ngx_slab_pool_t.zero,,core\ngx_slab.h,zero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1474,60951,log_nomem,3,ngx_slab_pool_t.log_nomem,,core\ngx_slab.h,log_nomem:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1475,60952,data,3,ngx_slab_pool_t.data,,core\ngx_slab.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1476,257559,ngx_http_close_connection,1,ngx_http_close_connection,void ngx_http_close_connection (ngx_connection_t*),http\ngx_http_request.c,"void
ngx_http_close_connection(ngx_connection_t *c)
{
    ngx_pool_t  *pool;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""close http connection: %d"", c->fd);

#if (NGX_HTTP_SSL)

    if (c->ssl) {
        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_http_close_connection;
            return;
        }
    }

#endif

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif

    c->destroyed = 1;

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}",3684.0,3714.0,1.0,1.0,31.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void
1477,167451,map,3,ngx_http_map_ctx_t.map,,http\modules\ngx_http_map_module.c,map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1478,167452,value,3,ngx_http_map_ctx_t.value,,http\modules\ngx_http_map_module.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1479,167453,default_value,3,ngx_http_map_ctx_t.default_value,,http\modules\ngx_http_map_module.c,*default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1480,167454,hostnames,3,ngx_http_map_ctx_t.hostnames,,http\modules\ngx_http_map_module.c,hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1481,216607,ngx_http_split_clients_variable,1,ngx_http_split_clients_variable,"ngx_int_t ngx_http_split_clients_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_split_clients_module.c,"static ngx_int_t
ngx_http_split_clients_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_split_clients_ctx_t *ctx = (ngx_http_split_clients_ctx_t *) data;

    uint32_t                        hash;
    ngx_str_t                       val;
    ngx_uint_t                      i;
    ngx_http_split_clients_part_t  *part;

    *v = ngx_http_variable_null_value;

    if (ngx_http_complex_value(r, &ctx->value, &val) != NGX_OK) {
        return NGX_OK;
    }

    hash = ngx_murmur_hash2(val.data, val.len);

    part = ctx->parts.elts;

    for (i = 0; i < ctx->parts.nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http split: %uD %uD"", hash, part[i].percent);

        if (hash < part[i].percent || part[i].percent == 0) {
            *v = part[i].value;
            return NGX_OK;
        }
    }

    return NGX_OK;
}",74.0,107.0,1.0,1.0,34.0,33,11,32,11,0,7,4,5,3,2,,0,7,6,3,3,ngx_int_t
1482,261674,ngx_http_test_content_type,1,ngx_http_test_content_type,"void* ngx_http_test_content_type (ngx_http_request_t*,ngx_hash_t*)",http\ngx_http_core_module.c,"void *
ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash)
{
    u_char      c, *lowcase;
    size_t      len;
    ngx_uint_t  i, hash;

    if (types_hash->size == 0) {
        return (void *) 4;
    }

    if (r->headers_out.content_type.len == 0) {
        return NULL;
    }

    len = r->headers_out.content_type_len;

    if (r->headers_out.content_type_lowcase == NULL) {

        lowcase = ngx_pnalloc(r->pool, len);
        if (lowcase == NULL) {
            return NULL;
        }

        r->headers_out.content_type_lowcase = lowcase;

        hash = 0;

        for (i = 0; i < len; i++) {
            c = ngx_tolower(r->headers_out.content_type.data[i]);
            hash = ngx_hash(hash, c);
            lowcase[i] = c;
        }

        r->headers_out.content_type_hash = hash;
    }

    return ngx_hash_find(types_hash, r->headers_out.content_type_hash,
                         r->headers_out.content_type_lowcase, len);
}",1533.0,1572.0,1.0,1.0,40.0,37,7,34,8,5,3,6,8,1,2,,0,2,4,2,2,void*
1483,15914,ngx_create_temp_file,1,ngx_create_temp_file,"ngx_int_t ngx_create_temp_file (ngx_file_t*,ngx_path_t*,ngx_pool_t*,ngx_uint_t,ngx_uint_t,ngx_uint_t)",core\ngx_file.c,"ngx_int_t
ngx_create_temp_file(ngx_file_t *file, ngx_path_t *path, ngx_pool_t *pool,
    ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access)
{
    size_t                    levels;
    u_char                   *p;
    uint32_t                  n;
    ngx_err_t                 err;
    ngx_str_t                 name;
    ngx_uint_t                prefix;
    ngx_pool_cleanup_t       *cln;
    ngx_pool_cleanup_file_t  *clnf;

    if (file->name.len) {
        name = file->name;
        levels = 0;
        prefix = 1;

    } else {
        name = path->name;
        levels = path->len;
        prefix = 0;
    }

    file->name.len = name.len + 1 + levels + 10;

    file->name.data = ngx_pnalloc(pool, file->name.len + 1);
    if (file->name.data == NULL) {
        return NGX_ERROR;
    }

#if 0
    for (i = 0; i < file->name.len; i++) {
        file->name.data[i] = 'X';
    }
#endif

    p = ngx_cpymem(file->name.data, name.data, name.len);

    if (prefix) {
        *p = '.';
 ...",140.0,237.0,1.0,1.0,98.0,78,14,73,25,1,15,12,16,2,8,,0,13,12,6,6,ngx_int_t
1484,24108,ngx_log_error_core,1,ngx_log_error_core,"void ngx_log_error_core (ngx_uint_t,ngx_log_t*,ngx_err_t,char*,va_list)",core\ngx_log.c,"void
ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, va_list args)

#endif
{
#if (NGX_HAVE_VARIADIC_MACROS)
    va_list      args;
#endif
    u_char      *p, *last, *msg;
    ssize_t      n;
    ngx_uint_t   wrote_stderr, debug_connection;
    u_char       errstr[NGX_MAX_ERROR_STR];

    last = errstr + NGX_MAX_ERROR_STR;

    p = ngx_cpymem(errstr, ngx_cached_err_log_time.data,
                   ngx_cached_err_log_time.len);

    p = ngx_slprintf(p, last, "" [%V] "", &err_levels[level]);

    /* pid#tid */
    p = ngx_slprintf(p, last, ""%P#"" NGX_TID_T_FMT "": "",
                    ngx_log_pid, ngx_log_tid);

    if (log->connection) {
        p = ngx_slprintf(p, last, ""*%uA "", log->connection);
    }

    msg = p;

#if (NGX_HAVE_VARIADIC_MACROS)

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

#else

    p = ngx_vslprintf(p, last, fmt, args);

#endif

    if (err) {
        p = ngx_log_errno(p, last, err...",101.0,210.0,1.0,1.0,110.0,68,18,89,23,2,11,15,17,1,7,,0,9,10,5,5,void
1485,40495,ngx_regex_malloc,1,ngx_regex_malloc,ANY ngx_regex_malloc (size_t),core\ngx_regex.c,"ngx_regex_malloc(size_t size)
{
    ngx_pool_t      *pool;
    pool = ngx_pcre_pool;

    if (pool) {
        return ngx_palloc(pool, size);
    }

    return NULL;
}",231.0,241.0,1.0,1.0,11.0,1,1,6,4,0,2,2,2,0,1,,0,1,2,1,1,ANY
1486,466482,hash,3,ngx_stream_map_t.hash,,stream\ngx_stream_variables.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1487,286258,ngx_http_postpone_filter_add,1,ngx_http_postpone_filter_add,"ngx_int_t ngx_http_postpone_filter_add (ngx_http_request_t*,ngx_chain_t*)",http\ngx_http_postpone_filter_module.c,"static ngx_int_t
ngx_http_postpone_filter_add(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_http_postponed_request_t  *pr, **ppr;

    if (r->postponed) {
        for (pr = r->postponed; pr->next; pr = pr->next) { /* void */ }

        if (pr->request == NULL) {
            goto found;
        }

        ppr = &pr->next;

    } else {
        ppr = &r->postponed;
    }

    pr = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t));
    if (pr == NULL) {
        return NGX_ERROR;
    }

    *ppr = pr;

    pr->request = NULL;
    pr->out = NULL;
    pr->next = NULL;

found:

    if (ngx_chain_add_copy(r->pool, &pr->out, in) == NGX_OK) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",141.0,177.0,1.0,1.0,37.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1488,3637,ngx_create_chain_of_bufs,1,ngx_create_chain_of_bufs,"ngx_chain_t ngx_create_chain_of_bufs (ngx_pool_t*,ngx_bufs_t*)",core\ngx_buf.c,"ngx_chain_t *
ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs)
{
    u_char       *p;
    ngx_int_t     i;
    ngx_buf_t    *b;
    ngx_chain_t  *chain, *cl, **ll;

    p = ngx_palloc(pool, bufs->num * bufs->size);
    if (p == NULL) {
        return NULL;
    }

    ll = &chain;

    for (i = 0; i < bufs->num; i++) {

        b = ngx_calloc_buf(pool);
        if (b == NULL) {
            return NULL;
        }

        /*
         * set by ngx_calloc_buf():
         *
         *     b->file_pos = 0;
         *     b->file_last = 0;
         *     b->file = NULL;
         *     b->shadow = NULL;
         *     b->tag = 0;
         *     and flags
         *
         */

        b->pos = p;
        b->last = p;
        b->temporary = 1;

        b->start = p;
        p += bufs->size;
        b->end = p;

        cl = ngx_alloc_chain_link(pool);
        if (cl == NULL) {
            return NULL;
        }

        cl->buf = b;
        *ll = cl;
        ll = &cl->next;
    ...",68.0,123.0,1.0,1.0,56.0,35,8,42,9,0,6,5,7,1,2,,0,6,4,2,2,ngx_chain_t
1489,286264,ngx_http_postpone_filter_in_memory,1,ngx_http_postpone_filter_in_memory,"ngx_int_t ngx_http_postpone_filter_in_memory (ngx_http_request_t*,ngx_chain_t*)",http\ngx_http_postpone_filter_module.c,"static ngx_int_t
ngx_http_postpone_filter_in_memory(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     len;
    ngx_buf_t                 *b;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http postpone filter in memory"");

    if (r->out == NULL) {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (r->headers_out.content_length_n != -1) {
            len = r->headers_out.content_length_n;

            if (len > clcf->subrequest_output_buffer_size) {
                ngx_log_error(NGX_LOG_ERR, c->log, 0,
                              ""too big subrequest response: %uz"", len);
                return NGX_ERROR;
            }

        } else {
            len = clcf->subrequest_output_buffer_size;
        }

        b = ngx_create_temp_buf(r->pool, len);
        if (b == NULL) {
            return NGX_ERROR;
        }...",180.0,249.0,1.0,1.0,70.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1490,126522,ngx_http_geo_range_variable,1,ngx_http_geo_range_variable,"ngx_int_t ngx_http_geo_range_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_geo_module.c,"static ngx_int_t
ngx_http_geo_range_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;

    in_addr_t              inaddr;
    ngx_addr_t             addr;
    ngx_uint_t             n;
    struct sockaddr_in    *sin;
    ngx_http_geo_range_t  *range;
#if (NGX_HAVE_INET6)
    u_char                *p;
    struct in6_addr       *inaddr6;
#endif

    *v = *ctx->u.high.default_value;

    if (ngx_http_geo_addr(r, ctx, &addr) == NGX_OK) {

        switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

            if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
                p = inaddr6->s6_addr;

                inaddr = p[12] << 24;
                inaddr += p[13] << 16;
                inaddr += p[14] << 8;
                inaddr += p[15];

            } else {
                inaddr = INADDR_NONE;
    ...",246.0,323.0,1.0,1.0,78.0,44,14,31,11,0,4,9,14,3,1,,0,4,6,3,3,ngx_int_t
1491,400958,ngx_write_chain_to_file,1,ngx_write_chain_to_file,"ssize_t ngx_write_chain_to_file (ngx_file_t*,ngx_chain_t*,off_t,ngx_pool_t*)",os\win32\ngx_files.c,"ssize_t
ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,
    ngx_pool_t *pool)
{
    u_char   *buf, *prev;
    size_t    size;
    ssize_t   total, n;

    total = 0;

    while (cl) {
        buf = cl->buf->pos;
        prev = buf;
        size = 0;

        /* coalesce the neighbouring bufs */

        while (cl && prev == cl->buf->pos) {
            size += cl->buf->last - cl->buf->pos;
            prev = cl->buf->last;
            cl = cl->next;
        }

        n = ngx_write_file(file, buf, size, offset);

        if (n == NGX_ERROR) {
            return NGX_ERROR;
        }

        total += n;
        offset += n;
    }

    return total;
}",127.0,161.0,1.0,1.0,35.0,31,10,39,10,1,7,6,10,1,4,,0,6,8,4,4,ssize_t
1492,319056,ngx_http_upstream_init_round_robin_peer,1,ngx_http_upstream_init_round_robin_peer,"ngx_int_t ngx_http_upstream_init_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)",http\ngx_http_upstream_round_robin.c,"ngx_int_t
ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_uint_t                         n;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    rrp = r->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        r->upstream->peer.data = rrp;
    }

    rrp->peers = us->peer.data;
    rrp->current = NULL;
    rrp->config = 0;

    n = rrp->peers->number;

    if (rrp->peers->next && rrp->peers->next->number > n) {
        n = rrp->peers->next->number;
    }

    if (n <= 8 * sizeof(uintptr_t)) {
        rrp->tried = &rrp->data;
        rrp->data = 0;

    } else {
        n = (n + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t));

        rrp->tried = ngx_pcalloc(r->pool, n * sizeof(uintptr_t));
        if (rrp->tried == NULL) {
            return NGX_ERROR;
        }
    }

    r->...",243.0,295.0,1.0,30.0,53.0,66,12,37,9,0,15,5,6,2,1,,0,15,4,2,2,ngx_int_t
1493,257617,ngx_http_arg,1,ngx_http_arg,"ngx_int_t ngx_http_arg (ngx_http_request_t*,u_char*,size_t,ngx_str_t*)",http\ngx_http_parse.c,"ngx_int_t
ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len, ngx_str_t *value)
{
    u_char  *p, *last;

    if (r->args.len == 0) {
        return NGX_DECLINED;
    }

    p = r->args.data;
    last = p + r->args.len;

    for ( /* void */ ; p < last; p++) {

        /* we need '=' after name, so drop one char from last */

        p = ngx_strlcasestrn(p, last - 1, name, len - 1);

        if (p == NULL) {
            return NGX_DECLINED;
        }

        if ((p == r->args.data || *(p - 1) == '&') && *(p + len) == '=') {

            value->data = p + len + 1;

            p = ngx_strlchr(p, last, '&');

            if (p == NULL) {
                p = r->args.data + r->args.len;
            }

            value->len = p - value->data;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}",2102.0,2141.0,1.0,1.0,40.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ngx_int_t
1494,7765,ngx_conf_set_bufs_slot,1,ngx_conf_set_bufs_slot,"char* ngx_conf_set_bufs_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_bufs_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char *p = conf;

    ngx_str_t   *value;
    ngx_bufs_t  *bufs;


    bufs = (ngx_bufs_t *) (p + cmd->offset);
    if (bufs->num) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    bufs->num = ngx_atoi(value[1].data, value[1].len);
    if (bufs->num == NGX_ERROR || bufs->num == 0) {
        return ""invalid value"";
    }

    bufs->size = ngx_parse_size(&value[2]);
    if (bufs->size == (size_t) NGX_ERROR || bufs->size == 0) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1321.0,1348.0,1.0,1.0,28.0,30,9,20,8,0,9,4,4,5,2,,0,9,6,3,3,char*
1495,89696,ngx_ssl_error,1,ngx_ssl_error,"ANY ngx_ssl_error (ngx_uint_t,ngx_log_t*,ngx_err_t,char*...)",event\ngx_event_openssl.c,"ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)
{
    int          flags;
    u_long       n;
    va_list      args;
    u_char      *p, *last;
    u_char       errstr[NGX_MAX_CONF_ERRSTR];
    const char  *data;

    last = errstr + NGX_MAX_CONF_ERRSTR;

    va_start(args, fmt);
    p = ngx_vslprintf(errstr, last - 1, fmt, args);
    va_end(args);

    if (ERR_peek_error()) {
        p = ngx_cpystrn(p, (u_char *) "" (SSL:"", last - p);

        for ( ;; ) {

            n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);

            if (n == 0) {
                break;
            }

            /* ERR_error_string_n() requires at least one byte */

            if (p >= last - 1) {
                goto next;
            }

            *p++ = ' ';

            ERR_error_string_n(n, (char *) p, last - p);

            while (p < last && *p) {
                p++;
            }

            if (p < last && *data && (flags & ERR_TXT_STRING)) {
       ...",3060.0,3116.0,1.0,1.0,57.0,39,12,52,14,42,4,10,18,0,4,,0,3,8,4,4,ANY
1496,286305,ngx_http_postpone_filter,1,ngx_http_postpone_filter,"ngx_int_t ngx_http_postpone_filter (ngx_http_request_t*,ngx_chain_t*)",http\ngx_http_postpone_filter_module.c,"static ngx_int_t
ngx_http_postpone_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_connection_t              *c;
    ngx_http_postponed_request_t  *pr;

    c = r->connection;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http postpone filter \""%V?%V\"" %p"", &r->uri, &r->args, in);

    if (r->subrequest_in_memory) {
        return ngx_http_postpone_filter_in_memory(r, in);
    }

    if (r != c->data) {

        if (in) {
            if (ngx_http_postpone_filter_add(r, in) != NGX_OK) {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

#if 0
        /* TODO: SSI may pass NULL */
        ngx_log_error(NGX_LOG_ALERT, c->log, 0,
                      ""http postpone filter NULL inactive request"");
#endif

        return NGX_OK;
    }

    if (r->postponed == NULL) {

        if (in || c->buffered) {
            return ngx_http_next_body_filter(r->main, in);
        }

        return NGX_OK;
    }

    if (in) {
      ...",54.0,138.0,1.0,1.0,85.0,41,6,52,9,0,5,12,19,2,5,,0,2,4,2,2,ngx_int_t
1497,61026,ngx_sprintf_num,1,ngx_sprintf_num,"u_char* ngx_sprintf_num (u_char*,u_char*,uint64_t,u_char,ngx_uint_t,ngx_uint_t)",core\ngx_string.c,"static u_char *
ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64, u_char zero,
    ngx_uint_t hexadecimal, ngx_uint_t width)
{
    u_char         *p, temp[NGX_INT64_LEN + 1];
                       /*
                        * we need temp[NGX_INT64_LEN] only,
                        * but icc issues the warning
                        */
    size_t          len;
    uint32_t        ui32;
    static u_char   hex[] = ""0123456789abcdef"";
    static u_char   HEX[] = ""0123456789ABCDEF"";

    p = temp + NGX_INT64_LEN;

    if (hexadecimal == 0) {

        if (ui64 <= (uint64_t) NGX_MAX_UINT32_VALUE) {

            /*
             * To divide 64-bit numbers and to find remainders
             * on the x86 platform gcc and icc call the libc functions
             * [u]divdi3() and [u]moddi3(), they call another function
             * in its turn.  On FreeBSD it is the qdivrem() function,
             * its source code is about 170 lines of the code.
             * The glibc counte...",493.0,576.0,1.0,1.0,84.0,0,0,0,0,3,0,1,1,0,0,,0,0,12,6,6,u_char
1498,433766,ngx_stream_limit_conn_module,2,stream\ngx_stream_limit_conn_module.c.ngx_stream_limit_conn_module,,stream\ngx_stream_limit_conn_module.c,ngx_module_t ngx_stream_limit_conn_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1499,61036,ngx_encode_base64_internal,1,ngx_encode_base64_internal,"void ngx_encode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*,ngx_uint_t)",core\ngx_string.c,"static void
ngx_encode_base64_internal(ngx_str_t *dst, ngx_str_t *src, const u_char *basis,
    ngx_uint_t padding)
{
    u_char         *d, *s;
    size_t          len;

    len = src->len;
    s = src->data;
    d = dst->data;

    while (len > 2) {
        *d++ = basis[(s[0] >> 2) & 0x3f];
        *d++ = basis[((s[0] & 3) << 4) | (s[1] >> 4)];
        *d++ = basis[((s[1] & 0x0f) << 2) | (s[2] >> 6)];
        *d++ = basis[s[2] & 0x3f];

        s += 3;
        len -= 3;
    }

    if (len) {
        *d++ = basis[(s[0] >> 2) & 0x3f];

        if (len == 1) {
            *d++ = basis[(s[0] & 3) << 4];
            if (padding) {
                *d++ = '=';
            }

        } else {
            *d++ = basis[((s[0] & 3) << 4) | (s[1] >> 4)];
            *d++ = basis[(s[1] & 0x0f) << 2];
        }

        if (padding) {
            *d++ = '=';
        }
    }

    dst->len = d - dst->data;
}",1157.0,1198.0,1.0,1.0,42.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
1500,61044,ngx_decode_base64_internal,1,ngx_decode_base64_internal,"ngx_int_t ngx_decode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*)",core\ngx_string.c,"static ngx_int_t
ngx_decode_base64_internal(ngx_str_t *dst, ngx_str_t *src, const u_char *basis)
{
    size_t          len;
    u_char         *d, *s;

    for (len = 0; len < src->len; len++) {
        if (src->data[len] == '=') {
            break;
        }

        if (basis[src->data[len]] == 77) {
            return NGX_ERROR;
        }
    }

    if (len % 4 == 1) {
        return NGX_ERROR;
    }

    s = src->data;
    d = dst->data;

    while (len > 3) {
        *d++ = (u_char) (basis[s[0]] << 2 | basis[s[1]] >> 4);
        *d++ = (u_char) (basis[s[1]] << 4 | basis[s[2]] >> 2);
        *d++ = (u_char) (basis[s[2]] << 6 | basis[s[3]]);

        s += 4;
        len -= 4;
    }

    if (len > 1) {
        *d++ = (u_char) (basis[s[0]] << 2 | basis[s[1]] >> 4);
    }

    if (len > 2) {
        *d++ = (u_char) (basis[s[1]] << 4 | basis[s[2]] >> 2);
    }

    dst->len = d - dst->data;

    return NGX_OK;
}",1255.0,1298.0,1.0,1.0,44.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1501,93544,ngx_ssl_ocsp_cleanup,1,ngx_ssl_ocsp_cleanup,void ngx_ssl_ocsp_cleanup (ngx_connection_t*),event\ngx_event_openssl_stapling.c,"void
ngx_ssl_ocsp_cleanup(ngx_connection_t *c)
{
}",2765.0,2768.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1502,167546,ngx_http_map_variable,1,ngx_http_map_variable,"ngx_int_t ngx_http_map_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)",http\modules\ngx_http_map_module.c,"static ngx_int_t
ngx_http_map_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_map_ctx_t  *map = (ngx_http_map_ctx_t *) data;

    ngx_str_t                   val, str;
    ngx_http_complex_value_t   *cv;
    ngx_http_variable_value_t  *value;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http map started"");

    if (ngx_http_complex_value(r, &map->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (map->hostnames && val.len > 0 && val.data[val.len - 1] == '.') {
        val.len--;
    }

    value = ngx_http_map_find(r, &map->map, &val);

    if (value == NULL) {
        value = map->default_value;
    }

    if (!value->valid) {
        cv = (ngx_http_complex_value_t *) value->data;

        if (ngx_http_complex_value(r, cv, &str) != NGX_OK) {
            return NGX_ERROR;
        }

        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->len = str.le...",107.0,155.0,1.0,1.0,49.0,49,13,42,12,0,13,6,7,7,3,,0,13,6,3,3,ngx_int_t
1503,61051,ngx_strlow,1,ngx_strlow,"void ngx_strlow (u_char*,u_char*,size_t)",core\ngx_string.c,"void
ngx_strlow(u_char *dst, u_char *src, size_t n)
{
    while (n) {
        *dst = ngx_tolower(*src);
        dst++;
        src++;
        n--;
    }
}",20.0,29.0,1.0,1.0,10.0,6,4,6,3,6,0,2,2,0,0,,0,0,6,3,3,void
1504,257659,ngx_http_update_location_config,1,ngx_http_update_location_config,void ngx_http_update_location_config (ngx_http_request_t*),http\ngx_http_core_module.c,"void
ngx_http_update_location_config(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (r->method & clcf->limit_except) {
        r->loc_conf = clcf->limit_except_loc_conf;
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
    }

    if (r == r->main) {
        ngx_set_connection_log(r->connection, clcf->error_log);
    }

    if ((ngx_io.flags & NGX_IO_SENDFILE) && clcf->sendfile) {
        r->connection->sendfile = 1;

    } else {
        r->connection->sendfile = 0;
    }

    if (clcf->client_body_in_file_only) {
        r->request_body_in_file_only = 1;
        r->request_body_in_persistent_file = 1;
        r->request_body_in_clean_file =
            clcf->client_body_in_file_only == NGX_HTTP_REQUEST_BODY_FILE_CLEAN;
        r->request_body_file_log_level = NGX_LOG_NOTICE;

    } else {
        r->request_body_file_log_level = NGX_LOG_WARN;
    }

    r->request_body_in_...",1290.0,1365.0,1.0,46.0,76.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
1505,257664,ngx_http_handler,1,ngx_http_handler,void ngx_http_handler (ngx_http_request_t*),http\ngx_http_core_module.c,"void
ngx_http_handler(ngx_http_request_t *r)
{
    ngx_http_core_main_conf_t  *cmcf;

    r->connection->log->action = NULL;

    if (!r->internal) {
        switch (r->headers_in.connection_type) {
        case 0:
            r->keepalive = (r->http_version > NGX_HTTP_VERSION_10);
            break;

        case NGX_HTTP_CONNECTION_CLOSE:
            r->keepalive = 0;
            break;

        case NGX_HTTP_CONNECTION_KEEP_ALIVE:
            r->keepalive = 1;
            break;
        }

        r->lingering_close = (r->headers_in.content_length_n > 0
                              || r->headers_in.chunked);
        r->phase_handler = 0;

    } else {
        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
        r->phase_handler = cmcf->phase_engine.server_rewrite_index;
    }

    r->valid_location = 1;
#if (NGX_HTTP_GZIP)
    r->gzip_tested = 0;
    r->gzip_ok = 0;
    r->gzip_vary = 0;
#endif

    r->write_event_handler = ngx_http_core_run_phases;
    ngx_htt...",812.0,852.0,1.0,1.0,41.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1506,257669,ngx_http_run_posted_requests,1,ngx_http_run_posted_requests,void ngx_http_run_posted_requests (ngx_connection_t*),http\ngx_http_request.c,"void
ngx_http_run_posted_requests(ngx_connection_t *c)
{
    ngx_http_request_t         *r;
    ngx_http_posted_request_t  *pr;

    for ( ;; ) {

        if (c->destroyed) {
            return;
        }

        r = c->data;
        pr = r->main->posted_requests;

        if (pr == NULL) {
            return;
        }

        r->main->posted_requests = pr->next;

        r = pr->request;

        ngx_http_set_log_request(c->log, r);

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                       ""http posted request: \""%V?%V\"""", &r->uri, &r->args);

        r->write_event_handler(r);
    }
}",2373.0,2403.0,1.0,1.0,31.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1507,347786,ngx_http_v2_filter_send,1,ngx_http_v2_filter_send,"ANY ngx_http_v2_filter_send (ngx_connection_t*,ngx_http_v2_stream_t*)",http\v2\ngx_http_v2_filter_module.c,"ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)
{
    stream->blocked = 1;

    if (ngx_http_v2_send_output_queue(stream->connection) == NGX_ERROR) {
        fc->error = 1;
        return NGX_ERROR;
    }

    stream->blocked = 0;

    if (stream->queued) {
        fc->buffered |= NGX_HTTP_V2_BUFFERED;
        fc->write->active = 1;
        fc->write->ready = 0;
        return NGX_AGAIN;
    }

    fc->buffered &= ~NGX_HTTP_V2_BUFFERED;

    return NGX_OK;
}",1810.0,1831.0,1.0,1.0,22.0,18,4,15,6,1,1,3,3,1,1,,0,1,4,2,2,ANY
1508,257674,ngx_http_post_request,1,ngx_http_post_request,"ngx_int_t ngx_http_post_request (ngx_http_request_t*,ngx_http_posted_request_t*)",http\ngx_http_request.c,"ngx_int_t
ngx_http_post_request(ngx_http_request_t *r, ngx_http_posted_request_t *pr)
{
    ngx_http_posted_request_t  **p;

    if (pr == NULL) {
        pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));
        if (pr == NULL) {
            return NGX_ERROR;
        }
    }

    pr->request = r;
    pr->next = NULL;

    for (p = &r->main->posted_requests; *p; p = &(*p)->next) { /* void */ }

    *p = pr;

    return NGX_OK;
}",2406.0,2426.0,1.0,1.0,21.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1509,433806,ngx_stream_limit_conn_handler,1,ngx_stream_limit_conn_handler,ngx_int_t ngx_stream_limit_conn_handler (ngx_stream_session_t*),stream\ngx_stream_limit_conn_module.c,"static ngx_int_t
ngx_stream_limit_conn_handler(ngx_stream_session_t *s)
{
    size_t                            n;
    uint32_t                          hash;
    ngx_str_t                         key;
    ngx_uint_t                        i;
    ngx_rbtree_node_t                *node;
    ngx_pool_cleanup_t               *cln;
    ngx_stream_limit_conn_ctx_t      *ctx;
    ngx_stream_limit_conn_node_t     *lc;
    ngx_stream_limit_conn_conf_t     *lccf;
    ngx_stream_limit_conn_limit_t    *limits;
    ngx_stream_limit_conn_cleanup_t  *lccln;

    lccf = ngx_stream_get_module_srv_conf(s, ngx_stream_limit_conn_module);
    limits = lccf->limits.elts;

    for (i = 0; i < lccf->limits.nelts; i++) {
        ctx = limits[i].shm_zone->data;

        if (ngx_stream_complex_value(s, &ctx->key, &key) != NGX_OK) {
            return NGX_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (key.len > 255) {
            ngx_log_error(NGX_LOG_ERR, s->connec...",163.0,288.0,1.0,31.0,126.0,97,12,84,26,0,38,11,19,6,10,,0,33,2,1,1,ngx_int_t
1510,257680,ngx_http_finalize_request,1,ngx_http_finalize_request,"void ngx_http_finalize_request (ngx_http_request_t*,ngx_int_t)",http\ngx_http_request.c,"void
ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_connection_t          *c;
    ngx_http_request_t        *pr;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http finalize request: %i, \""%V?%V\"" a:%d, c:%d"",
                   rc, &r->uri, &r->args, r == c->data, r->main->count);

    if (rc == NGX_DONE) {
        ngx_http_finalize_connection(r);
        return;
    }

    if (rc == NGX_OK && r->filter_finalize) {
        c->error = 1;
    }

    if (rc == NGX_DECLINED) {
        r->content_handler = NULL;
        r->write_event_handler = ngx_http_core_run_phases;
        ngx_http_core_run_phases(r);
        return;
    }

    if (r != r->main && r->post_subrequest) {
        rc = r->post_subrequest->handler(r, r->post_subrequest->data, rc);
    }

    if (rc == NGX_ERROR
        || rc == NGX_HTTP_REQUEST_TIME_OUT
        || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST
        ||...",2429.0,2618.0,1.0,1.0,190.0,0,0,0,0,26,0,1,1,0,0,,0,0,4,2,2,void
1511,257686,ngx_http_free_request,1,ngx_http_free_request,"void ngx_http_free_request (ngx_http_request_t*,ngx_int_t)",http\ngx_http_request.c,"void
ngx_http_free_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_t                 *log;
    ngx_pool_t                *pool;
    struct linger              linger;
    ngx_http_cleanup_t        *cln;
    ngx_http_log_ctx_t        *ctx;
    ngx_http_core_loc_conf_t  *clcf;

    log = r->connection->log;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, ""http close request"");

    if (r->pool == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, 0, ""http request already closed"");
        return;
    }

    cln = r->cleanup;
    r->cleanup = NULL;

    while (cln) {
        if (cln->handler) {
            cln->handler(cln->data);
        }

        cln = cln->next;
    }

#if (NGX_STAT_STUB)

    if (r->stat_reading) {
        (void) ngx_atomic_fetch_add(ngx_stat_reading, -1);
    }

    if (r->stat_writing) {
        (void) ngx_atomic_fetch_add(ngx_stat_writing, -1);
    }

#endif

    if (rc > 0 && (r->headers_out.status == 0 || r->connection->sent == 0)) {
        r->head...",3576.0,3663.0,1.0,1.0,88.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1512,257702,ngx_http_send_special,1,ngx_http_send_special,"ngx_int_t ngx_http_send_special (ngx_http_request_t*,ngx_uint_t)",http\ngx_http_request.c,"ngx_int_t
ngx_http_send_special(ngx_http_request_t *r, ngx_uint_t flags)
{
    ngx_buf_t    *b;
    ngx_chain_t   out;

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    if (flags & NGX_HTTP_LAST) {

        if (r == r->main && !r->post_action) {
            b->last_buf = 1;

        } else {
            b->sync = 1;
            b->last_in_chain = 1;
        }
    }

    if (flags & NGX_HTTP_FLUSH) {
        b->flush = 1;
    }

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &out);
}",3473.0,3503.0,1.0,1.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1513,261803,ngx_http_set_content_type,1,ngx_http_set_content_type,ngx_int_t ngx_http_set_content_type (ngx_http_request_t*),http\ngx_http_core_module.c,"ngx_int_t
ngx_http_set_content_type(ngx_http_request_t *r)
{
    u_char                     c, *exten;
    ngx_str_t                 *type;
    ngx_uint_t                 i, hash;
    ngx_http_core_loc_conf_t  *clcf;

    if (r->headers_out.content_type.len) {
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (r->exten.len) {

        hash = 0;

        for (i = 0; i < r->exten.len; i++) {
            c = r->exten.data[i];

            if (c >= 'A' && c <= 'Z') {

                exten = ngx_pnalloc(r->pool, r->exten.len);
                if (exten == NULL) {
                    return NGX_ERROR;
                }

                hash = ngx_hash_strlow(exten, r->exten.data, r->exten.len);

                r->exten.data = exten;

                break;
            }

            hash = ngx_hash(hash, c);
        }

        type = ngx_hash_find(&clcf->types_hash, hash,
                             r->exten.data, r->exten.len);

  ...",1575.0,1628.0,1.0,1.0,54.0,56,11,46,11,2,5,8,14,0,3,,0,5,2,1,1,ngx_int_t
1514,257708,ngx_http_read_client_request_body,1,ngx_http_read_client_request_body,"ngx_int_t ngx_http_read_client_request_body (ngx_http_request_t*,ngx_http_client_body_handler_pt)",http\ngx_http_request_body.c,"ngx_int_t
ngx_http_read_client_request_body(ngx_http_request_t *r,
    ngx_http_client_body_handler_pt post_handler)
{
    size_t                     preread;
    ssize_t                    size;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_chain_t                out;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    r->main->count++;

    if (r != r->main || r->request_body || r->discard_body) {
        r->request_body_no_buffering = 0;
        post_handler(r);
        return NGX_OK;
    }

    if (ngx_http_test_expect(r) != NGX_OK) {
        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
        goto done;
    }

    rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
    if (rb == NULL) {
        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
        goto done;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     rb->bufs = NULL;
     *     rb->buf = NULL;
     *     rb->free = NULL;
     *     rb->busy = NULL;
     *     rb-...",29.0,209.0,1.0,1.0,181.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1515,3757,ngx_chain_add_copy,1,ngx_chain_add_copy,"ngx_int_t ngx_chain_add_copy (ngx_pool_t*,ngx_chain_t**,ngx_chain_t*)",core\ngx_buf.c,"ngx_int_t
ngx_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain, ngx_chain_t *in)
{
    ngx_chain_t  *cl, **ll;

    ll = chain;

    for (cl = *chain; cl; cl = cl->next) {
        ll = &cl->next;
    }

    while (in) {
        cl = ngx_alloc_chain_link(pool);
        if (cl == NULL) {
            *ll = NULL;
            return NGX_ERROR;
        }

        cl->buf = in->buf;
        *ll = cl;
        ll = &cl->next;
        in = in->next;
    }

    *ll = NULL;

    return NGX_OK;
}",126.0,153.0,1.0,1.0,28.0,22,5,26,8,4,1,4,5,0,1,,0,1,6,3,3,ngx_int_t
1516,61102,ngx_cpystrn,1,ngx_cpystrn,"u_char ngx_cpystrn (u_char*,u_char*,size_t)",core\ngx_string.c,"u_char *
ngx_cpystrn(u_char *dst, u_char *src, size_t n)
{
    if (n == 0) {
        return dst;
    }

    while (--n) {
        *dst = *src;

        if (*dst == '\0') {
            return dst;
        }

        dst++;
        src++;
    }

    *dst = '\0';

    return dst;
}",48.0,69.0,1.0,1.0,22.0,11,5,11,3,13,0,4,5,0,0,,0,0,6,3,3,u_char
1517,7859,ngx_conf_set_enum_slot,1,ngx_conf_set_enum_slot,"char* ngx_conf_set_enum_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_enum_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_uint_t       *np, i;
    ngx_str_t        *value;
    ngx_conf_enum_t  *e;

    np = (ngx_uint_t *) (p + cmd->offset);

    if (*np != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;
    e = cmd->post;

    for (i = 0; e[i].name.len != 0; i++) {
        if (e[i].name.len != value[1].len
            || ngx_strcasecmp(e[i].name.data, value[1].data) != 0)
        {
            continue;
        }

        *np = e[i].value;

        return NGX_CONF_OK;
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""invalid value \""%s\"""", value[1].data);

    return NGX_CONF_ERROR;
}",1351.0,1385.0,1.0,1.0,35.0,36,9,28,12,0,2,5,5,1,2,,0,1,6,3,3,char*
1518,257719,ngx_http_send_header,1,ngx_http_send_header,ngx_int_t ngx_http_send_header (ngx_http_request_t*),http\ngx_http_core_module.c,"ngx_int_t
ngx_http_send_header(ngx_http_request_t *r)
{
    if (r->post_action) {
        return NGX_OK;
    }

    if (r->header_sent) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""header already sent"");
        return NGX_ERROR;
    }

    if (r->err_status) {
        r->headers_out.status = r->err_status;
        r->headers_out.status_line.len = 0;
    }

    return ngx_http_top_header_filter(r);
}",1813.0,1832.0,1.0,1.0,20.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1519,257730,ngx_http_filter_finalize_request,1,ngx_http_filter_finalize_request,"ngx_int_t ngx_http_filter_finalize_request (ngx_http_request_t*,ngx_module_t*,ngx_int_t)",http\ngx_http_special_response.c,"ngx_int_t
ngx_http_filter_finalize_request(ngx_http_request_t *r, ngx_module_t *m,
    ngx_int_t error)
{
    void       *ctx;
    ngx_int_t   rc;

    ngx_http_clean_header(r);

    ctx = NULL;

    if (m) {
        ctx = r->ctx[m->ctx_index];
    }

    /* clear the modules contexts */
    ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);

    if (m) {
        r->ctx[m->ctx_index] = ctx;
    }

    r->filter_finalize = 1;

    rc = ngx_http_special_response_handler(r, error);

    /* NGX_ERROR resets any pending data */

    switch (rc) {

    case NGX_OK:
    case NGX_DONE:
        return NGX_ERROR;

    default:
        return rc;
    }
}",527.0,564.0,1.0,1.0,38.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1520,257742,ngx_http_discard_request_body,1,ngx_http_discard_request_body,ngx_int_t ngx_http_discard_request_body (ngx_http_request_t*),http\ngx_http_request_body.c,"ngx_int_t
ngx_http_discard_request_body(ngx_http_request_t *r)
{
    ssize_t       size;
    ngx_int_t     rc;
    ngx_event_t  *rev;

    if (r != r->main || r->discard_body || r->request_body) {
        return NGX_OK;
    }

#if (NGX_HTTP_V2)
    if (r->stream) {
        r->stream->skip_data = 1;
        return NGX_OK;
    }
#endif

    if (ngx_http_test_expect(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    rev = r->connection->read;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0, ""http set discard body"");

    if (rev->timer_set) {
        ngx_del_timer(rev);
    }

    if (r->headers_in.content_length_n <= 0 && !r->headers_in.chunked) {
        return NGX_OK;
    }

    size = r->header_in->last - r->header_in->pos;

    if (size || r->headers_in.chunked) {
        rc = ngx_http_discard_request_body_filter(r, r->header_in);

        if (rc != NGX_OK) {
            return rc;
        }

        if (r->headers_in.content_length_n == 0) {
           ...",510.0,581.0,1.0,1.0,72.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1521,61143,ngx_pstrdup,1,ngx_pstrdup,"u_char ngx_pstrdup (ngx_pool_t*,ngx_str_t*)",core\ngx_string.c,"u_char *
ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src)
{
    u_char  *dst;

    dst = ngx_pnalloc(pool, src->len);
    if (dst == NULL) {
        return NULL;
    }

    ngx_memcpy(dst, src->data, src->len);

    return dst;
}",72.0,85.0,1.0,1.0,14.0,5,3,10,4,6,4,2,2,0,1,,0,4,4,2,2,u_char
1522,89842,ngx_ssl_session_cache,1,ngx_ssl_session_cache,"ngx_int_t ngx_ssl_session_cache (ngx_ssl_t*,ngx_str_t*,ngx_array_t*,ssize_t,ngx_shm_zone_t*,time_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ngx_array_t *certificates, ssize_t builtin_session_cache,
    ngx_shm_zone_t *shm_zone, time_t timeout)
{
    long  cache_mode;

    SSL_CTX_set_timeout(ssl->ctx, (long) timeout);

    if (ngx_ssl_session_id_context(ssl, sess_ctx, certificates) != NGX_OK) {
        return NGX_ERROR;
    }

    if (builtin_session_cache == NGX_SSL_NO_SCACHE) {
        SSL_CTX_set_session_cache_mode(ssl->ctx, SSL_SESS_CACHE_OFF);
        return NGX_OK;
    }

    if (builtin_session_cache == NGX_SSL_NONE_SCACHE) {

        /*
         * If the server explicitly says that it does not support
         * session reuse (see SSL_SESS_CACHE_OFF above), then
         * Outlook Express fails to upload a sent email to
         * the Sent Items folder on the IMAP server via a separate IMAP
         * connection in the background.  Therefore we have a special
         * mode (SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL_STORE)
         ...",3119.0,3190.0,1.0,1.0,72.0,23,7,49,23,0,3,9,11,2,2,,0,2,12,6,6,ngx_int_t
1523,61176,ngx_sprintf,1,ngx_sprintf,"ANY ngx_sprintf (u_char*,char*...)",core\ngx_string.c,"ngx_sprintf(u_char *buf, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, (void *) -1, fmt, args);
    va_end(args);

    return p;
}",121.0,131.0,1.0,1.0,11.0,3,3,8,4,28,1,1,1,0,1,,0,1,4,2,2,ANY
1524,3834,ngx_chain_get_free_buf,1,ngx_chain_get_free_buf,"ngx_chain_t ngx_chain_get_free_buf (ngx_pool_t*,ngx_chain_t**)",core\ngx_buf.c,"ngx_chain_t *
ngx_chain_get_free_buf(ngx_pool_t *p, ngx_chain_t **free)
{
    ngx_chain_t  *cl;

    if (*free) {
        cl = *free;
        *free = cl->next;
        cl->next = NULL;
        return cl;
    }

    cl = ngx_alloc_chain_link(p);
    if (cl == NULL) {
        return NULL;
    }

    cl->buf = ngx_calloc_buf(p);
    if (cl->buf == NULL) {
        return NULL;
    }

    cl->next = NULL;

    return cl;
}",156.0,181.0,1.0,1.0,26.0,16,4,21,4,7,1,4,4,0,1,,0,1,4,2,2,ngx_chain_t
1525,446897,ngx_stream_compile_complex_value,1,ngx_stream_compile_complex_value,ngx_int_t ngx_stream_compile_complex_value (ngx_stream_compile_complex_value_t*),stream\ngx_stream_script.c,"ngx_int_t
ngx_stream_compile_complex_value(ngx_stream_compile_complex_value_t *ccv)
{
    ngx_str_t                    *v;
    ngx_uint_t                    i, n, nv, nc;
    ngx_array_t                   flushes, lengths, values, *pf, *pl, *pv;
    ngx_stream_script_compile_t   sc;

    v = ccv->value;

    nv = 0;
    nc = 0;

    for (i = 0; i < v->len; i++) {
        if (v->data[i] == '$') {
            if (v->data[i + 1] >= '1' && v->data[i + 1] <= '9') {
                nc++;

            } else {
                nv++;
            }
        }
    }

    if ((v->len == 0 || v->data[0] != '$')
        && (ccv->conf_prefix || ccv->root_prefix))
    {
        if (ngx_conf_full_name(ccv->cf->cycle, v, ccv->conf_prefix) != NGX_OK) {
            return NGX_ERROR;
        }

        ccv->conf_prefix = 0;
        ccv->root_prefix = 0;
    }

    ccv->complex_value->value = *v;
    ccv->complex_value->flushes = NULL;
    ccv->complex_value->lengths = NULL;
    ccv->complex_value->values...",139.0,240.0,1.0,1.0,102.0,150,20,107,21,1,49,12,16,19,5,,0,49,2,1,1,ngx_int_t
1526,39028,ngx_rbtree_insert,1,ngx_rbtree_insert,"void ngx_rbtree_insert (ngx_rbtree_t*,ngx_rbtree_node_t*)",core\ngx_rbtree.c,"void
ngx_rbtree_insert(ngx_rbtree_t *tree, ngx_rbtree_node_t *node)
{
    ngx_rbtree_node_t  **root, *temp, *sentinel;

    /* a binary tree insert */

    root = &tree->root;
    sentinel = tree->sentinel;

    if (*root == sentinel) {
        node->parent = NULL;
        node->left = sentinel;
        node->right = sentinel;
        ngx_rbt_black(node);
        *root = node;

        return;
    }

    tree->insert(*root, node, sentinel);

    /* re-balance tree */

    while (node != *root && ngx_rbt_is_red(node->parent)) {

        if (node->parent == node->parent->parent->left) {
            temp = node->parent->parent->right;

            if (ngx_rbt_is_red(temp)) {
                ngx_rbt_black(node->parent);
                ngx_rbt_black(temp);
                ngx_rbt_red(node->parent->parent);
                node = node->parent->parent;

            } else {
                if (node == node->parent->right) {
                    node = node->parent;
                    ngx_...",24.0,93.0,1.0,1.0,70.0,37,7,33,6,3,0,5,8,0,0,,0,0,4,2,2,void
1527,249070,ngx_http_xslt_sax_error,1,ngx_http_xslt_sax_error,"ANY ngx_http_xslt_sax_error (void*,char*...)",http\modules\ngx_http_xslt_filter_module.c,"ngx_http_xslt_sax_error(void *data, const char *msg, ...)
{
    xmlParserCtxtPtr ctxt = data;

    size_t                       n;
    va_list                      args;
    ngx_http_xslt_filter_ctx_t  *ctx;
    u_char                       buf[NGX_MAX_ERROR_STR];

    ctx = ctxt->sax->_private;

    buf[0] = '\0';

    va_start(args, msg);
    n = (size_t) vsnprintf((char *) buf, NGX_MAX_ERROR_STR, msg, args);
    va_end(args);

    while (--n && (buf[n] == CR || buf[n] == LF)) { /* void */ }

    ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,
                  ""libxml2 error: \""%*s\"""", n + 1, buf);
}",463.0,484.0,1.0,1.0,22.0,20,9,24,11,0,2,2,2,0,1,,0,1,4,2,2,ANY
1528,61203,ngx_snprintf,1,ngx_snprintf,"ANY ngx_snprintf (u_char*,size_t,char*...)",core\ngx_string.c,"ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, buf + max, fmt, args);
    va_end(args);

    return p;
}",135.0,145.0,1.0,1.0,11.0,2,2,10,5,8,1,1,1,0,1,,0,1,6,3,3,ANY
1529,93975,ngx_event_pipe_read_upstream,1,ngx_event_pipe_read_upstream,ngx_int_t ngx_event_pipe_read_upstream (ngx_event_pipe_t*),event\ngx_event_pipe.c,"static ngx_int_t
ngx_event_pipe_read_upstream(ngx_event_pipe_t *p)
{
    off_t         limit;
    ssize_t       n, size;
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_msec_t    delay;
    ngx_chain_t  *chain, *cl, *ln;

    if (p->upstream_eof || p->upstream_error || p->upstream_done) {
        return NGX_OK;
    }

#if (NGX_THREADS)

    if (p->aio) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,
                       ""pipe read upstream: aio"");
        return NGX_AGAIN;
    }

    if (p->writing) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,
                       ""pipe read upstream: writing"");

        rc = ngx_event_pipe_write_chain_to_temp_file(p);

        if (rc != NGX_OK) {
            return rc;
        }
    }

#endif

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,
                   ""pipe read upstream: %d"", p->upstream->read->ready);

    for ( ;; ) {

        if (p->upstream_eof || p->upstream_error || p->upstream_done) {
            break...",101.0,498.0,1.0,1.0,398.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1530,93980,ngx_event_pipe_write_to_downstream,1,ngx_event_pipe_write_to_downstream,ngx_int_t ngx_event_pipe_write_to_downstream (ngx_event_pipe_t*),event\ngx_event_pipe.c,"static ngx_int_t
ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p)
{
    u_char            *prev;
    size_t             bsize;
    ngx_int_t          rc;
    ngx_uint_t         flush, flushed, prev_last_shadow;
    ngx_chain_t       *out, **ll, *cl;
    ngx_connection_t  *downstream;

    downstream = p->downstream;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,
                   ""pipe write downstream: %d"", downstream->write->ready);

#if (NGX_THREADS)

    if (p->writing) {
        rc = ngx_event_pipe_write_chain_to_temp_file(p);

        if (rc == NGX_ABORT) {
            return NGX_ABORT;
        }
    }

#endif

    flushed = 0;

    for ( ;; ) {
        if (p->downstream_error) {
            return ngx_event_pipe_drain_chains(p);
        }

        if (p->upstream_eof || p->upstream_error || p->upstream_done) {

            /* pass the p->out and p->in chains to the output filter */

            for (cl = p->busy; cl; cl = cl->next) {
                cl->buf->recy...",501.0,734.0,1.0,1.0,234.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,ngx_int_t
1531,40735,pattern,3,ngx_regex_compile_t.pattern,,core\ngx_regex.h,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1532,40736,pool,3,ngx_regex_compile_t.pool,,core\ngx_regex.h,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1533,24353,ngx_log_error,1,ngx_log_error,"ANY ngx_log_error (ngx_uint_t,ngx_log_t*,ngx_err_t,char*...)",core\ngx_log.c,"ngx_log_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, ...)
{
    va_list  args;

    if (log->log_level >= level) {
        va_start(args, fmt);
        ngx_log_error_core(level, log, err, fmt, args);
        va_end(args);
    }
}",216.0,226.0,1.0,1.0,11.0,2,2,10,5,211,1,2,2,0,1,,0,0,8,4,4,ANY
1534,319266,ngx_http_upstream_create_round_robin_peer,1,ngx_http_upstream_create_round_robin_peer,"ngx_int_t ngx_http_upstream_create_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_resolved_t*)",http\ngx_http_upstream_round_robin.c,"ngx_int_t
ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_resolved_t *ur)
{
    u_char                            *p;
    size_t                             len;
    socklen_t                          socklen;
    ngx_uint_t                         i, n;
    struct sockaddr                   *sockaddr;
    ngx_http_upstream_rr_peer_t       *peer, **peerp;
    ngx_http_upstream_rr_peers_t      *peers;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    rrp = r->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        r->upstream->peer.data = rrp;
    }

    peers = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peers_t));
    if (peers == NULL) {
        return NGX_ERROR;
    }

    peer = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peer_t)
                                * ur->naddrs);
    if (peer == ...",298.0,413.0,1.0,30.0,116.0,110,11,66,12,0,22,7,8,1,3,,0,22,4,2,2,ngx_int_t
1535,40739,captures,3,ngx_regex_compile_t.captures,,core\ngx_regex.h,captures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1536,40740,named_captures,3,ngx_regex_compile_t.named_captures,,core\ngx_regex.h,named_captures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1537,40741,name_size,3,ngx_regex_compile_t.name_size,,core\ngx_regex.h,name_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1538,7974,ngx_conf_set_bitmask_slot,1,ngx_conf_set_bitmask_slot,"char* ngx_conf_set_bitmask_slot (ngx_conf_t*,ngx_command_t*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_set_bitmask_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_uint_t          *np, i, m;
    ngx_str_t           *value;
    ngx_conf_bitmask_t  *mask;


    np = (ngx_uint_t *) (p + cmd->offset);
    value = cf->args->elts;
    mask = cmd->post;

    for (i = 1; i < cf->args->nelts; i++) {
        for (m = 0; mask[m].name.len != 0; m++) {

            if (mask[m].name.len != value[i].len
                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)
            {
                continue;
            }

            if (*np & mask[m].mask) {
                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                                   ""duplicate value \""%s\"""", value[i].data);

            } else {
                *np |= mask[m].mask;
            }

            break;
        }

        if (mask[m].name.len == 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%s\"""", value...",1388.0,1431.0,1.0,1.0,44.0,44,12,38,13,0,3,8,12,1,3,,0,1,6,3,3,char*
1539,40743,err,3,ngx_regex_compile_t.err,,core\ngx_regex.h,err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1540,372520,recv_buffer_size,3,ngx_http_v2_main_conf_t.recv_buffer_size,,http\v2\ngx_http_v2_module.h,recv_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1541,405288,ngx_execute,1,ngx_execute,"ngx_pid_t ngx_execute (ngx_cycle_t*,ngx_exec_ctx_t*)",os\win32\ngx_process.c,"ngx_pid_t
ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)
{
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;

    ngx_memzero(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    ngx_memzero(&pi, sizeof(PROCESS_INFORMATION));

    if (CreateProcess(ctx->path, ctx->args,
                      NULL, NULL, 0, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)
        == 0)
    {
        ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_errno,
                      ""CreateProcess(\""%s\"") failed"", ngx_argv[0]);

        return 0;
    }

    ctx->child = pi.hProcess;

    if (CloseHandle(pi.hThread) == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CloseHandle(pi.hThread) failed"");
    }

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                  ""start %s process %P"", ctx->name, pi.dwProcessId);

    return pi.dwProcessId;
}",206.0,238.0,1.0,1.0,33.0,1,1,5,4,1,2,1,1,0,1,,0,1,4,2,2,ngx_pid_t
1542,372521,recv_buffer,3,ngx_http_v2_main_conf_t.recv_buffer,,http\v2\ngx_http_v2_module.h,*recv_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1543,40742,names,3,ngx_regex_compile_t.names,,core\ngx_regex.h,*names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1544,93996,ngx_event_pipe,1,ngx_event_pipe,"ngx_int_t ngx_event_pipe (ngx_event_pipe_t*,ngx_int_t)",event\ngx_event_pipe.c,"ngx_int_t
ngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write)
{
    ngx_int_t     rc;
    ngx_uint_t    flags;
    ngx_event_t  *rev, *wev;

    for ( ;; ) {
        if (do_write) {
            p->log->action = ""sending to client"";

            rc = ngx_event_pipe_write_to_downstream(p);

            if (rc == NGX_ABORT) {
                return NGX_ABORT;
            }

            if (rc == NGX_BUSY) {
                return NGX_OK;
            }
        }

        p->read = 0;
        p->upstream_blocked = 0;

        p->log->action = ""reading upstream"";

        if (ngx_event_pipe_read_upstream(p) == NGX_ABORT) {
            return NGX_ABORT;
        }

        if (!p->read && !p->upstream_blocked) {
            break;
        }

        do_write = 1;
    }

    if (p->upstream->fd != (ngx_socket_t) -1) {
        rev = p->upstream->read;

        flags = (rev->eof || rev->error) ? NGX_CLOSE_EVENT : 0;

        if (ngx_handle_read_event(rev, flags) != NGX_OK) {
            re...",22.0,98.0,1.0,1.0,77.0,61,9,52,11,0,4,16,30,3,4,,0,4,4,2,2,ngx_int_t
1545,372524,pool_size,3,ngx_http_v2_srv_conf_t.pool_size,,http\v2\ngx_http_v2_module.h,pool_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1546,61230,ngx_slprintf,1,ngx_slprintf,"ANY ngx_slprintf (u_char*,u_char*,char*...)",core\ngx_string.c,"ngx_slprintf(u_char *buf, u_char *last, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, last, fmt, args);
    va_end(args);

    return p;
}",149.0,159.0,1.0,1.0,11.0,1,1,9,5,3,1,1,1,0,1,,0,1,6,3,3,ANY
1547,372526,concurrent_pushes,3,ngx_http_v2_srv_conf_t.concurrent_pushes,,http\v2\ngx_http_v2_module.h,concurrent_pushes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1548,372525,concurrent_streams,3,ngx_http_v2_srv_conf_t.concurrent_streams,,http\v2\ngx_http_v2_module.h,concurrent_streams,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1549,40746,regex,3,ngx_regex_elt_t.regex,,core\ngx_regex.h,*regex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1550,372530,preread_size,3,ngx_http_v2_srv_conf_t.preread_size,,http\v2\ngx_http_v2_module.h,preread_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1551,372531,streams_index_mask,3,ngx_http_v2_srv_conf_t.streams_index_mask,,http\v2\ngx_http_v2_module.h,streams_index_mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1552,40747,name,3,ngx_regex_elt_t.name,,core\ngx_regex.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1553,3895,ngx_chain_update_chains,1,ngx_chain_update_chains,"void ngx_chain_update_chains (ngx_pool_t*,ngx_chain_t**,ngx_chain_t**,ngx_chain_t**,ngx_buf_tag_t)",core\ngx_buf.c,"void
ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free, ngx_chain_t **busy,
    ngx_chain_t **out, ngx_buf_tag_t tag)
{
    ngx_chain_t  *cl;

    if (*out) {
        if (*busy == NULL) {
            *busy = *out;

        } else {
            for (cl = *busy; cl->next; cl = cl->next) { /* void */ }

            cl->next = *out;
        }

        *out = NULL;
    }

    while (*busy) {
        cl = *busy;

        if (ngx_buf_size(cl->buf) != 0) {
            break;
        }

        if (cl->buf->tag != tag) {
            *busy = cl->next;
            ngx_free_chain(p, cl);
            continue;
        }

        cl->buf->pos = cl->buf->start;
        cl->buf->last = cl->buf->start;

        *busy = cl->next;
        cl->next = *free;
        *free = cl;
    }
}",184.0,223.0,1.0,1.0,40.0,37,5,27,7,5,0,8,9,0,0,,0,0,10,5,5,void
1554,130878,ngx_http_geoip_addr,1,ngx_http_geoip_addr,"u_long ngx_http_geoip_addr (ngx_http_request_t*,ngx_http_geoip_conf_t*)",http\modules\ngx_http_geoip_module.c,"static u_long
ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)
{
    ngx_addr_t           addr;
    ngx_array_t         *xfwd;
    struct sockaddr_in  *sin;

    addr.sockaddr = r->connection->sockaddr;
    addr.socklen = r->connection->socklen;
    /* addr.name = r->connection->addr_text; */

    xfwd = &r->headers_in.x_forwarded_for;

    if (xfwd->nelts > 0 && gcf->proxies != NULL) {
        (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,
                                           gcf->proxies, gcf->proxy_recursive);
    }

#if (NGX_HAVE_INET6)

    if (addr.sockaddr->sa_family == AF_INET6) {
        u_char           *p;
        in_addr_t         inaddr;
        struct in6_addr  *inaddr6;

        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
         ...",239.0,286.0,1.0,1.0,48.0,29,8,21,8,0,6,3,3,2,1,,0,5,4,2,2,u_long
1555,24382,ngx_log_debug_core,1,ngx_log_debug_core,"ANY ngx_log_debug_core (ngx_log_t*,ngx_err_t,char*...)",core\ngx_log.c,"ngx_log_debug_core(ngx_log_t *log, ngx_err_t err, const char *fmt, ...)
{
    va_list  args;

    va_start(args, fmt);
    ngx_log_error_core(NGX_LOG_DEBUG, log, err, fmt, args);
    va_end(args);
}",230.0,237.0,1.0,1.0,8.0,0,0,8,5,0,1,1,1,0,1,,0,0,6,3,3,ANY
1556,16195,ngx_create_hashed_filename,1,ngx_create_hashed_filename,"void ngx_create_hashed_filename (ngx_path_t*,u_char*,size_t)",core\ngx_file.c,"void
ngx_create_hashed_filename(ngx_path_t *path, u_char *file, size_t len)
{
    size_t      i, level;
    ngx_uint_t  n;

    i = path->name.len + 1;

    file[path->name.len + path->len]  = '/';

    for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
        level = path->level[n];

        if (level == 0) {
            break;
        }

        len -= level;
        file[i - 1] = '/';
        ngx_memcpy(&file[i], &file[len], level);
        i += level + 1;
    }
}",240.0,262.0,1.0,1.0,23.0,26,11,23,7,1,4,4,4,0,0,,0,4,6,3,3,void
1557,61253,ngx_vslprintf,1,ngx_vslprintf,"u_char ngx_vslprintf (u_char*,u_char*,char*,va_list)",core\ngx_string.c,"u_char *
ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)
{
    u_char                *p, zero;
    int                    d;
    double                 f;
    size_t                 len, slen;
    int64_t                i64;
    uint64_t               ui64, frac;
    ngx_msec_t             ms;
    ngx_uint_t             width, sign, hex, max_width, frac_width, scale, n;
    ngx_str_t             *v;
    ngx_variable_value_t  *vv;

    while (*fmt && buf < last) {

        /*
         * ""buf < last"" means that we could copy at least one character:
         * the plain character, ""%%"", ""%c"", and minus without the checking
         */

        if (*fmt == '%') {

            i64 = 0;
            ui64 = 0;

            zero = (u_char) ((*++fmt == '0') ? '0' : ' ');
            width = 0;
            sign = 1;
            hex = 0;
            max_width = 0;
            frac_width = 0;
            slen = (size_t) -1;

            while (*fmt >= '0' && *fmt <= '9') ...",162.0,490.0,1.0,1.0,329.0,176,19,193,40,8,7,58,105,0,3,,0,7,8,4,4,u_char
1558,32591,fd,3,ngx_open_file_info_t.fd,,core\ngx_open_file_cache.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1559,32592,uniq,3,ngx_open_file_info_t.uniq,,core\ngx_open_file_cache.h,uniq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1560,32593,mtime,3,ngx_open_file_info_t.mtime,,core\ngx_open_file_cache.h,mtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1561,32594,size,3,ngx_open_file_info_t.size,,core\ngx_open_file_cache.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1562,24403,ngx_log_abort,1,ngx_log_abort,"ANY ngx_log_abort (ngx_err_t,char*...)",core\ngx_log.c,"ngx_log_abort(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;
    u_char    errstr[NGX_MAX_CONF_ERRSTR];

    va_start(args, fmt);
    p = ngx_vsnprintf(errstr, sizeof(errstr) - 1, fmt, args);
    va_end(args);

    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,
                  ""%*s"", p - errstr, errstr);
}",243.0,255.0,1.0,1.0,13.0,5,4,14,7,0,1,1,1,0,1,,0,0,4,2,2,ANY
1563,32596,directio,3,ngx_open_file_info_t.directio,,core\ngx_open_file_cache.h,directio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1564,32597,read_ahead,3,ngx_open_file_info_t.read_ahead,,core\ngx_open_file_cache.h,read_ahead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1565,32598,err,3,ngx_open_file_info_t.err,,core\ngx_open_file_cache.h,err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
1566,32599,failed,3,ngx_open_file_info_t.failed,,core\ngx_open_file_cache.h,*failed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1567,32600,valid,3,ngx_open_file_info_t.valid,,core\ngx_open_file_cache.h,valid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1568,69465,ngx_time_sigsafe_update,1,ngx_time_sigsafe_update,void ngx_time_sigsafe_update (void),core\ngx_times.c,"void
ngx_time_sigsafe_update(void)
{
    u_char          *p, *p2;
    ngx_tm_t         tm;
    time_t           sec;
    ngx_time_t      *tp;
    struct timeval   tv;

    if (!ngx_trylock(&ngx_time_lock)) {
        return;
    }

    ngx_gettimeofday(&tv);

    sec = tv.tv_sec;

    tp = &cached_time[slot];

    if (tp->sec == sec) {
        ngx_unlock(&ngx_time_lock);
        return;
    }

    if (slot == NGX_TIME_SLOTS - 1) {
        slot = 0;
    } else {
        slot++;
    }

    tp = &cached_time[slot];

    tp->sec = 0;

    ngx_gmtime(sec + cached_gmtoff * 60, &tm);

    p = &cached_err_log_time[slot][0];

    (void) ngx_sprintf(p, ""%4d/%02d/%02d %02d:%02d:%02d"",
                       tm.ngx_tm_year, tm.ngx_tm_mon,
                       tm.ngx_tm_mday, tm.ngx_tm_hour,
                       tm.ngx_tm_min, tm.ngx_tm_sec);

    p2 = &cached_syslog_time[slot][0];

    (void) ngx_sprintf(p2, ""%s %2d %02d:%02d:%02d"",
                       months[tm.ngx_tm_mon - 1], tm.ngx_tm...",222.0,277.0,1.0,16.0,56.0,50,11,44,15,0,25,4,4,3,4,,0,21,2,1,1,void
1569,32601,min_uses,3,ngx_open_file_info_t.min_uses,,core\ngx_open_file_cache.h,min_uses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1570,32595,fs_size,3,ngx_open_file_info_t.fs_size,,core\ngx_open_file_cache.h,fs_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1571,261980,ngx_http_set_exten,1,ngx_http_set_exten,void ngx_http_set_exten (ngx_http_request_t*),http\ngx_http_core_module.c,"void
ngx_http_set_exten(ngx_http_request_t *r)
{
    ngx_int_t  i;

    ngx_str_null(&r->exten);

    for (i = r->uri.len - 1; i > 1; i--) {
        if (r->uri.data[i] == '.' && r->uri.data[i - 1] != '/') {

            r->exten.len = r->uri.len - i - 1;
            r->exten.data = &r->uri.data[i + 1];

            return;

        } else if (r->uri.data[i] == '/') {
            return;
        }
    }

    return;
}",1631.0,1652.0,1.0,1.0,22.0,32,11,14,2,2,0,3,4,0,0,,0,0,2,1,1,void
1572,32605,test_only,3,ngx_open_file_info_t.test_only,,core\ngx_open_file_cache.h,test_only:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1573,32604,test_dir,3,ngx_open_file_info_t.test_dir,,core\ngx_open_file_cache.h,test_dir:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1574,405343,ngx_init_signals,1,ngx_init_signals,ngx_int_t ngx_init_signals (ngx_log_t*),os\unix\ngx_process.c,"ngx_int_t
ngx_init_signals(ngx_log_t *log)
{
    ngx_signal_t      *sig;
    struct sigaction   sa;

    for (sig = signals; sig->signo != 0; sig++) {
        ngx_memzero(&sa, sizeof(struct sigaction));

        if (sig->handler) {
            sa.sa_sigaction = sig->handler;
            sa.sa_flags = SA_SIGINFO;

        } else {
            sa.sa_handler = SIG_IGN;
        }

        sigemptyset(&sa.sa_mask);
        if (sigaction(sig->signo, &sa, NULL) == -1) {
#if (NGX_VALGRIND)
            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                          ""sigaction(%s) failed, ignored"", sig->signame);
#else
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ""sigaction(%s) failed"", sig->signame);
            return NGX_ERROR;
#endif
        }
    }

    return NGX_OK;
}",284.0,315.0,1.0,1.0,32.0,18,8,20,11,1,4,4,6,2,1,,0,3,2,1,1,ngx_int_t
1575,32607,errors,3,ngx_open_file_info_t.errors,,core\ngx_open_file_cache.h,errors:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1576,32608,events,3,ngx_open_file_info_t.events,,core\ngx_open_file_cache.h,events:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1577,32609,is_dir,3,ngx_open_file_info_t.is_dir,,core\ngx_open_file_cache.h,is_dir:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1578,32610,is_file,3,ngx_open_file_info_t.is_file,,core\ngx_open_file_cache.h,is_file:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1579,32611,is_link,3,ngx_open_file_info_t.is_link,,core\ngx_open_file_cache.h,is_link:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1580,32612,is_exec,3,ngx_open_file_info_t.is_exec,,core\ngx_open_file_cache.h,is_exec:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1581,32613,is_directio,3,ngx_open_file_info_t.is_directio,,core\ngx_open_file_cache.h,is_directio:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1582,413553,ngx_read_fd,1,ngx_read_fd,"ssize_t ngx_read_fd (ngx_fd_t,void*,size_t)",os\win32\ngx_files.c,"ssize_t
ngx_read_fd(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    if (ReadFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",164.0,174.0,1.0,1.0,11.0,4,4,6,5,2,0,2,2,0,0,,0,0,6,3,3,ssize_t
1583,298871,ngx_http_set_complex_value_slot,1,ngx_http_set_complex_value_slot,"char* ngx_http_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http_script.c,"char *
ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t                          *value;
    ngx_http_complex_value_t          **cv;
    ngx_http_compile_complex_value_t    ccv;

    cv = (ngx_http_complex_value_t **) (p + cmd->offset);

    if (*cv != NULL) {
        return ""is duplicate"";
    }

    *cv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));
    if (*cv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = *cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",242.0,275.0,1.0,1.0,34.0,29,11,27,13,1,5,4,4,1,2,,0,5,6,3,3,char*
1584,85880,ngx_ssl_ciphers,1,ngx_ssl_ciphers,"ngx_int_t ngx_ssl_ciphers (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_uint_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,
    ngx_uint_t prefer_server_ciphers)
{
    if (SSL_CTX_set_cipher_list(ssl->ctx, (char *) ciphers->data) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_cipher_list(\""%V\"") failed"",
                      ciphers);
        return NGX_ERROR;
    }

    if (prefer_server_ciphers) {
        SSL_CTX_set_options(ssl->ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
    }

#if (OPENSSL_VERSION_NUMBER < 0x10100001L && !defined LIBRESSL_VERSION_NUMBER)
    /* a temporary 512-bit RSA key is required for export versions of MSIE */
    SSL_CTX_set_tmp_rsa_callback(ssl->ctx, ngx_ssl_rsa512_key_callback);
#endif

    return NGX_OK;
}",847.0,868.0,1.0,1.0,22.0,7,3,11,7,0,2,3,3,1,1,,0,1,8,4,4,ngx_int_t
1585,24440,ngx_log_stderr,1,ngx_log_stderr,"ANY ngx_log_stderr (ngx_err_t,char*...)",core\ngx_log.c,"ngx_log_stderr(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p, *last;
    va_list   args;
    u_char    errstr[NGX_MAX_ERROR_STR];

    last = errstr + NGX_MAX_ERROR_STR;

    p = ngx_cpymem(errstr, ""nginx: "", 7);

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (p > last - NGX_LINEFEED_SIZE) {
        p = last - NGX_LINEFEED_SIZE;
    }

    ngx_linefeed(p);

    (void) ngx_write_console(ngx_stderr, errstr, p - errstr);
}",259.0,284.0,1.0,1.0,26.0,11,5,29,9,4,3,3,3,0,3,,0,2,4,2,2,ANY
1586,335745,ngx_http_v2_push_stream,1,ngx_http_v2_push_stream,"ngx_http_v2_stream_t ngx_http_v2_push_stream (ngx_http_v2_stream_t*,ngx_str_t*)",http\v2\ngx_http_v2.c,"ngx_http_v2_stream_t *
ngx_http_v2_push_stream(ngx_http_v2_stream_t *parent, ngx_str_t *path)
{
    ngx_int_t                     rc;
    ngx_str_t                     value;
    ngx_pool_t                   *pool;
    ngx_uint_t                    index;
    ngx_table_elt_t             **h;
    ngx_connection_t             *fc;
    ngx_http_request_t           *r;
    ngx_http_v2_node_t           *node;
    ngx_http_v2_stream_t         *stream;
    ngx_http_v2_srv_conf_t       *h2scf;
    ngx_http_v2_connection_t     *h2c;
    ngx_http_v2_parse_header_t   *header;

    h2c = parent->connection;

    pool = ngx_create_pool(1024, h2c->connection->log);
    if (pool == NULL) {
        goto rst_stream;
    }

    node = ngx_http_v2_get_node_by_id(h2c, h2c->last_push, 1);

    if (node == NULL) {
        ngx_destroy_pool(pool);
        goto rst_stream;
    }

    stream = ngx_http_v2_create_stream(h2c, 1);
    if (stream == NULL) {

        if (node->parent == NULL) {
            h2scf ...",2534.0,2688.0,1.0,20.0,155.0,135,14,129,28,0,32,25,20,4,16,,0,25,4,2,2,ngx_http_v2_stream_t
1587,32642,sentinel,3,ngx_open_file_cache_t.sentinel,,core\ngx_open_file_cache.h,sentinel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1588,40833,ngx_resolve_name_locked,1,ngx_resolve_name_locked,"ngx_int_t ngx_resolve_name_locked (ngx_resolver_t*,ngx_resolver_ctx_t*,ngx_str_t*)",core\ngx_resolver.c,"static ngx_int_t
ngx_resolve_name_locked(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx,
    ngx_str_t *name)
{
    uint32_t              hash;
    ngx_int_t             rc;
    ngx_str_t             cname;
    ngx_uint_t            i, naddrs;
    ngx_queue_t          *resend_queue, *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_ctx_t   *next, *last;
    ngx_resolver_addr_t  *addrs;
    ngx_resolver_node_t  *rn;

    ngx_strlow(name->data, name->data, name->len);

    hash = ngx_crc32_short(name->data, name->len);

    if (ctx->service.len) {
        rn = ngx_resolver_lookup_srv(r, name, hash);

        tree = &r->srv_rbtree;
        resend_queue = &r->srv_resend_queue;
        expire_queue = &r->srv_expire_queue;

    } else {
        rn = ngx_resolver_lookup_name(r, name, hash);

        tree = &r->name_rbtree;
        resend_queue = &r->name_resend_queue;
        expire_queue = &r->name_expire_queue;
    }

    if (rn) {

        /* ctx can be a list after NGX_RESOLV...",580.0,902.0,1.0,1.0,323.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1589,32643,expire_queue,3,ngx_open_file_cache_t.expire_queue,,core\ngx_open_file_cache.h,expire_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1590,32644,current,3,ngx_open_file_cache_t.current,,core\ngx_open_file_cache.h,current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1591,32645,max,3,ngx_open_file_cache_t.max,,core\ngx_open_file_cache.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1592,32646,inactive,3,ngx_open_file_cache_t.inactive,,core\ngx_open_file_cache.h,inactive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1593,32641,rbtree,3,ngx_open_file_cache_t.rbtree,,core\ngx_open_file_cache.h,rbtree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1594,40840,ngx_resolver_expire,1,ngx_resolver_expire,"void ngx_resolver_expire (ngx_resolver_t*,ngx_rbtree_t*,ngx_queue_t*)",core\ngx_resolver.c,"static void
ngx_resolver_expire(ngx_resolver_t *r, ngx_rbtree_t *tree, ngx_queue_t *queue)
{
    time_t                now;
    ngx_uint_t            i;
    ngx_queue_t          *q;
    ngx_resolver_node_t  *rn;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolver expire"");

    now = ngx_time();

    for (i = 0; i < 2; i++) {
        if (ngx_queue_empty(queue)) {
            return;
        }

        q = ngx_queue_last(queue);

        rn = ngx_queue_data(q, ngx_resolver_node_t, queue);

        if (now <= rn->expire) {
            return;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,
                       ""resolver expire \""%*s\"""", (size_t) rn->nlen, rn->name);

        ngx_queue_remove(q);

        ngx_rbtree_delete(tree, &rn->node);

        ngx_resolver_free_node(r, rn);
    }
}",1215.0,1249.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
1595,32649,cache,3,ngx_open_file_cache_cleanup_t.cache,,core\ngx_open_file_cache.h,*cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1596,32650,file,3,ngx_open_file_cache_cleanup_t.file,,core\ngx_open_file_cache.h,*file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1597,32651,min_uses,3,ngx_open_file_cache_cleanup_t.min_uses,,core\ngx_open_file_cache.h,min_uses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1598,32652,log,3,ngx_open_file_cache_cleanup_t.log,,core\ngx_open_file_cache.h,*log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1599,40847,ngx_resolver_send_query,1,ngx_resolver_send_query,"ngx_int_t ngx_resolver_send_query (ngx_resolver_t*,ngx_resolver_node_t*)",core\ngx_resolver.c,"static ngx_int_t
ngx_resolver_send_query(ngx_resolver_t *r, ngx_resolver_node_t *rn)
{
    ngx_int_t                   rc;
    ngx_resolver_connection_t  *rec;

    rec = r->connections.elts;
    rec = &rec[rn->last_connection];

    if (rec->log.handler == NULL) {
        rec->log = *r->log;
        rec->log.handler = ngx_resolver_log_error;
        rec->log.data = rec;
        rec->log.action = ""resolving"";
    }

    if (rn->naddrs == (u_short) -1) {
        rc = rn->tcp ? ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen)
                     : ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);

        if (rc != NGX_OK) {
            return rc;
        }
    }

#if (NGX_HAVE_INET6)

    if (rn->query6 && rn->naddrs6 == (u_short) -1) {
        rc = rn->tcp6
                    ? ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen)
                    : ngx_resolver_send_udp_query(r, rec, rn->query6, rn->qlen);

        if (rc != NGX_OK) {
            return rc;...",1252.0,1292.0,1.0,1.0,41.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,ngx_int_t
1600,16276,ngx_create_path,1,ngx_create_path,"ngx_int_t ngx_create_path (ngx_file_t*,ngx_path_t*)",core\ngx_file.c,"ngx_int_t
ngx_create_path(ngx_file_t *file, ngx_path_t *path)
{
    size_t      pos;
    ngx_err_t   err;
    ngx_uint_t  i;

    pos = path->name.len;

    for (i = 0; i < NGX_MAX_PATH_LEVEL; i++) {
        if (path->level[i] == 0) {
            break;
        }

        pos += path->level[i] + 1;

        file->name.data[pos] = '\0';

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, file->log, 0,
                       ""temp file: \""%s\"""", file->name.data);

        if (ngx_create_dir(file->name.data, 0700) == NGX_FILE_ERROR) {
            err = ngx_errno;
            if (err != NGX_EEXIST) {
                ngx_log_error(NGX_LOG_CRIT, file->log, err,
                              ngx_create_dir_n "" \""%s\"" failed"",
                              file->name.data);
                return NGX_ERROR;
            }
        }

        file->name.data[pos] = '/';
    }

    return NGX_OK;
}",265.0,300.0,1.0,1.0,36.0,28,9,25,12,1,3,6,9,1,0,,0,3,4,2,2,ngx_int_t
1601,413605,ngx_write_console,1,ngx_write_console,"ssize_t ngx_write_console (ngx_fd_t,void*,size_t)",os\win32\ngx_files.c,"ssize_t
ngx_write_console(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    (void) CharToOemBuff(buf, buf, size);

    if (WriteFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",190.0,202.0,1.0,1.0,13.0,5,4,9,5,2,0,2,2,0,0,,0,0,6,3,3,ssize_t
1602,85926,ngx_ssl_client_certificate,1,ngx_ssl_client_certificate,"ngx_int_t ngx_ssl_client_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)",event\ngx_event_openssl.c,"ngx_int_t
ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_int_t depth)
{
    STACK_OF(X509_NAME)  *list;

    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);

    SSL_CTX_set_verify_depth(ssl->ctx, depth);

    if (cert->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_load_verify_locations(\""%s\"") failed"",
                      cert->data);
        return NGX_ERROR;
    }

    /*
     * SSL_CTX_load_verify_locations() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

    list = SSL_load_client_CA_file((char *) cert->data);

    if (list == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                    ...",871.0,916.0,1.0,1.0,46.0,20,6,31,12,0,8,5,5,3,3,,0,6,8,4,4,ngx_int_t
1603,327589,hash,3,ngx_http_map_t.hash,,http\ngx_http_variables.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1604,40883,ngx_resolver_create_addr_query,1,ngx_resolver_create_addr_query,"ngx_int_t ngx_resolver_create_addr_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_resolver_addr_t*)",core\ngx_resolver.c,"static ngx_int_t
ngx_resolver_create_addr_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,
    ngx_resolver_addr_t *addr)
{
    u_char               *p, *d;
    size_t                len;
    in_addr_t             inaddr;
    ngx_int_t             n;
    ngx_uint_t            ident;
    ngx_resolver_hdr_t   *query;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (addr->sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        len = sizeof(ngx_resolver_hdr_t)
              + 64 + sizeof("".ip6.arpa."") - 1
              + sizeof(ngx_resolver_qs_t);

        break;
#endif

    default: /* AF_INET */
        len = sizeof(ngx_resolver_hdr_t)
              + sizeof("".255.255.255.255.in-addr.arpa."") - 1
              + sizeof(ngx_resolver_qs_t);
    }

    p = ngx_resolver_alloc(r, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    rn->query = p;
    query = (ngx_resolver_hdr_t *) p;

    ident = ngx_random()...",3825.0,3918.0,1.0,1.0,94.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ngx_int_t
1605,24504,ngx_log_errno,1,ngx_log_errno,"u_char ngx_log_errno (u_char*,u_char*,ngx_err_t)",core\ngx_log.c,"u_char *
ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err)
{
    if (buf > last - 50) {

        /* leave a space for an error code */

        buf = last - 50;
        *buf++ = '.';
        *buf++ = '.';
        *buf++ = '.';
    }

#if (NGX_WIN32)
    buf = ngx_slprintf(buf, last, ((unsigned) err < 0x80000000)
                                       ? "" (%d: "" : "" (%Xd: "", err);
#else
    buf = ngx_slprintf(buf, last, "" (%d: "", err);
#endif

    buf = ngx_strerror(err, buf, last - buf);

    if (buf < last) {
        *buf++ = ')';
    }

    return buf;
}",287.0,314.0,1.0,1.0,28.0,20,6,20,3,4,2,3,3,0,2,,0,2,6,3,3,u_char
1606,20413,ngx_hash_key,1,ngx_hash_key,"ngx_uint_t ngx_hash_key (u_char*,size_t)",core\ngx_hash.c,"ngx_uint_t
ngx_hash_key(u_char *data, size_t len)
{
    ngx_uint_t  i, key;

    key = 0;

    for (i = 0; i < len; i++) {
        key = ngx_hash(key, data[i]);
    }

    return key;
}",630.0,642.0,1.0,1.0,13.0,5,3,9,4,3,0,2,2,0,0,,0,0,4,2,2,ngx_uint_t
1607,270269,phase_engine,3,ngx_http_core_main_conf_t.phase_engine,,http\ngx_http_core_module.h,phase_engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1608,262078,ngx_http_set_etag,1,ngx_http_set_etag,ngx_int_t ngx_http_set_etag (ngx_http_request_t*),http\ngx_http_core_module.c,"ngx_int_t
ngx_http_set_etag(ngx_http_request_t *r)
{
    ngx_table_elt_t           *etag;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!clcf->etag) {
        return NGX_OK;
    }

    etag = ngx_list_push(&r->headers_out.headers);
    if (etag == NULL) {
        return NGX_ERROR;
    }

    etag->hash = 1;
    ngx_str_set(&etag->key, ""ETag"");

    etag->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);
    if (etag->value.data == NULL) {
        etag->hash = 0;
        return NGX_ERROR;
    }

    etag->value.len = ngx_sprintf(etag->value.data, ""\""%xT-%xO\"""",
                                  r->headers_out.last_modified_time,
                                  r->headers_out.content_length_n)
                      - etag->value.data;

    r->headers_out.etag = etag;

    return NGX_OK;
}",1655.0,1689.0,1.0,1.0,35.0,38,8,28,9,1,12,4,4,1,3,,0,12,2,1,1,ngx_int_t
1609,270271,variables_hash,3,ngx_http_core_main_conf_t.variables_hash,,http\ngx_http_core_module.h,variables_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1610,270272,variables,3,ngx_http_core_main_conf_t.variables,,http\ngx_http_core_module.h,variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1611,270273,prefix_variables,3,ngx_http_core_main_conf_t.prefix_variables,,http\ngx_http_core_module.h,prefix_variables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1612,8131,ngx_conf_deprecated,1,ngx_conf_deprecated,"char* ngx_conf_deprecated (ngx_conf_t*,void*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_deprecated(ngx_conf_t *cf, void *post, void *data)
{
    ngx_conf_deprecated_t  *d = post;

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""the \""%s\"" directive is deprecated, ""
                       ""use the \""%s\"" directive instead"",
                       d->old_name, d->new_name);

    return NGX_CONF_OK;
}",1445.0,1456.0,1.0,1.0,12.0,3,2,7,5,0,3,1,1,0,1,,0,2,6,3,3,char*
1613,413637,ngx_win32_rename_file,1,ngx_win32_rename_file,"ngx_err_t ngx_win32_rename_file (ngx_str_t*,ngx_str_t*,ngx_log_t*)",os\win32\ngx_files.c,"ngx_err_t
ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)
{
    u_char             *name;
    ngx_err_t           err;
    ngx_uint_t          collision;
    ngx_atomic_uint_t   num;

    name = ngx_alloc(to->len + 1 + NGX_ATOMIC_T_LEN + 1 + sizeof(""DELETE""),
                     log);
    if (name == NULL) {
        return NGX_ENOMEM;
    }

    ngx_memcpy(name, to->data, to->len);

    collision = 0;

    /* mutex_lock() (per cache or single ?) */

    for ( ;; ) {
        num = ngx_next_temp_number(collision);

        ngx_sprintf(name + to->len, "".%0muA.DELETE%Z"", num);

        if (MoveFile((const char *) to->data, (const char *) name) != 0) {
            break;
        }

        collision = 1;

        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,
                      ""MoveFile() \""%s\"" to \""%s\"" failed"", to->data, name);
    }

    if (MoveFile((const char *) from->data, (const char *) to->data) == 0) {
        err = ngx_errno;

    } else {
        err ...",205.0,257.0,1.0,1.0,53.0,28,7,35,12,0,13,7,7,3,5,,0,10,6,3,3,ngx_err_t
1614,270277,variables_hash_max_size,3,ngx_http_core_main_conf_t.variables_hash_max_size,,http\ngx_http_core_module.h,variables_hash_max_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1615,401350,ngx_set_file_time,1,ngx_set_file_time,"ngx_int_t ngx_set_file_time (u_char*,ngx_fd_t,time_t)",os\win32\ngx_files.c,"ngx_int_t
ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s)
{
    uint64_t  intervals;
    FILETIME  ft;

    /* 116444736000000000 is commented in src/os/win32/ngx_time.c */

    intervals = s * 10000000 + 116444736000000000;

    ft.dwLowDateTime = (DWORD) intervals;
    ft.dwHighDateTime = (DWORD) (intervals >> 32);

    if (SetFileTime(fd, NULL, NULL, &ft) != 0) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",305.0,323.0,1.0,1.0,19.0,15,6,9,5,2,0,2,2,0,0,,0,0,6,3,3,ngx_int_t
1616,270279,variables_keys,3,ngx_http_core_main_conf_t.variables_keys,,http\ngx_http_core_module.h,*variables_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1617,270280,ports,3,ngx_http_core_main_conf_t.ports,,http\ngx_http_core_module.h,*ports,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1618,40902,ngx_resolver_resend_empty,1,ngx_resolver_resend_empty,ngx_uint_t ngx_resolver_resend_empty (ngx_resolver_t*),core\ngx_resolver.c,"static ngx_uint_t
ngx_resolver_resend_empty(ngx_resolver_t *r)
{
    return ngx_queue_empty(&r->name_resend_queue)
           && ngx_queue_empty(&r->srv_resend_queue)
#if (NGX_HAVE_INET6)
           && ngx_queue_empty(&r->addr6_resend_queue)
#endif
           && ngx_queue_empty(&r->addr_resend_queue);
}",1540.0,1549.0,1.0,1.0,10.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,ngx_uint_t
1619,225227,hash,3,ngx_http_ssi_main_conf_t.hash,,http\modules\ngx_http_ssi_filter_module.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1620,270278,variables_hash_bucket_size,3,ngx_http_core_main_conf_t.variables_hash_bucket_size,,http\ngx_http_core_module.h,variables_hash_bucket_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1621,225231,buf,3,ngx_http_ssi_ctx_t.buf,,http\modules\ngx_http_ssi_filter_module.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1622,225232,pos,3,ngx_http_ssi_ctx_t.pos,,http\modules\ngx_http_ssi_filter_module.h,*pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1623,298961,ngx_http_set_complex_value_size_slot,1,ngx_http_set_complex_value_size_slot,"char* ngx_http_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)",http\ngx_http_script.c,"char *
ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    char                      *rv;
    ngx_http_complex_value_t  *cv;

    rv = ngx_http_set_complex_value_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    cv = *(ngx_http_complex_value_t **) (p + cmd->offset);

    if (cv->lengths) {
        return NGX_CONF_OK;
    }

    cv->u.size = ngx_parse_size(&cv->value);
    if (cv->u.size == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",278.0,305.0,1.0,1.0,28.0,18,9,19,8,0,4,4,4,1,2,,0,4,6,3,3,char*
1624,225233,copy_start,3,ngx_http_ssi_ctx_t.copy_start,,http\modules\ngx_http_ssi_filter_module.h,*copy_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1625,225235,key,3,ngx_http_ssi_ctx_t.key,,http\modules\ngx_http_ssi_filter_module.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1626,225236,command,3,ngx_http_ssi_ctx_t.command,,http\modules\ngx_http_ssi_filter_module.h,command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1627,225237,params,3,ngx_http_ssi_ctx_t.params,,http\modules\ngx_http_ssi_filter_module.h,params,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1628,225234,copy_end,3,ngx_http_ssi_ctx_t.copy_end,,http\modules\ngx_http_ssi_filter_module.h,*copy_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1629,225239,params_array,3,ngx_http_ssi_ctx_t.params_array,,http\modules\ngx_http_ssi_filter_module.h,params_array[NGX_HTTP_SSI_PARAMS_N],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1630,225240,in,3,ngx_http_ssi_ctx_t.in,,http\modules\ngx_http_ssi_filter_module.h,*in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1631,225241,out,3,ngx_http_ssi_ctx_t.out,,http\modules\ngx_http_ssi_filter_module.h,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1632,225242,last_out,3,ngx_http_ssi_ctx_t.last_out,,http\modules\ngx_http_ssi_filter_module.h,**last_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1633,225243,busy,3,ngx_http_ssi_ctx_t.busy,,http\modules\ngx_http_ssi_filter_module.h,*busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1634,225244,free,3,ngx_http_ssi_ctx_t.free,,http\modules\ngx_http_ssi_filter_module.h,*free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1635,20444,ngx_hash_key_lc,1,ngx_hash_key_lc,"ngx_uint_t ngx_hash_key_lc (u_char*,size_t)",core\ngx_hash.c,"ngx_uint_t
ngx_hash_key_lc(u_char *data, size_t len)
{
    ngx_uint_t  i, key;

    key = 0;

    for (i = 0; i < len; i++) {
        key = ngx_hash(key, ngx_tolower(data[i]));
    }

    return key;
}",645.0,657.0,1.0,1.0,13.0,5,3,9,4,2,0,2,2,0,0,,0,0,4,2,2,ngx_uint_t
1636,225245,state,3,ngx_http_ssi_ctx_t.state,,http\modules\ngx_http_ssi_filter_module.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1637,225247,saved,3,ngx_http_ssi_ctx_t.saved,,http\modules\ngx_http_ssi_filter_module.h,saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1638,225248,looked,3,ngx_http_ssi_ctx_t.looked,,http\modules\ngx_http_ssi_filter_module.h,looked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1639,225249,value_len,3,ngx_http_ssi_ctx_t.value_len,,http\modules\ngx_http_ssi_filter_module.h,value_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1640,8155,ngx_conf_check_num_bounds,1,ngx_conf_check_num_bounds,"char* ngx_conf_check_num_bounds (ngx_conf_t*,void*,void*)",core\ngx_conf_file.c,"char *
ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data)
{
    ngx_conf_num_bounds_t  *bounds = post;
    ngx_int_t  *np = data;

    if (bounds->high == -1) {
        if (*np >= bounds->low) {
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""value must be equal to or greater than %i"",
                           bounds->low);

        return NGX_CONF_ERROR;
    }

    if (*np >= bounds->low && *np <= bounds->high) {
        return NGX_CONF_OK;
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""value must be between %i and %i"",
                       bounds->low, bounds->high);

    return NGX_CONF_ERROR;
}",1459.0,1486.0,1.0,1.0,28.0,18,8,22,8,0,9,4,5,4,2,,0,7,6,3,3,char*
1641,225251,blocks,3,ngx_http_ssi_ctx_t.blocks,,http\modules\ngx_http_ssi_filter_module.h,*blocks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1642,384988,client_buffer_size,3,ngx_mail_imap_srv_conf_t.client_buffer_size,,mail\ngx_mail_imap_module.h,client_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1643,270307,named_locations,3,ngx_http_core_srv_conf_t.named_locations,,http\ngx_http_core_module.h,**named_locations,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1644,225255,conditional,3,ngx_http_ssi_ctx_t.conditional,,http\modules\ngx_http_ssi_filter_module.h,conditional:2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1645,225256,encoding,3,ngx_http_ssi_ctx_t.encoding,,http\modules\ngx_http_ssi_filter_module.h,encoding:2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1646,225257,block,3,ngx_http_ssi_ctx_t.block,,http\modules\ngx_http_ssi_filter_module.h,block:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1647,225258,output,3,ngx_http_ssi_ctx_t.output,,http\modules\ngx_http_ssi_filter_module.h,output:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1648,225260,wait,3,ngx_http_ssi_ctx_t.wait,,http\modules\ngx_http_ssi_filter_module.h,*wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1649,225262,timefmt,3,ngx_http_ssi_ctx_t.timefmt,,http\modules\ngx_http_ssi_filter_module.h,timefmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1650,225263,errmsg,3,ngx_http_ssi_ctx_t.errmsg,,http\modules\ngx_http_ssi_filter_module.h,errmsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1651,69620,ngx_http_time,1,ngx_http_time,"u_char ngx_http_time (u_char*,time_t)",core\ngx_times.c,"u_char *
ngx_http_time(u_char *buf, time_t t)
{
    ngx_tm_t  tm;

    ngx_gmtime(t, &tm);

    return ngx_sprintf(buf, ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
                       week[tm.ngx_tm_wday],
                       tm.ngx_tm_mday,
                       months[tm.ngx_tm_mon - 1],
                       tm.ngx_tm_year,
                       tm.ngx_tm_hour,
                       tm.ngx_tm_min,
                       tm.ngx_tm_sec);
}",282.0,297.0,1.0,1.0,16.0,11,4,12,5,1,4,1,1,0,2,,0,2,4,2,2,u_char
1652,24565,ngx_log_init,1,ngx_log_init,ngx_log_t ngx_log_init (u_char*),core\ngx_log.c,"ngx_log_t *
ngx_log_init(u_char *prefix)
{
    u_char  *p, *name;
    size_t   nlen, plen;

    ngx_log.file = &ngx_log_file;
    ngx_log.log_level = NGX_LOG_NOTICE;

    name = (u_char *) NGX_ERROR_LOG_PATH;

    /*
     * we use ngx_strlen() here since BCC warns about
     * condition is always false and unreachable code
     */

    nlen = ngx_strlen(name);

    if (nlen == 0) {
        ngx_log_file.fd = ngx_stderr;
        return &ngx_log;
    }

    p = NULL;

#if (NGX_WIN32)
    if (name[1] != ':') {
#else
    if (name[0] != '/') {
#endif

        if (prefix) {
            plen = ngx_strlen(prefix);

        } else {
#ifdef NGX_PREFIX
            prefix = (u_char *) NGX_PREFIX;
            plen = ngx_strlen(prefix);
#else
            plen = 0;
#endif
        }

        if (plen) {
            name = malloc(plen + nlen + 2);
            if (name == NULL) {
                return NULL;
            }

            p = ngx_cpymem(name, prefix, plen);

            if (!ngx_path_sepa...",317.0,400.0,1.0,1.0,84.0,37,12,48,15,1,11,9,15,1,2,,0,10,2,1,1,ngx_log_t
1653,401400,ngx_create_file_mapping,1,ngx_create_file_mapping,ngx_int_t ngx_create_file_mapping (ngx_file_mapping_t*),os\win32\ngx_files.c,"ngx_int_t
ngx_create_file_mapping(ngx_file_mapping_t *fm)
{
    LARGE_INTEGER  size;

    fm->fd = ngx_open_file(fm->name, NGX_FILE_RDWR, NGX_FILE_TRUNCATE,
                           NGX_FILE_DEFAULT_ACCESS);

    if (fm->fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", fm->name);
        return NGX_ERROR;
    }

    fm->handle = NULL;

    size.QuadPart = fm->size;

    if (SetFilePointerEx(fm->fd, size, NULL, FILE_BEGIN) == 0) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""SetFilePointerEx(\""%s\"", %uz) failed"",
                      fm->name, fm->size);
        goto failed;
    }

    if (SetEndOfFile(fm->fd) == 0) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""SetEndOfFile() \""%s\"" failed"", fm->name);
        goto failed;
    }

    fm->handle = CreateFileMapping(fm->fd, NULL, PAGE_READWRITE,
                                ...",326.0,394.0,1.0,1.0,69.0,23,6,32,15,0,18,6,5,5,3,,0,16,2,1,1,ngx_int_t
1654,20476,ngx_hash_strlow,1,ngx_hash_strlow,"ngx_uint_t ngx_hash_strlow (u_char*,u_char*,size_t)",core\ngx_hash.c,"ngx_uint_t
ngx_hash_strlow(u_char *dst, u_char *src, size_t n)
{
    ngx_uint_t  key;

    key = 0;

    while (n--) {
        *dst = ngx_tolower(*src);
        key = ngx_hash(key, *dst);
        dst++;
        src++;
    }

    return key;
}",660.0,675.0,1.0,1.0,16.0,9,4,10,4,5,0,2,2,0,0,,0,0,6,3,3,ngx_uint_t
1655,294909,rest,3,ngx_http_request_body_t.rest,,http\ngx_http_request.h,rest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1656,270334,family,3,ngx_http_conf_port_t.family,,http\ngx_http_core_module.h,family,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1657,270335,port,3,ngx_http_conf_port_t.port,,http\ngx_http_core_module.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
