,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,139266,GetLinkedBinding,1,node.binding.GetLinkedBinding,void node.binding.GetLinkedBinding (FunctionCallbackInfo<Value>),node_binding.cc,"void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = ...",641.0,689.0,1.0,1.0,49.0,55,10,63,17,0,3,5,5,1,0,,0,3,2,1,1,void
1,122915,persistent_,3,v8impl.Reference.persistent_,,js_native_api_v8.hpp,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2,122916,can_be_weak_,3,v8impl.Reference.can_be_weak_,,js_native_api_v8.hpp,can_be_weak_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
3,200742,CreateHeaders,1,node.anonymous_namespace_89.Parser.CreateHeaders,Local<Array> node.anonymous_namespace_89.Parser.CreateHeaders (),node_http_parser.cc,"Local<Array> CreateHeaders() {
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",880.0,890.0,3.0,3.0,11.0,20,8,18,9,0,4,2,2,1,0,,0,4,0,0,0,Local<Array>
4,221239,CreateProperties,1,node.Realm.CreateProperties,void node.Realm.CreateProperties (),node_realm.cc,"void Realm::CreateProperties() {
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BY...",42.0,84.0,1.0,2.0,43.0,83,5,79,15,0,1,1,1,0,1,,0,1,0,0,0,void
5,59,AsyncResource,1,node.AsyncResource.AsyncResource,"ANY node.AsyncResource.AsyncResource (Isolate*,Local<Object>,char*,async_id)",api\async_resource.cc,"AsyncResource::AsyncResource(Isolate* isolate,
                             Local<Object> resource,
                             const char* name,
                             async_id trigger_async_id)
    : env_(Environment::GetCurrent(isolate)),
      resource_(isolate, resource) {
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",14.0,23.0,1.0,1.0,10.0,1,1,6,6,0,2,1,1,0,0,,0,2,8,4,4,ANY
6,90175,schedulePauseOnNextStatement,1,node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement,void node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement (ANY),inspector_agent.cc,"void schedulePauseOnNextStatement(const std::string& reason) {
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",270.0,273.0,3.0,3.0,4.0,4,2,5,3,0,1,1,1,0,0,,0,1,2,1,1,void
7,76,~AsyncResource,1,node.AsyncResource.~AsyncResource,ANY node.AsyncResource.~AsyncResource (),api\async_resource.cc,"AsyncResource::~AsyncResource() {
  EmitAsyncDestroy(env_, async_context_);
}",25.0,27.0,1.0,1.0,3.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
8,83,MakeCallback,1,node.AsyncResource.MakeCallback,"MaybeLocal<Value> node.AsyncResource.MakeCallback (Local<Function>,int,Local<Value>*)",api\async_resource.cc,"MaybeLocal<Value> AsyncResource::MakeCallback(Local<String> symbol,
                                              int argc,
                                              Local<Value>* argv) {
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",45.0,51.0,1.0,1.0,7.0,2,2,6,6,0,3,1,1,0,1,,0,2,6,3,3,MaybeLocal<Value>
9,90197,preventShutdown,1,node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown,bool node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown (),inspector_agent.cc,"bool preventShutdown() {
    return prevent_shutdown_;
  }",275.0,277.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
10,241752,FromFilePath,1,node.url.FromFilePath,string node.url.FromFilePath (ANY),node_url.cc,"std::string FromFilePath(const std::string_view file_path) {
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",378.0,385.0,1.0,1.0,8.0,9,6,11,4,2,0,3,4,0,0,,0,0,2,1,1,string
11,82010,persistent_,3,node.heap.JSGraphJSNode.persistent_,,heap_utils.cc,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
12,90203,notifyWaitingForDisconnect,1,node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect,bool node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect (),inspector_agent.cc,"bool notifyWaitingForDisconnect() {
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",279.0,282.0,3.0,3.0,4.0,2,2,3,2,0,3,1,1,0,0,,0,3,0,0,0,bool
13,82017,V8Node,1,node.heap.JSGraph.V8Node,Node node.heap.JSGraph.V8Node (Local<Value>),heap_utils.cc,"Node* V8Node(const Local<Value>& value) override {
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",86.0,93.0,3.0,3.0,8.0,15,8,15,8,0,4,2,2,1,0,,0,4,2,1,1,Node
14,90215,retainingContext,1,node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext,bool node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext (),inspector_agent.cc,"bool retainingContext() {
    return retaining_context_;
  }",284.0,286.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
15,200808,Flush,1,node.anonymous_namespace_90.Parser.Flush,void node.anonymous_namespace_90.Parser.Flush (),node_http_parser.cc,"void Flush() {
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",894.0,917.0,3.0,3.0,24.0,24,7,22,12,0,3,3,3,0,0,,0,3,0,0,0,void
16,102513,Unwrap,1,v8impl.anonymous_namespace_32.Unwrap,"napi_status v8impl.anonymous_namespace_32.Unwrap (napi_env,napi_value,void**,UnwrapAction)",js_native_api_v8.cc,"inline napi_status Unwrap(napi_env env,
                          napi_value js_object,
                          void** result,
                          UnwrapAction action) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust...",319.0,357.0,1.0,2.0,39.0,64,11,78,20,0,10,9,12,1,9,,0,2,8,4,4,napi_status
17,90246,sendMessageToFrontend,1,node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend,void node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend (StringView),inspector_agent.cc,"void sendMessageToFrontend(const StringView& message) {
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",302.0,311.0,3.0,3.0,10.0,9,3,11,7,0,1,2,2,0,0,,0,1,2,1,1,void
18,135303,napi_async_destroy,1,napi_async_destroy,"napi_status napi_async_destroy (napi_env,napi_async_context)",node_api.cc,"napi_status NAPI_CDECL napi_async_destroy(napi_env env,
                                          napi_async_context async_context) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",946.0,957.0,1.0,12.0,12.0,6,6,12,4,0,2,1,1,0,2,,0,0,4,2,2,napi_status
19,146,get_resource,1,node.AsyncResource.get_resource,Local<Object> node.AsyncResource.get_resource (),api\async_resource.cc,"Local<Object> AsyncResource::get_resource() {
  return resource_.Get(env_->isolate());
}",53.0,55.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,Local<Object>
20,82072,AddNode,1,node.heap.JSGraph.AddNode,Node node.heap.JSGraph.AddNode (ANY),heap_utils.cc,"Node* AddNode(std::unique_ptr<Node> node) override {
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",95.0,99.0,3.0,3.0,5.0,4,2,6,4,0,1,1,1,0,0,,0,1,2,1,1,Node
21,159,get_async_id,1,node.AsyncResource.get_async_id,async_id node.AsyncResource.get_async_id (),api\async_resource.cc,"async_id AsyncResource::get_async_id() const {
  return async_context_.async_id;
}",57.0,59.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,async_id
22,167,get_trigger_async_id,1,node.AsyncResource.get_trigger_async_id,async_id node.AsyncResource.get_trigger_async_id (),api\async_resource.cc,"async_id AsyncResource::get_trigger_async_id() const {
  return async_context_.trigger_async_id;
}",61.0,63.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,async_id
23,82095,AddEdge,1,node.heap.JSGraph.AddEdge,"void node.heap.JSGraph.AddEdge (Node*,Node*,char*)",heap_utils.cc,"void AddEdge(Node* from, Node* to, const char* name = nullptr) override {
    edges_[from].insert(std::make_pair(name, to));
  }",101.0,103.0,3.0,3.0,3.0,3,2,5,5,0,1,1,1,0,0,,0,1,6,3,3,void
24,135350,napi_make_callback,1,napi_make_callback,"napi_status napi_make_callback (napi_env,napi_async_context,napi_value,napi_value,size_t,napi_value*,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_make_callback(napi_env env,
                                          napi_async_context async_context,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*...",959.0,1011.0,1.0,12.0,53.0,65,11,85,22,0,12,8,10,0,12,,0,1,14,7,7,napi_status
25,200889,Init,1,node.anonymous_namespace_91.Parser.Init,"void node.anonymous_namespace_91.Parser.Init (llhttp_type_t,uint64_t,uint32_t)",node_http_parser.cc,"void Init(llhttp_type_t type, uint64_t max_http_header_size,
            uint32_t lenient_flags) {
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",920.0,943.0,3.0,3.0,24.0,17,4,22,17,0,14,4,4,0,0,,0,14,6,3,3,void
26,82114,CreateObject,1,node.heap.JSGraph.CreateObject,MaybeLocal<Array> node.heap.JSGraph.CreateObject (),heap_utils.cc,"MaybeLocal<Array> CreateObject() const {
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& ...",105.0,203.0,3.0,3.0,99.0,140,13,162,42,0,19,18,34,9,0,,0,19,0,0,0,MaybeLocal<Array>
27,90328,runtime_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.runtime_agent_,,inspector_agent.cc,runtime_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
28,90329,tracing_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.tracing_agent_,,inspector_agent.cc,tracing_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
29,90330,worker_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.worker_agent_,,inspector_agent.cc,worker_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
30,90331,delegate_,3,node.inspector.anonymous_namespace_17.ChannelImpl.delegate_,,inspector_agent.cc,delegate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
31,90332,session_,3,node.inspector.anonymous_namespace_17.ChannelImpl.session_,,inspector_agent.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
32,90333,node_dispatcher_,3,node.inspector.anonymous_namespace_17.ChannelImpl.node_dispatcher_,,inspector_agent.cc,node_dispatcher_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
33,90334,prevent_shutdown_,3,node.inspector.anonymous_namespace_17.ChannelImpl.prevent_shutdown_,,inspector_agent.cc,prevent_shutdown_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
34,90335,retaining_context_,3,node.inspector.anonymous_namespace_17.ChannelImpl.retaining_context_,,inspector_agent.cc,retaining_context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
35,139493,RegisterBuiltinBindings,1,node.binding.RegisterBuiltinBindings,void node.binding.RegisterBuiltinBindings (),node_binding.cc,"void RegisterBuiltinBindings() {
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",693.0,697.0,1.0,2.0,5.0,0,0,0,0,0,56,1,1,0,0,,0,0,0,0,0,void
36,73973,Win32SymbolDebuggingContext,1,node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext,ANY node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext (),debug_utils.cc,"Win32SymbolDebuggingContext() {
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",153.0,156.0,3.0,3.0,4.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,ANY
37,252,~CallbackScope,1,node.CallbackScope.~CallbackScope,ANY node.CallbackScope.~CallbackScope (),api\callback.cc,"CallbackScope::~CallbackScope() {
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",34.0,38.0,1.0,1.0,5.0,3,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,ANY
38,200958,TrackHeader,1,node.anonymous_namespace_92.Parser.TrackHeader,int node.anonymous_namespace_92.Parser.TrackHeader (size_t),node_http_parser.cc,"int TrackHeader(size_t len) {
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",946.0,953.0,3.0,3.0,8.0,3,3,6,5,0,4,2,2,2,0,,0,4,2,1,1,int
39,73985,~Win32SymbolDebuggingContext,1,node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext,ANY node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext (),debug_utils.cc,"~Win32SymbolDebuggingContext() override {
    USE(SymCleanup(current_process_));
  }",158.0,160.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
40,73993,WrappedSymFromAddr,1,node.Win32SymbolDebuggingContext.WrappedSymFromAddr,NameAndDisplacement node.Win32SymbolDebuggingContext.WrappedSymFromAddr (DWORD64),debug_utils.cc,"NameAndDisplacement WrappedSymFromAddr(DWORD64 dwAddress) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAd...",163.0,191.0,3.0,3.0,29.0,10,5,13,7,0,1,2,2,1,0,,0,1,2,1,1,NameAndDisplacement
41,86281,Call,1,node.inspector.anonymous_namespace_10.CreateObjectRequest.Call,void node.inspector.anonymous_namespace_10.CreateObjectRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",45.0,47.0,3.0,3.0,3.0,1,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
42,131344,flags,3,node.IsolateSettings.flags,,node.hpp,"flags = MESSAGE_LISTENER_WITH_ERROR_LEVEL |
      DETAILED_SOURCE_POSITIONS_FOR_PROFILING",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
43,131345,policy,3,node.IsolateSettings.policy,,node.hpp,policy = v8::MicrotasksPolicy::kExplicit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
44,131346,should_abort_on_uncaught_exception_callback,3,node.IsolateSettings.should_abort_on_uncaught_exception_callback,,node.hpp,should_abort_on_uncaught_exception_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
45,131347,fatal_error_callback,3,node.IsolateSettings.fatal_error_callback,,node.hpp,fatal_error_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
46,131348,prepare_stack_trace_callback,3,node.IsolateSettings.prepare_stack_trace_callback,,node.hpp,prepare_stack_trace_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
47,131349,promise_reject_callback,3,node.IsolateSettings.promise_reject_callback,,node.hpp,promise_reject_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
48,131350,allow_wasm_code_generation_callback,3,node.IsolateSettings.allow_wasm_code_generation_callback,,node.hpp,allow_wasm_code_generation_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
49,131351,modify_code_generation_from_strings_callback,3,node.IsolateSettings.modify_code_generation_from_strings_callback,,node.hpp,modify_code_generation_from_strings_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
50,200979,MaybePause,1,node.anonymous_namespace_93.Parser.MaybePause,int node.anonymous_namespace_93.Parser.MaybePause (),node_http_parser.cc,"int MaybePause() {
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",956.0,964.0,3.0,3.0,9.0,3,3,4,3,0,3,2,2,1,0,,0,3,0,0,0,int
51,86294,object_id_,3,node.inspector.anonymous_namespace_8.CreateObjectRequest.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
52,201004,parser_,3,node.anonymous_namespace_49.Parser.parser_,,node_http_parser.cc,parser_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
53,201005,fields_,3,node.anonymous_namespace_49.Parser.fields_,,node_http_parser.cc,fields_[kMaxHeaderFieldsCount],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
54,201006,values_,3,node.anonymous_namespace_49.Parser.values_,,node_http_parser.cc,values_[kMaxHeaderFieldsCount],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
55,201007,url_,3,node.anonymous_namespace_49.Parser.url_,,node_http_parser.cc,url_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
56,201008,status_message_,3,node.anonymous_namespace_49.Parser.status_message_,,node_http_parser.cc,status_message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
57,201009,num_fields_,3,node.anonymous_namespace_49.Parser.num_fields_,,node_http_parser.cc,num_fields_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
58,201010,num_values_,3,node.anonymous_namespace_49.Parser.num_values_,,node_http_parser.cc,num_values_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
59,86323,Call,1,node.inspector.anonymous_namespace_14.DeleteRequest.Call,void node.inspector.anonymous_namespace_14.DeleteRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",64.0,66.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
60,201012,got_exception_,3,node.anonymous_namespace_49.Parser.got_exception_,,node_http_parser.cc,got_exception_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
61,201011,have_flushed_,3,node.anonymous_namespace_49.Parser.have_flushed_,,node_http_parser.cc,have_flushed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
62,201014,current_buffer_data_,3,node.anonymous_namespace_49.Parser.current_buffer_data_,,node_http_parser.cc,* current_buffer_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
63,201015,headers_completed_,3,node.anonymous_namespace_49.Parser.headers_completed_,,node_http_parser.cc,headers_completed_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
64,201016,pending_pause_,3,node.anonymous_namespace_49.Parser.pending_pause_,,node_http_parser.cc,pending_pause_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
65,201017,header_nread_,3,node.anonymous_namespace_49.Parser.header_nread_,,node_http_parser.cc,header_nread_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
66,201018,max_http_header_size_,3,node.anonymous_namespace_49.Parser.max_http_header_size_,,node_http_parser.cc,max_http_header_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
67,74042,WrappedGetLine,1,node.Win32SymbolDebuggingContext.WrappedGetLine,SymbolInfo node.Win32SymbolDebuggingContext.WrappedGetLine (DWORD64),debug_utils.cc,"SymbolInfo WrappedGetLine(DWORD64 dwAddress) const {
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 re...",193.0,226.0,3.0,3.0,34.0,13,5,12,6,0,1,2,2,1,0,,0,1,2,1,1,SymbolInfo
68,201020,connectionsList_,3,node.anonymous_namespace_49.Parser.connectionsList_,,node_http_parser.cc,* connectionsList_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
69,201021,binding_data_,3,node.anonymous_namespace_49.Parser.binding_data_,,node_http_parser.cc,binding_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
70,201019,last_message_start_,3,node.anonymous_namespace_49.Parser.last_message_start_,,node_http_parser.cc,last_message_start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
71,86333,object_id_,3,node.inspector.anonymous_namespace_12.DeleteRequest.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
72,201024,Raw,1,"node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw","int node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw (llhttp_t*,Args)",node_http_parser.cc,"static int Raw(llhttp_t* p, Args ... args) {
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",1000.0,1007.0,5.0,5.0,8.0,11,7,13,8,0,1,2,2,0,0,,0,1,4,2,2,int
73,86341,Call,1,node.inspector.anonymous_namespace_17.CallRequest.Call,void node.inspector.anonymous_namespace_17.CallRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",77.0,79.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
74,86353,id_,3,node.inspector.anonymous_namespace_15.CallRequest.id_,,inspector\main_thread_interface.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
75,86362,AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference,"ANY node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference<Factory> (ANY,Factory)",inspector\main_thread_interface.cc,"AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, Factory factory)
      : AnotherThreadObjectReference(thread, thread->newObjectId()) {
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",94.0,98.0,3.0,3.0,5.0,2,2,4,4,0,2,1,1,0,0,,0,2,4,2,2,ANY
76,295268,~ScopedTracer,1,node.tracing.ScopedTracer.~ScopedTracer,ANY node.tracing.ScopedTracer.~ScopedTracer (),tracing\trace_event.hpp,"~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",688.0,692.0,3.0,6.0,5.0,11,5,10,4,0,9,2,2,3,0,,0,9,0,0,0,ANY
77,90468,NodeInspectorClient,1,node.inspector.NodeInspectorClient.NodeInspectorClient,"ANY node.inspector.NodeInspectorClient.NodeInspectorClient (ANY*,bool)",inspector_agent.cc,"explicit NodeInspectorClient(node::Environment* env, bool is_main)
      : env_(env), is_main_(is_main) {
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",401.0,410.0,3.0,3.0,10.0,8,4,10,6,0,2,1,1,0,0,,0,2,4,2,2,ANY
78,86384,~AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference,ANY node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference (),inspector\main_thread_interface.cc,"~AnotherThreadObjectReference() {
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",101.0,104.0,3.0,3.0,4.0,4,4,4,4,0,2,1,1,0,0,,0,2,0,0,0,ANY
79,201076,settings,3,node.anonymous_namespace_49.Parser.settings,,node_http_parser.cc,settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
80,131447,impl_,3,node.EmbedderSnapshotData.impl_,,node.hpp,* impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
81,131448,owns_impl_,3,node.EmbedderSnapshotData.owns_impl_,,node.hpp,owns_impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
82,86399,Call,1,node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call,void node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call<Fn> (Fn),inspector\main_thread_interface.cc,"void Call(Fn fn) const {
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",107.0,111.0,3.0,3.0,5.0,6,5,7,5,0,2,1,1,0,0,,0,2,2,1,1,void
83,90507,runMessageLoopOnPause,1,node.inspector.NodeInspectorClient.runMessageLoopOnPause,void node.inspector.NodeInspectorClient.runMessageLoopOnPause (int),inspector_agent.cc,"void runMessageLoopOnPause(int context_group_id) override {
    waiting_for_resume_ = true;
    runMessageLoop();
  }",412.0,415.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
84,201099,operator (),1,node.anonymous_namespace_100.ParserComparator.operator (),"bool node.anonymous_namespace_100.ParserComparator.operator () (Parser*,Parser*)",node_http_parser.cc,"bool ParserComparator::operator()(const Parser* lhs, const Parser* rhs) const {
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",1016.0,1028.0,1.0,1.0,13.0,9,4,6,2,0,4,2,2,2,0,,0,4,4,2,2,bool
85,295309,Initialize,1,node.tracing.ScopedTracer.Initialize,"void node.tracing.ScopedTracer.Initialize (uint8_t*,char*,uint64_t)",tracing\trace_event.hpp,"void Initialize(const uint8_t* category_group_enabled, const char* name,
                  uint64_t event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",694.0,700.0,3.0,3.0,7.0,8,3,8,5,0,8,1,1,0,0,,0,8,6,3,3,void
86,90516,waitForSessionsDisconnect,1,node.inspector.NodeInspectorClient.waitForSessionsDisconnect,void node.inspector.NodeInspectorClient.waitForSessionsDisconnect (),inspector_agent.cc,"void waitForSessionsDisconnect() {
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",417.0,420.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
87,102808,New,1,v8impl.anonymous_namespace_34.CallbackBundle.New,"Local<v8::Value> v8impl.anonymous_namespace_34.CallbackBundle.New (napi_env,napi_callback,void*)",js_native_api_v8.cc,"static inline v8::Local<v8::Value> New(napi_env env,
                                         napi_callback cb,
                                         void* data) {
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",371.0,383.0,3.0,3.0,13.0,18,6,21,10,0,4,1,1,0,0,,0,4,6,3,3,Local<v8.Value>
88,90524,waitForFrontend,1,node.inspector.NodeInspectorClient.waitForFrontend,void node.inspector.NodeInspectorClient.waitForFrontend (),inspector_agent.cc,"void waitForFrontend() {
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",422.0,425.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
89,139681,<lambda>1,1,node.Blob.Reader.Pull.<lambda>1,"ANY node.Blob.Reader.Pull.<lambda>1 (int,ANY*,size_t,ANY)",node_blob.cc,"[impl](int status,
                     const DataQueue::Vec* vecs,
                     size_t count,
                     bob::Done doneCb) mutable {
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Lo...",340.0,376.0,15.0,3.0,37.0,58,10,59,22,0,1,5,7,0,0,,0,1,8,4,4,ANY
90,90532,maxAsyncCallStackDepthChanged,1,node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged,void node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged (int),inspector_agent.cc,"void maxAsyncCallStackDepthChanged(int depth) override {
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",427.0,440.0,3.0,3.0,14.0,4,3,5,4,0,2,4,5,1,0,,0,2,2,1,1,void
91,295336,category_group_enabled,3,node.tracing.ScopedTracer.Data.category_group_enabled,,tracing\trace_event.hpp,* category_group_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
92,295337,name,3,node.tracing.ScopedTracer.Data.name,,tracing\trace_event.hpp,* name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
93,295338,event_handle,3,node.tracing.ScopedTracer.Data.event_handle,,tracing\trace_event.hpp,event_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
94,295339,p_data_,3,node.tracing.ScopedTracer.p_data_,,tracing\trace_event.hpp,* p_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
95,295340,data_,3,node.tracing.ScopedTracer.data_,,tracing\trace_event.hpp,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
96,86462,thread_,3,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference.thread_,,inspector\main_thread_interface.cc,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
97,86463,object_id_,3,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
98,90566,contextCreated,1,node.inspector.NodeInspectorClient.contextCreated,"void node.inspector.NodeInspectorClient.contextCreated (Local<Context>,ContextInfo)",inspector_agent.cc,"void contextCreated(Local<Context> context, const ContextInfo& info) {
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",442.0,459.0,3.0,3.0,18.0,14,3,15,8,0,1,2,2,0,0,,0,1,4,2,2,void
99,299465,seq,2,util.cc.seq,,util.cc,ANY seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
100,102870,env,3,v8impl.anonymous_namespace_33.CallbackBundle.env,,js_native_api_v8.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
101,102871,cb_data,3,v8impl.anonymous_namespace_33.CallbackBundle.cb_data,,js_native_api_v8.cc,* cb_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
102,102872,cb,3,v8impl.anonymous_namespace_33.CallbackBundle.cb,,js_native_api_v8.cc,cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
103,86488,Connect,1,node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect,void node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect (ANY),inspector\main_thread_interface.cc,"void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",142.0,146.0,3.0,3.0,5.0,6,4,8,6,0,3,2,2,0,0,,0,3,2,1,1,void
104,201185,All,1,node.anonymous_namespace_102.ConnectionsList.All,void node.anonymous_namespace_102.ConnectionsList.All (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::All(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1037.0,1052.0,1.0,1.0,16.0,19,6,18,9,0,2,2,2,1,0,,0,2,2,1,1,void
105,74229,current_process_,3,node.Win32SymbolDebuggingContext.current_process_,,debug_utils.cc,current_process_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
106,86517,Dispatch,1,node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch,void node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch (ANY),inspector\main_thread_interface.cc,"void Dispatch(std::unique_ptr<StringBuffer> message) {
    session_->Dispatch(message->string());
  }",148.0,150.0,3.0,3.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
107,102911,This,1,v8impl.anonymous_namespace_42.CallbackWrapper.This,napi_value v8impl.anonymous_namespace_42.CallbackWrapper.This (),js_native_api_v8.cc,napi_value This() { return _this; },406.0,406.0,3.0,37.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,napi_value
108,86530,thread_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.thread_,,inspector\main_thread_interface.cc,* thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
109,86531,prevent_shutdown_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.prevent_shutdown_,,inspector\main_thread_interface.cc,prevent_shutdown_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
110,86532,session_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.session_,,inspector\main_thread_interface.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
111,102917,ArgsLength,1,v8impl.anonymous_namespace_43.CallbackWrapper.ArgsLength,size_t v8impl.anonymous_namespace_43.CallbackWrapper.ArgsLength (),js_native_api_v8.cc,size_t ArgsLength() { return _args_length; },408.0,408.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
112,86534,CrossThreadInspectorSession,1,node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession,"ANY node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession (int,ANY,ANY,bool)",inspector\main_thread_interface.cc,"CrossThreadInspectorSession(
      int id,
      std::shared_ptr<MainThreadHandle> thread,
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown)
      : state_(thread, std::bind(MainThreadSessionState::Create,
                                 std::placeholders::_1,
                                 prevent_shutdown)) {
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",160.0,169.0,3.0,3.0,10.0,4,2,4,4,0,1,1,1,0,0,,0,1,8,4,4,ANY
113,90631,contextDestroyed,1,node.inspector.NodeInspectorClient.contextDestroyed,void node.inspector.NodeInspectorClient.contextDestroyed (Local<Context>),inspector_agent.cc,"void contextDestroyed(Local<Context> context) {
    client_->contextDestroyed(context);
  }",461.0,463.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
114,102923,Data,1,v8impl.anonymous_namespace_44.CallbackWrapper.Data,void* v8impl.anonymous_namespace_44.CallbackWrapper.Data (),js_native_api_v8.cc,void* Data() { return _data; },410.0,410.0,3.0,32.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
115,90641,quitMessageLoopOnPause,1,node.inspector.NodeInspectorClient.quitMessageLoopOnPause,void node.inspector.NodeInspectorClient.quitMessageLoopOnPause (),inspector_agent.cc,"void quitMessageLoopOnPause() override {
    waiting_for_resume_ = false;
  }",465.0,467.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
116,102929,_this,3,v8impl.anonymous_namespace_37.CallbackWrapper._this,,js_native_api_v8.cc,_this,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
117,111123,node_api_symbol_for,1,node_api_symbol_for,"napi_status node_api_symbol_for (napi_env,char*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_symbol_for(napi_env env,
                                           const char* utf8description,
                                           size_t length,
                                           napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",1746.0,1763.0,1.0,12.0,18.0,19,10,28,13,0,5,1,1,0,5,,0,3,8,4,4,napi_status
118,102932,CallbackWrapperBase,1,v8impl.anonymous_namespace_46.CallbackWrapperBase.CallbackWrapperBase,"ANY v8impl.anonymous_namespace_46.CallbackWrapperBase.CallbackWrapperBase (ANY,size_t)",js_native_api_v8.cc,"inline CallbackWrapperBase(const v8::FunctionCallbackInfo<v8::Value>& cbinfo,
                             const size_t args_length)
      : CallbackWrapper(
            JsValueFromV8LocalValue(cbinfo.This()), args_length, nullptr),
        _cbinfo(cbinfo) {
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",420.0,428.0,3.0,3.0,9.0,7,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,ANY
119,102931,_data,3,v8impl.anonymous_namespace_37.CallbackWrapper._data,,js_native_api_v8.cc,* _data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
120,102930,_args_length,3,v8impl.anonymous_namespace_37.CallbackWrapper._args_length,,js_native_api_v8.cc,_args_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
121,90648,runIfWaitingForDebugger,1,node.inspector.NodeInspectorClient.runIfWaitingForDebugger,void node.inspector.NodeInspectorClient.runIfWaitingForDebugger (int),inspector_agent.cc,"void runIfWaitingForDebugger(int context_group_id) override {
    waiting_for_frontend_ = false;
  }",469.0,471.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
122,86555,Dispatch,1,node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch,void node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch (StringView),inspector\main_thread_interface.cc,"void Dispatch(const StringView& message) override {
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",171.0,174.0,3.0,3.0,4.0,4,2,4,4,0,1,1,1,0,0,,0,1,2,1,1,void
123,90656,connectFrontend,1,node.inspector.NodeInspectorClient.connectFrontend,"int node.inspector.NodeInspectorClient.connectFrontend (ANY,bool)",inspector_agent.cc,"int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate,
                      bool prevent_shutdown) {
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",473.0,483.0,3.0,3.0,11.0,10,8,12,9,0,4,1,1,0,0,,0,4,4,2,2,int
124,135717,napi_create_buffer,1,napi_create_buffer,"napi_status napi_create_buffer (napi_env,size_t,void**,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_buffer(napi_env env,
                                          size_t length,
                                          void** data,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1013.0,1033.0,1.0,12.0,21.0,39,10,48,16,0,9,6,8,0,9,,0,3,8,4,4,napi_status
125,201259,Idle,1,node.anonymous_namespace_103.ConnectionsList.Idle,void node.anonymous_namespace_103.ConnectionsList.Idle (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Idle(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1054.0,1071.0,1.0,1.0,18.0,21,7,19,9,0,2,3,4,1,0,,0,2,2,1,1,void
126,86573,state_,3,node.inspector.anonymous_namespace_31.CrossThreadInspectorSession.state_,,inspector\main_thread_interface.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
127,102957,InvokeCallback,1,v8impl.anonymous_namespace_47.CallbackWrapperBase.InvokeCallback,void v8impl.anonymous_namespace_47.CallbackWrapperBase.InvokeCallback (),js_native_api_v8.cc,"inline void InvokeCallback() {
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",431.0,453.0,3.0,3.0,23.0,14,6,11,6,0,2,2,2,0,0,,0,2,0,0,0,void
128,74290,DumpBacktrace,1,node.DumpBacktrace,void node.DumpBacktrace (FILE*),debug_utils.cc,"void DumpBacktrace(FILE* fp) {
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",306.0,315.0,1.0,1.0,10.0,12,5,19,8,1,0,2,2,0,0,,0,0,2,1,1,void
129,86580,SendMessageToFrontend,1,node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend,void node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend (ANY),inspector\main_thread_interface.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",185.0,191.0,3.0,3.0,7.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
130,86591,delegate_,3,node.inspector.anonymous_namespace_34.ThreadSafeDelegate.delegate_,,inspector\main_thread_interface.cc,delegate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
131,90691,disconnectFrontend,1,node.inspector.NodeInspectorClient.disconnectFrontend,void node.inspector.NodeInspectorClient.disconnectFrontend (int),inspector_agent.cc,"void disconnectFrontend(int session_id) {
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",485.0,500.0,3.0,3.0,16.0,14,6,16,8,0,8,6,9,4,0,,0,8,2,1,1,void
132,86597,~MainThreadInterface,1,node.inspector.MainThreadInterface.~MainThreadInterface,ANY node.inspector.MainThreadInterface.~MainThreadInterface (),inspector\main_thread_interface.cc,"MainThreadInterface::~MainThreadInterface() {
  if (handle_)
    handle_->Reset();
}",202.0,205.0,1.0,1.0,4.0,1,1,2,1,0,2,2,2,1,0,,0,2,0,0,0,ANY
133,86608,Post,1,node.inspector.MainThreadInterface.Post,void node.inspector.MainThreadInterface.Post (ANY),inspector\main_thread_interface.cc,"void MainThreadInterface::Post(std::unique_ptr<Request> request) {
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",207.0,219.0,1.0,1.0,13.0,9,4,12,9,0,6,2,2,0,0,,0,6,2,1,1,void
134,131676,OnFatalError,1,node.OnFatalError,"void node.OnFatalError (char*,char*)",node_errors.cc,"[[noreturn]] void OnFatalError(const char* location, const char* message) {
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",507.0,527.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
135,8796,EmitAsyncInit,1,node.AsyncWrap.EmitAsyncInit,"void node.AsyncWrap.EmitAsyncInit (Environment*,Local<Object>,Local<String>,double,double)",async_wrap.cc,"void AsyncWrap::EmitAsyncInit(Environment* env,
                              Local<Object> object,
                              Local<String> type,
                              double async_id,
                              double trigger_async_id) {
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",635.0,661.0,1.0,1.0,27.0,25,9,28,14,1,0,2,2,0,0,,0,0,10,5,5,void
136,606,InternalMakeCallback,1,node.InternalMakeCallback,"MaybeLocal<Value> node.InternalMakeCallback (Environment*,Local<Object>,Local<Object>,Local<Function>,int,Local<Value>[],async_context)",api\callback.cc,"MaybeLocal<Value> InternalMakeCallback(Environment* env,
                                       Local<Object> resource,
                                       Local<Object> recv,
                                       const Local<Function> callback,
                                       int argc,
                                       Local<Value> argv[],
                                       async_context asyncContext) {
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async...",170.0,229.0,1.0,1.0,60.0,61,9,61,25,1,1,7,8,0,0,,0,1,14,7,7,MaybeLocal<Value>
137,103005,_bundle,3,v8impl.anonymous_namespace_45.CallbackWrapperBase._bundle,,js_native_api_v8.cc,* _bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
138,291422,<lambda>0,1,node.tracing.Agent.Agent.<lambda>0,ANY node.tracing.Agent.Agent.<lambda>0 (uv_async_t*),tracing\agent.cc,"[](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",58.0,61.0,26.0,3.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
139,103019,NewFunction,1,v8impl.anonymous_namespace_52.FunctionCallbackWrapper.NewFunction,"napi_status v8impl.anonymous_namespace_52.FunctionCallbackWrapper.NewFunction (napi_env,napi_callback,void*,ANY*)",js_native_api_v8.cc,"static inline napi_status NewFunction(napi_env env,
                                        napi_callback cb,
                                        void* cb_data,
                                        v8::Local<v8::Function>* result) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",466.0,479.0,3.0,4.0,14.0,26,7,30,11,0,3,1,1,0,3,,0,0,8,4,4,napi_status
140,291442,<lambda>1,1,node.tracing.Agent.Start.<lambda>1,ANY node.tracing.Agent.Start.<lambda>1 (void*),tracing\agent.cc,"[](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",97.0,100.0,42.0,3.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
141,111222,set_error_code,1,set_error_code,"napi_status set_error_code (napi_env,ANY,napi_value,char*)",js_native_api_v8.cc,"static inline napi_status set_error_code(napi_env env,
                                         v8::Local<v8::Value> error,
                                         napi_value code,
                                         const char* code_cstring) {
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure...",1765.0,1789.0,1.0,6.0,25.0,57,12,63,19,2,7,3,4,0,7,,0,2,8,4,4,napi_status
142,295546,SetInteger,1,node.tracing.TracedValue.SetInteger,"void node.tracing.TracedValue.SetInteger (char*,int)",tracing\traced_value.cc,"void TracedValue::SetInteger(const char* name, int value) {
  WriteName(name);
  data_ += std::to_string(value);
}",116.0,119.0,1.0,1.0,4.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
143,201340,Active,1,node.anonymous_namespace_104.ConnectionsList.Active,void node.anonymous_namespace_104.ConnectionsList.Active (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Active(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1073.0,1088.0,1.0,1.0,16.0,19,6,18,9,0,2,2,2,1,0,,0,2,2,1,1,void
144,86654,WaitForFrontendEvent,1,node.inspector.MainThreadInterface.WaitForFrontendEvent,bool node.inspector.MainThreadInterface.WaitForFrontendEvent (),inspector\main_thread_interface.cc,"bool MainThreadInterface::WaitForFrontendEvent() {
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",221.0,231.0,1.0,1.0,11.0,3,2,4,4,0,4,3,4,2,0,,0,4,0,0,0,bool
145,90757,dispatchMessageFromFrontend,1,node.inspector.NodeInspectorClient.dispatchMessageFromFrontend,"void node.inspector.NodeInspectorClient.dispatchMessageFromFrontend (int,StringView)",inspector_agent.cc,"void dispatchMessageFromFrontend(int session_id, const StringView& message) {
    channels_[session_id]->dispatchProtocolMessage(message);
  }",502.0,504.0,3.0,3.0,3.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
146,295561,SetDouble,1,node.tracing.TracedValue.SetDouble,"void node.tracing.TracedValue.SetDouble (char*,double)",tracing\traced_value.cc,"void TracedValue::SetDouble(const char* name, double value) {
  WriteName(name);
  data_ += DoubleToCString(value);
}",121.0,124.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
147,90770,ensureDefaultContextInGroup,1,node.inspector.NodeInspectorClient.ensureDefaultContextInGroup,Local<Context> node.inspector.NodeInspectorClient.ensureDefaultContextInGroup (int),inspector_agent.cc,"Local<Context> ensureDefaultContextInGroup(int contextGroupId) override {
    return env_->context();
  }",506.0,508.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,Local<Context>
148,295573,SetBoolean,1,node.tracing.TracedValue.SetBoolean,"void node.tracing.TracedValue.SetBoolean (char*,bool)",tracing\traced_value.cc,"void TracedValue::SetBoolean(const char* name, bool value) {
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",126.0,129.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
149,291478,ScopedSuspendTracing,1,node.tracing.ScopedSuspendTracing.ScopedSuspendTracing,"ANY node.tracing.ScopedSuspendTracing.ScopedSuspendTracing (TracingController*,Agent*,bool)",tracing\agent.cc,"ScopedSuspendTracing(TracingController* controller, Agent* agent,
                       bool do_suspend = true)
    : controller_(controller), agent_(do_suspend ? agent : nullptr) {
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",14.0,21.0,3.0,3.0,8.0,2,1,3,3,0,1,2,2,0,0,,0,1,6,3,3,ANY
150,86682,DispatchMessages,1,node.inspector.MainThreadInterface.DispatchMessages,void node.inspector.MainThreadInterface.DispatchMessages (),inspector\main_thread_interface.cc,"void MainThreadInterface::DispatchMessages() {
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",233.0,254.0,1.0,1.0,22.0,16,4,18,8,0,12,5,7,3,0,,0,12,0,0,0,void
151,90780,installAdditionalCommandLineAPI,1,node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI,"void node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI (Local<Context>,Local<Object>)",inspector_agent.cc,"void installAdditionalCommandLineAPI(Local<Context> context,
                                       Local<Object> target) override {
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",510.0,518.0,3.0,3.0,9.0,9,7,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
152,295587,SetNull,1,node.tracing.TracedValue.SetNull,void node.tracing.TracedValue.SetNull (char*),tracing\traced_value.cc,"void TracedValue::SetNull(const char* name) {
  WriteName(name);
  data_ += ""null"";
}",131.0,134.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
153,291496,~ScopedSuspendTracing,1,node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing,ANY node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing (),tracing\agent.cc,"~ScopedSuspendTracing() {
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",23.0,29.0,3.0,3.0,7.0,5,4,6,3,0,3,3,3,1,0,,0,3,0,0,0,ANY
154,33451,TicketKeyCallback,1,node.crypto.SecureContext.TicketKeyCallback,"int node.crypto.SecureContext.TicketKeyCallback (SSL*,unsigned char*,unsigned char*,EVP_CIPHER_CTX*,HMAC_CTX*,int)",crypto\crypto_context.cc,"int SecureContext::TicketKeyCallback(SSL* ssl,
                                     unsigned char* name,
                                     unsigned char* iv,
                                     EVP_CIPHER_CTX* ectx,
                                     HMAC_CTX* hctx,
                                     int enc) {
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env...",1178.0,1277.0,1.0,1.0,100.0,111,13,105,31,0,1,9,10,1,1,,0,1,12,6,6,int
155,295597,SetString,1,node.tracing.TracedValue.SetString,"void node.tracing.TracedValue.SetString (char*,char*)",tracing\traced_value.hpp,"void SetString(const char* name, const std::string& value) {
    SetString(name, value.c_str());
  }",35.0,37.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
156,275118,<lambda>0,1,node.anonymous_namespace_11.SignalWrap.Start.<lambda>0,"ANY node.anonymous_namespace_11.SignalWrap.Start.<lambda>0 (uv_signal_t*,int)",signal_wrap.cc,"[](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",123.0,130.0,9.0,9.0,8.0,15,6,16,9,0,1,1,1,0,0,,0,1,4,2,2,ANY
157,295609,BeginDictionary,1,node.tracing.TracedValue.BeginDictionary,void node.tracing.TracedValue.BeginDictionary (char*),tracing\traced_value.cc,"void TracedValue::BeginDictionary() {
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",178.0,182.0,1.0,1.0,5.0,2,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,void
158,90818,ReportUncaughtException,1,node.inspector.NodeInspectorClient.ReportUncaughtException,"void node.inspector.NodeInspectorClient.ReportUncaughtException (Local<Value>,Local<Message>)",inspector_agent.cc,"void ReportUncaughtException(Local<Value> error, Local<Message> message) {
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",520.0,545.0,3.0,3.0,26.0,37,10,35,12,0,4,2,2,0,0,,0,4,4,2,2,void
159,291523,controller_,3,node.tracing.ScopedSuspendTracing.controller_,,tracing\agent.cc,* controller_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
160,291524,agent_,3,node.tracing.ScopedSuspendTracing.agent_,,tracing\agent.cc,* agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
161,8898,MakeCallback,1,node.AsyncWrap.MakeCallback,"MaybeLocal<Value> node.AsyncWrap.MakeCallback (Local<Function>,int,Local<Value>*)",async_wrap.cc,"MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb,
                                          int argc,
                                          Local<Value>* argv) {
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",664.0,679.0,1.0,1.0,16.0,7,5,12,8,0,1,1,1,0,0,,0,1,6,3,3,MaybeLocal<Value>
162,201414,Expired,1,node.anonymous_namespace_105.ConnectionsList.Expired,void node.anonymous_namespace_105.ConnectionsList.Expired (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Expired(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  // On IoT or embedded devices the uv_hrtime() may return the timestamp
  // that is smaller than configured timeout for headers or request
  // to prevent subtracting two unsigned integers
  // that can yield incorrect results we should check
  // if the 'now' is bigger than the timeout for headers or reque...",1090.0,1151.0,1.0,1.0,62.0,83,19,64,16,0,7,5,6,3,0,,0,7,2,1,1,void
163,295622,BeginArray,1,node.tracing.TracedValue.BeginArray,void node.tracing.TracedValue.BeginArray (char*),tracing\traced_value.cc,"void TracedValue::BeginArray() {
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",184.0,188.0,1.0,1.0,5.0,2,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,void
164,74437,__DumpBacktrace,1,__DumpBacktrace,void __DumpBacktrace (FILE*),debug_utils.cc,"void __DumpBacktrace(FILE* fp) {
  node::DumpBacktrace(fp);
}",516.0,518.0,12.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
165,135888,napi_create_external_buffer,1,napi_create_external_buffer,"napi_status napi_create_external_buffer (napi_env,size_t,void*,napi_finalize,void*,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_external_buffer(napi_env env,
                                                   size_t length,
                                                   void* data,
                                                   napi_finalize finalize_cb,
                                                   void* finalize_hint,
                                                   napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferF...",1035.0,1069.0,1.0,12.0,35.0,36,11,51,20,0,8,5,7,0,8,,0,2,12,6,6,napi_status
166,103122,NewTemplate,1,v8impl.anonymous_namespace_55.FunctionCallbackWrapper.NewTemplate,"napi_status v8impl.anonymous_namespace_55.FunctionCallbackWrapper.NewTemplate (napi_env,napi_callback,void*,ANY*,ANY)",js_native_api_v8.cc,"static inline napi_status NewTemplate(
      napi_env env,
      napi_callback cb,
      void* cb_data,
      v8::Local<v8::FunctionTemplate>* result,
      v8::Local<v8::Signature> sig = v8::Local<v8::Signature>()) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",481.0,492.0,3.0,4.0,12.0,17,7,21,11,0,2,1,1,0,2,,0,0,10,5,5,napi_status
167,295635,AppendInteger,1,node.tracing.TracedValue.AppendInteger,void node.tracing.TracedValue.AppendInteger (int),tracing\traced_value.cc,"void TracedValue::AppendInteger(int value) {
  WriteComma();
  data_ += std::to_string(value);
}",153.0,156.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
168,82651,isolate_,3,node.heap.JSGraph.isolate_,,heap_utils.cc,* isolate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
169,82652,nodes_,3,node.heap.JSGraph.nodes_,,heap_utils.cc,nodes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
170,82653,engine_nodes_,3,node.heap.JSGraph.engine_nodes_,,heap_utils.cc,engine_nodes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
171,82654,edges_,3,node.heap.JSGraph.edges_,,heap_utils.cc,edges_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
172,295648,AppendDouble,1,node.tracing.TracedValue.AppendDouble,void node.tracing.TracedValue.AppendDouble (double),tracing\traced_value.cc,"void TracedValue::AppendDouble(double value) {
  WriteComma();
  data_ += DoubleToCString(value);
}",158.0,161.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
173,86759,GetHandle,1,node.inspector.MainThreadInterface.GetHandle,shared_ptr<MainThreadHandle> node.inspector.MainThreadInterface.GetHandle (),inspector\main_thread_interface.cc,"std::shared_ptr<MainThreadHandle> MainThreadInterface::GetHandle() {
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",256.0,260.0,1.0,1.0,5.0,5,5,5,3,0,3,2,2,1,0,,0,3,0,0,0,shared_ptr<MainThreadHandle>
174,291561,Agent,1,node.tracing.Agent.Agent,ANY node.tracing.Agent.Agent (),tracing\agent.cc,"Agent::Agent() : tracing_controller_(new TracingController()) {
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",52.0,63.0,1.0,1.0,12.0,6,3,5,3,0,5,1,1,0,0,,0,5,0,0,0,ANY
175,295658,AppendBoolean,1,node.tracing.TracedValue.AppendBoolean,void node.tracing.TracedValue.AppendBoolean (bool),tracing\traced_value.cc,"void TracedValue::AppendBoolean(bool value) {
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",163.0,166.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
176,217844,nodedbg_const_ContextEmbedderIndex__kEnvironment__int,2,base_object-inl.hpp.nodedbg_const_ContextEmbedderIndex__kEnvironment__int,,base_object-inl.hpp,int nodedbg_const_ContextEmbedderIndex__kEnvironment__int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
177,217845,nodedbg_const_BaseObject__kInternalFieldCount__int,2,base_object-inl.hpp.nodedbg_const_BaseObject__kInternalFieldCount__int,,base_object-inl.hpp,int nodedbg_const_BaseObject__kInternalFieldCount__int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
178,217846,nodedbg_offset_ExternalString__data__uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ExternalString__data__uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ExternalString__data__uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
179,217847,nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
180,295670,AppendNull,1,node.tracing.TracedValue.AppendNull,void node.tracing.TracedValue.AppendNull (),tracing\traced_value.cc,"void TracedValue::AppendNull() {
  WriteComma();
  data_ += ""null"";
}",168.0,171.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
181,217849,nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,2,base_object-inl.hpp.nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,,base_object-inl.hpp,uintptr_t nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
182,217851,nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
183,86779,AddObject,1,node.inspector.MainThreadInterface.AddObject,"void node.inspector.MainThreadInterface.AddObject (int,ANY)",inspector\main_thread_interface.cc,"void MainThreadInterface::AddObject(int id,
                                    std::unique_ptr<Deletable> object) {
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",262.0,266.0,1.0,1.0,5.0,3,3,5,4,0,1,1,1,0,0,,0,1,4,2,2,void
184,217853,nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
185,295678,AppendString,1,node.tracing.TracedValue.AppendString,void node.tracing.TracedValue.AppendString (char*),tracing\traced_value.hpp,void AppendString(const std::string& value) { AppendString(value.c_str()); },46.0,46.0,3.0,78.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
186,217855,nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,2,base_object-inl.hpp.nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,,base_object-inl.hpp,uintptr_t nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
187,217857,nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,2,base_object-inl.hpp.nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
188,217859,nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
189,291588,InitializeWritersOnThread,1,node.tracing.Agent.InitializeWritersOnThread,void node.tracing.Agent.InitializeWritersOnThread (),tracing\agent.cc,"void Agent::InitializeWritersOnThread() {
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",65.0,73.0,1.0,1.0,9.0,9,6,10,6,0,6,2,2,1,0,,0,6,0,0,0,void
190,217861,nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
191,217863,nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
192,217865,nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
193,217867,nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
194,86796,RemoveObject,1,node.inspector.MainThreadInterface.RemoveObject,void node.inspector.MainThreadInterface.RemoveObject (int),inspector\main_thread_interface.cc,"void MainThreadInterface::RemoveObject(int id) {
  CHECK_EQ(1, managed_objects_.erase(id));
}",268.0,270.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
195,217869,GenDebugSymbols,1,node.GenDebugSymbols,int node.GenDebugSymbols (),node_postmortem_metadata.cc,"int GenDebugSymbols() {
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",52.0,69.0,1.0,51.0,18.0,51,6,35,23,0,14,1,1,0,0,,0,14,0,0,0,int
196,103197,GetNewTarget,1,v8impl.anonymous_namespace_59.FunctionCallbackWrapper.GetNewTarget,napi_value v8impl.anonymous_namespace_59.FunctionCallbackWrapper.GetNewTarget (),js_native_api_v8.cc,"napi_value GetNewTarget() override {
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",498.0,504.0,3.0,3.0,7.0,3,1,3,2,0,1,2,2,0,1,,0,0,0,0,0,napi_value
197,295710,EndDictionary,1,node.tracing.TracedValue.EndDictionary,void node.tracing.TracedValue.EndDictionary (),tracing\traced_value.cc,"void TracedValue::EndDictionary() {
  data_ += '}';
  first_item_ = false;
}",190.0,193.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
198,86822,GetObjectIfExists,1,node.inspector.MainThreadInterface.GetObjectIfExists,Deletable node.inspector.MainThreadInterface.GetObjectIfExists (int),inspector\main_thread_interface.cc,"Deletable* MainThreadInterface::GetObjectIfExists(int id) {
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",280.0,286.0,1.0,1.0,7.0,6,4,6,3,0,2,2,2,1,0,,0,2,2,1,1,Deletable
199,82727,WriteAsciiChunk,1,node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk,"WriteResult node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk (char*,int)",heap_utils.cc,"WriteResult WriteAsciiChunk(char* data, const int size) override {
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",233.0,255.0,3.0,3.0,23.0,13,9,25,10,0,5,3,4,0,0,,0,5,4,2,2,WriteResult
200,295720,EndArray,1,node.tracing.TracedValue.EndArray,void node.tracing.TracedValue.EndArray (),tracing\traced_value.cc,"void TracedValue::EndArray() {
  data_ += ']';
  first_item_ = false;
}",195.0,198.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
201,291626,~Agent,1,node.tracing.Agent.~Agent,ANY node.tracing.Agent.~Agent (),tracing\agent.cc,"Agent::~Agent() {
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",75.0,84.0,1.0,1.0,10.0,6,3,6,5,0,5,1,1,0,0,,0,5,0,0,0,ANY
202,131887,kIsForSnapshotting,3,node.CommonEnvironmentSetup.Flags.kIsForSnapshotting,,node.hpp,kIsForSnapshotting = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
203,295730,WriteComma,1,node.tracing.TracedValue.WriteComma,void node.tracing.TracedValue.WriteComma (),tracing\traced_value.cc,"void TracedValue::WriteComma() {
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",200.0,206.0,1.0,1.0,7.0,1,1,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
204,103220,Args,1,v8impl.anonymous_namespace_60.FunctionCallbackWrapper.Args,"void v8impl.anonymous_namespace_60.FunctionCallbackWrapper.Args (napi_value*,size_t)",js_native_api_v8.cc,"void Args(napi_value* buffer, size_t buffer_length) override {
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",507.0,522.0,3.0,3.0,16.0,16,4,23,10,0,2,4,5,0,2,,0,2,4,2,2,void
205,131899,impl_,3,node.CommonEnvironmentSetup.impl_,,node.hpp,* impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
206,831,MakeCallback,1,node.MakeCallback,"MaybeLocal<Value> node.MakeCallback (Isolate*,Local<Object>,char*,int,Local<Value>[],async_context)",api\callback.cc,"Local<Value> MakeCallback(Isolate* isolate,
                          Local<Object> recv,
                          Local<Function> callback,
                          int argc,
                          Local<Value>* argv) {
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",349.0,358.0,1.0,1.0,10.0,5,4,12,9,3,0,1,1,0,0,,0,0,10,5,5,Local<Value>
207,295745,WriteName,1,node.tracing.TracedValue.WriteName,void node.tracing.TracedValue.WriteName (char*),tracing\traced_value.cc,"void TracedValue::WriteName(const char* name) {
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",208.0,213.0,1.0,1.0,6.0,3,1,4,2,0,3,1,1,0,0,,0,3,2,1,1,void
208,291652,Start,1,node.tracing.Agent.Start,void node.tracing.Agent.Start (),tracing\agent.cc,"void Agent::Start() {
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",86.0,102.0,1.0,1.0,17.0,7,5,9,6,0,6,2,2,1,0,,0,6,0,0,0,void
209,90950,startRepeatingTimer,1,node.inspector.NodeInspectorClient.startRepeatingTimer,"void node.inspector.NodeInspectorClient.startRepeatingTimer (double,TimerCallback,void*)",inspector_agent.cc,"void startRepeatingTimer(double interval_s,
                           TimerCallback callback,
                           void* data) override {
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",547.0,556.0,3.0,3.0,10.0,12,5,13,7,0,2,1,1,0,0,,0,2,6,3,3,void
210,295760,AppendAsTraceFormat,1,node.tracing.TracedValue.AppendAsTraceFormat,void node.tracing.TracedValue.AppendAsTraceFormat (ANY*),tracing\traced_value.cc,"void TracedValue::AppendAsTraceFormat(std::string* out) const {
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",215.0,219.0,1.0,1.0,5.0,8,3,6,3,0,3,1,1,0,0,,0,3,2,1,1,void
211,99159,Close,1,node.inspector.SocketSession.Close,void node.inspector.SocketSession.Close (),inspector_socket_server.cc,"void Close() {
    ws_socket_.reset();
  }",157.0,159.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
212,275295,SignalWrap,1,node.anonymous_namespace_8.SignalWrap.SignalWrap,"ANY node.anonymous_namespace_8.SignalWrap.SignalWrap (Environment*,Local<Object>)",signal_wrap.cc,"SignalWrap(Environment* env, Local<Object> object)
      : HandleWrap(env,
                   object,
                   reinterpret_cast<uv_handle_t*>(&handle_),
                   AsyncWrap::PROVIDER_SIGNALWRAP) {
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",88.0,95.0,3.0,3.0,8.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,ANY
213,99172,Own,1,node.inspector.SocketSession.Own,void node.inspector.SocketSession.Own (ANY),inspector_socket_server.cc,"void Own(InspectorSocket::Pointer ws_socket) {
    ws_socket_ = std::move(ws_socket);
  }",161.0,163.0,3.0,3.0,3.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
214,291686,AddClient,1,node.tracing.Agent.AddClient,"AgentWriterHandle node.tracing.Agent.AddClient (ANY,ANY,UseDefaultCategoryMode)",tracing\agent.cc,"AgentWriterHandle Agent::AddClient(
    const std::set<std::string>& categories,
    std::unique_ptr<AsyncTraceWriter> writer,
    enum UseDefaultCategoryMode mode) {
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (...",104.0,135.0,1.0,1.0,32.0,31,8,35,17,0,13,3,3,2,0,,0,13,6,3,3,AgentWriterHandle
215,82795,status,1,node.heap.anonymous_namespace_6.FileOutputStream.status,int node.heap.anonymous_namespace_6.FileOutputStream.status (),heap_utils.cc,int status() const { return status_; },257.0,257.0,3.0,40.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
216,99184,id,1,node.inspector.SocketSession.id,int node.inspector.SocketSession.id (),inspector_socket_server.cc,int id() const { return id_; },164.0,164.0,3.0,32.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
217,82801,fd_,3,node.heap.anonymous_namespace_1.FileOutputStream.fd_,,heap_utils.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
218,275314,Close,1,node.anonymous_namespace_9.SignalWrap.Close,void node.anonymous_namespace_9.SignalWrap.Close (ANY),signal_wrap.cc,"void Close(v8::Local<v8::Value> close_callback) override {
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",97.0,103.0,3.0,3.0,7.0,3,2,5,4,0,3,2,2,1,0,,0,3,2,1,1,void
219,82803,status_,3,node.heap.anonymous_namespace_1.FileOutputStream.status_,,heap_utils.cc,status_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
220,82802,req_,3,node.heap.anonymous_namespace_1.FileOutputStream.req_,,heap_utils.cc,* req_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
221,99190,server_port,1,node.inspector.SocketSession.server_port,int node.inspector.SocketSession.server_port (),inspector_socket_server.cc,"int server_port() {
    return server_port_;
  }",165.0,167.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
222,90999,cancelTimer,1,node.inspector.NodeInspectorClient.cancelTimer,void node.inspector.NodeInspectorClient.cancelTimer (void*),inspector_agent.cc,"void cancelTimer(void* data) override {
    timers_.erase(data);
  }",558.0,560.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
223,99196,ws_socket,1,node.inspector.SocketSession.ws_socket,InspectorSocket node.inspector.SocketSession.ws_socket (),inspector_socket_server.cc,"InspectorSocket* ws_socket() {
    return ws_socket_.get();
  }",168.0,170.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,InspectorSocket
224,136061,napi_create_buffer_copy,1,napi_create_buffer_copy,"napi_status napi_create_buffer_copy (napi_env,size_t,void*,void**,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_buffer_copy(napi_env env,
                                               size_t length,
                                               const void* data,
                                               void** result_data,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1071.0,1092.0,1.0,12.0,22.0,40,11,49,17,0,9,6,8,0,9,,0,3,10,5,5,napi_status
225,4990,AddLinkedBinding,1,node.AddLinkedBinding,"void node.AddLinkedBinding (Environment*,node_module)",api\environment.cc,"void AddLinkedBinding(Environment* env,
                      const char* name,
                      napi_addon_register_func fn,
                      int32_t module_api_version) {
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",873.0,889.0,1.0,1.0,17.0,11,4,9,3,0,1,2,2,0,0,,0,1,8,4,4,void
226,86909,Connect,1,node.inspector.MainThreadHandle.Connect,"unique_ptr<InspectorSession> node.inspector.MainThreadHandle.Connect (ANY,bool)",inspector\main_thread_interface.cc,"std::unique_ptr<InspectorSession> MainThreadHandle::Connect(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",298.0,306.0,1.0,1.0,9.0,6,5,7,6,0,1,1,1,0,0,,0,1,4,2,2,unique_ptr<InspectorSession>
227,103293,SetReturnValue,1,v8impl.anonymous_namespace_61.FunctionCallbackWrapper.SetReturnValue,void v8impl.anonymous_namespace_61.FunctionCallbackWrapper.SetReturnValue (napi_value),js_native_api_v8.cc,"void SetReturnValue(napi_value value) override {
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",525.0,528.0,3.0,3.0,4.0,8,4,7,5,0,1,1,1,0,1,,0,1,2,1,1,void
228,91009,AsyncTaskScheduled,1,node.inspector.NodeInspectorClient.AsyncTaskScheduled,"void node.inspector.NodeInspectorClient.AsyncTaskScheduled (StringView,void*,bool)",inspector_agent.cc,"void AsyncTaskScheduled(const StringView& task_name, void* task,
                          bool recurring) {
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",563.0,566.0,3.0,3.0,4.0,1,1,4,4,0,1,1,1,0,0,,0,1,6,3,3,void
229,99205,Accept,1,node.inspector.SocketSession.Accept,void node.inspector.SocketSession.Accept (ANY),inspector_socket_server.cc,"void Accept(const std::string& ws_key) {
    ws_socket_->AcceptUpgrade(ws_key);
  }",171.0,173.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
230,275334,Start,1,node.anonymous_namespace_10.SignalWrap.Start,void node.anonymous_namespace_10.SignalWrap.Start (FunctionCallbackInfo<Value>),signal_wrap.cc,"static void Start(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(e...",105.0,141.0,3.0,3.0,37.0,22,8,18,7,0,3,3,3,0,0,,0,3,2,1,1,void
231,91023,AsyncTaskCanceled,1,node.inspector.NodeInspectorClient.AsyncTaskCanceled,void node.inspector.NodeInspectorClient.AsyncTaskCanceled (void*),inspector_agent.cc,"void AsyncTaskCanceled(void* task) {
    client_->asyncTaskCanceled(task);
  }",568.0,570.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
232,99215,Decline,1,node.inspector.SocketSession.Decline,void node.inspector.SocketSession.Decline (),inspector_socket_server.cc,"void Decline() {
    ws_socket_->CancelHandshake();
  }",174.0,176.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
233,82831,EndOfStream,1,node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream,void node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream (),heap_utils.cc,"void EndOfStream() override {
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",286.0,289.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
234,86933,Post,1,node.inspector.MainThreadHandle.Post,bool node.inspector.MainThreadHandle.Post (ANY),inspector\main_thread_interface.cc,"bool MainThreadHandle::Post(std::unique_ptr<Request> request) {
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",308.0,314.0,1.0,1.0,7.0,3,3,5,4,0,3,2,2,1,0,,0,3,2,1,1,bool
235,103321,Wrap,1,v8impl.anonymous_namespace_62.Wrap,"napi_status v8impl.anonymous_namespace_62.Wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)",js_native_api_v8.cc,"inline napi_status Wrap(napi_env env,
                        napi_value js_object,
                        void* native_object,
                        napi_finalize finalize_cb,
                        void* finalize_hint,
                        napi_ref* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
  ...",531.0,585.0,1.0,2.0,55.0,62,11,80,22,0,10,6,8,0,10,,0,2,12,6,6,napi_status
236,91033,AsyncTaskStarted,1,node.inspector.NodeInspectorClient.AsyncTaskStarted,void node.inspector.NodeInspectorClient.AsyncTaskStarted (void*),inspector_agent.cc,"void AsyncTaskStarted(void* task) {
    client_->asyncTaskStarted(task);
  }",572.0,574.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
237,99230,~Delegate,1,node.inspector.SocketSession.Delegate.~Delegate,ANY node.inspector.SocketSession.Delegate.~Delegate (),inspector_socket_server.cc,"~Delegate() override {
      server_->SessionTerminated(session_id_);
    }",182.0,184.0,5.0,5.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
238,91043,AsyncTaskFinished,1,node.inspector.NodeInspectorClient.AsyncTaskFinished,void node.inspector.NodeInspectorClient.AsyncTaskFinished (void*),inspector_agent.cc,"void AsyncTaskFinished(void* task) {
    client_->asyncTaskFinished(task);
  }",576.0,578.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
239,91053,AllAsyncTasksCanceled,1,node.inspector.NodeInspectorClient.AllAsyncTasksCanceled,void node.inspector.NodeInspectorClient.AllAsyncTasksCanceled (),inspector_agent.cc,"void AllAsyncTasksCanceled() {
    client_->allAsyncTasksCanceled();
  }",580.0,582.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
240,86958,Reset,1,node.inspector.MainThreadHandle.Reset,void node.inspector.MainThreadHandle.Reset (),inspector\main_thread_interface.cc,"void MainThreadHandle::Reset() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",316.0,319.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
241,91061,schedulePauseOnNextStatement,1,node.inspector.NodeInspectorClient.schedulePauseOnNextStatement,void node.inspector.NodeInspectorClient.schedulePauseOnNextStatement (ANY),inspector_agent.cc,"void schedulePauseOnNextStatement(const std::string& reason) {
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",584.0,588.0,3.0,3.0,5.0,2,2,3,3,0,1,2,2,1,0,,0,1,2,1,1,void
242,86968,MakeDelegateThreadSafe,1,node.inspector.MainThreadHandle.MakeDelegateThreadSafe,unique_ptr<InspectorSessionDelegate> node.inspector.MainThreadHandle.MakeDelegateThreadSafe (ANY),inspector\main_thread_interface.cc,"std::unique_ptr<InspectorSessionDelegate>
MainThreadHandle::MakeDelegateThreadSafe(
    std::unique_ptr<InspectorSessionDelegate> delegate) {
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",321.0,328.0,1.0,1.0,8.0,7,6,9,6,0,1,1,1,0,0,,0,1,2,1,1,unique_ptr<InspectorSessionDelegate>
243,99257,Session,1,node.inspector.SocketSession.Delegate.Session,SocketSession node.inspector.SocketSession.Delegate.Session (),inspector_socket_server.cc,"SocketSession* Session() {
      return server_->Session(session_id_);
    }",191.0,193.0,5.0,5.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,SocketSession
244,99267,server_,3,node.inspector.SocketSession.Delegate.server_,,inspector_socket_server.cc,* server_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
245,99268,session_id_,3,node.inspector.SocketSession.Delegate.session_id_,,inspector_socket_server.cc,session_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
246,99269,id_,3,node.inspector.SocketSession.id_,,inspector_socket_server.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
247,99270,ws_socket_,3,node.inspector.SocketSession.ws_socket_,,inspector_socket_server.cc,ws_socket_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
248,91077,hasConnectedSessions,1,node.inspector.NodeInspectorClient.hasConnectedSessions,bool node.inspector.NodeInspectorClient.hasConnectedSessions (),inspector_agent.cc,"bool hasConnectedSessions() {
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",590.0,597.0,3.0,3.0,8.0,2,2,2,2,0,1,3,4,1,0,,0,1,0,0,0,bool
249,99271,server_port_,3,node.inspector.SocketSession.server_port_,,inspector_socket_server.cc,server_port_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
250,82897,ReadStart,1,node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart,int node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart (),heap_utils.cc,"int ReadStart() override {
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",306.0,310.0,3.0,3.0,5.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,int
251,99284,Close,1,node.inspector.ServerSocket.Close,void node.inspector.ServerSocket.Close (),inspector_socket_server.cc,"void Close() {
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",210.0,212.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
252,275413,Stop,1,node.anonymous_namespace_12.SignalWrap.Stop,void node.anonymous_namespace_12.SignalWrap.Stop (FunctionCallbackInfo<Value>),signal_wrap.cc,"static void Stop(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",143.0,154.0,3.0,3.0,12.0,12,4,9,3,0,4,2,2,1,0,,0,4,2,1,1,void
253,86999,Expired,1,node.inspector.MainThreadHandle.Expired,bool node.inspector.MainThreadHandle.Expired (),inspector\main_thread_interface.cc,"bool MainThreadHandle::Expired() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",330.0,333.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
254,91097,notifyWaitingForDisconnect,1,node.inspector.NodeInspectorClient.notifyWaitingForDisconnect,bool node.inspector.NodeInspectorClient.notifyWaitingForDisconnect (),inspector_agent.cc,"bool notifyWaitingForDisconnect() {
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",599.0,606.0,3.0,3.0,8.0,4,3,5,3,0,1,3,4,1,0,,0,1,0,0,0,bool
255,99294,port,1,node.inspector.ServerSocket.port,int node.inspector.ServerSocket.port (),inspector_socket_server.cc,int port() const { return port_; },213.0,213.0,3.0,36.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
256,291806,DefaultHandle,1,node.tracing.Agent.DefaultHandle,AgentWriterHandle node.tracing.Agent.DefaultHandle (),tracing\agent.cc,"AgentWriterHandle Agent::DefaultHandle() {
  return AgentWriterHandle(this, kDefaultHandleId);
}",137.0,139.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,AgentWriterHandle
257,99300,FromTcpSocket,1,node.inspector.ServerSocket.FromTcpSocket,ServerSocket node.inspector.ServerSocket.FromTcpSocket<UvHandle> (UvHandle*),inspector_socket_server.cc,"static ServerSocket* FromTcpSocket(UvHandle* socket) {
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",217.0,220.0,3.0,3.0,4.0,4,3,3,3,0,1,1,1,0,0,,0,1,2,1,1,ServerSocket
258,291814,StopTracing,1,node.tracing.Agent.StopTracing,void node.tracing.Agent.StopTracing (),tracing\agent.cc,"void Agent::StopTracing() {
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",141.0,152.0,1.0,1.0,12.0,5,4,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
259,91122,getThreadHandle,1,node.inspector.NodeInspectorClient.getThreadHandle,shared_ptr<MainThreadHandle> node.inspector.NodeInspectorClient.getThreadHandle (),inspector_agent.cc,"std::shared_ptr<MainThreadHandle> getThreadHandle() {
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",608.0,614.0,3.0,3.0,7.0,7,6,6,4,0,4,2,2,1,0,,0,4,0,0,0,shared_ptr<MainThreadHandle>
260,82935,IsAlive,1,node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive,bool node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive (),heap_utils.cc,bool IsAlive() override { return snapshot_ != nullptr; },327.0,327.0,3.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
261,291838,Disconnect,1,node.tracing.Agent.Disconnect,void node.tracing.Agent.Disconnect (int),tracing\agent.cc,"void Agent::Disconnect(int client) {
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",154.0,163.0,1.0,1.0,10.0,7,3,11,7,0,7,2,2,1,0,,0,7,2,1,1,void
262,82943,IsClosing,1,node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing,bool node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing (),heap_utils.cc,bool IsClosing() override { return snapshot_ == nullptr; },328.0,328.0,3.0,60.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
263,275458,handle_,3,node.anonymous_namespace_1.SignalWrap.handle_,,signal_wrap.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
264,275459,active_,3,node.anonymous_namespace_1.SignalWrap.active_,,signal_wrap.cc,active_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
265,295945,data_,3,node.tracing.TracedValue.data_,,tracing\traced_value.hpp,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
266,295946,first_item_,3,node.tracing.TracedValue.first_item_,,tracing\traced_value.hpp,first_item_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
267,99339,tcp_socket_,3,node.inspector.ServerSocket.tcp_socket_,,inspector_socket_server.cc,tcp_socket_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
268,91147,getWorkerManager,1,node.inspector.NodeInspectorClient.getWorkerManager,shared_ptr<WorkerManager> node.inspector.NodeInspectorClient.getWorkerManager (),inspector_agent.cc,"std::shared_ptr<WorkerManager> getWorkerManager() {
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",616.0,625.0,3.0,3.0,10.0,6,6,6,4,0,4,3,3,2,0,,0,4,0,0,0,shared_ptr<WorkerManager>
269,82957,MemoryInfo,1,node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo,void node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo (MemoryTracker*),heap_utils.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",331.0,336.0,3.0,3.0,6.0,4,4,3,2,0,2,2,2,1,0,,0,2,2,1,1,void
270,295947,root_is_array_,3,node.tracing.TracedValue.root_is_array_,,tracing\traced_value.hpp,root_is_array_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
271,99341,port_,3,node.inspector.ServerSocket.port_,,inspector_socket_server.cc,port_ = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
272,87060,~MainThreadHandle,1,node.inspector.MainThreadHandle.~MainThreadHandle,ANY node.inspector.MainThreadHandle.~MainThreadHandle (),inspector\main_thread_interface.hpp,"~MainThreadHandle() {
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",46.0,49.0,3.0,3.0,4.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
273,87075,newObjectId,1,node.inspector.MainThreadHandle.newObjectId,int node.inspector.MainThreadHandle.newObjectId (),inspector\main_thread_interface.hpp,"int newObjectId() {
    return ++next_object_id_;
  }",53.0,55.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
274,82980,snapshot_,3,node.heap.anonymous_namespace_7.HeapSnapshotStream.snapshot_,,heap_utils.cc,snapshot_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
275,91173,IsActive,1,node.inspector.NodeInspectorClient.IsActive,bool node.inspector.NodeInspectorClient.IsActive (),inspector_agent.cc,"bool IsActive() {
    return !channels_.empty();
  }",627.0,629.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
276,78888,CollectExceptionInfo,1,node.CollectExceptionInfo,"void node.CollectExceptionInfo (Environment*,Local<Object>,int,char*,char*,char*,char*,char*)",env.cc,"void CollectExceptionInfo(Environment* env,
                          Local<Object> obj,
                          int errorno,
                          const char* err_string,
                          const char* syscall,
                          const char* message,
                          const char* path,
                          const char* dest) {
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest...",1364.0,1402.0,1.0,1.0,39.0,45,6,49,14,1,0,5,5,0,0,,0,0,16,8,8,void
277,291880,Enable,1,node.tracing.Agent.Enable,"void node.tracing.Agent.Enable (int,ANY)",tracing\agent.cc,"void Agent::Enable(int id, const std::set<std::string>& categories) {
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",165.0,172.0,1.0,1.0,8.0,7,3,8,5,0,3,2,2,0,0,,0,3,4,2,2,void
278,136236,napi_is_buffer,1,napi_is_buffer,"napi_status napi_is_buffer (napi_env,napi_value,bool*)",node_api.cc,"napi_status NAPI_CDECL napi_is_buffer(napi_env env,
                                      napi_value value,
                                      bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",1094.0,1103.0,1.0,12.0,10.0,10,6,19,7,0,5,1,1,0,5,,0,2,6,3,3,napi_status
279,91183,shouldRunMessageLoop,1,node.inspector.NodeInspectorClient.shouldRunMessageLoop,bool node.inspector.NodeInspectorClient.shouldRunMessageLoop (),inspector_agent.cc,"bool shouldRunMessageLoop() {
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",632.0,639.0,3.0,3.0,8.0,1,1,3,3,0,3,3,3,3,0,,0,3,0,0,0,bool
280,87100,main_thread_,3,node.inspector.MainThreadHandle.main_thread_,,inspector\main_thread_interface.hpp,* main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
281,87101,block_lock_,3,node.inspector.MainThreadHandle.block_lock_,,inspector\main_thread_interface.hpp,block_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
282,87102,next_session_id_,3,node.inspector.MainThreadHandle.next_session_id_,,inspector\main_thread_interface.hpp,next_session_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
283,87103,next_object_id_,3,node.inspector.MainThreadHandle.next_object_id_,,inspector\main_thread_interface.hpp,next_object_id_ = {1},-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
284,91201,runMessageLoop,1,node.inspector.NodeInspectorClient.runMessageLoop,void node.inspector.NodeInspectorClient.runMessageLoop (),inspector_agent.cc,"void runMessageLoop() {
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",641.0,652.0,3.0,3.0,12.0,4,2,6,3,0,6,4,5,2,0,,0,6,0,0,0,void
285,291917,Disable,1,node.tracing.Agent.Disable,"void node.tracing.Agent.Disable (int,ANY)",tracing\agent.cc,"void Agent::Disable(int id, const std::set<std::string>& categories) {
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",174.0,183.0,1.0,1.0,10.0,14,7,16,9,0,3,3,4,0,0,,0,3,4,2,2,void
286,70738,<lambda>3,1,node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3,"ANY node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3 (int,ANY*,uint64_t,Done)",dataqueue\queue.cc,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final ...",247.0,277.0,9.0,9.0,31.0,29,7,31,14,0,4,3,4,0,0,,0,4,8,4,4,ANY
287,91229,currentTimeMS,1,node.inspector.NodeInspectorClient.currentTimeMS,double node.inspector.NodeInspectorClient.currentTimeMS (),inspector_agent.cc,"double currentTimeMS() override {
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",654.0,656.0,3.0,3.0,3.0,3,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,double
288,87143,inspector_agent,1,node.inspector.MainThreadInterface.inspector_agent,Agent node.inspector.MainThreadInterface.inspector_agent (),inspector\main_thread_interface.hpp,"Agent* inspector_agent() {
    return agent_;
  }",82.0,84.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Agent
289,91244,resourceNameToUrl,1,node.inspector.NodeInspectorClient.resourceNameToUrl,unique_ptr<StringBuffer> node.inspector.NodeInspectorClient.resourceNameToUrl (StringView),inspector_agent.cc,"std::unique_ptr<StringBuffer> resourceNameToUrl(
      const StringView& resource_name_view) override {
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",658.0,667.0,3.0,3.0,10.0,7,3,10,6,0,1,2,2,0,1,,0,1,2,1,1,unique_ptr<StringBuffer>
290,136307,napi_get_buffer_info,1,napi_get_buffer_info,"napi_status napi_get_buffer_info (napi_env,napi_value,void**,size_t*)",node_api.cc,"napi_status NAPI_CDECL napi_get_buffer_info(napi_env env,
                                            napi_value value,
                                            void** data,
                                            size_t* length) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",1105.0,1122.0,1.0,12.0,18.0,19,8,24,10,0,5,3,3,0,5,,0,3,8,4,4,napi_status
291,87170,requests_,3,node.inspector.MainThreadInterface.requests_,,inspector\main_thread_interface.hpp,requests_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
292,87171,requests_lock_,3,node.inspector.MainThreadInterface.requests_lock_,,inspector\main_thread_interface.hpp,requests_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
293,291972,CreateTraceConfig,1,node.tracing.Agent.CreateTraceConfig,TraceConfig node.tracing.Agent.CreateTraceConfig (),tracing\agent.cc,"TraceConfig* Agent::CreateTraceConfig() const {
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",185.0,193.0,1.0,1.0,9.0,5,4,7,4,0,2,3,3,2,0,,0,2,0,0,0,TraceConfig
294,87172,dispatching_message_queue_,3,node.inspector.MainThreadInterface.dispatching_message_queue_,,inspector\main_thread_interface.hpp,dispatching_message_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
295,87174,incoming_message_cond_,3,node.inspector.MainThreadInterface.incoming_message_cond_,,inspector\main_thread_interface.hpp,incoming_message_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
296,87173,dispatching_messages_,3,node.inspector.MainThreadInterface.dispatching_messages_,,inspector\main_thread_interface.hpp,dispatching_messages_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
297,87175,agent_,3,node.inspector.MainThreadInterface.agent_,,inspector\main_thread_interface.hpp,* const agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
298,87176,handle_,3,node.inspector.MainThreadInterface.handle_,,inspector\main_thread_interface.hpp,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
299,87177,managed_objects_,3,node.inspector.MainThreadInterface.managed_objects_,,inspector\main_thread_interface.hpp,managed_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
300,91279,env_,3,node.inspector.NodeInspectorClient.env_,,inspector_agent.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
301,91280,is_main_,3,node.inspector.NodeInspectorClient.is_main_,,inspector_agent.cc,is_main_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
302,91281,running_nested_loop_,3,node.inspector.NodeInspectorClient.running_nested_loop_,,inspector_agent.cc,running_nested_loop_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
303,91282,client_,3,node.inspector.NodeInspectorClient.client_,,inspector_agent.cc,client_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
304,91283,timers_,3,node.inspector.NodeInspectorClient.timers_,,inspector_agent.cc,timers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
305,91284,channels_,3,node.inspector.NodeInspectorClient.channels_,,inspector_agent.cc,channels_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
306,91285,next_session_id_,3,node.inspector.NodeInspectorClient.next_session_id_,,inspector_agent.cc,next_session_id_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
307,91286,waiting_for_resume_,3,node.inspector.NodeInspectorClient.waiting_for_resume_,,inspector_agent.cc,waiting_for_resume_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
308,91287,waiting_for_frontend_,3,node.inspector.NodeInspectorClient.waiting_for_frontend_,,inspector_agent.cc,waiting_for_frontend_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
309,91288,waiting_for_sessions_disconnect_,3,node.inspector.NodeInspectorClient.waiting_for_sessions_disconnect_,,inspector_agent.cc,waiting_for_sessions_disconnect_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
310,91289,interface_,3,node.inspector.NodeInspectorClient.interface_,,inspector_agent.cc,interface_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
311,91290,worker_manager_,3,node.inspector.NodeInspectorClient.worker_manager_,,inspector_agent.cc,worker_manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
312,292004,GetEnabledCategories,1,node.tracing.Agent.GetEnabledCategories,string node.tracing.Agent.GetEnabledCategories (),tracing\agent.cc,"std::string Agent::GetEnabledCategories() const {
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",195.0,203.0,1.0,1.0,9.0,4,3,6,3,0,1,3,4,1,0,,0,1,0,0,0,string
313,300197,MakeFilename,1,node.DiagnosticFilename.MakeFilename,"string node.DiagnosticFilename.MakeFilename (uint64_t,char*,char*)",util.cc,"std::string DiagnosticFilename::MakeFilename(
    uint64_t thread_id,
    const char* prefix,
    const char* ext) {
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << st...",298.0,340.0,1.0,1.0,43.0,56,5,37,7,0,1,1,1,0,0,,0,1,6,3,3,string
314,292029,AppendTraceEvent,1,node.tracing.Agent.AppendTraceEvent,void node.tracing.Agent.AppendTraceEvent (TraceObject*),tracing\agent.cc,"void Agent::AppendTraceEvent(TraceObject* trace_event) {
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",205.0,208.0,1.0,1.0,4.0,0,0,1,1,0,1,2,2,1,0,,0,1,2,1,1,void
315,136393,napi_get_node_version,1,napi_get_node_version,"napi_status napi_get_node_version (napi_env,napi_node_version**)",node_api.cc,"napi_status NAPI_CDECL napi_get_node_version(napi_env env,
                                             const napi_node_version** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",1124.0,1132.0,1.0,12.0,9.0,8,7,12,4,0,2,1,1,0,2,,0,0,4,2,2,napi_status
316,292044,AddMetadataEvent,1,node.tracing.Agent.AddMetadataEvent,void node.tracing.Agent.AddMetadataEvent (ANY),tracing\agent.cc,"void Agent::AddMetadataEvent(std::unique_ptr<TraceObject> event) {
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",210.0,213.0,1.0,1.0,4.0,2,1,4,4,0,2,1,1,0,0,,0,2,2,1,1,void
317,103639,ResetFinalizer,1,v8impl.Finalizer.ResetFinalizer,void v8impl.Finalizer.ResetFinalizer (),js_native_api_v8.cc,"void Finalizer::ResetFinalizer() {
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",601.0,605.0,1.0,1.0,5.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,void
318,292061,Flush,1,node.tracing.Agent.Flush,void node.tracing.Agent.Flush (bool),tracing\agent.cc,"void Agent::Flush(bool blocking) {
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",215.0,224.0,1.0,1.0,10.0,0,0,3,3,0,3,3,3,2,0,,0,3,2,1,1,void
319,79081,CollectUVExceptionInfo,1,node.Environment.CollectUVExceptionInfo,"void node.Environment.CollectUVExceptionInfo (Local<Value>,int,char*,char*,char*,char*)",env.cc,"void Environment::CollectUVExceptionInfo(Local<Value> object,
                                         int errorno,
                                         const char* syscall,
                                         const char* message,
                                         const char* path,
                                         const char* dest) {
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",1404.0,1422.0,1.0,1.0,19.0,15,9,20,11,0,1,3,3,0,1,,0,0,12,6,6,void
320,70890,<lambda>10,1,node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10,"ANY node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10 (int,ANY*,uint64_t,Done)",dataqueue\queue.cc,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything ...",417.0,439.0,9.0,9.0,23.0,33,7,34,12,0,4,3,4,1,0,,0,4,8,4,4,ANY
321,292088,AddMetadataEvent,1,node.tracing.TracingController.AddMetadataEvent,"void node.tracing.TracingController.AddMetadataEvent (unsigned char*,char*,int,char**,unsigned char*,uint64_t*,ANY*,unsigned int)",tracing\agent.cc,"void TracingController::AddMetadataEvent(
    const unsigned char* category_group_enabled,
    const char* name,
    int num_args,
    const char** arg_names,
    const unsigned char* arg_types,
    const uint64_t* arg_values,
    std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
    unsigned int flags) {
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",226.0,248.0,1.0,6.0,23.0,19,8,25,14,0,1,2,2,0,0,,0,1,16,8,8,void
322,103675,~RefBase,1,v8impl.RefBase.~RefBase,ANY v8impl.RefBase.~RefBase (),js_native_api_v8.cc,"RefBase::~RefBase() {
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",622.0,627.0,1.0,1.0,6.0,1,1,1,1,0,1,1,1,0,1,,0,0,0,0,0,ANY
323,103710,Ref,1,v8impl.RefBase.Ref,uint32_t v8impl.RefBase.Ref (),js_native_api_v8.cc,"uint32_t RefBase::Ref() {
  return ++refcount_;
}",647.0,649.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint32_t
324,103717,Unref,1,v8impl.RefBase.Unref,uint32_t v8impl.RefBase.Unref (),js_native_api_v8.cc,"uint32_t RefBase::Unref() {
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",651.0,656.0,1.0,1.0,6.0,2,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,uint32_t
325,132396,nm_version,3,node.node_module.nm_version,,node.hpp,nm_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
326,132397,nm_flags,3,node.node_module.nm_flags,,node.hpp,nm_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
327,132398,nm_dso_handle,3,node.node_module.nm_dso_handle,,node.hpp,* nm_dso_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
328,132400,nm_register_func,3,node.node_module.nm_register_func,,node.hpp,nm_register_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
329,132401,nm_context_register_func,3,node.node_module.nm_context_register_func,,node.hpp,nm_context_register_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
330,132402,nm_modname,3,node.node_module.nm_modname,,node.hpp,* nm_modname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
331,103731,RefCount,1,v8impl.RefBase.RefCount,uint32_t v8impl.RefBase.RefCount (),js_native_api_v8.cc,"uint32_t RefBase::RefCount() {
  return refcount_;
}",658.0,660.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint32_t
332,132403,nm_priv,3,node.node_module.nm_priv,,node.hpp,* nm_priv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
333,132405,nm_link,3,node.node_module.nm_link,,node.hpp,* nm_link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
334,132406,node_module_register,1,node.node_module_register,void node.node_module_register (void*),node_binding.cc,"void node_module_register(void* m) {
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",255.0,270.0,12.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
335,103737,Finalize,1,v8impl.RefBase.Finalize,void v8impl.RefBase.Finalize (),js_native_api_v8.cc,"void RefBase::Finalize() {
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime...",662.0,688.0,1.0,1.0,27.0,9,6,15,10,0,3,3,3,1,1,,0,2,0,0,0,void
336,136518,DoThreadPoolWork,1,anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork,void anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork (),node_api.cc,"void DoThreadPoolWork() override { _execute(_env, _data); }",1184.0,1184.0,3.0,61.0,1.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
337,136525,AfterThreadPoolWork,1,anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork,void anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork (int),node_api.cc,"void AfterThreadPoolWork(int status) override {
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",1186.0,1201.0,3.0,3.0,16.0,3,2,3,2,0,3,2,2,1,0,,0,3,2,1,1,void
338,238941,GetCategories,1,node.NodeCategorySet.GetCategories,set<std::string> node.NodeCategorySet.GetCategories (),node_trace_events.cc,const std::set<std::string>& GetCategories() const { return categories_; },41.0,41.0,3.0,76.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,set<std.string>
339,132448,async_id,3,node.async_context.async_id,,node.hpp,async_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
340,238947,MemoryInfo,1,node.NodeCategorySet.MemoryInfo,void node.NodeCategorySet.MemoryInfo (MemoryTracker*),node_trace_events.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""categories"", categories_);
  }",43.0,45.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
341,136548,_env,3,anonymous_namespace_75.uvimpl.Work._env,,node_api.cc,_env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
342,111973,node_api_create_syntax_error,1,node_api_create_syntax_error,"napi_status node_api_create_syntax_error (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_create_syntax_error(napi_env env,
                                                    napi_value code,
                                                    napi_value msg,
                                                    napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1851.0,1869.0,1.0,12.0,19.0,27,9,41,14,0,7,1,1,0,7,,0,3,8,4,4,napi_status
343,136549,_data,3,anonymous_namespace_75.uvimpl.Work._data,,node_api.cc,* _data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
344,136551,_complete,3,anonymous_namespace_75.uvimpl.Work._complete,,node_api.cc,_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
345,136552,napi_create_async_work,1,napi_create_async_work,"napi_status napi_create_async_work (napi_env,napi_value,napi_value,napi_async_execute_callback,napi_async_complete_callback,void*,napi_async_work*)",node_api.cc,"napi_status NAPI_CDECL
napi_create_async_work(napi_env env,
                       napi_value async_resource,
                       napi_value async_resource_name,
                       napi_async_execute_callback execute,
                       napi_async_complete_callback complete,
                       void* data,
                       napi_async_work* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
              ...",1222.0,1256.0,1.0,12.0,35.0,47,10,68,20,0,7,2,2,0,7,,0,0,14,7,7,napi_status
346,71024,<lambda>15,1,node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15,"unique_ptr<Entry> node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15 (uint64_t,uint64_t)",dataqueue\queue.cc,"[&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",637.0,644.0,28.0,5.0,8.0,7,6,7,5,0,1,2,2,0,0,,0,1,4,2,2,unique_ptr<Entry>
347,103793,~Reference,1,v8impl.Reference.~Reference,ANY v8impl.Reference.~Reference (),js_native_api_v8.cc,"Reference::~Reference() {
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",700.0,703.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
348,103801,New,1,v8impl.Reference.New,"Reference v8impl.Reference.New (napi_env,ANY,uint32_t,Ownership,napi_finalize,void*,void*)",js_native_api_v8.cc,"Reference* Reference::New(napi_env env,
                          v8::Local<v8::Value> value,
                          uint32_t initial_refcount,
                          Ownership ownership,
                          napi_finalize finalize_callback,
                          void* finalize_data,
                          void* finalize_hint) {
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",705.0,719.0,1.0,1.0,15.0,1,1,8,8,1,0,1,1,0,0,,0,0,14,7,7,Reference
349,238971,categories_,3,node.NodeCategorySet.categories_,,node_trace_events.cc,categories_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
350,103822,Ref,1,v8impl.Reference.Ref,uint32_t v8impl.Reference.Ref (),js_native_api_v8.cc,"uint32_t Reference::Ref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",721.0,732.0,1.0,1.0,12.0,6,4,7,4,0,3,3,3,2,0,,0,3,0,0,0,uint32_t
351,292262,empty,1,node.tracing.AgentWriterHandle.empty,bool node.tracing.AgentWriterHandle.empty (),tracing\agent.hpp,inline bool empty() const { return agent_ == nullptr; },60.0,60.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
352,103854,Unref,1,v8impl.Reference.Unref,uint32_t v8impl.Reference.Unref (),js_native_api_v8.cc,"uint32_t Reference::Unref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",734.0,746.0,1.0,1.0,13.0,7,4,7,4,0,1,3,3,1,0,,0,1,0,0,0,uint32_t
353,1469,env,3,node.Impl.env,,api\embed_helpers.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
354,292288,agent,1,node.tracing.AgentWriterHandle.agent,Agent node.tracing.AgentWriterHandle.agent (),tracing\agent.hpp,inline Agent* agent() { return agent_; },68.0,68.0,3.0,42.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Agent
355,1481,CommonEnvironmentSetup,1,node.CommonEnvironmentSetup.CommonEnvironmentSetup,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,uint32_t,ANY)",api\embed_helpers.cc,"CommonEnvironmentSetup::CommonEnvironmentSetup(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    std::function<Environment*(const CommonEnvironmentSetup*)> make_env)
    : CommonEnvironmentSetup(platform, errors, nullptr, false, make_env) {}",168.0,172.0,1.0,75.0,5.0,55,10,63,19,0,15,6,7,2,0,,0,15,6,3,3,ANY
356,103889,Get,1,v8impl.Reference.Get,Local<v8::Value> v8impl.Reference.Get (),js_native_api_v8.cc,"v8::Local<v8::Value> Reference::Get() {
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",748.0,754.0,1.0,1.0,7.0,2,1,2,2,0,1,2,2,1,0,,0,1,0,0,0,Local<v8.Value>
357,71126,<lambda>26,1,node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26,ANY node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26 (),dataqueue\queue.cc,[this] { pending_pulls_.pop_front(); },1018.0,1018.0,31.0,68.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
358,292314,agent_,3,node.tracing.AgentWriterHandle.agent_,,tracing\agent.hpp,* agent_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
359,132592,private_,3,node.CallbackScope.private_,,node.hpp,* private_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
360,132593,try_catch_,3,node.CallbackScope.try_catch_,,node.hpp,try_catch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
361,292336,GetTracingController,1,node.tracing.Agent.GetTracingController,TracingController node.tracing.Agent.GetTracingController (),tracing\agent.hpp,"TracingController* GetTracingController() {
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",89.0,93.0,3.0,3.0,5.0,2,2,4,2,0,1,1,1,0,0,,0,1,0,0,0,TracingController
362,103923,Finalize,1,v8impl.Reference.Finalize,void v8impl.Reference.Finalize (),js_native_api_v8.cc,"void Reference::Finalize() {
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",756.0,763.0,1.0,1.0,8.0,2,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
363,103935,SetWeak,1,v8impl.Reference.SetWeak,void v8impl.Reference.SetWeak (),js_native_api_v8.cc,"void Reference::SetWeak() {
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",767.0,773.0,1.0,1.0,7.0,3,1,5,5,0,2,2,2,1,0,,0,2,0,0,0,void
364,292352,kUseDefaultCategories,3,node.tracing.Agent.UseDefaultCategoryMode.kUseDefaultCategories,,tracing\agent.hpp,kUseDefaultCategories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
365,103959,WeakCallback,1,v8impl.Reference.WeakCallback,void v8impl.Reference.WeakCallback (ANY),js_native_api_v8.cc,"void Reference::WeakCallback(const v8::WeakCallbackInfo<Reference>& data) {
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",778.0,783.0,1.0,1.0,6.0,6,3,5,2,0,2,1,1,0,1,,0,1,2,1,1,void
366,132669,env_,3,node.AsyncResource.env_,,node.hpp,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
367,132670,resource_,3,node.AsyncResource.resource_,,node.hpp,resource_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
368,132671,async_context_,3,node.AsyncResource.async_context_,,node.hpp,async_context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
369,292418,thread_,3,node.tracing.Agent.thread_,,tracing\agent.hpp,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
370,292419,tracing_loop_,3,node.tracing.Agent.tracing_loop_,,tracing\agent.hpp,tracing_loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
371,292420,started_,3,node.tracing.Agent.started_,,tracing\agent.hpp,started_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
372,292422,next_writer_id_,3,node.tracing.Agent.next_writer_id_,,tracing\agent.hpp,next_writer_id_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
373,292424,kDefaultHandleId,3,node.tracing.Agent.anonymous_enum_0.kDefaultHandleId,,tracing\agent.hpp,kDefaultHandleId = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
374,292433,categories_,3,node.tracing.Agent.categories_,,tracing\agent.hpp,categories_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
375,292434,writers_,3,node.tracing.Agent.writers_,,tracing\agent.hpp,writers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
376,292435,tracing_controller_,3,node.tracing.Agent.tracing_controller_,,tracing\agent.hpp,tracing_controller_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
377,292436,initialize_writer_mutex_,3,node.tracing.Agent.initialize_writer_mutex_,,tracing\agent.hpp,initialize_writer_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
378,132693,<lambda>1,1,node_napi_env__.EnqueueFinalizer.<lambda>1,ANY node_napi_env__.EnqueueFinalizer.<lambda>1 (ANY*),node_api.cc,"[this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",60.0,64.0,30.0,5.0,5.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
379,292438,initialize_writer_async_,3,node.tracing.Agent.initialize_writer_async_,,tracing\agent.hpp,initialize_writer_async_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
380,292439,to_be_initialized_,3,node.tracing.Agent.to_be_initialized_,,tracing\agent.hpp,to_be_initialized_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
381,292440,metadata_events_mutex_,3,node.tracing.Agent.metadata_events_mutex_,,tracing\agent.hpp,metadata_events_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
382,292441,metadata_events_,3,node.tracing.Agent.metadata_events_,,tracing\agent.hpp,metadata_events_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
383,292437,initialize_writer_condvar_,3,node.tracing.Agent.initialize_writer_condvar_,,tracing\agent.hpp,initialize_writer_condvar_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
384,71262,slice,1,node.anonymous_namespace_12.DataQueueImpl.slice,"shared_ptr<DataQueue> node.anonymous_namespace_12.DataQueueImpl.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::shared_ptr<DataQueue> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uin...",63.0,104.0,3.0,3.0,42.0,43,14,56,16,0,4,8,11,3,0,,0,4,4,2,2,shared_ptr<DataQueue>
385,136798,napi_delete_async_work,1,napi_delete_async_work,"napi_status napi_delete_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_delete_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",1258.0,1266.0,1.0,12.0,9.0,6,5,12,5,0,2,1,1,0,2,,0,0,4,2,2,napi_status
386,132704,<lambda>2,1,node_napi_env__.CallbackIntoModule.<lambda>2,"ANY node_napi_env__.CallbackIntoModule.<lambda>2 (napi_env,ANY)",node_api.cc,"[](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",90.0,110.0,24.0,3.0,21.0,11,5,10,5,0,2,3,3,0,1,,0,1,4,2,2,ANY
387,161411,kEnhance,3,node.EnhanceFatalException.kEnhance,,node_errors.cc,kEnhance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
388,161412,kDontEnhance,3,node.EnhanceFatalException.kDontEnhance,,node_errors.cc,kDontEnhance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
389,161413,ReportFatalException,1,node.ReportFatalException,"void node.ReportFatalException (Environment*,Local<Value>,Local<Message>,EnhanceFatalException)",node_errors.cc,"static void ReportFatalException(Environment* env,
                                 Local<Value> error,
                                 Local<Message> message,
                                 EnhanceFatalException enhance_stack) {
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stde...",362.0,505.0,1.0,1.0,144.0,46,8,51,18,0,1,9,11,0,0,,0,1,8,4,4,void
390,202379,main,1,main,"int main (int,char[]*)",node_main.cc,"int main(int argc, char* argv[]) {
  return node::Start(argc, argv);
}",96.0,98.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
391,296589,msg_size,3,node.SendWrap.msg_size,,udp_wrap.cc,msg_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
392,136846,napi_get_uv_event_loop,1,napi_get_uv_event_loop,"napi_status napi_get_uv_event_loop (napi_env,uv_loop_t**)",node_api.cc,"napi_status NAPI_CDECL napi_get_uv_event_loop(napi_env env, uv_loop_t** loop) {
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",1268.0,1273.0,1.0,12.0,6.0,8,7,11,3,1,3,1,1,0,2,,0,1,4,2,2,napi_status
393,132753,<lambda>3,1,v8impl.anonymous_namespace_10.NewEnv.<lambda>3,ANY v8impl.anonymous_namespace_10.NewEnv.<lambda>3 (void*),node_api.cc,[](void* arg) { static_cast<napi_env>(arg)->Unref(); },193.0,193.0,7.0,60.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
394,132765,<lambda>4,1,v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4,void v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4 (uv_handle_t*),node_api.cc,"[](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",318.0,323.0,11.0,11.0,6.0,6,5,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
395,132788,<lambda>5,1,v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5,ANY v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5 (napi_env),node_api.cc,"[&](napi_env env) { call_js_cb(env, js_callback, context, data); }",416.0,416.0,11.0,76.0,1.0,0,0,4,4,0,2,1,1,0,0,,0,2,2,1,1,ANY
396,136897,napi_queue_async_work,1,napi_queue_async_work,"napi_status napi_queue_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_queue_async_work(napi_env env,
                                             napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",1275.0,1288.0,1.0,12.0,14.0,10,7,19,8,0,3,1,1,0,3,,0,1,4,2,2,napi_status
397,132801,<lambda>6,1,v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6,void v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6 (uv_handle_t*),node_api.cc,"[](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",446.0,451.0,9.0,9.0,6.0,6,5,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
398,292567,<lambda>1,1,node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1,ANY node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1 (uv_handle_t*),tracing\node_trace_buffer.cc,"[](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",187.0,194.0,14.0,5.0,8.0,9,5,7,4,0,4,1,1,0,0,,0,4,2,1,1,ANY
399,132825,<lambda>7,1,napi_module_register_by_symbol.<lambda>7,ANY napi_module_register_by_symbol.<lambda>7 (napi_env),node_api.cc,"[&](napi_env env) {
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",726.0,728.0,23.0,3.0,3.0,2,2,4,4,0,1,1,1,0,1,,0,1,2,1,1,ANY
400,132843,<lambda>8,1,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8 (ANY*),node_api.cc,[env = env_](node::Environment*) { env->Unref(); },801.0,801.0,9.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
401,132854,<lambda>9,1,anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9,ANY anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9 (napi_env),node_api.cc,"[&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    }",1195.0,1197.0,36.0,5.0,3.0,0,0,3,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
402,1786,~CommonEnvironmentSetup,1,node.CommonEnvironmentSetup.~CommonEnvironmentSetup,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup (),api\embed_helpers.cc,"CommonEnvironmentSetup::~CommonEnvironmentSetup() {
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",204.0,235.0,1.0,1.0,32.0,29,8,21,3,0,13,5,7,4,0,,0,13,0,0,0,ANY
403,292603,<lambda>0,1,node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0,ANY node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0 (uv_handle_t*),tracing\node_trace_buffer.cc,"[](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",181.0,195.0,12.0,3.0,15.0,7,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,ANY
404,71421,size,1,node.anonymous_namespace_13.DataQueueImpl.size,optional<uint64_t> node.anonymous_namespace_13.DataQueueImpl.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return size_; },106.0,106.0,3.0,65.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
405,71427,is_idempotent,1,node.anonymous_namespace_14.DataQueueImpl.is_idempotent,bool node.anonymous_namespace_14.DataQueueImpl.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return idempotent_; },108.0,108.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
406,71433,is_capped,1,node.anonymous_namespace_15.DataQueueImpl.is_capped,bool node.anonymous_namespace_15.DataQueueImpl.is_capped (),dataqueue\queue.cc,bool is_capped() const override { return capped_size_.has_value(); },110.0,110.0,3.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
407,136970,napi_cancel_async_work,1,napi_cancel_async_work,"napi_status napi_cancel_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_cancel_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",1290.0,1300.0,1.0,12.0,11.0,11,7,23,8,0,3,1,1,0,3,,0,0,4,2,2,napi_status
408,141069,Pull,1,node.Blob.Reader.Pull,void node.Blob.Reader.Pull (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::Reader::Pull(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = ...",312.0,380.0,1.0,1.0,69.0,45,9,41,18,0,1,2,2,0,0,,0,1,2,1,1,void
409,284433,~ExternString,1,node.anonymous_namespace_2.ExternString.~ExternString,ANY node.anonymous_namespace_2.ExternString.~ExternString (),string_bytes.cc,"~ExternString() override {
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",58.0,61.0,3.0,3.0,4.0,3,3,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
410,71442,append,1,node.anonymous_namespace_16.DataQueueImpl.append,optional<bool> node.anonymous_namespace_16.DataQueueImpl.append (ANY),dataqueue\queue.cc,"std::optional<bool> append(std::unique_ptr<Entry> entry) override {
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",112.0,136.0,3.0,3.0,25.0,20,7,19,8,0,7,5,6,4,0,,0,7,2,1,1,optional<bool>
411,284447,data,1,node.anonymous_namespace_5.ExternString.data,TypeName node.anonymous_namespace_5.ExternString.data (),string_bytes.cc,"const TypeName* data() const override {
    return data_;
  }",63.0,65.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,TypeName
412,292639,InternalTraceBuffer,1,node.tracing.InternalTraceBuffer.InternalTraceBuffer,"ANY node.tracing.InternalTraceBuffer.InternalTraceBuffer (size_t,uint32_t,Agent*)",tracing\node_trace_buffer.cc,"InternalTraceBuffer::InternalTraceBuffer(size_t max_chunks, uint32_t id,
                                         Agent* agent)
    : flushing_(false), max_chunks_(max_chunks),
      agent_(agent), id_(id) {
  chunks_.resize(max_chunks);
}",9.0,14.0,1.0,1.0,6.0,1,1,2,2,0,1,1,1,0,0,,0,1,6,3,3,ANY
413,284453,length,1,node.anonymous_namespace_6.ExternString.length,size_t node.anonymous_namespace_6.ExternString.length (),string_bytes.cc,"size_t length() const override {
    return length_;
  }",67.0,69.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
414,132906,node_napi_env__,1,node_napi_env__.node_napi_env__,"ANY node_napi_env__.node_napi_env__ (ANY,ANY,int32_t)",node_api.cc,"node_napi_env__::node_napi_env__(v8::Local<v8::Context> context,
                                 const std::string& module_filename,
                                 int32_t module_api_version)
    : napi_env__(context, module_api_version), filename(module_filename) {
  CHECK_NOT_NULL(node_env());
}",22.0,27.0,1.0,1.0,6.0,0,0,0,0,0,1,1,1,0,0,,0,0,6,3,3,ANY
415,292651,AddTraceEvent,1,node.tracing.InternalTraceBuffer.AddTraceEvent,TraceObject node.tracing.InternalTraceBuffer.AddTraceEvent (uint64_t*),tracing\node_trace_buffer.cc,"TraceObject* InternalTraceBuffer::AddTraceEvent(uint64_t* handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",16.0,32.0,1.0,1.0,17.0,20,9,21,8,0,10,3,4,3,0,,0,10,2,1,1,TraceObject
416,132915,DeleteMe,1,node_napi_env__.DeleteMe,void node_napi_env__.DeleteMe (),node_api.cc,"void node_napi_env__::DeleteMe() {
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",29.0,33.0,1.0,1.0,5.0,2,2,2,2,0,2,1,1,0,0,,0,1,0,0,0,void
417,132927,can_call_into_js,1,node_napi_env__.can_call_into_js,bool node_napi_env__.can_call_into_js (),node_api.cc,"bool node_napi_env__::can_call_into_js() const {
  return node_env()->can_call_into_js();
}",35.0,37.0,1.0,1.0,3.0,1,1,0,0,0,1,1,1,0,0,,0,0,0,0,0,bool
418,198471,<lambda>0,1,node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0,ANY node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0 (),node_http_parser.cc,"[&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",761.0,766.0,40.0,5.0,6.0,6,4,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
419,137052,napi_create_threadsafe_function,1,napi_create_threadsafe_function,"napi_status napi_create_threadsafe_function (napi_env,napi_value,napi_value,napi_value,size_t,size_t,void*,napi_finalize,void*,napi_threadsafe_function_call_js,napi_threadsafe_function*)",node_api.cc,"napi_status NAPI_CDECL
napi_create_threadsafe_function(napi_env env,
                                napi_value func,
                                napi_value async_resource,
                                napi_value async_resource_name,
                                size_t max_queue_size,
                                size_t initial_thread_count,
                                void* thread_finalize_data,
                                napi_finalize thread_finalize_cb,
                                void* context,
                                napi_threadsafe_function_call_js call_js_cb,
                                napi_threadsafe_function* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, ...",1302.0,1363.0,1.0,12.0,62.0,49,10,77,26,0,7,4,4,0,7,,0,0,22,11,11,napi_status
420,132960,EnqueueFinalizer,1,node_napi_env__.EnqueueFinalizer,void node_napi_env__.EnqueueFinalizer (ANY*),node_api.cc,"void node_napi_env__::EnqueueFinalizer(v8impl::RefTracker* finalizer) {
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",51.0,66.0,1.0,1.0,16.0,6,5,5,4,0,4,2,2,2,0,,0,3,2,1,1,void
421,71531,cap,1,node.anonymous_namespace_17.DataQueueImpl.cap,void node.anonymous_namespace_17.DataQueueImpl.cap (uint64_t),dataqueue\queue.cc,"void cap(uint64_t limit = 0) override {
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",138.0,149.0,3.0,3.0,12.0,5,2,7,3,0,4,3,3,1,0,,0,4,2,1,1,void
422,132986,DrainFinalizerQueue,1,node_napi_env__.DrainFinalizerQueue,void node_napi_env__.DrainFinalizerQueue (),node_api.cc,"void node_napi_env__::DrainFinalizerQueue() {
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",68.0,77.0,1.0,1.0,10.0,7,5,6,2,2,0,2,2,0,0,,0,0,0,0,0,void
423,292733,GetEventByHandle,1,node.tracing.InternalTraceBuffer.GetEventByHandle,TraceObject node.tracing.InternalTraceBuffer.GetEventByHandle (uint64_t),tracing\node_trace_buffer.cc,"TraceObject* InternalTraceBuffer::GetEventByHandle(uint64_t handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",34.0,55.0,1.0,1.0,22.0,13,8,18,10,0,4,4,4,2,0,,0,4,2,1,1,TraceObject
424,71561,maybeCapRemaining,1,node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining,optional<uint64_t> node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining (),dataqueue\queue.cc,"std::optional<uint64_t> maybeCapRemaining() const override {
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",151.0,158.0,3.0,3.0,8.0,11,6,11,5,0,4,2,2,2,0,,0,4,0,0,0,optional<uint64_t>
425,87957,Wire,1,node.inspector.protocol.RuntimeAgent.Wire,void node.inspector.protocol.RuntimeAgent.Wire (UberDispatcher*),inspector\runtime_agent.cc,"void RuntimeAgent::Wire(UberDispatcher* dispatcher) {
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",13.0,16.0,1.0,1.0,4.0,8,5,7,5,0,1,1,1,0,0,,0,1,2,1,1,void
426,133014,trigger_fatal_exception,1,node_napi_env__.trigger_fatal_exception,void node_napi_env__.trigger_fatal_exception (ANY),node_api.cc,"void node_napi_env__::trigger_fatal_exception(v8::Local<v8::Value> local_err) {
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",79.0,83.0,1.0,1.0,5.0,9,4,12,7,2,1,1,1,0,1,,0,0,2,1,1,void
427,87984,notifyWhenWaitingForDisconnect,1,node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect,DispatchResponse node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect (bool),inspector\runtime_agent.cc,"DispatchResponse RuntimeAgent::notifyWhenWaitingForDisconnect(bool enabled) {
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",18.0,21.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,DispatchResponse
428,71603,MemoryInfo,1,node.anonymous_namespace_20.DataQueueImpl.MemoryInfo,void node.anonymous_namespace_20.DataQueueImpl.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",160.0,163.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
429,292795,Flush,1,node.tracing.InternalTraceBuffer.Flush,void node.tracing.InternalTraceBuffer.Flush (bool),tracing\node_trace_buffer.cc,"void InternalTraceBuffer::Flush(bool blocking) {
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",57.0,79.0,1.0,1.0,23.0,16,5,22,10,0,9,5,11,2,0,,0,9,2,1,1,void
430,87997,notifyWaitingForDisconnect,1,node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect,bool node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect (),inspector\runtime_agent.cc,"bool RuntimeAgent::notifyWaitingForDisconnect() {
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",23.0,29.0,1.0,1.0,7.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,bool
431,1981,array_buffer_allocator,1,node.CommonEnvironmentSetup.array_buffer_allocator,shared_ptr<ArrayBufferAllocator> node.CommonEnvironmentSetup.array_buffer_allocator (),api\embed_helpers.cc,"std::shared_ptr<ArrayBufferAllocator>
CommonEnvironmentSetup::array_buffer_allocator() const {
  return impl_->allocator;
}",264.0,267.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<ArrayBufferAllocator>
432,1989,isolate,1,node.CommonEnvironmentSetup.isolate,Isolate node.CommonEnvironmentSetup.isolate (),api\embed_helpers.cc,"Isolate* CommonEnvironmentSetup::isolate() const {
  return impl_->isolate;
}",269.0,271.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Isolate
433,71623,entries_,3,node.anonymous_namespace_5.DataQueueImpl.entries_,,dataqueue\queue.cc,entries_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
434,71624,idempotent_,3,node.anonymous_namespace_5.DataQueueImpl.idempotent_,,dataqueue\queue.cc,idempotent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
435,71625,size_,3,node.anonymous_namespace_5.DataQueueImpl.size_,,dataqueue\queue.cc,size_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
436,71626,capped_size_,3,node.anonymous_namespace_5.DataQueueImpl.capped_size_,,dataqueue\queue.cc,capped_size_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
437,1997,isolate_data,1,node.CommonEnvironmentSetup.isolate_data,IsolateData node.CommonEnvironmentSetup.isolate_data (),api\embed_helpers.cc,"IsolateData* CommonEnvironmentSetup::isolate_data() const {
  return impl_->isolate_data.get();
}",273.0,275.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,IsolateData
438,198613,parser_buffer,3,node.anonymous_namespace_22.BindingData.parser_buffer,,node_http_parser.cc,parser_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
439,198615,MemoryInfo,1,node.anonymous_namespace_24.BindingData.MemoryInfo,void node.anonymous_namespace_24.BindingData.MemoryInfo (MemoryTracker*),node_http_parser.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",103.0,105.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
440,284632,isolate,1,node.anonymous_namespace_12.ExternString.isolate,Isolate node.anonymous_namespace_12.ExternString.isolate (),string_bytes.cc,inline Isolate* isolate() const { return isolate_; },127.0,127.0,3.0,54.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Isolate
441,2008,env,1,node.CommonEnvironmentSetup.env,Environment node.CommonEnvironmentSetup.env (),api\embed_helpers.cc,"Environment* CommonEnvironmentSetup::env() const {
  return impl_->env.get();
}",277.0,279.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,Environment
442,6109,env,3,node.AsyncCleanupHookInfo.env,,api\hooks.cc,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
443,6110,fun,3,node.AsyncCleanupHookInfo.fun,,api\hooks.cc,fun,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
444,6111,arg,3,node.AsyncCleanupHookInfo.arg,,api\hooks.cc,* arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
445,6112,started,3,node.AsyncCleanupHookInfo.started,,api\hooks.cc,started = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
446,6113,self,3,node.AsyncCleanupHookInfo.self,,api\hooks.cc,self,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
447,2019,context,1,node.CommonEnvironmentSetup.context,Local<v8::Context> node.CommonEnvironmentSetup.context (),api\embed_helpers.cc,"v8::Local<v8::Context> CommonEnvironmentSetup::context() const {
  return impl_->main_context.Get(impl_->isolate);
}",281.0,283.0,1.0,1.0,3.0,3,2,2,1,0,2,1,1,0,0,,0,2,0,0,0,Local<v8.Context>
448,6122,info,3,node.ACHHandle.info,,api\hooks.cc,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
449,88044,frontend_,3,node.inspector.protocol.RuntimeAgent.frontend_,,inspector\runtime_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
450,88045,notify_when_waiting_for_disconnect_,3,node.inspector.protocol.RuntimeAgent.notify_when_waiting_for_disconnect_,,inspector\runtime_agent.hpp,notify_when_waiting_for_disconnect_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
451,198638,StringPtr,1,node.anonymous_namespace_26.StringPtr.StringPtr,ANY node.anonymous_namespace_26.StringPtr.StringPtr (),node_http_parser.cc,"StringPtr() {
    on_heap_ = false;
    Reset();
  }",112.0,115.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
452,2033,snapshot_creator,1,node.CommonEnvironmentSetup.snapshot_creator,SnapshotCreator node.CommonEnvironmentSetup.snapshot_creator (),api\embed_helpers.cc,"v8::SnapshotCreator* CommonEnvironmentSetup::snapshot_creator() {
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",285.0,287.0,1.0,1.0,3.0,5,4,2,1,0,2,1,1,0,0,,0,2,0,0,0,SnapshotCreator
453,6130,AddEnvironmentCleanupHook,1,node.AddEnvironmentCleanupHook,"void node.AddEnvironmentCleanupHook (Isolate*,CleanupHook,void*)",node.hpp,"inline AsyncCleanupHookHandle AddEnvironmentCleanupHook(
    v8::Isolate* isolate,
    void (*fun)(void* arg, void (*cb)(void*), void* cbarg),
    void* arg) {
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",1299.0,1305.0,1.0,1.0,7.0,3,3,7,5,3,0,1,1,0,0,,0,0,6,3,3,AsyncCleanupHookHandle
454,284659,isolate_,3,node.anonymous_namespace_1.ExternString.isolate_,,string_bytes.cc,* isolate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
455,284660,data_,3,node.anonymous_namespace_1.ExternString.data_,,string_bytes.cc,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
456,284661,length_,3,node.anonymous_namespace_1.ExternString.length_,,string_bytes.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
457,198651,Save,1,node.anonymous_namespace_30.StringPtr.Save,void node.anonymous_namespace_30.StringPtr.Save (),node_http_parser.cc,"void Save() {
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",126.0,133.0,3.0,3.0,8.0,7,5,10,5,0,6,2,2,2,0,,0,6,0,0,0,void
458,71678,Pull,1,node.anonymous_namespace_31.IdempotentDataQueueReader.Pull,"int node.anonymous_namespace_31.IdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, n...",201.0,306.0,3.0,3.0,106.0,32,7,39,17,0,8,7,9,4,0,,0,8,10,5,5,int
459,133121,BufferFinalizer,1,v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer,"ANY v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer (napi_env,napi_finalize,void*,void*)",node_api.cc,"BufferFinalizer(napi_env env,
                  napi_finalize finalize_callback,
                  void* finalize_data,
                  void* finalize_hint)
      : Finalizer(env, finalize_callback, finalize_data, finalize_hint) {
    env_->Ref();
  }",144.0,150.0,3.0,3.0,7.0,1,1,1,1,0,1,1,1,0,0,,0,0,8,4,4,ANY
460,2050,operator (),1,node.EmbedderSnapshotData.DeleteSnapshotData.operator (),void node.EmbedderSnapshotData.DeleteSnapshotData.operator () (EmbedderSnapshotData*),api\embed_helpers.cc,"void EmbedderSnapshotData::DeleteSnapshotData::operator()(
    const EmbedderSnapshotData* data) const {
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",289.0,297.0,1.0,1.0,9.0,12,5,8,3,0,5,2,2,2,0,,0,5,2,1,1,void
461,6153,RemoveEnvironmentCleanupHook,1,node.RemoveEnvironmentCleanupHook,"void node.RemoveEnvironmentCleanupHook (Isolate*,CleanupHook,void*)",node.hpp,"inline void RemoveEnvironmentCleanupHook(AsyncCleanupHookHandle holder) {
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",1310.0,1312.0,1.0,1.0,3.0,3,3,7,5,3,0,1,1,0,0,,0,0,2,1,1,void
462,88075,get,1,node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get,Frontend node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get (),inspector\tracing_agent.cc,NodeTracing::Frontend* get() { return frontend_.lock().get(); },25.0,25.0,3.0,65.0,1.0,2,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Frontend
463,292875,MakeHandle,1,node.tracing.InternalTraceBuffer.MakeHandle,"uint64_t node.tracing.InternalTraceBuffer.MakeHandle (size_t,uint32_t,size_t)",tracing\node_trace_buffer.cc,"uint64_t InternalTraceBuffer::MakeHandle(
    size_t chunk_index, uint32_t chunk_seq, size_t event_index) const {
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",81.0,85.0,1.0,1.0,5.0,8,5,5,5,0,1,1,1,0,0,,0,1,6,3,3,uint64_t
464,227341,<lambda>0,1,node.sea.anonymous_namespace_13.FindSingleExecutableBlob.<lambda>0,string_view node.sea.anonymous_namespace_13.FindSingleExecutableBlob.<lambda>0 (),node_sea.cc,"[]() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }",113.0,126.0,42.0,3.0,14.0,3,3,2,2,1,0,1,1,0,0,,0,0,0,0,0,string_view
465,133133,~BufferFinalizer,1,v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer,ANY v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer (),node_api.cc,~BufferFinalizer() { env_->Unref(); },152.0,152.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,ANY
466,198678,Reset,1,node.anonymous_namespace_31.StringPtr.Reset,void node.anonymous_namespace_31.StringPtr.Reset (),node_http_parser.cc,"void Reset() {
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",136.0,144.0,3.0,3.0,9.0,4,2,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
467,88087,frontend_,3,node.inspector.protocol.anonymous_namespace_2.DeletableFrontendWrapper.frontend_,,inspector\tracing_agent.cc,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
468,88089,CreateFrontendWrapperRequest,1,node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest,"ANY node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest (int,ANY)",inspector\tracing_agent.cc,"CreateFrontendWrapperRequest(int object_id,
                               std::weak_ptr<NodeTracing::Frontend> frontend)
      : object_id_(object_id) {
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",33.0,37.0,3.0,3.0,5.0,4,4,4,4,0,1,1,1,0,0,,0,1,4,2,2,ANY
469,227359,<lambda>1,1,node.sea.FindSingleExecutableResource.<lambda>1,SeaResource node.sea.FindSingleExecutableResource.<lambda>1 (),node_sea.cc,"[]() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }",137.0,145.0,43.0,3.0,9.0,6,2,7,4,1,0,1,1,0,0,,0,0,0,0,0,SeaResource
470,6176,FinishAsyncCleanupHook,1,node.FinishAsyncCleanupHook,void node.FinishAsyncCleanupHook (void*),api\hooks.cc,"static void FinishAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",134.0,140.0,1.0,1.0,7.0,8,4,6,3,0,3,1,1,0,0,,0,3,2,1,1,void
471,198696,Update,1,node.anonymous_namespace_32.StringPtr.Update,"void node.anonymous_namespace_32.StringPtr.Update (char*,size_t)",node_http_parser.cc,"void Update(const char* str, size_t size) {
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",147.0,165.0,3.0,3.0,19.0,3,3,5,4,0,3,2,2,1,0,,0,3,4,2,2,void
472,88104,Call,1,node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call,void node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",39.0,41.0,3.0,3.0,3.0,2,2,4,4,0,2,1,1,0,0,,0,2,2,1,1,void
473,88119,object_id_,3,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
474,88120,frontend_wrapper_,3,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest.frontend_wrapper_,,inspector\tracing_agent.cc,frontend_wrapper_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
475,6205,RunAsyncCleanupHook,1,node.RunAsyncCleanupHook,void node.RunAsyncCleanupHook (void*),api\hooks.cc,"static void RunAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",142.0,147.0,1.0,1.0,6.0,8,3,7,2,0,4,1,1,0,0,,0,4,2,1,1,void
476,88127,Call,1,node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call,void node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",53.0,55.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
477,88137,object_id_,3,node.inspector.protocol.anonymous_namespace_8.DestroyFrontendWrapperRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
478,88145,Call,1,node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call,void node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",66.0,75.0,3.0,3.0,10.0,8,5,9,5,0,2,3,3,0,0,,0,2,2,1,1,void
479,292950,NodeTraceBuffer,1,node.tracing.NodeTraceBuffer.NodeTraceBuffer,"ANY node.tracing.NodeTraceBuffer.NodeTraceBuffer (size_t,Agent*,uv_loop_t*)",tracing\node_trace_buffer.cc,"NodeTraceBuffer::NodeTraceBuffer(size_t max_chunks,
    Agent* agent, uv_loop_t* tracing_loop)
    : tracing_loop_(tracing_loop),
      buffer1_(max_chunks, 0, agent),
      buffer2_(max_chunks, 1, agent) {
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",98.0,113.0,1.0,1.0,16.0,10,3,14,8,0,8,1,1,0,0,,0,8,6,3,3,ANY
480,198752,ToString,1,node.anonymous_namespace_33.StringPtr.ToString,Local<String> node.anonymous_namespace_33.StringPtr.ToString (Environment*),node_http_parser.cc,"Local<String> ToString(Environment* env) const {
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",168.0,173.0,3.0,3.0,6.0,2,2,4,3,0,3,2,2,1,0,,0,3,2,1,1,Local<String>
481,2147,ToBlob,1,node.EmbedderSnapshotData.ToBlob,vector<char> node.EmbedderSnapshotData.ToBlob (),api\embed_helpers.cc,"std::vector<char> EmbedderSnapshotData::ToBlob() const {
  return impl_->ToBlob();
}",320.0,322.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,vector<char>
482,2156,ToFile,1,node.EmbedderSnapshotData.ToFile,void node.EmbedderSnapshotData.ToFile (FILE*),api\embed_helpers.cc,"void EmbedderSnapshotData::ToFile(FILE* out) const {
  impl_->ToFile(out);
}",324.0,326.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
483,88183,object_id_,3,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
484,88184,message_,3,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest.message_,,inspector\tracing_agent.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
485,92281,<lambda>0,1,node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0,ANY node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0 (uv_async_t*),inspector_io.cc,"[](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",101.0,105.0,44.0,5.0,5.0,5,4,5,4,0,1,1,1,0,0,,0,1,2,1,1,ANY
486,198781,ToTrimmedString,1,node.anonymous_namespace_34.StringPtr.ToTrimmedString,Local<String> node.anonymous_namespace_34.StringPtr.ToTrimmedString (Environment*),node_http_parser.cc,"Local<String> ToTrimmedString(Environment* env) {
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",177.0,182.0,3.0,3.0,6.0,5,5,5,3,0,4,2,2,3,0,,0,4,2,1,1,Local<String>
487,88192,AppendTraceEvent,1,node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent,void node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent (ANY*),inspector\tracing_agent.cc,"void AppendTraceEvent(
      v8::platform::tracing::TraceObject* trace_event) override {
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",88.0,93.0,3.0,3.0,6.0,4,3,6,4,0,4,2,2,1,0,,0,4,2,1,1,void
488,292994,~NodeTraceBuffer,1,node.tracing.NodeTraceBuffer.~NodeTraceBuffer,ANY node.tracing.NodeTraceBuffer.~NodeTraceBuffer (),tracing\node_trace_buffer.cc,"NodeTraceBuffer::~NodeTraceBuffer() {
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",115.0,121.0,1.0,1.0,7.0,3,3,5,5,0,4,2,2,1,0,,0,4,0,0,0,ANY
489,71814,getCurrentReader,1,node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader,Reader node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader (),dataqueue\queue.cc,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",308.0,319.0,3.0,3.0,12.0,13,8,10,5,0,6,2,2,1,0,,0,6,0,0,0,Reader
490,133254,ThreadSafeFunction,1,v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction,"ANY v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction (ANY,ANY,ANY,size_t,void*,size_t,node_napi_env,void*,napi_finalize,napi_threadsafe_function_call_js)",node_api.cc,"ThreadSafeFunction(v8::Local<v8::Function> func,
                     v8::Local<v8::Object> resource,
                     v8::Local<v8::String> name,
                     size_t thread_count_,
                     void* context_,
                     size_t max_queue_size_,
                     node_napi_env env_,
                     void* finalize_data_,
                     napi_finalize finalize_cb_,
                     napi_threadsafe_function_call_js call_js_cb_)
      : AsyncResource(env_->isolate,
                      resource,
                      *v8::String::Utf8Value(env_->isolate, name)),
        thread_count(thread_count_),
        is_closing(false),
        dispatch_state(kDispatchIdle),
        context(context_),
        max_queue_size(max_queue_size_),
        env(env_),
        finalize_data(finalize_data_),
        finalize_cb(finalize_cb_),
        call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),
        handles_closing(false) {
    ref.Reset(env->i...",201.0,227.0,3.0,3.0,27.0,5,2,6,4,0,5,1,1,0,1,,0,4,20,10,10,ANY
491,100486,napi_get_undefined,1,napi_get_undefined,"napi_status napi_get_undefined (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_undefined(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",1914.0,1921.0,1.0,12.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,napi_status
492,92304,<lambda>1,1,node.inspector.RequestQueueData.CloseAndFree.<lambda>1,ANY node.inspector.RequestQueueData.CloseAndFree.<lambda>1 (uv_handle_t*),inspector_io.cc,"[](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",376.0,381.0,12.0,3.0,6.0,7,5,7,5,0,1,1,1,0,0,,0,1,2,1,1,ANY
493,198803,str_,3,node.anonymous_namespace_25.StringPtr.str_,,node_http_parser.cc,* str_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
494,198804,on_heap_,3,node.anonymous_namespace_25.StringPtr.on_heap_,,node_http_parser.cc,on_heap_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
495,198805,size_,3,node.anonymous_namespace_25.StringPtr.size_,,node_http_parser.cc,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
496,293013,AddTraceEvent,1,node.tracing.NodeTraceBuffer.AddTraceEvent,TraceObject node.tracing.NodeTraceBuffer.AddTraceEvent (uint64_t*),tracing\node_trace_buffer.cc,"TraceObject* NodeTraceBuffer::AddTraceEvent(uint64_t* handle) {
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",123.0,133.0,1.0,1.0,11.0,5,5,3,2,0,1,2,2,0,0,,0,1,2,1,1,TraceObject
497,6292,RemoveEnvironmentCleanupHookInternal,1,node.RemoveEnvironmentCleanupHookInternal,void node.RemoveEnvironmentCleanupHookInternal (ACHHandle*),api\hooks.cc,"void RemoveEnvironmentCleanupHookInternal(
    ACHHandle* handle) {
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",164.0,169.0,1.0,1.0,6.0,10,2,4,1,0,4,2,2,1,0,,0,4,2,1,1,void
498,88216,Flush,1,node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush,void node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush (bool),inspector\tracing_agent.cc,"void Flush(bool) override {
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",95.0,107.0,3.0,3.0,13.0,15,8,13,8,0,6,2,2,1,0,,0,6,2,1,1,void
499,202908,ReadHostObject,1,node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject,MaybeLocal<Object> node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject (Isolate*),node_messaging.cc,"MaybeLocal<Object> ReadHostObject(Isolate* isolate) override {
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",103.0,119.0,3.0,3.0,17.0,20,9,23,11,0,4,4,4,2,0,,0,4,2,1,1,MaybeLocal<Object>
500,133289,~ThreadSafeFunction,1,v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction,ANY v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction (),node_api.cc,"~ThreadSafeFunction() override {
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",229.0,232.0,3.0,3.0,4.0,3,2,3,2,0,3,1,1,0,1,,0,2,0,0,0,ANY
501,293037,GetEventByHandle,1,node.tracing.NodeTraceBuffer.GetEventByHandle,TraceObject node.tracing.NodeTraceBuffer.GetEventByHandle (uint64_t),tracing\node_trace_buffer.cc,"TraceObject* NodeTraceBuffer::GetEventByHandle(uint64_t handle) {
  return current_buf_.load()->GetEventByHandle(handle);
}",135.0,137.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,TraceObject
502,96432,tcp,1,node.inspector.TcpHolder.tcp,uv_tcp_t node.inspector.TcpHolder.tcp (),inspector_socket.cc,"uv_tcp_t* tcp() {
    return &tcp_;
  }",30.0,32.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uv_tcp_t
503,71862,current_index_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.current_index_,,dataqueue\queue.cc,current_index_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
504,71863,current_reader_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.current_reader_,,dataqueue\queue.cc,current_reader_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
505,198840,Push,1,node.anonymous_namespace_45.ConnectionsList.Push,void node.anonymous_namespace_45.ConnectionsList.Push (Parser*),node_http_parser.cc,"void Push(Parser* parser) {
      all_connections_.insert(parser);
    }",208.0,210.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
506,71864,ended_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
507,133306,Push,1,v8impl.anonymous_namespace_16.ThreadSafeFunction.Push,"napi_status v8impl.anonymous_namespace_16.ThreadSafeFunction.Push (void*,napi_threadsafe_function_call_mode)",node_api.cc,"napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",236.0,259.0,3.0,3.0,24.0,10,7,12,10,0,8,5,7,6,0,,0,8,4,2,2,napi_status
508,71865,pull_pending_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.pull_pending_,,dataqueue\queue.cc,pull_pending_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
509,96443,From,1,node.inspector.TcpHolder.From,TcpHolder node.inspector.TcpHolder.From (void*),inspector_socket.cc,"static TcpHolder* From(void* handle) {
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",36.0,39.0,3.0,3.0,4.0,4,3,3,3,0,1,1,1,0,0,,0,1,2,1,1,TcpHolder
510,293051,Flush,1,node.tracing.NodeTraceBuffer.Flush,bool node.tracing.NodeTraceBuffer.Flush (),tracing\node_trace_buffer.cc,"bool NodeTraceBuffer::Flush() {
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",139.0,143.0,1.0,1.0,5.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
511,198850,Pop,1,node.anonymous_namespace_46.ConnectionsList.Pop,void node.anonymous_namespace_46.ConnectionsList.Pop (Parser*),node_http_parser.cc,"void Pop(Parser* parser) {
      all_connections_.erase(parser);
    }",212.0,214.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
512,293067,TryLoadAvailableBuffer,1,node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer,bool node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer (),tracing\node_trace_buffer.cc,"bool NodeTraceBuffer::TryLoadAvailableBuffer() {
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",148.0,161.0,1.0,1.0,14.0,13,7,12,6,0,6,3,4,0,0,,0,6,0,0,0,bool
513,198860,PushActive,1,node.anonymous_namespace_47.ConnectionsList.PushActive,void node.anonymous_namespace_47.ConnectionsList.PushActive (Parser*),node_http_parser.cc,"void PushActive(Parser* parser) {
      active_connections_.insert(parser);
    }",216.0,218.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
514,88269,json_writer_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.json_writer_,,inspector\tracing_agent.cc,json_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
515,88270,stream_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.stream_,,inspector\tracing_agent.cc,stream_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
516,88271,frontend_object_id_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.frontend_object_id_,,inspector\tracing_agent.cc,frontend_object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
517,88272,main_thread_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.main_thread_,,inspector\tracing_agent.cc,main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
518,92370,kKill,3,node.inspector.anonymous_namespace_3.TransportAction.kKill,,inspector_io.cc,kKill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
519,92371,kSendMessage,3,node.inspector.anonymous_namespace_3.TransportAction.kSendMessage,,inspector_io.cc,kSendMessage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
520,92372,kStop,3,node.inspector.anonymous_namespace_3.TransportAction.kStop,,inspector_io.cc,kStop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
521,100566,napi_create_string_utf8,1,napi_create_string_utf8,"napi_status napi_create_string_utf8 (napi_env,char*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_string_utf8(napi_env env,
                                               const char* str,
                                               size_t length,
                                               napi_value* result) {
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  });
}",1538.0,1546.0,1.0,12.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,napi_status
522,198870,PopActive,1,node.anonymous_namespace_48.ConnectionsList.PopActive,void node.anonymous_namespace_48.ConnectionsList.PopActive (Parser*),node_http_parser.cc,"void PopActive(Parser* parser) {
      active_connections_.erase(parser);
    }",220.0,222.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
523,88279,~TracingAgent,1,node.inspector.protocol.TracingAgent.~TracingAgent,ANY node.inspector.protocol.TracingAgent.~TracingAgent (),inspector\tracing_agent.cc,"TracingAgent::~TracingAgent() {
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",121.0,125.0,1.0,1.0,5.0,5,4,5,5,0,3,1,1,0,0,,0,3,0,0,0,ANY
524,198881,all_connections_,3,node.anonymous_namespace_39.ConnectionsList.all_connections_,,node_http_parser.cc,all_connections_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
525,198882,active_connections_,3,node.anonymous_namespace_39.ConnectionsList.active_connections_,,node_http_parser.cc,active_connections_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
526,96487,tcp_,3,node.inspector.TcpHolder.tcp_,,inspector_socket.cc,tcp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
527,88298,Wire,1,node.inspector.protocol.TracingAgent.Wire,void node.inspector.protocol.TracingAgent.Wire (UberDispatcher*),inspector\tracing_agent.cc,"void TracingAgent::Wire(UberDispatcher* dispatcher) {
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",127.0,134.0,1.0,1.0,8.0,16,7,14,8,0,6,1,1,0,0,,0,6,2,1,1,void
528,71915,Pull,1,node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull,"int node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::mo...",354.0,467.0,3.0,3.0,114.0,46,7,51,17,0,7,9,14,3,0,,0,7,10,5,5,int
529,198892,on_url,1,node.anonymous_namespace_53.Parser.on_url,"int node.anonymous_namespace_53.Parser.on_url (char*,size_t)",node_http_parser.cc,"int on_url(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",289.0,297.0,3.0,3.0,9.0,3,3,7,4,0,1,2,2,0,0,,0,1,4,2,2,int
530,202991,GetSharedArrayBufferFromId,1,node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId,"MaybeLocal<SharedArrayBuffer> node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId (Isolate*,uint32_t)",node_messaging.cc,"MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(
      Isolate* isolate, uint32_t clone_id) override {
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",121.0,125.0,3.0,3.0,5.0,2,2,4,2,0,2,1,1,0,0,,0,2,4,2,2,MaybeLocal<SharedArrayBuffer>
531,133370,Acquire,1,v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire,napi_status v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire (),node_api.cc,"napi_status Acquire() {
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",261.0,271.0,3.0,3.0,11.0,2,2,4,4,0,3,2,2,1,0,,0,3,0,0,0,napi_status
532,293117,NonBlockingFlushSignalCb,1,node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb,void node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb (uv_async_t*),tracing\node_trace_buffer.cc,"void NodeTraceBuffer::NonBlockingFlushSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",164.0,172.0,1.0,1.0,9.0,19,6,8,2,0,6,3,3,4,0,,0,6,2,1,1,void
533,203007,GetWasmModuleFromId,1,node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId,"MaybeLocal<WasmModuleObject> node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId (Isolate*,uint32_t)",node_messaging.cc,"MaybeLocal<WasmModuleObject> GetWasmModuleFromId(
      Isolate* isolate, uint32_t transfer_id) override {
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",127.0,132.0,3.0,3.0,6.0,3,2,6,4,0,2,1,1,0,0,,0,2,4,2,2,MaybeLocal<WasmModuleObject>
534,198918,on_status,1,node.anonymous_namespace_55.Parser.on_status,"int node.anonymous_namespace_55.Parser.on_status (char*,size_t)",node_http_parser.cc,"int on_status(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",300.0,308.0,3.0,3.0,9.0,3,3,7,4,0,1,2,2,0,0,,0,1,4,2,2,int
535,133388,Release,1,v8impl.anonymous_namespace_19.ThreadSafeFunction.Release,napi_status v8impl.anonymous_namespace_19.ThreadSafeFunction.Release (napi_threadsafe_function_release_mode),node_api.cc,"napi_status Release(napi_threadsafe_function_release_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",273.0,293.0,3.0,3.0,21.0,12,8,15,9,0,9,5,8,5,0,,0,9,2,1,1,napi_status
536,96525,inspector,1,node.inspector.ProtocolHandler.inspector,InspectorSocket node.inspector.ProtocolHandler.inspector (),inspector_socket.cc,"InspectorSocket* inspector() {
    return inspector_;
  }",66.0,68.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,InspectorSocket
537,203028,GetSharedValueConveyor,1,node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor,SharedValueConveyor node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor (Isolate*),node_messaging.cc,"const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate) override {
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",134.0,137.0,3.0,3.0,4.0,3,2,2,1,0,2,1,1,0,0,,0,2,2,1,1,SharedValueConveyor
538,88345,start,1,node.inspector.protocol.TracingAgent.start,DispatchResponse node.inspector.protocol.TracingAgent.start (ANY),inspector\tracing_agent.cc,"DispatchResponse TracingAgent::start(
    std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) {
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
     ...",136.0,165.0,1.0,1.0,30.0,35,10,28,15,0,5,6,6,2,0,,0,5,2,1,1,DispatchResponse
539,227613,FindSingleExecutableBlob,1,node.sea.anonymous_namespace_12.FindSingleExecutableBlob,string_view node.sea.anonymous_namespace_12.FindSingleExecutableBlob (),node_sea.cc,"std::string_view FindSingleExecutableBlob() {
  CHECK(IsSingleExecutable());
  static const std::string_view result = []() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }();
  per_process::Debug(DebugCategory::SEA,
                     ""Found SEA blob %p, size=%zu\n"",
                     result.data(),
                     result.size());
  return result;
}",111.0,132.0,1.0,1.0,22.0,5,2,6,3,0,1,1,1,0,0,,0,1,0,0,0,string_view
540,198944,on_header_field,1,node.anonymous_namespace_57.Parser.on_header_field,"int node.anonymous_namespace_57.Parser.on_header_field (char*,size_t)",node_http_parser.cc,"int on_header_field(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",311.0,335.0,3.0,3.0,25.0,14,8,21,7,0,13,4,5,3,0,,0,13,4,2,2,int
541,203044,deserializer,3,node.worker.anonymous_namespace_1.DeserializerDelegate.deserializer,,node_messaging.cc,* deserializer = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
542,203045,host_objects_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.host_objects_,,node_messaging.cc,& host_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
543,203046,shared_array_buffers_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.shared_array_buffers_,,node_messaging.cc,& shared_array_buffers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
544,203047,wasm_modules_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.wasm_modules_,,node_messaging.cc,& wasm_modules_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
545,203048,shared_value_conveyor_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.shared_value_conveyor_,,node_messaging.cc,& shared_value_conveyor_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
546,96549,inspector_,3,node.inspector.ProtocolHandler.inspector_,,inspector_socket.cc,* const inspector_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
547,96559,from_write_req,1,node.inspector.anonymous_namespace_3.WriteRequest.from_write_req,WriteRequest node.inspector.anonymous_namespace_3.WriteRequest.from_write_req (uv_write_t*),inspector_socket.cc,"static WriteRequest* from_write_req(uv_write_t* req) {
    return node::ContainerOf(&WriteRequest::req, req);
  }",116.0,118.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,WriteRequest
548,203056,Deserialize,1,node.worker.Message.Deserialize,"MaybeLocal<Value> node.worker.Message.Deserialize (Environment*,Local<Context>,Local<Value>*)",node_messaging.cc,"MaybeLocal<Value> Message::Deserialize(Environment* env,
                                       Local<Context> context,
                                       Local<Value>* port_list) {
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      objec...",150.0,243.0,1.0,1.0,94.0,94,13,103,32,0,1,13,21,0,0,,0,1,6,3,3,MaybeLocal<Value>
549,293176,ExitSignalCb,1,node.tracing.NodeTraceBuffer.ExitSignalCb,void node.tracing.NodeTraceBuffer.ExitSignalCb (uv_async_t*),tracing\node_trace_buffer.cc,"void NodeTraceBuffer::ExitSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",175.0,196.0,1.0,1.0,22.0,6,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
550,227641,FindSingleExecutableResource,1,node.sea.FindSingleExecutableResource,SeaResource node.sea.FindSingleExecutableResource (),node_sea.cc,"SeaResource FindSingleExecutableResource() {
  static const SeaResource sea_resource = []() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }();
  return sea_resource;
}",136.0,147.0,1.0,1.0,12.0,1,1,2,1,0,1,1,1,0,0,,0,1,0,0,0,SeaResource
551,137533,node_api_get_module_file_name,1,node_api_get_module_file_name,"napi_status node_api_get_module_file_name (napi_env,char**)",node_api.cc,"napi_status NAPI_CDECL node_api_get_module_file_name(napi_env env,
                                                     const char** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",1407.0,1414.0,1.0,12.0,8.0,7,7,11,3,0,3,1,1,0,2,,0,1,4,2,2,napi_status
552,133440,EmptyQueueAndDelete,1,v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete,void v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete (),node_api.cc,"void EmptyQueueAndDelete() {
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",295.0,300.0,3.0,3.0,6.0,4,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
553,125253,MapStaticCodeToLargePages,1,node.MapStaticCodeToLargePages,int node.MapStaticCodeToLargePages (),large_pages\node_large_page.cc,"int MapStaticCodeToLargePages() {
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",417.0,439.0,1.0,1.0,23.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,int
554,92490,Dispatch,1,node.inspector.anonymous_namespace_8.RequestToServer.Dispatch,void node.inspector.anonymous_namespace_8.RequestToServer.Dispatch (InspectorSocketServer*),inspector_io.cc,"void Dispatch(InspectorSocketServer* server) const {
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",73.0,87.0,3.0,3.0,15.0,9,2,11,7,0,6,4,2,1,0,,0,6,2,1,1,void
555,125259,LargePagesError,1,node.LargePagesError,const char* node.LargePagesError (int),large_pages\node_large_page.cc,"const char* LargePagesError(int status) {
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",441.0,462.0,1.0,1.0,22.0,1,1,4,4,1,0,2,2,0,0,,0,0,2,1,1,const char*
556,162124,~TryCatchScope,1,node.errors.TryCatchScope.~TryCatchScope,ANY node.errors.TryCatchScope.~TryCatchScope (),node_errors.cc,"TryCatchScope::~TryCatchScope() {
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",594.0,606.0,1.0,1.0,13.0,24,9,23,11,0,2,3,4,0,0,,0,2,0,0,0,ANY
557,96588,req,3,node.inspector.anonymous_namespace_1.WriteRequest.req,,inspector_socket.cc,req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
558,96586,handler,3,node.inspector.anonymous_namespace_1.WriteRequest.handler,,inspector_socket.cc,* const handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
559,133466,Init,1,v8impl.anonymous_namespace_22.ThreadSafeFunction.Init,napi_status v8impl.anonymous_namespace_22.ThreadSafeFunction.Init (),node_api.cc,"napi_status Init() {
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",304.0,333.0,3.0,3.0,30.0,17,9,16,9,0,10,4,6,4,0,,0,9,0,0,0,napi_status
560,199009,on_header_value,1,node.anonymous_namespace_60.Parser.on_header_value,"int node.anonymous_namespace_60.Parser.on_header_value (char*,size_t)",node_http_parser.cc,"int on_header_value(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",338.0,356.0,3.0,3.0,19.0,10,6,17,6,0,11,3,3,2,0,,0,11,4,2,2,int
561,293236,IsFull,1,node.tracing.InternalTraceBuffer.IsFull,bool node.tracing.InternalTraceBuffer.IsFull (),tracing\node_trace_buffer.hpp,"bool IsFull() const {
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",27.0,29.0,3.0,3.0,3.0,5,5,4,3,0,4,1,1,0,0,,0,4,0,0,0,bool
562,92535,action_,3,node.inspector.anonymous_namespace_6.RequestToServer.action_,,inspector_io.cc,action_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
563,92536,session_id_,3,node.inspector.anonymous_namespace_6.RequestToServer.session_id_,,inspector_io.cc,session_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
564,92537,message_,3,node.inspector.anonymous_namespace_6.RequestToServer.message_,,inspector_io.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
565,92539,RequestQueueData,1,node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData,ANY node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData (uv_loop_t*),inspector_io.cc,"explicit RequestQueueData(uv_loop_t* loop)
                            : handle_(std::make_shared<RequestQueue>(this)) {
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",99.0,107.0,3.0,3.0,9.0,2,2,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
566,293253,IsFlushing,1,node.tracing.InternalTraceBuffer.IsFlushing,bool node.tracing.InternalTraceBuffer.IsFlushing (),tracing\node_trace_buffer.hpp,"bool IsFlushing() const {
    return flushing_;
  }",30.0,32.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
567,92560,Post,1,node.inspector.anonymous_namespace_13.RequestQueueData.Post,"void node.inspector.anonymous_namespace_13.RequestQueueData.Post (int,TransportAction,ANY)",inspector_io.cc,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",111.0,121.0,3.0,3.0,11.0,6,3,12,10,0,5,2,2,0,0,,0,5,6,3,3,void
568,199061,on_headers_complete,1,node.anonymous_namespace_62.Parser.on_headers_complete,int node.anonymous_namespace_62.Parser.on_headers_complete (),node_http_parser.cc,"int on_headers_complete() {
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // ...",359.0,448.0,3.0,3.0,90.0,82,12,72,36,0,15,8,8,3,0,,0,15,0,0,0,int
569,88474,stop,1,node.inspector.protocol.TracingAgent.stop,DispatchResponse node.inspector.protocol.TracingAgent.stop (),inspector\tracing_agent.cc,"DispatchResponse TracingAgent::stop() {
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",167.0,171.0,1.0,1.0,5.0,3,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,DispatchResponse
570,293275,Capacity,1,node.tracing.InternalTraceBuffer.Capacity,size_t node.tracing.InternalTraceBuffer.Capacity (),tracing\node_trace_buffer.hpp,size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; },39.0,39.0,3.0,80.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,size_t
571,133532,Unref,1,v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref,napi_status v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref (),node_api.cc,"napi_status Unref() {
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",335.0,339.0,3.0,3.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,napi_status
572,293285,mutex_,3,node.tracing.InternalTraceBuffer.mutex_,,tracing\node_trace_buffer.hpp,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
573,293286,flushing_,3,node.tracing.InternalTraceBuffer.flushing_,,tracing\node_trace_buffer.hpp,flushing_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
574,133543,Ref,1,v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref,napi_status v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref (),node_api.cc,"napi_status Ref() {
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",341.0,345.0,3.0,3.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,napi_status
575,293287,max_chunks_,3,node.tracing.InternalTraceBuffer.max_chunks_,,tracing\node_trace_buffer.hpp,max_chunks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
576,293288,agent_,3,node.tracing.InternalTraceBuffer.agent_,,tracing\node_trace_buffer.hpp,* agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
577,293289,chunks_,3,node.tracing.InternalTraceBuffer.chunks_,,tracing\node_trace_buffer.hpp,chunks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
578,293290,total_chunks_,3,node.tracing.InternalTraceBuffer.total_chunks_,,tracing\node_trace_buffer.hpp,total_chunks_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
579,293291,current_chunk_seq_,3,node.tracing.InternalTraceBuffer.current_chunk_seq_,,tracing\node_trace_buffer.hpp,current_chunk_seq_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
580,293292,id_,3,node.tracing.InternalTraceBuffer.id_,,tracing\node_trace_buffer.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
581,72110,getCurrentReader,1,node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader,Reader node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader (),dataqueue\queue.cc,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",469.0,477.0,3.0,3.0,9.0,13,7,8,4,0,4,2,2,1,0,,0,4,0,0,0,Reader
582,227757,flags,3,node.sea.anonymous_namespace_16.SeaConfig.flags,,node_sea.cc,flags = SeaFlags::kDefault,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
583,227756,output_path,3,node.sea.anonymous_namespace_16.SeaConfig.output_path,,node_sea.cc,output_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
584,227755,main_path,3,node.sea.anonymous_namespace_16.SeaConfig.main_path,,node_sea.cc,main_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
585,133554,Context,1,v8impl.anonymous_namespace_27.ThreadSafeFunction.Context,void* v8impl.anonymous_namespace_27.ThreadSafeFunction.Context (),node_api.cc,inline void* Context() { return context; },347.0,347.0,3.0,44.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
586,227767,ParseSingleExecutableConfig,1,node.sea.anonymous_namespace_17.ParseSingleExecutableConfig,optional<SeaConfig> node.sea.anonymous_namespace_17.ParseSingleExecutableConfig (ANY),node_sea.cc,"std::optional<SeaConfig> ParseSingleExecutableConfig(
    const std::string& config_path) {
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" fiel...",188.0,239.0,1.0,1.0,52.0,33,5,39,10,0,5,7,7,2,0,,0,5,2,1,1,optional<SeaConfig>
587,133560,Dispatch,1,v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch,void v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch (),node_api.cc,"void Dispatch() {
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",350.0,369.0,3.0,3.0,20.0,10,5,13,6,0,6,4,5,3,0,,0,6,0,0,0,void
588,92601,Wait,1,node.inspector.anonymous_namespace_14.RequestQueueData.Wait,void node.inspector.anonymous_namespace_14.RequestQueueData.Wait (),inspector_io.cc,"void Wait() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",123.0,128.0,3.0,3.0,6.0,2,1,4,4,0,3,2,2,1,0,,0,3,0,0,0,void
589,92619,SetServer,1,node.inspector.anonymous_namespace_15.RequestQueueData.SetServer,void node.inspector.anonymous_namespace_15.RequestQueueData.SetServer (InspectorSocketServer*),inspector_io.cc,"void SetServer(InspectorSocketServer* server) {
    server_ = server;
  }",130.0,132.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
590,293329,kBufferChunks,3,node.tracing.NodeTraceBuffer.kBufferChunks,,tracing\node_trace_buffer.hpp,kBufferChunks = 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
591,92627,handle,1,node.inspector.anonymous_namespace_16.RequestQueueData.handle,shared_ptr<RequestQueue> node.inspector.anonymous_namespace_16.RequestQueueData.handle (),inspector_io.cc,"std::shared_ptr<RequestQueue> handle() {
    return handle_;
  }",134.0,136.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<RequestQueue>
592,72154,current_reader_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.current_reader_,,dataqueue\queue.cc,current_reader_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
593,72155,ended_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
594,72156,pull_pending_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.pull_pending_,,dataqueue\queue.cc,pull_pending_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
595,92637,GetMessages,1,node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages,MessageQueue node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages (),inspector_io.cc,"MessageQueue GetMessages() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",141.0,146.0,3.0,3.0,6.0,1,1,4,3,0,2,1,1,0,0,,0,2,0,0,0,MessageQueue
596,293344,tracing_loop_,3,node.tracing.NodeTraceBuffer.tracing_loop_,,tracing\node_trace_buffer.hpp,* tracing_loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
597,293345,flush_signal_,3,node.tracing.NodeTraceBuffer.flush_signal_,,tracing\node_trace_buffer.hpp,flush_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
598,133602,DispatchOne,1,v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne,bool v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne (),node_api.cc,"bool DispatchOne() {
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
       ...",371.0,420.0,3.0,3.0,50.0,22,6,20,10,0,8,4,5,2,1,,0,8,0,0,0,bool
599,293347,exited_,3,node.tracing.NodeTraceBuffer.exited_,,tracing\node_trace_buffer.hpp,exited_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
600,293346,exit_signal_,3,node.tracing.NodeTraceBuffer.exit_signal_,,tracing\node_trace_buffer.hpp,exit_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
601,293348,exit_mutex_,3,node.tracing.NodeTraceBuffer.exit_mutex_,,tracing\node_trace_buffer.hpp,exit_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
602,293350,current_buf_,3,node.tracing.NodeTraceBuffer.current_buf_,,tracing\node_trace_buffer.hpp,current_buf_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
603,293351,buffer1_,3,node.tracing.NodeTraceBuffer.buffer1_,,tracing\node_trace_buffer.hpp,buffer1_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
604,293352,buffer2_,3,node.tracing.NodeTraceBuffer.buffer2_,,tracing\node_trace_buffer.hpp,buffer2_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
605,293349,exit_cond_,3,node.tracing.NodeTraceBuffer.exit_cond_,,tracing\node_trace_buffer.hpp,exit_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
606,92652,DoDispatch,1,node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch,void node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch (),inspector_io.cc,"void DoDispatch() {
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",148.0,154.0,3.0,3.0,7.0,2,2,3,2,0,2,3,3,1,0,,0,2,0,0,0,void
607,293364,<lambda>0,1,node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0,ANY node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0 (uv_async_t*),tracing\node_trace_writer.cc,"[](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",20.0,24.0,27.0,3.0,5.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
608,100860,napi_call_function,1,napi_call_function,"napi_status napi_call_function (napi_env,napi_value,napi_value,size_t,napi_value*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_call_function(napi_env env,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
   ...",1978.0,2012.0,1.0,12.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,napi_status
609,92671,handle_,3,node.inspector.anonymous_namespace_9.RequestQueueData.handle_,,inspector_io.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
610,92672,async_,3,node.inspector.anonymous_namespace_9.RequestQueueData.async_,,inspector_io.cc,async_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
611,92673,server_,3,node.inspector.anonymous_namespace_9.RequestQueueData.server_,,inspector_io.cc,* server_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
612,92674,messages_,3,node.inspector.anonymous_namespace_9.RequestQueueData.messages_,,inspector_io.cc,messages_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
613,92675,state_lock_,3,node.inspector.anonymous_namespace_9.RequestQueueData.state_lock_,,inspector_io.cc,state_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
614,92676,incoming_message_cond_,3,node.inspector.anonymous_namespace_9.RequestQueueData.incoming_message_cond_,,inspector_io.cc,incoming_message_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
615,293384,<lambda>1,1,node.tracing.NodeTraceWriter.StartWrite.<lambda>1,ANY node.tracing.NodeTraceWriter.StartWrite.<lambda>1 (uv_fs_t*),tracing\node_trace_writer.cc,"[](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",187.0,191.0,7.0,7.0,5.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
616,92690,Reset,1,node.inspector.RequestQueue.Reset,void node.inspector.RequestQueue.Reset (),inspector_io.cc,"void Reset() {
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",169.0,172.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
617,293403,<lambda>3,1,node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3,ANY node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3 (uv_handle_t*),tracing\node_trace_writer.cc,"[](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",229.0,236.0,18.0,18.0,8.0,9,5,7,4,0,4,1,1,0,0,,0,4,2,1,1,ANY
618,92700,Post,1,node.inspector.RequestQueue.Post,"void node.inspector.RequestQueue.Post (int,TransportAction,ANY)",inspector_io.cc,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",174.0,180.0,3.0,3.0,7.0,3,3,7,6,0,3,2,2,1,0,,0,3,6,3,3,void
619,92726,Expired,1,node.inspector.RequestQueue.Expired,bool node.inspector.RequestQueue.Expired (),inspector_io.cc,"bool Expired() {
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",182.0,185.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
620,293438,<lambda>2,1,node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2,ANY node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2 (uv_handle_t*),tracing\node_trace_writer.cc,"[](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",223.0,237.0,12.0,12.0,15.0,7,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,ANY
621,92737,data_,3,node.inspector.RequestQueue.data_,,inspector_io.cc,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
622,92738,lock_,3,node.inspector.RequestQueue.lock_,,inspector_io.cc,lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
623,92746,SendMessageToFrontend,1,node.inspector.IoSessionDelegate.SendMessageToFrontend,void node.inspector.IoSessionDelegate.SendMessageToFrontend (ANY),inspector_io.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",196.0,199.0,3.0,3.0,4.0,3,2,5,5,0,3,1,1,0,0,,0,3,2,1,1,void
624,227922,GenerateSingleExecutableBlob,1,node.sea.anonymous_namespace_18.GenerateSingleExecutableBlob,ExitCode node.sea.anonymous_namespace_18.GenerateSingleExecutableBlob (SeaConfig),node_sea.cc,"ExitCode GenerateSingleExecutableBlob(const SeaConfig& config) {
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }

  SeaResource sea{config.flags, main_script};

  SeaSerializer serializer;
  serializer.Write(sea);

  uv_buf_t buf = uv_buf_init(serializer.sink.data(), serializer.sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }

  FPrintF(stderr,
          ""Wrote single executable preparation blob to %s\n"",
          config.output_path);
  return ExitCode::kNoFailure;
}",241.0,268.0,1.0,1.0,28.0,26,5,31,9,0,6,3,3,0,0,,0,6,2,1,1,ExitCode
625,92764,request_queue_,3,node.inspector.IoSessionDelegate.request_queue_,,inspector_io.cc,request_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
626,92765,id_,3,node.inspector.IoSessionDelegate.id_,,inspector_io.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
627,88671,env_,3,node.inspector.protocol.TracingAgent.env_,,inspector\tracing_agent.hpp,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
628,88672,main_thread_,3,node.inspector.protocol.TracingAgent.main_thread_,,inspector\tracing_agent.hpp,main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
629,88673,trace_writer_,3,node.inspector.protocol.TracingAgent.trace_writer_,,inspector\tracing_agent.hpp,trace_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
630,88674,frontend_object_id_,3,node.inspector.protocol.TracingAgent.frontend_object_id_,,inspector\tracing_agent.hpp,frontend_object_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
631,88675,frontend_,3,node.inspector.protocol.TracingAgent.frontend_,,inspector\tracing_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
632,293481,InitializeOnThread,1,node.tracing.NodeTraceWriter.InitializeOnThread,void node.tracing.NodeTraceWriter.InitializeOnThread (uv_loop_t*),tracing\node_trace_writer.cc,"void NodeTraceWriter::InitializeOnThread(uv_loop_t* loop) {
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",14.0,30.0,1.0,1.0,17.0,9,3,14,6,0,8,1,1,0,0,,0,8,2,1,1,void
633,133760,Finalize,1,v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize,void v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize (),node_api.cc,"void Finalize() {
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",422.0,429.0,3.0,3.0,8.0,2,1,6,4,0,6,2,2,1,0,,0,6,0,0,0,void
634,92811,AssignServer,1,node.inspector.InspectorIoDelegate.AssignServer,void node.inspector.InspectorIoDelegate.AssignServer (InspectorSocketServer*),inspector_io.cc,"void AssignServer(InspectorSocketServer* server) override {
    request_queue_->SetServer(server);
  }",224.0,226.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
635,293522,WriteSuffix,1,node.tracing.NodeTraceWriter.WriteSuffix,void node.tracing.NodeTraceWriter.WriteSuffix (),tracing\node_trace_writer.cc,"void NodeTraceWriter::WriteSuffix() {
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",32.0,47.0,1.0,1.0,16.0,4,2,7,4,0,4,3,3,1,0,,0,4,0,0,0,void
636,232084,FromEmbedderWrapper,1,node.SnapshotData.FromEmbedderWrapper,SnapshotData node.SnapshotData.FromEmbedderWrapper (EmbedderSnapshotData*),node_snapshotable.cc,"const SnapshotData* SnapshotData::FromEmbedderWrapper(
    const EmbedderSnapshotData* data) {
  return data != nullptr ? data->impl_ : nullptr;
}",616.0,619.0,1.0,1.0,4.0,3,3,2,1,0,1,1,1,0,0,,0,1,2,1,1,SnapshotData
637,72341,Pull,1,node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull,"int node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",579.0,602.0,5.0,5.0,24.0,23,7,21,8,0,2,2,2,1,0,,0,2,10,5,5,int
638,92821,request_queue_,3,node.inspector.InspectorIoDelegate.request_queue_,,inspector_io.cc,request_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
639,133783,CloseHandlesAndMaybeDelete,1,v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete,void v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete (bool),node_api.cc,"void CloseHandlesAndMaybeDelete(bool set_closing = false) {
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",431.0,452.0,3.0,3.0,22.0,10,5,10,8,0,10,4,5,2,0,,0,9,2,1,1,void
640,101029,napi_throw_error,1,napi_throw_error,"napi_status napi_throw_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_throw_error(napi_env env,
                                        const char* code,
                                        const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",2035.0,2051.0,1.0,12.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,napi_status
641,137899,node_env,1,node_napi_env__.node_env,Environment node_napi_env__.node_env (),node_api_internals.hpp,"inline node::Environment* node_env() const {
    return node::Environment::GetCurrent(context());
  }",30.0,32.0,3.0,3.0,3.0,2,1,2,2,10,0,1,1,0,0,,0,0,0,0,0,Environment
642,88749,WorkerCreated,1,node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated,"void node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated (ANY,ANY,bool,ANY)",inspector\worker_agent.cc,"void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target) override {
    workers_->WorkerCreated(title, url, waiting, target);
  }",38.0,43.0,3.0,3.0,6.0,1,1,5,5,0,1,1,1,0,0,,0,1,8,4,4,void
643,293550,~NodeTraceWriter,1,node.tracing.NodeTraceWriter.~NodeTraceWriter,ANY node.tracing.NodeTraceWriter.~NodeTraceWriter (),tracing\node_trace_writer.cc,"NodeTraceWriter::~NodeTraceWriter() {
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",49.0,61.0,1.0,1.0,13.0,7,5,9,7,0,6,3,3,2,0,,0,6,0,0,0,ANY
644,137911,GetFilename,1,node_napi_env__.GetFilename,const char* node_napi_env__.GetFilename (),node_api_internals.hpp,inline const char* GetFilename() const { return filename.c_str(); },33.0,33.0,3.0,69.0,1.0,1,1,1,1,1,1,1,1,0,0,,0,1,0,0,0,const char*
645,88765,workers_,3,node.inspector.protocol.anonymous_namespace_1.AgentWorkerInspectorDelegate.workers_,,inspector\worker_agent.cc,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
646,137920,filename,3,node_napi_env__.filename,,node_api_internals.hpp,filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
647,137921,destructing,3,node_napi_env__.destructing,,node_api_internals.hpp,destructing = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
648,137922,finalization_scheduled,3,node_napi_env__.finalization_scheduled,,node_api_internals.hpp,finalization_scheduled = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
649,199364,on_body,1,node.anonymous_namespace_65.Parser.on_body,"int node.anonymous_namespace_65.Parser.on_body (char*,size_t)",node_http_parser.cc,"int on_body(const char* at, size_t length) {
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",451.0,474.0,3.0,3.0,24.0,25,8,25,14,0,2,4,4,0,0,,0,2,4,2,2,int
650,88773,~ParentInspectorSessionDelegate,1,node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate,ANY node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate (),inspector\worker_agent.cc,"~ParentInspectorSessionDelegate() override {
    workers_->Detached(id_);
  }",55.0,57.0,3.0,3.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
651,133833,Send,1,v8impl.anonymous_namespace_39.ThreadSafeFunction.Send,void v8impl.anonymous_namespace_39.ThreadSafeFunction.Send (),node_api.cc,"void Send() {
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",454.0,462.0,3.0,3.0,9.0,5,5,7,5,0,5,2,2,2,0,,0,5,0,0,0,void
652,88782,SendMessageToFrontend,1,node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend,void node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend (ANY),inspector\worker_agent.cc,"void SendMessageToFrontend(const v8_inspector::StringView& msg) override {
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",59.0,62.0,3.0,3.0,4.0,4,3,7,6,0,2,1,1,0,0,,0,2,2,1,1,void
653,92887,~InspectorIo,1,node.inspector.InspectorIo.~InspectorIo,ANY node.inspector.InspectorIo.~InspectorIo (),inspector_io.cc,"InspectorIo::~InspectorIo() {
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",269.0,273.0,1.0,1.0,5.0,4,4,5,4,0,1,1,1,0,0,,0,1,0,0,0,ANY
654,133858,CallJs,1,v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs,"void v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs (napi_env,napi_value,void*,void*)",node_api.cc,"static void CallJs(napi_env env, napi_value cb, void* context, void* data) {
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",466.0,486.0,3.0,3.0,21.0,11,7,17,6,0,4,4,6,0,4,,0,2,8,4,4,void
655,88803,id_,3,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate.id_,,inspector\worker_agent.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
656,88804,workers_,3,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate.workers_,,inspector\worker_agent.cc,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
657,72425,ended_,3,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
658,162539,TriggerUncaughtException,1,node.errors.TriggerUncaughtException,void node.errors.TriggerUncaughtException (FunctionCallbackInfo<Value>),node_errors.cc,"void TriggerUncaughtException(Isolate* isolate, const v8::TryCatch& try_catch) {
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",1191.0,1210.0,1.0,1.0,20.0,20,8,28,13,1,1,2,2,0,0,,0,1,4,2,2,void
659,92909,StopAcceptingNewConnections,1,node.inspector.InspectorIo.StopAcceptingNewConnections,void node.inspector.InspectorIo.StopAcceptingNewConnections (),inspector_io.cc,"void InspectorIo::StopAcceptingNewConnections() {
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",275.0,277.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
660,137967,<lambda>0,1,node.binding.DLOpen.<lambda>0,ANY node.binding.DLOpen.<lambda>0 (DLib*),node_binding.cc,"[&](DLib* dlib) {
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->...",456.0,554.0,39.0,3.0,99.0,36,10,45,16,0,9,8,12,4,0,,0,9,2,1,1,ANY
661,72433,InMemoryEntry,1,node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry,"ANY node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry (ANY,uint64_t,uint64_t)",dataqueue\queue.cc,"InMemoryEntry(std::shared_ptr<BackingStore> backing_store,
                uint64_t offset,
                uint64_t byte_length)
      : backing_store_(std::move(backing_store)),
        offset_(offset),
        byte_length_(byte_length) {
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",613.0,622.0,3.0,3.0,10.0,2,2,3,3,0,3,1,1,0,0,,0,3,6,3,3,ANY
662,256754,message,3,node.anonymous_namespace_3.CompressionError.message,,node_zlib.cc,* message = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
663,256755,code,3,node.anonymous_namespace_3.CompressionError.code,,node_zlib.cc,* code = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
664,256756,err,3,node.anonymous_namespace_3.CompressionError.err,,node_zlib.cc,err = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
665,256757,IsError,1,node.anonymous_namespace_6.CompressionError.IsError,bool node.anonymous_namespace_6.CompressionError.IsError (),node_zlib.cc,inline bool IsError() const { return code != nullptr; },127.0,127.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
666,293637,OpenNewFileForStreaming,1,node.tracing.NodeTraceWriter.OpenNewFileForStreaming,void node.tracing.NodeTraceWriter.OpenNewFileForStreaming (),tracing\node_trace_writer.cc,"void NodeTraceWriter::OpenNewFileForStreaming() {
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",73.0,97.0,1.0,1.0,25.0,19,8,23,10,0,9,3,3,2,0,,0,9,0,0,0,void
667,88843,Wire,1,node.inspector.protocol.WorkerAgent.Wire,void node.inspector.protocol.WorkerAgent.Wire (UberDispatcher*),inspector\worker_agent.cc,"void WorkerAgent::Wire(UberDispatcher* dispatcher) {
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",84.0,91.0,1.0,1.0,8.0,14,8,14,10,0,4,1,1,0,0,,0,4,2,1,1,void
668,142101,is_eos,1,node.bob.SourceImpl.is_eos,bool node.bob.SourceImpl.is_eos (),node_bob.hpp,bool is_eos() const { return eos_; },90.0,90.0,3.0,38.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
669,133917,AsyncCb,1,v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb,void v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb (uv_async_t*),node_api.cc,"static void AsyncCb(uv_async_t* async) {
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",488.0,492.0,3.0,3.0,5.0,5,4,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
670,72481,slice,1,node.anonymous_namespace_84.InMemoryEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_84.InMemoryEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    ...",634.0,663.0,3.0,3.0,30.0,15,5,25,7,0,7,2,2,0,0,,0,7,4,2,2,unique_ptr<Entry>
671,142116,eos_,3,node.bob.SourceImpl.eos_,,node_bob.hpp,eos_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
672,199464,on_message_complete,1,node.anonymous_namespace_66.Parser.on_message_complete,int node.anonymous_namespace_66.Parser.on_message_complete (),node_http_parser.cc,"int on_message_complete() {
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exce...",477.0,517.0,3.0,3.0,41.0,30,8,26,14,0,8,7,7,3,0,,0,8,0,0,0,int
673,256814,SetMode,1,node.anonymous_namespace_15.ZlibContext.SetMode,void node.anonymous_namespace_15.ZlibContext.SetMode (node_zlib_mode),node_zlib.cc,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },141.0,141.0,3.0,60.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
674,88890,sendMessageToWorker,1,node.inspector.protocol.WorkerAgent.sendMessageToWorker,"DispatchResponse node.inspector.protocol.WorkerAgent.sendMessageToWorker (String,String)",inspector\worker_agent.cc,"DispatchResponse WorkerAgent::sendMessageToWorker(const String& message,
                                                  const String& sessionId) {
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",93.0,97.0,1.0,1.0,5.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,DispatchResponse
675,133950,kDispatchIdle,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchIdle,,node_api.cc,kDispatchIdle = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
676,133951,kDispatchRunning,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchRunning,,node_api.cc,kDispatchRunning = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
677,133952,kDispatchPending,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchPending,,node_api.cc,kDispatchPending = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
678,133953,kMaxIterationCount,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kMaxIterationCount,,node_api.cc,kMaxIterationCount = 1000,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
679,133954,mutex,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.mutex,,node_api.cc,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
680,133955,cond,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.cond,,node_api.cc,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
681,133956,queue,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.queue,,node_api.cc,queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
682,133957,async,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.async,,node_api.cc,async,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
683,133958,thread_count,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.thread_count,,node_api.cc,thread_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
684,133959,is_closing,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.is_closing,,node_api.cc,is_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
685,133960,dispatch_state,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.dispatch_state,,node_api.cc,dispatch_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
686,133961,context,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.context,,node_api.cc,* context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
687,133962,max_queue_size,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.max_queue_size,,node_api.cc,max_queue_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
688,88907,enable,1,node.inspector.protocol.WorkerAgent.enable,DispatchResponse node.inspector.protocol.WorkerAgent.enable (bool),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::enable(bool waitForDebuggerOnStart) {
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",99.0,111.0,1.0,1.0,13.0,11,5,14,9,0,5,3,3,1,0,,0,5,2,1,1,DispatchResponse
689,133964,env,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.env,,node_api.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
690,133963,ref,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.ref,,node_api.cc,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
691,133966,finalize_cb,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.finalize_cb,,node_api.cc,finalize_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
692,133965,finalize_data,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.finalize_data,,node_api.cc,* finalize_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
693,133968,handles_closing,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.handles_closing,,node_api.cc,handles_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
694,256852,MemoryInfo,1,node.anonymous_namespace_20.ZlibContext.MemoryInfo,void node.anonymous_namespace_20.ZlibContext.MemoryInfo (MemoryTracker*),node_zlib.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""dictionary"", dictionary_);
  }",153.0,155.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
695,293720,AppendTraceEvent,1,node.tracing.NodeTraceWriter.AppendTraceEvent,void node.tracing.NodeTraceWriter.AppendTraceEvent (TraceObject*),tracing\node_trace_writer.cc,"void NodeTraceWriter::AppendTraceEvent(TraceObject* trace_event) {
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",99.0,114.0,1.0,1.0,16.0,5,4,8,6,0,6,2,2,1,0,,0,6,2,1,1,void
696,72545,size,1,node.anonymous_namespace_86.InMemoryEntry.size,optional<uint64_t> node.anonymous_namespace_86.InMemoryEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return byte_length_; },665.0,665.0,3.0,72.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
697,133990,AsyncContext,1,v8impl.anonymous_namespace_44.AsyncContext.AsyncContext,"ANY v8impl.anonymous_namespace_44.AsyncContext.AsyncContext (node_napi_env,ANY,ANY,bool)",node_api.cc,"AsyncContext(node_napi_env env,
               v8::Local<v8::Object> resource_object,
               const v8::Local<v8::String> resource_name,
               bool externally_managed_resource)
      : env_(env) {
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",537.0,556.0,3.0,3.0,20.0,13,3,16,12,0,8,2,2,0,1,,0,7,8,4,4,ANY
698,72557,MemoryInfo,1,node.anonymous_namespace_88.InMemoryEntry.MemoryInfo,void node.anonymous_namespace_88.InMemoryEntry.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",669.0,672.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
699,293750,FlushPrivate,1,node.tracing.NodeTraceWriter.FlushPrivate,void node.tracing.NodeTraceWriter.FlushPrivate (),tracing\node_trace_writer.cc,"void NodeTraceWriter::FlushPrivate() {
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",116.0,137.0,1.0,1.0,22.0,9,3,15,10,0,12,2,2,2,0,,0,12,0,0,0,void
700,256892,mode_,3,node.anonymous_namespace_7.ZlibContext.mode_,,node_zlib.cc,mode_ = NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
701,72573,backing_store_,3,node.anonymous_namespace_71.InMemoryEntry.backing_store_,,dataqueue\queue.cc,backing_store_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
702,72574,offset_,3,node.anonymous_namespace_71.InMemoryEntry.offset_,,dataqueue\queue.cc,offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
703,72575,byte_length_,3,node.anonymous_namespace_71.InMemoryEntry.byte_length_,,dataqueue\queue.cc,byte_length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
704,256896,dictionary_,3,node.anonymous_namespace_7.ZlibContext.dictionary_,,node_zlib.cc,dictionary_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
705,88958,disable,1,node.inspector.protocol.WorkerAgent.disable,DispatchResponse node.inspector.protocol.WorkerAgent.disable (),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::disable() {
  event_handle_.reset();
  return DispatchResponse::OK();
}",113.0,116.0,1.0,1.0,4.0,2,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,DispatchResponse
706,72578,DataQueueEntry,1,node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry,ANY node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry (ANY),dataqueue\queue.cc,"explicit DataQueueEntry(std::shared_ptr<DataQueue> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_);
  }",690.0,693.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
707,129927,InitializeOncePerProcessInternal,1,node.InitializeOncePerProcessInternal,"unique_ptr<InitializationResultImpl> node.InitializeOncePerProcessInternal (ANY,ANY)",node.cc,"static std::unique_ptr<InitializationResultImpl>
InitializeOncePerProcessInternal(const std::vector<std::string>& args,
                                 ProcessInitializationFlags::Flags flags =
                                     ProcessInitializationFlags::kNoFlags) {
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_proce...",910.0,1092.0,1.0,21.0,183.0,95,11,63,13,0,2,12,16,0,1,,0,1,4,2,2,unique_ptr<InitializationResultImpl>
708,88971,detach,1,node.inspector.protocol.WorkerAgent.detach,DispatchResponse node.inspector.protocol.WorkerAgent.detach (String),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::detach(const String& sessionId) {
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",118.0,121.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,DispatchResponse
709,203666,ThrowDataCloneError,1,node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError,void node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError (Local<String>),node_messaging.cc,"void ThrowDataCloneError(Local<String> message) override {
    ThrowDataCloneException(context_, message);
  }",316.0,318.0,3.0,3.0,3.0,0,0,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
710,80789,handle_,3,node.anonymous_namespace_1.FSEventWrap.handle_,,fs_event_wrap.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
711,80791,encoding_,3,node.anonymous_namespace_1.FSEventWrap.encoding_,,fs_event_wrap.cc,encoding_ = kDefaultEncoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
712,203674,WriteHostObject,1,node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject,"Maybe<bool> node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject (Isolate*,Local<Object>)",node_messaging.cc,"Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override {
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(...",320.0,343.0,3.0,3.0,24.0,21,8,26,11,0,7,3,3,0,0,,0,7,4,2,2,Maybe<bool>
713,72605,get_reader,1,node.anonymous_namespace_96.DataQueueEntry.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_96.DataQueueEntry.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",701.0,703.0,3.0,3.0,3.0,4,4,3,3,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<DataQueue.Reader>
714,134049,~AsyncContext,1,v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext,ANY v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext (),node_api.cc,"~AsyncContext() {
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",558.0,562.0,3.0,3.0,5.0,4,2,5,5,0,4,1,1,0,1,,0,3,0,0,0,ANY
715,199592,on_chunk_header,1,node.anonymous_namespace_68.Parser.on_chunk_header,int node.anonymous_namespace_68.Parser.on_chunk_header (),node_http_parser.cc,"int on_chunk_header() {
    header_nread_ = 0;
    return 0;
  }",520.0,523.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
716,293801,Flush,1,node.tracing.NodeTraceWriter.Flush,void node.tracing.NodeTraceWriter.Flush (bool),tracing\node_trace_writer.cc,"void NodeTraceWriter::Flush(bool blocking) {
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",139.0,160.0,1.0,1.0,22.0,7,6,13,11,0,7,4,5,2,0,,0,7,2,1,1,void
717,72620,slice,1,node.anonymous_namespace_97.DataQueueEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_97.DataQueueEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",705.0,711.0,3.0,3.0,7.0,10,6,11,7,0,1,2,2,0,0,,0,1,4,2,2,unique_ptr<Entry>
718,142254,persistent_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.persistent_,,node_buffer.cc,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
719,199601,on_chunk_complete,1,node.anonymous_namespace_69.Parser.on_chunk_complete,int node.anonymous_namespace_69.Parser.on_chunk_complete (),node_http_parser.cc,"int on_chunk_complete() {
    header_nread_ = 0;
    return 0;
  }",527.0,530.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
720,142259,env_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.env_,,node_buffer.cc,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
721,134068,MakeCallback,1,v8impl.anonymous_namespace_51.AsyncContext.MakeCallback,"MaybeLocal<v8::Value> v8impl.anonymous_namespace_51.AsyncContext.MakeCallback (ANY,ANY,int,ANY[])",node_api.cc,"inline v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::Object> recv,
      const v8::Local<v8::Function> callback,
      int argc,
      v8::Local<v8::Value> argv[]) {
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",564.0,577.0,3.0,3.0,14.0,2,2,7,7,0,3,1,1,0,1,,0,2,8,4,4,MaybeLocal<v8.Value>
722,256953,SetMode,1,node.anonymous_namespace_31.BrotliContext.SetMode,void node.anonymous_namespace_31.BrotliContext.SetMode (node_zlib_mode),node_zlib.cc,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },189.0,189.0,3.0,60.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
723,256971,mode_,3,node.anonymous_namespace_26.BrotliContext.mode_,,node_zlib.cc,mode_ = NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
724,134091,OpenCallbackScope,1,v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope,napi_callback_scope v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope (),node_api.cc,"inline napi_callback_scope OpenCallbackScope() {
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",579.0,585.0,3.0,3.0,7.0,5,5,4,3,0,1,1,1,0,0,,0,1,0,0,0,napi_callback_scope
725,72658,size,1,node.anonymous_namespace_98.DataQueueEntry.size,optional<uint64_t> node.anonymous_namespace_98.DataQueueEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return data_queue_->size(); },719.0,719.0,3.0,79.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
726,293845,WriteToFile,1,node.tracing.NodeTraceWriter.WriteToFile,"void node.tracing.NodeTraceWriter.WriteToFile (ANY,int)",tracing\node_trace_writer.cc,"void NodeTraceWriter::WriteToFile(std::string&& str, int highest_request_id) {
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",162.0,182.0,1.0,1.0,21.0,21,8,14,7,0,7,4,4,3,0,,0,7,4,2,2,void
727,72667,is_idempotent,1,node.anonymous_namespace_99.DataQueueEntry.is_idempotent,bool node.anonymous_namespace_99.DataQueueEntry.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return data_queue_->is_idempotent(); },727.0,727.0,3.0,78.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
728,134110,EnsureReference,1,v8impl.anonymous_namespace_57.AsyncContext.EnsureReference,void v8impl.anonymous_namespace_57.AsyncContext.EnsureReference (),node_api.cc,"inline void EnsureReference() {
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",587.0,594.0,3.0,3.0,8.0,7,3,5,4,0,3,2,2,1,0,,0,3,0,0,0,void
729,72676,MemoryInfo,1,node.anonymous_namespace_100.DataQueueEntry.MemoryInfo,void node.anonymous_namespace_100.DataQueueEntry.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",729.0,732.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
730,72688,getDataQueue,1,node.anonymous_namespace_101.DataQueueEntry.getDataQueue,DataQueue node.anonymous_namespace_101.DataQueueEntry.getDataQueue (),dataqueue\queue.cc,DataQueue& getDataQueue() { return *data_queue_; },734.0,734.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DataQueue
731,199668,Remove,1,node.anonymous_namespace_73.Parser.Remove,void node.anonymous_namespace_73.Parser.Remove (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Remove(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",556.0,564.0,3.0,3.0,9.0,8,4,7,2,0,3,2,2,1,0,,0,3,2,1,1,void
732,113652,node_api_throw_syntax_error,1,node_api_throw_syntax_error,"napi_status node_api_throw_syntax_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_throw_syntax_error(napi_env env,
                                                   const char* code,
                                                   const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",2089.0,2105.0,1.0,12.0,17.0,46,13,60,19,0,8,5,7,0,8,,0,1,6,3,3,napi_status
733,203765,GetSharedArrayBufferId,1,node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId,"Maybe<uint32_t> node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)",node_messaging.cc,"Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate,
      Local<SharedArrayBuffer> shared_array_buffer) override {
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",345.0,360.0,3.0,3.0,16.0,10,7,14,6,0,4,3,4,2,0,,0,4,4,2,2,Maybe<uint32_t>
734,72699,data_queue_,3,node.anonymous_namespace_90.DataQueueEntry.data_queue_,,dataqueue\queue.cc,data_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
735,134144,node_env,1,v8impl.anonymous_namespace_61.AsyncContext.node_env,Environment v8impl.anonymous_namespace_61.AsyncContext.node_env (),node_api.cc,inline node::Environment* node_env() { return env_->node_env(); },596.0,596.0,3.0,67.0,1.0,1,1,1,1,0,2,1,1,0,0,,0,1,0,0,0,Environment
736,134153,resource,1,v8impl.anonymous_namespace_62.AsyncContext.resource,Local<v8::Object> v8impl.anonymous_namespace_62.AsyncContext.resource (),node_api.cc,"inline v8::Local<v8::Object> resource() {
    return resource_.Get(node_env()->isolate());
  }",597.0,599.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,Local<v8.Object>
737,7183,asyncId,3,node.DestroyParam.asyncId,,async_wrap.cc,asyncId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
738,7184,env,3,node.DestroyParam.env,,async_wrap.cc,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
739,7185,target,3,node.DestroyParam.target,,async_wrap.cc,target,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
740,7186,propBag,3,node.DestroyParam.propBag,,async_wrap.cc,propBag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
741,93204,CloseAndFree,1,node.inspector.RequestQueueData.CloseAndFree,void node.inspector.RequestQueueData.CloseAndFree (RequestQueueData*),inspector_io.cc,"void RequestQueueData::CloseAndFree(RequestQueueData* queue) {
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",372.0,382.0,1.0,1.0,11.0,7,4,3,1,0,3,1,1,0,0,,0,3,2,1,1,void
742,199702,Save,1,node.anonymous_namespace_74.Parser.Save,void node.anonymous_namespace_74.Parser.Save (),node_http_parser.cc,"void Save() {
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",566.0,577.0,3.0,3.0,12.0,10,4,12,7,0,6,3,3,2,0,,0,6,0,0,0,void
743,138263,_register_async_wrap,1,_register_async_wrap,void _register_async_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
744,138267,_register_blob,1,_register_blob,void _register_blob (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
745,138271,_register_block_list,1,_register_block_list,void _register_block_list (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
746,138275,_register_buffer,1,_register_buffer,void _register_buffer (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
747,293925,StartWrite,1,node.tracing.NodeTraceWriter.StartWrite,void node.tracing.NodeTraceWriter.StartWrite (uv_buf_t),tracing\node_trace_writer.cc,"void NodeTraceWriter::StartWrite(uv_buf_t buf) {
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",184.0,193.0,1.0,1.0,10.0,4,3,6,5,0,3,1,1,0,0,,0,3,2,1,1,void
748,138279,_register_builtins,1,_register_builtins,void _register_builtins (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
749,203819,GetWasmModuleTransferId,1,node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId,"Maybe<uint32_t> node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId (Isolate*,Local<WasmModuleObject>)",node_messaging.cc,"Maybe<uint32_t> GetWasmModuleTransferId(
      Isolate* isolate, Local<WasmModuleObject> module) override {
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",362.0,365.0,3.0,3.0,4.0,2,1,2,2,0,1,1,1,0,0,,0,1,4,2,2,Maybe<uint32_t>
750,138283,_register_cares_wrap,1,_register_cares_wrap,void _register_cares_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
751,134189,WeakCallback,1,v8impl.anonymous_namespace_66.AsyncContext.WeakCallback,void v8impl.anonymous_namespace_66.AsyncContext.WeakCallback (ANY),node_api.cc,"static void WeakCallback(const v8::WeakCallbackInfo<AsyncContext>& data) {
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",611.0,615.0,3.0,3.0,5.0,6,3,4,2,0,2,1,1,0,0,,0,2,2,1,1,void
752,138287,_register_config,1,_register_config,void _register_config (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
753,142384,CleanupHook,1,node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook,void node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook (void*),node_buffer.cc,"void CallbackInfo::CleanupHook(void* data) {
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",154.0,169.0,1.0,1.0,16.0,20,8,13,5,0,4,2,2,0,0,,0,4,2,1,1,void
754,138291,_register_constants,1,_register_constants,void _register_constants (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
755,138295,_register_contextify,1,_register_contextify,void _register_contextify (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
756,293947,AfterWrite,1,node.tracing.NodeTraceWriter.AfterWrite,void node.tracing.NodeTraceWriter.AfterWrite (),tracing\node_trace_writer.cc,"void NodeTraceWriter::AfterWrite() {
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",195.0,215.0,1.0,1.0,21.0,24,8,18,9,0,11,3,3,2,0,,0,11,0,0,0,void
757,203835,AdoptSharedValueConveyor,1,node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor,"bool node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor (Isolate*,SharedValueConveyor)",node_messaging.cc,"bool AdoptSharedValueConveyor(Isolate* isolate,
                                SharedValueConveyor&& conveyor) override {
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",367.0,371.0,3.0,3.0,5.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,bool
758,138299,_register_credentials,1,_register_credentials,void _register_credentials (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
759,138303,_register_encoding_binding,1,_register_encoding_binding,void _register_encoding_binding (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
760,138307,_register_errors,1,_register_errors,void _register_errors (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
761,257094,kWriteJSCallback,3,node.anonymous_namespace_49.CompressionStream.InternalFields.kWriteJSCallback,,node_zlib.cc,kWriteJSCallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
762,138311,_register_fs,1,_register_fs,void _register_fs (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
763,134218,env_,3,v8impl.anonymous_namespace_43.AsyncContext.env_,,node_api.cc,env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
764,138315,_register_fs_dir,1,_register_fs_dir,void _register_fs_dir (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
765,134219,async_id_,3,v8impl.anonymous_namespace_43.AsyncContext.async_id_,,node_api.cc,async_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
766,203852,Finish,1,node.worker.anonymous_namespace_21.SerializerDelegate.Finish,Maybe<bool> node.worker.anonymous_namespace_21.SerializerDelegate.Finish (Local<Context>),node_messaging.cc,"Maybe<bool> Finish(Local<Context> context) {
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",373.0,387.0,3.0,3.0,15.0,22,7,26,12,0,5,6,10,3,0,,0,5,2,1,1,Maybe<bool>
767,134220,trigger_async_id_,3,v8impl.anonymous_namespace_43.AsyncContext.trigger_async_id_,,node_api.cc,trigger_async_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
768,134222,lost_reference_,3,v8impl.anonymous_namespace_43.AsyncContext.lost_reference_,,node_api.cc,lost_reference_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
769,134221,resource_,3,v8impl.anonymous_namespace_43.AsyncContext.resource_,,node_api.cc,resource_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
770,138319,_register_fs_event_wrap,1,_register_fs_event_wrap,void _register_fs_event_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
771,134223,napi_module_register_cb,1,napi_module_register_cb,"void napi_module_register_cb (ANY,ANY,ANY,void*)",node_api.cc,"static void napi_module_register_cb(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",641.0,650.0,1.0,1.0,10.0,2,2,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
772,138323,_register_heap_utils,1,_register_heap_utils,void _register_heap_utils (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
773,138327,_register_http2,1,_register_http2,void _register_http2 (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
774,257112,~CompressionStream,1,node.anonymous_namespace_51.CompressionStream.~CompressionStream,ANY node.anonymous_namespace_51.CompressionStream.~CompressionStream (),node_zlib.cc,"~CompressionStream() override {
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",267.0,272.0,3.0,3.0,6.0,1,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
775,138331,_register_http_parser,1,_register_http_parser,void _register_http_parser (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
776,101469,utf8name,3,napi_property_descriptor.utf8name,,js_native_api_types.hpp,* utf8name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
777,80989,Start,1,node.anonymous_namespace_20.FSEventWrap.Start,void node.anonymous_namespace_20.FSEventWrap.Start (FunctionCallbackInfo<Value>),fs_event_wrap.cc,"void FSEventWrap::Start(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(er...",138.0,178.0,1.0,1.0,41.0,47,11,47,14,0,4,5,5,0,0,,0,4,2,1,1,void
778,138335,_register_inspector,1,_register_inspector,void _register_inspector (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
779,101472,getter,3,napi_property_descriptor.getter,,js_native_api_types.hpp,getter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
780,19553,<lambda>0,1,node.crypto.NodeBIO.GetMethod.<lambda>0,ANY node.crypto.NodeBIO.GetMethod.<lambda>0 (),crypto\crypto_bio.cc,"[&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",224.0,234.0,37.0,3.0,11.0,1,1,17,9,1,0,1,1,0,0,,0,0,0,0,0,ANY
781,101473,setter,3,napi_property_descriptor.setter,,js_native_api_types.hpp,setter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
782,101475,attributes,3,napi_property_descriptor.attributes,,js_native_api_types.hpp,attributes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
783,138339,_register_js_stream,1,_register_js_stream,void _register_js_stream (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
784,134240,node_api_context_register_func,1,node_api_context_register_func,"void node_api_context_register_func<int32_t> (ANY,ANY,ANY,void*)",node_api.cc,"static void node_api_context_register_func(v8::Local<v8::Object> exports,
                                           v8::Local<v8::Value> module,
                                           v8::Local<v8::Context> context,
                                           void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",653.0,663.0,1.0,1.0,11.0,1,1,5,5,0,1,1,1,0,1,,0,0,8,4,4,void
785,257126,Close,1,node.anonymous_namespace_53.CompressionStream.Close,void node.anonymous_namespace_53.CompressionStream.Close (),node_zlib.cc,"void Close() {
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",274.0,286.0,3.0,3.0,13.0,5,3,6,5,0,6,2,2,1,0,,0,6,0,0,0,void
786,138343,_register_js_udp_wrap,1,_register_js_udp_wrap,void _register_js_udp_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
787,89192,manager_,3,node.inspector.protocol.WorkerAgent.manager_,,inspector\worker_agent.hpp,manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
788,89193,event_handle_,3,node.inspector.protocol.WorkerAgent.event_handle_,,inspector\worker_agent.hpp,event_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
789,89194,workers_,3,node.inspector.protocol.WorkerAgent.workers_,,inspector\worker_agent.hpp,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
790,138347,_register_messaging,1,_register_messaging,void _register_messaging (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
791,89191,frontend_,3,node.inspector.protocol.WorkerAgent.frontend_,,inspector\worker_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
792,216168,Start,1,node.DelayedTaskScheduler.Start,unique_ptr<uv_thread_t> node.DelayedTaskScheduler.Start (),node_platform.cc,"std::unique_ptr<uv_thread_t> Start() {
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",62.0,72.0,3.0,3.0,11.0,10,7,10,5,0,3,1,1,0,0,,0,3,0,0,0,unique_ptr<uv_thread_t>
793,138351,_register_module_wrap,1,_register_module_wrap,void _register_module_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
794,138355,_register_mksnapshot,1,_register_mksnapshot,void _register_mksnapshot (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
795,72822,slice,1,node.anonymous_namespace_111.FdEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_111.FdEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",815.0,827.0,3.0,3.0,13.0,14,9,21,11,0,8,2,2,0,0,,0,8,4,2,2,unique_ptr<Entry>
796,138359,_register_options,1,_register_options,void _register_options (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
797,138363,_register_os,1,_register_os,void _register_os (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
798,97404,OnEof,1,node.inspector.anonymous_namespace_19.WsHandler.OnEof,void node.inspector.anonymous_namespace_19.WsHandler.OnEof (),inspector_socket.cc,"void OnEof() override {
    tcp_.reset();
    if (dispose_)
      delete this;
  }",382.0,386.0,3.0,3.0,5.0,2,2,2,2,0,1,2,2,1,0,,0,1,0,0,0,void
799,138367,_register_performance,1,_register_performance,void _register_performance (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
800,138371,_register_permission,1,_register_permission,void _register_permission (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
801,273541,Spawn,1,node.anonymous_namespace_8.ProcessWrap.Spawn,void node.anonymous_namespace_8.ProcessWrap.Spawn (FunctionCallbackInfo<Value>),process_wrap.cc,"static void Spawn(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToL...",146.0,291.0,3.0,3.0,146.0,210,16,197,45,0,3,17,21,0,0,,0,3,2,1,1,void
802,89221,Call,1,node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call,void node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call (MainThreadInterface*),inspector\worker_inspector.cc,"void Call(MainThreadInterface* thread) override {
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",22.0,25.0,3.0,3.0,4.0,4,2,6,5,0,3,1,1,0,0,,0,3,2,1,1,void
803,138375,_register_pipe_wrap,1,_register_pipe_wrap,void _register_pipe_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
804,7304,RegisterDestroyHook,1,node.RegisterDestroyHook,void node.RegisterDestroyHook (FunctionCallbackInfo<Value>),async_wrap.cc,"static void RegisterDestroyHook(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",231.0,246.0,1.0,1.0,16.0,37,8,26,7,0,6,2,2,0,0,,0,6,2,1,1,void
805,138379,_register_process_wrap,1,_register_process_wrap,void _register_process_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
806,100774,napi_set_named_property,1,napi_set_named_property,"napi_status napi_set_named_property (napi_env,napi_value,char*,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_set_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",1162.0,1183.0,1.0,12.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,napi_status
807,216207,PostDelayedTask,1,node.DelayedTaskScheduler.PostDelayedTask,"void node.DelayedTaskScheduler.PostDelayedTask (ANY,double)",node_platform.cc,"void PostDelayedTask(std::unique_ptr<Task> task, double delay_in_seconds) {
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",74.0,78.0,3.0,3.0,5.0,8,6,7,6,0,2,1,1,0,0,,0,2,4,2,2,void
808,138383,_register_process_methods,1,_register_process_methods,void _register_process_methods (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
809,294034,ExitSignalCb,1,node.tracing.NodeTraceWriter.ExitSignalCb,void node.tracing.NodeTraceWriter.ExitSignalCb (uv_async_t*),tracing\node_trace_writer.cc,"void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Sig...",218.0,238.0,1.0,1.0,21.0,6,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
810,138387,_register_report,1,_register_report,void _register_report (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
811,138391,_register_sea,1,_register_sea,void _register_sea (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
812,138395,_register_serdes,1,_register_serdes,void _register_serdes (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
813,138399,_register_signal_wrap,1,_register_signal_wrap,void _register_signal_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
814,199841,Initialize,1,node.anonymous_namespace_77.Parser.Initialize,void node.anonymous_namespace_77.Parser.Initialize (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Initialize(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || ...",604.0,666.0,3.0,3.0,63.0,70,13,56,13,0,4,6,6,0,0,,0,4,2,1,1,void
815,138403,_register_spawn_sync,1,_register_spawn_sync,void _register_spawn_sync (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
816,134310,napi_module_register_by_symbol,1,napi_module_register_by_symbol,"void napi_module_register_by_symbol (ANY,ANY,ANY,napi_addon_register_func,int32_t)",node_api.cc,"void napi_module_register_by_symbol(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    napi_addon_register_func init,
                                    int32_t module_api_version) {
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
 ...",691.0,738.0,1.0,1.0,48.0,39,9,45,18,2,4,4,4,1,4,,0,3,10,5,5,void
817,138407,_register_stream_pipe,1,_register_stream_pipe,void _register_stream_pipe (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
818,203944,AddHostObject,1,node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject,void node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject (BaseObjectPtr<BaseObject>),node_messaging.cc,"inline void AddHostObject(BaseObjectPtr<BaseObject> host_object) {
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",389.0,393.0,3.0,3.0,5.0,2,1,5,5,0,2,1,1,0,0,,0,2,2,1,1,void
819,138411,_register_stream_wrap,1,_register_stream_wrap,void _register_stream_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
820,216235,Stop,1,node.DelayedTaskScheduler.Stop,void node.DelayedTaskScheduler.Stop (),node_platform.cc,"void Stop() {
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",80.0,83.0,3.0,3.0,4.0,5,4,4,4,0,2,1,1,0,0,,0,2,0,0,0,void
821,72877,size,1,node.anonymous_namespace_112.FdEntry.size,optional<uint64_t> node.anonymous_namespace_112.FdEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return end_ - start_; },829.0,829.0,3.0,73.0,1.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,optional<uint64_t>
822,138415,_register_string_decoder,1,_register_string_decoder,void _register_string_decoder (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
823,93362,SendMessageToFrontend,1,node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend,void node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend (ANY),inspector_js_api.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message)
        override {
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",74.0,84.0,5.0,5.0,11.0,13,7,15,9,0,3,2,2,0,0,,0,3,2,1,1,void
824,138419,_register_symbols,1,_register_symbols,void _register_symbols (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
825,89268,id_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.id_,,inspector\worker_inspector.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
826,89269,info_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.info_,,inspector\worker_inspector.cc,info_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
827,89270,waiting_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.waiting_,,inspector\worker_inspector.cc,waiting_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
828,138423,_register_task_queue,1,_register_task_queue,void _register_task_queue (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
829,89271,Report,1,node.inspector.anonymous_namespace_5.Report,"void node.inspector.anonymous_namespace_5.Report (ANY,WorkerInfo,bool)",inspector\worker_inspector.cc,"void Report(const std::unique_ptr<WorkerDelegate>& delegate,
            const WorkerInfo& info, bool waiting) {
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",39.0,43.0,1.0,1.0,5.0,5,2,6,3,0,4,2,2,1,0,,0,4,6,3,3,void
830,142521,HasInstance,1,node.Buffer.HasInstance,bool node.Buffer.HasInstance (Local<Value>),node_buffer.cc,"bool HasInstance(Local<Object> obj) {
  return obj->IsArrayBufferView();
}",242.0,244.0,1.0,1.0,3.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,bool
831,203961,AddNestedHostObjects,1,node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects,Maybe<bool> node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects (),node_messaging.cc,"inline Maybe<bool> AddNestedHostObjects() {
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",398.0,412.0,3.0,3.0,15.0,17,9,17,7,0,5,5,9,5,0,,0,5,0,0,0,Maybe<bool>
832,138427,_register_tcp_wrap,1,_register_tcp_wrap,void _register_tcp_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
833,97465,Shutdown,1,node.inspector.anonymous_namespace_24.WsHandler.Shutdown,void node.inspector.anonymous_namespace_24.WsHandler.Shutdown (),inspector_socket.cc,"void Shutdown() override {
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",406.0,413.0,3.0,3.0,8.0,1,1,2,2,0,1,2,2,0,0,,0,1,0,0,0,void
834,216253,Run,1,node.DelayedTaskScheduler.Run,void node.DelayedTaskScheduler.Run (),node_platform.cc,"void Run() {
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",86.0,97.0,3.0,3.0,12.0,10,3,9,4,0,8,1,1,0,0,,0,8,0,0,0,void
835,72891,env,1,node.anonymous_namespace_114.FdEntry.env,Environment node.anonymous_namespace_114.FdEntry.env (),dataqueue\queue.cc,Environment* env() const { return env_; },833.0,833.0,3.0,43.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Environment
836,138431,_register_timers,1,_register_timers,void _register_timers (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
837,72898,path_,3,node.anonymous_namespace_105.FdEntry.path_,,dataqueue\queue.cc,path_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
838,72899,stat_,3,node.anonymous_namespace_105.FdEntry.stat_,,dataqueue\queue.cc,stat_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
839,72900,start_,3,node.anonymous_namespace_105.FdEntry.start_,,dataqueue\queue.cc,start_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
840,72901,end_,3,node.anonymous_namespace_105.FdEntry.end_,,dataqueue\queue.cc,end_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
841,72902,is_modified,1,node.anonymous_namespace_115.FdEntry.is_modified,bool node.anonymous_namespace_115.FdEntry.is_modified (uv_stat_t),dataqueue\queue.cc,"bool is_modified(const uv_stat_t& other) {
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",846.0,849.0,3.0,3.0,4.0,9,3,4,2,0,2,1,1,0,0,,0,2,2,1,1,bool
842,138435,_register_trace_events,1,_register_trace_events,void _register_trace_events (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
843,138439,_register_tty_wrap,1,_register_tty_wrap,void _register_tty_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
844,97481,OnCloseFrameWritten,1,node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten,"void node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten (uv_write_t*,int)",inspector_socket.cc,"static void OnCloseFrameWritten(uv_write_t* req, int status) {
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",418.0,424.0,3.0,3.0,7.0,9,5,10,5,0,2,1,1,0,0,,0,2,4,2,2,void
845,138443,_register_types,1,_register_types,void _register_types (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
846,142541,Data,1,node.Buffer.Data,char* node.Buffer.Data (Local<Value>),node_buffer.cc,"char* Data(Local<Object> obj) {
  return Data(obj.As<Value>());
}",254.0,256.0,1.0,1.0,3.0,10,7,7,4,3,0,1,1,0,0,,0,0,2,1,1,char*
847,138447,_register_udp_wrap,1,_register_udp_wrap,void _register_udp_wrap (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
848,294097,kTracesPerFile,3,node.tracing.NodeTraceWriter.kTracesPerFile,,tracing\node_trace_writer.hpp,kTracesPerFile = 1 << 19,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
849,294099,str,3,node.tracing.NodeTraceWriter.WriteRequest.str,,tracing\node_trace_writer.hpp,str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
850,138451,_register_url,1,_register_url,void _register_url (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
851,138455,_register_util,1,_register_util,void _register_util (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
852,89303,Call,1,node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call,void node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call (MainThreadInterface*),inspector\worker_inspector.cc,"void Call(MainThreadInterface* thread) override {
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",49.0,51.0,3.0,3.0,3.0,3,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
853,138459,_register_uv,1,_register_uv,void _register_uv (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
854,138463,_register_v8,1,_register_v8,void _register_v8 (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
855,138467,_register_wasi,1,_register_wasi,void _register_wasi (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
856,138471,_register_wasm_web_api,1,_register_wasm_web_api,void _register_wasm_web_api (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
857,216295,FlushTasks,1,node.DelayedTaskScheduler.FlushTasks,void node.DelayedTaskScheduler.FlushTasks (uv_async_t*),node_platform.cc,"static void FlushTasks(uv_async_t* flush_tasks) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",99.0,104.0,3.0,3.0,6.0,10,6,7,6,0,2,2,2,1,0,,0,2,2,1,1,void
858,89319,worker_id_,3,node.inspector.anonymous_namespace_6.WorkerFinishedRequest.worker_id_,,inspector\worker_inspector.cc,worker_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
859,93418,env_,3,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate.env_,,inspector_js_api.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
860,93419,connection_,3,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate.connection_,,inspector_js_api.cc,connection_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
861,93420,JSBindingsConnection,1,node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection,"ANY node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection (Environment*,Local<Object>,Local<Function>)",inspector_js_api.cc,"JSBindingsConnection(Environment* env,
                       Local<Object> wrap,
                       Local<Function> callback)
                       : AsyncWrap(env, wrap, PROVIDER_INSPECTORJSBINDING),
                         callback_(env->isolate(), callback) {
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",91.0,99.0,3.0,3.0,9.0,9,7,8,6,0,1,1,1,0,0,,0,1,6,3,3,ANY
862,138475,_register_watchdog,1,_register_watchdog,void _register_watchdog (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
863,97515,WaitForCloseReply,1,node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply,void node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply (),inspector_socket.cc,"void WaitForCloseReply() {
    OnCloseReceived = &WsHandler::OnEof;
  }",426.0,428.0,3.0,3.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
864,138479,_register_worker,1,_register_worker,void _register_worker (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
865,89329,~ParentInspectorHandle,1,node.inspector.ParentInspectorHandle.~ParentInspectorHandle,ANY node.inspector.ParentInspectorHandle.~ParentInspectorHandle (),inspector\worker_inspector.cc,"ParentInspectorHandle::~ParentInspectorHandle() {
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",70.0,73.0,1.0,1.0,4.0,5,5,5,5,0,2,1,1,0,0,,0,2,0,0,0,ANY
866,138483,_register_zlib,1,_register_zlib,void _register_zlib (),node_binding.cc,void void ();,100.0,100.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
867,294133,tracing_loop_,3,node.tracing.NodeTraceWriter.tracing_loop_,,tracing\node_trace_writer.hpp,* tracing_loop_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
868,294134,flush_signal_,3,node.tracing.NodeTraceWriter.flush_signal_,,tracing\node_trace_writer.hpp,flush_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
869,294135,exit_signal_,3,node.tracing.NodeTraceWriter.exit_signal_,,tracing\node_trace_writer.hpp,exit_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
870,294136,stream_mutex_,3,node.tracing.NodeTraceWriter.stream_mutex_,,tracing\node_trace_writer.hpp,stream_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
871,294137,request_mutex_,3,node.tracing.NodeTraceWriter.request_mutex_,,tracing\node_trace_writer.hpp,request_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
872,294138,request_cond_,3,node.tracing.NodeTraceWriter.request_cond_,,tracing\node_trace_writer.hpp,request_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
873,142587,Length,1,node.Buffer.Length,size_t node.Buffer.Length (Local<Value>),node_buffer.cc,"size_t Length(Local<Object> obj) {
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",266.0,270.0,1.0,1.0,5.0,6,5,6,4,1,0,1,1,0,0,,0,0,2,1,1,size_t
874,294139,exit_cond_,3,node.tracing.NodeTraceWriter.exit_cond_,,tracing\node_trace_writer.hpp,exit_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
875,294140,fd_,3,node.tracing.NodeTraceWriter.fd_,,tracing\node_trace_writer.hpp,fd_ = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
876,294141,write_req_,3,node.tracing.NodeTraceWriter.write_req_,,tracing\node_trace_writer.hpp,write_req_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
877,294143,num_write_requests_,3,node.tracing.NodeTraceWriter.num_write_requests_,,tracing\node_trace_writer.hpp,num_write_requests_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
878,294144,highest_request_id_completed_,3,node.tracing.NodeTraceWriter.highest_request_id_completed_,,tracing\node_trace_writer.hpp,highest_request_id_completed_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
879,294142,write_req_queue_,3,node.tracing.NodeTraceWriter.write_req_queue_,,tracing\node_trace_writer.hpp,write_req_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
880,294145,total_traces_,3,node.tracing.NodeTraceWriter.total_traces_,,tracing\node_trace_writer.hpp,total_traces_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
881,204034,serializer,3,node.worker.anonymous_namespace_12.SerializerDelegate.serializer,,node_messaging.cc,* serializer = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
882,204035,WriteHostObject,1,node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject,Maybe<bool> node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject (BaseObjectPtr<BaseObject>),node_messaging.cc,"Maybe<bool> WriteHostObject(BaseObjectPtr<BaseObject> host_object) {
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",417.0,443.0,3.0,3.0,27.0,23,6,31,11,0,10,6,7,3,0,,0,10,2,1,1,Maybe<bool>
883,89346,WorkerStarted,1,node.inspector.ParentInspectorHandle.WorkerStarted,"void node.inspector.ParentInspectorHandle.WorkerStarted (ANY,bool)",inspector\worker_inspector.cc,"void ParentInspectorHandle::WorkerStarted(
    std::shared_ptr<MainThreadHandle> worker_thread, bool waiting) {
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",75.0,80.0,1.0,1.0,6.0,3,3,9,9,0,4,1,1,0,0,,0,4,4,2,2,void
884,294148,stream_,3,node.tracing.NodeTraceWriter.stream_,,tracing\node_trace_writer.hpp,stream_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
885,294149,json_trace_writer_,3,node.tracing.NodeTraceWriter.json_trace_writer_,,tracing\node_trace_writer.hpp,json_trace_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
886,72961,Create,1,node.anonymous_namespace_119.FdEntry.ReaderImpl.Create,shared_ptr<ReaderImpl> node.anonymous_namespace_119.FdEntry.ReaderImpl.Create (FdEntry*),dataqueue\queue.cc,"static std::shared_ptr<ReaderImpl> Create(FdEntry* entry) {
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",868.0,886.0,5.0,5.0,19.0,31,10,27,12,0,4,2,2,0,0,,0,4,2,1,1,shared_ptr<ReaderImpl>
887,97540,CloseFrameReceived,1,node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived,void node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived (),inspector_socket.cc,"void CloseFrameReceived() {
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",435.0,438.0,3.0,3.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
888,294150,exited_,3,node.tracing.NodeTraceWriter.exited_,,tracing\node_trace_writer.hpp,exited_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
889,294146,file_num_,3,node.tracing.NodeTraceWriter.file_num_,,tracing\node_trace_writer.hpp,file_num_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
890,294147,log_file_pattern_,3,node.tracing.NodeTraceWriter.log_file_pattern_,,tracing\node_trace_writer.hpp,log_file_pattern_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
891,93451,OnMessage,1,node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage,void node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage (Local<Value>),inspector_js_api.cc,"void OnMessage(Local<Value> value) {
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",101.0,103.0,3.0,3.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
892,81166,OnEvent,1,node.anonymous_namespace_22.FSEventWrap.OnEvent,"void node.anonymous_namespace_22.FSEventWrap.OnEvent (uv_fs_event_t*,char*,int,int)",fs_event_wrap.cc,"void FSEventWrap::OnEvent(uv_fs_event_t* handle, const char* filename,
    int events, int status) {
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> ...",181.0,238.0,1.0,1.0,58.0,42,10,48,17,0,1,4,5,0,0,,0,1,8,4,4,void
893,216335,Run,1,node.DelayedTaskScheduler.StopTask.Run,void node.DelayedTaskScheduler.StopTask.Run (),node_platform.cc,"void Run() override {
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",110.0,118.0,5.0,5.0,9.0,4,3,3,2,0,2,3,3,1,0,,0,2,0,0,0,void
894,3352,Create,1,node.ArrayBufferAllocator.Create,unique_ptr<ArrayBufferAllocator> node.ArrayBufferAllocator.Create (bool),api\environment.cc,"std::unique_ptr<ArrayBufferAllocator> ArrayBufferAllocator::Create(bool debug) {
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",216.0,221.0,1.0,1.0,6.0,4,3,3,3,1,0,2,2,0,0,,0,0,2,1,1,unique_ptr<ArrayBufferAllocator>
895,89370,Connect,1,node.inspector.ParentInspectorHandle.Connect,"unique_ptr<inspector::InspectorSession> node.inspector.ParentInspectorHandle.Connect (ANY,bool)",inspector\worker_inspector.cc,"std::unique_ptr<inspector::InspectorSession> ParentInspectorHandle::Connect(
    std::unique_ptr<inspector::InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",82.0,86.0,1.0,1.0,5.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,unique_ptr<inspector.InspectorSession>
896,89387,WorkerFinished,1,node.inspector.WorkerManager.WorkerFinished,void node.inspector.WorkerManager.WorkerFinished (uint64_t),inspector\worker_inspector.cc,"void WorkerManager::WorkerFinished(uint64_t session_id) {
  children_.erase(session_id);
}",88.0,90.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
897,142637,New,1,node.Buffer.New,"MaybeLocal<Uint8Array> node.Buffer.New (Environment*,Local<ArrayBuffer>,size_t,size_t)",node_buffer.cc,"MaybeLocal<Object> New(Environment* env,
                       char* data,
                       size_t length) {
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",493.0,521.0,1.0,1.0,29.0,12,6,14,8,2,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Object>
898,216366,scheduler_,3,node.DelayedTaskScheduler.StopTask.scheduler_,,node_platform.cc,* scheduler_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
899,3378,CreateArrayBufferAllocator,1,node.CreateArrayBufferAllocator,ArrayBufferAllocator node.CreateArrayBufferAllocator (),api\environment.cc,"ArrayBufferAllocator* CreateArrayBufferAllocator() {
  return ArrayBufferAllocator::Create().release();
}",223.0,225.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,1,,0,0,0,0,0,ArrayBufferAllocator
900,89397,WorkerStarted,1,node.inspector.WorkerManager.WorkerStarted,"void node.inspector.WorkerManager.WorkerStarted (uint64_t,WorkerInfo,bool)",inspector\worker_inspector.cc,"void WorkerManager::WorkerStarted(uint64_t session_id,
                                  const WorkerInfo& info,
                                  bool waiting) {
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",92.0,101.0,1.0,1.0,10.0,4,2,8,6,0,3,3,3,2,0,,0,3,6,3,3,void
901,138550,set,1,node.binding.global_handle_map_t.set,"void node.binding.global_handle_map_t.set (void*,node_module*)",node_binding.cc,"void set(void* handle, node_module* mod) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",276.0,289.0,3.0,3.0,14.0,11,6,11,5,0,5,1,1,0,0,,0,5,4,2,2,void
902,216375,Run,1,node.DelayedTaskScheduler.ScheduleTask.Run,void node.DelayedTaskScheduler.ScheduleTask.Run (),node_platform.cc,"void Run() override {
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",133.0,140.0,5.0,5.0,8.0,16,8,13,7,0,4,1,1,0,0,,0,4,0,0,0,void
903,134458,napi_module_to_node_module,1,node.napi_module_to_node_module,node_module node.napi_module_to_node_module (napi_module*),node_api.cc,"node_module napi_module_to_node_module(const napi_module* mod) {
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",741.0,753.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,node_module
904,134464,napi_module_register,1,napi_module_register,void napi_module_register (napi_module*),node_api.cc,"void NAPI_CDECL napi_module_register(napi_module* mod) {
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",757.0,761.0,1.0,5.0,5.0,4,3,6,4,0,2,1,1,0,2,,0,1,2,1,1,void
905,253249,WorkerThreadData,1,node.worker.WorkerThreadData.WorkerThreadData,ANY node.worker.WorkerThreadData.WorkerThreadData (Worker*),node_worker.cc,"explicit WorkerThreadData(Worker* w)
    : w_(w) {
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INI...",143.0,204.0,3.0,3.0,62.0,49,8,55,15,0,17,4,4,1,0,,0,17,2,1,1,ANY
906,97616,OnCloseSent,3,node.inspector.anonymous_namespace_15.WsHandler.OnCloseSent,,inspector_socket.cc,OnCloseSent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
907,97617,OnCloseReceived,3,node.inspector.anonymous_namespace_15.WsHandler.OnCloseReceived,,inspector_socket.cc,OnCloseReceived,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
908,294226,GetAgent,1,node.tracing.TraceEventHelper.GetAgent,Agent node.tracing.TraceEventHelper.GetAgent (),tracing\trace_event.cc,"Agent* TraceEventHelper::GetAgent() {
  return g_agent;
}",20.0,22.0,1.0,1.0,3.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,Agent
909,97618,dispose_,3,node.inspector.anonymous_namespace_15.WsHandler.dispose_,,inspector_socket.cc,dispose_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
910,101714,NewString,1,v8impl.anonymous_namespace_1.NewString,"napi_status v8impl.anonymous_namespace_1.NewString<CCharType,StringMaker> (napi_env,CCharType*,size_t,napi_value*,StringMaker)",js_native_api_v8.cc,"napi_status NewString(napi_env env,
                      const CCharType* str,
                      size_t length,
                      napi_value* result,
                      StringMaker string_maker) {
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = string_maker(isolate);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",65.0,81.0,1.0,2.0,17.0,20,10,36,11,0,6,2,2,0,6,,0,1,10,5,5,napi_status
911,89429,NewParentHandle,1,node.inspector.WorkerManager.NewParentHandle,"unique_ptr<ParentInspectorHandle> node.inspector.WorkerManager.NewParentHandle (uint64_t,ANY,ANY)",inspector\worker_inspector.cc,"std::unique_ptr<ParentInspectorHandle> WorkerManager::NewParentHandle(
    uint64_t thread_id, const std::string& url, const std::string& name) {
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",103.0,108.0,1.0,1.0,6.0,8,7,9,8,0,2,1,1,0,0,,0,2,6,3,3,unique_ptr<ParentInspectorHandle>
912,134484,napi_add_env_cleanup_hook,1,napi_add_env_cleanup_hook,"napi_status napi_add_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)",node_api.cc,"napi_status NAPI_CDECL napi_add_env_cleanup_hook(napi_env env,
                                                 napi_cleanup_hook fun,
                                                 void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",763.0,772.0,1.0,12.0,10.0,5,5,13,6,0,2,1,1,0,2,,0,0,6,3,3,napi_status
913,294232,GetTracingController,1,node.tracing.TraceEventHelper.GetTracingController,TracingController node.tracing.TraceEventHelper.GetTracingController (),tracing\trace_event.cc,"v8::TracingController* TraceEventHelper::GetTracingController() {
  return g_controller;
}",24.0,26.0,1.0,1.0,3.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,TracingController
914,138586,get_and_increase_refcount,1,node.binding.global_handle_map_t.get_and_increase_refcount,node_module node.binding.global_handle_map_t.get_and_increase_refcount (void*),node_binding.cc,"node_module* get_and_increase_refcount(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",291.0,299.0,3.0,3.0,9.0,9,5,9,4,0,3,2,2,1,0,,0,3,2,1,1,node_module
915,97631,isGET,3,node.inspector.anonymous_namespace_36.HttpEvent.isGET,,inspector_socket.cc,isGET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
916,97633,host,3,node.inspector.anonymous_namespace_36.HttpEvent.host,,inspector_socket.cc,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
917,97635,HttpHandler,1,node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler,"ANY node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler (InspectorSocket*,ANY)",inspector_socket.cc,"explicit HttpHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
                       : ProtocolHandler(inspector, std::move(tcp)),
                         parsing_value_(false) {
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",485.0,494.0,3.0,3.0,10.0,11,3,8,3,0,7,1,1,0,0,,0,7,4,2,2,ANY
918,73063,ReaderImpl,1,node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl,"ANY node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl (ANY,FdEntry*)",dataqueue\queue.cc,"explicit ReaderImpl(BaseObjectPtr<fs::FileHandle> handle, FdEntry* entry)
        : env_(handle->env()), handle_(std::move(handle)), entry_(entry) {
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",888.0,892.0,5.0,5.0,5.0,3,1,2,1,0,2,1,1,0,0,,0,2,4,2,2,ANY
919,204141,env_,3,node.worker.anonymous_namespace_12.SerializerDelegate.env_,,node_messaging.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
920,204142,context_,3,node.worker.anonymous_namespace_12.SerializerDelegate.context_,,node_messaging.cc,context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
921,204143,msg_,3,node.worker.anonymous_namespace_12.SerializerDelegate.msg_,,node_messaging.cc,* msg_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
922,204144,seen_shared_array_buffers_,3,node.worker.anonymous_namespace_12.SerializerDelegate.seen_shared_array_buffers_,,node_messaging.cc,seen_shared_array_buffers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
923,204145,host_objects_,3,node.worker.anonymous_namespace_12.SerializerDelegate.host_objects_,,node_messaging.cc,host_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
924,89458,RemoveAttachDelegate,1,node.inspector.WorkerManager.RemoveAttachDelegate,void node.inspector.WorkerManager.RemoveAttachDelegate (int),inspector\worker_inspector.cc,"void WorkerManager::RemoveAttachDelegate(int id) {
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",110.0,113.0,1.0,1.0,4.0,2,1,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
925,204146,first_cloned_object_index_,3,node.worker.anonymous_namespace_12.SerializerDelegate.first_cloned_object_index_,,node_messaging.cc,first_cloned_object_index_ = SIZE_MAX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
926,216436,delay_in_seconds_,3,node.DelayedTaskScheduler.ScheduleTask.delay_in_seconds_,,node_platform.cc,delay_in_seconds_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
927,216434,scheduler_,3,node.DelayedTaskScheduler.ScheduleTask.scheduler_,,node_platform.cc,* scheduler_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
928,216435,task_,3,node.DelayedTaskScheduler.ScheduleTask.task_,,node_platform.cc,task_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
929,216437,RunTask,1,node.DelayedTaskScheduler.RunTask,void node.DelayedTaskScheduler.RunTask (uv_timer_t*),node_platform.cc,"static void RunTask(uv_timer_t* timer) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",148.0,152.0,3.0,3.0,5.0,7,4,6,3,0,2,1,1,0,0,,0,2,2,1,1,void
930,73083,~ReaderImpl,1,node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl,ANY node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl (),dataqueue\queue.cc,"~ReaderImpl() override {
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",894.0,898.0,5.0,5.0,5.0,3,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,ANY
931,204158,Serialize,1,node.worker.Message.Serialize,"Maybe<bool> node.worker.Message.Serialize (Environment*,Local<Context>,Local<Value>,TransferList,Local<Object>)",node_messaging.cc,"Maybe<bool> Message::Serialize(Environment* env,
                               Local<Context> context,
                               Local<Value> input,
                               const TransferList& transfer_list_v,
                               Local<Object> source_port) {
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              contex...",457.0,585.0,1.0,1.0,129.0,65,11,70,21,0,1,15,22,0,0,,0,1,10,5,5,Maybe<bool>
932,89473,SetAutoAttach,1,node.inspector.WorkerManager.SetAutoAttach,unique_ptr<WorkerManagerEventHandle> node.inspector.WorkerManager.SetAutoAttach (ANY),inspector\worker_inspector.cc,"std::unique_ptr<WorkerManagerEventHandle> WorkerManager::SetAutoAttach(
    std::unique_ptr<WorkerDelegate> attach_delegate) {
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",115.0,125.0,1.0,1.0,11.0,13,8,15,9,0,4,2,2,1,0,,0,4,2,1,1,unique_ptr<WorkerManagerEventHandle>
933,138627,erase,1,node.binding.global_handle_map_t.erase,void node.binding.global_handle_map_t.erase (void*),node_binding.cc,"void erase(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",301.0,313.0,3.0,3.0,13.0,16,6,13,4,0,4,4,5,1,0,,0,4,2,1,1,void
934,134532,napi_remove_env_cleanup_hook,1,napi_remove_env_cleanup_hook,"napi_status napi_remove_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)",node_api.cc,"napi_status NAPI_CDECL napi_remove_env_cleanup_hook(napi_env env,
                                                    napi_cleanup_hook fun,
                                                    void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",774.0,783.0,1.0,12.0,10.0,5,5,13,6,0,2,1,1,0,2,,0,0,6,3,3,napi_status
935,3461,SetIsolateErrorHandlers,1,node.SetIsolateErrorHandlers,"void node.SetIsolateErrorHandlers (ANY*,IsolateSettings)",api\environment.cc,"void SetIsolateErrorHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareSt...",251.0,273.0,1.0,1.0,23.0,28,7,28,12,0,8,3,3,2,0,,0,8,4,2,2,void
936,93577,Disconnect,1,node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect,void node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect (),inspector_js_api.cc,"void Disconnect() {
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",127.0,131.0,3.0,3.0,5.0,4,4,3,3,0,1,1,1,0,0,,0,1,0,0,0,void
937,73102,OnStreamAlloc,1,node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc,uv_buf_t node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc (size_t),dataqueue\queue.cc,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
      return env_->allocate_managed_buffer(suggested_size);
    }",900.0,902.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,uv_buf_t
938,216464,TakeTimerTask,1,node.DelayedTaskScheduler.TakeTimerTask,unique_ptr<Task> node.DelayedTaskScheduler.TakeTimerTask (uv_timer_t*),node_platform.cc,"std::unique_ptr<Task> TakeTimerTask(uv_timer_t* timer) {
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",154.0,162.0,3.0,3.0,9.0,7,5,8,5,0,1,1,1,0,0,,0,1,2,1,1,unique_ptr<Task>
939,200083,Pause,1,node.anonymous_namespace_78.Parser.Pause,void node.anonymous_namespace_78.Parser.Pause<bool> (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Pause(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",669.0,681.0,3.0,3.0,13.0,7,4,9,5,0,1,2,2,0,0,,0,1,2,1,1,void
940,73113,OnStreamRead,1,node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead,"void node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead (ssize_t,uv_buf_t)",dataqueue\queue.cc,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      Data...",904.0,945.0,5.0,5.0,42.0,31,8,32,16,0,10,7,9,5,0,,0,10,4,2,2,void
941,257442,Write,1,node.anonymous_namespace_62.CompressionStream.Write,"void node.anonymous_namespace_62.CompressionStream.Write<bool> (uint32_t,char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void Write(uint32_t flush,
             const char* in, uint32_t in_len,
             char* out, uint32_t out_len) {
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",348.0,378.0,3.0,3.0,31.0,10,5,15,12,0,8,3,4,0,0,,0,8,10,5,5,void
942,93610,Dispatch,1,node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch,void node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void Dispatch(const FunctionCallbackInfo<Value>& info) {
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",139.0,149.0,3.0,3.0,11.0,12,5,10,4,0,2,2,2,1,0,,0,2,2,1,1,void
943,216495,ready_,3,node.DelayedTaskScheduler.ready_,,node_platform.cc,ready_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
944,89519,SetWaitOnStartForDelegate,1,node.inspector.WorkerManager.SetWaitOnStartForDelegate,"void node.inspector.WorkerManager.SetWaitOnStartForDelegate (int,bool)",inspector\worker_inspector.cc,"void WorkerManager::SetWaitOnStartForDelegate(int id, bool wait) {
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",127.0,132.0,1.0,1.0,6.0,1,1,3,3,0,1,2,2,0,0,,0,1,4,2,2,void
945,216497,tasks_,3,node.DelayedTaskScheduler.tasks_,,node_platform.cc,tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
946,216498,loop_,3,node.DelayedTaskScheduler.loop_,,node_platform.cc,loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
947,216499,flush_tasks_,3,node.DelayedTaskScheduler.flush_tasks_,,node_platform.cc,flush_tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
948,216500,timers_,3,node.DelayedTaskScheduler.timers_,,node_platform.cc,timers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
949,134580,napi_async_cleanup_hook_handle__,1,napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__,"ANY napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__ (napi_env,napi_async_cleanup_hook,void*)",node_api.cc,"napi_async_cleanup_hook_handle__(napi_env env,
                                   napi_async_cleanup_hook user_hook,
                                   void* user_data)
      : env_(env), user_hook_(user_hook), user_data_(user_data) {
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",786.0,792.0,3.0,3.0,7.0,4,3,4,3,0,2,1,1,0,1,,0,2,6,3,3,ANY
950,216496,pending_worker_tasks_,3,node.DelayedTaskScheduler.pending_worker_tasks_,,node_platform.cc,* pending_worker_tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
951,220600,CreateProcessObject,1,node.CreateProcessObject,MaybeLocal<Object> node.CreateProcessObject (Realm*),node_process_object.cc,"MaybeLocal<Object> CreateProcessObject(Realm* realm) {
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version ...",81.0,175.0,1.0,1.0,95.0,78,10,81,23,1,0,4,4,0,0,,0,0,2,1,1,MaybeLocal<Object>
952,122305,napi_clear_last_error,1,napi_clear_last_error,napi_status napi_clear_last_error (napi_env),js_native_api_v8.hpp,"inline napi_status napi_clear_last_error(napi_env env) {
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",158.0,164.0,1.0,1.0,7.0,0,0,0,0,32,0,1,1,0,0,,0,0,2,1,1,napi_status
953,138690,mutex_,3,node.binding.global_handle_map_t.mutex_,,node_binding.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
954,89540,SetWaitOnStart,1,node.inspector.WorkerManagerEventHandle.SetWaitOnStart,void node.inspector.WorkerManagerEventHandle.SetWaitOnStart (bool),inspector\worker_inspector.cc,"void WorkerManagerEventHandle::SetWaitOnStart(bool wait_on_start) {
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",134.0,136.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
955,138695,map_,3,node.binding.global_handle_map_t.map_,,node_binding.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
956,134602,~napi_async_cleanup_hook_handle__,1,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__ (),node_api.cc,"~napi_async_cleanup_hook_handle__() {
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",794.0,802.0,3.0,3.0,9.0,6,4,6,6,0,6,2,2,0,2,,0,3,0,0,0,ANY
957,89551,~WorkerManagerEventHandle,1,node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle,ANY node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle (),inspector\worker_inspector.cc,"WorkerManagerEventHandle::~WorkerManagerEventHandle() {
  manager_->RemoveAttachDelegate(id_);
}",138.0,140.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
958,122325,Link,1,v8impl.RefTracker.Link,void v8impl.RefTracker.Link (RefList*),js_native_api_v8.hpp,"inline void Link(RefList* list) {
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",19.0,26.0,3.0,3.0,8.0,8,3,7,3,0,5,2,2,1,0,,0,5,2,1,1,void
959,93660,MemoryInfo,1,node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo,void node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo (MemoryTracker*),inspector_js_api.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",151.0,155.0,3.0,3.0,5.0,4,3,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
960,3554,SetIsolateMiscHandlers,1,node.SetIsolateMiscHandlers,"void node.SetIsolateMiscHandlers (ANY*,IsolateSettings)",api\environment.cc,"void SetIsolateMiscHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

...",275.0,312.0,1.0,1.0,38.0,38,7,35,15,0,9,6,6,3,0,,0,9,4,2,2,void
961,257508,UpdateWriteResult,1,node.anonymous_namespace_68.CompressionStream.UpdateWriteResult,void node.anonymous_namespace_68.CompressionStream.UpdateWriteResult (),node_zlib.cc,"void UpdateWriteResult() {
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",380.0,382.0,3.0,3.0,3.0,5,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,void
962,294374,raw_id,1,node.tracing.TraceID.WithScope.raw_id,uint64_t node.tracing.TraceID.WithScope.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },338.0,338.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
963,134632,Hook,1,napi_async_cleanup_hook_handle__.Hook,"void napi_async_cleanup_hook_handle__.Hook (void*,void,void*)",node_api.cc,"static void Hook(void* data, void (*done_cb)(void*), void* done_data) {
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",804.0,810.0,3.0,3.0,7.0,8,3,9,4,0,3,1,1,0,0,,0,3,6,3,3,void
964,294380,scope,1,node.tracing.TraceID.WithScope.scope,const char* node.tracing.TraceID.WithScope.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },339.0,339.0,5.0,48.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
965,122353,Unlink,1,v8impl.RefTracker.Unlink,void v8impl.RefTracker.Unlink (),js_native_api_v8.hpp,"inline void Unlink() {
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",28.0,37.0,3.0,3.0,10.0,8,3,8,2,0,10,3,3,2,0,,0,10,0,0,0,void
966,294386,scope_,3,node.tracing.TraceID.WithScope.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
967,294387,raw_id_,3,node.tracing.TraceID.WithScope.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
968,257524,DoThreadPoolWork,1,node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork,void node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork (),node_zlib.cc,"void DoThreadPoolWork() override {
    ctx_.DoThreadPoolWork();
  }",388.0,390.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
969,97781,OnData,1,node.inspector.anonymous_namespace_49.HttpHandler.OnData,void node.inspector.anonymous_namespace_49.HttpHandler.OnData (ANY*),inspector_socket.cc,"void OnData(std::vector<char>* data) override {
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",532.0,560.0,3.0,3.0,29.0,15,8,18,9,0,5,5,6,2,0,,0,5,2,1,1,void
970,93690,session_,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.session_,,inspector_js_api.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
971,93691,callback_,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.callback_,,inspector_js_api.cc,callback_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
972,257532,CheckError,1,node.anonymous_namespace_70.CompressionStream.CheckError,bool node.anonymous_namespace_70.CompressionStream.CheckError (),node_zlib.cc,"bool CheckError() {
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",393.0,398.0,3.0,3.0,6.0,4,3,4,2,0,1,2,2,0,0,,0,1,0,0,0,bool
973,200193,GetCurrentBuffer,1,node.anonymous_namespace_81.Parser.GetCurrentBuffer,void node.anonymous_namespace_81.Parser.GetCurrentBuffer (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void GetCurrentBuffer(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",706.0,716.0,3.0,3.0,11.0,12,6,11,6,0,2,1,1,0,0,,0,2,2,1,1,void
974,253443,~WorkerThreadData,1,node.worker.WorkerThreadData.~WorkerThreadData,ANY node.worker.WorkerThreadData.~WorkerThreadData (),node_worker.cc,"~WorkerThreadData() {
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_fini...",206.0,241.0,3.0,3.0,36.0,21,6,21,7,0,12,4,5,1,0,,0,12,0,0,0,ANY
975,134663,handle_,3,napi_async_cleanup_hook_handle__.handle_,,node_api.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
976,89608,manager_,3,node.inspector.WorkerManagerEventHandle.manager_,,inspector\worker_inspector.hpp,manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
977,89609,id_,3,node.inspector.WorkerManagerEventHandle.id_,,inspector\worker_inspector.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
978,134664,env_,3,napi_async_cleanup_hook_handle__.env_,,node_api.cc,env_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
979,134665,user_hook_,3,napi_async_cleanup_hook_handle__.user_hook_,,node_api.cc,user_hook_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
980,134666,user_data_,3,napi_async_cleanup_hook_handle__.user_data_,,node_api.cc,* user_data_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
981,134667,done_cb_,1,napi_async_cleanup_hook_handle__.done_cb_,void napi_async_cleanup_hook_handle__.done_cb_ (void*),node_api.cc,void (*done_cb_)(void*) = nullptr;,816.0,816.0,8.0,35.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
982,122383,FinalizeAll,1,v8impl.RefTracker.FinalizeAll,void v8impl.RefTracker.FinalizeAll (RefList*),js_native_api_v8.hpp,"static void FinalizeAll(RefList* list) {
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",39.0,43.0,3.0,3.0,5.0,4,2,2,1,2,0,2,2,0,0,,0,0,2,1,1,void
983,134672,done_data_,3,napi_async_cleanup_hook_handle__.done_data_,,node_api.cc,* done_data_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
984,89618,title,3,node.inspector.WorkerInfo.title,,inspector\worker_inspector.hpp,title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
985,89619,url,3,node.inspector.WorkerInfo.url,,inspector\worker_inspector.hpp,url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
986,89620,worker_thread,3,node.inspector.WorkerInfo.worker_thread,,inspector\worker_inspector.hpp,worker_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
987,257556,AfterThreadPoolWork,1,node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork,void node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork (int),node_zlib.cc,"void AfterThreadPoolWork(int status) override {
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",402.0,431.0,3.0,3.0,30.0,13,7,16,12,0,4,4,4,1,0,,0,4,2,1,1,void
988,122401,next_,3,v8impl.RefTracker.next_,,js_native_api_v8.hpp,* next_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
989,122402,prev_,3,v8impl.RefTracker.prev_,,js_native_api_v8.hpp,* prev_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
990,89635,NewParentInspectorHandle,1,node.inspector.ParentInspectorHandle.NewParentInspectorHandle,"unique_ptr<ParentInspectorHandle> node.inspector.ParentInspectorHandle.NewParentInspectorHandle (uint64_t,ANY,ANY)",inspector\worker_inspector.hpp,"std::unique_ptr<ParentInspectorHandle> NewParentInspectorHandle(
      uint64_t thread_id, const std::string& url, const std::string& name) {
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",62.0,66.0,3.0,3.0,5.0,5,5,7,7,0,2,1,1,0,0,,0,2,6,3,3,unique_ptr<ParentInspectorHandle>
991,134692,napi_add_async_cleanup_hook,1,napi_add_async_cleanup_hook,"napi_status napi_add_async_cleanup_hook (napi_env,napi_async_cleanup_hook,void*,napi_async_cleanup_hook_handle*)",node_api.cc,"napi_status NAPI_CDECL
napi_add_async_cleanup_hook(napi_env env,
                            napi_async_cleanup_hook hook,
                            void* arg,
                            napi_async_cleanup_hook_handle* remove_handle) {
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",820.0,834.0,1.0,12.0,15.0,8,6,17,7,0,2,2,2,0,2,,0,0,8,4,4,napi_status
992,7717,EmitDestroy,1,node.AsyncWrap.EmitDestroy,void node.AsyncWrap.EmitDestroy (bool),async_wrap.cc,"void AsyncWrap::EmitDestroy(Environment* env, double async_id) {
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",552.0,576.0,1.0,1.0,25.0,7,5,5,4,1,0,2,2,0,0,,0,0,4,2,2,void
993,208423,ObjectWrap,1,node.ObjectWrap.ObjectWrap,ANY node.ObjectWrap.ObjectWrap (),node_object_wrap.hpp,"ObjectWrap() {
    refs_ = 0;
  }",33.0,35.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
994,200237,Duration,1,node.anonymous_namespace_82.Parser.Duration,void node.anonymous_namespace_82.Parser.Duration (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Duration(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",718.0,729.0,3.0,3.0,12.0,12,7,8,3,0,2,2,2,1,0,,0,2,2,1,1,void
995,294446,scope,1,node.tracing.TraceID.DontMangle.scope,const char* node.tracing.TraceID.DontMangle.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },363.0,363.0,5.0,48.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
996,73263,Pull,1,node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull,"int node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",947.0,969.0,5.0,5.0,23.0,15,5,20,10,0,8,4,4,5,0,,0,8,10,5,5,int
997,122414,napi_env__,1,napi_env__.napi_env__,"ANY napi_env__.napi_env__ (ANY,int32_t)",js_native_api_v8.hpp,"explicit napi_env__(v8::Local<v8::Context> context,
                      int32_t module_api_version)
      : isolate(context->GetIsolate()),
        context_persistent(isolate, context),
        module_api_version(module_api_version) {
    napi_clear_last_error(this);
  }",54.0,60.0,3.0,3.0,7.0,0,0,0,0,0,1,1,1,0,1,,0,0,4,2,2,ANY
998,294452,raw_id,1,node.tracing.TraceID.DontMangle.raw_id,uint64_t node.tracing.TraceID.DontMangle.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },364.0,364.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
999,122422,context,1,napi_env__.context,Local<v8::Context> napi_env__.context (),js_native_api_v8.hpp,"inline v8::Local<v8::Context> context() const {
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",62.0,64.0,3.0,3.0,3.0,2,1,3,3,0,1,1,1,0,0,,0,1,0,0,0,Local<v8.Context>
1000,294458,scope_,3,node.tracing.TraceID.DontMangle.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1001,294459,raw_id_,3,node.tracing.TraceID.DontMangle.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1002,101947,data,1,v8impl.anonymous_namespace_9.ExternalOneByteStringResource.data,const char* v8impl.anonymous_namespace_9.ExternalOneByteStringResource.data (),js_native_api_v8.cc,const char* data() const override { return string_; },163.0,163.0,3.0,55.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
1003,89662,WaitForConnect,1,node.inspector.ParentInspectorHandle.WaitForConnect,bool node.inspector.ParentInspectorHandle.WaitForConnect (),inspector\worker_inspector.hpp,"bool WaitForConnect() {
    return wait_;
  }",69.0,71.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1004,101953,length,1,v8impl.anonymous_namespace_10.ExternalOneByteStringResource.length,size_t v8impl.anonymous_namespace_10.ExternalOneByteStringResource.length (),js_native_api_v8.cc,size_t length() const override { return length_; },164.0,164.0,3.0,52.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1005,122434,Ref,1,napi_env__.Ref,void napi_env__.Ref (),js_native_api_v8.hpp,inline void Ref() { refs++; },66.0,66.0,3.0,31.0,1.0,1,1,1,1,1,1,1,1,0,0,,0,1,0,0,0,void
1006,89668,url,1,node.inspector.ParentInspectorHandle.url,string node.inspector.ParentInspectorHandle.url (),inspector\worker_inspector.hpp,const std::string& url() const { return url_; },72.0,72.0,3.0,49.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
1007,101959,string_,3,v8impl.anonymous_namespace_7.ExternalOneByteStringResource.string_,,js_native_api_v8.cc,* string_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1008,122440,Unref,1,napi_env__.Unref,void napi_env__.Unref (),js_native_api_v8.hpp,"inline void Unref() {
    if (--refs == 0) DeleteMe();
  }",67.0,69.0,3.0,3.0,3.0,2,2,1,1,3,2,2,2,1,0,,0,1,0,0,0,void
1009,101960,length_,3,v8impl.anonymous_namespace_7.ExternalOneByteStringResource.length_,,js_native_api_v8.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1010,89680,id_,3,node.inspector.ParentInspectorHandle.id_,,inspector\worker_inspector.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1011,89681,url_,3,node.inspector.ParentInspectorHandle.url_,,inspector\worker_inspector.hpp,url_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1012,89682,parent_thread_,3,node.inspector.ParentInspectorHandle.parent_thread_,,inspector\worker_inspector.hpp,parent_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1013,89683,wait_,3,node.inspector.ParentInspectorHandle.wait_,,inspector\worker_inspector.hpp,wait_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1014,89684,name_,3,node.inspector.ParentInspectorHandle.name_,,inspector\worker_inspector.hpp,name_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1015,101971,data,1,v8impl.anonymous_namespace_13.ExternalStringResource.data,uint16_t v8impl.anonymous_namespace_13.ExternalStringResource.data (),js_native_api_v8.cc,const uint16_t* data() const override { return string_; },183.0,183.0,3.0,59.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint16_t
1016,122451,can_call_into_js,1,napi_env__.can_call_into_js,bool napi_env__.can_call_into_js (),js_native_api_v8.hpp,virtual bool can_call_into_js() const { return true; },71.0,71.0,3.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,bool
1017,253524,loop_is_usable,1,node.worker.WorkerThreadData.loop_is_usable,bool node.worker.WorkerThreadData.loop_is_usable (),node_worker.cc,bool loop_is_usable() const { return !loop_init_failed_; },243.0,243.0,3.0,60.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1018,101977,length,1,v8impl.anonymous_namespace_14.ExternalStringResource.length,size_t v8impl.anonymous_namespace_14.ExternalStringResource.length (),js_native_api_v8.cc,size_t length() const override { return length_; },184.0,184.0,3.0,52.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1019,253531,w_,3,node.worker.WorkerThreadData.w_,,node_worker.cc,* const w_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1020,200284,HeadersCompleted,1,node.anonymous_namespace_83.Parser.HeadersCompleted,void node.anonymous_namespace_83.Parser.HeadersCompleted (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void HeadersCompleted(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",731.0,736.0,3.0,3.0,6.0,5,3,4,2,0,1,1,1,0,0,,0,1,2,1,1,void
1021,253532,loop_,3,node.worker.WorkerThreadData.loop_,,node_worker.cc,loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1022,253534,isolate_data_,3,node.worker.WorkerThreadData.isolate_data_,,node_worker.cc,isolate_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1023,257631,EmitError,1,node.anonymous_namespace_79.CompressionStream.EmitError,void node.anonymous_namespace_79.CompressionStream.EmitError (CompressionError),node_zlib.cc,"void EmitError(const CompressionError& err) {
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",434.0,451.0,3.0,3.0,18.0,17,4,18,7,0,5,2,2,1,0,,0,5,2,1,1,void
1024,253533,loop_init_failed_,3,node.worker.WorkerThreadData.loop_init_failed_,,node_worker.cc,loop_init_failed_ = true,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1025,101985,V8NameFromPropertyDescriptor,1,v8impl.anonymous_namespace_15.V8NameFromPropertyDescriptor,"napi_status v8impl.anonymous_namespace_15.V8NameFromPropertyDescriptor (napi_env,napi_property_descriptor*,ANY*)",js_native_api_v8.cc,"inline napi_status V8NameFromPropertyDescriptor(
    napi_env env,
    const napi_property_descriptor* p,
    v8::Local<v8::Name>* result) {
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",191.0,206.0,1.0,4.0,16.0,28,11,28,10,0,7,2,2,1,3,,0,4,6,3,3,napi_status
1026,101984,length_,3,v8impl.anonymous_namespace_11.ExternalStringResource.length_,,js_native_api_v8.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1027,101983,string_,3,v8impl.anonymous_namespace_11.ExternalStringResource.string_,,js_native_api_v8.cc,* string_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1028,294508,raw_id,1,node.tracing.TraceID.ForceMangle.raw_id,uint64_t node.tracing.TraceID.ForceMangle.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },384.0,384.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1029,122477,terminatedOrTerminating,1,napi_env__.terminatedOrTerminating,bool napi_env__.terminatedOrTerminating (),js_native_api_v8.hpp,"inline bool terminatedOrTerminating() {
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",81.0,83.0,3.0,3.0,3.0,4,3,0,0,0,2,1,1,0,0,,0,1,0,0,0,bool
1030,134766,napi_fatal_exception,1,napi_fatal_exception,"napi_status napi_fatal_exception (napi_env,napi_value)",node_api.cc,"napi_status NAPI_CDECL napi_fatal_exception(napi_env env, napi_value err) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",845.0,853.0,1.0,12.0,9.0,19,10,26,8,0,7,5,7,0,7,,0,1,4,2,2,napi_status
1031,294514,raw_id_,3,node.tracing.TraceID.ForceMangle.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1032,200307,kAllocBufferSize,3,node.anonymous_namespace_49.Parser.kAllocBufferSize,,node_http_parser.cc,kAllocBufferSize = 64 * 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1033,200308,OnStreamAlloc,1,node.anonymous_namespace_84.Parser.OnStreamAlloc,uv_buf_t node.anonymous_namespace_84.Parser.OnStreamAlloc (size_t),node_http_parser.cc,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",741.0,753.0,3.0,3.0,13.0,9,3,9,3,0,7,3,3,2,0,,0,7,2,1,1,uv_buf_t
1034,122491,CallIntoModule,1,napi_env__.CallIntoModule,"void napi_env__.CallIntoModule<T,U> (T,U)",js_native_api_v8.hpp,"inline void CallIntoModule(T&& call, U&& handle_exception = HandleThrow) {
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",89.0,100.0,3.0,3.0,12.0,7,4,11,5,0,9,2,2,1,1,,0,8,4,2,2,void
1035,89726,MainThread,1,node.inspector.WorkerManager.MainThread,shared_ptr<MainThreadHandle> node.inspector.WorkerManager.MainThread (),inspector\worker_inspector.hpp,"std::shared_ptr<MainThreadHandle> MainThread() {
    return thread_;
  }",98.0,100.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<MainThreadHandle>
1036,73347,env_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.env_,,dataqueue\queue.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1037,73348,handle_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.handle_,,dataqueue\queue.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1038,208517,persistent,1,node.ObjectWrap.persistent,Persistent<v8::Object> node.ObjectWrap.persistent (),node_object_wrap.hpp,"inline v8::Persistent<v8::Object>& persistent() {
    return handle_;
  }",69.0,71.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Persistent<v8.Object>
1039,73350,pending_pulls_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.pending_pulls_,,dataqueue\queue.cc,pending_pulls_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1040,73351,reading_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.reading_,,dataqueue\queue.cc,reading_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1041,89734,delegates_,3,node.inspector.WorkerManager.delegates_,,inspector\worker_inspector.hpp,delegates_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1042,89735,delegates_waiting_on_start_,3,node.inspector.WorkerManager.delegates_waiting_on_start_,,inspector\worker_inspector.hpp,delegates_waiting_on_start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1043,73352,ended_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1044,89732,thread_,3,node.inspector.WorkerManager.thread_,,inspector\worker_inspector.hpp,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1045,73349,entry_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.entry_,,dataqueue\queue.cc,* entry_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1046,89733,children_,3,node.inspector.WorkerManager.children_,,inspector\worker_inspector.hpp,children_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1047,20109,GetMethod,1,node.crypto.NodeBIO.GetMethod,BIO_METHOD node.crypto.NodeBIO.GetMethod (),crypto\crypto_bio.cc,"const BIO_METHOD* NodeBIO::GetMethod() {
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",222.0,237.0,1.0,1.0,16.0,1,1,2,1,0,1,1,1,0,0,,0,1,0,0,0,BIO_METHOD
1048,89736,next_delegate_id_,3,node.inspector.WorkerManager.next_delegate_id_,,inspector\worker_inspector.hpp,next_delegate_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1049,298633,CreateSendWrap,1,node.UDPWrap.CreateSendWrap,ReqWrap<uv_udp_send_t> node.UDPWrap.CreateSendWrap (size_t),udp_wrap.cc,"ReqWrap<uv_udp_send_t>* UDPWrap::CreateSendWrap(size_t msg_size) {
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",614.0,620.0,1.0,1.0,7.0,4,3,7,5,0,1,1,1,0,0,,0,1,2,1,1,ReqWrap<uv_udp_send_t>
1050,97937,OnHeaderValue,1,node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue,"int node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnHeaderValue(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",578.0,583.0,3.0,3.0,6.0,7,4,7,4,0,3,1,1,0,0,,0,3,6,3,3,int
1051,201013,current_buffer_len_,3,node.anonymous_namespace_49.Parser.current_buffer_len_,,node_http_parser.cc,current_buffer_len_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1052,73368,DrainAndClose,1,node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose,void node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose (),dataqueue\queue.cc,"void DrainAndClose() {
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",995.0,1014.0,5.0,5.0,20.0,12,5,13,8,0,5,3,3,2,0,,0,5,0,0,0,void
1053,200352,OnStreamRead,1,node.anonymous_namespace_85.Parser.OnStreamRead,"void node.anonymous_namespace_85.Parser.OnStreamRead (ssize_t,uv_buf_t)",node_http_parser.cc,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
    HandleScope scope(env()->isolate());
    // Once were done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didnt come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_d...",756.0,797.0,3.0,3.0,42.0,24,8,23,10,0,4,5,5,0,0,,0,4,4,2,2,void
1054,253604,Run,1,node.worker.Worker.Run,void node.worker.Worker.Run (),node_worker.cc,"void Worker::Run() {
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateEx...",277.0,405.0,1.0,1.0,129.0,72,14,73,27,0,1,13,14,0,0,,0,1,0,0,0,void
1055,122535,CallFinalizer,1,napi_env__.CallFinalizer,"void napi_env__.CallFinalizer (napi_finalize,void*,void*)",js_native_api_v8.hpp,"virtual void CallFinalizer(napi_finalize cb, void* data, void* hint) {
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",103.0,106.0,3.0,3.0,4.0,0,0,1,1,1,1,1,1,0,0,,0,1,6,3,3,void
1056,143022,Copy,1,node.Buffer.Copy,"MaybeLocal<Object> node.Buffer.Copy (Isolate*,char*,size_t)",node_buffer.cc,"MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",398.0,426.0,1.0,1.0,29.0,9,6,16,10,1,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Object>
1057,97968,OnHeaderField,1,node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField,"int node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnHeaderField(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",585.0,593.0,3.0,3.0,9.0,8,3,8,4,0,4,2,2,1,0,,0,4,6,3,3,int
1058,122545,EnqueueFinalizer,1,napi_env__.EnqueueFinalizer,void napi_env__.EnqueueFinalizer (ANY*),js_native_api_v8.hpp,"virtual void EnqueueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.emplace(finalizer);
  }",112.0,114.0,3.0,3.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
1059,122555,DequeueFinalizer,1,napi_env__.DequeueFinalizer,void napi_env__.DequeueFinalizer (ANY*),js_native_api_v8.hpp,"virtual void DequeueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.erase(finalizer);
  }",118.0,120.0,3.0,3.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
1060,208573,Ref,1,node.ObjectWrap.Ref,void node.ObjectWrap.Ref (),node_object_wrap.hpp,"virtual void Ref() {
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",92.0,96.0,3.0,3.0,5.0,4,3,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1061,122565,DeleteMe,1,napi_env__.DeleteMe,void napi_env__.DeleteMe (),js_native_api_v8.hpp,"virtual void DeleteMe() {
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",122.0,131.0,3.0,3.0,10.0,7,3,6,4,1,4,1,1,0,2,,0,2,0,0,0,void
1062,208589,Unref,1,node.ObjectWrap.Unref,void node.ObjectWrap.Unref (),node_object_wrap.hpp,"virtual void Unref() {
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",107.0,113.0,3.0,3.0,7.0,7,5,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
1063,257744,MemoryInfo,1,node.anonymous_namespace_82.CompressionStream.MemoryInfo,void node.anonymous_namespace_82.CompressionStream.MemoryInfo (MemoryTracker*),node_zlib.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",463.0,467.0,3.0,3.0,5.0,3,2,5,4,0,3,1,1,0,0,,0,3,2,1,1,void
1064,73425,DequeuePendingPull,1,node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull,PendingPull node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull (),dataqueue\queue.cc,"PendingPull DequeuePendingPull() {
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",1016.0,1020.0,5.0,5.0,5.0,5,3,4,3,0,2,1,1,0,0,,0,2,0,0,0,PendingPull
1065,134869,napi_fatal_error,1,napi_fatal_error,"void napi_fatal_error (char*,size_t,char*,size_t)",node_api.cc,"void NAPI_CDECL napi_fatal_error(const char* location,
                                                size_t location_len,
                                                const char* message,
                                                size_t message_len) {
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",855.0,875.0,16.0,20.0,21.0,9,3,13,8,0,1,3,3,0,1,,0,0,8,4,4,void
1066,98006,OnPath,1,node.inspector.anonymous_namespace_65.HttpHandler.OnPath,"int node.inspector.anonymous_namespace_65.HttpHandler.OnPath (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnPath(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",595.0,599.0,3.0,3.0,5.0,3,3,5,4,0,1,1,1,0,0,,0,1,6,3,3,int
1067,122587,isolate,3,napi_env__.isolate,,js_native_api_v8.hpp,* const isolate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1068,122588,context_persistent,3,napi_env__.context_persistent,,js_native_api_v8.hpp,context_persistent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1069,122589,last_exception,3,napi_env__.last_exception,,js_native_api_v8.hpp,last_exception,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1070,122590,reflist,3,napi_env__.reflist,,js_native_api_v8.hpp,reflist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1071,122591,finalizing_reflist,3,napi_env__.finalizing_reflist,,js_native_api_v8.hpp,finalizing_reflist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1072,122592,pending_finalizers,3,napi_env__.pending_finalizers,,js_native_api_v8.hpp,pending_finalizers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1073,130785,Start,1,node.Start,"int node.Start (int,char**)",node.cc,"int Start(int argc, char** argv) {
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",1296.0,1301.0,1.0,1.0,6.0,4,3,8,4,1,0,1,1,0,0,,0,0,4,2,2,int
1074,122594,open_handle_scopes,3,napi_env__.open_handle_scopes,,js_native_api_v8.hpp,open_handle_scopes = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1075,122595,open_callback_scopes,3,napi_env__.open_callback_scopes,,js_native_api_v8.hpp,open_callback_scopes = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1076,122596,refs,3,napi_env__.refs,,js_native_api_v8.hpp,refs = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1077,257763,context,1,node.anonymous_namespace_83.CompressionStream.context,CompressionContext node.anonymous_namespace_83.CompressionStream.context (),node_zlib.cc,CompressionContext* context() { return &ctx_; },470.0,470.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,CompressionContext
1078,294631,raw_id,1,node.tracing.TraceID.raw_id,uint64_t node.tracing.TraceID.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },430.0,430.0,3.0,45.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1079,208616,refs_,3,node.ObjectWrap.refs_,,node_object_wrap.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1080,208617,WeakCallback,1,node.ObjectWrap.WeakCallback,void node.ObjectWrap.WeakCallback (ANY),node_object_wrap.hpp,"static void WeakCallback(
      const v8::WeakCallbackInfo<ObjectWrap>& data) {
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",118.0,124.0,3.0,3.0,7.0,7,5,5,2,0,2,1,1,0,0,,0,2,2,1,1,void
1081,257770,InitStream,1,node.anonymous_namespace_84.CompressionStream.InitStream,"void node.anonymous_namespace_84.CompressionStream.InitStream (uint32_t*,Local<Function>)",node_zlib.cc,"void InitStream(uint32_t* write_result, Local<Function> write_js_callback) {
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",472.0,476.0,3.0,3.0,5.0,3,2,5,5,0,3,1,1,0,0,,0,3,4,2,2,void
1082,98028,From,1,node.inspector.anonymous_namespace_68.HttpHandler.From,HttpHandler node.inspector.anonymous_namespace_68.HttpHandler.From (llhttp_t*),inspector_socket.cc,"static HttpHandler* From(llhttp_t* parser) {
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",601.0,603.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,HttpHandler
1083,294637,scope,1,node.tracing.TraceID.scope,const char* node.tracing.TraceID.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },431.0,431.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
1084,294643,scope_,3,node.tracing.TraceID.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1085,98043,OnMessageComplete,1,node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete,int node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete (llhttp_t*),inspector_socket.cc,"static int OnMessageComplete(llhttp_t* parser) {
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",605.0,618.0,3.0,3.0,14.0,17,4,13,3,0,6,1,1,0,0,,0,6,2,1,1,int
1086,200448,Execute,1,node.anonymous_namespace_87.Parser.Execute,"Local<Value> node.anonymous_namespace_87.Parser.Execute (char*,size_t)",node_http_parser.cc,"Local<Value> Execute(const char* data, size_t len) {
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
...",800.0,878.0,3.0,3.0,79.0,72,13,74,26,0,14,9,11,3,0,,0,14,4,2,2,Local<Value>
1087,102146,V8PropertyAttributesFromDescriptor,1,v8impl.anonymous_namespace_16.V8PropertyAttributesFromDescriptor,PropertyAttribute v8impl.anonymous_namespace_16.V8PropertyAttributesFromDescriptor (napi_property_descriptor*),js_native_api_v8.cc,"inline v8::PropertyAttribute V8PropertyAttributesFromDescriptor(
    const napi_property_descriptor* descriptor) {
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",209.0,228.0,1.0,1.0,20.0,25,7,21,7,0,5,4,4,5,0,,0,5,2,1,1,PropertyAttribute
1088,139011,FindModule,1,node.binding.FindModule,"struct node_module node.binding.FindModule (node_module*,char*,int)",node_binding.cc,"inline struct node_module* FindModule(struct node_module* list,
                                      const char* name,
                                      int flag) {
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",560.0,571.0,1.0,1.0,12.0,9,6,9,4,0,2,4,4,1,0,,0,2,6,3,3,struct node_module
1089,208643,handle_,3,node.ObjectWrap.handle_,,node_object_wrap.hpp,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1090,294672,AddTraceEventImpl,1,node.tracing.AddTraceEventImpl,"uint64_t node.tracing.AddTraceEventImpl (char,uint8_t*,char*,char*,uint64_t,uint64_t,int32_t,char**,uint8_t*,uint64_t*,unsigned int)",tracing\trace_event.hpp,"static inline uint64_t AddTraceEventImpl(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled,...",458.0,479.0,1.0,38.0,22.0,26,8,26,16,0,1,4,4,0,0,,0,1,22,11,11,uint64_t
1091,257809,AllocForBrotli,1,node.anonymous_namespace_88.CompressionStream.AllocForBrotli,"void* node.anonymous_namespace_88.CompressionStream.AllocForBrotli (void*,size_t)",node_zlib.cc,"static void* AllocForBrotli(void* data, size_t size) {
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",491.0,500.0,3.0,3.0,10.0,14,9,14,6,0,1,2,2,0,0,,0,1,4,2,2,void*
1092,134943,napi_open_callback_scope,1,napi_open_callback_scope,"napi_status napi_open_callback_scope (napi_env,napi_value,napi_async_context,napi_callback_scope*)",node_api.cc,"napi_status NAPI_CDECL
napi_open_callback_scope(napi_env env,
                         napi_value /** ignored */,
                         napi_async_context async_context_handle,
                         napi_callback_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",877.0,893.0,1.0,12.0,17.0,8,7,13,5,0,2,1,1,0,2,,0,0,8,4,4,napi_status
1093,122659,napi_set_last_error,1,napi_set_last_error,"napi_status napi_set_last_error (napi_env,napi_status,uint32_t,void*)",js_native_api_v8.hpp,"inline napi_status napi_set_last_error(napi_env env,
                                       napi_status error_code,
                                       uint32_t engine_error_code = 0,
                                       void* engine_reserved = nullptr) {
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",166.0,174.0,1.0,1.0,9.0,9,3,7,4,106,0,1,1,0,0,,0,0,8,4,4,napi_status
1094,98103,HeaderValue,1,node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue,string node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue (ANY),inspector_socket.cc,"std::string HeaderValue(const std::string& header) const {
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",620.0,633.0,3.0,3.0,14.0,9,2,11,6,0,1,4,7,1,0,,0,1,2,1,1,string
1095,257859,FreeForZlib,1,node.anonymous_namespace_89.CompressionStream.FreeForZlib,"void node.anonymous_namespace_89.CompressionStream.FreeForZlib (void*,void*)",node_zlib.cc,"static void FreeForZlib(void* data, void* pointer) {
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",502.0,510.0,3.0,3.0,9.0,13,8,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
1096,274247,Kill,1,node.anonymous_namespace_10.ProcessWrap.Kill,void node.anonymous_namespace_10.ProcessWrap.Kill (FunctionCallbackInfo<Value>),process_wrap.cc,"static void Kill(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",293.0,300.0,3.0,3.0,8.0,14,5,13,6,0,1,1,1,0,0,,0,1,2,1,1,void
1097,122698,JsValueFromV8LocalValue,1,v8impl.JsValueFromV8LocalValue,napi_value v8impl.JsValueFromV8LocalValue (ANY),js_native_api_v8.hpp,"inline napi_value JsValueFromV8LocalValue(v8::Local<v8::Value> local) {
  return reinterpret_cast<napi_value>(*local);
}",297.0,299.0,1.0,1.0,3.0,2,2,1,1,13,0,1,1,0,0,,0,0,2,1,1,napi_value
1098,122708,V8LocalValueFromJsValue,1,v8impl.V8LocalValueFromJsValue,Local<v8::Value> v8impl.V8LocalValueFromJsValue (napi_value),js_native_api_v8.hpp,"inline v8::Local<v8::Value> V8LocalValueFromJsValue(napi_value v) {
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",301.0,305.0,1.0,1.0,5.0,8,6,7,3,12,0,1,1,0,0,,0,0,2,1,1,Local<v8.Value>
1099,134997,napi_close_callback_scope,1,napi_close_callback_scope,"napi_status napi_close_callback_scope (napi_env,napi_callback_scope)",node_api.cc,"napi_status NAPI_CDECL napi_close_callback_scope(napi_env env,
                                                 napi_callback_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",895.0,909.0,1.0,12.0,15.0,8,6,15,6,0,2,2,2,0,2,,0,0,4,2,2,napi_status
1100,139102,InitInternalBinding,1,node.binding.InitInternalBinding,"Local<Object> node.binding.InitInternalBinding (Realm*,node_module*)",node_binding.cc,"static Local<Object> InitInternalBinding(Realm* realm, node_module* mod) {
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",606.0,617.0,1.0,1.0,12.0,19,5,24,10,0,5,1,1,0,0,,0,5,4,2,2,Local<Object>
1101,89957,ChannelImpl,1,node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl,"ANY node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl (Environment*,ANY,ANY,ANY,ANY,bool)",inspector_agent.cc,"explicit ChannelImpl(Environment* env,
                       const std::unique_ptr<V8Inspector>& inspector,
                       std::shared_ptr<WorkerManager> worker_manager,
                       std::unique_ptr<InspectorSessionDelegate> delegate,
                       std::shared_ptr<MainThreadHandle> main_thread_,
                       bool prevent_shutdown)
      : delegate_(std::move(delegate)), prevent_shutdown_(prevent_shutdown),
        retaining_context_(false) {
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::Work...",215.0,237.0,3.0,3.0,23.0,29,7,26,14,0,11,2,2,0,0,,0,11,12,6,6,ANY
1102,102254,escape_called,1,v8impl.anonymous_namespace_23.EscapableHandleScopeWrapper.escape_called,bool v8impl.anonymous_namespace_23.EscapableHandleScopeWrapper.escape_called (),js_native_api_v8.cc,bool escape_called() const { return escape_called_; },257.0,257.0,3.0,55.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1103,257906,AdjustAmountOfExternalAllocatedMemory,1,node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory,void node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory (),node_zlib.cc,"void AdjustAmountOfExternalAllocatedMemory() {
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",514.0,521.0,3.0,3.0,8.0,12,9,11,5,0,3,2,2,0,0,,0,3,0,0,0,void
1104,102260,Escape,1,v8impl.anonymous_namespace_24.EscapableHandleScopeWrapper.Escape,Local<T> v8impl.anonymous_namespace_24.EscapableHandleScopeWrapper.Escape<T> (ANY),js_native_api_v8.cc,"v8::Local<T> Escape(v8::Local<T> handle) {
    escape_called_ = true;
    return scope.Escape(handle);
  }",259.0,262.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,Local<T>
1105,274301,OnExit,1,node.anonymous_namespace_11.ProcessWrap.OnExit,"void node.anonymous_namespace_11.ProcessWrap.OnExit (uv_process_t*,int64_t,int)",process_wrap.cc,"static void OnExit(uv_process_t* handle,
                     int64_t exit_status,
                     int term_signal) {
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",302.0,318.0,3.0,3.0,17.0,17,6,19,8,0,2,1,1,0,0,,0,2,6,3,3,void
1106,102274,scope,3,v8impl.anonymous_namespace_21.EscapableHandleScopeWrapper.scope,,js_native_api_v8.cc,scope,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1107,102275,escape_called_,3,v8impl.anonymous_namespace_21.EscapableHandleScopeWrapper.escape_called_,,js_native_api_v8.cc,escape_called_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1108,98180,parsing_value_,3,node.inspector.anonymous_namespace_38.HttpHandler.parsing_value_,,inspector_socket.cc,parsing_value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1109,98181,parser_,3,node.inspector.anonymous_namespace_38.HttpHandler.parser_,,inspector_socket.cc,parser_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1110,98182,parser_settings,3,node.inspector.anonymous_namespace_38.HttpHandler.parser_settings,,inspector_socket.cc,parser_settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1111,98183,events_,3,node.inspector.anonymous_namespace_38.HttpHandler.events_,,inspector_socket.cc,events_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1112,98184,current_header_,3,node.inspector.anonymous_namespace_38.HttpHandler.current_header_,,inspector_socket.cc,current_header_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1113,98185,headers_,3,node.inspector.anonymous_namespace_38.HttpHandler.headers_,,inspector_socket.cc,headers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1114,98186,path_,3,node.inspector.anonymous_namespace_38.HttpHandler.path_,,inspector_socket.cc,path_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1115,122761,callback,1,v8impl.Finalizer.callback,napi_finalize v8impl.Finalizer.callback (),js_native_api_v8.hpp,napi_finalize callback() { return finalize_callback_; },329.0,329.0,3.0,57.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,napi_finalize
1116,122767,data,1,v8impl.Finalizer.data,void* v8impl.Finalizer.data (),js_native_api_v8.hpp,void* data() { return finalize_data_; },330.0,330.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
1117,135055,napi_async_init,1,napi_async_init,"napi_status napi_async_init (napi_env,napi_value,napi_value,napi_async_context*)",node_api.cc,"napi_status NAPI_CDECL napi_async_init(napi_env env,
                                       napi_value async_resource,
                                       napi_value async_resource_name,
                                       napi_async_context* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                          ...",911.0,944.0,1.0,12.0,34.0,49,11,68,18,0,7,2,2,0,7,,0,0,8,4,4,napi_status
1118,122773,hint,1,v8impl.Finalizer.hint,void* v8impl.Finalizer.hint (),js_native_api_v8.hpp,void* hint() { return finalize_hint_; },331.0,331.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
1119,122784,finalize_callback_,3,v8impl.Finalizer.finalize_callback_,,js_native_api_v8.hpp,finalize_callback_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1120,122785,finalize_data_,3,v8impl.Finalizer.finalize_data_,,js_native_api_v8.hpp,* finalize_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1121,122786,finalize_hint_,3,v8impl.Finalizer.finalize_hint_,,js_native_api_v8.hpp,* finalize_hint_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1122,257957,~AllocScope,1,node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope,ANY node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope (),node_zlib.cc,~AllocScope() { stream->AdjustAmountOfExternalAllocatedMemory(); },525.0,525.0,5.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1123,102312,ConcludeDeferred,1,v8impl.anonymous_namespace_29.ConcludeDeferred,"napi_status v8impl.anonymous_namespace_29.ConcludeDeferred (napi_env,napi_deferred,napi_value,bool)",js_native_api_v8.cc,"inline napi_status ConcludeDeferred(napi_env env,
                                    napi_deferred deferred,
                                    napi_value result,
                                    bool is_resolved) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",289.0,315.0,1.0,2.0,27.0,45,11,55,17,0,8,5,7,0,8,,0,2,8,4,4,napi_status
1124,122793,~TryCatch,1,v8impl.TryCatch.~TryCatch,ANY v8impl.TryCatch.~TryCatch (),js_native_api_v8.hpp,"~TryCatch() {
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",346.0,350.0,3.0,3.0,5.0,3,2,2,1,0,2,2,2,0,0,,0,2,0,0,0,ANY
1125,257965,stream,3,node.anonymous_namespace_91.CompressionStream.AllocScope.stream,,node_zlib.cc,* stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1126,257966,Ref,1,node.anonymous_namespace_94.CompressionStream.Ref,void node.anonymous_namespace_94.CompressionStream.Ref (),node_zlib.cc,"void Ref() {
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",530.0,534.0,3.0,3.0,5.0,2,2,1,1,0,1,2,2,1,0,,0,1,0,0,0,void
1127,257977,Unref,1,node.anonymous_namespace_95.CompressionStream.Unref,void node.anonymous_namespace_95.CompressionStream.Unref (),node_zlib.cc,"void Unref() {
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",536.0,541.0,3.0,3.0,6.0,2,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
1128,122810,_env,3,v8impl.TryCatch._env,,js_native_api_v8.hpp,_env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1129,122812,kRuntime,3,v8impl.Ownership.kRuntime,,js_native_api_v8.hpp,kRuntime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1130,122813,kUserland,3,v8impl.Ownership.kUserland,,js_native_api_v8.hpp,kUserland,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1131,90050,~ChannelImpl,1,node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl,ANY node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl (),inspector_agent.cc,"~ChannelImpl() override {
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",239.0,248.0,3.0,3.0,10.0,6,2,7,3,0,7,2,2,1,0,,0,7,0,0,0,ANY
1132,274375,process_,3,node.anonymous_namespace_1.ProcessWrap.process_,,process_wrap.cc,process_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1133,257992,write_in_progress_,3,node.anonymous_namespace_48.CompressionStream.write_in_progress_,,node_zlib.cc,write_in_progress_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1134,257993,pending_close_,3,node.anonymous_namespace_48.CompressionStream.pending_close_,,node_zlib.cc,pending_close_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1135,257991,init_done_,3,node.anonymous_namespace_48.CompressionStream.init_done_,,node_zlib.cc,init_done_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1136,257995,refs_,3,node.anonymous_namespace_48.CompressionStream.refs_,,node_zlib.cc,refs_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1137,257996,write_result_,3,node.anonymous_namespace_48.CompressionStream.write_result_,,node_zlib.cc,* write_result_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1138,257994,closed_,3,node.anonymous_namespace_48.CompressionStream.closed_,,node_zlib.cc,closed_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1139,257998,zlib_memory_,3,node.anonymous_namespace_48.CompressionStream.zlib_memory_,,node_zlib.cc,zlib_memory_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1140,257999,ctx_,3,node.anonymous_namespace_48.CompressionStream.ctx_,,node_zlib.cc,ctx_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1141,257997,unreported_allocations_,3,node.anonymous_namespace_48.CompressionStream.unreported_allocations_,,node_zlib.cc,unreported_allocations_{0},-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1142,90081,dispatchProtocolMessage,1,node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage,void node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage (StringView),inspector_agent.cc,"void dispatchProtocolMessage(const StringView& message) {
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",250.0,268.0,3.0,3.0,19.0,22,6,24,15,0,2,2,2,0,0,,0,2,2,1,1,void
1143,122855,ownership,1,v8impl.RefBase.ownership,Ownership v8impl.RefBase.ownership (),js_native_api_v8.hpp,Ownership ownership() { return ownership_; },390.0,390.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Ownership
1144,81901,JSValue,1,node.heap.JSGraphJSNode.JSValue,Local<Value> node.heap.JSGraphJSNode.JSValue (),heap_utils.cc,Local<Value> JSValue() { return PersistentToLocal::Strong(persistent_); },51.0,51.0,3.0,75.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,Local<Value>
1145,122865,refcount_,3,v8impl.RefBase.refcount_,,js_native_api_v8.hpp,refcount_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1146,122866,ownership_,3,v8impl.RefBase.ownership_,,js_native_api_v8.hpp,ownership_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
