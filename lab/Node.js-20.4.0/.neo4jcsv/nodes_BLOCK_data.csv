6,BLOCK,-1,,<empty>,1,,1,1,,ANY
15,BLOCK,-1,,<empty>,1,,1,1,,ANY
26,BLOCK,-1,,<empty>,1,,1,1,,ANY
37,BLOCK,-1,,<empty>,1,,1,1,,ANY
48,BLOCK,-1,,<empty>,1,,1,1,,ANY
57,BLOCK,-1,,<empty>,1,,1,1,,ANY
64,BLOCK,-1,,"{
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",36,,19,5,,void
77,BLOCK,-1,,"{
  EmitAsyncDestroy(env_, async_context_);
}",33,,25,1,,void
87,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            callback, argc, argv,
                            async_context_);
}",67,,31,4,,void
108,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            method, argc, argv,
                            async_context_);
}",67,,39,4,,void
129,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",67,,47,4,,void
147,BLOCK,-1,,"{
  return resource_.Get(env_->isolate());
}",45,,53,1,,void
160,BLOCK,-1,,"{
  return async_context_.async_id;
}",46,,57,1,,void
168,BLOCK,-1,,"{
  return async_context_.trigger_async_id;
}",54,,61,1,,void
177,BLOCK,-1,,<empty>,48,,68,2,,void
182,BLOCK,-1,,"{
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  }",39,,103,1,,void
188,BLOCK,-1,,"{
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }",30,,104,2,,void
202,BLOCK,-1,,{ isolate->SetIdle(true); },34,,114,1,,void
213,BLOCK,-1,,{ env_->RunWeakRefCleanup(); },45,,133,1,,void
231,BLOCK,-1,,<empty>,1,,1,1,,ANY
237,BLOCK,-1,,<empty>,76,,22,4,,void
244,BLOCK,-1,,"{
  try_catch_.SetVerbose(true);
}",32,,30,4,,void
253,BLOCK,-1,,"{
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",33,,34,1,,void
259,BLOCK,-1,,<empty>,5,,36,2,,void
271,BLOCK,-1,,<empty>,36,,45,3,,void
279,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->PushAsyncCallbackScope();

  if (!env->can_call_into_js()) {
    failed_ = true;
    return;
  }

  Isolate* isolate = env->isolate();

  HandleScope handle_scope(isolate);
  Local<Context> current_context = isolate->GetCurrentContext();
  // If you hit this assertion, the caller forgot to enter the right Node.js
  // Environment's v8::Context first.
  // We first check `env->context() != current_context` because the contexts
  // likely *are* the same, in which case we can skip the slightly more
  // expensive Environment::GetCurrent() call.
  if (UNLIKELY(env->context() != current_context)) {
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }

  isolate->SetIdle(false);

  env->async_hooks()->push_async_context(
    async_context_.async_id, async_context_.trigger_async_id, object);

  pushed_ids_ = true;

  if (asyncContext.async_id != 0 && !skip_hooks_) {
    // No need to check a return value because the application will exit if
    // an ex...",48,,55,5,,void
292,BLOCK,-1,,"{
    failed_ = true;
    return;
  }",33,,59,2,,void
325,BLOCK,-1,,"{
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }",52,,73,2,,void
364,BLOCK,-1,,"{
    // No need to check a return value because the application will exit if
    // an exception occurs.
    AsyncWrap::EmitBefore(env, asyncContext.async_id);
  }",51,,84,2,,void
376,BLOCK,-1,,"{
  Close();
  env_->PopAsyncCallbackScope();
}",49,,91,1,,void
385,BLOCK,-1,,"{
  if (closed_) return;
  closed_ = true;

  // This function must ends up with either cleanup the
  // async id stack or pop the topmost one from it

  auto perform_stopping_check = [&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  };
  perform_stopping_check();

  if (env_->is_stopping()) return;

  Isolate* isolate = env_->isolate();
  auto idle = OnScopeLeave([&]() { isolate->SetIdle(true); });

  if (!failed_ && async_context_.async_id != 0 && !skip_hooks_) {
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }

  if (pushed_ids_)
    env_->async_hooks()->pop_async_context(async_context_.async_id);

  if (failed_) return;

  if (env_->async_callback_scope_depth() > 1 || skip_task_queues_) {
    return;
  }

  TickInfo* tick_info = env_->tick_info();

  if (!env_->can_call_into_js()) return;

  auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); });

  Local<Context> context = env_-...",37,,96,1,,void
388,BLOCK,-1,,<empty>,16,,97,2,,void
403,BLOCK,-1,,<empty>,28,,111,2,,void
428,BLOCK,-1,,"{
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }",65,,116,2,,void
439,BLOCK,-1,,<empty>,5,,121,2,,void
452,BLOCK,-1,,<empty>,16,,123,2,,void
463,BLOCK,-1,,"{
    return;
  }",68,,125,2,,void
478,BLOCK,-1,,<empty>,34,,131,2,,void
501,BLOCK,-1,,"{
    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);

    perform_stopping_check();
  }",41,,136,2,,void
523,BLOCK,-1,,"{
    CHECK_EQ(env_->execution_async_id(), 0);
    CHECK_EQ(env_->trigger_async_id(), 0);
  }",59,,144,2,,void
548,BLOCK,-1,,"{
    return;
  }",80,,149,2,,void
569,BLOCK,-1,,<empty>,34,,156,2,,void
599,BLOCK,-1,,"{
    failed_ = true;
  }",68,,164,2,,void
614,BLOCK,-1,,"{
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }

  InternalCallbackScope scope(env, resource, asyncContext, flags);
  if (scope.Failed()) {
    return MaybeLocal<Value>();
  }

  MaybeLocal<Value> ret;

  Local<Context> context = env->context();
  if (use_async_hooks_t...",68,,176,8,,void
654,BLOCK,-1,,"{
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }",27,,187,2,,void
701,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,198,2,,void
721,BLOCK,-1,,"{
    MaybeStackBuffer<Local<Value>, 16> args(3 + argc);
    args[0] = v8::Number::New(env->isolate(), asyncContext.async_id);
    args[1] = resource;
    args[2] = callback;
    for (int i = 0; i < argc; i++) {
      args[i + 3] = argv[i];
    }
    ret = hook_cb->Call(context, recv, args.length(), &args[0]);
  }",35,,205,2,,void
755,BLOCK,-1,,<empty>,5,,210,1,,void
765,BLOCK,4,,"{
      args[i + 3] = argv[i];
    }",36,,210,4,,void
792,BLOCK,-1,,"{
    ret = callback->Call(context, recv, argc, argv);
  }",10,,214,1,,void
808,BLOCK,-1,,"{
    scope.MarkAsFailed();
    return MaybeLocal<Value>();
  }",22,,218,2,,void
824,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,224,2,,void
838,BLOCK,-1,,"{
  Local<String> method_string =
      String::NewFromUtf8(isolate, method).ToLocalChecked();
  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);
}",60,,238,7,,void
871,BLOCK,-1,,"{
  // Check can_call_into_js() first because calling Get() might do so.
  Environment* env =
      Environment::GetCurrent(recv->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Value> callback_v;
  if (!recv->Get(isolate->GetCurrentContext(), symbol).ToLocal(&callback_v))
    return Local<Value>();
  if (!callback_v->IsFunction()) {
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }
  Local<Function> callback = callback_v.As<Function>();
  return MakeCallback(isolate, recv, callback, argc, argv, asyncContext);
}",60,,249,7,,void
894,BLOCK,-1,,<empty>,33,,254,2,,void
918,BLOCK,-1,,<empty>,5,,258,2,,void
927,BLOCK,-1,,"{
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }",34,,259,2,,void
958,BLOCK,-1,,"{
  // Observe the following two subtleties:
  //
  // 1. The environment is retrieved from the callback function's context.
  // 2. The context to enter is retrieved from the environment.
  //
  // Because of the AssignToContext() call in src/node_contextify.cc,
  // the two contexts need not be the same.
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  Context::Scope context_scope(env->context());
  MaybeLocal<Value> ret =
      InternalMakeCallback(env, recv, recv, callback, argc, argv, asyncContext);
  if (ret.IsEmpty() && env->async_callback_scope_depth() == 0) {
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }
  return ret;
}",60,,273,7,,void
1007,BLOCK,-1,,"{
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }",64,,287,2,,void
1021,BLOCK,-1,,"{
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  if (env->async_callback_scope_depth()) {
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }

  // This is a toplevel invocation and the caller (intentionally)
  // didn't provide any async_context to run in. Install a default context.
  MaybeLocal<Value> ret =
    InternalMakeCallback(env, env->process_object(), recv, callback, argc, argv,
                         async_context{0, 0});
  return ret;
}",57,,303,6,,void
1044,BLOCK,-1,,<empty>,33,,307,2,,void
1065,BLOCK,-1,,"{
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }",42,,311,2,,void
1105,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, method, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,331,6,,void
1135,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,342,6,,void
1165,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,353,6,,void
1192,BLOCK,-1,,{ realm->VerifyNoStrongBaseObjects(); },38,,75,2,,void
1202,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    }",47,,136,1,,void
1208,BLOCK,-1,,"{
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }",39,,137,2,,void
1227,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }",64,,192,2,,void
1251,BLOCK,-1,,"{
      *static_cast<bool*>(data) = true;
    }",73,,217,2,,void
1271,BLOCK,-1,,<empty>,1,,1,1,,ANY
1275,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  MultiIsolatePlatform* platform = GetMultiIsolatePlatform(env);
  CHECK_NOT_NULL(platform);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  SealHandleScope seal(isolate);

  if (env->is_stopping()) return Nothing<ExitCode>();

  env->set_trace_sync_io(env->options()->trace_sync_io);
  {
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      ...",57,,22,2,,void
1309,BLOCK,-1,,<empty>,27,,32,2,,void
1322,BLOCK,15,,"{
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    } while (more == true && !env->is_stopping());
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);
  }",3,,35,15,,void
1337,BLOCK,-1,,"{
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    }",8,,39,1,,void
1343,BLOCK,-1,,<empty>,31,,40,2,,void
1356,BLOCK,-1,,<empty>,31,,42,2,,void
1378,BLOCK,-1,,<empty>,40,,47,2,,void
1386,BLOCK,-1,,<empty>,9,,50,2,,void
1388,BLOCK,8,,"{
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }",7,,52,8,,void
1400,BLOCK,-1,,"{
          break;
        }",60,,54,2,,void
1435,BLOCK,-1,,<empty>,27,,66,2,,void
1472,BLOCK,-1,,<empty>,,,,1,,<empty>
1486,BLOCK,-1,,"{
  CHECK_NOT_NULL(platform);
  CHECK_NOT_NULL(errors);

  impl_->platform = platform;
  uv_loop_t* loop = &impl_->loop;
  // Use `data` to tell the destructor whether the loop was initialized or not.
  loop->data = nullptr;
  int ret = uv_loop_init(loop);
  if (ret != 0) {
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }
  loop->data = this;

  Isolate* isolate;
  if (flags & Flags::kIsForSnapshotting) {
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMi...",25,,96,6,,void
1517,BLOCK,-1,,"{
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }",17,,105,2,,void
1541,BLOCK,-1,,"{
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMiscHandlers(isolate, {});
  }",42,,113,2,,void
1593,BLOCK,-1,,"{
    impl_->allocator = ArrayBufferAllocator::Create();
    isolate = impl_->isolate =
        NewIsolate(impl_->allocator, &impl_->loop, platform, snapshot_data);
  }",10,,124,1,,void
1618,BLOCK,13,,"{
    Locker locker(isolate);
    Isolate::Scope isolate_scope(isolate);
    HandleScope handle_scope(isolate);

    TryCatch bootstrapCatch(isolate);
    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    });

    impl_->isolate_data.reset(CreateIsolateData(
        isolate, loop, platform, impl_->allocator.get(), snapshot_data));
    impl_->isolate_data->set_is_building_snapshot(
        impl_->snapshot_creator.has_value());

    if (snapshot_data) {
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }

    Local<Context> context = NewContext(isolate);
    impl_->main_context.Reset(isolate, context);
    if (context.IsEmpty()) {
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }

    Cont...",3,,130,13,,void
1666,BLOCK,-1,,"{
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }",24,,148,2,,void
1679,BLOCK,-1,,"{
        impl_->main_context.Reset(isolate, impl_->env->context());
      }",23,,150,2,,void
1715,BLOCK,-1,,"{
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }",28,,158,2,,void
1739,BLOCK,-1,,<empty>,74,,172,4,,void
1745,BLOCK,-1,,"{
  // It's not guaranteed that a context that goes through
  // v8_inspector::V8Inspector::contextCreated() is runtime-independent,
  // so do not start the inspector on the main context when building
  // the default snapshot.
  uint64_t env_flags =
      EnvironmentFlags::kDefaultFlags | EnvironmentFlags::kNoCreateInspector;

  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      nullptr,
      true,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",48,,179,5,,void
1777,BLOCK,-1,,<empty>,25,,200,2,,void
1787,BLOCK,-1,,"{
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",51,,204,1,,void
1794,BLOCK,-1,,"{
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }",34,,205,2,,void
1801,BLOCK,3,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }",5,,207,3,,void
1854,BLOCK,-1,,<empty>,7,,222,2,,void
1862,BLOCK,-1,,<empty>,7,,224,1,,void
1888,BLOCK,-1,,<empty>,5,,232,2,,void
1899,BLOCK,-1,,"{
  CHECK_NOT_NULL(snapshot_creator());
  SnapshotData* snapshot_data = new SnapshotData();
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};

  auto exit_code = SnapshotBuilder::CreateSnapshot(
      snapshot_data,
      this,
      static_cast<uint8_t>(SnapshotMetadata::Type::kFullyCustomized));
  if (exit_code != ExitCode::kNoFailure) return {};

  return result;
}",72,,237,1,,void
1937,BLOCK,-1,,<empty>,42,,247,2,,void
1945,BLOCK,-1,,"{
  Maybe<ExitCode> result = SpinEventLoopInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",44,,252,2,,void
1959,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,254,2,,void
1973,BLOCK,-1,,"{
  return &impl_->loop;
}",55,,260,1,,void
1982,BLOCK,-1,,"{
  return impl_->allocator;
}",56,,265,1,,void
1990,BLOCK,-1,,"{
  return impl_->isolate;
}",50,,269,1,,void
1998,BLOCK,-1,,"{
  return impl_->isolate_data.get();
}",59,,273,1,,void
2009,BLOCK,-1,,"{
  return impl_->env.get();
}",50,,277,1,,void
2020,BLOCK,-1,,"{
  return impl_->main_context.Get(impl_->isolate);
}",64,,281,1,,void
2034,BLOCK,-1,,"{
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",65,,285,1,,void
2052,BLOCK,-1,,"{
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",45,,290,2,,void
2076,BLOCK,-1,,"{
    delete data->impl_;
  }",75,,293,2,,void
2086,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(
      SnapshotBuilder::GetEmbeddedSnapshotData(), false)};
}",75,,299,1,,void
2101,BLOCK,-1,,"{
  SnapshotData* snapshot_data = new SnapshotData();
  CHECK_EQ(snapshot_data->data_ownership, SnapshotData::DataOwnership::kOwned);
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};
  if (!SnapshotData::FromBlob(snapshot_data, in)) {
    return {};
  }
  return result;
}",34,,305,2,,void
2132,BLOCK,-1,,"{
    return {};
  }",51,,310,2,,void
2140,BLOCK,-1,,"{
  return FromBlob(ReadFileSync(in));
}",72,,316,2,,void
2148,BLOCK,-1,,"{
  return impl_->ToBlob();
}",56,,320,1,,void
2158,BLOCK,-1,,"{
  impl_->ToFile(out);
}",52,,324,2,,void
2169,BLOCK,-1,,<empty>,42,,330,3,,void
2173,BLOCK,-1,,"{
#ifdef NODE_V8_SHARED_RO_HEAP
  return false;
#else
  return true;
#endif
}",61,,332,1,,void
2190,BLOCK,-1,,<empty>,1,,1,1,,ANY
2195,BLOCK,-1,,"{
  switch (encoding[0]) {
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encod...",61,,14,3,,void
2200,BLOCK,-1,,"{
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encoding, ""ucs-2""))
        re...",24,,15,2,,void
2217,BLOCK,-1,,"{
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      }",53,,23,2,,void
2243,BLOCK,-1,,<empty>,11,,27,2,,void
2255,BLOCK,-1,,<empty>,11,,29,2,,void
2259,BLOCK,-1,,<empty>,14,,31,1,,void
2272,BLOCK,-1,,"{
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }",60,,31,2,,void
2298,BLOCK,-1,,<empty>,11,,34,2,,void
2305,BLOCK,-1,,<empty>,9,,37,2,,void
2312,BLOCK,-1,,<empty>,9,,39,2,,void
2319,BLOCK,-1,,<empty>,9,,41,2,,void
2326,BLOCK,-1,,<empty>,9,,43,2,,void
2333,BLOCK,-1,,<empty>,9,,45,2,,void
2340,BLOCK,-1,,<empty>,9,,47,2,,void
2354,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""tin1"", 5) == 0)
          return LATIN1;
      }",31,,53,2,,void
2364,BLOCK,-1,,<empty>,11,,55,2,,void
2371,BLOCK,-1,,<empty>,9,,58,2,,void
2385,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""nary"", 5) == 0)
          return LATIN1;
      // buffer
      }",31,,64,2,,void
2395,BLOCK,-1,,<empty>,11,,66,2,,void
2399,BLOCK,-1,,<empty>,14,,68,1,,void
2406,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""ffer"", 5) == 0)
          return BUFFER;
      // base64
      }",38,,68,2,,void
2416,BLOCK,-1,,<empty>,11,,70,2,,void
2420,BLOCK,-1,,<empty>,14,,72,1,,void
2427,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""se64"", 5) == 0)
          return BASE64;
        if (strncmp(encoding + 2, ""se64url"", 8) == 0)
          return BASE64URL;
      }",38,,72,2,,void
2437,BLOCK,-1,,<empty>,11,,74,2,,void
2449,BLOCK,-1,,<empty>,11,,76,2,,void
2456,BLOCK,-1,,<empty>,9,,79,2,,void
2463,BLOCK,-1,,<empty>,9,,81,2,,void
2470,BLOCK,-1,,<empty>,9,,83,2,,void
2477,BLOCK,-1,,<empty>,9,,85,2,,void
2491,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""cii"", 4) == 0)
          return ASCII;
      }",31,,91,2,,void
2501,BLOCK,-1,,<empty>,11,,93,2,,void
2508,BLOCK,-1,,<empty>,9,,96,2,,void
2522,BLOCK,-1,,<empty>,9,,103,2,,void
2535,BLOCK,-1,,<empty>,11,,104,2,,void
2542,BLOCK,-1,,<empty>,9,,106,2,,void
2554,BLOCK,-1,,"{
  CHECK(!encoding_v.IsEmpty());

  if (!encoding_v->IsString())
    return default_encoding;

  Utf8Value encoding(isolate, encoding_v);

  return ParseEncoding(*encoding, default_encoding);
}",61,,115,4,,void
2567,BLOCK,-1,,<empty>,5,,119,2,,void
2586,BLOCK,-1,,"{
  CHECK_NE(encoding, UCS2);
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, encoding, &error)
      .ToLocalChecked();
}",45,,129,5,,void
2615,BLOCK,-1,,"{
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, &error)
      .ToLocalChecked();
}",72,,136,4,,void
2640,BLOCK,-1,,"{
  HandleScope scope(isolate);

  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);
}",45,,145,4,,void
2665,BLOCK,-1,,"{
  return StringBytes::Write(isolate, buf, buflen, val, encoding);
}",45,,156,6,,void
2681,BLOCK,-1,,"{
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      }",77,,556,2,,void
2725,BLOCK,-1,,"{
    movedHandler(env, static_cast<int>(exit_code));
  }",75,,932,3,,void
2771,BLOCK,-1,,<empty>,1,,1,1,,ANY
2776,BLOCK,-1,,"{
  Local<Value> wasm_code_gen =
      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);
  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();
}",53,,48,3,,void
2804,BLOCK,-1,,"{
  DebugSealHandleScope scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  return env != nullptr &&
         (env->is_main_thread() || !env->is_stopping()) &&
         env->abort_on_uncaught_exception() &&
         env->should_abort_on_uncaught_toggle()[0] &&
         !env->inside_should_not_abort_on_uncaught_scope();
}",55,,54,2,,void
2855,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Realm* realm = Realm::GetCurrent(context);
  Local<Function> prepare;
  if (realm != nullptr) {
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  } else {
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }
  if (prepare.IsEmpty()) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Local<Value> args[] = {
      context->Global(),
      exception,
      trace,
  };
  // This TryCatch + Rethrow is required by V8 due to details around exception
  // ha...",65,,66,4,,void
2868,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",23,,68,2,,void
2896,BLOCK,-1,,"{
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  }",25,,73,2,,void
2904,BLOCK,-1,,"{
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }",10,,78,1,,void
2919,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",26,,83,2,,void
2973,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,98,2,,void
2984,BLOCK,-1,,"{
  void* ret;
  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)
    ret = allocator_->Allocate(size);
  else
    ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",55,,104,2,,void
2994,BLOCK,-1,,<empty>,5,,107,2,,void
3003,BLOCK,-1,,<empty>,5,,109,1,,void
3016,BLOCK,-1,,<empty>,5,,111,2,,void
3031,BLOCK,-1,,"{
  void* ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",68,,115,2,,void
3045,BLOCK,-1,,<empty>,5,,118,2,,void
3062,BLOCK,-1,,"{
  void* ret = allocator_->Reallocate(data, old_size, size);
  if (LIKELY(ret != nullptr) || UNLIKELY(size == 0))
    total_mem_usage_.fetch_add(size - old_size, std::memory_order_relaxed);
  return ret;
}",47,,123,4,,void
3083,BLOCK,-1,,<empty>,5,,126,2,,void
3101,BLOCK,-1,,"{
  total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
  allocator_->Free(data, size);
}",62,,130,3,,void
3119,BLOCK,-1,,"{
  CHECK(allocations_.empty());
}",65,,135,1,,void
3129,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::Allocate(size);
  RegisterPointerInternal(data, size);
  return data;
}",60,,139,2,,void
3150,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::AllocateUninitialized(size);
  RegisterPointerInternal(data, size);
  return data;
}",73,,146,2,,void
3172,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  UnregisterPointerInternal(data, size);
  NodeArrayBufferAllocator::Free(data, size);
}",67,,153,3,,void
3191,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* ret = NodeArrayBufferAllocator::Reallocate(data, old_size, size);
  if (ret == nullptr) {
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }

  if (data != nullptr) {
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }

  RegisterPointerInternal(ret, size);
  return ret;
}",62,,161,4,,void
3209,BLOCK,-1,,"{
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }",23,,164,2,,void
3214,BLOCK,-1,,"{  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }",20,,165,2,,void
3224,BLOCK,-1,,"{
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }",24,,174,2,,void
3254,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::RegisterPointer(data, size);
  RegisterPointerInternal(data, size);
}",78,,184,3,,void
3272,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::UnregisterPointer(data, size);
  UnregisterPointerInternal(data, size);
}",80,,190,3,,void
3290,BLOCK,-1,,"{
  if (data == nullptr) return;
  auto it = allocations_.find(data);
  CHECK_NE(it, allocations_.end());
  if (size > 0) {
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }
  allocations_.erase(it);
}",76,,197,3,,void
3295,BLOCK,-1,,<empty>,24,,198,2,,void
3315,BLOCK,-1,,"{
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }",17,,201,2,,void
3331,BLOCK,-1,,"{
  if (data == nullptr) return;
  CHECK_EQ(allocations_.count(data), 0);
  allocations_[data] = size;
}",74,,210,3,,void
3336,BLOCK,-1,,<empty>,24,,211,2,,void
3354,BLOCK,-1,,"{
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",80,,216,2,,void
3363,BLOCK,-1,,<empty>,5,,218,2,,void
3370,BLOCK,-1,,<empty>,5,,220,1,,void
3379,BLOCK,-1,,"{
  return ArrayBufferAllocator::Create().release();
}",52,,223,1,,void
3392,BLOCK,-1,,"{
  delete allocator;
}",64,,227,2,,void
3399,BLOCK,-1,,"{
  const uint64_t constrained_memory = uv_get_constrained_memory();
  const uint64_t total_memory = constrained_memory > 0 ?
      std::min(uv_get_total_memory(), constrained_memory) :
      uv_get_total_memory();
  if (total_memory > 0 &&
      params->constraints.max_old_generation_size_in_bytes() == 0) {
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }
  params->embedder_wrapper_object_index = BaseObject::InternalFields::kSlot;
  params->embedder_wrapper_type_index = std::numeric_limits<int>::max();

#ifdef NODE_ENABLE_VTUNE_PROFILING
  params->code_event_handler = vTune::GetVtuneCodeEventHandler();
#endif
}",67,,231,2,,void
3431,BLOCK,-1,,"{
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }",68,,237,2,,void
3464,BLOCK,-1,,"{
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }
}",78,,251,3,,void
3471,BLOCK,-1,,<empty>,5,,253,2,,void
3535,BLOCK,-1,,"{
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }",69,,268,2,,void
3557,BLOCK,-1,,"{
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

  if (per_process::cli_options->get_per_isolate_options()
          ->experi...",77,,275,3,,void
3591,BLOCK,-1,,"{
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }",66,,284,2,,void
3621,BLOCK,-1,,"{
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }",33,,294,2,,void
3638,BLOCK,-1,,"{
    isolate->SetHostCreateShadowRealmContextCallback(
        shadow_realm::HostCreateShadowRealmContextCallback);
  }",40,,299,2,,void
3654,BLOCK,-1,,"{
    auto* promise_reject_cb = s.promise_reject_callback ?
      s.promise_reject_callback : PromiseRejectCallback;
    isolate->SetPromiseRejectCallback(promise_reject_cb);
  }",67,,304,2,,void
3677,BLOCK,-1,,<empty>,5,,311,2,,void
3690,BLOCK,-1,,"{
  SetIsolateErrorHandlers(isolate, settings);
  SetIsolateMiscHandlers(isolate, settings);
}",59,,315,3,,void
3701,BLOCK,-1,,"{
  IsolateSettings settings;
  SetIsolateUpForNode(isolate, settings);
}",48,,320,2,,void
3714,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  if (isolate == nullptr) return nullptr;

  if (snapshot_data != nullptr) {
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }

#ifdef NODE_V8_SHARED_RO_HEAP
  {
    // In shared-readonly-heap mode, V8 requires all snapshots used for
    // creating Isolates to be identical. This isn't really memory-safe
    // but also otherwise just doesn't work, and the only real alternative
    // is disabling shared-readonly-heap mode altogether.
    static Isolate::CreateParams first_params = *params;
    params->snapshot_blob = first_params.snapshot_blob;
    params->external_references = first_params.external_references;
  }
#endif

  // Register the isolate on the platform before the isolate gets initialized,
  // so that the isolate can access the platform during initialization.
  platform->RegisterIsolate(isolate, event_loop);

  SetIsolateCreateParamsForNode(params);
  Isolate::Initialize(isolate, *params);
  if (snapshot...",54,,331,6,,void
3726,BLOCK,-1,,<empty>,27,,333,2,,void
3733,BLOCK,-1,,"{
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }",33,,335,2,,void
3759,BLOCK,-1,,"{
    // If in deserialize mode, delay until after the deserialization is
    // complete.
    SetIsolateUpForNode(isolate, settings);
  }",33,,357,2,,void
3764,BLOCK,-1,,"{
    SetIsolateMiscHandlers(isolate, settings);
  }",10,,361,1,,void
3778,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator != nullptr) params.array_buffer_allocator = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,372,6,,void
3784,BLOCK,-1,,<empty>,29,,374,2,,void
3810,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator) params.array_buffer_allocator_shared = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,386,6,,void
3814,BLOCK,-1,,<empty>,18,,388,2,,void
3840,BLOCK,-1,,"{
  const SnapshotData* snapshot_data =
      SnapshotData::FromEmbedderWrapper(embedder_snapshot_data);
  return new IsolateData(isolate, loop, platform, allocator, snapshot_data);
}",57,,401,6,,void
3861,BLOCK,-1,,"{
  delete isolate_data;
}",49,,407,2,,void
3867,BLOCK,-1,,<empty>,49,,411,1,,void
3878,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope handle_scope(isolate);

  const bool use_snapshot = context.IsEmpty();
  const EnvSerializeInfo* env_snapshot_info = nullptr;
  if (use_snapshot) {
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }

  // TODO(addaleax): This is a much better place for parsing per-Environment
  // options than the global parse call.
  Environment* env = new Environment(isolate_data,
                                     isolate,
                                     args,
                                     exec_args,
                                     env_snapshot_info,
                                     flags,
                                     thread_id);
  CHECK_NOT_NULL(env);

  if (use_snapshot) {
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {Deseriali...",69,,431,8,,void
3902,BLOCK,-1,,"{
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }",21,,437,2,,void
3933,BLOCK,-1,,"{
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {DeserializeNodeInternalFields, env})
                  .ToLocalChecked();

    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);

    if (InitializeContextRuntime(context).IsNothing()) {
      FreeEnvironment(env);
      return nullptr;
    }
    SetIsolateErrorHandlers(isolate, {});
  }",21,,453,2,,void
3965,BLOCK,-1,,"{
      FreeEnvironment(env);
      return nullptr;
    }",56,,462,2,,void
3996,BLOCK,-1,,"{
    FreeEnvironment(env);
    return nullptr;
  }",78,,484,2,,void
4007,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate,
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);
  {
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }

  // This call needs to be made while the `Environment` is still alive
  // because we assume that it is available for async tracking in the
  // NodePlatform implementation.
  MultiIsolatePlatform* platform = env->isolate_data()->platform();
  if (platform != nullptr)
    platform->DrainTasks(isolate);

  delete env;
}",40,,492,2,,void
4023,BLOCK,5,,"{
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }",3,,496,5,,void
4070,BLOCK,-1,,<empty>,5,,515,2,,void
4084,BLOCK,-1,,"{
  return GetInspectorParentHandle(env, thread_id, url, """");
}",22,,523,4,,void
4098,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  if (name == nullptr) name = """";
  CHECK_NE(thread_id.id, static_cast<uint64_t>(-1));
  if (!env->should_create_inspector()) {
    return nullptr;
  }
#if HAVE_INSPECTOR
  return std::make_unique<InspectorParentHandleImpl>(
      env->inspector_agent()->GetParentHandle(thread_id.id, url, name));
#else
  return {};
#endif
}",78,,528,5,,void
4105,BLOCK,-1,,<empty>,24,,530,2,,void
4123,BLOCK,-1,,"{
    return nullptr;
  }",40,,532,2,,void
4132,BLOCK,-1,,"{
  env->InitializeLibuv();
  env->InitializeDiagnostics();

  return StartExecution(env, cb);
}",32,,545,3,,void
4148,BLOCK,-1,,"{
  CHECK_NOT_NULL(main_script_source_utf8.data());
  return LoadEnvironment(
      env, [&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      });
}",77,,553,3,,void
4162,BLOCK,-1,,"{
  return Environment::GetCurrent(context);
}",60,,564,2,,void
4173,BLOCK,-1,,"{
  return env->isolate_data();
}",58,,568,2,,void
4183,BLOCK,-1,,"{
  return isolate_data->node_allocator();
}",74,,572,2,,void
4193,BLOCK,-1,,"{
  return env->context();
}",49,,576,2,,void
4203,BLOCK,-1,,"{
  return GetMultiIsolatePlatform(env->isolate_data());
}",65,,580,2,,void
4214,BLOCK,-1,,"{
  return env->platform();
}",65,,584,2,,void
4225,BLOCK,-1,,"{
  return CreatePlatform(
      thread_pool_size,
      static_cast<v8::TracingController*>(tracing_controller));
}",59,,590,3,,void
4237,BLOCK,-1,,"{
  return MultiIsolatePlatform::Create(thread_pool_size,
                                      tracing_controller)
      .release();
}",48,,598,3,,void
4252,BLOCK,-1,,"{
  delete platform;
}",51,,604,2,,void
4261,BLOCK,-1,,"{
  return std::make_unique<NodePlatform>(thread_pool_size,
                                        tracing_controller,
                                        page_allocator);
}",40,,611,4,,void
4278,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope handle_scope(isolate);

  Local<Object> global = context->Global();
  Local<Private> key = Private::ForApi(isolate,
      FIXED_ONE_BYTE_STRING(isolate, ""node:per_context_binding_exports""));

  Local<Value> existing_value;
  if (!global->GetPrivate(context, key).ToLocal(&existing_value))
    return MaybeLocal<Object>();
  if (existing_value->IsObject())
    return handle_scope.Escape(existing_value.As<Object>());

  Local<Object> exports = Object::New(isolate);
  if (context->Global()->SetPrivate(context, key, exports).IsNothing() ||
      InitializePrimordials(context).IsNothing())
    return MaybeLocal<Object>();
  return handle_scope.Escape(exports);
}",65,,617,2,,void
4331,BLOCK,-1,,<empty>,5,,627,2,,void
4339,BLOCK,-1,,<empty>,5,,629,2,,void
4380,BLOCK,-1,,<empty>,5,,634,2,,void
4394,BLOCK,-1,,"{
  auto context = Context::New(isolate, nullptr, object_template);
  if (context.IsEmpty()) return context;

  if (InitializeContext(context).IsNothing()) {
    return Local<Context>();
  }

  return context;
}",66,,642,3,,void
4410,BLOCK,-1,,<empty>,26,,644,2,,void
4419,BLOCK,-1,,"{
    return Local<Context>();
  }",47,,646,2,,void
4428,BLOCK,-1,,"{
  THROW_ERR_PROTO_ACCESS(info.GetIsolate());
}",60,,653,2,,void
4438,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // When `IsCodeGenerationFromStringsAllowed` is true, V8 takes the fast path
  // and ignores the ModifyCodeGenerationFromStrings callback. Set it to false
  // to delegate the code generation validation to
  // node::ModifyCodeGenerationFromStrings.
  // The `IsCodeGenerationFromStringsAllowed` can be refreshed by V8 according
  // to the runtime flags, propagate the value to the embedder data.
  bool is_code_generation_from_strings_allowed =
      context->IsCodeGenerationFromStringsAllowed();
  context->AllowCodeGenerationFromStrings(false);
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings,
      Boolean::New(isolate, is_code_generation_from_strings_allowed));

  if (per_process::cli_options->disable_proto == """") {
    return Just(true);
  }

  // Remove __proto__
  // https://github.com/nodejs/node/issues/31951
  Local<Object> prototype;
  {
    Local<Stri...",62,,659,2,,void
4482,BLOCK,-1,,"{
    return Just(true);
  }",54,,676,2,,void
4491,BLOCK,11,,"{
    Local<String> object_string =
      FIXED_ONE_BYTE_STRING(isolate, ""Object"");
    Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate, ""prototype"");

    Local<Value> object_v;
    if (!context->Global()
        ->Get(context, object_string)
        .ToLocal(&object_v)) {
      return Nothing<bool>();
    }

    Local<Value> prototype_v;
    if (!object_v.As<Object>()
        ->Get(context, prototype_string)
        .ToLocal(&prototype_v)) {
      return Nothing<bool>();
    }

    prototype = prototype_v.As<Object>();
  }",3,,683,11,,void
4531,BLOCK,-1,,"{
      return Nothing<bool>();
    }",30,,692,2,,void
4555,BLOCK,-1,,"{
      return Nothing<bool>();
    }",33,,699,2,,void
4581,BLOCK,-1,,"{
    if (prototype
        ->Delete(context, proto_string)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",60,,709,2,,void
4592,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,712,2,,void
4596,BLOCK,-1,,<empty>,10,,715,1,,void
4605,BLOCK,-1,,"{
    Local<Value> thrower;
    if (!Function::New(context, ProtoThrower)
        .ToLocal(&thrower)) {
      return Nothing<bool>();
    }

    PropertyDescriptor descriptor(thrower, thrower);
    descriptor.set_enumerable(false);
    descriptor.set_configurable(true);
    if (prototype
        ->DefineProperty(context, proto_string, descriptor)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",66,,715,2,,void
4624,BLOCK,-1,,"{
      return Nothing<bool>();
    }",29,,718,2,,void
4652,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,727,2,,void
4656,BLOCK,-1,,<empty>,10,,730,1,,void
4665,BLOCK,-1,,"{
    // Validated in ProcessGlobalArgs
    OnFatalError(""InitializeContextRuntime()"", ""invalid --disable-proto mode"");
  }",61,,730,2,,void
4676,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Delete `Intl.v8BreakIterator`
  // https://github.com/nodejs/node/issues/14909
  {
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }
  return Just(true);
}",70,,738,2,,void
4687,BLOCK,5,,"{
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }",3,,744,5,,void
4730,BLOCK,-1,,"{
      return Nothing<bool>();
    }",73,,751,2,,void
4751,BLOCK,-1,,"{
      return Nothing<bool>();
    }",78,,756,2,,void
4761,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Initialize the default values.
  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,
                           True(isolate));
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings, True(isolate));

  if (InitializeBaseContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }
  return InitializePrimordials(context);
}",70,,763,2,,void
4796,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,773,2,,void
4806,BLOCK,-1,,"{
  // Run per-context JS files.
  Isolate* isolate = context->GetIsolate();
  Context::Scope context_scope(context);
  Local<Object> exports;

  Local<String> primordials_string =
      FIXED_ONE_BYTE_STRING(isolate, ""primordials"");

  // Create primordials first and make it available to per-context scripts.
  Local<Object> primordials = Object::New(isolate);
  if (primordials->SetPrototype(context, Null(isolate)).IsNothing() ||
      !GetPerContextExports(context).ToLocal(&exports) ||
      exports->Set(context, primordials_string, primordials).IsNothing()) {
    return Nothing<bool>();
  }

  static const char* context_files[] = {""internal/per_context/primordials"",
                                        ""internal/per_context/domexception"",
                                        ""internal/per_context/messageport"",
                                        nullptr};

  // We do not have access to a per-Environment BuiltinLoader instance
  // at this point, because this code runs be...",59,,779,2,,void
4873,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,792,2,,void
4886,BLOCK,-1,,<empty>,3,,807,1,,void
4897,BLOCK,4,,"{
    Local<Value> arguments[] = {exports, primordials};
    if (builtin_loader
            .CompileAndCall(
                context, *module, arraysize(arguments), arguments, nullptr)
            .IsEmpty()) {
      // Execution failed during context creation.
      return Nothing<bool>();
    }
  }",75,,807,4,,void
4919,BLOCK,-1,,"{
      // Execution failed during context creation.
      return Nothing<bool>();
    }",25,,812,2,,void
4929,BLOCK,-1,,"{
  if (InitializeMainContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }

  return InitializeContextRuntime(context);
}",55,,822,2,,void
4936,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,823,2,,void
4946,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  if (context.IsEmpty()) return nullptr;
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) return nullptr;
  return env->event_loop();
}",50,,830,2,,void
4965,BLOCK,-1,,<empty>,26,,833,2,,void
4980,BLOCK,-1,,<empty>,23,,835,2,,void
4993,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  Mutex::ScopedLock lock(env->extra_linked_bindings_mutex());

  node_module* prev_tail = env->extra_linked_bindings_tail();
  env->extra_linked_bindings()->push_back(mod);
  if (prev_tail != nullptr)
    prev_tail->nm_link = &env->extra_linked_bindings()->back();
}",65,,839,3,,void
5021,BLOCK,-1,,<empty>,5,,846,2,,void
5039,BLOCK,-1,,"{
  node_module node_mod = napi_module_to_node_module(&mod);
  node_mod.nm_flags = NM_F_LINKED;
  AddLinkedBinding(env, node_mod);
}",65,,849,3,,void
5061,BLOCK,-1,,"{
  node_module mod = {
    NODE_MODULE_VERSION,
    NM_F_LINKED,
    nullptr,  // nm_dso_handle
    nullptr,  // nm_filename
    nullptr,  // nm_register_func
    fn,
    name,
    priv,
    nullptr   // nm_link
  };
  AddLinkedBinding(env, mod);
}",35,,858,5,,void
5067,BLOCK,1,,<empty>,,,,1,,void
5087,BLOCK,-1,,"{
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",51,,876,5,,void
5118,BLOCK,-1,,"{
  return ThreadId { next_thread_id++ };
}",40,,893,1,,void
5128,BLOCK,-1,,"{
  exit(static_cast<int>(exit_code));
}",44,,897,2,,void
5138,BLOCK,-1,,"{
  env->set_stopping(true);
  env->set_can_call_into_js(false);
  env->stop_sub_worker_contexts();
  env->isolate()->DumpAndResetStats();
  // The tracing agent could be in the process of writing data using the
  // threadpool. Stop it before shutting down libuv. The rest of the tracing
  // agent disposal will be performed in DisposePlatform().
  per_process::v8_platform.StopTracingAgent();
  // When the process exits, the tasks in the thread pool may also need to
  // access the data of V8Platform, such as trace agent, or a field
  // added in the future. So make sure the thread pool exits first.
  // And make sure V8Platform don not call into Libuv threadpool, see Dispose
  // in node_v8_platform-inl.h
  uv_library_shutdown();
  DisposePlatform();
  Exit(exit_code);
}",78,,901,3,,void
5175,BLOCK,-1,,"{
  DefaultProcessExitHandlerInternal(env, static_cast<ExitCode>(exit_code));
}",65,,920,3,,void
5186,BLOCK,-1,,"{
  env->set_process_exit_handler(std::move(handler));
}",78,,925,3,,void
5200,BLOCK,-1,,"{
  auto movedHandler = std::move(handler);
  env->set_process_exit_handler([=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  });
}",78,,930,3,,void
5234,BLOCK,-1,,<empty>,1,,1,1,,ANY
5242,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  Local<Value> e;
  Local<String> estring = OneByteString(isolate, errors::errno_string(errorno));
  if (msg == nullptr || msg[0] == '\0') {
    msg = strerror(errorno);
  }
  Local<String> message = OneByteString(isolate, msg);

  Local<String> cons =
      String::Concat(isolate, estring, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  cons = String::Concat(isolate, cons, message);

  Local<String> path_string;
  if (path != nullptr) {
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }

  if (path_string.IsEmpty() == false) {
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }
  e = Exception::Error(cons);

  Local<Context> context = env->cont...",47,,27,6,,void
5281,BLOCK,-1,,"{
    msg = strerror(errorno);
  }",41,,33,2,,void
5328,BLOCK,-1,,"{
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }",24,,43,2,,void
5347,BLOCK,-1,,"{
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",39,,48,2,,void
5444,BLOCK,-1,,"{
    obj->Set(context, env->path_string(), path_string).Check();
  }",39,,62,2,,void
5462,BLOCK,-1,,"{
    obj->Set(context,
             env->syscall_string(),
             OneByteString(isolate, syscall)).Check();
  }",27,,66,2,,void
5485,BLOCK,-1,,"{
#ifdef _WIN32
  if (strncmp(path, ""\\\\?\\UNC\\"", 8) == 0) {
    return String::Concat(
        isolate,
        FIXED_ONE_BYTE_STRING(isolate, ""\\\\""),
        String::NewFromUtf8(isolate, path + 8).ToLocalChecked());
  } else if (strncmp(path, ""\\\\?\\"", 4) == 0) {
    return String::NewFromUtf8(isolate, path + 4).ToLocalChecked();
  }
#endif

  return String::NewFromUtf8(isolate, path).ToLocalChecked();
}",73,,75,3,,void
5505,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  if (!msg || !msg[0])
    msg = uv_strerror(errorno);

  Local<String> js_code = OneByteString(isolate, uv_err_name(errorno));
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_path;
  Local<String> js_dest;

  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "": ""));
  js_msg = String::Concat(isolate, js_msg, OneByteString(isolate, msg));
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);

  if (path != nullptr) {
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }

  if (dest != nullptr...",44,,96,7,,void
5524,BLOCK,-1,,<empty>,5,,101,2,,void
5611,BLOCK,-1,,"{
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,116,2,,void
5652,BLOCK,-1,,"{
    js_dest = StringFromPath(isolate, dest);

    js_msg = String::Concat(
        isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" -> '""));
    js_msg = String::Concat(isolate, js_msg, js_dest);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,126,2,,void
5770,BLOCK,-1,,<empty>,5,,147,2,,void
5790,BLOCK,-1,,<empty>,5,,149,2,,void
5811,BLOCK,-1,,"{
  errors::TriggerUncaughtException(isolate, try_catch);
}",70,,246,3,,void
5823,BLOCK,-1,,"{
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  }",54,,172,2,,void
5853,BLOCK,-1,,<empty>,1,,1,1,,ANY
5857,BLOCK,-1,,"{
  env->RunAtExitCallbacks();
}",34,,20,2,,void
5868,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->AtExit(cb, arg);
}",65,,24,4,,void
5881,BLOCK,-1,,"{
  USE(EmitProcessBeforeExit(env));
}",39,,29,2,,void
5889,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""BeforeExit"");
  if (!env->destroy_async_id_list()->empty())
    AsyncWrap::DestroyAsyncIdsCallback(env);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  if (!env->can_call_into_js()) {
    return Nothing<bool>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  return ProcessEmit(env, ""beforeExit"", exit_code).IsEmpty() ?
      Nothing<bool>() : Just(true);
}",53,,33,2,,void
5903,BLOCK,-1,,<empty>,5,,36,2,,void
5931,BLOCK,-1,,"{
    return Nothing<bool>();
  }",33,,42,2,,void
5970,BLOCK,-1,,"{
  return EmitProcessExitInternal(env).FromMaybe(ExitCode::kGenericUserError);
}",52,,53,2,,void
5984,BLOCK,-1,,"{
  return static_cast<int>(EmitExitInternal(env));
}",32,,57,2,,void
5994,BLOCK,-1,,"{
  // process.emit('exit')
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  env->set_exiting(true);

  if (!env->can_call_into_js()) {
    return Nothing<ExitCode>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  if (ProcessEmit(env, ""exit"", exit_code).IsEmpty()) {
    return Nothing<ExitCode>();
  }
  // Reload exit code, it may be changed by `emit('exit')`
  return Just(env->exit_code(ExitCode::kNoFailure));
}",59,,61,2,,void
6022,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",33,,69,2,,void
6053,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",54,,76,2,,void
6069,BLOCK,-1,,"{
  Maybe<ExitCode> result = EmitProcessExitInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",46,,83,2,,void
6083,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,85,2,,void
6098,BLOCK,-1,,<empty>,,,,2,,<empty>
6105,BLOCK,-1,,<empty>,,,,4,,<empty>
6115,BLOCK,-1,,<empty>,,,,1,,<empty>
6125,BLOCK,-1,,{ delete handle; },60,,116,2,,void
6134,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->AddCleanupHook(fun, arg);
}",43,,120,4,,void
6157,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->RemoveCleanupHook(fun, arg);
}",46,,128,4,,void
6178,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",47,,134,2,,void
6207,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",44,,142,2,,void
6240,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  auto info = std::make_shared<AsyncCleanupHookInfo>();
  info->env = env;
  info->fun = fun;
  info->arg = arg;
  info->self = info;
  env->AddCleanupHook(RunAsyncCleanupHook, info.get());
  return new ACHHandle { info };
}",16,,152,4,,void
6294,BLOCK,-1,,"{
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",24,,165,2,,void
6301,BLOCK,-1,,<empty>,30,,166,2,,void
6330,BLOCK,-1,,"{
  env->RequestInterrupt([fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  });
}",76,,171,4,,void
6340,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->execution_async_id();
}",58,,181,2,,void
6353,BLOCK,-1,,<empty>,23,,183,2,,void
6366,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->trigger_async_id();
}",56,,187,2,,void
6379,BLOCK,-1,,<empty>,23,,189,2,,void
6395,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<String> type =
      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)
          .ToLocalChecked();
  return EmitAsyncInit(isolate, resource, type, trigger_async_id);
}",56,,197,5,,void
6430,BLOCK,-1,,"{
  DebugSealHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  // Initialize async context struct
  if (trigger_async_id == -1)
    trigger_async_id = env->get_default_trigger_async_id();

  async_context context = {
    env->new_async_id(),  // async_id_
    trigger_async_id  // trigger_async_id_
  };

  // Run init hooks
  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,
                           context.trigger_async_id);

  return context;
}",56,,208,5,,void
6449,BLOCK,-1,,<empty>,5,,215,2,,void
6485,BLOCK,-1,,"{
  EmitAsyncDestroy(Environment::GetCurrent(isolate), asyncContext);
}",69,,229,3,,void
6498,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env, asyncContext.async_id);
}",69,,233,3,,void
6517,BLOCK,-1,,<empty>,1,,1,1,,ANY
6521,BLOCK,-1,,"{
#define SIGNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (signo) {
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHL...",37,,7,2,,void
6524,BLOCK,-1,,"{
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHLD);
#endif

#ifdef SIGSTKFLT
    SIGNO_CASE(SIGSTKFLT);
#endif

#ifdef SIGCONT
    SIGNO_CASE(SIGCONT);
#endif

#ifdef SIGSTOP
    SIGNO_CASE(SIGSTOP);
#endif

#ifdef SIGTSTP
    SIGNO_CASE(SIGTST...",18,,11,2,,void
6526,BLOCK,1,,<empty>,,,,1,,void
6546,BLOCK,-1,,<empty>,1,,1,1,,ANY
6550,BLOCK,-1,,"{
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }",23,,569,2,,void
6561,BLOCK,-1,,"{
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      }",48,,566,2,,void
6600,BLOCK,-1,,<empty>,1,,1,1,,ANY
6611,BLOCK,-1,,"{
  Local<Function> fn = env->async_hooks_destroy_function();

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);

  do {
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  } while (!env->destroy_async_id_list()->empty());
}",59,,67,2,,void
6631,BLOCK,-1,,"{
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  }",6,,72,1,,void
6648,BLOCK,-1,,<empty>,35,,75,2,,void
6653,BLOCK,-1,,"{
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }",49,,76,3,,void
6702,BLOCK,-1,,<empty>,9,,85,2,,void
6719,BLOCK,-1,,"{
  AsyncHooks* async_hooks = env->async_hooks();

  if (async_hooks->fields()[type] == 0 || !env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Local<Value> async_id_value = Number::New(env->isolate(), async_id);
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));
}",31,,91,5,,void
6742,BLOCK,-1,,<empty>,5,,95,2,,void
6795,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kPromiseResolve,
       env->async_hooks_promise_resolve_function());
}",71,,104,3,,void
6809,BLOCK,-1,,"{
  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",40,,110,1,,void
6812,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",28,,111,2,,void
6822,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kBefore,
       env->async_hooks_before_function());
}",63,,126,3,,void
6838,BLOCK,-1,,"{
  switch (type) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",73,,132,3,,void
6841,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",17,,133,2,,void
6851,BLOCK,-1,,"{
  // If the user's callback failed then the after() hooks will be called at the
  // end of _fatalException().
  Emit(env, async_id, AsyncHooks::kAfter,
       env->async_hooks_after_function());
}",62,,148,3,,void
6866,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());

  // All of init, before, after, destroy, and promise_resolve are supplied by
  // async_hooks internally, so this should only ever be called once. At which
  // time all the functions should be set. Detect this by checking if
  // init !IsEmpty().
  CHECK(env->async_hooks_init_function().IsEmpty());

  Local<Object> fn_obj = args[0].As<Object>();

#define SET_HOOK_FN(name)                                                      \
  do {                                                                         \
    Local<Value> v =                                                           \
        fn_obj->Get(env->context(),                                            \
                    FIXED_ONE_BYTE_STRING(env->isolate(), #name))              \
            .ToLocalChecked();                                                 \
    CHECK(v->IsFunction());                                               ...",65,,155,2,,void
6903,BLOCK,1,,<empty>,,,,4,,void
6905,BLOCK,-1,,SET_HOOK_FN(init),3,,178,1,,void
6944,BLOCK,1,,<empty>,,,,4,,void
6946,BLOCK,-1,,SET_HOOK_FN(before),3,,179,1,,void
6985,BLOCK,1,,<empty>,,,,4,,void
6987,BLOCK,-1,,SET_HOOK_FN(after),3,,180,1,,void
7026,BLOCK,1,,<empty>,,,,4,,void
7028,BLOCK,-1,,SET_HOOK_FN(destroy),3,,181,1,,void
7067,BLOCK,1,,<empty>,,,,4,,void
7069,BLOCK,-1,,SET_HOOK_FN(promise_resolve),3,,182,1,,void
7111,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->ResetPromiseHooks(
      args[0]->IsFunction() ? args[0].As<Function>() : Local<Function>(),
      args[1]->IsFunction() ? args[1].As<Function>() : Local<Function>(),
      args[2]->IsFunction() ? args[2].As<Function>() : Local<Function>(),
      args[3]->IsFunction() ? args[3].As<Function>() : Local<Function>());
}",70,,186,2,,void
7189,BLOCK,-1,,"{
  delete static_cast<DestroyParam*>(ptr);
}",48,,204,2,,void
7198,BLOCK,-1,,"{
  HandleScope scope(info.GetIsolate());

  std::unique_ptr<DestroyParam> p{info.GetParameter()};
  Local<Object> prop_bag = PersistentToLocal::Default(info.GetIsolate(),
                                                      p->propBag);
  Local<Value> val;

  p->env->RemoveCleanupHook(DestroyParamCleanupHook, p.get());

  if (!prop_bag.IsEmpty() &&
      !prop_bag->Get(p->env->context(), p->env->destroyed_string())
        .ToLocal(&val)) {
    return;
  }

  if (val.IsEmpty() || val->IsFalse()) {
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }
  // unique_ptr goes out of scope here and pointer is deleted.
}",74,,208,2,,void
7279,BLOCK,-1,,"{
    return;
  }",25,,220,2,,void
7291,BLOCK,-1,,"{
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }",40,,224,2,,void
7306,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",74,,231,2,,void
7389,BLOCK,-1,,"{
    p->propBag.Reset(isolate, args[2].As<Object>());
  }",26,,241,2,,void
7428,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(kInvalidAsyncId);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->get_async_id());
}",69,,248,2,,void
7460,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // No need for CHECK(IsNumber()) on args because if FromJust() doesn't fail
  // then the checks in push_async_ids() and pop_async_id() will.
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  double trigger_async_id = args[1]->NumberValue(env->context()).FromJust();
  env->async_hooks()->push_async_context(async_id, trigger_async_id, {});
}",75,,256,2,,void
7515,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  args.GetReturnValue().Set(env->async_hooks()->pop_async_context(async_id));
}",74,,266,2,,void
7559,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t index;
  if (!args[0]->Uint32Value(env->context()).To(&index)) return;
  args.GetReturnValue().Set(
      env->async_hooks()->native_execution_async_resource(index));
}",46,,274,2,,void
7586,BLOCK,-1,,<empty>,57,,277,2,,void
7607,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->async_hooks()->clear_async_id_stack();
}",76,,283,2,,void
7627,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  AsyncWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> resource = args[0].As<Object>();
  double execution_async_id =
      args[1]->IsNumber() ? args[1].As<Number>()->Value() : kInvalidAsyncId;
  wrap->AsyncReset(resource, execution_async_id);
}",69,,289,2,,void
7685,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->provider_type());
}",74,,302,2,,void
7719,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env(), async_id_);
  // Ensure no double destroy is emitted via AsyncReset().
  async_id_ = kInvalidAsyncId;

  if (!persistent().IsEmpty() && !from_gc) {
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }
}",43,,310,2,,void
7738,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }",44,,315,2,,void
7750,BLOCK,-1,,"{
  CHECK(args[0]->IsNumber());
  AsyncWrap::EmitDestroy(
      Environment::GetCurrent(args),
      args[0].As<Number>()->Value());
}",78,,321,2,,void
7780,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[0]->IsFunction()) {
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  } else {
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }
}",80,,328,2,,void
7796,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  }",30,,331,2,,void
7808,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }",10,,333,1,,void
7818,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->async_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,339,2,,void
7834,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }",23,,341,2,,void
7890,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupHooks"", SetupHooks);
  SetMethod(isolate, target, ""setCallbackTrampoline"", SetCallbackTrampoline);
  SetMethod(isolate, target, ""pushAsyncContext"", PushAsyncContext);
  SetMethod(isolate, target, ""popAsyncContext"", PopAsyncContext);
  SetMethod(isolate, target, ""executionAsyncResource"", ExecutionAsyncResource);
  SetMethod(isolate, target, ""clearAsyncIdStack"", ClearAsyncIdStack);
  SetMethod(isolate, target, ""queueDestroyAsyncId"", QueueDestroyAsyncId);
  SetMethod(isolate, target, ""setPromiseHooks"", SetPromiseHooks);
  SetMethod(isolate, target, ""registerDestroyHook"", RegisterDestroyHook);
  AsyncWrap::GetConstructorTemplate(isolate_data);
}",74,,356,3,,void
7955,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  PropertyAttribute ReadOnlyDontDelete =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

#define FORCE_SET_TARGET_FIELD(obj, str, field)                               \
  (obj)->DefineOwnProperty(context,                                           \
                           FIXED_ONE_BYTE_STRING(isolate, str),               \
                           field,                                             \
                           ReadOnlyDontDelete).FromJust()

  // Attach the uint32_t[] where each slot contains the count of the number of
  // callbacks waiting to be called on a particular event. It can then be
  // incremented/decremented from JS quickly to communicate to C++ if there are
  // any callbacks waiting to be called.
  FORCE_SET_TARGET_FIELD(target,
                         ""async_hook_fields"",
                         env->async_h...",56,,374,5,,void
7995,BLOCK,1,,<empty>,,,,7,,void
8031,BLOCK,1,,<empty>,,,,7,,void
8064,BLOCK,1,,<empty>,,,,7,,void
8118,BLOCK,1,,<empty>,,,,4,,void
8140,BLOCK,1,,<empty>,,,,4,,void
8162,BLOCK,1,,<empty>,,,,4,,void
8184,BLOCK,1,,<empty>,,,,4,,void
8206,BLOCK,1,,<empty>,,,,4,,void
8228,BLOCK,1,,<empty>,,,,4,,void
8250,BLOCK,1,,<empty>,,,,4,,void
8272,BLOCK,1,,<empty>,,,,4,,void
8294,BLOCK,1,,<empty>,,,,4,,void
8316,BLOCK,1,,<empty>,,,,4,,void
8338,BLOCK,1,,<empty>,,,,4,,void
8360,BLOCK,1,,<empty>,,,,4,,void
8382,BLOCK,1,,<empty>,,,,4,,void
8407,BLOCK,1,,<empty>,,,,6,,void
8441,BLOCK,1,,<empty>,,,,2,,void
8490,BLOCK,-1,,"{
  registry->Register(SetupHooks);
  registry->Register(SetCallbackTrampoline);
  registry->Register(PushAsyncContext);
  registry->Register(PopAsyncContext);
  registry->Register(ExecutionAsyncResource);
  registry->Register(ClearAsyncIdStack);
  registry->Register(QueueDestroyAsyncId);
  registry->Register(SetPromiseHooks);
  registry->Register(RegisterDestroyHook);
  registry->Register(AsyncWrap::GetAsyncId);
  registry->Register(AsyncWrap::AsyncReset);
  registry->Register(AsyncWrap::GetProviderType);
}",42,,459,2,,void
8564,BLOCK,-1,,<empty>,67,,478,5,,void
8573,BLOCK,-1,,"{
  CHECK_NE(provider, PROVIDER_NONE);
  provider_type_ = provider;

  // Use AsyncReset() call to execute the init() callbacks.
  AsyncReset(object, execution_async_id, silent);
  init_hook_ran_ = true;
}",30,,485,6,,void
8595,BLOCK,-1,,"{
  trigger_async_id_ = trigger_async_id;
}",66,,499,6,,void
8604,BLOCK,-1,,"{
}",29,,504,3,,void
8608,BLOCK,-1,,"{
  return init_hook_ran_;
}",44,,528,1,,void
8614,BLOCK,-1,,"{
  EmitTraceEventDestroy();
  EmitDestroy(true /* from gc */);
}",25,,532,1,,void
8621,BLOCK,-1,,"{
  switch (provider_type()) {
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }
}",41,,537,1,,void
8624,BLOCK,-1,,"{
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }",28,,538,2,,void
8633,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",64,,552,3,,void
8654,BLOCK,-1,,"{
    return;
  }",33,,554,2,,void
8664,BLOCK,-1,,"{
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }",46,,558,2,,void
8684,BLOCK,-1,,"{
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }",54,,565,2,,void
8704,BLOCK,-1,,"{
  CHECK_NE(provider_type(), PROVIDER_NONE);

  if (async_id_ != kInvalidAsyncId) {
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }

  // Now we can assign a new async_id_ to this instance.
  async_id_ = execution_async_id == kInvalidAsyncId ? env()->new_async_id()
                                                     : execution_async_id;
  trigger_async_id_ = env()->get_default_trigger_async_id();

  {
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }

  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*...",41,,582,4,,void
8712,BLOCK,-1,,"{
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }",37,,585,2,,void
8731,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }",3,,597,5,,void
8755,BLOCK,-1,,"{
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }",26,,601,2,,void
8772,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(                        \
          TRACING_CATEGORY_NODE1(async_hooks))) {                             \
        auto data = tracing::TracedValue::Create();                           \
        data->SetInteger(""executionAsyncId"",                                  \
                         static_cast<int64_t>(env()->execution_async_id()));  \
        data->SetInteger(""triggerAsyncId"",                                    \
                         static_cast<int64_t>(get_trigger_async_id()));       \
        TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(                                    \
          TRACING_CATEGORY_NODE1(async_hooks),                                \
          #PROVIDER, static_cast<int64_t>(get_async_id()),                    \
          ""data"", std::move(data));...",28,,606,2,,void
8779,BLOCK,-1,,<empty>,15,,628,2,,void
8802,BLOCK,-1,,"{
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",56,,639,6,,void
8833,BLOCK,-1,,"{
    return;
  }",54,,645,2,,void
8902,BLOCK,-1,,"{
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",63,,666,4,,void
8938,BLOCK,-1,,"{
  return provider_names[provider_type()];
}",47,,681,1,,void
8946,BLOCK,-1,,"{
  char buf[64];
  snprintf(buf,
           sizeof(buf),
           ""%s(%"" PRIu64 "":%.0f)"",
           MemoryInfoName(),
           env()->thread_id(),
           async_id_);
  return buf;
}",48,,685,1,,void
8954,BLOCK,-1,,"{
  return GetOwner(env(), object());
}",37,,696,1,,void
8964,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  CHECK(!obj.IsEmpty());

  TryCatchScope ignore_exceptions(env);
  while (true) {
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }
}",72,,700,3,,void
8982,BLOCK,-1,,"{
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }",16,,705,2,,void
9013,BLOCK,-1,,"{
      return handle_scope.Escape(obj);
    }",29,,709,2,,void
9039,BLOCK,-1,,<empty>,1,,1,1,,ANY
9050,BLOCK,-1,,<empty>,1,,1,1,,ANY
9063,BLOCK,-1,,<empty>,1,,1,1,,ANY
9068,BLOCK,-1,,<empty>,1,,1,1,,ANY
9081,BLOCK,-1,,<empty>,1,,1,1,,ANY
9085,BLOCK,-1,,"{
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      }",52,,55,2,,void
9128,BLOCK,-1,,<empty>,1,,1,1,,ANY
9133,BLOCK,-1,,"{
  CHECK_EQ(false, object.IsEmpty());
  CHECK_GE(object->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(object, static_cast<void*>(this));
  realm->AddCleanupHook(DeleteMe, static_cast<void*>(this));
  realm->modify_base_object_count(1);
}",67,,17,3,,void
9169,BLOCK,-1,,"{
  realm()->modify_base_object_count(-1);
  realm()->RemoveCleanupHook(DeleteMe, static_cast<void*>(this));

  if (UNLIKELY(has_pointer_data())) {
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }

  if (persistent_handle_.IsEmpty()) {
    // This most likely happened because the weak callback below cleared it.
    return;
  }

  {
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }
}",27,,25,1,,void
9185,BLOCK,-1,,<empty>,7,,29,1,,void
9187,BLOCK,-1,,"{
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }",37,,29,2,,void
9208,BLOCK,-1,,<empty>,40,,33,2,,void
9216,BLOCK,-1,,"{
    // This most likely happened because the weak callback below cleared it.
    return;
  }",37,,36,2,,void
9218,BLOCK,5,,"{
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }",3,,41,5,,void
9236,BLOCK,-1,,"{
  if (has_pointer_data()) {
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }

  persistent_handle_.SetWeak(
      this,
      [](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      },
      WeakCallbackType::kParameter);
}",29,,47,1,,void
9239,BLOCK,-1,,"{
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }",27,,48,2,,void
9251,BLOCK,-1,,<empty>,47,,50,2,,void
9270,BLOCK,-1,,"{
  DCHECK(args.IsConstructCall());
  CHECK_GE(args.This()->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(args.This(), nullptr);
}",46,,77,2,,void
9297,BLOCK,-1,,"{
  return MakeLazilyInitializedJSTemplate(env->isolate_data());
}",23,,84,2,,void
9308,BLOCK,-1,,"{
  Local<FunctionTemplate> t = NewFunctionTemplate(
      isolate_data->isolate(), LazilyInitializedJSTemplateConstructor);
  t->InstanceTemplate()->SetInternalFieldCount(BaseObject::kInternalFieldCount);
  return t;
}",32,,89,2,,void
9336,BLOCK,-1,,"{
  if (!has_pointer_data()) {
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }
  CHECK(has_pointer_data());
  return pointer_data_;
}",53,,96,1,,void
9340,BLOCK,-1,,"{
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }",28,,97,2,,void
9368,BLOCK,-1,,"{
  CHECK(has_pointer_data());
  PointerData* metadata = pointer_data();
  CHECK_GT(metadata->strong_ptr_count, 0);
  unsigned int new_refcount = --metadata->strong_ptr_count;
  if (new_refcount == 0) {
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }
}",38,,107,1,,void
9390,BLOCK,-1,,"{
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }",26,,112,2,,void
9395,BLOCK,-1,,"{
      OnGCCollect();
    }",32,,113,2,,void
9398,BLOCK,-1,,<empty>,12,,115,1,,void
9409,BLOCK,-1,,"{
      MakeWeak();
    }",77,,115,2,,void
9414,BLOCK,-1,,"{
  unsigned int prev_refcount = pointer_data()->strong_ptr_count++;
  if (prev_refcount == 0 && !persistent_handle_.IsEmpty())
    persistent_handle_.ClearWeak();
}",38,,121,1,,void
9432,BLOCK,-1,,<empty>,5,,124,2,,void
9441,BLOCK,-1,,"{
  BaseObject* self = static_cast<BaseObject*>(data);
  if (self->has_pointer_data() && self->pointer_data()->strong_ptr_count > 0) {
    return self->Detach();
  }
  delete self;
}",39,,127,2,,void
9462,BLOCK,-1,,"{
    return self->Detach();
  }",79,,129,2,,void
9473,BLOCK,-1,,"{
  return true;
}",45,,135,1,,void
9479,BLOCK,-1,,"{
  return object();
}",49,,139,1,,void
9485,BLOCK,-1,,"{
  return !persistent_handle_.IsWeak();
}",37,,143,1,,void
9495,BLOCK,-1,,"{
  return IsWeakOrDetached();
}",60,,147,1,,void
9512,BLOCK,-1,,<empty>,1,,1,1,,ANY
9519,BLOCK,-1,,<empty>,1,,1,1,,ANY
9538,BLOCK,-1,,<empty>,1,,1,1,,ANY
9547,BLOCK,-1,,<empty>,1,,1,1,,ANY
9554,BLOCK,-1,,<empty>,1,,1,1,,ANY
9561,BLOCK,-1,,<empty>,1,,1,1,,ANY
9565,BLOCK,-1,,{ delete handle; },60,,763,2,,void
9573,BLOCK,-1,,{ uv_freeaddrinfo(res); },37,,1434,1,,void
9583,BLOCK,-1,,"{
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    }",68,,1453,3,,void
9585,BLOCK,-1,,<empty>,7,,1454,1,,void
9598,BLOCK,4,,"{
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }",56,,1454,4,,void
9613,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        }",51,,1458,2,,void
9627,BLOCK,-1,,<empty>,16,,1461,1,,void
9636,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        }",59,,1461,2,,void
9650,BLOCK,-1,,"{
          continue;
        }",16,,1464,1,,void
9662,BLOCK,-1,,<empty>,11,,1470,2,,void
9690,BLOCK,-1,,<empty>,11,,1474,2,,void
9704,BLOCK,-1,,{ ares_free_data(servers); },37,,1660,1,,void
9751,BLOCK,-1,,<empty>,1,,1,1,,ANY
9758,BLOCK,-1,,"{
  return static_cast<uint32_t>(p[0] << 8U) | (static_cast<uint32_t>(p[1]));
}",57,,81,2,,void
9779,BLOCK,-1,,"{
  NodeAresTask* task = ContainerOf(&NodeAresTask::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;

  /* Reset the idle timer */
  uv_timer_again(channel->timer_handle());

  if (status < 0) {
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }

  /* Process DNS responses */
  ares_process_fd(channel->cares_channel(),
                  events & UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}",63,,85,4,,void
9804,BLOCK,-1,,"{
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }",19,,92,2,,void
9842,BLOCK,-1,,"{
  std::unique_ptr<NodeAresTask> free_me(
        ContainerOf(&NodeAresTask::poll_watcher, watcher));
}",45,,106,2,,void
9863,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(data);
  NodeAresTask* task;

  NodeAresTask lookup_task;
  lookup_task.sock = sock;
  auto it = channel->task_list()->find(&lookup_task);

  task = (it == channel->task_list()->end()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  } else {
    /* read == 0 and write == 0 this is c-ar...",77,,113,5,,void
9908,BLOCK,-1,,"{
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  }",22,,123,2,,void
9912,BLOCK,-1,,"{
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }",16,,124,2,,void
9929,BLOCK,-1,,"{
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }",28,,129,2,,void
9955,BLOCK,-1,,"{
    /* read == 0 and write == 0 this is c-ares's way of notifying us that */
    /* the socket is now closed. We must free the data associated with */
    /* socket. */
    CHECK(task &&
          ""When an ares socket is closed we should have a handle for it"");

    channel->task_list()->erase(it);
    channel->env()->CloseHandle(&task->poll_watcher, ares_poll_close_cb);

    if (channel->task_list()->empty()) {
      channel->CloseTimer();
    }
  }",10,,145,1,,void
9988,BLOCK,-1,,"{
      channel->CloseTimer();
    }",40,,155,2,,void
9998,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  std::vector<Local<Value>> names;

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i)
    names.emplace_back(OneByteString(env->isolate(), host->h_aliases[i]));

  Local<Array> ret = Array::New(env->isolate(), names.data(), names.size());

  return scope.Escape(ret);
}",69,,161,3,,void
10015,BLOCK,-1,,<empty>,3,,166,1,,void
10077,BLOCK,-1,,"{
  size_t offset = names->Length();

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i) {
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }

  return names;
}",49,,176,4,,void
10086,BLOCK,-1,,<empty>,3,,179,1,,void
10100,BLOCK,4,,"{
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }",60,,179,4,,void
10133,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 8> ttls(naddrttls);
  for (size_t i = 0; i < naddrttls; i++)
    ttls[i] = Integer::NewFromUnsigned(env->isolate(), addrttls[i].ttl);

  return Array::New(env->isolate(), ttls.out(), naddrttls);
}",23,,193,4,,void
10138,BLOCK,-1,,<empty>,3,,195,1,,void
10189,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  hostent* host;

  int status;
  switch (*type) {
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }

  if (status != ARES_SUCCESS)
    return status;

  CHECK...",31,,208,8,,void
10201,BLOCK,-1,,"{
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }",18,,213,2,,void
10264,BLOCK,-1,,<empty>,5,,241,2,,void
10292,BLOCK,-1,,"{
    // A cname lookup always returns a single record but we follow the
    // common API here.
    *type = ns_t_cname;
    ret->Set(env->context(),
             ret->Length(),
             OneByteString(env->isolate(), ptr->h_name)).Check();
    return ARES_SUCCESS;
  }",28,,250,2,,void
10327,BLOCK,-1,,<empty>,5,,261,2,,void
10337,BLOCK,-1,,"{
    HostentToNames(env, ptr.get(), ret);
  }",25,,263,2,,void
10346,BLOCK,-1,,<empty>,10,,265,1,,void
10352,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    for (uint32_t i = 0; ptr->h_aliases[i] != nullptr; i++) {
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }
  }",33,,265,2,,void
10361,BLOCK,-1,,<empty>,5,,267,1,,void
10375,BLOCK,4,,"{
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }",61,,267,4,,void
10405,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    char ip[INET6_ADDRSTRLEN];
    for (uint32_t i = 0; ptr->h_addr_list[i] != nullptr; ++i) {
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }
  }",10,,271,1,,void
10415,BLOCK,-1,,<empty>,5,,274,1,,void
10429,BLOCK,4,,"{
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }",63,,274,4,,void
10476,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_mx_reply* mx_start;
  int status = ares_parse_mx_reply(buf, len, &mx_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_mx_reply* current = mx_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }

  ares_free_data(mx_start);
  return ARES_SUCCESS;
}",29,,289,6,,void
10496,BLOCK,-1,,<empty>,5,,295,2,,void
10511,BLOCK,-1,,<empty>,3,,299,1,,void
10527,BLOCK,4,,"{
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }",74,,299,4,,void
10593,BLOCK,-1,,<empty>,7,,308,2,,void
10640,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_caa_reply* caa_start;
  int status = ares_parse_caa_reply(buf, len, &caa_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_caa_reply* current = caa_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }

  ares_free_data(caa_start);
 ...",29,,324,6,,void
10660,BLOCK,-1,,<empty>,5,,330,2,,void
10675,BLOCK,-1,,<empty>,3,,334,1,,void
10691,BLOCK,4,,"{
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }",74,,334,4,,void
10761,BLOCK,-1,,<empty>,7,,344,2,,void
10808,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_txt_ext* txt_out;

  int status = ares_parse_txt_reply_ext(buf, len, &txt_out);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> txt_chunk;

  struct ares_txt_ext* current = txt_out;
  uint32_t i = 0, j;
  uint32_t offset = ret->Length();
  for (j = 0; current != nullptr; current = current->next) {
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context...",29,,360,6,,void
10828,BLOCK,-1,,<empty>,5,,367,2,,void
10853,BLOCK,-1,,<empty>,3,,374,1,,void
10865,BLOCK,4,,"{
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }

    txt_chunk->Set(env->context(), j++, txt).Check();
  }",60,,374,4,,void
10887,BLOCK,-1,,"{
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }",32,,379,2,,void
10894,BLOCK,-1,,"{
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }",33,,380,2,,void
10897,BLOCK,-1,,"{
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        }",24,,381,2,,void
10964,BLOCK,-1,,"{
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }",16,,388,1,,void
11014,BLOCK,-1,,"{
    if (need_type) {
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    } else {
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }
  }",29,,401,2,,void
11017,BLOCK,-1,,"{
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    }",20,,402,2,,void
11083,BLOCK,-1,,"{
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }",12,,409,1,,void
11111,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_srv_reply* srv_start;
  int status = ares_parse_srv_reply(buf, len, &srv_start);
  if (status != ARES_SUCCESS)
    return status;

  ares_srv_reply* current = srv_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight...",29,,424,6,,void
11131,BLOCK,-1,,<empty>,5,,430,2,,void
11146,BLOCK,-1,,<empty>,3,,434,1,,void
11162,BLOCK,4,,"{
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight)).Check();
    if (need_type)
      srv_record->Set(env->context(),
                      env->type_string(),
                      env->dns_srv_string()).Check();

    ret->Set(env->context(), i + offset, srv_record).Check();
  }",74,,434,4,,void
11280,BLOCK,-1,,<empty>,7,,449,2,,void
11327,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  ares_naptr_reply* naptr_start;
  int status = ares_parse_naptr_reply(buf, len, &naptr_start);

  if (status != ARES_SUCCESS)
    return status;

  ares_naptr_reply* current = naptr_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
...",29,,466,6,,void
11347,BLOCK,-1,,<empty>,5,,473,2,,void
11362,BLOCK,-1,,<empty>,3,,477,1,,void
11378,BLOCK,4,,"{
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
                      env->replacement_string(),
                      OneByteString(env->isolate(),
                                    current->replacement)).Check();
    naptr_record->Set(env->context(),
                      env->order_string(),
                      Integer::New(env->isolate(), current->order)).Check();
    naptr_rec...",74,,477,4,,void
11539,BLOCK,-1,,<empty>,7,,502,2,,void
11585,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());

  // Manage memory using standardard smart pointer std::unique_tr
  struct AresDeleter {
    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }
  };
  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;

  // Can't use ares_parse_soa_reply() here which can only parse single record
  const unsigned int ancount = cares_get_16bit(buf + 6);
  unsigned char* ptr = buf + NS_HFIXEDSZ;
  char* name_temp = nullptr;
  long temp_len;  // NOLINT(runtime/int)
  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);
  if (status != ARES_SUCCESS) {
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }

  const ares_unique_ptr name(name_temp);

  if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {
    return ARES_EBADRESP;
  }
  ptr += temp_len + NS_QFIXEDSZ;

  for (unsigned int i = 0; i < ancount; i++) {
    char* rr_name_temp = nullptr;
    lon...",25,,518,5,,void
11626,BLOCK,-1,,"{
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }",31,,533,2,,void
11647,BLOCK,-1,,"{
    return ARES_EBADRESP;
  }",49,,540,2,,void
11656,BLOCK,-1,,<empty>,3,,545,1,,void
11666,BLOCK,4,,"{
    char* rr_name_temp = nullptr;
    long rr_temp_len;  // NOLINT(runtime/int)
    int status2 = ares_expand_name(ptr, buf, len, &rr_name_temp, &rr_temp_len);

    if (status2 != ARES_SUCCESS)
      return status2 == ARES_EBADNAME ? ARES_EBADRESP : status2;

    const ares_unique_ptr rr_name(rr_name_temp);

    ptr += rr_temp_len;
    if (ptr + NS_RRFIXEDSZ > buf + len) {
      return ARES_EBADRESP;
    }

    const int rr_type = cares_get_16bit(ptr);
    const int rr_len = cares_get_16bit(ptr + 8);
    ptr += NS_RRFIXEDSZ;

    // only need SOA
    if (rr_type == ns_t_soa) {
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
   ...",46,,545,4,,void
11687,BLOCK,-1,,<empty>,7,,551,2,,void
11709,BLOCK,-1,,"{
      return ARES_EBADRESP;
    }",41,,556,2,,void
11731,BLOCK,-1,,"{
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
      ptr += nsname_temp_len;

      char* hostmaster_temp = nullptr;
      long hostmaster_temp_len;  // NOLINT(runtime/int)
      int status4 = ares_expand_name(ptr, buf, len,
                                     &hostmaster_temp,
                                     &hostmaster_temp_len);
      if (status4 != ARES_SUCCESS) {
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }
      const ares_unique_ptr hostmaster(hostmaster_temp);
      ptr += hostmaster_temp_len;

      if (ptr + 5 * 4 > buf + len) {
        return ARES_EBADRESP;
      }

      const un...",30,,565,2,,void
11752,BLOCK,-1,,"{
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }",36,,572,2,,void
11786,BLOCK,-1,,"{
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }",36,,583,2,,void
11810,BLOCK,-1,,"{
        return ARES_EBADRESP;
      }",36,,589,2,,void
12080,BLOCK,-1,,"{
  MakeWeak();

  Setup();
}",21,,645,5,,void
12087,BLOCK,-1,,"{
  if (timer_handle_ != nullptr)
    tracker->TrackField(""timer_handle"", *timer_handle_);
  tracker->TrackField(""task_list"", task_list_, ""NodeAresTask::List"");
}",60,,651,2,,void
12092,BLOCK,-1,,<empty>,5,,653,2,,void
12111,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  const int timeout = args[0].As<Int32>()->Value();
  const int tries = args[1].As<Int32>()->Value();
  Environment* env = Environment::GetCurrent(args);
  new ChannelWrap(env, args.This(), timeout, tries);
}",64,,657,2,,void
12184,BLOCK,-1,,<empty>,27,,673,4,,void
12190,BLOCK,-1,,<empty>,74,,678,3,,void
12195,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(handle->data);
  CHECK_EQ(channel->timer_handle(), handle);
  CHECK_EQ(false, channel->task_list()->empty());
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD);
}",51,,682,2,,void
12230,BLOCK,-1,,"{
  tracker->TrackField(""channel"", channel);
}",61,,690,2,,void
12242,BLOCK,-1,,"{
  auto task = new NodeAresTask();

  task->channel = channel;
  task->sock = sock;

  if (uv_poll_init_socket(channel->env()->event_loop(),
                          &task->poll_watcher, sock) < 0) {
    /* This should never happen. */
    delete task;
    return nullptr;
  }

  return task;
}",78,,695,3,,void
12274,BLOCK,-1,,"{
    /* This should never happen. */
    delete task;
    return nullptr;
  }",59,,702,2,,void
12284,BLOCK,-1,,"{
  struct ares_options options;
  memset(&options, 0, sizeof(options));
  options.flags = ARES_FLAG_NOCHECKRESP;
  options.sock_state_cb = ares_sockstate_cb;
  options.sock_state_cb_data = this;
  options.timeout = timeout_;
  options.tries = tries_;

  int r;
  if (!library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }

  /* We do the call to ares_init_option for caller. */
  const int optmask =
      ARES_OPT_FLAGS | ARES_OPT_TIMEOUTMS |
      ARES_OPT_SOCK_STATE_CB | ARES_OPT_TRIES;
  r = ares_init_options(&channel_, &options, optmask);

  if (r != ARES_SUCCESS) {
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }

  library_i...",27,,711,1,,void
12321,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }",25,,721,2,,void
12333,BLOCK,-1,,<empty>,7,,727,2,,void
12363,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }",26,,736,2,,void
12381,BLOCK,-1,,"{
  if (timer_handle_ == nullptr) {
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast<uv_handle_t*>(timer_handle_))) {
    return;
  }
  int timeout = timeout_;
  if (timeout == 0) timeout = 1;
  if (timeout < 0 || timeout > 1000) timeout = 1000;
  uv_timer_start(timer_handle_, AresTimeout, timeout, timeout);
}",32,,745,1,,void
12386,BLOCK,-1,,"{
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  }",33,,746,2,,void
12405,BLOCK,-1,,<empty>,10,,750,1,,void
12411,BLOCK,-1,,"{
    return;
  }",75,,750,2,,void
12421,BLOCK,-1,,<empty>,21,,754,2,,void
12433,BLOCK,-1,,<empty>,38,,755,2,,void
12445,BLOCK,-1,,"{
  if (timer_handle_ == nullptr)
    return;

  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });
  timer_handle_ = nullptr;
}",32,,759,1,,void
12450,BLOCK,-1,,<empty>,5,,761,2,,void
12464,BLOCK,-1,,"{
  ares_destroy(channel_);

  if (library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }

  CloseTimer();
}",29,,767,1,,void
12468,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }",24,,770,2,,void
12478,BLOCK,-1,,"{
  active_query_count_ += count;
  CHECK_GE(active_query_count_, 0);
}",55,,780,2,,void
12488,BLOCK,-1,,"{
  /* if last query is OK or servers are set by user self, do not check */
  if (query_last_ok_ || !is_servers_default_) {
    return;
  }

  ares_addr_port_node* servers = nullptr;

  ares_get_servers_ports(channel_, &servers);

  /* if no server or multi-servers, ignore */
  if (servers == nullptr) return;
  if (servers->next != nullptr) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  /* if the only server is not 127.0.0.1, ignore */
  if (servers[0].family != AF_INET ||
      servers[0].addr.addr4.s_addr != htonl(INADDR_LOOPBACK) ||
      servers[0].tcp_port != 0 ||
      servers[0].udp_port != 0) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  ares_free_data(servers);
  servers = nullptr;

  /* destroy channel and reset channel */
  ares_destroy(channel_);

  CloseTimer();
  Setup();
}",35,,793,1,,void
12494,BLOCK,-1,,"{
    return;
  }",47,,795,2,,void
12508,BLOCK,-1,,<empty>,27,,804,2,,void
12516,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,805,2,,void
12560,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,815,2,,void
12580,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_any);
  return 0;
}",67,,831,3,,void
12595,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_a);
  return 0;
}",63,,836,3,,void
12610,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_aaaa);
  return 0;
}",69,,841,3,,void
12625,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, T_CAA);
  return 0;
}",67,,846,3,,void
12633,BLOCK,1,,<empty>,,,,1,,void
12642,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_cname);
  return 0;
}",71,,851,3,,void
12657,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_mx);
  return 0;
}",65,,856,3,,void
12672,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ns);
  return 0;
}",65,,861,3,,void
12687,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_txt);
  return 0;
}",67,,866,3,,void
12702,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_srv);
  return 0;
}",67,,871,3,,void
12717,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ptr);
  return 0;
}",67,,876,3,,void
12732,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_naptr);
  return 0;
}",71,,881,3,,void
12747,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_soa);
  return 0;
}",67,,886,3,,void
12762,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type, status, old_count;

  /* Parse A records or CNAME records */
  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls);

  type = ns_t_cname_or_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  uint32_t a_count = ret->Length();
  if (status != ARES_SUCCESS && status != ARES_ENODATA)
    return status;

  if (type == ns_t_a) {
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> o...",52,,893,3,,void
12768,BLOCK,-1,,<empty>,5,,895,2,,void
12859,BLOCK,-1,,<empty>,5,,921,2,,void
12866,BLOCK,-1,,"{
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",23,,923,2,,void
12873,BLOCK,-1,,<empty>,5,,925,1,,void
12883,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,925,4,,void
12986,BLOCK,-1,,"{
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",10,,939,1,,void
12988,BLOCK,-1,,<empty>,5,,940,1,,void
12998,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,940,4,,void
13110,BLOCK,-1,,<empty>,5,,966,2,,void
13127,BLOCK,-1,,<empty>,3,,970,1,,void
13140,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->address_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->ttl_string(),
              Integer::NewFromUnsigned(
                env->isolate(), addr6ttls[i - a_count].ttl)).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_aaaa_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",54,,970,4,,void
13260,BLOCK,-1,,<empty>,5,,988,2,,void
13289,BLOCK,-1,,<empty>,5,,995,2,,void
13293,BLOCK,-1,,<empty>,3,,997,1,,void
13306,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
             env->value_string(),
             ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ns_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,997,4,,void
13396,BLOCK,-1,,<empty>,5,,1011,2,,void
13415,BLOCK,-1,,<empty>,5,,1016,2,,void
13444,BLOCK,-1,,<empty>,5,,1023,2,,void
13448,BLOCK,-1,,<empty>,3,,1024,1,,void
13461,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->value_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ptr_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,1024,4,,void
13551,BLOCK,-1,,<empty>,5,,1038,2,,void
13577,BLOCK,-1,,<empty>,5,,1044,2,,void
13586,BLOCK,-1,,<empty>,5,,1047,2,,void
13619,BLOCK,-1,,<empty>,5,,1052,2,,void
13634,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addrttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1060,3,,void
13640,BLOCK,-1,,<empty>,5,,1062,2,,void
13719,BLOCK,-1,,<empty>,5,,1084,2,,void
13750,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addr6ttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_aaaa;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addr6ttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1094,3,,void
13756,BLOCK,-1,,<empty>,5,,1096,2,,void
13835,BLOCK,-1,,<empty>,5,,1118,2,,void
13866,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int status = ParseCaaReply(env, buf, len, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1128,3,,void
13872,BLOCK,-1,,<empty>,5,,1130,2,,void
13936,BLOCK,-1,,<empty>,5,,1142,2,,void
13951,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type = ns_t_cname;
  int status = ParseGeneralReply(env, buf, len, &type, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1150,3,,void
13957,BLOCK,-1,,<empty>,5,,1152,2,,void
14027,BLOCK,-1,,<empty>,5,,1165,2,,void
14042,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> mx_records = Array::New(env->isolate());
  int status = ParseMxReply(env, buf, len, mx_records);

  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(mx_records);
  return 0;
}",52,,1173,3,,void
14048,BLOCK,-1,,<empty>,5,,1175,2,,void
14112,BLOCK,-1,,<empty>,5,,1188,2,,void
14127,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ns;
  Local<Array> names = Array::New(env->isolate());
  int status = ParseGeneralReply(env, buf, len, &type, names);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(names);
  return 0;
}",52,,1196,3,,void
14133,BLOCK,-1,,<empty>,5,,1198,2,,void
14203,BLOCK,-1,,<empty>,5,,1211,2,,void
14218,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> txt_records = Array::New(env->isolate());
  int status = ParseTxtReply(env, buf, len, txt_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(txt_records);
  return 0;
}",52,,1219,3,,void
14224,BLOCK,-1,,<empty>,5,,1221,2,,void
14288,BLOCK,-1,,<empty>,5,,1233,2,,void
14303,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> srv_records = Array::New(env->isolate());
  int status = ParseSrvReply(env, buf, len, srv_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(srv_records);
  return 0;
}",52,,1241,3,,void
14309,BLOCK,-1,,<empty>,5,,1243,2,,void
14373,BLOCK,-1,,<empty>,5,,1255,2,,void
14388,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ptr;
  Local<Array> aliases = Array::New(env->isolate());

  int status = ParseGeneralReply(env, buf, len, &type, aliases);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(aliases);
  return 0;
}",52,,1263,3,,void
14394,BLOCK,-1,,<empty>,5,,1265,2,,void
14464,BLOCK,-1,,<empty>,5,,1279,2,,void
14479,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> naptr_records = Array::New(env->isolate());
  int status = ParseNaptrReply(env, buf, len, naptr_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(naptr_records);
  return 0;
}",52,,1287,3,,void
14485,BLOCK,-1,,<empty>,5,,1289,2,,void
14549,BLOCK,-1,,<empty>,5,,1301,2,,void
14564,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_soa_reply* soa_out;
  int status = ares_parse_soa_reply(buf, len, &soa_out);

  if (status != ARES_SUCCESS)
    return status;

  Local<Object> soa_record = Object::New(env->isolate());

  soa_record->Set(env->context(),
                  env->nsname_string(),
                  OneByteString(env->isolate(), soa_out->nsname)).Check();
  soa_record->Set(env->context(),
                  env->hostmaster_string(),
                  OneByteString(env->isolate(), soa_out->hostmaster)).Check();
  soa_record->Set(env->context(),
                  env->serial_string(),
                  Integer::NewFromUnsigned(
                      env->isolate(), soa_out->serial)).Check();
  soa_record->Set(env->context(),
             ...",52,,1309,3,,void
14570,BLOCK,-1,,<empty>,5,,1311,2,,void
14621,BLOCK,-1,,<empty>,5,,1324,2,,void
14828,BLOCK,-1,,"{
  int length, family;
  char address_buffer[sizeof(struct in6_addr)];

  if (uv_inet_pton(AF_INET, name, &address_buffer) == 0) {
    length = sizeof(struct in_addr);
    family = AF_INET;
  } else if (uv_inet_pton(AF_INET6, name, &address_buffer) == 0) {
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  } else {
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""reverse"", wrap,
      ""name"", TRACE_STR_COPY(name),
      ""family"", family == AF_INET ? ""ipv4"" : ""ipv6"");

  ares_gethostbyaddr(
      wrap->channel()->cares_channel(),
      address_buffer,
      length,
      family,
      GetHostByAddrWrap::Callback,
      wrap->MakeCallbackPointer());
  return 0;
}",68,,1358,3,,void
14840,BLOCK,-1,,"{
    length = sizeof(struct in_addr);
    family = AF_INET;
  }",58,,1362,2,,void
14849,BLOCK,-1,,<empty>,10,,1365,1,,void
14858,BLOCK,-1,,"{
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  }",66,,1365,2,,void
14867,BLOCK,-1,,"{
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }",10,,1368,1,,void
14911,BLOCK,-1,,"{
  if (UNLIKELY(!response->is_host))
    return ARES_EBADRESP;

  struct hostent* host = response->host.get();

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  wrap->CallOnComplete(HostentToNames(env, host));
  return 0;
}",52,,1389,3,,void
14918,BLOCK,-1,,<empty>,5,,1391,2,,void
14963,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(false, args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);

  node::Utf8Value utf8name(env->isolate(), string);
  auto plain_name = utf8name.ToStringView();
  std::string name = ada::idna::to_ascii(plain_name);
  channel->ModifyActivityQueryCount(1);
  int err = wrap->Send(name.c_str());
  if (err) {
    channel->ModifyActivityQueryCount(-1);
  } else {
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }

  args.GetReturnValue().Set(err);
}",60,,1404,2,,void
15079,BLOCK,-1,,"{
    channel->ModifyActivityQueryCount(-1);
  }",12,,1422,2,,void
15087,BLOCK,-1,,"{
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }",10,,1424,1,,void
15106,BLOCK,-1,,"{
  auto cleanup = OnScopeLeave([&]() { uv_freeaddrinfo(res); });
  BaseObjectPtr<GetAddrInfoReqWrap> req_wrap{
      static_cast<GetAddrInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate())
  };

  uint32_t n = 0;
  const bool verbatim = req_wrap->verbatim();

  if (status == 0) {
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpre...",80,,1433,4,,void
15173,BLOCK,-1,,"{
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    };

    if (...",20,,1450,2,,void
15199,BLOCK,-1,,<empty>,7,,1481,2,,void
15205,BLOCK,-1,,"{
      if (add(false, true).IsNothing())
        return;
    }",28,,1482,2,,void
15213,BLOCK,-1,,<empty>,9,,1484,2,,void
15219,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EAI_NODATA);
    }",17,,1488,2,,void
15269,BLOCK,-1,,"{
  BaseObjectPtr<GetNameInfoReqWrap> req_wrap{
      static_cast<GetNameInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate()),
    Null(env->isolate())
  };

  if (status == 0) {
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }

  TRACE_EVENT_NESTABLE_ASYNC_END2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""hostname"", TRACE_STR_COPY(hostname),
      ""service"", TRACE_STR_COPY(service));

  // Make the callback into JavaScript
  req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",44,,1507,5,,void
15327,BLOCK,-1,,"{
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }",20,,1521,2,,void
15392,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip(isolate, args[0]);

  int af;
  unsigned char result[sizeof(ares_addr_port_node::addr)];
  if (uv_inet_pton(af = AF_INET, *ip, result) != 0 &&
      uv_inet_pton(af = AF_INET6, *ip, result) != 0)
    return;

  char canonical_ip[INET6_ADDRSTRLEN];
  CHECK_EQ(0, uv_inet_ntop(af, result, canonical_ip, sizeof(canonical_ip)));
  Local<String> val = String::NewFromUtf8(isolate, canonical_ip)
      .ToLocalChecked();
  args.GetReturnValue().Set(val);
}",62,,1538,2,,void
15428,BLOCK,-1,,<empty>,5,,1546,2,,void
15466,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsInt32());
  CHECK(args[4]->IsBoolean());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value hostname(env->isolate(), args[1]);
  std::string ascii_hostname = ada::idna::to_ascii(hostname.ToStringView());

  int32_t flags = 0;
  if (args[3]->IsInt32()) {
    flags = args[3].As<Int32>()->Value();
  }

  int family;

  switch (args[2].As<Int32>()->Value()) {
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }

  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args[4]->IsTrue());

  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai...",59,,1555,2,,void
15548,BLOCK,-1,,"{
    flags = args[3].As<Int32>()->Value();
  }",27,,1567,2,,void
15571,BLOCK,-1,,"{
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }",41,,1573,2,,void
15681,BLOCK,-1,,<empty>,5,,1611,2,,void
15699,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsUint32());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip(env->isolate(), args[1]);
  const unsigned port = args[2]->Uint32Value(env->context()).FromJust();
  struct sockaddr_storage addr;

  CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||
        uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);

  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""ip"", TRACE_STR_COPY(*ip), ""port"", port);

  int err = req_wrap->Dispatch(uv_getnameinfo,
                               AfterGetNameInfo,
                               reinterpret_cast<struct sockaddr*>(&addr),
                               NI_NAMEREQD);
  if (err == 0)
    // Release owner...",59,,1617,2,,void
15835,BLOCK,-1,,<empty>,5,,1643,2,,void
15853,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  Local<Array> server_array = Array::New(env->isolate());

  ares_addr_port_node* servers;

  int r = ares_get_servers_ports(channel->cares_channel(), &servers);
  CHECK_EQ(r, ARES_SUCCESS);
  auto cleanup = OnScopeLeave([&]() { ares_free_data(servers); });

  ares_addr_port_node* cur = servers;

  for (uint32_t i = 0; cur != nullptr; ++i, cur = cur->next) {
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }

  args.GetReturnValue().Set...",58,,1649,2,,void
15907,BLOCK,-1,,<empty>,3,,1664,1,,void
15923,BLOCK,4,,"{
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }",62,,1664,4,,void
15993,BLOCK,-1,,"{
      return;
    }",25,,1678,2,,void
16007,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  if (channel->active_query_count()) {
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }

  CHECK(args[0]->IsArray());

  Local<Array> arr = args[0].As<Array>();

  uint32_t len = arr->Length();

  if (len == 0) {
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }

  std::vector<ares_addr_port_node> servers(len);
  ares_addr_port_node* last = nullptr;

  int err;

  for (uint32_t i = 0; i < len; i++) {
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                 ...",58,,1687,2,,void
16029,BLOCK,-1,,"{
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }",38,,1692,2,,void
16069,BLOCK,-1,,"{
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }",17,,1702,2,,void
16102,BLOCK,-1,,<empty>,3,,1712,1,,void
16112,BLOCK,4,,"{
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                   2).ToLocalChecked()->Int32Value(env->context()).FromJust());

    int fam = elm->Get(env->context(), 0)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();
    node::Utf8Value ip(env->isolate(),
                       elm->Get(env->context(), 1).ToLocalChecked());
    int port = elm->Get(env->context(), 2)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();

    ares_addr_port_node* cur = &servers[i];

    cur->tcp_port = cur->udp_port = port;
    switch (fam) {
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        brea...",38,,1712,4,,void
16298,BLOCK,-1,,"{
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        break;
      case 6:
        cur->family = AF_INET6;
        err = uv_inet_pton(AF_INET6, *ip, &cur->addr);
        break;
      default:
        UNREACHABLE(""Bad address family"");
    }",18,,1733,2,,void
16340,BLOCK,-1,,<empty>,7,,1747,2,,void
16351,BLOCK,-1,,<empty>,7,,1752,2,,void
16364,BLOCK,-1,,<empty>,5,,1758,2,,void
16377,BLOCK,-1,,<empty>,5,,1760,1,,void
16385,BLOCK,-1,,<empty>,5,,1763,2,,void
16403,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsString());

  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip0(isolate, args[0]);

  unsigned char addr0[sizeof(struct in6_addr)];
  unsigned char addr1[sizeof(struct in6_addr)];
  int type0 = 0;

  // This function accepts 2 arguments.  The first may be either an IPv4
  // address or an IPv6 address.  If present, the second argument must be the
  // other type of address.  Otherwise, the unspecified type of IP is set
  // to 0 (any).

  if (uv_inet_pton(AF_INET, *ip0, &addr0) == 0) {
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  } else if (uv_inet_pton(AF_INET6, *ip0, &addr0) == 0) {
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  } else {
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }

  if (!args...",63,,1768,2,,void
16461,BLOCK,-1,,"{
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  }",49,,1788,2,,void
16473,BLOCK,-1,,<empty>,10,,1791,1,,void
16483,BLOCK,-1,,"{
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  }",57,,1791,2,,void
16494,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }",10,,1794,1,,void
16507,BLOCK,-1,,"{
    CHECK(args[1]->IsString());
    node::Utf8Value ip1(isolate, args[1]);

    if (uv_inet_pton(AF_INET, *ip1, &addr1) == 0) {
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    } else if (uv_inet_pton(AF_INET6, *ip1, &addr1) == 0) {
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    } else {
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }
  }",32,,1799,2,,void
16530,BLOCK,-1,,"{
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    }",51,,1803,2,,void
16535,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      }",23,,1804,2,,void
16541,BLOCK,-1,,"{
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }",14,,1807,1,,void
16550,BLOCK,-1,,<empty>,12,,1810,1,,void
16560,BLOCK,-1,,"{
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    }",59,,1810,2,,void
16565,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      }",23,,1811,2,,void
16571,BLOCK,-1,,"{
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }",14,,1814,1,,void
16579,BLOCK,-1,,"{
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }",12,,1817,1,,void
16585,BLOCK,-1,,"{
    // No second arg specified
    if (type0 == 4) {
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    } else {
      ares_set_local_ip4(channel->cares_channel(), 0);
    }
  }",10,,1821,1,,void
16590,BLOCK,-1,,"{
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    }",21,,1823,2,,void
16604,BLOCK,-1,,"{
      ares_set_local_ip4(channel->cares_channel(), 0);
    }",12,,1826,1,,void
16615,BLOCK,-1,,"{
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
      ""cancel"", TRACE_EVENT_SCOPE_THREAD);

  ares_cancel(channel->cares_channel());
}",54,,1832,2,,void
16643,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int code = args[0]->Int32Value(env->context()).FromJust();
  const char* errmsg = (code == DNS_ESETSRVPENDING) ?
    EMSG_ESETSRVPENDING :
    ares_strerror(code);
  args.GetReturnValue().Set(OneByteString(env->isolate(), errmsg));
}",56,,1843,2,,void
16695,BLOCK,-1,,"{
  int idx;

  if (host->h_addr_list != nullptr) {
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }

  if (host->h_aliases != nullptr) {
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }

  free(host->h_name);
  free(host);
}",53,,1854,2,,void
16703,BLOCK,-1,,"{
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }",37,,1857,2,,void
16713,BLOCK,-1,,"{
      free(host->h_addr_list[idx++]);
    }",36,,1859,2,,void
16736,BLOCK,-1,,"{
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }",35,,1866,2,,void
16746,BLOCK,-1,,"{
      free(host->h_aliases[idx++]);
    }",34,,1868,2,,void
16776,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getaddrinfo"", GetAddrInfo);
  SetMethod(context, target, ""getnameinfo"", GetNameInfo);
  SetMethodNoSideEffect(context, target, ""canonicalizeIP"", CanonicalizeIP);

  SetMethod(context, target, ""strerror"", StrError);

  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET""),
              Integer::New(env->isolate(), AF_INET)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET6""),
              Integer::New(env->isolate(), AF_INET6)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AF_UNSPEC""),
              Integer::New(env->isolate(), AF_UNSPEC)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AI_ADDRCONFIG""),
              Integer::New(env->is...",29,,1882,5,,void
16941,BLOCK,1,,<empty>,,,,1,,void
16969,BLOCK,1,,<empty>,,,,1,,void
17171,BLOCK,-1,,"{
  registry->Register(GetAddrInfo);
  registry->Register(GetNameInfo);
  registry->Register(CanonicalizeIP);
  registry->Register(StrError);
  registry->Register(ChannelWrap::New);

  registry->Register(Query<QueryAnyWrap>);
  registry->Register(Query<QueryAWrap>);
  registry->Register(Query<QueryAaaaWrap>);
  registry->Register(Query<QueryCaaWrap>);
  registry->Register(Query<QueryCnameWrap>);
  registry->Register(Query<QueryMxWrap>);
  registry->Register(Query<QueryNsWrap>);
  registry->Register(Query<QueryTxtWrap>);
  registry->Register(Query<QuerySrvWrap>);
  registry->Register(Query<QueryPtrWrap>);
  registry->Register(Query<QueryNaptrWrap>);
  registry->Register(Query<QuerySoaWrap>);
  registry->Register(Query<GetHostByAddrWrap>);

  registry->Register(GetServers);
  registry->Register(SetServers);
  registry->Register(SetLocalAddress);
  registry->Register(Cancel);
}",70,,1953,2,,void
17317,BLOCK,-1,,<empty>,1,,1,1,,ANY
17322,BLOCK,-1,,<empty>,1,,1,1,,ANY
17335,BLOCK,-1,,<empty>,1,,1,1,,ANY
17340,BLOCK,-1,,"{
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            }",76,,17,3,,void
17363,BLOCK,-1,,<empty>,1,,1,1,,ANY
17366,BLOCK,-1,,"{
  // Copy into a vector, since we can't sort an unordered_set in-place.
  std::vector<CleanupHookCallback> callbacks(cleanup_hooks_.begin(),
                                             cleanup_hooks_.end());
  // We can't erase the copied elements from `cleanup_hooks_` yet, because we
  // need to be able to check whether they were un-scheduled by another hook.

  std::sort(callbacks.begin(),
            callbacks.end(),
            [](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            });

  for (const CleanupHookCallback& cb : callbacks) {
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    clean...",28,,8,1,,void
17398,BLOCK,-1,,"{
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    cleanup_hooks_.erase(cb);
  }",51,,23,3,,void
17407,BLOCK,-1,,"{
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }",40,,24,2,,void
17425,BLOCK,-1,,"{
  return std::hash<void*>()(cb.arg_);
}",42,,36,2,,void
17440,BLOCK,-1,,"{
  return a.fn_ == b.fn_ && a.arg_ == b.arg_;
}",71,,41,3,,void
17471,BLOCK,-1,,<empty>,1,,1,1,,ANY
17480,BLOCK,-1,,<empty>,1,,1,1,,ANY
17487,BLOCK,-1,,"{
}",78,,13,4,,void
17498,BLOCK,-1,,<empty>,1,,1,1,,ANY
17519,BLOCK,-1,,<empty>,1,,1,1,,ANY
17525,BLOCK,-1,,<empty>,33,,29,4,,void
17531,BLOCK,-1,,"{
  WrapType* wrap_data = static_cast<WrapType*>(handle->data);
  CHECK_NOT_NULL(wrap_data);
  CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));

  Environment* env = wrap_data->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(wrap_data->persistent().IsEmpty(), false);

  Local<Value> client_handle;

  if (status == 0) {
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EA...",65,,34,3,,void
17587,BLOCK,-1,,"{
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EAGAIN (resource temporarily unavailable) will be
    // returned.
    if (uv_accept(handle, client))
      return;

    // Successful accept. Call the onconnection callback in JavaScript land.
    client_handle = client_obj;
  }",20,,49,2,,void
17609,BLOCK,-1,,<empty>,7,,54,2,,void
17629,BLOCK,-1,,<empty>,7,,64,2,,void
17635,BLOCK,-1,,"{
    client_handle = Undefined(env->isolate());
  }",10,,68,1,,void
17673,BLOCK,-1,,"{
  BaseObjectPtr<ConnectWrap> req_wrap{static_cast<ConnectWrap*>(req->data)};
  CHECK(req_wrap);
  WrapType* wrap = static_cast<WrapType*>(req->handle->data);
  CHECK_EQ(req_wrap->env(), wrap->env());
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // The wrap and request objects should still be there.
  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);
  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  bool readable, writable;

  if (status) {
    readable = writable = false;
  } else {
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }

  Local<Value> argv[5] = {
    Integer::New(env->isolate(), status),
    wrap->object(),
    req_wrap->object(),
    Boolean::New(env->isolate(), readable),
    Boolean::New(env->isolate(), writable)
  };

  TRACE_EVENT_NESTABLE_ASYNC_END1(TRACING_CATEGORY_NODE2(net, native),
                                  ""conn...",65,,79,3,,void
17746,BLOCK,-1,,"{
    readable = writable = false;
  }",15,,95,2,,void
17753,BLOCK,-1,,"{
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }",10,,97,1,,void
17808,BLOCK,-1,,<empty>,1,,1,1,,ANY
17839,BLOCK,-1,,<empty>,1,,1,1,,ANY
17850,BLOCK,-1,,"{
  CHECK_NOT_NULL(key_data);
  CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);

  const int mode = EVP_CIPHER_mode(params.cipher);

  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  EVP_CIPHER_CTX_init(ctx.get());
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          nullptr,
          nullptr,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
        ctx.get(),
        EVP_CTRL_AEAD_SET_IVLEN,
        params.iv.size(),
        nullptr)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CIPHER_CTX_set_key_length(
          ctx.get(),
          key_data->GetSymmetricKeySize()) ||
      !EVP_CipherInit_ex(
          ctx.get(),
          nullptr,
          nul...",22,,40,7,,void
17878,BLOCK,-1,,<empty>,5,,49,2,,void
17905,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,59,2,,void
17929,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",19,,68,2,,void
17967,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",21,,81,2,,void
17980,BLOCK,-1,,"{
    switch (cipher_mode) {
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }
  }",34,,87,2,,void
17983,BLOCK,-1,,"{
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }",26,,88,2,,void
18012,BLOCK,-1,,"{
          return WebCryptoCipherStatus::FAILED;
        }",79,,95,2,,void
18081,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",45,,123,2,,void
18096,BLOCK,-1,,"{
    out_len = 0;
  }",23,,137,2,,void
18101,BLOCK,-1,,<empty>,10,,139,1,,void
18123,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",44,,143,2,,void
18156,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",68,,151,2,,void
18172,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                             EVP_CTRL_AEAD_GET_TAG,
                             tag_len,
                             buf.data<unsigned char>() + total))
      return WebCryptoCipherStatus::FAILED;
    total += tag_len;
  }",76,,158,2,,void
18188,BLOCK,-1,,<empty>,7,,163,2,,void
18217,BLOCK,-1,,"{
  return a == 0 ? 0 : 1 + (a - 1) / b;
}",21,,178,3,,void
18235,BLOCK,-1,,"{
  unsigned int remainder = (params.length % CHAR_BIT);
  const unsigned char* data = params.iv.data<unsigned char>();

  if (remainder == 0) {
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }

  unsigned int byte_length =
      CeilDiv(params.length, static_cast<size_t>(CHAR_BIT));

  std::vector<unsigned char> counter(
      data + params.iv.size() - byte_length,
      data + params.iv.size());
  counter[0] &= ~(0xFF << remainder);

  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
}",57,,182,2,,void
18257,BLOCK,-1,,"{
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }",23,,186,2,,void
18335,BLOCK,-1,,"{
  unsigned int length_bytes = params.length / CHAR_BIT;
  unsigned int remainder = params.length % CHAR_BIT;

  const unsigned char* data = params.iv.data<unsigned char>();

  std::vector<unsigned char> new_counter_block(data, data + params.iv.size());

  size_t index = new_counter_block.size() - length_bytes;
  memset(&new_counter_block.front() + index, 0, length_bytes);

  if (remainder)
    new_counter_block[index - 1] &= 0xFF << remainder;

  return new_counter_block;
}",36,,206,2,,void
18393,BLOCK,-1,,<empty>,5,,218,2,,void
18414,BLOCK,-1,,"{
  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          reinterpret_cast<const unsigned char*>(key_data->GetSymmetricKey()),
          counter,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  int out_len = 0;
  int final_len = 0;
  if (!EVP_CipherUpdate(
          ctx.get(),
          out,
          &out_len,
          in.data<unsigned char>(),
          in.size())) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
    return WebCryptoCipherStatus::FAILED;

  out_len += final_len;
  if (static_cast<unsigned>(out_len) != in.size())
    return WebCryptoCipherStatus::FAILED;

  return WebCryptoCipherStatus::OK;
}",25,,229,7,,void
18443,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,239,2,,void
18474,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",23,,251,2,,void
18491,BLOCK,-1,,<empty>,5,,256,2,,void
18508,BLOCK,-1,,<empty>,5,,260,2,,void
18526,BLOCK,-1,,"{
  BignumPointer num_counters(BN_new());
  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
    return WebCryptoCipherStatus::FAILED;

  BignumPointer current_counter = GetCounter(params);

  BignumPointer num_output(BN_new());

  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
    return WebCryptoCipherStatus::FAILED;

  // Just like in chromium's implementation, if the counter will
  // be incremented more than there are counter values, we fail.
  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
    return WebCryptoCipherStatus::FAILED;

  BignumPointer remaining_until_reset(BN_new());
  if (!BN_sub(remaining_until_reset.get(),
              num_counters.get(),
              current_counter.get())) {
    return WebCryptoCipherStatus::FAILED;
  }

  // Output size is identical to the input size.
  ByteSource::Builder buf(in.size());

  // Also just like in chromium's implementation, if we can process
  // the input without wrapping the...",22,,271,7,,void
18541,BLOCK,-1,,<empty>,5,,274,2,,void
18567,BLOCK,-1,,<empty>,5,,281,2,,void
18584,BLOCK,-1,,<empty>,5,,286,2,,void
18607,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",39,,291,2,,void
18630,BLOCK,-1,,"{
    auto status = AES_CTR_Cipher2(key_data,
                                  cipher_mode,
                                  params,
                                  in,
                                  params.iv.data<unsigned char>(),
                                  buf.data<unsigned char>());
    if (status == WebCryptoCipherStatus::OK) *out = std::move(buf).release();
    return status;
  }",67,,301,2,,void
18655,BLOCK,-1,,<empty>,46,,308,2,,void
18715,BLOCK,-1,,<empty>,5,,325,2,,void
18761,BLOCK,-1,,<empty>,44,,340,2,,void
18782,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> iv(value);
  if (UNLIKELY(!iv.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }
  params->iv = (mode == kCryptoJobAsync)
      ? iv.ToCopy()
      : iv.ToByteSource();
  return true;
}",30,,349,5,,void
18793,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }",39,,351,2,,void
18823,BLOCK,-1,,"{
  CHECK(value->IsUint32());  // Length
  params->length = value.As<Uint32>()->Value();
  if (params->iv.size() != 16 ||
      params->length == 0 ||
      params->length > 128) {
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }
  return true;
}",28,,364,4,,void
18861,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }",29,,369,2,,void
18876,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }
  return true;
}",30,,381,6,,void
18879,BLOCK,-1,,"{
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }",24,,382,2,,void
18882,BLOCK,3,,"{
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }",35,,383,3,,void
18887,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",36,,384,2,,void
18902,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }",53,,389,2,,void
18927,BLOCK,6,,"{
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }",35,,398,6,,void
18934,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",31,,399,2,,void
18956,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",33,,404,2,,void
18973,BLOCK,-1,,"{
  // Additional Data
  if (IsAnyByteSource(value)) {
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }
  return true;
}",30,,420,5,,void
18977,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }",31,,422,2,,void
18988,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }",49,,424,2,,void
19016,BLOCK,-1,,"{
  params->iv = ByteSource::Foreign(kDefaultWrapIV, strlen(kDefaultWrapIV));
}",44,,435,2,,void
19032,BLOCK,-1,,<empty>,33,,447,2,,void
19037,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~AESCipherConfig();
  return *new (this) AESCipherConfig(std::move(other));
}",79,,449,2,,void
19043,BLOCK,-1,,<empty>,23,,450,2,,void
19065,BLOCK,-1,,"{
  // If mode is sync, then the data in each of these properties
  // is not owned by the AESCipherConfig, so we ignore it.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }
}",64,,455,2,,void
19070,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }",32,,458,2,,void
19106,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsUint32());  // Key Variant
  params->variant =
      static_cast<AESKeyVariant>(args[offset].As<Uint32>()->Value());

  int cipher_nid;

  switch (params->variant) {
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      ...",30,,470,6,,void
19147,BLOCK,-1,,"{
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      break;
    case kKeyVariantAES_CBC_128:
      if (!ValidateIV(env, mode, args[offset + 1], params))
        return Nothing<bool>();
      cipher_nid = NID_aes_128_cbc;
      break;
    case kKeyVariantAES_CBC_192:
      if (!ValidateIV(env, mode, args[offset + 1], pa...",28,,481,2,,void
19171,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,484,2,,void
19201,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,491,2,,void
19231,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,498,2,,void
19251,BLOCK,-1,,<empty>,9,,505,2,,void
19271,BLOCK,-1,,<empty>,9,,510,2,,void
19291,BLOCK,-1,,<empty>,9,,515,2,,void
19358,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,533,2,,void
19401,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,541,2,,void
19444,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,549,2,,void
19465,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
    return Nothing<bool>();
  }",34,,559,2,,void
19484,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env);
    return Nothing<bool>();
  }",66,,565,2,,void
19501,BLOCK,-1,,"{
#define V(name, fn)                                                           \
  case kKeyVariantAES_ ## name:                                               \
    return fn(env, key_data.get(), cipher_mode, params, in, out);
  switch (params.variant) {
    VARIANTS(V)
    default:
      UNREACHABLE();
  }
#undef V
}",22,,579,7,,void
19506,BLOCK,-1,,"{
    VARIANTS(V)
    default:
      UNREACHABLE();
  }",27,,583,2,,void
19516,BLOCK,-1,,"{
  AESCryptoJob::Initialize(env, target);

#define V(name, _) NODE_DEFINE_CONSTANT(target, kKeyVariantAES_ ## name);
  VARIANTS(V)
#undef V
}",62,,591,3,,void
19529,BLOCK,-1,,"{
  AESCryptoJob::RegisterExternalReferences(registry);
}",75,,599,2,,void
19551,BLOCK,-1,,<empty>,1,,1,1,,ANY
19554,BLOCK,-1,,"{
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",43,,224,1,,void
19604,BLOCK,-1,,<empty>,1,,1,1,,ANY
19609,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(GetMethod()));
  if (bio && env != nullptr)
    NodeBIO::FromBIO(bio.get())->env_ = env;
  return bio;
}",43,,35,2,,void
19612,BLOCK,-1,,<empty>,,,,2,,<empty>
19621,BLOCK,-1,,<empty>,5,,38,2,,void
19642,BLOCK,-1,,"{
  BIOPointer bio = New(env);

  if (!bio ||
      len > INT_MAX ||
      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
    return BIOPointer();
  }

  return bio;
}",78,,43,4,,void
19676,BLOCK,-1,,"{
    return BIOPointer();
  }",50,,49,2,,void
19685,BLOCK,-1,,"{
  BIO_set_data(bio, new NodeBIO());
  BIO_set_init(bio, 1);

  return 1;
}",28,,57,2,,void
19699,BLOCK,-1,,"{
  if (bio == nullptr)
    return 0;

  if (BIO_get_shutdown(bio)) {
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }

  return 1;
}",29,,65,2,,void
19704,BLOCK,-1,,<empty>,5,,67,2,,void
19710,BLOCK,-1,,"{
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }",30,,69,2,,void
19719,BLOCK,-1,,"{
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }",60,,70,2,,void
19734,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  NodeBIO* nbio = FromBIO(bio);
  int bytes = nbio->Read(out, len);

  if (bytes == 0) {
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }

  return bytes;
}",49,,80,4,,void
19755,BLOCK,-1,,"{
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }",19,,86,2,,void
19766,BLOCK,-1,,"{
      BIO_set_retry_read(bio);
    }",21,,88,2,,void
19775,BLOCK,-1,,"{
  *size = read_head_->write_pos_ - read_head_->read_pos_;
  return read_head_->data_ + read_head_->read_pos_;
}",35,,97,2,,void
19800,BLOCK,-1,,"{
  Buffer* pos = read_head_;
  size_t max = *count;
  size_t total = 0;

  size_t i;
  for (i = 0; i < max; i++) {
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }

  if (i == max)
    *count = i;
  else
    *count = i + 1;

  return total;
}",71,,103,4,,void
19816,BLOCK,-1,,<empty>,3,,109,1,,void
19825,BLOCK,4,,"{
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }",29,,109,4,,void
19857,BLOCK,-1,,<empty>,7,,116,2,,void
19860,BLOCK,-1,,<empty>,7,,118,1,,void
19870,BLOCK,-1,,<empty>,5,,122,2,,void
19876,BLOCK,-1,,<empty>,5,,124,1,,void
19891,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  FromBIO(bio)->Write(data, len);

  return len;
}",57,,130,4,,void
19908,BLOCK,-1,,"{
  return Write(bio, str, strlen(str));
}",46,,139,3,,void
19921,BLOCK,-1,,"{
  NodeBIO* nbio = FromBIO(bio);

  if (nbio->Length() == 0)
    return 0;

  int i = nbio->IndexOf('\n', size);

  // Include '\n', if it's there.  If not, don't read off the end.
  if (i < size && i >= 0 && static_cast<size_t>(i) < nbio->Length())
    i++;

  // Shift `i` a bit to nullptr-terminate string later
  if (size == i)
    i--;

  // Flush read data
  nbio->Read(out, i);

  out[i] = 0;

  return i;
}",50,,144,4,,void
19934,BLOCK,-1,,<empty>,5,,148,2,,void
19963,BLOCK,-1,,<empty>,5,,154,2,,void
19970,BLOCK,-1,,<empty>,5,,158,2,,void
19993,BLOCK,-1,,"{
  NodeBIO* nbio;
  long ret;  // NOLINT(runtime/int)

  nbio = FromBIO(bio);
  ret = 1;

  switch (cmd) {
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
...",31,,170,5,,void
20005,BLOCK,-1,,"{
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
    case BIO_CTRL_PUSH:
    case BIO_CTRL_POP:
    default:
      ret = 0;
      break;
  }",16,,177,2,,void
20044,BLOCK,-1,,<empty>,9,,190,2,,void
20110,BLOCK,-1,,"{
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",40,,222,1,,void
20121,BLOCK,-1,,"{
  // `read_pos_` and `write_pos_` means the position of the reader and writer
  // inside the buffer, respectively. When they're equal - its safe to reset
  // them, because both reader and writer will continue doing their stuff
  // from new (zero) positions.
  while (read_head_->read_pos_ != 0 &&
         read_head_->read_pos_ == read_head_->write_pos_) {
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }
}",33,,240,1,,void
20136,BLOCK,-1,,"{
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }",59,,246,2,,void
20151,BLOCK,-1,,<empty>,7,,254,2,,void
20162,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t expected = Length() > size ? size : Length();
  size_t offset = 0;
  size_t left = size;

  while (bytes_read < expected) {
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }
  CHECK_EQ(expected, bytes_read);
  length_ -= bytes_read;

  // Free all empty buffers, but write_head's child
  FreeEmpty();

  return bytes_read;
}",46,,259,3,,void
20188,BLOCK,-1,,"{
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }",33,,265,2,,void
20210,BLOCK,-1,,<empty>,7,,269,2,,void
20218,BLOCK,-1,,<empty>,7,,273,2,,void
20258,BLOCK,-1,,"{
  if (write_head_ == nullptr)
    return;
  Buffer* child = write_head_->next_;
  if (child == write_head_ || child == read_head_)
    return;
  Buffer* cur = child->next_;
  if (cur == write_head_ || cur == read_head_)
    return;

  Buffer* prev = child;
  while (cur != read_head_) {
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }
  prev->next_ = cur;
}",27,,293,1,,void
20263,BLOCK,-1,,<empty>,5,,295,2,,void
20279,BLOCK,-1,,<empty>,5,,298,2,,void
20295,BLOCK,-1,,<empty>,5,,301,2,,void
20305,BLOCK,-1,,"{
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }",29,,304,2,,void
20337,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t max = Length() > limit ? limit : Length();
  size_t left = limit;
  Buffer* current = read_head_;

  while (bytes_read < max) {
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }
  CHECK_EQ(max, bytes_read);

  return max;
}",51,,316,3,,void
20363,BLOCK,-1,,"{
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }",28,,322,2,,void
20385,BLOCK,-1,,<empty>,7,,326,2,,void
20412,BLOCK,-1,,"{
      off++;
      tmp++;
    }",42,,331,2,,void
20427,BLOCK,-1,,"{
      return bytes_read;
    }",23,,341,2,,void
20440,BLOCK,-1,,"{
      current = current->next_;
    }",54,,346,2,,void
20456,BLOCK,-1,,"{
  size_t offset = 0;
  size_t left = size;

  // Allocate initial buffer if the ring is empty
  TryAllocateForWrite(left);

  while (left > 0) {
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMov...",52,,356,3,,void
20471,BLOCK,-1,,"{
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }
  }",20,,363,2,,void
20497,BLOCK,-1,,<empty>,7,,369,2,,void
20538,BLOCK,-1,,"{
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }",20,,384,2,,void
20561,BLOCK,-1,,"{
  TryAllocateForWrite(*size);

  size_t available = write_head_->len_ - write_head_->write_pos_;
  if (*size == 0 || available <= *size)
    *size = available;

  return write_head_->data_ + write_head_->write_pos_;
}",43,,398,2,,void
20585,BLOCK,-1,,<empty>,5,,403,2,,void
20602,BLOCK,-1,,"{
  write_head_->write_pos_ += size;
  length_ += size;
  CHECK_LE(write_head_->write_pos_, write_head_->len_);

  // Allocate new buffer if write head is full,
  // and there're no other place to go
  TryAllocateForWrite(0);
  if (write_head_->write_pos_ == write_head_->len_) {
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }
}",35,,409,2,,void
20628,BLOCK,-1,,"{
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }",53,,417,2,,void
20639,BLOCK,-1,,"{
  Buffer* w = write_head_;
  Buffer* r = read_head_;
  // If write head is full, next buffer is either read head or not empty.
  if (w == nullptr ||
      (w->write_pos_ == w->len_ &&
       (w->next_ == r || w->next_->write_pos_ != 0))) {
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }
}",48,,427,2,,void
20674,BLOCK,-1,,"{
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }",55,,433,2,,void
20688,BLOCK,-1,,<empty>,7,,437,2,,void
20696,BLOCK,-1,,"{
      len = allocate_hint_;
      allocate_hint_ = 0;
    }",31,,440,2,,void
20714,BLOCK,-1,,"{
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    }",23,,447,2,,void
20727,BLOCK,-1,,"{
      next->next_ = w->next_;
      w->next_ = next;
    }",12,,451,1,,void
20743,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  while (read_head_->read_pos_ != read_head_->write_pos_) {
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }
  write_head_ = read_head_;
  CHECK_EQ(length_, 0);
}",23,,459,1,,void
20748,BLOCK,-1,,<empty>,5,,461,2,,void
20758,BLOCK,-1,,"{
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }",59,,463,2,,void
20800,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  Buffer* current = read_head_;
  do {
    Buffer* next = current->next_;
    delete current;
    current = next;
  } while (current != read_head_);

  read_head_ = nullptr;
  write_head_ = nullptr;
}",21,,477,1,,void
20805,BLOCK,-1,,<empty>,5,,479,2,,void
20812,BLOCK,-1,,"{
    Buffer* next = current->next_;
    delete current;
    current = next;
  }",6,,482,1,,void
20837,BLOCK,-1,,"{
  CHECK_NOT_NULL(BIO_get_data(bio));
  return static_cast<NodeBIO*>(BIO_get_data(bio));
}",37,,493,2,,void
20860,BLOCK,-1,,<empty>,1,,1,1,,ANY
20867,BLOCK,-1,,"{
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  }",62,,849,5,,void
20888,BLOCK,-1,,<empty>,7,,854,2,,void
20908,BLOCK,-1,,"{
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }",24,,858,2,,void
20913,BLOCK,-1,,"{
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }",29,,859,2,,void
20985,BLOCK,-1,,<empty>,1,,1,1,,ANY
20991,BLOCK,-1,,"{
  switch (EVP_CIPHER_mode(cipher)) {
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }
}",61,,29,2,,void
20995,BLOCK,-1,,"{
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }",36,,30,2,,void
21018,BLOCK,-1,,"{
  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
  return IsSupportedAuthenticatedMode(cipher);
}",62,,44,2,,void
21031,BLOCK,-1,,"{
  return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);
}",48,,49,2,,void
21052,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> info = args[0].As<Object>();

  CHECK(args[1]->IsString() || args[1]->IsInt32());

  const EVP_CIPHER* cipher;
  if (args[1]->IsString()) {
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  } else {
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }

  if (cipher == nullptr)
    return;

  int mode = EVP_CIPHER_mode(cipher);
  int iv_length = EVP_CIPHER_iv_length(cipher);
  int key_length = EVP_CIPHER_key_length(cipher);
  int block_length = EVP_CIPHER_block_size(cipher);
  const char* mode_label = nullptr;
  switch (mode) {
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIP...",61,,54,2,,void
21102,BLOCK,-1,,"{
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  }",28,,62,2,,void
21118,BLOCK,-1,,"{
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }",10,,65,1,,void
21139,BLOCK,-1,,<empty>,5,,71,2,,void
21167,BLOCK,-1,,"{
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIPH_GCM_MODE: mode_label = ""gcm""; break;
    case EVP_CIPH_OCB_MODE: mode_label = ""ocb""; break;
    case EVP_CIPH_OFB_MODE: mode_label = ""ofb""; break;
    case EVP_CIPH_WRAP_MODE: mode_label = ""wrap""; break;
    case EVP_CIPH_XTS_MODE: mode_label = ""xts""; break;
    case EVP_CIPH_STREAM_CIPHER: mode_label = ""stream""; break;
  }",17,,78,2,,void
21248,BLOCK,-1,,"{
    // Test and input IV or key length to determine if it's acceptable.
    // If it is, then the getCipherInfo will succeed with the given
    // values.
    CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
    if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
      return;

    if (args[2]->IsInt32()) {
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }

    if (args[3]->IsInt32()) {
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
      ...",49,,97,2,,void
21264,BLOCK,-1,,<empty>,7,,103,2,,void
21273,BLOCK,-1,,"{
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }",29,,105,2,,void
21294,BLOCK,-1,,<empty>,9,,108,2,,void
21306,BLOCK,-1,,"{
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }
      iv_length = check_len;
    }",29,,112,2,,void
21321,BLOCK,-1,,"{
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }",21,,118,2,,void
21332,BLOCK,-1,,<empty>,13,,121,2,,void
21349,BLOCK,-1,,"{
            return;
          }",29,,130,2,,void
21357,BLOCK,-1,,<empty>,13,,136,2,,void
21390,BLOCK,-1,,"{
    return;
  }",67,,146,2,,void
21416,BLOCK,-1,,"{
    return;
  }",63,,157,2,,void
21446,BLOCK,-1,,"{
    return;
  }",76,,164,2,,void
21479,BLOCK,-1,,"{
    return;
  }",66,,173,2,,void
21512,BLOCK,-1,,"{
    return;
  }",63,,182,2,,void
21541,BLOCK,-1,,"{
    return;
  }",64,,189,2,,void
21555,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
  if (!ctx) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }

  SSLPointer ssl(SSL_new(ctx.get()));
  if (!ssl) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }

  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());

  // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
  // document them, but since there are only 5, easier to just add them manually
  // and not have to explain their absence in the API docs. They are lower-cased
  // because the docs say they will be.
  static const char* TLS13_CIPHERS[] = {
    ""tls_aes_256_gcm_sha384"",
    ""tls_chacha20_poly1305_sha256"",
    ""tls_aes_128_gcm_sha256"",
    ""tls_aes_128_ccm_8_sha256"",
    ""tls_aes_128_ccm_sha256""
  };

  const int n = sk_SSL_CIPHER_num(ciphers);
  std::vector<Local<Value>> arr(n + arraysize(TLS13_CIPHERS));

  for (int i = 0; i < n; ++i) {
    co...",73,,197,2,,void
21566,BLOCK,-1,,<empty>,,,,2,,<empty>
21572,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",13,,201,2,,void
21588,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }",13,,206,2,,void
21632,BLOCK,-1,,<empty>,3,,227,1,,void
21642,BLOCK,4,,"{
    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
    arr[i] = OneByteString(env->isolate(), SSL_CIPHER_get_name(cipher));
  }",31,,227,4,,void
21661,BLOCK,-1,,<empty>,3,,232,1,,void
21672,BLOCK,4,,"{
    const char* name = TLS13_CIPHERS[i];
    arr[n + i] = OneByteString(env->isolate(), name);
  }",59,,232,4,,void
21718,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_CIPHER_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_CIPHER,
                    EVP_CIPHER_fetch,
                    EVP_CIPHER_free,
                    EVP_get_cipherbyname,
                    EVP_CIPHER_get0_name>,
#else
    array_push_back<EVP_CIPHER>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",70,,240,2,,void
21752,BLOCK,-1,,"{
  MakeWeak();
}",35,,266,4,,void
21758,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_EVP_CIPHER_CTX : 0);
}",59,,270,2,,void
21773,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(CipherBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", Init);
  SetProtoMethod(isolate, t, ""initiv"", InitIv);
  SetProtoMethod(isolate, t, ""update"", Update);
  SetProtoMethod(isolate, t, ""final"", Final);
  SetProtoMethod(isolate, t, ""setAutoPadding"", SetAutoPadding);
  SetProtoMethodNoSideEffect(isolate, t, ""getAuthTag"", GetAuthTag);
  SetProtoMethod(isolate, t, ""setAuthTag"", SetAuthTag);
  SetProtoMethod(isolate, t, ""setAAD"", SetAAD);
  SetConstructorFunction(context, target, ""CipherBase"", t);

  SetMethodNoSideEffect(context, target, ""getSSLCiphers"", GetSSLCiphers);
  SetMethodNoSideEffect(context, target, ""getCiphers"", GetCiphers);

  SetMethod(context,
            target,
            ""publicEncrypt"",
            PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
        ...",69,,274,3,,void
21903,BLOCK,1,,<empty>,,,,7,,void
21905,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherEncrypt)",3,,322,1,,void
22002,BLOCK,1,,<empty>,,,,7,,void
22004,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherDecrypt)",3,,323,1,,void
22100,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Init);
  registry->Register(InitIv);
  registry->Register(Update);
  registry->Register(Final);
  registry->Register(SetAutoPadding);
  registry->Register(GetAuthTag);
  registry->Register(SetAuthTag);
  registry->Register(SetAAD);

  registry->Register(GetSSLCiphers);
  registry->Register(GetCiphers);

  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
                                             EVP_PKEY_encrypt_init,
                                             EVP_PKEY_encrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_decrypt_init,
                                             EVP_PKEY_decrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_sign_init,
                                             EVP_PKEY_sign>);
  registry->Register(PublicKeyCip...",42,,327,2,,void
22193,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new CipherBase(env, args.This(), args[0]->IsTrue() ? kCipher : kDecipher);
}",63,,358,2,,void
22233,BLOCK,-1,,"{
  CHECK(!ctx_);
  ctx_.reset(EVP_CIPHER_CTX_new());

  const int mode = EVP_CIPHER_mode(cipher);
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = (kind_ == kCipher);
  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                             nullptr, nullptr, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }

  if (IsSupportedAuthenticatedMode(cipher)) {
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }

  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }

  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }
}",56,,370,8,,void
22251,BLOCK,-1,,<empty>,5,,376,2,,void
22277,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",58,,380,2,,void
22286,BLOCK,-1,,"{
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }",45,,385,2,,void
22296,BLOCK,-1,,<empty>,7,,388,2,,void
22306,BLOCK,-1,,"{
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }",60,,391,2,,void
22327,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",79,,396,2,,void
22339,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr)) {
#else
  if (FIPS_mode()) {
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  unsigned char key[EVP_MAX_KEY_LENGTH];
  unsigned char iv[EVP_MAX_IV_LENGTH];

  int key_len = EVP_BytesToKey(cipher,
                               EVP_md5(),
                               nullptr,
                               key_buf.data(),
                               key_buf.size(),
                               1,
                               key,
                               iv);
  CHECK_NE(key_len, 0);

  const int mode = EVP_CIPHER_mode(cipher);
  if (kind_ == kCipher && (mode == EVP_C...",50,,404,4,,void
22349,BLOCK,-1,,"{
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }",20,,410,2,,void
22363,BLOCK,-1,,<empty>,5,,418,2,,void
22411,BLOCK,-1,,"{
    // Ignore the return value (i.e. possible exception) because we are
    // not calling back into JS anyway.
    ProcessEmitWarning(env(),
                       ""Use Cipheriv for counter mode of %s"",
                       cipher_type);
  }",56,,436,2,,void
22429,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_GE(args.Length(), 3);

  const Utf8Value cipher_type(args.GetIsolate(), args[0]);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[1]);
  if (!key_buf.CheckSizeInt32())
    return THROW_ERR_OUT_OF_RANGE(env, ""password is too large"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[2]->IsUint32()) {
    auth_tag_len = args[2].As<Uint32>()->Value();
  } else {
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }

  cipher->Init(*cipher_type, key_buf, auth_tag_len);
}",64,,448,2,,void
22472,BLOCK,-1,,<empty>,5,,458,2,,void
22485,BLOCK,-1,,"{
    auth_tag_len = args[2].As<Uint32>()->Value();
  }",28,,463,2,,void
22498,BLOCK,-1,,"{
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,465,1,,void
22537,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
  const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
  const bool has_iv = iv_buf.size() > 0;

  // Throw if no IV was passed and the cipher requires an IV
  if (!has_iv && expected_iv_len != 0)
    return THROW_ERR_CRYPTO_INVALID_IV(env());

  // Throw if an IV was passed which does not match the cipher's fixed IV length
  // static_cast<int> for the iv_buf.size() is safe because we've verified
  // prior that the value is not larger than INT_MAX.
  if (!is_authenticated_mode &&
      has_iv &&
      static_cast<int>(iv_buf.size()) != expected_iv_len) {
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }

  if (EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
    CHE...",52,,476,5,,void
22554,BLOCK,-1,,<empty>,5,,482,2,,void
22584,BLOCK,-1,,<empty>,5,,490,2,,void
22602,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",59,,497,2,,void
22611,BLOCK,-1,,"{
    CHECK(has_iv);
    // Check for invalid IV lengths, since OpenSSL does not under some
    // conditions:
    //   https://www.openssl.org/news/secadv/20190306.txt.
    if (iv_buf.size() > 12)
      return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",56,,501,2,,void
22621,BLOCK,-1,,<empty>,7,,507,2,,void
22649,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = cipher->env();

  CHECK_GE(args.Length(), 4);

  const Utf8Value cipher_type(env->isolate(), args[0]);

  // The argument can either be a KeyObjectHandle or a byte source
  // (e.g. ArrayBuffer, TypedArray, etc). Whichever it is, grab the
  // raw bytes and proceed...
  const ByteSource key_buf = ByteSource::FromSecretKeyBytes(env, args[1]);

  if (UNLIKELY(key_buf.size() > INT_MAX))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  ArrayBufferOrViewContents<unsigned char> iv_buf(
      !args[2]->IsNull() ? args[2] : Local<Value>());

  if (UNLIKELY(!iv_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[3]->IsUint32()) {
    auth_tag_len = args[3].As<Uint32>()->Value();
  } else {
    CHECK(ar...",66,,520,2,,void
22699,BLOCK,-1,,<empty>,5,,535,2,,void
22725,BLOCK,-1,,<empty>,5,,541,2,,void
22738,BLOCK,-1,,"{
    auth_tag_len = args[3].As<Uint32>()->Value();
  }",28,,546,2,,void
22751,BLOCK,-1,,"{
    CHECK(args[3]->IsInt32() && args[3].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,548,1,,void
22790,BLOCK,-1,,"{
  CHECK(IsAuthenticatedMode());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                           EVP_CTRL_AEAD_SET_IVLEN,
                           iv_len,
                           nullptr)) {
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
  if (mode == EVP_CIPH_GCM_MODE) {
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  } else {
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag...",32,,559,4,,void
22803,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }",38,,566,2,,void
22819,BLOCK,-1,,"{
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  }",34,,572,2,,void
22824,BLOCK,-1,,"{
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }",43,,573,2,,void
22829,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }",47,,574,2,,void
22840,BLOCK,-1,,"{
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }

    // TODO(tniessen) Support CCM decryption in FIPS mode

#if OPENSSL_VERSION_MAJOR >= 3
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher &&
        EVP_default_properties_is_fips_enabled(nullptr)) {
#else
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mo...",10,,585,1,,void
22845,BLOCK,-1,,"{
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }",43,,586,2,,void
22854,BLOCK,-1,,"{
        auth_tag_len = 16;
      }",68,,591,2,,void
22859,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }",14,,593,1,,void
22876,BLOCK,-1,,"{
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mode"");
      return false;
    }",73,,606,2,,void
22892,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""Invalid authentication tag length: %u"", auth_tag_len);
      return false;
    }",40,,615,2,,void
22906,BLOCK,-1,,"{
      // Restrict the message length to min(INT_MAX, 2^(8*(15-iv_len))-1) bytes.
      CHECK(iv_len >= 7 && iv_len <= 13);
      max_message_size_ = INT_MAX;
      if (iv_len == 12) max_message_size_ = 16777215;
      if (iv_len == 13) max_message_size_ = 65535;
    }",36,,624,2,,void
22922,BLOCK,-1,,<empty>,25,,628,2,,void
22930,BLOCK,-1,,<empty>,25,,629,2,,void
22940,BLOCK,-1,,"{
  CHECK(ctx_);
  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);

  if (message_len > max_message_size_) {
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }

  return true;
}",57,,636,2,,void
22954,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }",40,,640,2,,void
22963,BLOCK,-1,,"{
  // Check if this cipher operates in an AEAD mode that we support.
  CHECK(ctx_);
  return IsSupportedAuthenticatedMode(ctx_.get());
}",46,,648,1,,void
22975,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  // Only callable after Final and if encrypting.
  if (cipher->ctx_ ||
      cipher->kind_ != kCipher ||
      cipher->auth_tag_len_ == kNoAuthTagLength) {
    return;
  }

  args.GetReturnValue().Set(
      Buffer::Copy(env, cipher->auth_tag_, cipher->auth_tag_len_)
          .FromMaybe(Local<Value>()));
}",70,,654,2,,void
23008,BLOCK,-1,,"{
    return;
  }",50,,662,2,,void
23036,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  if (!cipher->ctx_ ||
      !cipher->IsAuthenticatedMode() ||
      cipher->kind_ != kDecipher ||
      cipher->auth_tag_state_ != kAuthTagUnknown) {
    return args.GetReturnValue().Set(false);
  }

  ArrayBufferOrViewContents<char> auth_tag(args[0]);
  if (UNLIKELY(!auth_tag.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  unsigned int tag_len = auth_tag.size();

  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
  bool is_valid;
  if (mode == EVP_CIPH_GCM_MODE) {
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  } else {
    // At this point, the tag length is already known and must match the
    // length of the given authentication ta...",70,,671,2,,void
23076,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,679,2,,void
23098,BLOCK,-1,,<empty>,5,,685,2,,void
23125,BLOCK,-1,,"{
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  }",34,,691,2,,void
23143,BLOCK,-1,,"{
    // At this point, the tag length is already known and must match the
    // length of the given authentication tag.
    CHECK(IsSupportedAuthenticatedMode(cipher->ctx_.get()));
    CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);
    is_valid = cipher->auth_tag_len_ == tag_len;
  }",10,,696,1,,void
23167,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
      env, ""Invalid authentication tag length: %u"", tag_len);
  }",18,,704,2,,void
23221,BLOCK,-1,,"{
  if (auth_tag_state_ == kAuthTagKnown) {
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }
  return true;
}",46,,719,1,,void
23226,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }",41,,720,2,,void
23239,BLOCK,-1,,"{
      return false;
    }",76,,724,2,,void
23252,BLOCK,-1,,"{
  if (!ctx_ || !IsAuthenticatedMode())
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  int outlen;
  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  // When in CCM mode, we need to set the authentication tag and the plaintext
  // length in advance.
  if (mode == EVP_CIPH_CCM_MODE) {
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }

  return 1 == EVP_CipherUpdate(ctx_.get(),
                               nullptr,
                               &outlen,
                               data.data(),
                               data.size());
}",24,,734,3,,void
23259,BLOCK,-1,,<empty>,5,,736,2,,void
23276,BLOCK,-1,,"{
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }",34,,744,2,,void
23281,BLOCK,-1,,"{
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }",28,,745,2,,void
23291,BLOCK,-1,,<empty>,7,,752,2,,void
23298,BLOCK,-1,,"{
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }",29,,754,2,,void
23302,BLOCK,-1,,<empty>,9,,756,2,,void
23317,BLOCK,-1,,<empty>,7,,761,2,,void
23343,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[1]->IsInt32());
  int plaintext_len = args[1].As<Int32>()->Value();
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);

  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
  args.GetReturnValue().Set(cipher->SetAAD(buf, plaintext_len));
}",66,,771,2,,void
23397,BLOCK,-1,,<empty>,5,,782,2,,void
23421,BLOCK,-1,,"{
  if (!ctx_ || len > INT_MAX)
    return kErrorState;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
    return kErrorMessageSize;

  // Pass the authentication tag to OpenSSL if possible. This will only happen
  // once, usually on the first update.
  if (kind_ == kDecipher && IsAuthenticatedMode())
    CHECK(MaybePassAuthTagToOpenSSL());

  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
  CHECK_GT(block_size, 0);
  if (len + block_size > INT_MAX) return kErrorState;
  int buf_len = len + block_size;

  // For key wrapping algorithms, get output size by calling
  // EVP_CipherUpdate() with null output.
  if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
      EVP_CipherUpdate(ctx_.get(),
                       nullptr,
                       &buf_len,
                       reinterpret_cast<const unsigned char*>(data),
                       l...",41,,789,4,,void
23429,BLOCK,-1,,<empty>,5,,791,2,,void
23449,BLOCK,-1,,<empty>,5,,797,2,,void
23458,BLOCK,-1,,<empty>,5,,802,2,,void
23477,BLOCK,-1,,<empty>,35,,806,2,,void
23509,BLOCK,-1,,"{
    return kErrorState;
  }",35,,816,2,,void
23512,BLOCK,14,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), buf_len);
  }",3,,820,14,,void
23565,BLOCK,-1,,<empty>,5,,833,2,,void
23579,BLOCK,-1,,<empty>,5,,835,1,,void
23609,BLOCK,-1,,"{
    pending_auth_failed_ = true;
    return kSuccess;
  }",62,,839,2,,void
23625,BLOCK,-1,,"{
  Decode<CipherBase>(args, [](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  });
}",66,,846,2,,void
23638,BLOCK,-1,,"{
  if (!ctx_)
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;
  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
}",52,,872,2,,void
23642,BLOCK,-1,,<empty>,5,,874,2,,void
23657,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
  args.GetReturnValue().Set(b);  // Possibly report invalid state failure
}",74,,879,2,,void
23698,BLOCK,-1,,"{
  if (!ctx_)
    return false;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }

  if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
    MaybePassAuthTagToOpenSSL();

  // OpenSSL v1.x doesn't verify the presence of the auth tag so do
  // it ourselves, see https://github.com/nodejs/node/issues/45874.
  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
    return false;
  }

  // In CCM mode, final() only checks whether authentication failed in update().
  // EVP_CipherFinal_ex must not be called and will fail.
  bool ok;
  if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
    ok = !pending_auth_failed_;
    *out = Ar...",60,,887,2,,void
23702,BLOCK,-1,,<empty>,5,,889,2,,void
23713,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }",3,,893,4,,void
23748,BLOCK,-1,,<empty>,5,,900,2,,void
23770,BLOCK,-1,,"{
    return false;
  }",51,,906,2,,void
23782,BLOCK,-1,,"{
    ok = !pending_auth_failed_;
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
  }",56,,913,2,,void
23800,BLOCK,-1,,"{
    int out_len = (*out)->ByteLength();
    ok = EVP_CipherFinal_ex(ctx_.get(),
                            static_cast<unsigned char*>((*out)->Data()),
                            &out_len) == 1;

    CHECK_LE(static_cast<size_t>(out_len), (*out)->ByteLength());
    if (out_len > 0) {
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    } else {
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }

    if (ok && kind_ == kCipher && IsAuthenticatedMode()) {
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinte...",10,,916,1,,void
23840,BLOCK,-1,,"{
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    }",22,,923,2,,void
23860,BLOCK,-1,,"{
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }",12,,926,1,,void
23881,BLOCK,-1,,"{
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinterpret_cast<unsigned char*>(auth_tag_)));
    }",58,,930,2,,void
23886,BLOCK,-1,,"{
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }",46,,934,2,,void
23919,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  if (cipher->ctx_ == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env);

  std::unique_ptr<BackingStore> out;

  // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.
  const bool is_auth_mode = cipher->IsAuthenticatedMode();
  bool r = cipher->Final(&out);

  if (!r) {
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
  args.GetReturnValue().Set(
      Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
}",65,,949,2,,void
23942,BLOCK,-1,,<empty>,5,,955,2,,void
23972,BLOCK,-1,,"{
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }",11,,963,2,,void
24036,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (!ctx)
    return false;
  if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
    return false;
  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
    return false;

  if (digest != nullptr) {
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }

  if (!SetRsaOaepLabel(ctx, oaep_label.ToByteSource())) return false;

  size_t out_len = 0;
  if (EVP_PKEY_cipher(
          ctx.get(),
          nullptr,
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (EVP_PKEY_cipher(
          ctx.get(),
          static_cast<unsigned char*>((*out)->Data()),
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  CHECK_LE(out_len, (*out)->ByteLength());
  if (o...",41,,986,8,,void
24048,BLOCK,-1,,<empty>,5,,989,2,,void
24059,BLOCK,-1,,<empty>,5,,991,2,,void
24071,BLOCK,-1,,<empty>,5,,993,2,,void
24078,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }",26,,995,2,,void
24088,BLOCK,-1,,<empty>,7,,997,2,,void
24099,BLOCK,-1,,<empty>,57,,1000,2,,void
24125,BLOCK,-1,,"{
    return false;
  }",30,,1008,2,,void
24128,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,1012,11,,void
24172,BLOCK,-1,,"{
    return false;
  }",30,,1022,2,,void
24186,BLOCK,-1,,<empty>,5,,1028,2,,void
24206,BLOCK,-1,,<empty>,5,,1030,1,,void
24225,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<unsigned char> buf(args[offset]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too long"");

  uint32_t padding;
  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;

  const EVP_MD* digest = nullptr;
  if (args[offset + 2]->IsString()) {
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }

  ArrayBufferOrViewContents<unsigned char> oaep_label(
      !args[offset + 3]->IsUndefined() ? args[offset + 3] : Local<Value>());
  if (UNLIKELY(!oaep_label.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""oaepL...",71,,1038,2,,void
24252,BLOCK,-1,,<empty>,5,,1046,2,,void
24266,BLOCK,-1,,<empty>,5,,1050,2,,void
24291,BLOCK,-1,,<empty>,68,,1053,2,,void
24306,BLOCK,-1,,"{
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }",37,,1056,2,,void
24327,BLOCK,-1,,<empty>,7,,1060,2,,void
24356,BLOCK,-1,,<empty>,5,,1066,2,,void
24379,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error());
  }",63,,1070,2,,void
24445,BLOCK,-1,,<empty>,1,,1,1,,ANY
24454,BLOCK,-1,,<empty>,1,,1,1,,ANY
24463,BLOCK,-1,,<empty>,1,,1,1,,ANY
24469,BLOCK,-1,,"{
  switch (state_) {
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }
}",66,,27,3,,void
24472,BLOCK,-1,,"{
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }",19,,28,2,,void
24480,BLOCK,-1,,<empty>,9,,31,2,,void
24500,BLOCK,-1,,"{
  // >= 5 bytes for header parsing
  if (avail < 5)
    return false;

  if (data[0] == kChangeCipherSpec ||
      data[0] == kAlert ||
      data[0] == kHandshake ||
      data[0] == kApplicationData) {
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  } else {
    End();
    return false;
  }

  // Sanity check (too big frame, or too small)
  // Let OpenSSL handle it
  if (frame_len_ >= kMaxTLSFrameLen) {
    End();
    return false;
  }

  return true;
}",78,,47,3,,void
24505,BLOCK,-1,,<empty>,5,,50,2,,void
24532,BLOCK,-1,,"{
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  }",36,,55,2,,void
24551,BLOCK,-1,,"{
    End();
    return false;
  }",10,,59,1,,void
24559,BLOCK,-1,,"{
    End();
    return false;
  }",38,,66,2,,void
24570,BLOCK,-1,,"{
  ClientHello hello;

  // We need at least six bytes (one byte for kClientHello, three bytes for the
  // length of the handshake message, and two bytes for the protocol version).
  // If the client sent a frame that suggests a smaller ClientHello, give up.
  if (frame_len_ < 6) return End();

  // >= 5 + frame size bytes for frame parsing
  if (body_offset_ + frame_len_ > avail)
    return;

  // Check hello protocol version.  Protocol tuples that we know about:
  //
  // (3,1) TLS v1.0
  // (3,2) TLS v1.1
  // (3,3) TLS v1.2
  //
  // Note that TLS v1.3 uses a TLS v1.2 handshake so requires no specific
  // support here.
  if (data[body_offset_ + 4] != 0x03 ||
      data[body_offset_ + 5] < 0x01 ||
      data[body_offset_ + 5] > 0x03) {
    return End();
  }

  if (data[body_offset_] == kClientHello) {
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
  ...",72,,75,3,,void
24576,BLOCK,-1,,<empty>,23,,81,2,,void
24585,BLOCK,-1,,<empty>,5,,85,2,,void
24611,BLOCK,-1,,"{
    return End();
  }",38,,97,2,,void
24620,BLOCK,-1,,"{
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
    }

    // Check if we overflowed (do not reply with any private data)
    if (session_id_ == nullptr ||
        session_size_ > 32 ||
        session_id_ + session_size_ > data + avail) {
      return End();
    }
  }",43,,101,2,,void
24625,BLOCK,-1,,"{
      if (!ParseTLSClientHello(data, avail))
        return End();
    }",31,,102,2,,void
24631,BLOCK,-1,,<empty>,9,,104,2,,void
24635,BLOCK,-1,,"{
      // We couldn't get here, but whatever
      return End();
    }",12,,105,1,,void
24654,BLOCK,-1,,"{
      return End();
    }",53,,113,2,,void
24702,BLOCK,-1,,"{
  // NOTE: In case of anything we're just returning back, ignoring the problem.
  // That's because we're heavily relying on OpenSSL to solve any problem with
  // incoming data.
  switch (type) {
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data ...",52,,130,4,,void
24705,BLOCK,-1,,"{
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data + len;
      break;
    default:
      // Ignore
      break;
  }",17,,134,2,,void
24708,BLOCK,3,,"{
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }",7,,136,3,,void
24713,BLOCK,-1,,<empty>,11,,138,2,,void
24733,BLOCK,-1,,<empty>,11,,141,2,,void
24736,BLOCK,-1,,<empty>,9,,142,1,,void
24746,BLOCK,4,,"{
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }",66,,142,4,,void
24753,BLOCK,-1,,<empty>,13,,144,2,,void
24765,BLOCK,-1,,<empty>,13,,147,2,,void
24792,BLOCK,-1,,<empty>,13,,151,2,,void
24824,BLOCK,-1,,"{
  const uint8_t* body;

  // Skip frame header, hello header, protocol version and random data
  size_t session_offset = body_offset_ + 4 + 2 + 32;

  if (session_offset + 1 >= avail)
    return false;

  body = data + session_offset;
  session_size_ = *body;
  session_id_ = body + 1;

  size_t cipher_offset = session_offset + 1 + session_size_;

  // Session OOB failure
  if (cipher_offset + 1 >= avail)
    return false;

  uint16_t cipher_len =
      (data[cipher_offset] << 8) + data[cipher_offset + 1];
  size_t comp_offset = cipher_offset + 2 + cipher_len;

  // Cipher OOB failure
  if (comp_offset >= avail)
    return false;

  uint8_t comp_len = data[comp_offset];
  size_t extension_offset = comp_offset + 1 + comp_len;

  // Compression OOB failure
  if (extension_offset > avail)
    return false;

  // No extensions present
  if (extension_offset == avail)
    return true;

  size_t ext_off = extension_offset + 2;

  // Parse known extensions
  while (ext_off < avail) {
    ...",80,,169,3,,void
24842,BLOCK,-1,,<empty>,5,,176,2,,void
24873,BLOCK,-1,,<empty>,5,,186,2,,void
24902,BLOCK,-1,,<empty>,5,,194,2,,void
24923,BLOCK,-1,,<empty>,5,,201,2,,void
24930,BLOCK,-1,,<empty>,5,,205,2,,void
24943,BLOCK,-1,,"{
    // Extension OOB
    if (ext_off + 4 > avail)
      return false;

    uint16_t ext_type = (data[ext_off] << 8) + data[ext_off + 1];
    uint16_t ext_len = (data[ext_off + 2] << 8) + data[ext_off + 3];
    ext_off += 4;

    // Extension OOB
    if (ext_off + ext_len > avail)
      return false;

    ParseExtension(ext_type,
                   data + ext_off,
                   ext_len);

    ext_off += ext_len;
  }",27,,210,2,,void
24950,BLOCK,-1,,<empty>,7,,213,2,,void
24992,BLOCK,-1,,<empty>,7,,221,2,,void
25008,BLOCK,-1,,<empty>,5,,232,2,,void
25023,BLOCK,-1,,<empty>,1,,1,1,,ANY
25026,BLOCK,-1,,{ OPENSSL_free(value_str); },46,,999,1,,void
25076,BLOCK,-1,,<empty>,1,,1,1,,ANY
25104,BLOCK,-1,,"{
  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
      X509_STORE_CTX_new());
  X509Pointer result;
  X509* issuer;
  if (store_ctx.get() != nullptr &&
      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
    result.reset(issuer);
  }
  return result;
}",58,,54,3,,void
25149,BLOCK,-1,,"{
    result.reset(issuer);
  }",72,,62,2,,void
25164,BLOCK,-1,,"{
  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
  // All supported versions of TLS/SSL fix the client random to the same size.
  constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
  unsigned char crandom[kTlsClientRandomSize];

  if (keylog_cb == nullptr ||
      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
          kTlsClientRandomSize) {
    return;
  }

  std::string line = name;
  line += "" "" + StringBytes::hex_encode(reinterpret_cast<const char*>(crandom),
                                        kTlsClientRandomSize);
  line += "" "" + StringBytes::hex_encode(
      reinterpret_cast<const char*>(secret), secretlen);
  keylog_cb(ssl.get(), line.c_str());
}",23,,72,5,,void
25193,BLOCK,-1,,"{
    return;
  }",33,,80,2,,void
25238,BLOCK,-1,,"{
  const unsigned char* resp;
  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
  if (resp == nullptr)
    return default_value;

  Local<Value> ret;
  MaybeLocal<Object> maybe_buffer =
      Buffer::Copy(env, reinterpret_cast<const char*>(resp), len);

  if (!maybe_buffer.ToLocal(&ret))
    return MaybeLocal<Value>();

  return ret;
}",33,,95,4,,void
25251,BLOCK,-1,,<empty>,5,,99,2,,void
25282,BLOCK,-1,,<empty>,5,,106,2,,void
25292,BLOCK,-1,,"{
  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
}",39,,113,3,,void
25314,BLOCK,-1,,"{
  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
}",74,,117,3,,void
25327,BLOCK,-1,,"{  // NOLINT(runtime/int)
  long err = def;  // NOLINT(runtime/int)
  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  } else {
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }
  return err;
}",15,,123,3,,void
25333,BLOCK,-1,,<empty>,7,,125,1,,void
25342,BLOCK,-1,,"{
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  }",62,,125,2,,void
25353,BLOCK,-1,,"{
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }",10,,128,1,,void
25386,BLOCK,-1,,"{
      return X509_V_OK;
    }",42,,136,2,,void
25396,BLOCK,-1,,"{
  SSL_CTX* ctx = context->ctx().get();
  X509* x509 = SSL_CTX_get0_certificate(ctx);
  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
  STACK_OF(X509)* chain;

  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
  return err == 1;
}",66,,144,3,,void
25432,BLOCK,-1,,<empty>,17,,151,2,,void
25445,BLOCK,-1,,<empty>,17,,152,2,,void
25462,BLOCK,-1,,<empty>,37,,153,2,,void
25479,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_application_layer_protocol_negotiation,
          &buf,
          &rem) ||
      rem < 2) {
    return nullptr;
  }

  len = (buf[0] << 8) | buf[1];
  if (len + 2 != rem) return nullptr;
  return reinterpret_cast<const char*>(buf + 3);
}",55,,157,2,,void
25499,BLOCK,-1,,"{
    return nullptr;
  }",16,,167,2,,void
25519,BLOCK,-1,,<empty>,23,,172,2,,void
25532,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_server_name,
          &buf,
          &rem) || rem <= 2) {
    return nullptr;
  }

  len = (*buf << 8) | *(buf + 1);
  if (len + 2 != rem)
    return nullptr;
  rem = len;

  if (rem == 0 || *(buf + 2) != TLSEXT_NAMETYPE_host_name) return nullptr;
  rem--;
  if (rem <= 2)
    return nullptr;
  len = (*(buf + 3) << 8) | *(buf + 4);
  if (len + 2 > rem)
    return nullptr;
  return reinterpret_cast<const char*>(buf + 5);
}",61,,176,2,,void
25552,BLOCK,-1,,"{
    return nullptr;
  }",30,,185,2,,void
25572,BLOCK,-1,,<empty>,5,,191,2,,void
25589,BLOCK,-1,,<empty>,60,,194,2,,void
25598,BLOCK,-1,,<empty>,5,,197,2,,void
25620,BLOCK,-1,,<empty>,5,,200,2,,void
25633,BLOCK,-1,,"{
  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
}",37,,204,2,,void
25643,BLOCK,-1,,"{
  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
}",55,,208,3,,void
25660,BLOCK,-1,,"{  // NOLINT(runtime/int)
  const char* code = ""UNSPECIFIED"";
#define CASE_X509_ERR(CODE) case X509_V_ERR_##CODE: code = #CODE; break;
  switch (err) {
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIG...",37,,212,2,,void
25667,BLOCK,-1,,"{
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIGNED_CERT)
    CASE_X509_ERR(SELF_SIGNED_CERT_IN_CHAIN)
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
    CASE_X509_ERR(UNABLE_TO_VERIFY_LEAF_SI...",16,,215,2,,void
25669,BLOCK,1,,<empty>,,,,1,,void
25677,BLOCK,1,,<empty>,,,,1,,void
25685,BLOCK,1,,<empty>,,,,1,,void
25693,BLOCK,1,,<empty>,,,,1,,void
25701,BLOCK,1,,<empty>,,,,1,,void
25709,BLOCK,1,,<empty>,,,,1,,void
25717,BLOCK,1,,<empty>,,,,1,,void
25725,BLOCK,1,,<empty>,,,,1,,void
25733,BLOCK,1,,<empty>,,,,1,,void
25741,BLOCK,1,,<empty>,,,,1,,void
25749,BLOCK,1,,<empty>,,,,1,,void
25757,BLOCK,1,,<empty>,,,,1,,void
25765,BLOCK,1,,<empty>,,,,1,,void
25773,BLOCK,1,,<empty>,,,,1,,void
25781,BLOCK,1,,<empty>,,,,1,,void
25789,BLOCK,1,,<empty>,,,,1,,void
25797,BLOCK,1,,<empty>,,,,1,,void
25805,BLOCK,1,,<empty>,,,,1,,void
25813,BLOCK,1,,<empty>,,,,1,,void
25821,BLOCK,1,,<empty>,,,,1,,void
25829,BLOCK,1,,<empty>,,,,1,,void
25837,BLOCK,1,,<empty>,,,,1,,void
25845,BLOCK,1,,<empty>,,,,1,,void
25853,BLOCK,1,,<empty>,,,,1,,void
25861,BLOCK,1,,<empty>,,,,1,,void
25869,BLOCK,1,,<empty>,,,,1,,void
25877,BLOCK,1,,<empty>,,,,1,,void
25885,BLOCK,1,,<empty>,,,,1,,void
25899,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  const char* reason = X509_verify_cert_error_string(err);
  return OneByteString(env->isolate(), reason);
}",71,,251,3,,void
25904,BLOCK,-1,,<empty>,5,,253,2,,void
25928,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  return OneByteString(env->isolate(), X509ErrorCode(err));
}",69,,258,3,,void
25933,BLOCK,-1,,<empty>,5,,260,2,,void
25953,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return Undefined(env->isolate());

  MaybeLocal<Object> maybe_cert = X509ToObject(env, cert);
  return maybe_cert.FromMaybe<Value>(Local<Value>());
}",68,,264,3,,void
25967,BLOCK,-1,,<empty>,5,,268,2,,void
25996,BLOCK,-1,,"{
  BUF_MEM* mem;
  BIO_get_mem_ptr(bio.get(), &mem);
  MaybeLocal<String> ret =
      String::NewFromUtf8(
          env->isolate(),
          mem->data,
          NewStringType::kNormal,
          mem->length);
  CHECK_EQ(BIO_reset(bio.get()), 1);
  return ret.FromMaybe(Local<Value>());
}",65,,274,3,,void
26049,BLOCK,-1,,"{
  Local<Value> value;
  if (!maybe_value.ToLocal(&value))
    return false;

  // Undefined is ignored, but still considered successful
  if (value->IsUndefined())
    return true;

  return !target->Set(context, name, value).IsNothing();
}",32,,293,5,,void
26063,BLOCK,-1,,<empty>,5,,296,2,,void
26071,BLOCK,-1,,<empty>,5,,300,2,,void
26091,BLOCK,-1,,"{
  if (cipher == nullptr)
    return Undefined(env->isolate());

  return OneByteString(env->isolate(), getstr(cipher));
}",78,,306,3,,void
26096,BLOCK,-1,,<empty>,5,,308,2,,void
26131,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  cert->reset(sk_X509_delete(peer_certs.get(), 0));
  for (;;) {
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }
  return MaybeLocal<Object>(object);
}",29,,337,5,,void
26156,BLOCK,-1,,<empty>,3,,340,1,,void
26157,BLOCK,4,,"{
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }",12,,340,4,,void
26160,BLOCK,-1,,<empty>,5,,342,1,,void
26173,BLOCK,4,,"{
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }",57,,342,4,,void
26192,BLOCK,-1,,<empty>,9,,345,2,,void
26216,BLOCK,-1,,<empty>,9,,350,2,,void
26229,BLOCK,-1,,<empty>,9,,353,2,,void
26254,BLOCK,-1,,<empty>,7,,364,2,,void
26269,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }
  return MaybeLocal<Object>(issuer_chain);
}",29,,373,5,,void
26295,BLOCK,-1,,"{
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }",68,,375,2,,void
26311,BLOCK,-1,,<empty>,7,,378,2,,void
26338,BLOCK,-1,,<empty>,7,,383,2,,void
26351,BLOCK,-1,,<empty>,7,,386,2,,void
26367,BLOCK,-1,,<empty>,34,,393,2,,void
26389,BLOCK,-1,,"{
  unsigned int i;
  const char hex[] = ""0123456789ABCDEF"";

  for (i = 0; i < md_size; i++) {
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }

  DCHECK_GT(md_size, 0);
  fingerprint[(3 * (md_size - 1)) + 2] = '\0';
}",44,,404,4,,void
26396,BLOCK,-1,,<empty>,3,,408,1,,void
26405,BLOCK,4,,"{
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }",33,,408,4,,void
26464,BLOCK,-1,,"{
  const char* name = nid2string(nid);
  return name != nullptr ?
      MaybeLocal<Value>(OneByteString(env->isolate(), name)) :
      MaybeLocal<Value>(Undefined(env->isolate()));
}",65,,419,3,,void
26500,BLOCK,-1,,"{
  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
  if (pubkey == nullptr)
    return Undefined(env->isolate());

  return ECPointToBuffer(
      env,
      group,
      pubkey,
      EC_KEY_get_conv_form(ec.get()),
      nullptr).FromMaybe(Local<Object>());
}",26,,429,4,,void
26513,BLOCK,-1,,<empty>,5,,432,2,,void
26541,BLOCK,-1,,"{
  if (group == nullptr)
    return Undefined(env->isolate());

  int bits = EC_GROUP_order_bits(group);
  if (bits <= 0)
    return Undefined(env->isolate());

  return Integer::New(env->isolate(), bits);
}",26,,445,4,,void
26546,BLOCK,-1,,<empty>,5,,447,2,,void
26562,BLOCK,-1,,<empty>,5,,451,2,,void
26584,BLOCK,-1,,"{
  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
  CHECK_GE(size, 0);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",71,,456,3,,void
26604,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,461,5,,void
26681,BLOCK,-1,,"{
  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
  BIO_printf(bio.get(), ""0x%"" PRIx64, exponent_word);
  return ToV8Value(env, bio);
}",22,,476,4,,void
26699,BLOCK,-1,,"{
  return Integer::New(env->isolate(), BN_num_bits(n));
}",57,,482,3,,void
26717,BLOCK,-1,,"{
  BN_print(bio.get(), n);
  return ToV8Value(env, bio);
}",22,,489,4,,void
26733,BLOCK,-1,,"{
  int size = i2d_X509(cert, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_X509(cert, &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",71,,495,3,,void
26747,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,499,4,,void
26820,BLOCK,-1,,"{
  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }

  return Undefined(env->isolate());
}",65,,511,3,,void
26822,BLOCK,-1,,<empty>,7,,512,1,,void
26828,BLOCK,-1,,"{
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }",66,,512,2,,void
26836,BLOCK,-1,,"{
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }",13,,514,2,,void
26857,BLOCK,-1,,<empty>,16,,517,2,,void
26879,BLOCK,-1,,"{
  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
  if (eku) {
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }

  return Undefined(env->isolate());
}",61,,524,3,,void
26885,BLOCK,-1,,"{
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }",12,,527,2,,void
26903,BLOCK,-1,,<empty>,5,,533,1,,void
26913,BLOCK,4,,"{
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }",37,,533,4,,void
26928,BLOCK,-1,,"{
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }",68,,536,2,,void
26965,BLOCK,-1,,"{
  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
}",63,,548,3,,void
26979,BLOCK,-1,,"{
  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
}",66,,553,3,,void
26994,BLOCK,-1,,"{
  unsigned char md[EVP_MAX_MD_SIZE];
  unsigned int md_size;
  char fingerprint[EVP_MAX_MD_SIZE * 3];

  if (X509_digest(cert, method, md, &md_size)) {
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }
  return Undefined(env->isolate());
}",17,,560,4,,void
27005,BLOCK,-1,,"{
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }",48,,565,2,,void
27029,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
  return ToV8Value(env, bio);
}",28,,575,4,,void
27047,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
  return ToV8Value(env, bio);
}",28,,583,4,,void
27065,BLOCK,-1,,"{
  for (size_t i = 0; i < length; i++) {
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a c...",78,,588,4,,void
27067,BLOCK,-1,,<empty>,3,,589,1,,void
27077,BLOCK,4,,"{
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character....",39,,589,4,,void
27086,BLOCK,-1,,"{
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may n...",16,,591,2,,void
27100,BLOCK,-1,,"{
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      }",17,,606,2,,void
27111,BLOCK,-1,,"{
          return false;
        }",65,,610,2,,void
27115,BLOCK,-1,,"{
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may not be a signed type. Regardless, non-ASCII
        // values will always be outside of this range.
        if (c < ' ' || c > '~') {
          return false;
        }
      }",14,,613,1,,void
27124,BLOCK,-1,,"{
          return false;
        }",33,,617,2,,void
27137,BLOCK,-1,,"{
  if (IsSafeAltName(name, length, utf8)) {
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  } else {
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        //...",58,,628,6,,void
27143,BLOCK,-1,,"{
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  }",42,,629,2,,void
27148,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,632,2,,void
27164,BLOCK,-1,,"{
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the st...",10,,636,1,,void
27176,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,641,2,,void
27185,BLOCK,-1,,<empty>,5,,644,1,,void
27195,BLOCK,4,,"{
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      } else {
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex...",41,,644,4,,void
27208,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\\"", 2);
      }",22,,646,2,,void
27217,BLOCK,-1,,<empty>,14,,648,1,,void
27222,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\"""", 2);
      }",28,,648,2,,void
27231,BLOCK,-1,,<empty>,14,,650,1,,void
27250,BLOCK,-1,,"{
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      }",78,,650,2,,void
27260,BLOCK,-1,,"{
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex[c & 0x0f] };
        BIO_write(out.get(), u, sizeof(u));
      }",14,,658,1,,void
27306,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               false, safe_prefix);
}",74,,672,4,,void
27325,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               true, safe_prefix);
}",72,,679,4,,void
27343,BLOCK,-1,,"{
  if (gen->type == GEN_DNS) {
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_EMAIL) {
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_URI) {
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_DIRNAME) {
    // Earlier versions of Node.js used X509_N...",78,,686,3,,void
27350,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  }",29,,687,2,,void
27370,BLOCK,-1,,<empty>,10,,694,1,,void
27377,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  }",38,,694,2,,void
27397,BLOCK,-1,,<empty>,10,,698,1,,void
27404,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  }",36,,698,2,,void
27424,BLOCK,-1,,<empty>,10,,706,1,,void
27431,BLOCK,-1,,"{
    // Earlier versions of Node.js used X509_NAME_oneline to print the X509_NAME
    // object. The format was non standard and should be avoided. The use of
    // X509_NAME_oneline is discouraged by OpenSSL but was required for backward
    // compatibility. Conveniently, X509_NAME_oneline produced ASCII and the
    // output was unlikely to contains commas or other characters that would
    // require escaping. However, it SHOULD NOT produce ASCII output since an
    // RFC5280 AttributeValue may be a UTF8String.
    // Newer versions of Node.js have since switched to X509_NAME_print_ex to
    // produce a better format at the cost of backward compatibility. The new
    // format may contain Unicode characters and it is likely to contain commas,
    // which require escaping. Fortunately, the recently safeguarded function
    // PrintAltName handles all of that safely.
    BIO_printf(out.get(), ""DirName:"");
    BIOPointer tmp(BIO_new(BIO_s_mem()));
    CHECK(tmp);
    if (X509_...",40,,706,2,,void
27440,BLOCK,-1,,<empty>,,,,2,,<empty>
27460,BLOCK,-1,,"{
      return false;
    }",70,,725,2,,void
27496,BLOCK,-1,,<empty>,10,,733,1,,void
27503,BLOCK,-1,,"{
    BIO_printf(out.get(), ""IP Address:"");
    const ASN1_OCTET_STRING* ip = gen->d.ip;
    const unsigned char* b = ip->data;
    if (ip->length == 4) {
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    } else if (ip->length == 16) {
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    } else {
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }
  }",38,,733,2,,void
27530,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    }",26,,737,2,,void
27550,BLOCK,-1,,<empty>,12,,739,1,,void
27557,BLOCK,-1,,"{
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    }",34,,739,2,,void
27559,BLOCK,-1,,<empty>,7,,740,1,,void
27569,BLOCK,4,,"{
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }",44,,740,4,,void
27601,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }",12,,744,1,,void
27609,BLOCK,-1,,<empty>,10,,751,1,,void
27616,BLOCK,-1,,"{
    // Unlike OpenSSL's default implementation, never print the OID as text and
    // instead always print its numeric representation.
    char oline[256];
    OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
    BIO_printf(out.get(), ""Registered ID:%s"", oline);
  }",36,,751,2,,void
27636,BLOCK,-1,,<empty>,10,,757,1,,void
27643,BLOCK,-1,,"{
    // The format that is used here is based on OpenSSL's implementation of
    // GENERAL_NAME_print (as of OpenSSL 3.0.1). Earlier versions of Node.js
    // instead produced the same format as i2v_GENERAL_NAME, which was somewhat
    // awkward, especially when passed to translatePeerCertificate.
    bool unicode = true;
    const char* prefix = nullptr;
    // OpenSSL 1.1.1 does not support othername in GENERAL_NAME_print and may
    // not define these NIDs.
#if OPENSSL_VERSION_MAJOR >= 3
    int nid = OBJ_obj2nid(gen->d.otherName->type_id);
    switch (nid) {
      case NID_id_on_SmtpUTF8Mailbox:
        prefix = ""SmtpUTF8Mailbox"";
        break;
      case NID_XmppAddr:
        prefix = ""XmppAddr"";
        break;
      case NID_SRVName:
        prefix = ""SRVName"";
        unicode = false;
        break;
      case NID_ms_upn:
        prefix = ""UPN"";
        break;
      case NID_NAIRealm:
        prefix = ""NAIRealm"";
        break;
    }
#endif  // OPENSSL_VERSION_MAJOR >= ...",42,,757,2,,void
27681,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:<unsupported>"");
    }",53,,790,2,,void
27689,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:"");
      if (unicode) {
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      } else {
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }
    }",12,,792,1,,void
27698,BLOCK,-1,,"{
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      }",20,,794,2,,void
27714,BLOCK,-1,,"{
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }",14,,797,1,,void
27730,BLOCK,-1,,<empty>,10,,802,1,,void
27737,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""X400Name:<unsupported>"");
  }",37,,802,2,,void
27745,BLOCK,-1,,<empty>,10,,805,1,,void
27752,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""EdiPartyName:<unsupported>"");
  }",41,,805,2,,void
27760,BLOCK,-1,,"{
    // This is safe because X509V3_EXT_d2i would have returned nullptr in this
    // case already.
    UNREACHABLE();
  }",10,,808,1,,void
27769,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));

  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
  if (names == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }
  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);

  return ok;
}",78,,817,3,,void
27791,BLOCK,-1,,<empty>,5,,823,2,,void
27799,BLOCK,-1,,<empty>,3,,827,1,,void
27810,BLOCK,4,,"{
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }",56,,827,4,,void
27821,BLOCK,-1,,<empty>,7,,831,2,,void
27836,BLOCK,-1,,"{
      break;
    }",45,,833,2,,void
27848,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_info_access));

  AUTHORITY_INFO_ACCESS* descs =
      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
  if (descs == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }
  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);

#if OPENSSL_VERSION_MAJOR < 3
  BIO_write(out.get(), ""\n"", 1);
#endif

  return ok;
}",74,,842,3,,void
27870,BLOCK,-1,,<empty>,5,,849,2,,void
27878,BLOCK,-1,,<empty>,3,,853,1,,void
27889,BLOCK,4,,"{
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }",62,,853,4,,void
27900,BLOCK,-1,,<empty>,7,,857,2,,void
27932,BLOCK,-1,,"{
      break;
    }",56,,862,2,,void
27952,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509SubjectAltNamePrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,878,4,,void
27965,BLOCK,-1,,<empty>,5,,881,2,,void
27985,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",47,,886,2,,void
28012,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509InfoAccessPrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,897,4,,void
28025,BLOCK,-1,,<empty>,5,,900,2,,void
28045,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",43,,905,2,,void
28072,BLOCK,-1,,"{
  X509_NAME* issuer_name = X509_get_issuer_name(cert);
  if (X509_NAME_print_ex(
          bio.get(),
          issuer_name,
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,916,4,,void
28089,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,922,2,,void
28113,BLOCK,-1,,"{
  if (X509_NAME_print_ex(
          bio.get(),
          X509_get_subject_name(cert),
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,933,4,,void
28126,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,938,2,,void
28149,BLOCK,-1,,"{
  X509_NAME* name = get_name(cert);
  CHECK_NOT_NULL(name);

  int cnt = X509_NAME_entry_count(name);
  CHECK_GE(cnt, 0);

  Local<Object> result =
      Object::New(env->isolate(), Null(env->isolate()), nullptr, nullptr, 0);
  if (result.IsEmpty()) {
    return MaybeLocal<Value>();
  }

  for (int i = 0; i < cnt; i++) {
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int t...",74,,947,3,,void
28192,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",25,,956,2,,void
28196,BLOCK,-1,,<empty>,3,,960,1,,void
28206,BLOCK,4,,"{
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int type_nid = OBJ_obj2nid(type);
    char type_buf[80];
    const char* type_str;
    if (type_nid != NID_undef) {
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    } else {
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }

    Local<String> v8_name;
    if (...",33,,960,4,,void
28236,BLOCK,-1,,"{
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    }",32,,976,2,,void
28244,BLOCK,-1,,"{
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }",12,,979,1,,void
28275,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",75,,985,2,,void
28289,BLOCK,-1,,"{
      return Undefined(env->isolate());
    }",29,,996,2,,void
28328,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",35,,1006,2,,void
28348,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",73,,1016,2,,void
28352,BLOCK,-1,,<empty>,12,,1018,1,,void
28355,BLOCK,-1,,"{
      Local<Value> accum;
      if (!result->Get(env->context(), v8_name).ToLocal(&accum)) {
        return MaybeLocal<Value>();
      }
      if (!accum->IsArray()) {
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }
      Local<Array> array = accum.As<Array>();
      if (array->Set(env->context(), array->Length(), v8_value).IsNothing()) {
        return MaybeLocal<Value>();
      }
    }",26,,1018,2,,void
28377,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",66,,1020,2,,void
28386,BLOCK,-1,,"{
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }",30,,1023,2,,void
28414,BLOCK,-1,,"{
          return MaybeLocal<Value>();
        }",70,,1025,2,,void
28444,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",78,,1030,2,,void
28448,BLOCK,-1,,<empty>,12,,1033,1,,void
28463,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",76,,1033,2,,void
28473,BLOCK,-1,,"{
  return Get(env, SSL_get_current_cipher(ssl.get()));
}",64,,1043,3,,void
28487,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  const unsigned char* buf;
  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
  size_t count = len / 2;
  MaybeStackBuffer<Local<Value>, 16> ciphers(count);
  int j = 0;
  for (size_t n = 0; n < len; n += 2) {
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }
  Local<Array> ret = Array::New(env->isolate(), ciphers.out(), count);
  return scope.Escape(ret);
}",28,,1049,3,,void
28519,BLOCK,-1,,<empty>,3,,1056,1,,void
28530,BLOCK,4,,"{
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }",39,,1056,4,,void
28602,BLOCK,-1,,"{
      return MaybeLocal<Array>();
    }",46,,1071,2,,void
28641,BLOCK,-1,,"{
  if (SSL_get_current_cipher(ssl.get()) == nullptr)
    return MaybeLocal<Object>();
  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());

  if (!Set<Value>(env->context(),
                  info,
                  env->name_string(),
                  GetCurrentCipherValue<GetCipherName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->standard_name_string(),
                  GetCurrentCipherValue<GetCipherStandardName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->version_string(),
                  GetCurrentCipherValue<GetCipherVersion>(env, ssl))) {
    return MaybeLocal<Object>();
  }

  return scope.Escape(info);
}",75,,1081,3,,void
28650,BLOCK,-1,,<empty>,5,,1083,2,,void
28718,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",71,,1098,2,,void
28732,BLOCK,-1,,"{
  CHECK_EQ(SSL_is_server(ssl.get()), 0);
  EVP_PKEY* raw_key;

  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());
  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
    return scope.Escape(info);

  Local<Context> context = env->context();
  crypto::EVPKeyPointer key(raw_key);

  int kid = EVP_PKEY_id(key.get());
  int bits = EVP_PKEY_bits(key.get());
  switch (kid) {
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get...",77,,1105,3,,void
28770,BLOCK,-1,,<empty>,5,,1112,2,,void
28808,BLOCK,-1,,"{
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name...",16,,1119,2,,void
28842,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",53,,1125,2,,void
28852,BLOCK,11,,"{
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name)) ||
            !Set<Integer>(context,
                 info,
                 env->size_string(),
                 Integer::New(env->isolate(), bits))) {
          return MaybeLocal<Object>();
        }
      }",7,,1132,11,,void
28858,BLOCK,-1,,"{
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        }",33,,1134,2,,void
28880,BLOCK,-1,,"{
          curve_name = OBJ_nid2sn(kid);
        }",16,,1138,1,,void
28931,BLOCK,-1,,"{
          return MaybeLocal<Object>();
        }",55,,1152,2,,void
28949,BLOCK,-1,,"{
  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  len = EC_POINT_point2oct(group,
                           point,
                           form,
                           reinterpret_cast<unsigned char*>(bs->Data()),
                           bs->ByteLength(),
                           nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",56,,1166,6,,void
28964,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }",17,,1168,2,,void
28969,BLOCK,-1,,<empty>,27,,1169,2,,void
28983,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1174,5,,void
29022,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }",17,,1185,2,,void
29027,BLOCK,-1,,<empty>,27,,1186,2,,void
29076,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Local<Object> result;
  MaybeLocal<Object> maybe_cert;

  // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
  // contains the `peer_certificate`, but on server it doesn't.
  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return Undefined(env->isolate());

  // Short result requested.
  if (abbreviated) {
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }

  StackOfX509 peer_certs = CloneSSLCerts(std::move(cert), ssl_certs);
  if (peer_certs == nullptr)
    return Undefined(env->isolate());

  // First and main certificate.
  X509Pointer first_cert(sk_X509_value(peer_certs.get(), 0));
  CHECK(first_cert);
  maybe_cert = X509ToOb...",21,,1198,5,,void
29120,BLOCK,-1,,<empty>,5,,1208,2,,void
29129,BLOCK,-1,,"{
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }",20,,1211,2,,void
29167,BLOCK,-1,,<empty>,5,,1219,2,,void
29200,BLOCK,-1,,<empty>,5,,1226,2,,void
29233,BLOCK,-1,,<empty>,5,,1238,2,,void
29256,BLOCK,-1,,<empty>,5,,1249,2,,void
29284,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",27,,1256,2,,void
29294,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  Local<Context> context = env->context();
  Local<Object> info = Object::New(env->isolate());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // X509_check_ca() returns a range of values. Only 1 means ""is a CA""
  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
  if (!Set<Value>(context,
                  info,
                  env->subject_string(),
                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->issuer_string(),
                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->subjectaltname_string(),
                  GetSubjectAltNameString(env, bio, cert)) ||
      !Set<Value>(context,
                  info,
                  env->infoaccess_string(),
                  GetInfoAccessString(env, bio, cert)) ||
      !Set<B...",17,,1265,3,,void
29327,BLOCK,-1,,<empty>,,,,2,,<empty>
29407,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,1291,2,,void
29418,BLOCK,-1,,"{
    switch (EVP_PKEY_id(pkey.get())) {
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }
  }",13,,1298,2,,void
29425,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }",38,,1299,2,,void
29452,BLOCK,-1,,"{
    const BIGNUM* n;
    const BIGNUM* e;
    RSA_get0_key(rsa.get(), &n, &e, nullptr);
    if (!Set<Value>(context,
                    info,
                    env->modulus_string(),
                    GetModulusString(env, bio, n)) ||
        !Set<Value>(context, info, env->bits_string(), GetBits(env, n)) ||
        !Set<Value>(context,
                    info,
                    env->exponent_string(),
                    GetExponentString(env, bio, e)) ||
        !Set<Object>(context,
                     info,
                     env->pubkey_string(),
                     GetPubKey(env, rsa))) {
      return MaybeLocal<Object>();
    }
  }",12,,1309,2,,void
29515,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",44,,1325,2,,void
29519,BLOCK,-1,,<empty>,10,,1328,1,,void
29522,BLOCK,-1,,"{
    const EC_GROUP* group = EC_KEY_get0_group(ec.get());

    if (!Set<Value>(context,
                    info,
                    env->bits_string(),
                    GetECGroup(env, group, ec)) ||
        !Set<Value>(context,
                    info,
                    env->pubkey_string(),
                    GetECPubKey(env, group, ec))) {
      return MaybeLocal<Object>();
    }

    const int nid = EC_GROUP_get_curve_name(group);
    if (nid != 0) {
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    } else {
      // Unnamed curves can be described by their ...",18,,1328,2,,void
29557,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",51,,1338,2,,void
29569,BLOCK,-1,,"{
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    }",19,,1343,2,,void
29594,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",67,,1353,2,,void
29598,BLOCK,-1,,"{
      // Unnamed curves can be described by their mathematical properties,
      // but aren't used much (at all?) with X.509/TLS. Support later if needed.
    }",12,,1356,1,,void
29637,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",48,,1374,2,,void
29719,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",54,,1404,2,,void
29744,BLOCK,-1,,<empty>,1,,1,1,,ANY
29783,BLOCK,-1,,<empty>,1,,1,1,,ANY
29799,BLOCK,-1,,"{
  // Guaranteed thread-safe by standard, just don't use -fno-threadsafe-statics.
  static X509_STORE* store = NewRootCertStore();
  return store;
}",47,,56,1,,void
29811,BLOCK,-1,,"{
  if (v->IsString() || v->IsArrayBufferView()) {
    BIOPointer bio(BIO_new(BIO_s_secmem()));
    if (!bio) return nullptr;
    ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
    if (bsrc.size() > INT_MAX) return nullptr;
    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
    if (written < 0) return nullptr;
    if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
    return bio;
  }
  return nullptr;
}",54,,64,3,,void
29822,BLOCK,-1,,"{
    BIOPointer bio(BIO_new(BIO_s_secmem()));
    if (!bio) return nullptr;
    ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
    if (bsrc.size() > INT_MAX) return nullptr;
    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
    if (written < 0) return nullptr;
    if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
    return bio;
  }",48,,65,2,,void
29825,BLOCK,-1,,<empty>,,,,2,,<empty>
29831,BLOCK,-1,,<empty>,15,,67,2,,void
29850,BLOCK,-1,,<empty>,32,,69,2,,void
29873,BLOCK,-1,,<empty>,22,,71,2,,void
29885,BLOCK,-1,,<empty>,54,,72,2,,void
29901,BLOCK,-1,,"{
  // Just to ensure that `ERR_peek_last_error` below will return only errors
  // that we are interested in
  ERR_clear_error();

  X509Pointer x(
      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));

  if (!x)
    return 0;

  unsigned long err = 0;  // NOLINT(runtime/int)

  StackOfX509 extra_certs(sk_X509_new_null());
  if (!extra_certs)
    return 0;

  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
                                    nullptr,
                                    NoPasswordCallback,
                                    nullptr)}) {
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }

  // When the while loop ends, it's usually just EOF.
  err = ERR_peek_last_error();
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    ERR_clear_error();
  } else {
    // some real error
    return 0;
  }

  return SSL_CTX_use_certificat...",56,,151,5,,void
29916,BLOCK,-1,,<empty>,5,,160,2,,void
29929,BLOCK,-1,,<empty>,5,,166,2,,void
29933,BLOCK,-1,,"{
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }",48,,171,1,,void
29944,BLOCK,-1,,"{
      extra.release();
      continue;
    }",55,,172,2,,void
29965,BLOCK,-1,,"{
    ERR_clear_error();
  }",51,,183,2,,void
29968,BLOCK,-1,,"{
    // some real error
    return 0;
  }",10,,185,1,,void
29988,BLOCK,-1,,"{
  static std::vector<X509*> root_certs_vector;
  static Mutex root_certs_vector_mutex;
  Mutex::ScopedLock lock(root_certs_vector_mutex);

  if (root_certs_vector.empty() &&
      per_process::cli_options->ssl_openssl_cert_store == false) {
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }

  X509_STORE* store = X509_STORE_new();
  if (*system_cert_path != '\0') {
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }

  Mutex::ScopedLock cli_lock(node::pe...",32,,199,1,,void
30007,BLOCK,-1,,"{
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }",66,,205,2,,void
30009,BLOCK,-1,,<empty>,5,,206,1,,void
30020,BLOCK,4,,"{
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }",56,,206,4,,void
30058,BLOCK,-1,,"{
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }",34,,222,2,,void
30078,BLOCK,-1,,"{
    X509_STORE_set_default_paths(store);
  }",57,,229,2,,void
30082,BLOCK,-1,,"{
    for (X509* cert : root_certs_vector) {
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }
  }",10,,231,1,,void
30086,BLOCK,-1,,"{
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }",42,,232,3,,void
30098,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Value> result[arraysize(root_certs)];

  for (size_t i = 0; i < arraysize(root_certs); i++) {
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), result, arraysize(root_certs)));
}",67,,241,2,,void
30116,BLOCK,-1,,<empty>,3,,245,1,,void
30127,BLOCK,4,,"{
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }",54,,245,4,,void
30150,BLOCK,-1,,"{
      return;
    }",35,,249,2,,void
30175,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,258,3,,void
30187,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->secure_context_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""set...",23,,263,2,,void
30203,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""setDHParam"", SetDHParam);
    SetProtoMethod(isolate, tmpl, ""setMaxProto"", SetMaxProto);
    SetProtoMet...",23,,265,2,,void
30374,BLOCK,1,,<empty>,,,,5,,void
30391,BLOCK,1,,<empty>,,,,5,,void
30408,BLOCK,1,,<empty>,,,,5,,void
30425,BLOCK,1,,<empty>,,,,5,,void
30442,BLOCK,1,,<empty>,,,,5,,void
30504,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetConstructorFunction(context,
                         target,
                         ""SecureContext"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SetMethodNoSideEffect(
      context, target, ""getRootCertificates"", GetRootCertificates);
  // Exposed for testing purposes only.
  SetMethodNoSideEffect(context,
                        target,
                        ""isExtraRootCertsFileLoaded"",
                        IsExtraRootCertsFileLoaded);
}",72,,331,3,,void
30538,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(SetKey);
  registry->Register(SetCert);
  registry->Register(AddCACert);
  registry->Register(AddCRL);
  registry->Register(AddRootCerts);
  registry->Register(SetCipherSuites);
  registry->Register(SetCiphers);
  registry->Register(SetSigalgs);
  registry->Register(SetECDHCurve);
  registry->Register(SetDHParam);
  registry->Register(SetMaxProto);
  registry->Register(SetMinProto);
  registry->Register(GetMaxProto);
  registry->Register(GetMinProto);
  registry->Register(SetOptions);
  registry->Register(SetSessionIdContext);
  registry->Register(SetSessionTimeout);
  registry->Register(Close);
  registry->Register(LoadPKCS12);
  registry->Register(SetTicketKeys);
  registry->Register(EnableTicketKeyCallback);
  registry->Register(GetTicketKeys);
  registry->Register(GetCertificate<true>);
  registry->Register(GetCertificate<false>);

#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngineKey);
  registr...",42,,349,2,,void
30698,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return nullptr;
  }

  return new SecureContext(env, obj);
}",56,,388,2,,void
30723,BLOCK,-1,,"{
    return nullptr;
  }",56,,392,2,,void
30736,BLOCK,-1,,"{
  MakeWeak();
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
}",29,,400,3,,void
30749,BLOCK,-1,,"{
  if (ctx_ != nullptr) {
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }
  ctx_.reset();
  cert_.reset();
  issuer_.reset();
}",36,,405,1,,void
30754,BLOCK,-1,,"{
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }",24,,406,2,,void
30779,BLOCK,-1,,"{
  Reset();
}",33,,414,1,,void
30785,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new SecureContext(env, args.This());
}",66,,418,2,,void
30805,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_EQ(args.Length(), 3);
  CHECK(args[1]->IsInt32());
  CHECK(args[2]->IsInt32());

  int min_version = args[1].As<Int32>()->Value();
  int max_version = args[2].As<Int32>()->Value();
  const SSL_METHOD* method = TLS_method();

  if (max_version == 0)
    max_version = kMaxSupportedVersion;

  if (args[0]->IsString()) {
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmet...",67,,423,2,,void
30873,BLOCK,-1,,<empty>,5,,437,2,,void
30884,BLOCK,-1,,"{
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv3_method"" ||
               sslmethod == ""SSLv3_server_method"" ||
               sslmethod == ""SSLv3_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv23_method"") {
      max_version = TLS1_2_VERSION;
    } else if (sslmethod == ""SSLv23_server_method"") {
      max_version = TLS1_2_VERSION;
      method = TLS_server_method()...",28,,439,2,,void
30906,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    }",45,,448,2,,void
30912,BLOCK,-1,,<empty>,12,,451,1,,void
30925,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    }",52,,453,2,,void
30931,BLOCK,-1,,<empty>,12,,456,1,,void
30936,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
    }",46,,456,2,,void
30941,BLOCK,-1,,<empty>,12,,458,1,,void
30946,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",53,,458,2,,void
30954,BLOCK,-1,,<empty>,12,,461,1,,void
30959,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",53,,461,2,,void
30967,BLOCK,-1,,<empty>,12,,464,1,,void
30972,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
    }",43,,464,2,,void
30980,BLOCK,-1,,<empty>,12,,467,1,,void
30985,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_server_method();
    }",50,,467,2,,void
30996,BLOCK,-1,,<empty>,12,,471,1,,void
31001,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_client_method();
    }",50,,471,2,,void
31012,BLOCK,-1,,<empty>,12,,475,1,,void
31017,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
    }",45,,475,2,,void
31025,BLOCK,-1,,<empty>,12,,478,1,,void
31030,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_server_method();
    }",52,,478,2,,void
31041,BLOCK,-1,,<empty>,12,,482,1,,void
31046,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_client_method();
    }",52,,482,2,,void
31057,BLOCK,-1,,<empty>,12,,486,1,,void
31062,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
    }",47,,486,2,,void
31070,BLOCK,-1,,<empty>,12,,489,1,,void
31075,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_server_method();
    }",54,,489,2,,void
31086,BLOCK,-1,,<empty>,12,,493,1,,void
31091,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_client_method();
    }",54,,493,2,,void
31102,BLOCK,-1,,<empty>,12,,497,1,,void
31107,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
    }",47,,497,2,,void
31115,BLOCK,-1,,<empty>,12,,500,1,,void
31120,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",54,,500,2,,void
31131,BLOCK,-1,,<empty>,12,,504,1,,void
31136,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",54,,504,2,,void
31147,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(
          env, ""Unknown method: %s"", *sslmethod);
      return;
    }",12,,508,1,,void
31167,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",18,,516,2,,void
31271,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error generating ticket keys"");
  }",74,,551,2,,void
31287,BLOCK,-1,,"{
  return SSLPointer(SSL_new(ctx_.get()));
}",39,,558,1,,void
31299,BLOCK,-1,,"{
  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
}",60,,562,2,,void
31310,BLOCK,-1,,"{
  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
}",60,,566,2,,void
31321,BLOCK,-1,,"{
  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
}",72,,570,2,,void
31332,BLOCK,-1,,"{
  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
}",52,,574,2,,void
31344,BLOCK,-1,,"{
  if (key->GetKeyType() != KeyType::kKeyTypePrivate) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  ClearErrorOnReturn clear_error_on_return;
  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }

  return Just(true);
}",71,,579,3,,void
31354,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",54,,580,2,,void
31374,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }",75,,586,2,,void
31388,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Private key argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return;

  ByteSource passphrase;
  if (args[1]->IsString())
    passphrase = ByteSource::FromString(env, args[1].As<String>());
  // This redirection is necessary because the PasswordCallback expects a
  // pointer to a pointer to the passphrase ByteSource to allow passing in
  // const ByteSources.
  const ByteSource* pass_ptr = &passphrase;

  EVPKeyPointer key(
      PEM_read_bio_PrivateKey(bio.get(),
                              nullptr,
                              PasswordCallback,
                              &pass_ptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""PEM_read_bio_PrivateKey"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX...",69,,594,2,,void
31421,BLOCK,-1,,<empty>,5,,604,2,,void
31431,BLOCK,-1,,<empty>,5,,608,2,,void
31464,BLOCK,-1,,<empty>,5,,621,2,,void
31483,BLOCK,-1,,<empty>,5,,624,2,,void
31493,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sigalgs(env->isolate(), args[0]);

  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
    return ThrowCryptoError(env, ERR_get_error());
}",73,,627,2,,void
31543,BLOCK,-1,,<empty>,5,,639,2,,void
31552,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 2);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  Utf8Value engine_id(env->isolate(), args[1]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  if (!ENGINE_init(engine.get())) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }

  engine.finish_on_exit = true;

  Utf8Value key_name(env->isolate(), args[0]);
  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
     ...",75,,643,2,,void
31584,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,651,2,,void
31610,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,661,2,,void
31627,BLOCK,-1,,<empty>,7,,664,2,,void
31644,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }",35,,668,2,,void
31677,BLOCK,-1,,<empty>,5,,680,2,,void
31696,BLOCK,-1,,<empty>,5,,683,2,,void
31716,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);
  cert_.reset();
  issuer_.reset();

  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
  // the method implemented elsewhere in this file. The naming is a bit
  // confusing, unfortunately.
  if (SSL_CTX_use_certificate_chain(
          ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }
  return Just(true);
}",72,,689,3,,void
31721,BLOCK,-1,,<empty>,13,,691,2,,void
31750,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }",63,,699,2,,void
31764,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->AddCert(env, std::move(bio)));
}",70,,706,2,,void
31809,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return;
  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }
}",54,,718,2,,void
31814,BLOCK,-1,,<empty>,13,,720,2,,void
31825,BLOCK,-1,,"{
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }",65,,723,1,,void
31830,BLOCK,-1,,"{
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }",51,,724,2,,void
31863,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  sc->SetCACert(bio);
}",72,,733,2,,void
31903,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);

  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));

  if (!crl) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }

  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  if (cert_store == GetOrCreateRootCertStore()) {
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }

  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
  CHECK_EQ(1,
           X509_STORE_set_flags(
               cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
  return Just(true);
}",76,,745,3,,void
31908,BLOCK,-1,,<empty>,13,,747,2,,void
31930,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }",13,,752,2,,void
31948,BLOCK,-1,,"{
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }",49,,758,2,,void
31980,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CRL argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->SetCRL(env, bio));
}",69,,770,2,,void
32020,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  auto store = GetOrCreateRootCertStore();

  // Increment reference count so global store is not deleted along with CTX.
  X509_STORE_up_ref(store);
  SSL_CTX_set_cert_store(ctx_.get(), store);
}",36,,782,1,,void
32038,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->SetRootCerts();
}",75,,791,2,,void
32055,BLOCK,-1,,"{
  // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
#ifndef OPENSSL_IS_BORINGSSL
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
    return ThrowCryptoError(env, ERR_get_error(), ""Failed to set ciphers"");
#endif
}",78,,797,2,,void
32105,BLOCK,-1,,<empty>,5,,810,2,,void
32115,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }
}",73,,814,2,,void
32165,BLOCK,-1,,"{
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }",59,,824,2,,void
32181,BLOCK,-1,,"{
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }",80,,827,2,,void
32192,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
  CHECK(args[0]->IsString());

  Utf8Value curve(env->isolate(), args[0]);

  if (curve != ""auto"" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }
}",75,,838,2,,void
32245,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }",77,,848,2,,void
32254,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_GE(args.Length(), 1);  // DH argument is mandatory

  // If the user specified ""auto"" for dhparams, the JavaScript layer will pass
  // true to this function instead of the original string. Any other string
  // value will be interpreted as custom DH parameters below.
  if (args[0]->IsTrue()) {
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }

  DHPointer dh;
  {
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }

  // Invalid dhparam is silently discarded and DHE is no longer used.
  // TODO(tniessen): don't silently discard invalid dhparam.
  if (!dh)
    return;

  const BIGNUM* p;
  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
  const int size = BN_num_bits(p);
  if (size < 1024) {
    return THROW_ERR_INVALID...",73,,853,2,,void
32284,BLOCK,-1,,"{
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }",26,,864,2,,void
32296,BLOCK,9,,"{
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }",3,,870,9,,void
32307,BLOCK,-1,,<empty>,7,,873,2,,void
32324,BLOCK,-1,,<empty>,5,,881,2,,void
32345,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(
        env, ""DH parameter is less than 1024 bits"");
  }",20,,886,2,,void
32351,BLOCK,-1,,<empty>,10,,889,1,,void
32356,BLOCK,-1,,"{
    args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(
        env->isolate(), ""DH parameter is less than 2048 bits""));
  }",27,,889,2,,void
32383,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error setting temp DH parameter"");
  }",54,,894,2,,void
32392,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
}",74,,900,2,,void
32439,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
}",74,,912,2,,void
32486,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_min_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,924,2,,void
32525,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_max_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,935,2,,void
32564,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsNumber());

  int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);

  SSL_CTX_set_options(sc->ctx_.get(),
                      static_cast<long>(val));  // NOLINT(runtime/int)
}",73,,946,2,,void
32625,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sessionIdContext(env->isolate(), args[0]);
  const unsigned char* sid_ctx =
      reinterpret_cast<const unsigned char*>(*sessionIdContext);
  unsigned int sid_ctx_len = sessionIdContext.length();

  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
    return;

  BUF_MEM* mem;
  Local<String> message;

  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) {
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  } else {
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }

  env->isolate()->ThrowException(Exception::TypeError(message));
}",46,,961,2,,void
32689,BLOCK,-1,,<empty>,5,,975,2,,void
32699,BLOCK,-1,,<empty>,,,,2,,<empty>
32705,BLOCK,-1,,"{
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  }",13,,981,2,,void
32715,BLOCK,-1,,"{
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }",10,,984,1,,void
32757,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int32_t sessionTimeout = args[0].As<Int32>()->Value();
  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
}",80,,993,2,,void
32803,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->Reset();
}",68,,1004,2,,void
32820,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<char> pass;
  bool ret = false;

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  ClearErrorOnReturn clear_error_on_return;

  if (args.Length() < 1) {
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }

  BIOPointer in(LoadBIO(env, args[0]));
  if (!in) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }

  if (args.Length() >= 2) {
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }

  // Free previous certs
  sc->issuer_.reset();
  sc->cert_.reset();

  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());

  DeleteFnPtr<PKCS12, PKCS12_free> p12;
  EVPKeyPointer pkey;
  X509Pointer ...",73,,1011,2,,void
32850,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }",26,,1021,2,,void
32865,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }",12,,1026,2,,void
32877,BLOCK,-1,,"{
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }",27,,1031,2,,void
33063,BLOCK,-1,,"{
    // Add CA certs too
    for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }
    ret = true;
  }",59,,1068,2,,void
33065,BLOCK,-1,,<empty>,5,,1070,1,,void
33079,BLOCK,4,,"{
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }",62,,1070,4,,void
33093,BLOCK,-1,,"{
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }",53,,1073,2,,void
33122,BLOCK,-1,,"{
    // TODO(@jasnell): Should this use ThrowCryptoError?
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    const char* str = ERR_reason_error_string(err);
    str = str != nullptr ? str : ""Unknown error"";

    return env->ThrowError(str);
  }",13,,1083,2,,void
33150,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // SSL_CTX_set_client_cert_engine does not itself support multiple
  // calls by cleaning up before overwriting the client_cert_engine
  // internal context variable.
  // Instead of trying to fix up this problem we in turn also do not
  // support multiple calls to SetClientCertEngine.
  CHECK(!sc->client_cert_engine_provided_);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  const Utf8Value engine_id(env->isolate(), args[0]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Valu...",46,,1095,2,,void
33195,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,1112,2,,void
33221,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,1122,2,,void
33238,BLOCK,-1,,<empty>,7,,1125,2,,void
33261,BLOCK,-1,,<empty>,5,,1131,2,,void
33275,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> buff;
  if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
    return;

  memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);
  memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);
  memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);

  args.GetReturnValue().Set(buff);
}",76,,1136,2,,void
33305,BLOCK,-1,,<empty>,5,,1142,2,,void
33353,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<char> buf(args[0].As<ArrayBufferView>());

  CHECK_EQ(buf.length(), 48);

  memcpy(wrap->ticket_key_name_, buf.data(), 16);
  memcpy(wrap->ticket_key_hmac_, buf.data() + 16, 16);
  memcpy(wrap->ticket_key_aes_, buf.data() + 32, 16);

  args.GetReturnValue().Set(true);
}",76,,1151,2,,void
33432,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
}",46,,1171,2,,void
33458,BLOCK,-1,,"{
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env->isolate(),
          sc->object(),
          env->ticketkeycallback_string(),
          arraysize(argv),
          argv,
          {0, 0}).ToLocal(&ret) ||
      !ret->IsArray()) {
    return -1;
  }
  Local<Array> arr = ret.As<Array>();

  Local<Value> val;
  if (!arr->Get(env->context(), kTicketKeyReturnIndex).ToL...",47,,1183,7,,void
33533,BLOCK,-1,,"{
    return -1;
  }",47,,1202,2,,void
33592,BLOCK,-1,,"{
    return -1;
  }",24,,1216,2,,void
33633,BLOCK,-1,,"{
    return -1;
  }",24,,1223,2,,void
33651,BLOCK,-1,,<empty>,5,,1229,2,,void
33704,BLOCK,-1,,"{
    return -1;
  }",47,,1236,2,,void
33710,BLOCK,-1,,"{
    Local<Value> name_val;
    Local<Value> iv_val;
    if (!arr->Get(env->context(), kTicketKeyNameIndex).ToLocal(&name_val) ||
        !arr->Get(env->context(), kTicketKeyIVIndex).ToLocal(&iv_val) ||
        Buffer::Length(name_val) != kTicketPartSize ||
        Buffer::Length(iv_val) != kTicketPartSize) {
      return -1;
    }

    name_val.As<ArrayBufferView>()->CopyContents(name, kTicketPartSize);
    iv_val.As<ArrayBufferView>()->CopyContents(iv, kTicketPartSize);
  }",12,,1240,2,,void
33769,BLOCK,-1,,"{
      return -1;
    }",52,,1246,2,,void
33814,BLOCK,-1,,"{
    EVP_EncryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",12,,1262,2,,void
33825,BLOCK,-1,,"{
    EVP_DecryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",10,,1268,1,,void
33846,BLOCK,-1,,"{
  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  if (enc) {
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }

  if (memcmp(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_)) != 0) {
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }

  if (EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
                         iv) <= 0 ||
      HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
                   EVP_sha256(), nullptr) <= 0) {
    return -1;
  }
  retur...",57,,1284,7,,void
33857,BLOCK,-1,,"{
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }",12,,1288,2,,void
33899,BLOCK,-1,,"{
      return -1;
    }",37,,1297,2,,void
33917,BLOCK,-1,,"{
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }",78,,1303,2,,void
33945,BLOCK,-1,,"{
    return -1;
  }",49,,1311,2,,void
33955,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, info.This());
  Local<External> ext = External::New(info.GetIsolate(), sc->ctx_.get());
  info.GetReturnValue().Set(ext);
}",72,,1317,2,,void
33996,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  X509* cert;

  if (primary)
    cert = wrap->cert_.get();
  else
    cert = wrap->issuer_.get();
  if (cert == nullptr)
    return args.GetReturnValue().SetNull();

  int size = i2d_X509(cert, nullptr);
  Local<Object> buff;
  if (!Buffer::New(env, size).ToLocal(&buff))
    return;
  unsigned char* serialized = reinterpret_cast<unsigned char*>(
      Buffer::Data(buff));
  i2d_X509(cert, &serialized);

  args.GetReturnValue().Set(buff);
}",77,,1325,2,,void
34015,BLOCK,-1,,<empty>,5,,1332,2,,void
34025,BLOCK,-1,,<empty>,5,,1334,1,,void
34038,BLOCK,-1,,<empty>,5,,1336,2,,void
34071,BLOCK,-1,,<empty>,5,,1341,2,,void
34101,BLOCK,-1,,"{
  ERR_clear_error();
  MarkPopErrorOnReturn mark_pop_error_on_return;

  BIOPointer bio(BIO_new_file(file, ""r""));
  if (!bio)
    return ERR_get_error();

  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    X509_STORE_add_cert(store, x509.get());
  }

  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
  // Ignore error if its EOF/no start line found.
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    return 0;
  }

  return err;
}",23,,1352,3,,void
34112,BLOCK,-1,,<empty>,5,,1358,2,,void
34116,BLOCK,-1,,"{
    X509_STORE_add_cert(store, x509.get());
  }",65,,1361,1,,void
34137,BLOCK,-1,,"{
    return 0;
  }",51,,1368,2,,void
34146,BLOCK,-1,,"{
  if (file.empty()) return;
  ClearErrorOnReturn clear_error_on_return;
  X509_STORE* store = GetOrCreateRootCertStore();
  if (auto err = AddCertsFromFile(store, file.c_str())) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  } else {
    extra_root_certs_loaded = true;
  }
}",47,,1377,2,,void
34152,BLOCK,-1,,<empty>,21,,1378,2,,void
34160,BLOCK,-1,,<empty>,7,,1381,1,,void
34170,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  }",57,,1381,2,,void
34186,BLOCK,-1,,"{
    extra_root_certs_loaded = true;
  }",10,,1388,1,,void
34194,BLOCK,-1,,"{
  return args.GetReturnValue().Set(extra_root_certs_loaded);
}",46,,1395,2,,void
34222,BLOCK,-1,,<empty>,1,,1,1,,ANY
34227,BLOCK,-1,,"{
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> verify_error_getter_templ =
        FunctionTemplate::New(isolate,
                              DiffieHellman::VerifyErrorGetter,
                   ...",66,,64,3,,void
34354,BLOCK,-1,,"{
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }",52,,355,2,,void
34369,BLOCK,-1,,"{
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }",52,,363,2,,void
34384,BLOCK,-1,,"{
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }",52,,371,2,,void
34398,BLOCK,-1,,"{
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }",52,,379,2,,void
34413,BLOCK,-1,,"{ return DH_set0_key(dh, num, nullptr); }",34,,461,3,,void
34425,BLOCK,-1,,"{ return DH_set0_key(dh, nullptr, num); }",34,,467,3,,void
34454,BLOCK,-1,,<empty>,1,,1,1,,ANY
34462,BLOCK,-1,,"{
  // DH_size returns number of bytes in a prime number.
  // DH_compute_key returns number of bytes in a remainder of exponent, which
  // may have less bytes than a prime number. Therefore add 0-padding to the
  // allocated buffer.
  const size_t prime_size = length;
  if (remainder_size != prime_size) {
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }
}",48,,41,4,,void
34471,BLOCK,-1,,"{
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }",37,,47,2,,void
34496,BLOCK,-1,,"{
  MakeWeak();
}",46,,57,3,,void
34501,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  auto make = [&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> ver...",72,,61,3,,void
34567,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(DiffieHellmanGroup);

  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPrime);
  registry->Register(GetGenerator);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);

  registry->Register(DiffieHellman::VerifyErrorGetter);
  registry->Register(DiffieHellman::Stateless);

  DHKeyPairGenJob::RegisterExternalReferences(registry);
  DHKeyExportJob::RegisterExternalReferences(registry);
  DHBitsJob::RegisterExternalReferences(registry);
}",42,,112,2,,void
34652,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
    return false;
  return VerifyContext();
}",50,,133,3,,void
34668,BLOCK,-1,,<empty>,5,,136,2,,void
34677,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dh"", dh_ ? kSizeOf_DH : 0);
}",62,,140,2,,void
34692,BLOCK,-1,,"{
  dh_.reset(DH_new());
  CHECK_GE(g, 2);
  BignumPointer bn_g(BN_new());
  return bn_g && BN_set_word(bn_g.get(), g) &&
         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
         VerifyContext();
}",55,,144,3,,void
34736,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g <= 1) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  BIGNUM* bn_g = BN_new();
  if (!BN_set_word(bn_g, g) ||
      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",59,,153,4,,void
34746,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,155,2,,void
34752,BLOCK,1,,<empty>,,,,1,,void
34755,BLOCK,1,,<empty>,,,,1,,void
34763,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",15,,160,2,,void
34769,BLOCK,1,,<empty>,,,,1,,void
34772,BLOCK,1,,<empty>,,,,1,,void
34804,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,169,2,,void
34820,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g_len <= 0) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_g =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",78,,177,5,,void
34830,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,179,2,,void
34836,BLOCK,1,,<empty>,,,,1,,void
34839,BLOCK,1,,<empty>,,,,1,,void
34847,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",19,,184,2,,void
34853,BLOCK,1,,<empty>,,,,1,,void
34856,BLOCK,1,,<empty>,,,,1,,void
34875,BLOCK,-1,,"{
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",44,,191,2,,void
34883,BLOCK,1,,<empty>,,,,1,,void
34886,BLOCK,1,,<empty>,,,,1,,void
34909,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,199,2,,void
34925,BLOCK,-1,,"{
  return BignumPointer(p(nullptr));
}",46,,210,1,,void
34933,BLOCK,-1,,<empty>,,,,1,,<empty>
34938,BLOCK,-1,,"{
#define V(n, p)                                                                \
  if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
  V(""modp1"", BN_get_rfc2409_prime_768);
  V(""modp2"", BN_get_rfc2409_prime_1024);
  V(""modp5"", BN_get_rfc3526_prime_1536);
  V(""modp14"", BN_get_rfc3526_prime_2048);
  V(""modp15"", BN_get_rfc3526_prime_3072);
  V(""modp16"", BN_get_rfc3526_prime_4096);
  V(""modp17"", BN_get_rfc3526_prime_6144);
  V(""modp18"", BN_get_rfc3526_prime_8192);
#undef V
  return nullptr;
}",79,,218,2,,void
34941,BLOCK,1,,<empty>,,,,2,,void
34946,BLOCK,-1,,<empty>,3,,221,2,,void
34951,BLOCK,1,,<empty>,,,,2,,void
34956,BLOCK,-1,,<empty>,3,,222,2,,void
34961,BLOCK,1,,<empty>,,,,2,,void
34966,BLOCK,-1,,<empty>,3,,223,2,,void
34971,BLOCK,1,,<empty>,,,,2,,void
34976,BLOCK,-1,,<empty>,3,,224,2,,void
34981,BLOCK,1,,<empty>,,,,2,,void
34986,BLOCK,-1,,<empty>,3,,225,2,,void
34991,BLOCK,1,,<empty>,,,,2,,void
34996,BLOCK,-1,,<empty>,3,,226,2,,void
35001,BLOCK,1,,<empty>,,,,2,,void
35006,BLOCK,-1,,<empty>,3,,227,2,,void
35011,BLOCK,1,,<empty>,,,,2,,void
35016,BLOCK,-1,,<empty>,3,,228,2,,void
35025,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman = new DiffieHellman(env, args.This());

  CHECK_EQ(args.Length(), 1);
  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""Group name"");

  bool initialized = false;

  const node::Utf8Value group_name(env->isolate(), args[0]);
  auto group = FindDiffieHellmanGroup(*group_name);
  if (group == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);

  initialized = diffieHellman->Init(group(), kStandardizedGenerator);
  if (!initialized)
    THROW_ERR_CRYPTO_INITIALIZATION_FAILED(env);
}",46,,234,2,,void
35079,BLOCK,-1,,<empty>,5,,246,2,,void
35094,BLOCK,-1,,<empty>,5,,250,2,,void
35101,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman =
      new DiffieHellman(env, args.This());
  bool initialized = false;

  if (args.Length() == 2) {
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized ...",66,,254,2,,void
35131,BLOCK,-1,,"{
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }
  }",27,,260,2,,void
35139,BLOCK,-1,,"{
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    }",29,,261,2,,void
35147,BLOCK,-1,,"{
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }",31,,262,2,,void
35173,BLOCK,-1,,"{
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }",12,,266,1,,void
35186,BLOCK,-1,,<empty>,9,,269,2,,void
35198,BLOCK,-1,,"{
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      }",31,,270,2,,void
35223,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }",14,,274,1,,void
35236,BLOCK,-1,,<empty>,11,,277,2,,void
35266,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Initialization failed"");
  }",21,,284,2,,void
35276,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  if (!DH_generate_key(diffieHellman->dh_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }

  const BIGNUM* pub_key;
  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(pub_key,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue()....",75,,290,2,,void
35302,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }",51,,296,2,,void
35326,BLOCK,9,,"{
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,304,9,,void
35413,BLOCK,-1,,<empty>,68,,318,2,,void
35429,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());

  const BIGNUM* num = get_field(dh->dh_.get());
  if (num == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env, err_if_null);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(num,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",55,,325,4,,void
35460,BLOCK,-1,,<empty>,5,,333,2,,void
35472,BLOCK,9,,"{
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,336,9,,void
35559,BLOCK,-1,,<empty>,68,,350,2,,void
35573,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }, ""p is null"");
}",71,,354,2,,void
35582,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }, ""g is null"");
}",75,,362,2,,void
35591,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }, ""No public key - did you forget to generate one?"");
}",75,,370,2,,void
35600,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }, ""No private key - did you forget to generate one?"");
}",76,,378,2,,void
35609,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
  if (UNLIKELY(!key_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""secret is too big"");
  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }

  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                            key.get(),
                            diffieHellman->dh_.get());

  if (size == -1) {
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
            ...",76,,386,2,,void
35645,BLOCK,-1,,<empty>,5,,397,2,,void
35669,BLOCK,13,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }",3,,401,13,,void
35718,BLOCK,-1,,"{
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
                               key.get(),
                               &checkResult);

    if (!checked) {
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    } else if (checkResult) {
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }

    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  }",19,,411,2,,void
35739,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    }",19,,419,2,,void
35746,BLOCK,-1,,<empty>,12,,421,1,,void
35749,BLOCK,-1,,"{
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }",29,,421,2,,void
35754,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      }",52,,422,2,,void
35760,BLOCK,-1,,<empty>,14,,425,1,,void
35765,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }",59,,425,2,,void
35830,BLOCK,-1,,<empty>,68,,441,2,,void
35846,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buf is too big"");
  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
  CHECK_NOT_NULL(num);
  CHECK_EQ(1, set_field(dh->dh_.get(), num));
}",78,,446,4,,void
35881,BLOCK,-1,,<empty>,5,,453,2,,void
35915,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
         ""Public key"");
}",75,,459,2,,void
35924,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
         ""Private key"");
}",76,,465,2,,void
35933,BLOCK,-1,,"{
  HandleScope scope(args.GetIsolate());

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  args.GetReturnValue().Set(diffieHellman->verifyError_);
}",80,,471,2,,void
35961,BLOCK,-1,,"{
  int codes;
  if (!DH_check(dh_.get(), &codes))
    return false;
  verifyError_ = codes;
  return true;
}",37,,480,1,,void
35972,BLOCK,-1,,<empty>,5,,483,2,,void
35987,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[*offset]->IsString()) {
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  } else {
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nu...",33,,506,5,,void
36004,BLOCK,-1,,"{
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  }",34,,509,2,,void
36025,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }",27,,512,2,,void
36049,BLOCK,-1,,"{
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }

    CHECK(args[*offset + 1]->IsInt32());
    params->params.generator = args[*offset + 1].As<Int32>()->Value();
    *offset += 2;
  }",10,,520,1,,void
36058,BLOCK,-1,,"{
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    }",35,,521,2,,void
36076,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }",21,,523,2,,void
36090,BLOCK,-1,,"{
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }",12,,528,1,,void
36104,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }",46,,530,2,,void
36166,BLOCK,-1,,"{
  EVPKeyPointer key_params;
  if (BignumPointer* prime_fixed_value =
          std::get_if<BignumPointer>(&params->params.prime)) {
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
         ...",68,,546,2,,void
36169,BLOCK,-1,,<empty>,7,,548,1,,void
36185,BLOCK,-1,,"{
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  }",62,,549,2,,void
36192,BLOCK,-1,,<empty>,7,,552,2,,void
36230,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",61,,557,2,,void
36259,BLOCK,-1,,<empty>,10,,567,1,,void
36261,BLOCK,-1,,<empty>,14,,567,1,,void
36275,BLOCK,-1,,"{
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
            *prime_size) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_generator(
            param_ctx.get(),
            params->params.generator) <= 0 ||
        EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
      return EVPKeyCtxPointer();
    }

    key_params = EVPKeyPointer(raw_params);
  }",73,,567,2,,void
36329,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",63,,578,2,,void
36337,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,583,1,,void
36358,BLOCK,-1,,<empty>,5,,589,2,,void
36369,BLOCK,-1,,"{
  return Just(true);
}",32,,597,4,,void
36380,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,605,5,,void
36389,BLOCK,-1,,"{
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,608,2,,void
36399,BLOCK,-1,,<empty>,9,,611,2,,void
36420,BLOCK,-1,,<empty>,9,,615,2,,void
36440,BLOCK,-1,,"{
  size_t out_size;

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
  if (!ctx ||
      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
    return ByteSource();

  ByteSource::Builder out(out_size);
  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
    return ByteSource();
  }

  ZeroPadDiffieHellmanSecret(out_size, out.data<char>(), out.size());
  return std::move(out).release();
}",38,,625,3,,void
36484,BLOCK,-1,,<empty>,5,,633,2,,void
36504,BLOCK,-1,,"{
    return ByteSource();
  }",78,,636,2,,void
36530,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject() && args[1]->IsObject());
  KeyObjectHandle* our_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&our_key_object, args[0].As<Object>());
  CHECK_EQ(our_key_object->Data()->GetKeyType(), kKeyTypePrivate);
  KeyObjectHandle* their_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&their_key_object, args[1].As<Object>());
  CHECK_NE(their_key_object->Data()->GetKeyType(), kKeyTypeSecret);

  ManagedEVPPKey our_key = our_key_object->Data()->GetAsymmetricKey();
  ManagedEVPPKey their_key = their_key_object->Data()->GetAsymmetricKey();

  Local<Value> out;
  if (!StatelessDiffieHellmanThreadsafe(our_key, their_key)
          .ToBuffer(env)
              .ToLocal(&out)) return;

  if (Buffer::Length(out) == 0)
    return ThrowCryptoError(env, ERR_get_error(), ""diffieHellman failed"");

  args.GetReturnValue().Set(out);
}",72,,645,2,,void
36630,BLOCK,-1,,<empty>,31,,662,2,,void
36640,BLOCK,-1,,<empty>,5,,665,2,,void
36661,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsObject());  // public key
  CHECK(args[offset + 1]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 1], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->public_key = public_key->Data();
  params->private_key = private_key->Data();

  return Just(true);
}",27,,674,5,,void
36724,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,687,2,,void
36755,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,702,5,,void
36777,BLOCK,-1,,"{
  *out = StatelessDiffieHellmanThreadsafe(
      params.private_key->GetAsymmetricKey(),
      params.public_key->GetAsymmetricKey());
  return true;
}",22,,710,4,,void
36802,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
  return Just(true);
}",27,,720,4,,void
36840,BLOCK,-1,,<empty>,1,,1,1,,ANY
36867,BLOCK,-1,,<empty>,1,,1,1,,ANY
36872,BLOCK,-1,,"{
  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
  EVP_PKEY* raw_params = nullptr;

  if (!param_ctx ||
      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
      EVP_PKEY_CTX_set_dsa_paramgen_bits(
          param_ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  if (params->params.divisor_bits != -1) {
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }

  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
    return EVPKeyCtxPointer();

  EVPKeyPointer key_params(raw_params);
  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));

  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return key_ctx;
}",70,,40,2,,void
36906,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,48,2,,void
36918,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }",42,,52,2,,void
36931,BLOCK,1,,<empty>,,,,4,,void
36947,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",65,,54,2,,void
36960,BLOCK,-1,,<empty>,5,,60,2,,void
36985,BLOCK,-1,,<empty>,5,,66,2,,void
36997,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());  // modulus bits
  CHECK(args[*offset + 1]->IsInt32());  // divisor bits

  params->params.modulus_bits = args[*offset].As<Uint32>()->Value();
  params->params.divisor_bits = args[*offset + 1].As<Int32>()->Value();
  CHECK_GE(params->params.divisor_bits, -1);

  *offset += 2;

  return Just(true);
}",34,,85,5,,void
37071,BLOCK,-1,,"{
  return Just(true);
}",33,,101,4,,void
37082,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,109,5,,void
37091,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,112,2,,void
37107,BLOCK,-1,,<empty>,9,,118,2,,void
37128,BLOCK,-1,,<empty>,9,,122,2,,void
37148,BLOCK,-1,,"{
  const BIGNUM* p;  // Modulus length
  const BIGNUM* q;  // Divisor length

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_DSA);

  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
  CHECK_NOT_NULL(dsa);

  DSA_get0_pqg(dsa, &p, &q, nullptr);

  size_t modulus_length = BN_num_bits(p);
  size_t divisor_length = BN_num_bits(q);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing() ||
      target
          ->Set(
              env->context(),
              env->divisor_length_string(),
              Number::New(env->isolate(), static_cast<double>(divisor_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,132,4,,void
37258,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,160,2,,void
37270,BLOCK,-1,,"{
  DsaKeyPairGenJob::Initialize(env, target);
  DSAKeyExportJob::Initialize(env, target);
}",57,,168,3,,void
37287,BLOCK,-1,,"{
  DsaKeyPairGenJob::RegisterExternalReferences(registry);
  DSAKeyExportJob::RegisterExternalReferences(registry);
}",70,,173,2,,void
37316,BLOCK,-1,,<empty>,1,,1,1,,ANY
37320,BLOCK,-1,,"{
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  }",80,,115,2,,void
37368,BLOCK,-1,,<empty>,1,,1,1,,ANY
37373,BLOCK,-1,,"{
  int nid = EC_curve_nist2nid(name);
  if (nid == NID_undef)
    nid = OBJ_sn2nid(name);
  return nid;
}",40,,41,2,,void
37383,BLOCK,-1,,<empty>,5,,44,2,,void
37394,BLOCK,-1,,"{
  int nid;
  if (strcmp(name, ""Ed25519"") == 0) {
    nid = EVP_PKEY_ED25519;
  } else if (strcmp(name, ""Ed448"") == 0) {
    nid = EVP_PKEY_ED448;
  } else if (strcmp(name, ""X25519"") == 0) {
    nid = EVP_PKEY_X25519;
  } else if (strcmp(name, ""X448"") == 0) {
    nid = EVP_PKEY_X448;
  } else {
    nid = NID_undef;
  }
  return nid;
}",43,,48,2,,void
37402,BLOCK,-1,,"{
    nid = EVP_PKEY_ED25519;
  }",37,,50,2,,void
37407,BLOCK,-1,,<empty>,10,,52,1,,void
37414,BLOCK,-1,,"{
    nid = EVP_PKEY_ED448;
  }",42,,52,2,,void
37419,BLOCK,-1,,<empty>,10,,54,1,,void
37426,BLOCK,-1,,"{
    nid = EVP_PKEY_X25519;
  }",43,,54,2,,void
37431,BLOCK,-1,,<empty>,10,,56,1,,void
37438,BLOCK,-1,,"{
    nid = EVP_PKEY_X448;
  }",41,,56,2,,void
37443,BLOCK,-1,,"{
    nid = NID_undef;
  }",10,,58,1,,void
37454,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(ECDH::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
  SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
  SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
  SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
  SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
  SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

  SetConstructorFunction(context, target, ""ECDH"", t);

  SetMethodNoSideEffect(context, target, ""ECDHConvertKey"", ECDH::ConvertKey);
  SetMethodNoSideEffect(context, target, ""getCurves"", ECDH::GetCurves);

  ECDHBitsJob::Initialize(env, target);
  ECKeyPairGenJob::Initialize(env, target);
  ECKeyExportJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED...",63,,64,3,,void
37563,BLOCK,1,,<empty>,,,,7,,void
37565,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE)",3,,88,1,,void
37662,BLOCK,1,,<empty>,,,,7,,void
37664,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE)",3,,89,1,,void
37760,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);
  registry->Register(ECDH::ConvertKey);
  registry->Register(ECDH::GetCurves);

  ECDHBitsJob::RegisterExternalReferences(registry);
  ECKeyPairGenJob::RegisterExternalReferences(registry);
  ECKeyExportJob::RegisterExternalReferences(registry);
}",76,,92,2,,void
37829,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
  std::vector<EC_builtin_curve> curves(num_curves);
  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);

  std::vector<Local<Value>> arr(num_curves);
  std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  });
  args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
}",63,,108,2,,void
37915,BLOCK,-1,,"{
  MakeWeak();
  CHECK_NOT_NULL(group_);
}",43,,124,4,,void
37922,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""key"", key_ ? kSizeOf_EC_KEY : 0);
}",53,,129,2,,void
37935,BLOCK,-1,,<empty>,15,,133,1,,void
37940,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // TODO(indutny): Support raw curves?
  CHECK(args[0]->IsString());
  node::Utf8Value curve(env->isolate(), args[0]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
  if (!key)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
      ""Failed to create key using named curve"");

  new ECDH(env, args.This(), std::move(key));
}",57,,135,2,,void
37976,BLOCK,-1,,<empty>,5,,146,2,,void
37987,BLOCK,-1,,<empty>,5,,150,2,,void
38008,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  if (!EC_KEY_generate_key(ecdh->key_.get()))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to generate key"");
}",66,,156,2,,void
38034,BLOCK,-1,,<empty>,5,,163,2,,void
38045,BLOCK,-1,,"{
  int r;

  ECPointPointer pub(EC_POINT_new(group));
  if (!pub) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }

  ArrayBufferOrViewContents<unsigned char> input(buf);
  if (UNLIKELY(!input.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }
  r = EC_POINT_oct2point(
      group,
      pub.get(),
      input.data(),
      input.size(),
      nullptr);
  if (!r)
    return ECPointPointer();

  return pub;
}",54,,168,4,,void
38054,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }",13,,172,2,,void
38070,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }",42,,179,2,,void
38096,BLOCK,-1,,<empty>,5,,190,2,,void
38105,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(IsAnyByteSource(args[0]));

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!ecdh->IsKeyPairValid())
    return THROW_ERR_CRYPTO_INVALID_KEYPAIR(env);

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (!ECDH_compute_key(
          bs->Data(), bs->ByteLength(), pub.get(), ecdh->key_.get(), nullptr))
    r...",67,,195,2,,void
38134,BLOCK,-1,,<empty>,5,,206,2,,void
38154,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }",13,,212,2,,void
38176,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,220,12,,void
38231,BLOCK,-1,,<empty>,5,,230,2,,void
38278,BLOCK,-1,,<empty>,68,,234,2,,void
38292,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // Conversion form
  CHECK_EQ(args.Length(), 1);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
  if (pub == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH public key"");

  CHECK(args[0]->IsUint32());
  uint32_t val = args[0].As<Uint32>()->Value();
  point_conversion_form_t form = static_cast<point_conversion_form_t>(val);

  const char* error;
  Local<Object> buf;
  if (!ECPointToBuffer(env, group, pub, form, &error).ToLocal(&buf))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, error);
  args.GetReturnValue().Set(buf);
}",66,,238,2,,void
38339,BLOCK,-1,,<empty>,5,,250,2,,void
38389,BLOCK,-1,,<empty>,5,,260,2,,void
38406,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
  if (b == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH private key"");

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }
  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(
               b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,264,2,,void
38437,BLOCK,-1,,<empty>,5,,272,2,,void
38449,BLOCK,9,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }",3,,276,9,,void
38529,BLOCK,-1,,<empty>,68,,286,2,,void
38543,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
  if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  BignumPointer priv(BN_bin2bn(
      priv_buffer.data(), priv_buffer.size(), nullptr));
  if (!priv) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }

  if (!ecdh->IsKeyValidForCurve(priv)) {
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }

  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
  CHECK(new_key);

  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
  priv.reset();

  if (!result) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_...",67,,290,2,,void
38572,BLOCK,-1,,<empty>,5,,298,2,,void
38592,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }",14,,302,2,,void
38604,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }",40,,307,2,,void
38639,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }",16,,318,2,,void
38680,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to generate ECDH public key"");
  }",49,,333,2,,void
38696,BLOCK,-1,,<empty>,5,,339,2,,void
38725,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  CHECK(IsAnyByteSource(args[0]));

  MarkPopErrorOnReturn mark_pop_error_on_return;

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
  if (!r) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }
}",66,,346,2,,void
38764,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",13,,360,2,,void
38786,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }",11,,366,2,,void
38795,BLOCK,-1,,"{
  CHECK(group_);
  CHECK(private_key);
  // Private keys must be in the range [1, n-1].
  // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
    return false;
  }
  BignumPointer order(BN_new());
  CHECK(order);
  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
         BN_cmp(private_key.get(), order.get()) < 0;
}",65,,372,2,,void
38808,BLOCK,-1,,"{
    return false;
  }",54,,377,2,,void
38839,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_return);
  return 1 == EC_KEY_check_key(key_.get());
}",29,,386,1,,void
38856,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(IsAnyByteSource(args[0]));

  ArrayBufferOrViewContents<char> args0(args[0]);
  if (UNLIKELY(!args0.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");
  if (args0.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  node::Utf8Value curve(env->isolate(), args[1]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECGroupPointer group(
      EC_GROUP_new_by_curve_name(nid));
  if (group == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to get EC_GROUP"");

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          group.get(),
                          args[0]));

  if (pub == nullptr) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  CHECK(args[2]->IsUi...",64,,393,2,,void
38889,BLOCK,-1,,<empty>,5,,402,2,,void
38901,BLOCK,-1,,<empty>,5,,404,2,,void
38929,BLOCK,-1,,<empty>,5,,410,2,,void
38941,BLOCK,-1,,<empty>,5,,415,2,,void
38964,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",23,,422,2,,void
39020,BLOCK,-1,,<empty>,5,,434,2,,void
39037,BLOCK,-1,,"{
  tracker->TrackField(""public"", public_);
  tracker->TrackField(""private"", private_);
}",63,,438,2,,void
39057,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,447,5,,void
39080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsString());  // curve name
  CHECK(args[offset + 1]->IsObject());  // public key
  CHECK(args[offset + 2]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  Utf8Value name(env->isolate(), args[offset]);

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset + 1], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 2], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->id_ = GetOKPCurveFromName(*name);
  params->private_ = private_key->Data();
  params->public_ = public_key->Data();

  return Just(true);
}",29,,456,5,,void
39163,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,472,2,,void
39200,BLOCK,-1,,"{
  size_t len = 0;
  ManagedEVPPKey m_privkey = params.private_->GetAsymmetricKey();
  ManagedEVPPKey m_pubkey = params.public_->GetAsymmetricKey();

  switch (params.id_) {
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_k...",50,,486,4,,void
39227,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get(...",23,,491,2,,void
39232,BLOCK,5,,"{
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }",25,,494,5,,void
39237,BLOCK,3,,"{
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }",7,,496,3,,void
39286,BLOCK,-1,,"{
        return false;
      }",59,,504,2,,void
39306,BLOCK,-1,,"{
        return false;
      }",77,,510,2,,void
39323,BLOCK,7,,"{
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get());

      const EC_GROUP* group = EC_KEY_get0_group(private_key);
      if (group == nullptr)
        return false;

      CHECK_EQ(EC_KEY_check_key(private_key), 1);
      CHECK_EQ(EC_KEY_check_key(public_key), 1);
      const EC_POINT* pub = EC_KEY_get0_public_key(public_key);
      int field_size = EC_GROUP_get_degree(group);
      len = (field_size + 7) / 8;
      ByteSource::Builder buf(len);
      CHECK_NOT_NULL(pub);
      CHECK_NOT_NULL(private_key);
      if (ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
          0) {
        return false;
      }

      *out = std::move(buf).release();
    }",14,,518,7,,void
39325,BLOCK,2,,"{
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }",7,,520,2,,void
39364,BLOCK,-1,,<empty>,9,,530,2,,void
39411,BLOCK,-1,,"{
        return false;
      }",14,,541,2,,void
39431,BLOCK,-1,,"{
  EVPKeyCtxPointer key_ctx;
  switch (params->params.curve_nid) {
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }

  i...",68,,552,2,,void
39439,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }",37,,554,2,,void
39461,BLOCK,12,,"{
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }",14,,564,12,,void
39518,BLOCK,-1,,"{
        return EVPKeyCtxPointer();
      }",65,,573,2,,void
39544,BLOCK,-1,,<empty>,5,,582,2,,void
39558,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[*offset]->IsString());  // curve name
  CHECK(args[*offset + 1]->IsInt32());  // param encoding

  Utf8Value curve_name(env->isolate(), args[*offset]);
  params->params.curve_nid = GetCurveFromName(*curve_name);
  if (params->params.curve_nid == NID_undef) {
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }

  params->params.param_encoding = args[*offset + 1].As<Int32>()->Value();
  if (params->params.param_encoding != OPENSSL_EC_NAMED_CURVE &&
      params->params.param_encoding != OPENSSL_EC_EXPLICIT_CURVE) {
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }

  *offset += 2;

  return Just(true);
}",33,,601,5,,void
39612,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }",46,,608,2,,void
39651,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }",67,,615,2,,void
39671,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  CHECK(m_pkey);
  Mutex::ScopedLock lock(*m_pkey.mutex());

  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());

  size_t len = 0;

  if (ec_key == nullptr) {
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  } else {
    if (key_data->GetKeyTy...",22,,629,4,,void
39704,BLOCK,-1,,"{
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  }",26,,638,2,,void
39709,BLOCK,-1,,<empty>,,,,4,,<empty>
39721,BLOCK,-1,,"{
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }",37,,641,2,,void
39750,BLOCK,-1,,<empty>,7,,654,2,,void
39772,BLOCK,-1,,<empty>,7,,657,2,,void
39790,BLOCK,-1,,"{
    if (key_data->GetKeyType() != kKeyTypePublic)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
    const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    // Get the allocated data size...
    len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
    if (len == 0)
      return WebCryptoKeyExportStatus::FAILED;
    ByteSource::Builder data(len);
    size_t check_len = EC_POINT_point2oct(
        group, point, form, data.data<unsigned char>(), len, nullptr);
    if (check_len == 0)
      return WebCryptoKeyExportStatus::FAILED;

    CHECK_EQ(len, check_len);
    *out = std::move(data).release();
  }",10,,659,1,,void
39798,BLOCK,-1,,<empty>,7,,661,2,,void
39830,BLOCK,-1,,<empty>,7,,669,2,,void
39855,BLOCK,-1,,<empty>,7,,674,2,,void
39884,BLOCK,-1,,"{
  return Just(true);
}",32,,687,4,,void
39895,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
    ...",22,,695,5,,void
39904,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock...",19,,698,2,,void
39924,BLOCK,-1,,<empty>,9,,703,2,,void
39938,BLOCK,10,,"{
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            E...",35,,705,10,,void
39946,BLOCK,-1,,<empty>,9,,707,2,,void
39966,BLOCK,-1,,"{
        return PKEY_SPKI_Export(key_data.get(), out);
      }",53,,710,2,,void
39975,BLOCK,-1,,"{
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
        if (need == 0) return WebCryptoKeyExportStatus::FAILED;
        ByteSource::Builder data(need);
        const size_t have = EC_POINT_point2oct(
            group, point, form, data.data<unsigned char>(), need, nullptr);
       ...",14,,712,1,,void
40019,BLOCK,-1,,<empty>,24,,725,2,,void
40044,BLOCK,-1,,<empty>,24,,729,2,,void
40108,BLOCK,-1,,<empty>,,,,2,,<empty>
40124,BLOCK,-1,,<empty>,11,,745,2,,void
40149,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);

  int degree_bits = EC_GROUP_get_degree(group);
  int degree_bytes =
    (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;

  BignumPointer x(BN_new());
  BignumPointer y(BN_new());

  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_ec_string()).IsNothing()) {
    return Nothing<void>();
  }

  if (SetEncodedValue(
          env,
          target,
          env->jwk_x_string...",27,,758,4,,void
40230,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }",80,,776,2,,void
40257,BLOCK,-1,,"{
    return Nothing<void>();
  }",46,,785,2,,void
40292,BLOCK,-1,,"{
    return Nothing<void>();
  }",38,,800,2,,void
40307,BLOCK,-1,,"{
    case NID_X9_62_prime256v1:
      crv_name = OneByteString(env->isolate(), ""P-256"");
      break;
    case NID_secp256k1:
      crv_name = OneByteString(env->isolate(), ""secp256k1"");
      break;
    case NID_secp384r1:
      crv_name = OneByteString(env->isolate(), ""P-384"");
      break;
    case NID_secp521r1:
      crv_name = OneByteString(env->isolate(), ""P-521"");
      break;
    default: {
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }
  }",16,,806,2,,void
40353,BLOCK,18,,"{
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }",14,,819,18,,void
40378,BLOCK,-1,,"{
    return Nothing<void>();
  }",30,,828,2,,void
40388,BLOCK,-1,,"{
    const BIGNUM* pvt = EC_KEY_get0_private_key(ec);
    return SetEncodedValue(
      env,
      target,
      env->jwk_d_string(),
      pvt,
      degree_bytes).IsJust() ? JustVoid() : Nothing<void>();
  }",45,,832,2,,void
40418,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*pkey.mutex());

  const char* curve = nullptr;
  switch (EVP_PKEY_id(pkey.get())) {
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }
  if (target->Set(
          env->context(),
          env->jwk_crv_string(),
          OneByteString(env->isolate(), curve)).IsNothing()) {
    return Nothing<bool>();
  }

  size_t len = 0;
  Local<Value> encoded;
  Local<Value> error;

  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
    return Nothing<bool>();

  ByteSource::Builder out(len);

  if (key->GetKeyType() == kKeyTypePrivate) {
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
           ...",27,,848,4,,void
40443,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }",36,,853,2,,void
40492,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,872,2,,void
40519,BLOCK,-1,,<empty>,5,,881,2,,void
40532,BLOCK,-1,,"{
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
             env->isolate(), out.data<const char>(), len, BASE64URL, &error)
             .ToLocal(&encoded) ||
        !target->Set(env->context(), env->jwk_d_string(), encoded).IsJust()) {
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }
  }",45,,885,2,,void
40587,BLOCK,-1,,"{
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }",78,,891,2,,void
40594,BLOCK,-1,,<empty>,9,,893,2,,void
40659,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",76,,903,2,,void
40666,BLOCK,-1,,<empty>,7,,905,2,,void
40697,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,912,2,,void
40710,BLOCK,-1,,"{
  CHECK(args[offset]->IsString());  // curve name
  Utf8Value curve(env->isolate(), args[offset].As<String>());

  int nid = GetCurveFromName(*curve);
  if (nid == NID_undef) {  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }

  Local<Value> x_value;
  Local<Value> y_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_x_string()).ToLocal(&x_value) ||
      !jwk->Get(env->context(), env->jwk_y_string()).ToLocal(&y_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value)) {
    return std::shared_ptr<KeyObjectData>();
  }

  if (!x_value->IsString() ||
      !y_value->IsString() ||
      (!d_value->IsUndefined() && !d_value->IsString())) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  ECKeyPointer ec(EC_KEY_new_by_curve_name(nid));
  if (!ec)...",26,,923,5,,void
40740,BLOCK,-1,,"{  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }",25,,928,2,,void
40820,BLOCK,-1,,"{
    return std::shared_ptr<KeyObjectData>();
  }",73,,939,2,,void
40850,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",58,,945,2,,void
40876,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",12,,953,2,,void
40930,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",28,,964,2,,void
40943,BLOCK,-1,,"{
    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());
    if (!EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }
  }",32,,969,2,,void
40970,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }",60,,971,2,,void
41011,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_GROUP* group = EC_KEY_get0_group(ec);
  int nid = EC_GROUP_get_curve_name(group);

  return target->Set(
      env->context(),
      env->named_curve_string(),
      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
}",27,,986,4,,void
41077,BLOCK,-1,,"{
  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
  CHECK_NOT_NULL(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);
  BignumPointer order(BN_new());
  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
  return BN_num_bytes(order.get());
}",50,,1008,2,,void
41134,BLOCK,-1,,<empty>,1,,1,1,,ANY
41141,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,142,5,,void
41155,BLOCK,-1,,<empty>,7,,145,2,,void
41202,BLOCK,-1,,<empty>,1,,1,1,,ANY
41208,BLOCK,-1,,"{
  MakeWeak();
}",74,,28,3,,void
41214,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
  tracker->TrackFieldWithSize(""md"", digest_ ? md_len_ : 0);
}",53,,32,2,,void
41237,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_MD_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_MD,
                    EVP_MD_fetch,
                    EVP_MD_free,
                    EVP_get_digestbyname,
                    EVP_MD_get0_name>,
#else
    array_push_back<EVP_MD>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",63,,37,2,,void
41270,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hash::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""update"", HashUpdate);
  SetProtoMethod(isolate, t, ""digest"", HashDigest);

  SetConstructorFunction(context, target, ""Hash"", t);

  SetMethodNoSideEffect(context, target, ""getHashes"", GetHashes);

  HashJob::Initialize(env, target);
}",63,,55,3,,void
41337,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HashUpdate);
  registry->Register(HashDigest);
  registry->Register(GetHashes);

  HashJob::RegisterExternalReferences(registry);
}",76,,72,2,,void
41367,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const Hash* orig = nullptr;
  const EVP_MD* md = nullptr;

  if (args[0]->IsObject()) {
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  } else {
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }

  Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
  if (!args[1]->IsUndefined()) {
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }

  Hash* hash = new Hash(env, args.This());
  if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }

  if (orig != nullptr &&
      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }
}",57,,81,2,,void
41391,BLOCK,-1,,"{
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  }",28,,87,2,,void
41411,BLOCK,-1,,"{
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }",10,,90,1,,void
41438,BLOCK,-1,,"{
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }",32,,96,2,,void
41480,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }",57,,102,2,,void
41506,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }",69,,108,2,,void
41517,BLOCK,-1,,"{
  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
    mdctx_.reset();
    return false;
  }

  md_len_ = EVP_MD_size(md);
  if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }

  return true;
}",71,,113,3,,void
41536,BLOCK,-1,,"{
    mdctx_.reset();
    return false;
  }",69,,115,2,,void
41559,BLOCK,-1,,"{
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }",64,,121,2,,void
41567,BLOCK,-1,,"{
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }",52,,124,2,,void
41586,BLOCK,-1,,"{
  if (!mdctx_)
    return false;
  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
}",53,,134,3,,void
41590,BLOCK,-1,,<empty>,5,,136,2,,void
41606,BLOCK,-1,,"{
  Decode<Hash>(args, [](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,140,2,,void
41619,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hash* hash;
  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned int len = hash->md_len_;

  // TODO(tniessen): SHA3_squeeze does not work for zero-length outputs on all
  // platforms and will cause a segmentation fault if called. This workaround
  // causes hash.digest() to correctly return an empty buffer / string.
  // See https://github.com/openssl/openssl/issues/9431.

  if (!hash->digest_ && len > 0) {
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int r...",64,,151,2,,void
41647,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,158,2,,void
41674,BLOCK,-1,,"{
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int ret;
    if (len == default_len) {
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    } else {
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }

    if (ret != 1)
      return ThrowCryptoError(env, ERR_get_error());

    hash->digest_ = std::move(digest).release();
  }",34,,169,2,,void
41693,BLOCK,-1,,"{
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    }",29,,180,2,,void
41715,BLOCK,-1,,"{
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }",12,,185,1,,void
41734,BLOCK,-1,,<empty>,7,,191,2,,void
41785,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,199,2,,void
41817,BLOCK,-1,,<empty>,28,,211,2,,void
41822,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HashConfig();
  return *new (this) HashConfig(std::move(other));
}",64,,213,2,,void
41828,BLOCK,-1,,<empty>,23,,214,2,,void
41850,BLOCK,-1,,"{
  // If the Job is sync, then the HashConfig does not own the data.
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""in"", in.size());
}",59,,219,2,,void
41855,BLOCK,-1,,<empty>,5,,222,2,,void
41872,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,229,5,,void
41895,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash algorithm
  Utf8Value digest(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*digest);
  if (UNLIKELY(params->digest == nullptr)) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  ArrayBufferOrViewContents<char> data(args[offset + 1]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->in = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  unsigned int expected = EVP_MD_size(params->digest);
  params->length = expected;
  if (UNLIKELY(args[offset + 2]->IsUint32())) {
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if...",25,,238,5,,void
41939,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",44,,246,2,,void
41961,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,252,2,,void
42005,BLOCK,-1,,"{
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }
  }",47,,262,2,,void
42031,BLOCK,-1,,"{
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }",37,,267,2,,void
42041,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }",66,,268,2,,void
42056,BLOCK,-1,,"{
  EVPMDPointer ctx(EVP_MD_CTX_new());

  if (UNLIKELY(!ctx ||
               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
               EVP_DigestUpdate(
                   ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
    return false;
  }

  if (LIKELY(params.length > 0)) {
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }

  return true;
}",22,,281,4,,void
42096,BLOCK,-1,,"{
    return false;
  }",80,,287,2,,void
42106,BLOCK,-1,,"{
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }",34,,291,2,,void
42157,BLOCK,-1,,<empty>,7,,303,2,,void
42191,BLOCK,-1,,<empty>,1,,1,1,,ANY
42212,BLOCK,-1,,<empty>,1,,1,1,,ANY
42217,BLOCK,-1,,<empty>,35,,26,2,,void
42222,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HKDFConfig();
  return *new (this) HKDFConfig(std::move(other));
}",64,,28,2,,void
42228,BLOCK,-1,,<empty>,23,,29,2,,void
42253,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,38,5,,void
42276,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash
  CHECK(args[offset + 1]->IsObject());  // Key
  CHECK(IsAnyByteSource(args[offset + 2]));  // Salt
  CHECK(IsAnyByteSource(args[offset + 3]));  // Info
  CHECK(args[offset + 4]->IsUint32());  // Length

  Utf8Value hash(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*hash);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 1], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> salt(args[offset + 2]);
  ArrayBufferOrViewContents<char> info(args[offset + 3]);

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }
  if (UNLIKELY(!info.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(e...",25,,47,5,,void
42351,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }",34,,60,2,,void
42398,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }",41,,72,2,,void
42411,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""info is too big"");
    return Nothing<bool>();
  }",41,,76,2,,void
42483,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYLEN(env);
    return Nothing<bool>();
  }",36,,95,2,,void
42497,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
      !EVP_PKEY_CTX_add1_hkdf_info(
          ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
    return false;
  }

  // TODO(panva): Once support for OpenSSL 1.1.1 is dropped the whole
  // of HKDFTraits::DeriveBits can be refactored to use
  // EVP_KDF which does handle zero length key.

  std::string_view salt;
  if (params.salt.size() != 0) {
    salt = {params.salt.data<char>(), params.salt.size()};
  } else {
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }

  // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
  // the extraction step ourselves because EVP_PKEY_derive does not handle
  // zero-length keys, which are required for Web Cr...",22,,106,4,,void
42544,BLOCK,-1,,"{
    return false;
  }",78,,112,2,,void
42557,BLOCK,-1,,"{
    salt = {params.salt.data<char>(), params.salt.size()};
  }",32,,121,2,,void
42561,BLOCK,-1,,"{
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }",10,,123,1,,void
42607,BLOCK,-1,,"{
    return false;
  }",33,,140,2,,void
42627,BLOCK,-1,,"{
    return false;
  }",74,,144,2,,void
42653,BLOCK,-1,,<empty>,5,,151,2,,void
42673,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  // If the job is sync, then the HKDFConfig does not own the data
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }
}",59,,157,2,,void
42684,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }",32,,160,2,,void
42719,BLOCK,-1,,<empty>,1,,1,1,,ANY
42726,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,104,5,,void
42740,BLOCK,-1,,<empty>,7,,107,2,,void
42793,BLOCK,-1,,<empty>,1,,1,1,,ANY
42799,BLOCK,-1,,"{
  MakeWeak();
}",21,,33,3,,void
42805,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_HMAC_CTX : 0);
}",53,,37,2,,void
42820,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hmac::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", HmacInit);
  SetProtoMethod(isolate, t, ""update"", HmacUpdate);
  SetProtoMethod(isolate, t, ""digest"", HmacDigest);

  SetConstructorFunction(env->context(), target, ""Hmac"", t);

  HmacJob::Initialize(env, target);
}",63,,41,3,,void
42880,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HmacInit);
  registry->Register(HmacUpdate);
  registry->Register(HmacDigest);
  HmacJob::RegisterExternalReferences(registry);
}",76,,56,2,,void
42910,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Hmac(env, args.This());
}",57,,64,2,,void
42932,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());

  const EVP_MD* md = EVP_get_digestbyname(hash_type);
  if (md == nullptr)
    return THROW_ERR_CRYPTO_INVALID_DIGEST(
        env(), ""Invalid digest: %s"", hash_type);
  if (key_len == 0) {
    key = """";
  }
  ctx_.reset(HMAC_CTX_new());
  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }
}",74,,69,4,,void
42948,BLOCK,-1,,<empty>,5,,74,2,,void
42958,BLOCK,-1,,"{
    key = """";
  }",21,,76,2,,void
42981,BLOCK,-1,,"{
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }",70,,80,2,,void
42994,BLOCK,-1,,"{
  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
  Environment* env = hmac->env();

  const node::Utf8Value hash_type(env->isolate(), args[0]);
  ByteSource key = ByteSource::FromSecretKeyBytes(env, args[1]);
  hmac->HmacInit(*hash_type, key.data<char>(), key.size());
}",62,,86,2,,void
43049,BLOCK,-1,,"{
  return ctx_ && HMAC_Update(ctx_.get(),
                             reinterpret_cast<const unsigned char*>(data),
                             len) == 1;
}",53,,96,3,,void
43067,BLOCK,-1,,"{
  Decode<Hmac>(args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,102,2,,void
43080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len = 0;

  if (hmac->ctx_) {
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }

  Local<Value> error;
  MaybeLocal<Value> rc =
      StringBytes::Encode(env->isolate(),
                          reinterpret_cast<const char*>(md_value),
                          md_len,
                          encoding,
                          &error);
  if (rc.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(rc.FromMaybe(Local<Value>()));
}",64,,113,2,,void
43108,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,120,2,,void
43129,BLOCK,-1,,"{
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }",19,,127,2,,void
43152,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }",14,,130,2,,void
43189,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,142,2,,void
43221,BLOCK,-1,,<empty>,28,,156,2,,void
43226,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HmacConfig();
  return *new (this) HmacConfig(std::move(other));
}",64,,158,2,,void
43232,BLOCK,-1,,<empty>,23,,159,2,,void
43254,BLOCK,-1,,"{
  tracker->TrackField(""key"", key.get());
  // If the job is sync, then the HmacConfig does not own the data
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",59,,164,2,,void
43268,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,167,2,,void
43294,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // SignConfiguration::Mode
  params->mode =
    static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  CHECK(args[offset + 1]->IsString());  // Hash
  CHECK(args[offset + 2]->IsObject());  // Key

  Utf8Value digest(env->isolate(), args[offset + 1]);
  params->digest = EVP_get_digestbyname(*digest);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 2], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> data(args[offset + 3]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (!args[off...",25,,177,5,,void
43372,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",34,,191,2,,void
43412,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,201,2,,void
43444,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 4]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    params->signature = mode == kCryptoJobAsync
        ? signature.ToCopy()
        : signature.ToByteSource();
  }",41,,209,2,,void
43459,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,211,2,,void
43490,BLOCK,-1,,"{
  HMACCtxPointer ctx(HMAC_CTX_new());

  if (!ctx ||
      !HMAC_Init_ex(
          ctx.get(),
          params.key->GetSymmetricKey(),
          params.key->GetSymmetricKeySize(),
          params.digest,
          nullptr)) {
    return false;
  }

  if (!HMAC_Update(
          ctx.get(),
          params.data.data<unsigned char>(),
          params.data.size())) {
    return false;
  }

  ByteSource::Builder buf(EVP_MAX_MD_SIZE);
  unsigned int len;

  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
    return false;
  }

  *out = std::move(buf).release(len);

  return true;
}",22,,226,4,,void
43520,BLOCK,-1,,"{
    return false;
  }",21,,235,2,,void
43542,BLOCK,-1,,"{
    return false;
  }",32,,242,2,,void
43562,BLOCK,-1,,"{
    return false;
  }",64,,249,2,,void
43586,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,262,5,,void
43591,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }",24,,263,2,,void
43686,BLOCK,-1,,<empty>,1,,1,1,,ANY
43709,BLOCK,-1,,<empty>,1,,1,1,,ANY
43717,BLOCK,-1,,"{
  CHECK(args[*offset]->IsInt32());
  params->params.id = args[*offset].As<Int32>()->Value();

  *offset += 1;

  return Just(true);
}",34,,37,5,,void
43753,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return ctx;
}",74,,46,2,,void
43776,BLOCK,-1,,<empty>,5,,50,2,,void
43785,BLOCK,-1,,"{
  if (out) tracker->TrackFieldWithSize(""out"", length);
}",67,,55,2,,void
43788,BLOCK,-1,,<empty>,12,,56,2,,void
43802,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());
  uint32_t bits = args[*offset].As<Uint32>()->Value();
  params->length = bits / CHAR_BIT;
  *offset += 1;
  return Just(true);
}",33,,63,5,,void
43843,BLOCK,-1,,"{
  ByteSource::Builder bytes(params->length);
  if (CSPRNG(bytes.data<unsigned char>(), params->length).is_err())
    return KeyGenJobStatus::FAILED;
  params->out = std::move(bytes).release();
  return KeyGenJobStatus::OK;
}",74,,72,3,,void
43861,BLOCK,-1,,<empty>,5,,75,2,,void
43888,BLOCK,-1,,"{
  std::shared_ptr<KeyObjectData> data =
      KeyObjectData::CreateSecret(std::move(params->out));
  return Just(KeyObjectHandle::Create(env, data).ToLocal(result));
}",65,,82,4,,void
43926,BLOCK,-1,,"{
  NidKeyPairGenJob::Initialize(env, target);
  SecretKeyGenJob::Initialize(env, target);
}",57,,89,3,,void
43943,BLOCK,-1,,"{
  NidKeyPairGenJob::RegisterExternalReferences(registry);
  SecretKeyGenJob::RegisterExternalReferences(registry);
}",70,,94,2,,void
43974,BLOCK,-1,,<empty>,1,,1,1,,ANY
43979,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      }",43,,115,3,,void
43992,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      }",43,,124,3,,void
44005,BLOCK,-1,,"{  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
      }",43,,133,3,,void
44060,BLOCK,-1,,<empty>,1,,1,1,,ANY
44069,BLOCK,-1,,"{
  // During key pair generation, it is possible not to specify a key encoding,
  // which will lead to a key object being returned.
  if (args[*offset]->IsUndefined()) {
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  } else {
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }

  *offset += 2;
}",33,,47,5,,void
44078,BLOCK,-1,,"{
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  }",37,,50,2,,void
44098,BLOCK,-1,,"{
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }",10,,54,1,,void
44138,BLOCK,-1,,"{
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    }",39,,61,2,,void
44162,BLOCK,-1,,"{
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }",12,,64,1,,void
44209,BLOCK,-1,,"{
  unsigned char* der_data;
  long der_len;  // NOLINT(runtime/int)

  // This skips surrounding data and decodes PEM to DER.
  {
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }

  // OpenSSL might modify the pointer, so we need to make a copy before parsing.
  const unsigned char* p = der_data;
  pkey->reset(parse(&p, der_len));
  OPENSSL_clear_free(der_data, der_len);

  return *pkey ? ParseKeyResult::kParseKeyOk :
                 ParseKeyResult::kParseKeyFailed;
}",77,,83,5,,void
44212,BLOCK,3,,"{
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }",3,,88,3,,void
44230,BLOCK,-1,,<empty>,7,,92,2,,void
44266,BLOCK,-1,,"{
  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
  if (!bp)
    return ParseKeyResult::kParseKeyFailed;

  ParseKeyResult ret;

  // Try parsing as a SubjectPublicKeyInfo first.
  ret = TryParsePublicKey(pkey, bp, ""PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // Maybe it is PKCS#1.
  CHECK(BIO_reset(bp.get()));
  ret = TryParsePublicKey(pkey, bp, ""RSA PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // X.509 fallback.
  CHECK(BIO_reset(bp.get()));
  return TryParsePublicKey(pkey, bp, ""CERTIFICATE"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        retur...",51,,106,4,,void
44277,BLOCK,-1,,<empty>,5,,109,2,,void
44296,BLOCK,-1,,<empty>,5,,119,2,,void
44318,BLOCK,-1,,<empty>,5,,128,2,,void
44340,BLOCK,-1,,"{
  if (config.format_ == kKeyFormatPEM) {
    return ParsePublicKeyPEM(pkey, key, key_len);
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }
}",47,,142,5,,void
44347,BLOCK,-1,,"{
    return ParsePublicKeyPEM(pkey, key, key_len);
  }",40,,143,2,,void
44354,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }",10,,145,1,,void
44375,BLOCK,-1,,"{
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,149,2,,void
44387,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }",12,,151,1,,void
44422,BLOCK,-1,,"{
  if (size < 2 || data[0] != 0x30)
    return false;

  if (data[1] & 0x80) {
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  } else {
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }

  return true;
}",61,,162,5,,void
44433,BLOCK,-1,,<empty>,5,,164,2,,void
44442,BLOCK,-1,,"{
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  }",23,,166,2,,void
44463,BLOCK,-1,,<empty>,7,,170,2,,void
44471,BLOCK,-1,,<empty>,5,,172,1,,void
44512,BLOCK,-1,,"{
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }",10,,176,1,,void
44541,BLOCK,-1,,"{
  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // An RSAPrivateKey sequence always starts with a single-byte integer whose
  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus
  // (which is the product of two primes and therefore at least 4), so we can
  // decide the type of the structure based on the first three bytes of the
  // sequence.
  return len >= 3 &&
         data[offset] == 2 &&
         data[offset + 1] == 1 &&
         !(data[offset + 2] & 0xfe);
}",62,,185,3,,void
44553,BLOCK,-1,,<empty>,5,,189,2,,void
44588,BLOCK,-1,,"{
  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // A PrivateKeyInfo sequence always starts with an integer whereas an
  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.
  return len >= 1 &&
         data[offset] != 2;
}",72,,202,3,,void
44600,BLOCK,-1,,<empty>,5,,206,2,,void
44620,BLOCK,-1,,"{
  const ByteSource* passphrase = config.passphrase_.get();

  if (config.format_ == kKeyFormatPEM) {
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->rese...",48,,217,5,,void
44636,BLOCK,-1,,"{
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  }",40,,220,2,,void
44645,BLOCK,-1,,<empty>,7,,223,2,,void
44664,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    } else {
      CHECK_EQ(config.type_.ToChecked(), k...",10,,229,1,,void
44679,BLOCK,-1,,"{
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,232,2,,void
44697,BLOCK,-1,,<empty>,12,,235,1,,void
44707,BLOCK,-1,,"{
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    }",63,,235,2,,void
44716,BLOCK,-1,,<empty>,9,,238,2,,void
44727,BLOCK,-1,,"{
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      }",70,,241,2,,void
44742,BLOCK,-1,,"{
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }",14,,246,1,,void
44753,BLOCK,-1,,<empty>,11,,249,2,,void
44764,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
    }",12,,251,1,,void
44797,BLOCK,-1,,<empty>,5,,261,2,,void
44805,BLOCK,-1,,<empty>,5,,264,2,,void
44820,BLOCK,-1,,"{
    if (config.passphrase_.IsEmpty())
      return ParseKeyResult::kParseKeyNeedPassphrase;
  }",55,,266,2,,void
44828,BLOCK,-1,,<empty>,7,,268,2,,void
44843,BLOCK,-1,,"{
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio, &bptr);
  if (format == kKeyFormatPEM) {
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  } else {
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }
}",26,,276,4,,void
44853,BLOCK,-1,,"{
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  }",32,,279,2,,void
44877,BLOCK,-1,,"{
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }",10,,284,1,,void
44903,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // If an empty string was passed as the passphrase, the ByteSource might
  // contain a null pointer, which OpenSSL will ignore, causing it to invoke its
  // default passphrase callback, which would block the thread until the user
  // manually enters a passphrase. We could supply our own passphrase callback
  // to handle this special case, but it is easier to avoid passing a null
  // pointer to OpenSSL.
  char* pass = nullptr;
  size_t pass_len = 0;
  if (!config.passphrase_.IsEmpty()) {
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = rei...",45,,296,4,,void
44906,BLOCK,-1,,<empty>,,,,2,,<empty>
44927,BLOCK,-1,,"{
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }
  }",38,,308,2,,void
44950,BLOCK,-1,,"{
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }",26,,311,2,,void
44978,BLOCK,-1,,"{
    // PKCS#1 is only permitted for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);

    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }
  }",43,,326,2,,void
44993,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,331,2,,void
45017,BLOCK,-1,,"{
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }",12,,339,1,,void
45041,BLOCK,-1,,<empty>,10,,345,1,,void
45046,BLOCK,-1,,"{
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }
  }",50,,345,2,,void
45053,BLOCK,-1,,"{
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,346,2,,void
45072,BLOCK,-1,,"{
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",12,,354,1,,void
45096,BLOCK,-1,,"{
    CHECK_EQ(encoding_type, kKeyEncodingSEC1);

    // SEC1 is only permitted for EC keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);

    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }
  }",10,,364,1,,void
45114,BLOCK,-1,,"{
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,371,2,,void
45138,BLOCK,-1,,"{
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }",12,,379,1,,void
45163,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode private key"");
    return MaybeLocal<Value>();
  }",12,,387,2,,void
45186,BLOCK,-1,,"{
  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  } else {
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }
}",65,,396,4,,void
45196,BLOCK,-1,,"{
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  }",54,,397,2,,void
45211,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    }",42,,401,2,,void
45225,BLOCK,-1,,"{
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }",12,,404,1,,void
45244,BLOCK,-1,,"{
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }",10,,409,1,,void
45259,BLOCK,-1,,"{
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    }",42,,411,2,,void
45270,BLOCK,-1,,"{
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }",12,,414,1,,void
45291,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  if (!WritePublicKeyInner(pkey, bio, config)) {
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }
  return BIOToStringOrBuffer(env, bio.get(), config.format_);
}",73,,424,4,,void
45294,BLOCK,-1,,<empty>,,,,2,,<empty>
45305,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }",48,,428,2,,void
45328,BLOCK,-1,,"{
  CHECK_EQ(key->GetKeyType(), kKeyTypeSecret);

  Local<Value> error;
  Local<Value> raw;
  MaybeLocal<Value> key_data =
      StringBytes::Encode(
          env->isolate(),
          key->GetSymmetricKey(),
          key->GetSymmetricKeySize(),
          BASE64URL,
          &error);
  if (key_data.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  if (!key_data.ToLocal(&raw))
    return Nothing<bool>();

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_oct_string()).IsNothing() ||
      target->Set(
          env->context(),
          env->jwk_k_string(),
          raw).IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,438,4,,void
45375,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",27,,450,2,,void
45400,BLOCK,-1,,<empty>,5,,456,2,,void
45440,BLOCK,-1,,"{
    return Nothing<bool>();
  }",29,,465,2,,void
45451,BLOCK,-1,,"{
  Local<Value> key;
  if (!jwk->Get(env->context(), env->jwk_k_string()).ToLocal(&key) ||
      !key->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }

  static_assert(String::kMaxLength <= INT_MAX);
  ByteSource key_data = ByteSource::FromEncodedString(env, key.As<String>());
  return KeyObjectData::CreateSecret(std::move(key_data));
}",24,,474,3,,void
45482,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }",25,,477,2,,void
45526,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }
  THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE(env);
  return Just(false);
}",24,,491,5,,void
45536,BLOCK,-1,,"{
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }",55,,492,2,,void
45539,BLOCK,3,,"{
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }",28,,493,3,,void
45542,BLOCK,-1,,<empty>,25,,494,2,,void
45596,BLOCK,-1,,"{
  if (strcmp(kty, ""RSA"") == 0) {
    return ImportJWKRsaKey(env, jwk, args, offset);
  } else if (strcmp(kty, ""EC"") == 0) {
    return ImportJWKEcKey(env, jwk, args, offset);
  }

  THROW_ERR_CRYPTO_INVALID_JWK(env, ""%s is not a supported JWK key type"", kty);
  return std::shared_ptr<KeyObjectData>();
}",26,,517,6,,void
45603,BLOCK,-1,,"{
    return ImportJWKRsaKey(env, jwk, args, offset);
  }",32,,518,2,,void
45611,BLOCK,-1,,<empty>,10,,520,1,,void
45618,BLOCK,-1,,"{
    return ImportJWKEcKey(env, jwk, args, offset);
  }",38,,520,2,,void
45640,BLOCK,-1,,"{
  // For the secret key detail, all we care about is the length,
  // converted to bits.

  size_t length = key->GetSymmetricKeySize() * CHAR_BIT;
  return target->Set(env->context(),
                     env->length_string(),
                     Number::New(env->isolate(), static_cast<double>(length)));
}",27,,531,4,,void
45680,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }
  THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  return Nothing<bool>();
}",25,,544,4,,void
45690,BLOCK,-1,,"{
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }",55,,545,2,,void
45729,BLOCK,-1,,<empty>,39,,559,2,,void
45734,BLOCK,-1,,"{
  *this = that;
}",60,,561,2,,void
45743,BLOCK,-1,,"{
  Mutex::ScopedLock lock(*that.mutex_);

  pkey_.reset(that.get());

  if (pkey_)
    EVP_PKEY_up_ref(pkey_.get());

  mutex_ = that.mutex_;

  return *this;
}",71,,565,2,,void
45760,BLOCK,-1,,<empty>,5,,571,2,,void
45777,BLOCK,-1,,"{
  return !!pkey_;
}",39,,578,1,,void
45785,BLOCK,-1,,"{
  return pkey_.get();
}",39,,582,1,,void
45794,BLOCK,-1,,"{
  return mutex_.get();
}",38,,586,1,,void
45804,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""pkey"",
                              !pkey_ ? 0 : kSizeOf_EVP_PKEY +
                              size_of_private_key() +
                              size_of_public_key());
}",63,,590,2,,void
45822,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_private_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",52,,597,1,,void
45846,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_public_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",51,,603,1,,void
45871,BLOCK,-1,,"{
  return b ? Just(true) : Nothing<bool>();
}",44,,610,2,,void
45885,BLOCK,-1,,"{
  switch (key->GetKeyType()) {
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }
}",47,,617,5,,void
45891,BLOCK,-1,,"{
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }",30,,618,2,,void
45923,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePublicKey(env, get(), config).ToLocal(out));
}",24,,634,4,,void
45928,BLOCK,-1,,<empty>,15,,635,2,,void
45935,BLOCK,-1,,"{
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,636,2,,void
45964,BLOCK,-1,,<empty>,10,,642,1,,void
45971,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,642,2,,void
46021,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePrivateKey(env, get(), config).ToLocal(out));
}",24,,655,4,,void
46026,BLOCK,-1,,<empty>,15,,656,2,,void
46033,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,657,2,,void
46062,BLOCK,-1,,<empty>,10,,661,1,,void
46069,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,661,2,,void
46119,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PrivateKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);

  if (result.output_key_object_) {
    if (context != kKeyContextInput)
      (*offset)++;
  } else {
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offs...",33,,675,4,,void
46139,BLOCK,-1,,"{
    if (context != kKeyContextInput)
      (*offset)++;
  }",34,,681,2,,void
46144,BLOCK,-1,,<empty>,7,,683,2,,void
46149,BLOCK,-1,,"{
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
      ...",10,,684,1,,void
46158,BLOCK,-1,,"{
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }",38,,686,2,,void
46167,BLOCK,-1,,"{
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      }",38,,687,2,,void
46191,BLOCK,-1,,"{
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }",40,,690,2,,void
46200,BLOCK,-1,,"{
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }",14,,695,1,,void
46223,BLOCK,-1,,"{
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
          passphrase.ToNullTerminatedCopy());
    }",41,,702,2,,void
46246,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }",51,,705,2,,void
46265,BLOCK,-1,,"{
      CHECK(args[*offset]->IsNullOrUndefined() && !needs_passphrase);
    }",12,,711,1,,void
46296,BLOCK,-1,,"{
  PublicKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);
  return result;
}",33,,723,4,,void
46312,BLOCK,-1,,"{
  if (args[*offset]->IsString() || IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  } else {
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }
}",28,,732,4,,void
46327,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  }",68,,733,2,,void
46364,BLOCK,-1,,<empty>,7,,739,2,,void
46397,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,746,1,,void
46446,BLOCK,-1,,"{
  if (IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the ty...",27,,758,3,,void
46453,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the type determines how to parse it. SPKI, PKC...",39,,759,2,,void
46476,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }",43,,762,2,,void
46497,BLOCK,-1,,<empty>,7,,769,2,,void
46515,BLOCK,-1,,"{
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",42,,774,2,,void
46535,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",58,,778,2,,void
46551,BLOCK,-1,,"{
      // For DER, the type determines how to parse it. SPKI, PKCS#8 and SEC1 are
      // easy, but PKCS#1 can be a public key or a private key.
      bool is_public;
      switch (config.type_.ToChecked()) {
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }

      if (is_public) {
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      } else {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",12,,781,1,,void
46560,BLOCK,-1,,"{
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }",41,,785,2,,void
46597,BLOCK,-1,,"{
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      }",22,,801,2,,void
46613,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",14,,803,1,,void
46642,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject());
    KeyObjectHandle* key = Unwrap<KeyObjectHandle>(args[*offset].As<Object>());
    CHECK_NOT_NULL(key);
    CHECK_NE(key->Data()->GetKeyType(), kKeyTypeSecret);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,810,1,,void
46695,BLOCK,-1,,"{
  switch (ret) {
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }

  return ManagedEVPPKey(std::move(pkey));
}",70,,823,5,,void
46698,BLOCK,-1,,"{
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }",16,,824,2,,void
46730,BLOCK,-1,,<empty>,25,,842,2,,void
46736,BLOCK,-1,,<empty>,64,,845,3,,void
46741,BLOCK,-1,,"{
  switch (GetKeyType()) {
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }
}",62,,847,2,,void
46744,BLOCK,-1,,"{
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }",25,,848,2,,void
46774,BLOCK,-1,,"{
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(std::move(key)));
}",76,,862,2,,void
46794,BLOCK,-1,,"{
  CHECK(pkey);
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(key_type, pkey));
}",33,,868,3,,void
46811,BLOCK,-1,,"{
  return key_type_;
}",43,,873,1,,void
46817,BLOCK,-1,,"{
  CHECK_NE(key_type_, kKeyTypeSecret);
  return asymmetric_key_;
}",56,,877,1,,void
46826,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.data<char>();
}",52,,882,1,,void
46838,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.size();
}",51,,887,1,,void
46852,BLOCK,-1,,"{
  Local<FunctionTemplate> t = env->crypto_key_object_handle_constructor();
  return !t.IsEmpty() && t->HasInstance(value);
}",73,,892,3,,void
46879,BLOCK,-1,,"{
  Local<FunctionTemplate> templ = env->crypto_key_object_handle_constructor();
  if (templ.IsEmpty()) {
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_con...",71,,897,2,,void
46895,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_constructor(templ);
  }",24,,899,2,,void
46989,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(GetSymmetricKeySize);
  registry->Register(GetAsymmetricKeyType);
  registry->Register(Export);
  registry->Register(ExportJWK);
  registry->Register(InitECRaw);
  registry->Register(InitEDRaw);
  registry->Register(InitJWK);
  registry->Register(GetKeyDetail);
  registry->Register(Equals);
}",42,,924,2,,void
47050,BLOCK,-1,,"{
  Local<Object> obj;
  Local<Function> ctor = KeyObjectHandle::Initialize(env);
  CHECK(!env->crypto_key_object_handle_constructor().IsEmpty());
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj))
    return MaybeLocal<Object>();

  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(obj);
  CHECK_NOT_NULL(key);
  key->data_ = data;
  return obj;
}",42,,940,3,,void
47093,BLOCK,-1,,<empty>,5,,945,2,,void
47116,BLOCK,-1,,"{
  return data_;
}",63,,953,1,,void
47123,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new KeyObjectHandle(env, args.This());
}",68,,957,2,,void
47149,BLOCK,-1,,"{
  MakeWeak();
}",29,,965,3,,void
47155,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  CHECK(args[0]->IsInt32());
  KeyType type = static_cast<KeyType>(args[0].As<Uint32>()->Value());

  unsigned int offset;
  ManagedEVPPKey pkey;

  switch (type) {
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHAB...",69,,969,2,,void
47190,BLOCK,-1,,"{
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHABLE();
  }",17,,980,2,,void
47193,BLOCK,3,,"{
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }",24,,981,3,,void
47220,BLOCK,6,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",24,,987,6,,void
47242,BLOCK,-1,,<empty>,7,,993,2,,void
47257,BLOCK,9,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",25,,997,9,,void
47280,BLOCK,-1,,<empty>,7,,1003,2,,void
47299,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  // The argument must be a JavaScript object that we will inspect
  // to get the JWK properties from.
  CHECK(args[0]->IsObject());

  // Step one, Secret key or not?
  Local<Object> input = args[0].As<Object>();

  Local<Value> kty;
  if (!input->Get(env->context(), env->jwk_kty_string()).ToLocal(&kty) ||
      !kty->IsString()) {
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }

  Utf8Value kty_string(env->isolate(), kty);

  if (strcmp(*kty_string, ""oct"") == 0) {
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  } else {
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for ...",72,,1012,2,,void
47366,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }",25,,1027,2,,void
47384,BLOCK,-1,,"{
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  }",40,,1033,2,,void
47397,BLOCK,-1,,"{
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }",22,,1036,2,,void
47400,BLOCK,-1,,"{
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }
  }",10,,1040,1,,void
47417,BLOCK,-1,,"{
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }",22,,1042,2,,void
47436,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  int id = OBJ_txt2nid(*name);
  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
  if (!eckey)
    return args.GetReturnValue().Set(false);

  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
  ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));

  if (!pub ||
      !eckey ||
      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
    return args.GetReturnValue().Set(false);
  }

  EVPKeyPointer pkey(EVP_PKEY_new());
  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
    args.GetReturnValue().Set(false);

  eckey.release();  // Release ownership of the key

  key->data_ =
      KeyObjectData::CreateAsymmetric(
          kKeyTypePublic,
          ManagedEVPPKey(std::move(pkey)));

  args.GetReturnValue().Set(true);
}",74,,1051,2,,void
47483,BLOCK,-1,,<empty>,5,,1064,2,,void
47529,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",55,,1071,2,,void
47553,BLOCK,-1,,<empty>,5,,1077,2,,void
47593,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  ArrayBufferOrViewContents<unsigned char> key_data(args[1]);
  KeyType type = static_cast<KeyType>(args[2].As<Int32>()->Value());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
  new_key_fn fn = type == kKeyTypePrivate
      ? EVP_PKEY_new_raw_private_key
      : EVP_PKEY_new_raw_public_key;

  int id = GetOKPCurveFromName(*name);

  switch (id) {
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std:...",74,,1089,2,,void
47651,BLOCK,-1,,<empty>,,,,5,,<empty>
47671,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }
    default:
      UNREACHABLE();
  }",15,,1109,2,,void
47680,BLOCK,9,,"{
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }",26,,1113,9,,void
47697,BLOCK,-1,,<empty>,9,,1116,2,,void
47741,BLOCK,-1,,"{
  KeyObjectHandle* self_handle;
  KeyObjectHandle* arg_handle;
  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
  ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
  std::shared_ptr<KeyObjectData> key = self_handle->Data();
  std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();

  KeyType key_type = key->GetKeyType();
  CHECK_EQ(key_type, key2->GetKeyType());

  bool ret;
  switch (key_type) {
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(...",71,,1131,2,,void
47800,BLOCK,-1,,"{
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }
    default:
      UNREACHABLE(""unsupported key type"");
  }",21,,1143,2,,void
47803,BLOCK,3,,"{
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }",26,,1144,3,,void
47818,BLOCK,-1,,"{
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      }",48,,1146,2,,void
47834,BLOCK,-1,,"{
        ret = false;
      }",14,,1151,1,,void
47843,BLOCK,8,,"{
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }",27,,1157,8,,void
47875,BLOCK,-1,,"{
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }",21,,1165,2,,void
47908,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());

  std::shared_ptr<KeyObjectData> data = key->Data();

  switch (data->GetKeyType()) {
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }

  args.GetReturnValue().Set(args[0]);
}",77,,1179,2,,void
47949,BLOCK,-1,,"{
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }",31,,1188,2,,void
47965,BLOCK,-1,,<empty>,9,,1191,2,,void
47985,BLOCK,-1,,<empty>,9,,1197,2,,void
48003,BLOCK,-1,,"{
  const ManagedEVPPKey& key = data_->GetAsymmetricKey();
  switch (EVP_PKEY_id(key.get())) {
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }
}",60,,1206,1,,void
48017,BLOCK,-1,,"{
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }",35,,1208,2,,void
48092,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  args.GetReturnValue().Set(key->GetAsymmetricKeyType());
}",46,,1233,2,,void
48116,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  args.GetReturnValue().Set(
      static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
}",46,,1241,2,,void
48145,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  KeyType type = key->Data()->GetKeyType();

  MaybeLocal<Value> result;
  if (type == kKeyTypeSecret) {
    result = key->ExportSecretKey();
  } else if (type == kKeyTypePublic) {
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  } else {
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }

  if (!result.IsEmpty())
    args.GetReturnValue().Set(result.FromMaybe(L...",71,,1248,2,,void
48173,BLOCK,-1,,"{
    result = key->ExportSecretKey();
  }",31,,1255,2,,void
48181,BLOCK,-1,,<empty>,10,,1257,1,,void
48186,BLOCK,-1,,"{
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  }",38,,1257,2,,void
48218,BLOCK,-1,,"{
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }",10,,1264,1,,void
48245,BLOCK,-1,,<empty>,7,,1271,2,,void
48271,BLOCK,-1,,<empty>,5,,1277,2,,void
48287,BLOCK,-1,,"{
  const char* buf = data_->GetSymmetricKey();
  unsigned int len = data_->GetSymmetricKeySize();
  return Buffer::Copy(env(), buf, len).FromMaybe(Local<Value>());
}",60,,1280,1,,void
48318,BLOCK,-1,,"{
  return WritePublicKey(env(), data_->GetAsymmetricKey().get(), config);
}",50,,1287,2,,void
48334,BLOCK,-1,,"{
  return WritePrivateKey(env(), data_->GetAsymmetricKey().get(), config);
}",51,,1292,2,,void
48350,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsBoolean());

  ExportJWKInner(env, key->Data(), args[0], args[1]->IsTrue());

  args.GetReturnValue().Set(args[0]);
}",54,,1297,2,,void
48411,BLOCK,-1,,"{
  SetMethod(env->context(),
            target,
            ""createNativeKeyObjectClass"",
            NativeKeyObject::CreateNativeKeyObjectClass);
}",74,,1310,3,,void
48426,BLOCK,-1,,"{
  registry->Register(NativeKeyObject::CreateNativeKeyObjectClass);
  registry->Register(NativeKeyObject::New);
}",42,,1318,2,,void
48445,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsObject());
  KeyObjectHandle* handle = Unwrap<KeyObjectHandle>(args[0].As<Object>());
  new NativeKeyObject(env, args.This(), handle->Data());
}",68,,1323,2,,void
48495,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  Local<Value> callback = args[0];
  CHECK(callback->IsFunction());

  Local<FunctionTemplate> t =
      NewFunctionTemplate(isolate, NativeKeyObject::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      KeyObjectHandle::kInternalFieldCount);

  Local<Value> ctor;
  if (!t->GetFunction(env->context()).ToLocal(&ctor))
    return;

  Local<Value> recv = Undefined(env->isolate());
  Local<Value> ret_v;
  if (!callback.As<Function>()->Call(
          env->context(), recv, 1, &ctor).ToLocal(&ret_v)) {
    return;
  }
  Local<Array> ret = ret_v.As<Array>();
  if (!ret->Get(env->context(), 1).ToLocal(&ctor)) return;
  env->set_crypto_key_object_secret_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 2).ToLocal(&ctor)) return;
  env->set_crypto_key_object_public_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 3).ToLocal(&ctor)) r...",46,,1332,2,,void
48572,BLOCK,-1,,<empty>,5,,1347,2,,void
48612,BLOCK,-1,,"{
    return;
  }",60,,1352,2,,void
48640,BLOCK,-1,,<empty>,52,,1356,2,,void
48666,BLOCK,-1,,<empty>,52,,1358,2,,void
48692,BLOCK,-1,,<empty>,52,,1360,2,,void
48716,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!KeyObjectHandle::Create(env, data_).ToLocal(&handle))
    return {};

  Local<Function> key_ctor;
  Local<Value> arg = FIXED_ONE_BYTE_STRING(env->isolate(),
                                           ""internal/crypto/keys"");
  if (env->builtin_module_require()
          ->Call(context, Null(env->isolate()), 1, &arg)
          .IsEmpty()) {
    return {};
  }
  switch (data_->GetKeyType()) {
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> key;
  if (!key_ctor->NewInstance(context, 1, &handle).ToLocal(&key))
    return {};

  return BaseObject...",53,,1368,4,,void
48724,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1369,2,,void
48746,BLOCK,-1,,<empty>,5,,1376,2,,void
48785,BLOCK,-1,,"{
    return {};
  }",23,,1383,2,,void
48792,BLOCK,-1,,"{
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }",32,,1386,2,,void
48842,BLOCK,-1,,<empty>,5,,1402,2,,void
48860,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,1407,1,,void
48870,BLOCK,-1,,"{
  return std::make_unique<KeyObjectTransferData>(handle_data_);
}",11,,1412,1,,void
48884,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1418,3,,void
48907,BLOCK,-1,,<empty>,,,,2,,<empty>
48923,BLOCK,-1,,<empty>,5,,1425,2,,void
48945,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1433,3,,void
48968,BLOCK,-1,,<empty>,,,,2,,<empty>
48991,BLOCK,-1,,<empty>,5,,1442,2,,void
49014,BLOCK,-1,,"{
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""KeyObjectHandle""),
              KeyObjectHandle::Initialize(env)).Check();

  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK);

  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);
  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);
  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);
  NODE_DEFINE_CONSTANT(target, kKeyFormatJWK);
  NODE_DEFINE_CONSTANT(target, kKeyTypeSecret);
  NODE_DEFINE_CONSTANT...",57,,1449,3,,void
49042,BLOCK,1,,<empty>,,,,7,,void
49044,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw)",3,,1454,1,,void
49141,BLOCK,1,,<empty>,,,,7,,void
49143,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8)",3,,1455,1,,void
49240,BLOCK,1,,<empty>,,,,7,,void
49242,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI)",3,,1456,1,,void
49339,BLOCK,1,,<empty>,,,,7,,void
49341,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK)",3,,1457,1,,void
49438,BLOCK,1,,<empty>,,,,7,,void
49440,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519)",3,,1459,1,,void
49537,BLOCK,1,,<empty>,,,,7,,void
49539,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448)",3,,1460,1,,void
49636,BLOCK,1,,<empty>,,,,7,,void
49638,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519)",3,,1461,1,,void
49735,BLOCK,1,,<empty>,,,,7,,void
49737,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448)",3,,1462,1,,void
49834,BLOCK,1,,<empty>,,,,7,,void
49836,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1)",3,,1463,1,,void
49933,BLOCK,1,,<empty>,,,,7,,void
49935,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8)",3,,1464,1,,void
50032,BLOCK,1,,<empty>,,,,7,,void
50034,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI)",3,,1465,1,,void
50131,BLOCK,1,,<empty>,,,,7,,void
50133,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1)",3,,1466,1,,void
50230,BLOCK,1,,<empty>,,,,7,,void
50232,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatDER)",3,,1467,1,,void
50329,BLOCK,1,,<empty>,,,,7,,void
50331,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatPEM)",3,,1468,1,,void
50428,BLOCK,1,,<empty>,,,,7,,void
50430,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatJWK)",3,,1469,1,,void
50527,BLOCK,1,,<empty>,,,,7,,void
50529,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypeSecret)",3,,1470,1,,void
50626,BLOCK,1,,<empty>,,,,7,,void
50628,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePublic)",3,,1471,1,,void
50725,BLOCK,1,,<empty>,,,,7,,void
50727,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePrivate)",3,,1472,1,,void
50824,BLOCK,1,,<empty>,,,,7,,void
50826,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncDER)",3,,1473,1,,void
50923,BLOCK,1,,<empty>,,,,7,,void
50925,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncP1363)",3,,1474,1,,void
51021,BLOCK,-1,,"{
  KeyObjectHandle::RegisterExternalReferences(registry);
}",70,,1477,2,,void
51053,BLOCK,-1,,<empty>,1,,1,1,,ANY
51074,BLOCK,-1,,<empty>,1,,1,1,,ANY
51079,BLOCK,-1,,<empty>,28,,26,2,,void
51084,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~PBKDF2Config();
  return *new (this) PBKDF2Config(std::move(other));
}",70,,28,2,,void
51090,BLOCK,-1,,<empty>,23,,29,2,,void
51112,BLOCK,-1,,"{
  // The job is sync, the PBKDF2Config does not own the data.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,34,2,,void
51117,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,36,2,,void
51143,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,46,5,,void
51166,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsInt32());  // iteration_count
  CHECK(args[offset + 3]->IsInt32());  // length
  CHECK(args[offset + 4]->IsString());  // digest_name

  params->iterations = args[offset + 2].As<Int32>()->Value();
  if (params->iterations < 0) {
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }

 ...",27,,62,5,,void
51199,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,70,2,,void
51212,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,75,2,,void
51298,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",31,,93,2,,void
51326,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""length must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",27,,99,2,,void
51357,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *name);
    return Nothing<bool>();
  }",34,,106,2,,void
51374,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both pass and salt may be zero length here.
  // The generated bytes are stored in buf, which is
  // assigned to out on success.

  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                        params.pass.size(),
                        params.salt.data<unsigned char>(),
                        params.salt.size(),
                        params.iterations,
                        params.digest,
                        params.length,
                        buf.data<unsigned char>()) <= 0) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,117,4,,void
51421,BLOCK,-1,,"{
    return false;
  }",58,,131,2,,void
51453,BLOCK,-1,,<empty>,1,,1,1,,ANY
51476,BLOCK,-1,,<empty>,1,,1,1,,ANY
51484,BLOCK,-1,,"{
  *result = v8::Undefined(env->isolate());
  return Just(!result->IsEmpty());
}",35,,32,5,,void
51510,BLOCK,-1,,"{
  CHECK(IsAnyByteSource(args[offset]));  // Buffer to fill
  CHECK(args[offset + 1]->IsUint32());  // Offset
  CHECK(args[offset + 2]->IsUint32());  // Size

  ArrayBufferOrViewContents<unsigned char> in(args[offset]);

  const uint32_t byte_offset = args[offset + 1].As<Uint32>()->Value();
  const uint32_t size = args[offset + 2].As<Uint32>()->Value();
  CHECK_GE(byte_offset + size, byte_offset);  // Overflow check.
  CHECK_LE(byte_offset + size, in.size());  // Bounds check.

  params->buffer = in.data() + byte_offset;
  params->size = size;

  return Just(true);
}",32,,41,5,,void
51604,BLOCK,-1,,"{
  return CSPRNG(params.buffer, params.size).is_ok();
}",25,,62,4,,void
51620,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""prime"", prime ? bits * 8 : 0);
}",66,,66,2,,void
51639,BLOCK,-1,,"{
  size_t size = BN_num_bytes(params.prime.get());
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), size);
  BN_bn2binpad(
      params.prime.get(),
      reinterpret_cast<unsigned char*>(store->Data()),
      size);
  *result = ArrayBuffer::New(env->isolate(), store);
  return Just(true);
}",35,,74,5,,void
51703,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error;
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[offset]->IsUint32());  // Size
  CHECK(args[offset + 1]->IsBoolean());  // Safe

  const uint32_t size = args[offset].As<Uint32>()->Value();
  bool safe = args[offset + 1]->IsTrue();

  if (!args[offset + 2]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  if (!args[offset + 3]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  // The JS interface already ensures that the (positive) size fits into an int....",32,,90,5,,void
51762,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,99,2,,void
51791,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,102,2,,void
51807,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,108,2,,void
51836,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,111,2,,void
51855,BLOCK,-1,,"{
    if (BN_num_bits(params->add.get()) > bits) {
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }

    if (params->rem) {
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }
  }",20,,121,2,,void
51866,BLOCK,-1,,"{
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }",48,,122,2,,void
51876,BLOCK,-1,,"{
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }",22,,131,2,,void
51893,BLOCK,-1,,"{
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }",62,,132,2,,void
51921,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
    return Nothing<bool>();
  }",23,,144,2,,void
51936,BLOCK,-1,,"{
  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
  // Make sure the CSPRNG is properly seeded.
  CHECK(CSPRNG(nullptr, 0).is_ok());

  if (BN_generate_prime_ex(
          params.prime.get(),
          params.bits,
          params.safe ? 1 : 0,
          params.add.get(),
          params.rem.get(),
          nullptr) == 0) {
    return false;
  }

  return true;
}",56,,154,4,,void
51976,BLOCK,-1,,"{
    return false;
  }",26,,165,2,,void
51985,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(
      ""prime"", candidate ? BN_num_bytes(candidate.get()) : 0);
}",65,,172,2,,void
52006,BLOCK,-1,,"{
  ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);

  params->candidate =
      BignumPointer(BN_bin2bn(
          candidate.data(),
          candidate.size(),
          nullptr));

  CHECK(args[offset + 1]->IsInt32());  // Checks
  params->checks = args[offset + 1].As<Int32>()->Value();
  CHECK_GE(params->checks, 0);

  return Just(true);
}",31,,181,5,,void
52065,BLOCK,-1,,"{

  BignumCtxPointer ctx(BN_CTX_new());

  int ret = BN_is_prime_ex(
            params.candidate.get(),
            params.checks,
            ctx.get(),
            nullptr);
  if (ret < 0) return false;
  ByteSource::Builder buf(1);
  buf.data<char>()[0] = ret;
  *out = std::move(buf).release();
  return true;
}",22,,200,4,,void
52091,BLOCK,-1,,<empty>,16,,209,2,,void
52125,BLOCK,-1,,"{
  *result = Boolean::New(env->isolate(), out->data<char>()[0] != 0);
  return Just(true);
}",35,,220,5,,void
52154,BLOCK,-1,,"{
  RandomBytesJob::Initialize(env, target);
  RandomPrimeJob::Initialize(env, target);
  CheckPrimeJob::Initialize(env, target);
}",57,,226,3,,void
52177,BLOCK,-1,,"{
  RandomBytesJob::RegisterExternalReferences(registry);
  RandomPrimeJob::RegisterExternalReferences(registry);
  CheckPrimeJob::RegisterExternalReferences(registry);
}",70,,232,2,,void
52211,BLOCK,-1,,<empty>,1,,1,1,,ANY
52240,BLOCK,-1,,<empty>,1,,1,1,,ANY
52245,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(
      EVP_PKEY_CTX_new_id(
          params->params.variant == kKeyVariantRSA_PSS
              ? EVP_PKEY_RSA_PSS
              : EVP_PKEY_RSA,
          nullptr));

  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
          ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  // 0x10001 is the default RSA exponent.
  if (params->params.exponent != 0x10001) {
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPo...",70,,32,2,,void
52268,BLOCK,-1,,<empty>,5,,41,2,,void
52284,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,45,2,,void
52295,BLOCK,-1,,"{
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }",43,,50,2,,void
52327,BLOCK,-1,,<empty>,7,,56,2,,void
52342,BLOCK,-1,,"{
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPointer();
    }

    // TODO(tniessen): This appears to only be necessary in OpenSSL 3, while
    // OpenSSL 1.1.1 behaves as recommended by RFC 8017 and defaults the MGF1
    // hash algorithm to the RSA-PSS hashAlgorithm. Remove this code if the
    // behavior of OpenSSL 3 changes.
    const EVP_MD* mgf1_md = params->params.mgf1_md;
    if (mgf1_md == nullptr && params->params.md != nullptr) {
      mgf1_md = params->params.md;
    }

    if (mgf1_md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
            ctx.get(),
            mgf1_md) <= 0) {
      return EVPKeyCtxPointer();
    }

    int saltlen = params->params.saltlen;
    if (saltlen < 0 && params->params.md != nullptr) {
      saltlen = EVP_MD_size(params->params.md);
    }

    if (saltlen >= 0 &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
            c...",53,,61,2,,void
52364,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",80,,63,2,,void
52387,BLOCK,-1,,"{
      mgf1_md = params->params.md;
    }",61,,72,2,,void
52408,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,79,2,,void
52431,BLOCK,-1,,"{
      saltlen = EVP_MD_size(params->params.md);
    }",54,,84,2,,void
52453,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,91,2,,void
52465,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[*offset]->IsUint32());  // Variant
  CHECK(args[*offset + 1]->IsUint32());  // Modulus bits
  CHECK(args[*offset + 2]->IsUint32());  // Exponent

  params->params.variant =
      static_cast<RSAKeyVariant>(args[*offset].As<Uint32>()->Value());

  CHECK_IMPLIES(params->params.variant != kKeyVariantRSA_PSS,
                args.Length() == 10);
  CHECK_IMPLIES(params->params.variant == kKeyVariantRSA_PSS,
                args.Length() == 13);

  params->params.modulus_bits = args[*offset + 1].As<Uint32>()->Value();
  params->params.exponent = args[*offset + 2].As<Uint32>()->Value();

  *offset += 3;

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_D...",34,,130,5,,void
52596,BLOCK,-1,,"{
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 1]->IsUndefined()) {
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 2]->IsUndefined()) {
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
      ...",53,,150,2,,void
52606,BLOCK,-1,,"{
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",40,,151,2,,void
52642,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",41,,155,2,,void
52661,BLOCK,-1,,"{
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",44,,161,2,,void
52701,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }",46,,165,2,,void
52720,BLOCK,-1,,"{
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }
    }",44,,172,2,,void
52757,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }",39,,175,2,,void
52777,BLOCK,-1,,"{
  return WebCryptoKeyExportStatus::FAILED;
}",22,,193,4,,void
52790,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));

  if (!ctx || init(ctx.get()) <= 0)
    return WebCryptoCipherStatus::FAILED;

  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (params.digest != nullptr &&
      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!SetRsaOaepLabel(ctx, params.label)) return WebCryptoCipherStatus::FAILED;

  size_t out_len = 0;
  if (cipher(
          ctx.get(),
          nullptr,
          &out_len,
          in.data<unsigned char>(),
          in.size()) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  ByteSource::Builder buf(out_len);

  if (cipher(ctx.get(),
        ...",22,,204,6,,void
52830,BLOCK,-1,,<empty>,5,,212,2,,void
52846,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",69,,214,2,,void
52879,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",70,,220,2,,void
52891,BLOCK,-1,,<empty>,44,,224,2,,void
52919,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",28,,232,2,,void
52949,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",31,,242,2,,void
52976,BLOCK,-1,,"{
  CHECK(args[offset]->IsUint32());  // RSAKeyVariant
  params->variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());
  return Just(true);
}",33,,254,4,,void
53009,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,265,5,,void
53018,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,268,2,,void
53044,BLOCK,-1,,<empty>,9,,276,2,,void
53065,BLOCK,-1,,<empty>,9,,280,2,,void
53083,BLOCK,-1,,<empty>,28,,291,2,,void
53088,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""label"", label.size());
}",64,,293,2,,void
53093,BLOCK,-1,,<empty>,5,,295,2,,void
53111,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;
  params->padding = RSA_PKCS1_OAEP_PADDING;

  CHECK(args[offset]->IsUint32());
  RSAKeyVariant variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());

  switch (variant) {
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPT...",30,,303,6,,void
53153,BLOCK,-1,,"{
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
      return Nothing<bool>();
  }",20,,313,2,,void
53156,BLOCK,3,,"{
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }",31,,314,3,,void
53190,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",38,,319,2,,void
53205,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }",46,,324,2,,void
53220,BLOCK,-1,,"{
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }",48,,326,2,,void
53252,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }
  return WebCryptoCipherStatus::FAILED;
}",22,,348,7,,void
53255,BLOCK,-1,,"{
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }",24,,349,2,,void
53302,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  const BIGNUM* n;
  const BIGNUM* e;
  const BIGNUM* d;
  const BIGNUM* p;
  const BIGNUM* q;
  const BIGNUM* dp;
  const BIGNUM* dq;
  const BIGNUM* qi;
  RSA_get0_key(rsa, &n, &e, &d);

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_rsa_string()).IsNothing()) {
    return Nothing<bool>();
  }

  if (SetEncodedValue(env, target, env->jwk_n_string(), n).IsNothing() ||
      SetEncodedValue(env, tar...",27,,365,4,,void
53338,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,374,2,,void
53347,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,376,1,,void
53395,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,394,2,,void
53422,BLOCK,-1,,"{
    return Nothing<bool>();
  }",73,,399,2,,void
53432,BLOCK,-1,,"{
    RSA_get0_factors(rsa, &p, &q);
    RSA_get0_crt_params(rsa, &dp, &dq, &qi);
    if (SetEncodedValue(env, target, env->jwk_d_string(), d).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_p_string(), p).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_q_string(), q).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dp_string(), dp).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dq_string(), dq).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_qi_string(), qi).IsNothing()) {
      return Nothing<bool>();
    }
  }",45,,403,2,,void
53519,BLOCK,-1,,"{
      return Nothing<bool>();
    }",77,,411,2,,void
53532,BLOCK,-1,,"{
  Local<Value> n_value;
  Local<Value> e_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_n_string()).ToLocal(&n_value) ||
      !jwk->Get(env->context(), env->jwk_e_string()).ToLocal(&e_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value) ||
      !n_value->IsString() ||
      !e_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  if (!d_value->IsUndefined() && !d_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  RsaPointer rsa(RSA_new());

  ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
  ByteSource e = ByteSource::FromEncodedString(env, e_value.As<String>());

  if (!RSA_set0_key(
          rsa.get(),
          n.ToBN().release(),
          e.ToBN().release(),
  ...",26,,423,5,,void
53617,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",29,,432,2,,void
53638,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",56,,437,2,,void
53706,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",21,,453,2,,void
53719,BLOCK,-1,,"{
    Local<Value> p_value;
    Local<Value> q_value;
    Local<Value> dp_value;
    Local<Value> dq_value;
    Local<Value> qi_value;

    if (!jwk->Get(env->context(), env->jwk_p_string()).ToLocal(&p_value) ||
        !jwk->Get(env->context(), env->jwk_q_string()).ToLocal(&q_value) ||
        !jwk->Get(env->context(), env->jwk_dp_string()).ToLocal(&dp_value) ||
        !jwk->Get(env->context(), env->jwk_dq_string()).ToLocal(&dq_value) ||
        !jwk->Get(env->context(), env->jwk_qi_string()).ToLocal(&qi_value)) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    if (!p_value->IsString() ||
        !q_value->IsString() ||
        !dp_value->IsString() ||
        !dq_value->IsString() ||
        !qi_value->IsString()) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());...",32,,458,2,,void
53840,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",77,,469,2,,void
53879,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",32,,478,2,,void
54025,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",35,,496,2,,void
54066,BLOCK,-1,,"{
  const BIGNUM* e;  // Public Exponent
  const BIGNUM* n;  // Modulus

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  RSA_get0_key(rsa, &n, &e, nullptr);

  size_t modulus_length = BN_num_bits(n);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  std::unique_ptr<BackingStore> public_exponent;
  {
   ...",27,,511,4,,void
54104,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,523,2,,void
54113,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,525,1,,void
54164,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,539,2,,void
54174,BLOCK,18,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    public_exponent =
        ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(e));
  }",3,,544,18,,void
54241,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,558,2,,void
54248,BLOCK,-1,,"{
    // Due to the way ASN.1 encoding works, default values are omitted when
    // encoding the data structure. However, there are also RSA-PSS keys for
    // which no parameters are set. In that case, the ASN.1 RSASSA-PSS-params
    // sequence will be missing entirely and RSA_get0_pss_params will return
    // nullptr. If parameters are present but all parameters are set to their
    // default values, an empty sequence will be stored in the ASN.1 structure.
    // In that case, RSA_get0_pss_params does not return nullptr but all fields
    // of the returned RSA_PSS_PARAMS will be set to nullptr.

    const RSA_PSS_PARAMS* params = RSA_get0_pss_params(rsa);
    if (params != nullptr) {
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
       ...",33,,562,2,,void
54258,BLOCK,-1,,"{
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
                  env->context(),
                  env->hash_algorithm_string(),
                  OneByteString(env->isolate(), OBJ_nid2ln(hash_nid)))
              .IsNothing()) {
        return Nothing<bool>();
      }

      if (params->maskGenAlgorithm != nullptr) {
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }

      // If, for some reason, the MGF is not MGF1, then the MGF1 hash function
      // is intentionally not added to the object.
      if (mgf_nid == NID_mgf1) {
        if (target
                ->Set(
                    env->context(),
  ...",28,,573,2,,void
54281,BLOCK,-1,,"{
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }",45,,579,2,,void
54313,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,588,2,,void
54322,BLOCK,-1,,"{
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }",48,,592,2,,void
54335,BLOCK,-1,,"{
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }",34,,594,2,,void
54348,BLOCK,-1,,"{
        if (target
                ->Set(
                    env->context(),
                    env->mgf1_hash_algorithm_string(),
                    OneByteString(env->isolate(), OBJ_nid2ln(mgf1_hash_nid)))
                .IsNothing()) {
          return Nothing<bool>();
        }
      }",32,,601,2,,void
54372,BLOCK,-1,,"{
          return Nothing<bool>();
        }",31,,607,2,,void
54381,BLOCK,-1,,"{
        if (ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }
      }",42,,612,2,,void
54391,BLOCK,-1,,"{
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }",76,,613,2,,void
54425,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,624,2,,void
54437,BLOCK,-1,,"{
  RSAKeyPairGenJob::Initialize(env, target);
  RSAKeyExportJob::Initialize(env, target);
  RSACipherJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_SSA_PKCS1_v1_5);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_PSS);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_OAEP);
}",57,,634,3,,void
54469,BLOCK,-1,,"{
  RSAKeyPairGenJob::RegisterExternalReferences(registry);
  RSAKeyExportJob::RegisterExternalReferences(registry);
  RSACipherJob::RegisterExternalReferences(registry);
}",70,,644,2,,void
54505,BLOCK,-1,,<empty>,1,,1,1,,ANY
54526,BLOCK,-1,,<empty>,1,,1,1,,ANY
54531,BLOCK,-1,,<empty>,26,,31,2,,void
54536,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~ScryptConfig();
  return *new (this) ScryptConfig(std::move(other));
}",70,,33,2,,void
54542,BLOCK,-1,,<empty>,23,,34,2,,void
54564,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,39,2,,void
54569,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,40,2,,void
54595,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,50,5,,void
54618,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsUint32());  // N
  CHECK(args[offset + 3]->IsUint32());  // r
  CHECK(args[offset + 4]->IsUint32());  // p
  CHECK(args[offset + 5]->IsNumber());  // maxmem
  CHECK(args[offset + 6]->IsInt32());  // length

  params->N = args[offset + 2].As<Uint32>()->Value();
  params->r = args[offset + 3].As<Uint32>()->Value();
  params->p = args...",27,,59,5,,void
54651,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,67,2,,void
54664,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,72,2,,void
54833,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_SCRYPT_PARAMS(env);
    return Nothing<bool>();
  }",20,,106,2,,void
54867,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both the pass and salt may be zero-length at this point

  if (!EVP_PBE_scrypt(params.pass.data<char>(),
                      params.pass.size(),
                      params.salt.data<unsigned char>(),
                      params.salt.size(),
                      params.N,
                      params.r,
                      params.p,
                      params.maxmem,
                      buf.data<unsigned char>(),
                      params.length)) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,120,4,,void
54919,BLOCK,-1,,"{
    return false;
  }",39,,134,2,,void
54949,BLOCK,-1,,<empty>,1,,1,1,,ANY
54956,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  }",56,,377,5,,void
54970,BLOCK,-1,,<empty>,7,,380,2,,void
55003,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  }",58,,494,5,,void
55017,BLOCK,-1,,<empty>,7,,497,2,,void
55066,BLOCK,-1,,<empty>,1,,1,1,,ANY
55072,BLOCK,-1,,"{
  /* Validate DSA2 parameters from FIPS 186-4 */
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr) &&
      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#else
  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }

  return true;
}",43,,32,2,,void
55080,BLOCK,-1,,"{
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }",61,,38,2,,void
55151,BLOCK,-1,,"{
  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }

  return true;
}",50,,60,5,,void
55176,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }",52,,63,2,,void
55183,BLOCK,-1,,<empty>,7,,65,2,,void
55195,BLOCK,-1,,"{
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }",64,,66,2,,void
55205,BLOCK,-1,,<empty>,9,,68,2,,void
55218,BLOCK,-1,,"{
  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return nullptr;

  int signed_sig_len = EVP_PKEY_size(pkey.get());
  CHECK_GE(signed_sig_len, 0);
  size_t sig_len = static_cast<size_t>(signed_sig_len);
  std::unique_ptr<BackingStore> sig;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }
  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_sign_init(pkctx.get()) &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(), EVP_MD_CTX_md(mdctx.get())) &&
      EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
                    &sig_len, m, m_len)) {
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore:...",71,,79,6,,void
55231,BLOCK,-1,,<empty>,5,,84,2,,void
55258,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }",3,,90,10,,void
55328,BLOCK,-1,,"{
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore::Reallocate(env->isolate(), std::move(sig), sig_len);
    return sig;
  }",42,,100,2,,void
55339,BLOCK,-1,,<empty>,7,,103,2,,void
55352,BLOCK,-1,,<empty>,7,,105,1,,void
55377,BLOCK,-1,,"{
  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                         RSA_PKCS1_PADDING;
}",57,,112,2,,void
55393,BLOCK,-1,,"{
  int bits, base_id = EVP_PKEY_base_id(pkey.get());

  if (base_id == EVP_PKEY_DSA) {
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  } else if (base_id == EVP_PKEY_EC) {
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  } else {
    return kNoDsaSignature;
  }

  return (bits + 7) / 8;
}",55,,117,2,,void
55407,BLOCK,-1,,"{
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  }",32,,120,2,,void
55422,BLOCK,-1,,<empty>,10,,124,1,,void
55427,BLOCK,-1,,"{
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  }",38,,124,2,,void
55446,BLOCK,-1,,"{
    return kNoDsaSignature;
  }",10,,128,1,,void
55462,BLOCK,-1,,"{
  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
  if (!asn1_sig)
    return false;

  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());

  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
}",15,,139,5,,void
55473,BLOCK,-1,,<empty>,5,,142,2,,void
55514,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(signature);

  std::unique_ptr<BackingStore> buf;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }
  if (!ExtractP1363(static_cast<unsigned char*>(signature->Data()),
                    static_cast<unsigned char*>(buf->Data()),
                    signature->ByteLength(), n))
    return std::move(signature);

  return buf;
}",76,,152,4,,void
55524,BLOCK,-1,,<empty>,5,,155,2,,void
55538,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }",3,,158,5,,void
55578,BLOCK,-1,,<empty>,5,,165,2,,void
55593,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return ByteSource();

  const unsigned char* sig_data = signature.data<unsigned char>();

  ByteSource::Builder out(n * 2);
  memset(out.data<void>(), 0, n * 2);

  if (!ExtractP1363(sig_data, out.data<unsigned char>(), signature.size(), n))
    return ByteSource();

  return std::move(out).release();
}",34,,174,4,,void
55603,BLOCK,-1,,<empty>,5,,177,2,,void
55640,BLOCK,-1,,<empty>,5,,185,2,,void
55657,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(out);

  const unsigned char* sig_data = out.data<unsigned char>();

  if (out.size() != 2 * n)
    return ByteSource();

  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
  CHECK(asn1_sig);
  BIGNUM* r = BN_new();
  CHECK_NOT_NULL(r);
  BIGNUM* s = BN_new();
  CHECK_NOT_NULL(s);
  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));

  unsigned char* data = nullptr;
  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);

  if (len <= 0)
    return ByteSource();

  CHECK_NOT_NULL(data);

  return ByteSource::Allocated(data, len);
}",25,,192,3,,void
55667,BLOCK,-1,,<empty>,5,,195,2,,void
55690,BLOCK,-1,,<empty>,5,,200,2,,void
55751,BLOCK,-1,,<empty>,5,,216,2,,void
55768,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  switch (error) {
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_Si...",58,,223,3,,void
55777,BLOCK,-1,,"{
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignP...",18,,226,2,,void
55831,BLOCK,18,,"{
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }
      }",7,,240,18,,void
55838,BLOCK,-1,,<empty>,11,,243,2,,void
55845,BLOCK,-1,,"{
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }",24,,244,2,,void
55899,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }
}",43,,267,2,,void
55906,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }",35,,268,2,,void
55921,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }
}",54,,278,3,,void
55928,BLOCK,-1,,"{
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }",35,,279,2,,void
55944,BLOCK,-1,,"{
  CHECK_NULL(mdctx_);
  // Historically, ""dss1"" and ""DSS1"" were DSA aliases for SHA-1
  // exposed through the public API.
  if (strcmp(sign_type, ""dss1"") == 0 ||
      strcmp(sign_type, ""DSS1"") == 0) {
    sign_type = ""SHA1"";
  }
  const EVP_MD* md = EVP_get_digestbyname(sign_type);
  if (md == nullptr)
    return kSignUnknownDigest;

  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
    mdctx_.reset();
    return kSignInit;
  }

  return kSignOk;
}",55,,289,2,,void
55958,BLOCK,-1,,"{
    sign_type = ""SHA1"";
  }",39,,294,2,,void
55971,BLOCK,-1,,<empty>,5,,299,2,,void
55991,BLOCK,-1,,"{
    mdctx_.reset();
    return kSignInit;
  }",65,,302,2,,void
56005,BLOCK,-1,,"{
  if (mdctx_ == nullptr)
    return kSignNotInitialised;
  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
    return kSignUpdate;
  return kSignOk;
}",64,,310,3,,void
56010,BLOCK,-1,,<empty>,5,,312,2,,void
56022,BLOCK,-1,,<empty>,5,,314,2,,void
56032,BLOCK,-1,,<empty>,29,,319,3,,void
56037,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
}",57,,321,2,,void
56052,BLOCK,-1,,"{
  MakeWeak();
}",72,,325,3,,void
56059,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", SignInit);
  SetProtoMethod(isolate, t, ""update"", SignUpdate);
  SetProtoMethod(isolate, t, ""sign"", SignFinal);

  SetConstructorFunction(env->context(), target, ""Sign"", t);

  SignJob::Initialize(env, target);

  constexpr int kSignJobModeSign = SignConfiguration::kSign;
  constexpr int kSignJobModeVerify = SignConfiguration::kVerify;

  NODE_DEFINE_CONSTANT(target, kSignJobModeSign);
  NODE_DEFINE_CONSTANT(target, kSignJobModeVerify);
  NODE_DEFINE_CONSTANT(target, kSigEncDER);
  NODE_DEFINE_CONSTANT(target, kSigEncP1363);
  NODE_DEFINE_CONSTANT(target, RSA_PKCS1_PSS_PADDING);
}",63,,329,3,,void
56146,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(SignInit);
  registry->Register(SignUpdate);
  registry->Register(SignFinal);
  SignJob::RegisterExternalReferences(registry);
}",76,,353,2,,void
56176,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Sign(env, args.This());
}",57,,361,2,,void
56196,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, sign->Init(*sign_type));
}",62,,366,2,,void
56236,BLOCK,-1,,"{
  Decode<Sign>(args, [](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  });
}",64,,375,2,,void
56252,BLOCK,-1,,"{
  if (!mdctx_)
    return SignResult(kSignNotInitialised);

  EVPMDPointer mdctx = std::move(mdctx_);

  if (!ValidateDSAParameters(pkey.get()))
    return SignResult(kSignPrivateKey);

  std::unique_ptr<BackingStore> buffer =
      Node_SignFinal(env(), std::move(mdctx), pkey, padding, salt_len);
  Error error = buffer ? kSignOk : kSignPrivateKey;
  if (error == kSignOk && dsa_sig_enc == kSigEncP1363) {
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }
  return SignResult(error, std::move(buffer));
}",28,,390,5,,void
56256,BLOCK,-1,,<empty>,5,,392,2,,void
56275,BLOCK,-1,,<empty>,5,,397,2,,void
56312,BLOCK,-1,,"{
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }",56,,402,2,,void
56340,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  unsigned int offset = 0;
  ManagedEVPPKey key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, true);
  if (!key)
    return;

  int padding = GetDefaultSignPadding(key);
  if (!args[offset]->IsUndefined()) {
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }

  CHECK(args[offset + 2]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 2].As<Int32>()->Value());

  SignResult ret = sign->SignFinal(
      key,
      padding,
      salt_len,
      dsa_sig_enc);

  if (ret.error != kSignOk)
    return crypto::CheckThrow(env, ret.error);

  Local<ArrayBuffer> ab =
  ...",63,,409,2,,void
56376,BLOCK,-1,,<empty>,5,,419,2,,void
56391,BLOCK,-1,,"{
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }",37,,422,2,,void
56424,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }",41,,428,2,,void
56490,BLOCK,-1,,<empty>,5,,444,2,,void
56548,BLOCK,-1,,"{
  MakeWeak();
}",25,,453,3,,void
56555,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", VerifyInit);
  SetProtoMethod(isolate, t, ""update"", VerifyUpdate);
  SetProtoMethod(isolate, t, ""verify"", VerifyFinal);

  SetConstructorFunction(env->context(), target, ""Verify"", t);
}",65,,457,3,,void
56609,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(VerifyInit);
  registry->Register(VerifyUpdate);
  registry->Register(VerifyFinal);
}",78,,470,2,,void
56634,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Verify(env, args.This());
}",59,,477,2,,void
56654,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, verify->Init(*verify_type));
}",66,,482,2,,void
56694,BLOCK,-1,,"{
  Decode<Verify>(args, [](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  });
}",68,,491,2,,void
56711,BLOCK,-1,,"{
  if (!mdctx_)
    return kSignNotInitialised;

  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;
  *verify_result = false;
  EVPMDPointer mdctx = std::move(mdctx_);

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return kSignPublicKey;

  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }

  return kSignOk;
}",58,,507,6,,void
56715,BLOCK,-1,,<empty>,5,,509,2,,void
56742,BLOCK,-1,,<empty>,5,,517,2,,void
56785,BLOCK,-1,,"{
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }",70,,524,2,,void
56820,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ClearErrorOnReturn clear_error_on_return;

  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<char> hbuf(args[offset]);
  if (UNLIKELY(!hbuf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  int padding = GetDefaultSignPadding(pkey);
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 2]->IsUndefined()) {
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }

  CHECK(args[offset + 3]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 3].As<Int32>()->Value());

  ByteSource signa...",67,,533,2,,void
56855,BLOCK,-1,,<empty>,5,,544,2,,void
56869,BLOCK,-1,,<empty>,5,,548,2,,void
56889,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }",41,,551,2,,void
56926,BLOCK,-1,,"{
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }",41,,557,2,,void
56986,BLOCK,-1,,"{
    signature = ConvertSignatureToDER(pkey, hbuf.ToByteSource());
    if (signature.data() == nullptr)
      return crypto::CheckThrow(env, Error::kSignMalformedSignature);
  }",36,,567,2,,void
57002,BLOCK,-1,,<empty>,7,,570,2,,void
57030,BLOCK,-1,,<empty>,5,,577,2,,void
57050,BLOCK,-1,,<empty>,40,,591,2,,void
57055,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~SignConfiguration();
  return *new (this) SignConfiguration(std::move(other));
}",41,,594,2,,void
57061,BLOCK,-1,,<empty>,23,,595,2,,void
57083,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",66,,600,2,,void
57094,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,602,2,,void
57120,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // Sign Mode

  params->mode =
      static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  ManagedEVPPKey key;
  unsigned int keyParamOffset = offset + 1;
  if (params->mode == SignConfiguration::kVerify) {
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  } else {
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }
  if (!key)
    return Nothing<bool>();
  params->key = key;

  ArrayBufferOrViewContents<char> data(args[offset + 5]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (args[offset + 6]->IsString()) {
    Utf8Value digest(env->isolate(), args[offset + 6]);
  ...",32,,612,5,,void
57172,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  }",51,,625,2,,void
57183,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }",10,,627,1,,void
57197,BLOCK,-1,,<empty>,5,,631,2,,void
57219,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,635,2,,void
57250,BLOCK,-1,,"{
    Utf8Value digest(env->isolate(), args[offset + 6]);
    params->digest = EVP_get_digestbyname(*digest);
    if (params->digest == nullptr) {
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }
  }",37,,643,2,,void
57275,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }",36,,646,2,,void
57292,BLOCK,-1,,"{  // Salt length
    params->flags |= SignConfiguration::kHasSaltLength;
    params->salt_length = args[offset + 7].As<Int32>()->Value();
  }",36,,652,2,,void
57324,BLOCK,-1,,"{  // Padding
    params->flags |= SignConfiguration::kHasPadding;
    params->padding = args[offset + 8].As<Uint32>()->Value();
  }",37,,656,2,,void
57356,BLOCK,-1,,"{  // DSA Encoding
    params->dsa_encoding =
        static_cast<DSASigEnc>(args[offset + 9].As<Uint32>()->Value());
    if (params->dsa_encoding != kSigEncDER &&
        params->dsa_encoding != kSigEncP1363) {
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }
  }",37,,661,2,,void
57386,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }",47,,665,2,,void
57400,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 10]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    // If this is an EC key (assuming ECDSA) we need to convert the
    // the signature from WebCrypto format into DER format...
    ManagedEVPPKey m_pkey = params->key;
    Mutex::ScopedLock lock(*m_pkey.mutex());
    if (UseP1363Encoding(m_pkey, params->dsa_encoding)) {
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    } else {
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }
  }",51,,671,2,,void
57415,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,673,2,,void
57440,BLOCK,-1,,"{
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    }",57,,681,2,,void
57452,BLOCK,-1,,"{
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }",12,,684,1,,void
57478,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EVPMDPointer context(EVP_MD_CTX_new());
  EVP_PKEY_CTX* ctx = nullptr;

  switch (params.mode) {
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }

  int padding = params.flags & SignConfiguration::kHasPadding
      ? params.padding
      : GetDefaultSignPadding(params.key);

  Maybe<int> salt_length = params.flags & SignConfiguration::kHasSaltLength
      ? Just<int>(params.s...",22,,697,4,,void
57491,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }",24,,702,2,,void
57515,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,709,2,,void
57552,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,720,2,,void
57609,BLOCK,-1,,"{
    crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
    return false;
  }",25,,738,2,,void
57626,BLOCK,-1,,"{
    case SignConfiguration::kSign: {
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
 ...",24,,743,2,,void
57631,BLOCK,3,,"{
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(conte...",36,,744,3,,void
57637,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      }",34,,745,2,,void
57661,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",34,,752,2,,void
57702,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",50,,761,2,,void
57728,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(context.get(), nullptr, &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSignFinal(
                context.get(), buf.data<unsigned char>(), &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }

        if (UseP1363Encoding(params.key, params.dsa_encoding)) {
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        } else {
          *out = std::move(buf).release(len);
        }
      }",14,,766,1,,void
57759,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",65,,772,2,,void
57788,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",66,,778,2,,void
57809,BLOCK,-1,,"{
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        }",64,,783,2,,void
57827,BLOCK,-1,,"{
          *out = std::move(buf).release(len);
        }",16,,786,1,,void
57845,BLOCK,6,,"{
      ByteSource::Builder buf(1);
      buf.data<char>()[0] = 0;
      if (EVP_DigestVerify(
              context.get(),
              params.signature.data<unsigned char>(),
              params.signature.size(),
              params.data.data<unsigned char>(),
              params.data.size()) == 1) {
        buf.data<char>()[0] = 1;
      }
      *out = std::move(buf).release();
    }",38,,792,6,,void
57889,BLOCK,-1,,"{
        buf.data<char>()[0] = 1;
      }",41,,800,2,,void
57918,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,814,5,,void
57923,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }",24,,815,2,,void
57986,BLOCK,-1,,<empty>,1,,1,1,,ANY
58005,BLOCK,-1,,<empty>,1,,1,1,,ANY
58011,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki)
    return false;

  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
  if (!pkey)
    return false;

  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
}",64,,19,2,,void
58030,BLOCK,-1,,<empty>,5,,30,2,,void
58044,BLOCK,-1,,<empty>,5,,34,2,,void
58063,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  args.GetReturnValue().Set(VerifySpkac(input));
}",59,,39,2,,void
58084,BLOCK,-1,,<empty>,5,,43,2,,void
58100,BLOCK,-1,,<empty>,5,,46,2,,void
58119,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) return ByteSource();

  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki) return ByteSource();

  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
  if (!pkey) return ByteSource();

  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();

  return ByteSource::FromBIO(bio);
}",74,,52,3,,void
58122,BLOCK,-1,,<empty>,,,,2,,<empty>
58128,BLOCK,-1,,<empty>,13,,54,2,,void
58149,BLOCK,-1,,<empty>,14,,65,2,,void
58162,BLOCK,-1,,<empty>,14,,68,2,,void
58177,BLOCK,-1,,<empty>,57,,70,2,,void
58190,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0) return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource pkey = ExportPublicKey(env, input);
  if (!pkey) return args.GetReturnValue().SetEmptyString();

  args.GetReturnValue().Set(pkey.ToBuffer(env).FromMaybe(Local<Value>()));
}",63,,75,2,,void
58211,BLOCK,-1,,<empty>,26,,79,2,,void
58227,BLOCK,-1,,<empty>,5,,82,2,,void
58241,BLOCK,-1,,<empty>,14,,85,2,,void
58270,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer sp(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!sp)
    return ByteSource();

  unsigned char* buf = nullptr;
  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
  return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
}",74,,90,2,,void
58289,BLOCK,-1,,<empty>,5,,101,2,,void
58323,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource cert = ExportChallenge(input);
  if (!cert)
    return args.GetReturnValue().SetEmptyString();

  Local<Value> outString =
      Encode(env->isolate(), cert.data<char>(), cert.size(), BUFFER);

  args.GetReturnValue().Set(outString);
}",63,,108,2,,void
58344,BLOCK,-1,,<empty>,5,,113,2,,void
58360,BLOCK,-1,,<empty>,5,,116,2,,void
58373,BLOCK,-1,,<empty>,5,,120,2,,void
58415,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetMethodNoSideEffect(context, target, ""certVerifySpkac"", VerifySpkac);
  SetMethodNoSideEffect(
      context, target, ""certExportPublicKey"", ExportPublicKey);
  SetMethodNoSideEffect(
      context, target, ""certExportChallenge"", ExportChallenge);
}",57,,128,3,,void
58445,BLOCK,-1,,"{
  registry->Register(VerifySpkac);
  registry->Register(ExportPublicKey);
  registry->Register(ExportChallenge);
}",70,,137,2,,void
58473,BLOCK,-1,,<empty>,1,,1,1,,ANY
58492,BLOCK,-1,,<empty>,1,,1,1,,ANY
58498,BLOCK,-1,,"{
  // Moving the type checking into JS leads to test failures, most likely due
  // to V8 inlining certain parts of the wrapper. Therefore, keep them in C++.
  // Refs: https://github.com/nodejs/node/issues/34073.
  Environment* env = Environment::GetCurrent(args);
  if (!IsAnyByteSource(args[0])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }
  if (!IsAnyByteSource(args[1])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }

  ArrayBufferOrViewContents<char> buf1(args[0]);
  ArrayBufferOrViewContents<char> buf2(args[1]);

  if (buf1.size() != buf2.size()) {
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }

  return args.GetReturnValue().Set(
      CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
}",63,,19,2,,void
58513,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,24,2,,void
58524,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,30,2,,void
58549,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }",35,,40,2,,void
58581,BLOCK,-1,,"{
  SetMethodNoSideEffect(
      env->context(), target, ""timingSafeEqual"", TimingSafeEqual);
}",57,,49,3,,void
58594,BLOCK,-1,,"{
  registry->Register(TimingSafeEqual);
}",70,,53,2,,void
58610,BLOCK,-1,,<empty>,1,,1,1,,ANY
58616,BLOCK,-1,,"{
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      }",53,,347,4,,void
58633,BLOCK,-1,,"{
          InvokeQueued(0);
        }",66,,629,2,,void
58641,BLOCK,-1,,"{
      OnStreamAfterWrite(nullptr, 0);
    }",62,,661,2,,void
58650,BLOCK,-1,,{ return c == ' ' ? '_' : ToUpper(c); },37,,807,2,,void
58664,BLOCK,-1,,"{
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        }",66,,974,2,,void
58683,BLOCK,-1,,"{
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    }",17,,1205,8,,void
58724,BLOCK,-1,,<empty>,1,,1,1,,ANY
58733,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  *copy = 0;
  return w->ReleaseSession();
}",16,,71,5,,void
58755,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> hello_obj = Object::New(env->isolate());
  Local<String> servername = (hello.servername() == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(),
                      hello.servername(),
                      hello.servername_size());
  Local<Object> buf =
      Buffer::Copy(
          env,
          reinterpret_cast<const char*>(hello.session_id()),
          hello.session_size()).FromMaybe(Local<Object>());

  if ((buf.IsEmpty() ||
       hello_obj->Set(env->context(), env->session_id_string(), buf)
           .IsNothing()) ||
      hello_obj->Set(env->context(), env->servername_string(), servername)
          .IsNothing() ||
      hello_obj
          ->Set(env->context(),
                env->tls_ticket_string(),
                Boolean::New(env->isolate(), hello.ha...",50,,79,3,,void
58921,BLOCK,-1,,"{
    return;
  }",25,,106,2,,void
58944,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const size_t size = strlen(line);
  Local<Value> line_bf = Buffer::Copy(env, line, 1 + size)
      .FromMaybe(Local<Value>());
  if (UNLIKELY(line_bf.IsEmpty()))
    return;

  char* data = Buffer::Data(line_bf);
  data[size] = '\n';
  w->MakeCallback(env->onkeylog_string(), 1, &line_bf);
}",53,,114,3,,void
59001,BLOCK,-1,,<empty>,5,,124,2,,void
59032,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (!w->has_session_callbacks())
    return 0;

  // Check if session is small enough to be stored
  int size = i2d_SSL_SESSION(sess, nullptr);
  if (UNLIKELY(size > SecureContext::kMaxSessionSize))
    return 0;

  // Serialize session
  Local<Object> session = Buffer::New(env, size).FromMaybe(Local<Object>());
  if (UNLIKELY(session.IsEmpty()))
    return 0;

  unsigned char* session_data =
      reinterpret_cast<unsigned char*>(Buffer::Data(session));

  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);

  unsigned int session_id_length;
  const unsigned char* session_id_data =
      SSL_SESSION_get_id(sess, &session_id_length);

  Local<Object> session_id = Buffer::Copy(
      env,
      reinterpret_cast<const char*>(session_id_data),
      session_id_length).FromMaybe(Local<Object>());
  if...",51,,131,3,,void
59065,BLOCK,-1,,<empty>,5,,138,2,,void
59081,BLOCK,-1,,<empty>,5,,143,2,,void
59106,BLOCK,-1,,<empty>,5,,148,2,,void
59158,BLOCK,-1,,<empty>,5,,164,2,,void
59172,BLOCK,-1,,<empty>,5,,174,2,,void
59196,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));

  if (!w->is_server() || !w->is_waiting_cert_cb())
    return 1;

  if (w->is_cert_cb_running())
    // Not an error. Suspend handshake with SSL_ERROR_WANT_X509_LOOKUP, and
    // handshake will continue after certcb is done.
    return -1;

  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  w->set_cert_cb_running();

  Local<Object> info = Object::New(env->isolate());

  const char* servername = GetServerName(s);
  Local<String> servername_str = (servername == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(), servername, strlen(servername));

  Local<Value> ocsp = Boolean::New(
      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);

  if (info->Set(env->context(), env->servername_string(), servername_str)
          .IsNothing() ||
      info->Set(env->context(), env->ocsp_request_string(),...",40,,181,3,,void
59216,BLOCK,-1,,<empty>,5,,185,2,,void
59224,BLOCK,-1,,<empty>,5,,190,2,,void
59348,BLOCK,-1,,"{
    return 1;
  }",80,,209,2,,void
59385,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  if (w->alpn_callback_enabled_) {
    Environment* env = w->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> callback_arg =
        Buffer::Copy(env, reinterpret_cast<const char*>(in), inlen)
            .ToLocalChecked();

    MaybeLocal<Value> maybe_callback_result =
        w->MakeCallback(env->alpn_callback_string(), 1, &callback_arg);

    if (UNLIKELY(maybe_callback_result.IsEmpty())) {
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    Local<Value> callback_result = maybe_callback_result.ToLocalChecked();

    if (callback_result->IsUndefined()) {
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT...",16,,225,7,,void
59396,BLOCK,-1,,"{
    Environment* env = w->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> callback_arg =
        Buffer::Copy(env, reinterpret_cast<const char*>(in), inlen)
            .ToLocalChecked();

    MaybeLocal<Value> maybe_callback_result =
        w->MakeCallback(env->alpn_callback_string(), 1, &callback_arg);

    if (UNLIKELY(maybe_callback_result.IsEmpty())) {
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    Local<Value> callback_result = maybe_callback_result.ToLocalChecked();

    if (callback_result->IsUndefined()) {
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    CHECK(callback_result->IsNumber());
    unsigned int result...",34,,227,2,,void
59451,BLOCK,-1,,"{
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }",52,,238,2,,void
59469,BLOCK,-1,,"{
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }",41,,246,2,,void
59515,BLOCK,-1,,<empty>,28,,267,2,,void
59548,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());

  if (w->is_client()) {
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }

  // Outgoing response
  Local<ArrayBufferView> obj =
      w->ocsp_response().FromMaybe(Local<ArrayBufferView>());
  if (UNLIKELY(obj.IsEmpty()))
    return SSL_TLSEXT_ERR_NOACK;

  size_t len = obj->ByteLength();

  // OpenSSL takes control of the pointer after accepting it
  unsigned char* data = MallocOpenSSL<unsigned char>(len);
  obj->CopyContents(data, len);

  if (!SSL_set_tl...",45,,285,3,,void
59574,BLOCK,-1,,"{
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }",23,,290,2,,void
59594,BLOCK,-1,,<empty>,7,,294,2,,void
59628,BLOCK,-1,,<empty>,5,,307,2,,void
59655,BLOCK,-1,,<empty>,5,,316,2,,void
59668,BLOCK,-1,,"{
  // OCSP stapling
  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
}",48,,323,2,,void
59695,BLOCK,-1,,"{
  if (value == nullptr)
    return ignore_null;
  return !target->Set(
      env->context(),
      name,
      OneByteString(env->isolate(), value))
          .IsNothing();
}",30,,334,6,,void
59700,BLOCK,-1,,<empty>,5,,336,2,,void
59726,BLOCK,-1,,"{
  std::string ret;
  ERR_print_errors_cb(
      [](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      },
      static_cast<void*>(&ret));
  return ret;
}",27,,344,1,,void
59744,BLOCK,-1,,"{
  MakeWeak();
  CHECK(sc_);
  ssl_ = sc_->CreateSSL();
  CHECK(ssl_);

  sc_->SetGetSessionCallback(GetSessionCallback);
  sc_->SetNewSessionCallback(NewSessionCallback);

  StreamBase::AttachToObject(GetObject());
  stream->PushStreamListener(this);

  env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);

  InitSSL();
  Debug(this, ""Created new TLSWrap"");
}",15,,365,6,,void
59785,BLOCK,-1,,"{
  Destroy();
}",21,,383,1,,void
59790,BLOCK,-1,,"{
  if (ocsp_response_.IsEmpty())
    return MaybeLocal<ArrayBufferView>();
  return PersistentToLocal::Default(env()->isolate(), ocsp_response_);
}",60,,387,1,,void
59796,BLOCK,-1,,<empty>,5,,389,2,,void
59812,BLOCK,-1,,"{
  ocsp_response_.Reset();
}",35,,393,1,,void
59820,BLOCK,-1,,"{
  return next_sess_.release();
}",40,,397,1,,void
59831,BLOCK,-1,,"{
  Debug(this, ""Invoking queued write callbacks (%d, %s)"", status, error_str);
  if (!write_callback_scheduled_)
    return;

  if (current_write_) {
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }
}",63,,401,3,,void
59840,BLOCK,-1,,<empty>,5,,404,2,,void
59844,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }",23,,406,2,,void
59877,BLOCK,-1,,"{
  Debug(this, ""New session callback done"");
  Cycle();
}",34,,414,1,,void
59885,BLOCK,-1,,"{
  // Initialize SSL – OpenSSL takes ownership of these.
  enc_in_ = NodeBIO::New(env()).release();
  enc_out_ = NodeBIO::New(env()).release();

  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);

  // NOTE: This could be overridden in SetVerifyMode
  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);

#ifdef SSL_MODE_RELEASE_BUFFERS
  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
#endif  // SSL_MODE_RELEASE_BUFFERS

  // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
  // left sitting in the incoming enc_in_ and never get processed.
  // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);

#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
  // Configure BoringSSL to match OpenSSL's behavior.
  SSL_set_renegotiate_mode(ssl_.get(), ssl_renegotiate_fr...",25,,419,1,,void
59940,BLOCK,-1,,<empty>,5,,454,2,,void
59960,BLOCK,-1,,"{
    SSL_set_accept_state(ssl_.get());
  }",20,,460,2,,void
59967,BLOCK,-1,,<empty>,10,,462,1,,void
59970,BLOCK,-1,,"{
    // Enough space for server response (hello, cert)
    NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);
    SSL_set_connect_state(ssl_.get());
  }",27,,462,2,,void
59986,BLOCK,-1,,"{
    // Unexpected
    ABORT();
  }",10,,466,1,,void
59992,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsBoolean());

  Local<Object> sc = args[1].As<Object>();
  Kind kind = args[2]->IsTrue() ? Kind::kServer : Kind::kClient;

  StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
  CHECK_NOT_NULL(stream);

  Local<Object> obj;
  if (!env->tls_wrap_constructor_function()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return;
  }

  TLSWrap* res = new TLSWrap(env, obj, kind, stream, Unwrap<SecureContext>(sc));

  args.GetReturnValue().Set(res->object());
}",61,,472,2,,void
60094,BLOCK,-1,,"{
    return;
  }",28,,489,2,,void
60125,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(wrap, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer entirely or partiall if handle becomes closed
  while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",64,,498,2,,void
60172,BLOCK,-1,,"{
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",60,,508,2,,void
60221,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(!wrap->started_);
  wrap->started_ = true;

  // Send ClientHello handshake
  CHECK(wrap->is_client());
  // Seems odd to read when when we want to send, but SSL_read() triggers a
  // handshake if a session isn't established, and handshake will cause
  // encrypted data to become available for output.
  wrap->ClearOut();
  wrap->EncOut();
}",62,,520,2,,void
60259,BLOCK,-1,,"{
  if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
    return;

  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
  SSL* ssl = const_cast<SSL*>(ssl_);
  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
  Environment* env = c->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  Local<Object> object = c->object();

  if (where & SSL_CB_HANDSHAKE_START) {
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }

  // SSL_CB_HANDSHAKE_START and SSL_CB_HANDSHAKE_DONE are ca...",68,,536,4,,void
60267,BLOCK,-1,,<empty>,5,,538,2,,void
60315,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }",39,,548,2,,void
60347,BLOCK,-1,,"{
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }",60,,555,2,,void
60375,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_DONE);"");
    CHECK(!SSL_renegotiate_pending(ssl));
    Local<Value> callback;

    c->established_ = true;

    if (object->Get(env->context(), env->onhandshakedone_string())
          .ToLocal(&callback) && callback->IsFunction()) {
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }
  }",71,,564,2,,void
60416,BLOCK,-1,,"{
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }",58,,572,2,,void
60430,BLOCK,-1,,"{
  Debug(this, ""Trying to write encrypted output"");

  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }

  // Write in progress
  if (write_size_ != 0) {
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }

  // Wait for `newSession` callback to be invoked
  if (is_awaiting_new_session()) {
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }

  // Split-off queue
  if (established_ && current_write_) {
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }

  // No encrypted output ready to write to the underlying stream.
  if (BIO_pending(enc_out_) == 0) {
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cle...",24,,578,1,,void
60440,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }",33,,582,2,,void
60449,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }",25,,588,2,,void
60456,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }",34,,594,2,,void
60462,BLOCK,-1,,<empty>,7,,600,1,,void
60464,BLOCK,-1,,"{
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }",39,,600,2,,void
60475,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }",24,,605,2,,void
60485,BLOCK,-1,,"{
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cleartext_input_->ByteLength() == 0) {
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmedi...",35,,611,2,,void
60499,BLOCK,-1,,"{
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }
    }",54,,614,2,,void
60503,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      }",25,,615,2,,void
60510,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }",14,,618,1,,void
60562,BLOCK,-1,,<empty>,3,,645,1,,void
60602,BLOCK,-1,,"{
    InvokeQueued(res.err);
    return;
  }",21,,650,2,,void
60613,BLOCK,-1,,"{
    Debug(this, ""Write finished synchronously"");
    HandleScope handle_scope(env()->isolate());

    // Simulate asynchronous finishing, TLS cannot handle this at the moment.
    BaseObjectPtr<TLSWrap> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      OnStreamAfterWrite(nullptr, 0);
    });
  }",19,,655,2,,void
60640,BLOCK,-1,,"{
  Debug(this, ""OnStreamAfterWrite(status = %d)"", status);
  if (current_empty_write_) {
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }

  // Handle error
  if (status) {
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }

  // Commit
  NodeBIO::FromBIO(enc_out_)->Read(nullptr, write_size_);

  // Ensure that the progress will be made and `InvokeQueued` will be called.
  ClearIn();

  // Try writing more data
  write_size_ = 0;
  EncOut();
}",67,,667,3,,void
60647,BLOCK,-1,,"{
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }",29,,669,2,,void
60684,BLOCK,-1,,"{
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }",24,,679,2,,void
60693,BLOCK,-1,,"{
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }",15,,685,2,,void
60696,BLOCK,-1,,"{
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }",20,,686,2,,void
60722,BLOCK,-1,,"{
  Debug(this, ""Trying to read cleartext output"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }

  // No reads after EOF
  if (eof_) {
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;

  char out[kClearOutChunkSize];
  int read;
  for (;;) {
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS...",26,,707,1,,void
60732,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }",33,,710,2,,void
60739,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }",13,,716,2,,void
60748,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }",24,,721,2,,void
60757,BLOCK,-1,,<empty>,3,,730,1,,void
60758,BLOCK,4,,"{
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }
  }",12,,730,4,,void
60777,BLOCK,-1,,<empty>,7,,735,2,,void
60787,BLOCK,-1,,"{
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }",22,,738,2,,void
60805,BLOCK,-1,,<empty>,9,,743,2,,void
60824,BLOCK,-1,,"{
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }",28,,750,2,,void
60839,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Value> error;
    int err = SSL_get_error(ssl_.get(), read);
    switch (err) {
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib...",18,,766,2,,void
60862,BLOCK,-1,,"{
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_...",18,,770,2,,void
60868,BLOCK,-1,,"{
          eof_ = true;
          EmitRead(UV_EOF);
        }",20,,772,2,,void
60878,BLOCK,9,,"{
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_err);
          if (!Set(env(), obj, env()->library_string(), ls) ||
              !Set(env(), obj, env()->function_string(), fs) ||
              !Set(env(), obj, env()->reason_string(), rs, false))...",9,,780,9,,void
60902,BLOCK,-1,,<empty>,44,,784,2,,void
60933,BLOCK,-1,,<empty>,44,,788,2,,void
60948,BLOCK,-1,,<empty>,42,,790,2,,void
60968,BLOCK,-1,,<empty>,66,,792,2,,void
61016,BLOCK,-1,,<empty>,68,,799,2,,void
61053,BLOCK,-1,,<empty>,72,,809,2,,void
61067,BLOCK,-1,,<empty>,7,,821,2,,void
61080,BLOCK,-1,,"{
  Debug(this, ""Trying to write cleartext input"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }

  if (!pending_cleartext_input_ ||
      pending_cleartext_input_->ByteLength() == 0) {
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }

  std::unique_ptr<BackingStore> bs = std::move(pending_cleartext_input_);
  MarkPopErrorOnReturn mark_pop_error_on_return;

  NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
  Debug(this, ""Writing %zu bytes, written = %d"", bs->ByteLength(), written);
  CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));

  // All written
  if (written != -1) {
    Debug(this, ""Successfully wrote all dat...",25,,827,1,,void
61090,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }",33,,830,2,,void
61099,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }",24,,835,2,,void
61114,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }",52,,841,2,,void
61188,BLOCK,-1,,"{
    Debug(this, ""Successfully wrote all data to SSL"");
    return;
  }",22,,855,2,,void
61210,BLOCK,-1,,"{
    Debug(this, ""Got SSL error (%d)"", err);
    write_callback_scheduled_ = true;
    // TODO(@sam-github) Should forward an error object with
    // .code/.function/.etc, if possible.
    InvokeQueued(UV_EPROTO, GetBIOError().c_str());
    return;
  }",57,,862,2,,void
61238,BLOCK,-1,,"{
  std::string name = ""TLSWrap "";
  name += is_server() ? ""server ("" : ""client ("";
  name += std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
  return name;
}",46,,877,1,,void
61265,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",36,,884,1,,void
61273,BLOCK,-1,,"{
  return underlying_stream()->IsIPCPipe();
}",27,,888,1,,void
61282,BLOCK,-1,,"{
  return underlying_stream()->GetFD();
}",22,,892,1,,void
61291,BLOCK,-1,,"{
  return ssl_ &&
      underlying_stream() != nullptr &&
      underlying_stream()->IsAlive();
}",25,,896,1,,void
61306,BLOCK,-1,,"{
  return underlying_stream()->IsClosing();
}",27,,902,1,,void
61315,BLOCK,-1,,"{
  Debug(this, ""ReadStart()"");
  if (underlying_stream() != nullptr && !eof_)
    return underlying_stream()->ReadStart();
  return 0;
}",26,,906,1,,void
61326,BLOCK,-1,,<empty>,5,,909,2,,void
61337,BLOCK,-1,,"{
  Debug(this, ""ReadStop()"");
  return underlying_stream() != nullptr ? underlying_stream()->ReadStop() : 0;
}",25,,913,1,,void
61354,BLOCK,-1,,"{
  return error_.empty() ? nullptr : error_.c_str();
}",36,,918,1,,void
61369,BLOCK,-1,,"{
  error_.clear();
}",28,,922,1,,void
61381,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Debug(this, ""DoWrite()"");

  if (ssl_ == nullptr) {
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }

  size_t length = 0;
  size_t i;
  size_t nonempty_i = 0;
  size_t nonempty_count = 0;
  for (i = 0; i < count; i++) {
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }

  // We want to trigger a Write() on the underlying stream to drive the stream
  // system, but don't want to encrypt empty buffers into a TLS frame, so see
  // if we can find something to Write().
  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
  // or other internal messages to be encrypted. If it does, write them later
  // with EncOut().
  // If there is still no encrypted output, call Write(bufs) on the underlying
  // stream. Since the bufs are empty, it won't actually write non-TLS data
  // onto the socket, we just want the side-effects. After, make ...",48,,931,5,,void
61391,BLOCK,-1,,"{
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }",24,,935,2,,void
61412,BLOCK,-1,,<empty>,3,,945,1,,void
61421,BLOCK,4,,"{
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }",31,,945,4,,void
61437,BLOCK,-1,,"{
      nonempty_i = i;
      nonempty_count += 1;
    }",26,,947,2,,void
61448,BLOCK,-1,,"{
    Debug(this, ""Empty write"");
    ClearOut();
    if (BIO_pending(enc_out_) == 0) {
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }
  }",20,,963,2,,void
61458,BLOCK,-1,,"{
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }",37,,966,2,,void
61488,BLOCK,-1,,"{
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }",23,,972,2,,void
61518,BLOCK,-1,,"{
    EncOut();
    return 0;
  }",20,,987,2,,void
61538,BLOCK,-1,,"{
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }
    size_t offset = 0;
    for (i = 0; i < count; i++) {
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }

    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(length);
    written = SSL_write(ssl_.get(), bs->Data(), length);
  }",28,,1005,2,,void
61539,BLOCK,1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }",5,,1006,1,,void
61562,BLOCK,-1,,<empty>,5,,1011,1,,void
61571,BLOCK,4,,"{
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }",33,,1011,4,,void
61620,BLOCK,-1,,"{
    // Only one buffer: try to write directly, only store if it fails
    uv_buf_t* buf = &bufs[nonempty_i];
    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(buf->len);
    written = SSL_write(ssl_.get(), buf->base, buf->len);

    if (written == -1) {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }
  }",10,,1019,1,,void
61657,BLOCK,-1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }",24,,1025,2,,void
61707,BLOCK,-1,,"{
    // If we stopped writing because of an error, it's fatal, discard the data.
    int err = SSL_get_error(ssl_.get(), written);
    if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }

    Debug(this, ""Saving data for later write"");
    // Otherwise, save unwritten data so it can be written later by ClearIn().
    CHECK(!pending_cleartext_input_ ||
          pending_cleartext_input_->ByteLength() == 0);
    pending_cleartext_input_ = std::move(bs);
  }",22,,1035,2,,void
61725,BLOCK,-1,,"{
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }",59,,1038,2,,void
61769,BLOCK,-1,,"{
  CHECK_NOT_NULL(ssl_);

  size_t size = suggested_size;
  char* base = NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);
  return uv_buf_init(base, size);
}",56,,1061,2,,void
61797,BLOCK,-1,,"{
  Debug(this, ""Read %zd bytes from underlying stream"", nread);

  // Ignore everything after close_notify (rfc5246#section-7.2.1)
  if (eof_)
    return;

  if (nread < 0)  {
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }

  // DestroySSL() is the only thing that un-sets ssl_, but that also removes
  // this TLSWrap as a stream listener, so we should not receive OnStreamRead()
  // calls anymore.
  CHECK(ssl_);

  // Commit the amount of data actually read into the peeked/allocated buffer
  // from the underlying stream.
  NodeBIO* enc_in = NodeBIO::FromBIO(enc_in_);
  enc_in->Commit(nread);

  // Parse ClientHello first, if we need to. It's only parsed if session event
  // listeners are used on the server side.  ""ended"" is the initial state, so
  // can mean parsing was never started,...",64,,1069,3,,void
61804,BLOCK,-1,,<empty>,5,,1074,2,,void
61810,BLOCK,-1,,"{
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }",19,,1076,2,,void
61816,BLOCK,-1,,"{
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }",26,,1080,2,,void
61843,BLOCK,-1,,"{
    size_t avail = 0;
    uint8_t* data = reinterpret_cast<uint8_t*>(enc_in->Peek(&avail));
    CHECK_IMPLIES(data == nullptr, avail == 0);
    Debug(this, ""Passing %zu bytes to the hello parser"", avail);
    return hello_parser_.Parse(data, avail);
  }",33,,1103,2,,void
61882,BLOCK,-1,,"{
  return underlying_stream()->CreateShutdownWrap(req_wrap_object);
}",74,,1115,2,,void
61893,BLOCK,-1,,"{
  Debug(this, ""DoShutdown()"");
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
    SSL_shutdown(ssl_.get());

  shutdown_ = true;
  EncOut();
  return underlying_stream()->DoShutdown(req_wrap);
}",49,,1119,2,,void
61908,BLOCK,-1,,<empty>,5,,1124,2,,void
61928,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsBoolean());
  CHECK(args[1]->IsBoolean());
  CHECK_NOT_NULL(wrap->ssl_);

  int verify_mode;
  if (wrap->is_server()) {
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  } else {
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }

  // Always allow a connection. We'll reject in javascript.
  SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
}",70,,1131,2,,void
61967,BLOCK,-1,,"{
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  }",26,,1141,2,,void
61980,BLOCK,-1,,"{
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    }",24,,1143,2,,void
61985,BLOCK,-1,,"{
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }",12,,1146,1,,void
62000,BLOCK,-1,,<empty>,9,,1150,2,,void
62005,BLOCK,-1,,"{
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }",10,,1152,1,,void
62022,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);
  wrap->enable_session_callbacks();

  // Clients don't use the HelloParser.
  if (wrap->is_client())
    return;

  NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);
  wrap->hello_parser_.Start(OnClientHello,
                            OnClientHelloParseEnd,
                            wrap);
}",79,,1163,2,,void
62044,BLOCK,-1,,<empty>,5,,1171,2,,void
62070,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(wrap->sc_);
  wrap->sc_->SetKeylogCallback(KeylogCallback);
}",77,,1179,2,,void
62094,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

#if HAVE_SSL_TRACE
  if (wrap->ssl_) {
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }
#endif
}",68,,1196,2,,void
62107,BLOCK,-1,,"{
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }",19,,1201,2,,void
62144,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->Destroy();
  Debug(wrap, ""DestroySSL() finished"");
}",67,,1219,2,,void
62163,BLOCK,-1,,"{
  if (!ssl_)
    return;

  // If there is a write happening, mark it as finished.
  write_callback_scheduled_ = true;

  // And destroy
  InvokeQueued(UV_ECANCELED, ""Canceled because of SSL destruction"");

  env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  ssl_.reset();

  enc_in_ = nullptr;
  enc_out_ = nullptr;

  if (underlying_stream() != nullptr)
    underlying_stream()->RemoveStreamListener(this);

  sc_.reset();
}",25,,1226,1,,void
62167,BLOCK,-1,,<empty>,5,,1228,2,,void
62198,BLOCK,-1,,<empty>,5,,1243,2,,void
62212,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
}",69,,1248,2,,void
62232,BLOCK,-1,,"{
  cert_cb_ = cb;
  cert_cb_arg_ = arg;
}",51,,1254,3,,void
62243,BLOCK,-1,,"{
  TLSWrap* c = static_cast<TLSWrap*>(arg);
  Debug(c, ""OnClientHelloParseEnd()"");
  c->Cycle();
}",48,,1259,2,,void
62261,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->alpn_callback_enabled_ = true;

  SSL* ssl = wrap->ssl_.get();
  SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, wrap);
}",69,,1265,2,,void
62293,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_NOT_NULL(wrap->ssl_);

  const char* servername = GetServerName(wrap->ssl_.get());
  if (servername != nullptr) {
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  } else {
    args.GetReturnValue().Set(false);
  }
}",70,,1274,2,,void
62328,BLOCK,-1,,"{
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  }",30,,1283,2,,void
62343,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
  }",10,,1285,1,,void
62356,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  CHECK(!wrap->started_);
  CHECK(wrap->is_client());

  CHECK(wrap->ssl_);

  Utf8Value servername(env->isolate(), args[0].As<String>());
  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
}",70,,1290,2,,void
62427,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = p->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const char* servername = GetServerName(s);
  if (!Set(env, p->GetOwner(), env->servername_string(), servername))
    return SSL_TLSEXT_ERR_NOACK;

  Local<Value> ctx = p->object()->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());

  if (UNLIKELY(ctx.IsEmpty()) || !ctx->IsObject())
    return SSL_TLSEXT_ERR_NOACK;

  if (!env->secure_context_constructor_template()->HasInstance(ctx)) {
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }

  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
  CHECK_NOT_NULL(sc);
  p->sni_context_ = BaseObjectPtr<SecureContext>(sc);

  ConfigureSecureContext(sc);
  CHECK_E...",67,,1307,4,,void
62472,BLOCK,-1,,<empty>,5,,1315,2,,void
62512,BLOCK,-1,,<empty>,5,,1321,2,,void
62525,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }",70,,1323,2,,void
62610,BLOCK,-1,,"{
  int err = SSL_set1_verify_cert_store(ssl_.get(),
                                       SSL_CTX_get_cert_store(sc->ctx().get()));
  if (err != 1)
    return err;

  STACK_OF(X509_NAME)* list =
      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));

  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
  SSL_set_client_CA_list(ssl_.get(), list);
  return 1;
}",44,,1341,2,,void
62631,BLOCK,-1,,<empty>,5,,1345,2,,void
62660,BLOCK,-1,,"{
  TLSWrap* p;
  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
  CHECK_NOT_NULL(p->ssl_);

  Environment* env = p->env();
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsString());
  Utf8Value hint(isolate, args[0].As<String>());

  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }
}",75,,1357,2,,void
62714,BLOCK,-1,,"{
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }",57,,1368,2,,void
62741,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);

  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
}",74,,1374,2,,void
62777,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<String> identity_str =
      String::NewFromUtf8(env->isolate(), identity).FromMaybe(Local<String>());
  if (UNLIKELY(identity_str.IsEmpty()))
    return 0;

  // Make sure there are no utf8 replacement symbols.
  Utf8Value identity_utf8(env->isolate(), identity_str);
  if (identity_utf8 != identity) return 0;

  Local<Value> argv[] = {
    identity_str,
    Integer::NewFromUnsigned(env->isolate(), max_psk_len)
  };

  Local<Value> psk_val =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_buf(psk_val);

  if (psk_buf.length() > max_psk_len)
    return 0;

  memcpy(psk, psk_buf.data(), psk_buf.length());
  return psk_buf.length();
}",31,,1387,5,,void
62823,BLOCK,-1,,<empty>,5,,1396,2,,void
62837,BLOCK,-1,,<empty>,34,,1400,2,,void
62887,BLOCK,-1,,<empty>,5,,1411,2,,void
62900,BLOCK,-1,,<empty>,5,,1416,2,,void
62927,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<Value> argv[] = {
    Null(env->isolate()),
    Integer::NewFromUnsigned(env->isolate(), max_psk_len),
    Integer::NewFromUnsigned(env->isolate(), max_identity_len)
  };

  if (hint != nullptr) {
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }

  Local<Value> ret =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(ret.IsEmpty()) || !ret->IsObject())
    return 0;

  Local<Object> obj = ret.As<Object>();

  Local<Value> psk_val = obj->Get(env->context(), env->psk_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_bu...",31,,1428,7,,void
62979,BLOCK,-1,,"{
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }",24,,1440,2,,void
63005,BLOCK,-1,,<empty>,7,,1444,2,,void
63046,BLOCK,-1,,<empty>,5,,1453,2,,void
63093,BLOCK,-1,,<empty>,5,,1460,2,,void
63106,BLOCK,-1,,<empty>,5,,1464,2,,void
63143,BLOCK,-1,,<empty>,5,,1469,2,,void
63160,BLOCK,-1,,<empty>,5,,1474,2,,void
63190,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (!wrap->ssl_)
    return info.GetReturnValue().Set(0);

  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
  info.GetReturnValue().Set(write_queue_size);
}",74,,1484,2,,void
63204,BLOCK,-1,,<empty>,5,,1489,2,,void
63233,BLOCK,-1,,"{
  tracker->TrackField(""ocsp_response"", ocsp_response_);
  tracker->TrackField(""sni_context"", sni_context_);
  tracker->TrackField(""error"", error_);
  if (pending_cleartext_input_)
    tracker->TrackField(""pending_cleartext_input"", pending_cleartext_input_);
  if (enc_in_ != nullptr)
    tracker->TrackField(""enc_in"", NodeBIO::FromBIO(enc_in_));
  if (enc_out_ != nullptr)
    tracker->TrackField(""enc_out"", NodeBIO::FromBIO(enc_out_));
}",56,,1495,2,,void
63254,BLOCK,-1,,<empty>,5,,1500,2,,void
63265,BLOCK,-1,,<empty>,5,,1502,2,,void
63280,BLOCK,-1,,<empty>,5,,1504,2,,void
63295,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);

  Local<Object> object = w->object();
  Local<Value> ctx = object->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(ctx.IsEmpty()))
    return;

  Local<FunctionTemplate> cons = env->secure_context_constructor_template();
  if (cons->HasInstance(ctx)) {
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDon...",67,,1507,2,,void
63359,BLOCK,-1,,<empty>,5,,1518,2,,void
63377,BLOCK,-1,,"{
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }
  }",31,,1521,2,,void
63415,BLOCK,-1,,"{
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }",72,,1527,2,,void
63426,BLOCK,-1,,<empty>,10,,1533,1,,void
63432,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    w->MakeCallback(env->onerror_string(), 1, &err);
    return;
  }",31,,1533,2,,void
63492,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
    return env->ThrowTypeError(""Must give a Buffer as first argument"");

  ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
  SSL* ssl = w->ssl_.get();
  if (w->is_client()) {
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  } else {
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }
}",73,,1553,2,,void
63524,BLOCK,-1,,<empty>,5,,1558,2,,void
63556,BLOCK,-1,,"{
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  }",23,,1562,2,,void
63570,BLOCK,-1,,"{
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }",10,,1564,1,,void
63601,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();

  Local<Value> ret;
  if (GetPeerCert(
          env,
          w->ssl_,
          abbreviated,
          w->is_server()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1571,2,,void
63655,BLOCK,-1,,<empty>,5,,1584,2,,void
63668,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  X509Certificate::GetPeerCertificateFlag flag = w->is_server()
      ? X509Certificate::GetPeerCertificateFlag::SERVER
      : X509Certificate::GetPeerCertificateFlag::NONE;

  Local<Value> ret;
  if (X509Certificate::GetPeerCert(env, w->ssl_, flag).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,1587,2,,void
63722,BLOCK,-1,,<empty>,5,,1598,2,,void
63735,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  Local<Value> ret;
  if (GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",71,,1601,2,,void
63767,BLOCK,-1,,<empty>,5,,1608,2,,void
63780,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  Local<Value> ret;
  if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1611,2,,void
63815,BLOCK,-1,,<empty>,5,,1617,2,,void
63828,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buff...",68,,1620,2,,void
63863,BLOCK,-1,,<empty>,5,,1634,2,,void
63872,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1637,10,,void
63952,BLOCK,-1,,<empty>,68,,1647,2,,void
63966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_peer_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnV...",72,,1651,2,,void
64001,BLOCK,-1,,<empty>,5,,1665,2,,void
64010,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1668,10,,void
64090,BLOCK,-1,,<empty>,68,,1678,2,,void
64104,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  int slen = i2d_SSL_SESSION(sess, nullptr);
  if (slen <= 0)
    return;  // Invalid or malformed session.

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }

  unsigned char* p = static_cast<unsigned char*>(bs->Data());
  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,1682,2,,void
64135,BLOCK,-1,,<empty>,5,,1690,2,,void
64147,BLOCK,-1,,<empty>,5,,1694,2,,void
64156,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }",3,,1697,12,,void
64231,BLOCK,-1,,<empty>,68,,1707,2,,void
64245,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""Session argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""Session"");
  ArrayBufferViewContents<unsigned char> sbuf(args[0]);
  SSLSessionPointer sess = GetTLSSession(sbuf.data(), sbuf.length());
  if (sess == nullptr)
    return;  // TODO(tniessen): figure out error handling

  if (!SetTLSSession(w->ssl_, sess))
    return env->ThrowError(""SSL_set_session error"");
}",67,,1711,2,,void
64269,BLOCK,-1,,<empty>,5,,1718,2,,void
64301,BLOCK,-1,,<empty>,5,,1724,2,,void
64310,BLOCK,-1,,<empty>,5,,1727,2,,void
64321,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  bool yes = SSL_session_reused(w->ssl_.get());
  args.GetReturnValue().Set(yes);
}",72,,1730,2,,void
64352,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
  // peer certificate is questionable but it's compatible with what was
  // here before.
  long x509_verify_error =  // NOLINT(runtime/int)
      VerifyPeerCertificate(
          w->ssl_,
          X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT);

  if (x509_verify_error == X509_V_OK)
    return args.GetReturnValue().SetNull();

  const char* reason = X509_verify_cert_error_string(x509_verify_error);
  const char* code = X509ErrorCode(x509_verify_error);

  Local<Object> error =
      Exception::Error(OneByteString(env->isolate(), reason))
          ->ToObject(env->isolate()->GetCurrentContext())
              .FromMaybe(Local<Object>());

  if (Set(env, error, env->code_string(), code))
    args.GetReturnValue().Set(error);
}",68,,1737,2,,void
64381,BLOCK,-1,,<empty>,5,,1751,2,,void
64439,BLOCK,-1,,<empty>,5,,1762,2,,void
64452,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
}",66,,1765,2,,void
64489,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // TODO(@sam-github) check arg length and types in js, and CHECK in c++
  if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }
}",68,,1773,2,,void
64513,BLOCK,-1,,"{
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }",59,,1778,2,,void
64548,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL* ssl = w->ssl_.get();
  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                    nullptr);
  MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);

  for (int i = 0; i < nsig; i++) {
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#...",73,,1789,2,,void
64589,BLOCK,-1,,<empty>,3,,1799,1,,void
64599,BLOCK,4,,"{
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char*...",34,,1799,4,,void
64615,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char* sn = OBJ_nid2sn(sign_nid);

        if (sn != nullptr) {
          sig_with_md = std::string(sn) + ""+"";
        } else {
          sig_with_md = ""UNDEF+"";
        }
        break;
    }",23,,1807,2,,void
64680,BLOCK,-1,,"{
          sig_with_md = std::string(sn) + ""+"";
        }",28,,1847,2,,void
64691,BLOCK,-1,,"{
          sig_with_md = ""UNDEF+"";
        }",16,,1849,1,,void
64705,BLOCK,-1,,"{
      sig_with_md += std::string(sn_hash);
    }",29,,1856,2,,void
64714,BLOCK,-1,,"{
      sig_with_md += ""UNDEF"";
    }",12,,1858,1,,void
64758,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsString());

  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  uint32_t olen = args[0].As<Uint32>()->Value();
  Utf8Value label(env->isolate(), args[1]);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }

  ByteSource context;
  bool use_context = !args[2]->IsUndefined();
  if (use_context)
    context = ByteSource::FromBuffer(args[2]);

  if (SSL_export_keying_material(
          w->ssl_.get(),
          static_cast<unsigned char*>(bs->Data()),
          olen,
          *label,
          label.length(),
          context.data<unsigned char>(),
          context.size(),
          use_context) != 1) {
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }

  Local<ArrayBuffer> ab = ArrayBu...",77,,1868,2,,void
64817,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }",3,,1880,12,,void
64848,BLOCK,-1,,<empty>,5,,1888,2,,void
64890,BLOCK,-1,,"{
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }",30,,1898,2,,void
64938,BLOCK,-1,,<empty>,68,,1907,2,,void
64952,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->hello_parser_.End();
}",66,,1911,2,,void
64971,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  if (SSL_renegotiate(w->ssl_.get()) != 1)
    return ThrowCryptoError(w->env(), ERR_get_error());
}",68,,1917,2,,void
64991,BLOCK,-1,,<empty>,5,,1922,2,,void
65003,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  const unsigned char* ticket;
  size_t length;
  SSL_SESSION_get0_ticket(sess, &ticket, &length);

  if (ticket != nullptr) {
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }
}",69,,1925,2,,void
65033,BLOCK,-1,,<empty>,5,,1932,2,,void
65047,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }",26,,1938,2,,void
65072,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->awaiting_new_session_ = false;
  w->NewSessionDoneCb();
}",71,,1945,2,,void
65094,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""OCSP response argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""OCSP response"");

  w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<ArrayBufferView>());
}",72,,1952,2,,void
65117,BLOCK,-1,,<empty>,5,,1958,2,,void
65148,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
}",68,,1965,2,,void
65169,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK(w->ssl_);

  // tmp key is available on only client
  if (w->is_server())
    return args.GetReturnValue().SetNull();

  args.GetReturnValue().Set(GetEphemeralKey(env, w->ssl_)
      .FromMaybe(Local<Value>()));

  // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
  // ERR_get_error())
}",76,,1972,2,,void
65195,BLOCK,-1,,<empty>,5,,1981,2,,void
65224,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
}",68,,1990,2,,void
65264,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  const unsigned char* alpn_proto;
  unsigned int alpn_proto_len;

  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);

  Local<Value> result;
  if (alpn_proto_len == 0) {
    result = False(env->isolate());
  } else if (alpn_proto_len == sizeof(""h2"") - 1 &&
             0 == memcmp(alpn_proto, ""h2"", sizeof(""h2"") - 1)) {
    result = env->h2_string();
  } else if (alpn_proto_len == sizeof(""http/1.1"") - 1 &&
             0 == memcmp(alpn_proto, ""http/1.1"", sizeof(""http/1.1"") - 1)) {
    result = env->http_1_1_string();
  } else {
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }

  args.GetReturnValue().Set(result);
}",79,,1998,2,,void
65303,BLOCK,-1,,"{
    result = False(env->isolate());
  }",28,,2009,2,,void
65312,BLOCK,-1,,<empty>,10,,2011,1,,void
65330,BLOCK,-1,,"{
    result = env->h2_string();
  }",63,,2012,2,,void
65338,BLOCK,-1,,<empty>,10,,2014,1,,void
65356,BLOCK,-1,,"{
    result = env->http_1_1_string();
  }",75,,2015,2,,void
65364,BLOCK,-1,,"{
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }",10,,2017,1,,void
65385,BLOCK,-1,,"{
  // Prevent recursion
  if (++cycle_depth_ > 1)
    return;

  for (; cycle_depth_ > 0; cycle_depth_--) {
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }
}",23,,2024,1,,void
65391,BLOCK,-1,,<empty>,5,,2027,2,,void
65394,BLOCK,-1,,<empty>,3,,2029,1,,void
65400,BLOCK,4,,"{
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }",44,,2029,4,,void
65411,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""wrap"", TLSWrap::Wrap);

  NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE);

  Local<FunctionTemplate> t = BaseObject::MakeLazilyInitializedJSTemplate(env);
  Local<String> tlsWrapString =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""TLSWrap"");
  t->SetClassName(tlsWrapString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  Local<FunctionTemplate> get_write_queue_size =
      FunctionTemplate::New(env->isolate(),
                            GetWriteQueueSize,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));
  t->PrototypeTemplate()->SetAccessorProperty(
      env->write_queue_size_string(),
      get_write_queue_size,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete));

  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  S...",17,,2054,5,,void
65438,BLOCK,1,,<empty>,,,,6,,void
65440,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE)",3,,2060,1,,void
65857,BLOCK,-1,,"{
  registry->Register(TLSWrap::Wrap);
  registry->Register(GetWriteQueueSize);

  registry->Register(CertCbDone);
  registry->Register(DestroySSL);
  registry->Register(EnableCertCb);
  registry->Register(EnableALPNCb);
  registry->Register(EndParser);
  registry->Register(EnableKeylogCallback);
  registry->Register(EnableSessionCallbacks);
  registry->Register(EnableTrace);
  registry->Register(GetServername);
  registry->Register(LoadSession);
  registry->Register(NewSessionDone);
  registry->Register(Receive);
  registry->Register(Renegotiate);
  registry->Register(RequestOCSP);
  registry->Register(SetALPNProtocols);
  registry->Register(SetOCSPResponse);
  registry->Register(SetServername);
  registry->Register(SetSession);
  registry->Register(SetVerifyMode);
  registry->Register(Start);
  registry->Register(ExportKeyingMaterial);
  registry->Register(IsSessionReused);
  registry->Register(GetALPNNegotiatedProto);
  registry->Register(GetCertificate);
  registry->Register(Get...",79,,2143,2,,void
66083,BLOCK,-1,,<empty>,1,,1,1,,ANY
66089,BLOCK,-1,,"{
        OPENSSL_clear_free(deleter_data, length);
      }",57,,358,4,,void
66101,BLOCK,-1,,"{
            OPENSSL_secure_clear_free(data, len);
          }",58,,728,4,,void
66142,BLOCK,-1,,<empty>,1,,1,1,,ANY
66148,BLOCK,-1,,"{
  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:
  //
  //   If VerifyCallback returns 1, the verification process is continued. If
  //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
  //   terminated with respect to verification failures and the connection will
  //   be established. The calling process can however retrieve the error code
  //   of the last verification error using SSL_get_verify_result(3) or by
  //   maintaining its own error storage managed by VerifyCallback.
  //
  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
  // this callback, we ignore all preverify_ok errors and let the handshake
  // continue. It is imperative that the user use Connection::VerifyError after
  // the 'secure' callback has been made.
  return 1;
}",59,,46,3,,void
66157,BLOCK,-1,,"{
  unsigned char* buf = static_cast<unsigned char*>(buffer);
  do {
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
 ...",66,,63,3,,void
66165,BLOCK,-1,,"{
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
    }
#endif
  }",6,,65,1,,void
66170,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }",29,,66,2,,void
66181,BLOCK,-1,,"{
        buf += INT_MAX;
        length -= INT_MAX;
      }",65,,70,2,,void
66200,BLOCK,-1,,<empty>,9,,75,2,,void
66213,BLOCK,-1,,"{
  const ByteSource* passphrase = *static_cast<const ByteSource**>(u);
  if (passphrase != nullptr) {
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }

  return -1;
}",64,,97,5,,void
66225,BLOCK,-1,,"{
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }",30,,99,2,,void
66243,BLOCK,-1,,<empty>,7,,103,2,,void
66266,BLOCK,-1,,"{
  return 0;
}",66,,116,5,,void
66272,BLOCK,-1,,"{
  /* Override FIPS settings in configuration file, if needed. */
  if (per_process::cli_options->enable_fips_crypto ||
      per_process::cli_options->force_fips_crypto) {
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }
  return true;
}",27,,120,1,,void
66285,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }",52,,123,2,,void
66290,BLOCK,-1,,<empty>,27,,133,2,,void
66300,BLOCK,-1,,"{
  static uv_once_t init_once = UV_ONCE_INIT;
  TryCatch try_catch{isolate};
  uv_once(&init_once, InitCryptoOnce);
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
    return false;
  }
  return true;
}",39,,140,2,,void
66325,BLOCK,-1,,"{
    try_catch.ReThrow();
    return false;
  }",60,,144,2,,void
66338,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);
#ifndef OPENSSL_IS_BORINGSSL
  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();

#if OPENSSL_VERSION_MAJOR < 3
  // --openssl-config=...
  if (!per_process::cli_options->openssl_config.empty()) {
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }
#endif

#if OPENSSL_VERSION_MAJOR >= 3
  // --openssl-legacy-provider
  if (per_process::cli_options->openssl_legacy_provider) {
    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, ""legacy"");
    if (legacy_provider == nullptr) {
      fprintf(stderr, ""Unable to load legacy provider.\n"");
    }
  }
#endif

  OPENSSL_init_ssl(0, settings);
  OPENSSL_INIT_free(settings);
  settings = nullptr;

#ifndef _WIN32
  if (per_process::cli_options->secure_heap != 0) {
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure...",23,,155,1,,void
66361,BLOCK,-1,,"{
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }",58,,163,2,,void
66392,BLOCK,-1,,"{
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure_heap,
                static_cast<int>(per_process::cli_options->secure_heap_min))) {
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }
  }",51,,184,2,,void
66407,BLOCK,-1,,"{
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }",79,,187,2,,void
66430,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
      1 : 0);
#else
  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
#endif
}",61,,214,2,,void
66454,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

  CHECK(!per_process::cli_options->force_fips_crypto);
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());
  bool enable = args[0]->BooleanValue(env->isolate());

#if OPENSSL_VERSION_MAJOR >= 3
  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
#else
  if (static_cast<int>(enable) == FIPS_mode())
#endif
    return;  // No action needed.

#if OPENSSL_VERSION_MAJOR >= 3
  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
#else
  if (!FIPS_mode_set(enable)) {
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }
}",61,,226,2,,void
66502,BLOCK,-1,,<empty>,5,,240,2,,void
66508,BLOCK,-1,,"{
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }",31,,245,2,,void
66521,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  OSSL_PROVIDER* fips_provider = nullptr;
  if (OSSL_PROVIDER_available(nullptr, ""fips"")) {
    fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
  }
  const auto enabled = fips_provider == nullptr ? 0 :
      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
#else
#ifdef OPENSSL_FIPS
  const auto enabled = FIPS_selftest() ? 1 : 0;
#else  // OPENSSL_FIPS
  const auto enabled = 0;
#endif  // OPENSSL_FIPS
#endif

  args.GetReturnValue().Set(enabled);
}",70,,252,2,,void
66545,BLOCK,-1,,"{
  errors_.clear();
  while (const uint32_t err = ERR_get_error()) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }
  std::reverse(std::begin(errors_), std::end(errors_));
}",34,,274,1,,void
66551,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }",48,,276,1,,void
66580,BLOCK,-1,,"{
  return errors_.empty();
}",38,,284,1,,void
66591,BLOCK,-1,,"{
  if (exception_string.IsEmpty()) {
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }

  Local<Value> exception_v = Exception::Error(exception_string);
  CHECK(!exception_v.IsEmpty());

  if (!Empty()) {
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->conte...",43,,290,3,,void
66597,BLOCK,-1,,"{
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }",35,,291,2,,void
66607,BLOCK,-1,,"{
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }",23,,293,2,,void
66655,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",67,,305,2,,void
66691,BLOCK,-1,,"{
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->context(), errors_).ToLocal(&stack) ||
        exception->Set(env->context(), env->openssl_error_stack(), stack)
            .IsNothing()) {
      return MaybeLocal<Value>();
    }
  }",17,,315,2,,void
66742,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",27,,321,2,,void
66751,BLOCK,-1,,"{
  other.allocated_data_ = nullptr;
}",26,,332,2,,void
66760,BLOCK,-1,,"{
  OPENSSL_clear_free(allocated_data_, size_);
}",27,,336,1,,void
66768,BLOCK,-1,,"{
  if (&other != this) {
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }
  return *this;
}",64,,340,2,,void
66774,BLOCK,-1,,"{
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }",23,,341,2,,void
66804,BLOCK,-1,,"{
  // It's ok for allocated_data_ to be nullptr but
  // only if size_ is zero.
  CHECK_IMPLIES(size_ > 0, allocated_data_ != nullptr);
  std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
      allocated_data_,
      size(),
      [](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }, allocated_data_);
  CHECK(ptr);
  allocated_data_ = nullptr;
  data_ = nullptr;
  size_ = 0;
  return ptr;
}",67,,351,1,,void
66844,BLOCK,-1,,"{
  std::unique_ptr<BackingStore> store = ReleaseToBackingStore();
  return ArrayBuffer::New(env->isolate(), std::move(store));
}",64,,368,2,,void
66872,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ToArrayBuffer(env);
  return Buffer::New(env, ab, 0, ab->ByteLength());
}",63,,373,2,,void
66897,BLOCK,-1,,"{
  CHECK(bio);
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio.get(), &bptr);
  ByteSource::Builder out(bptr->length);
  memcpy(out.data<void>(), bptr->data, bptr->length);
  return std::move(out).release();
}",55,,378,2,,void
66939,BLOCK,-1,,"{
  size_t length = 0;
  ByteSource out;

  if (StringBytes::Size(env->isolate(), key, enc).To(&length) && length > 0) {
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }

  return out;
}",61,,389,4,,void
66965,BLOCK,-1,,"{
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }",78,,393,2,,void
67005,BLOCK,-1,,"{
  return IsAnyByteSource(value) ? FromBuffer(value)
                                : FromString(env, value.As<String>());
}",63,,404,3,,void
67024,BLOCK,-1,,"{
  CHECK(str->IsString());
  size_t size = str->Utf8Length(env->isolate());
  size_t alloc_size = ntc ? size + 1 : size;
  ByteSource::Builder out(alloc_size);
  int opts = String::NO_OPTIONS;
  if (!ntc) opts |= String::NO_NULL_TERMINATION;
  str->WriteUtf8(env->isolate(), out.data<char>(), alloc_size, nullptr, opts);
  return std::move(out).release();
}",45,,410,4,,void
67062,BLOCK,-1,,<empty>,13,,416,2,,void
67097,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> buf(buffer);
  return ntc ? buf.ToNullTerminatedCopy() : buf.ToByteSource();
}",66,,421,3,,void
67117,BLOCK,-1,,"{
  // A key can be passed as a string, buffer or KeyObject with type 'secret'.
  // If it is a string, we need to convert it to a buffer. We are not doing that
  // in JS to avoid creating an unprotected copy on the heap.
  return value->IsString() || IsAnyByteSource(value) ?
           ByteSource::FromStringOrBuffer(env, value) :
           ByteSource::FromSymmetricKeyObjectHandle(value);
}",25,,428,3,,void
67143,BLOCK,-1,,"{
  return Buffer::HasInstance(value) ? FromBuffer(value, true)
                                    : FromString(env, value.As<String>(), true);
}",63,,438,3,,void
67165,BLOCK,-1,,"{
  CHECK(handle->IsObject());
  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(handle.As<Object>());
  CHECK_NOT_NULL(key);
  return Foreign(key->Data()->GetSymmetricKey(),
                 key->Data()->GetSymmetricKeySize());
}",74,,443,2,,void
67205,BLOCK,-1,,"{
  return ByteSource(data, data, size);
}",59,,451,3,,void
67216,BLOCK,-1,,"{
  return ByteSource(data, nullptr, size);
}",63,,455,3,,void
67229,BLOCK,-1,,"{  // NOLINT(runtime/int)
  if (err == 0) return Just(true);  // No decoration necessary.

  const char* ls = ERR_lib_error_string(err);
  const char* fs = ERR_func_error_string(err);
  const char* rs = ERR_reason_error_string(err);

  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (ls != nullptr) {
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (fs != nullptr) {
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (rs != nullptr) {
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // wh...",34,,461,4,,void
67234,BLOCK,-1,,<empty>,17,,462,2,,void
67274,BLOCK,-1,,"{
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,471,2,,void
67291,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,473,2,,void
67298,BLOCK,-1,,"{
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,477,2,,void
67315,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,479,2,,void
67322,BLOCK,-1,,"{
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // which ends up being close to the original error macro name.
    std::string reason(rs);

    for (auto& c : reason) {
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }

#define OSSL_ERROR_CODES_MAP(V)                                               \
    V(SYS)                                                                    \
    V(BN)                                                                     \
    V(RSA)                                                                    \
    V(DH)                                                                     \
    V(EVP)                                                                    \
    V(BUF)          ...",22,,483,2,,void
67339,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,485,2,,void
67348,BLOCK,-1,,"{
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }",28,,494,3,,void
67353,BLOCK,-1,,<empty>,9,,496,2,,void
67358,BLOCK,-1,,<empty>,9,,498,1,,void
67374,BLOCK,-1,,{ OSSL_ERROR_CODES_MAP(V) },31,,543,2,,void
67376,BLOCK,1,,<empty>,,,,1,,void
67607,BLOCK,-1,,<empty>,7,,548,2,,void
67648,BLOCK,-1,,<empty>,7,,559,2,,void
67660,BLOCK,-1,,"{
  char message_buffer[128] = {0};
  if (err != 0 || message == nullptr) {
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }
  HandleScope scope(env->isolate());
  Local<String> exception_string;
  Local<Value> exception;
  Local<Object> obj;
  if (!String::NewFromUtf8(env->isolate(), message).ToLocal(&exception_string))
    return;
  CryptoErrorStore errors;
  errors.Capture();
  if (!errors.ToException(env, exception_string).ToLocal(&exception) ||
      !exception->ToObject(env->context()).ToLocal(&obj) ||
      error::Decorate(env, obj, err).IsNothing()) {
    return;
  }
  env->isolate()->ThrowException(exception);
}",44,,570,4,,void
67674,BLOCK,-1,,"{
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }",39,,572,2,,void
67720,BLOCK,-1,,<empty>,5,,581,2,,void
67766,BLOCK,-1,,"{
    return;
  }",51,,586,2,,void
67781,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;

  EnginePointer engine(ENGINE_by_id(id));
  if (!engine) {
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }

  if (!engine && errors != nullptr) {
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }

  return engine;
}",72,,593,3,,void
67790,BLOCK,-1,,"{
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }",16,,597,2,,void
67798,BLOCK,-1,,"{
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }",17,,600,2,,void
67819,BLOCK,-1,,"{
        engine.reset();
      }",70,,602,2,,void
67831,BLOCK,-1,,"{
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }",37,,608,2,,void
67841,BLOCK,-1,,"{
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }",26,,610,2,,void
67858,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EnginePointer engine = LoadEngineById(id, errors);
  if (!engine)
    return false;

  if (!ENGINE_set_default(engine.get(), flags)) {
    if (errors != nullptr)
      errors->Capture();
    return false;
  }

  return true;
}",74,,618,4,,void
67869,BLOCK,-1,,<empty>,5,,622,2,,void
67880,BLOCK,-1,,"{
    if (errors != nullptr)
      errors->Capture();
    return false;
  }",49,,624,2,,void
67885,BLOCK,-1,,<empty>,7,,626,2,,void
67898,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.Length() >= 2 && args[0]->IsString());
  uint32_t flags;
  if (!args[1]->Uint32Value(env->context()).To(&flags)) return;

  const node::Utf8Value engine_id(env->isolate(), args[0]);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  args.GetReturnValue().Set(SetEngine(*engine_id, flags));
}",57,,633,2,,void
67939,BLOCK,-1,,<empty>,57,,637,2,,void
67959,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,641,2,,void
67982,BLOCK,-1,,"{
  std::vector<uint8_t> buf(size);
  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
  return StringBytes::Encode(
      env->isolate(),
      reinterpret_cast<const char*>(buf.data()),
      buf.size(),
      BASE64URL,
      error);
}",26,,656,5,,void
68029,BLOCK,-1,,"{
  Local<Value> value;
  Local<Value> error;
  CHECK_NOT_NULL(bn);
  if (size == 0)
    size = BN_num_bytes(bn);
  if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  return target->Set(env->context(), name, value);
}",15,,672,6,,void
68046,BLOCK,-1,,<empty>,5,,677,2,,void
68064,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",61,,678,2,,void
68071,BLOCK,-1,,<empty>,7,,680,2,,void
68098,BLOCK,-1,,"{
  if (label.size() != 0) {
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }
  return true;
}",76,,686,3,,void
68106,BLOCK,-1,,"{
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }",26,,687,2,,void
68140,BLOCK,-1,,"{
      OPENSSL_free(label_copy);
      return false;
    }",19,,693,2,,void
68151,BLOCK,-1,,"{
  CHECK(args->IsUint32());
  uint32_t mode = args.As<v8::Uint32>()->Value();
  CHECK_LE(mode, kCryptoJobSync);
  return static_cast<CryptoJobMode>(mode);
}",59,,701,2,,void
68179,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t len = args[0].As<Uint32>()->Value();
  void* data = OPENSSL_secure_zalloc(len);
  if (data == nullptr) {
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(
          data,
          len,
          [](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          },
          data);
  Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
  args.GetReturnValue().Set(Uint8Array::New(buffer, 0, len));
}",60,,714,2,,void
68214,BLOCK,-1,,"{
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }",24,,719,2,,void
68265,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (CRYPTO_secure_malloc_initialized())
    args.GetReturnValue().Set(
        BigInt::New(env->isolate(), CRYPTO_secure_used()));
}",62,,736,2,,void
68276,BLOCK,-1,,<empty>,5,,739,2,,void
68299,BLOCK,-1,,"{
  Local<Context> context = env->context();
#ifndef OPENSSL_NO_ENGINE
  SetMethod(context, target, ""setEngine"", SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  SetMethodNoSideEffect(context, target, ""getFipsCrypto"", GetFipsCrypto);
  SetMethod(context, target, ""setFipsCrypto"", SetFipsCrypto);
  SetMethodNoSideEffect(context, target, ""testFipsCrypto"", TestFipsCrypto);

  NODE_DEFINE_CONSTANT(target, kCryptoJobAsync);
  NODE_DEFINE_CONSTANT(target, kCryptoJobSync);

  SetMethod(context, target, ""secureBuffer"", SecureBuffer);
  SetMethod(context, target, ""secureHeapUsed"", SecureHeapUsed);
}",57,,745,3,,void
68335,BLOCK,1,,<empty>,,,,7,,void
68337,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobAsync)",3,,755,1,,void
68434,BLOCK,1,,<empty>,,,,7,,void
68436,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobSync)",3,,756,1,,void
68542,BLOCK,-1,,"{
#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  registry->Register(GetFipsCrypto);
  registry->Register(SetFipsCrypto);
  registry->Register(TestFipsCrypto);
  registry->Register(SecureBuffer);
  registry->Register(SecureHeapUsed);
}",70,,761,2,,void
68629,BLOCK,-1,,<empty>,1,,1,1,,ANY
68660,BLOCK,-1,,<empty>,1,,1,1,,ANY
68665,BLOCK,-1,,<empty>,71,,33,2,,void
68670,BLOCK,-1,,"{
  *this = that;
}",51,,35,2,,void
68679,BLOCK,-1,,"{
  cert_.reset(that.get());

  if (cert_)
    X509_up_ref(cert_.get());

  return *this;
}",62,,39,2,,void
68690,BLOCK,-1,,<empty>,5,,43,2,,void
68703,BLOCK,-1,,"{
  // This is an approximation based on the der encoding size.
  int size = i2d_X509(cert_.get(), nullptr);
  tracker->TrackFieldWithSize(""cert"", size);
}",60,,48,2,,void
68724,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",59,,56,2,,void
68759,BLOCK,-1,,<empty>,5,,62,2,,void
68772,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->x509_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", Ke...",23,,67,2,,void
68788,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", KeyUsage);
    SetProtoMethod(isolate, tmpl, ""serialNumber"", SerialNumber);
    SetProtoMetho...",23,,69,2,,void
68948,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",75,,104,3,,void
68963,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return MaybeLocal<Object>();

  X509Pointer ptr(X509_dup(cert));
  return New(env, std::move(ptr));
}",28,,135,3,,void
68977,BLOCK,-1,,<empty>,5,,139,2,,void
68998,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  MaybeLocal<Object> maybe_cert;

  bool is_server =
      static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);

  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return MaybeLocal<Object>();

  std::vector<Local<Value>> certs;

  if (!cert) {
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }

  return sk_X509_num(ssl_certs)
      ? New(env, std::move(cert), ssl_certs)
      : New(env, std::move(cert));
}",34,,148,4,,void
69049,BLOCK,-1,,<empty>,5,,158,2,,void
69064,BLOCK,-1,,"{
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }",14,,162,2,,void
69098,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<unsigned char> buf(args[0].As<ArrayBufferView>());
  const unsigned char* data = buf.data();
  unsigned data_len = buf.length();

  ClearErrorOnReturn clear_error_on_return;
  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return ThrowCryptoError(env, ERR_get_error());

  Local<Object> cert;

  X509Pointer pem(PEM_read_bio_X509_AUX(
      bio.get(), nullptr, NoPasswordCallback, nullptr));
  if (!pem) {
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  } else if (!X509Certificate::New(env, std::move(pem)).ToLocal(&cert)) {
    return;
  }

  args.GetReturnValue().Set(cert);
}",70,,172,2,,void
69147,BLOCK,-1,,<empty>,5,,183,2,,void
69170,BLOCK,-1,,"{
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  }",13,,189,2,,void
69182,BLOCK,-1,,<empty>,7,,195,2,,void
69204,BLOCK,-1,,<empty>,7,,198,2,,void
69207,BLOCK,-1,,<empty>,10,,199,1,,void
69225,BLOCK,-1,,"{
    return;
  }",73,,199,2,,void
69239,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubject(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",72,,206,2,,void
69258,BLOCK,-1,,<empty>,,,,2,,<empty>
69281,BLOCK,-1,,<empty>,5,,214,2,,void
69294,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetIssuerString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",71,,217,2,,void
69313,BLOCK,-1,,<empty>,,,,2,,<empty>
69336,BLOCK,-1,,<empty>,5,,225,2,,void
69349,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubjectAltNameString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,228,2,,void
69368,BLOCK,-1,,<empty>,,,,2,,<empty>
69391,BLOCK,-1,,<empty>,5,,236,2,,void
69404,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetInfoAccessString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,239,2,,void
69423,BLOCK,-1,,<empty>,,,,2,,<empty>
69446,BLOCK,-1,,<empty>,5,,247,2,,void
69459,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidFrom(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",74,,250,2,,void
69478,BLOCK,-1,,<empty>,,,,2,,<empty>
69501,BLOCK,-1,,<empty>,5,,258,2,,void
69514,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidTo(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",72,,261,2,,void
69533,BLOCK,-1,,<empty>,,,,2,,<empty>
69556,BLOCK,-1,,<empty>,5,,269,2,,void
69569,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetKeyUsage(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",73,,272,2,,void
69603,BLOCK,-1,,<empty>,5,,278,2,,void
69616,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetSerialNumber(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",77,,281,2,,void
69650,BLOCK,-1,,<empty>,5,,287,2,,void
69663,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetRawDERCertificate(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",68,,290,2,,void
69697,BLOCK,-1,,<empty>,5,,296,2,,void
69710,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  // TODO(tniessen): consider checking X509_get_pubkey() when the
  // X509Certificate object is being created.
  ClearErrorOnReturn clear_error_on_return;
  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
  if (!pkey) return ThrowCryptoError(env, ERR_get_error());
  ManagedEVPPKey epkey(std::move(pkey));
  std::shared_ptr<KeyObjectData> key_data =
      KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);

  Local<Value> ret;
  if (KeyObjectHandle::Create(env, key_data).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",74,,299,2,,void
69738,BLOCK,-1,,<empty>,14,,308,2,,void
69781,BLOCK,-1,,<empty>,5,,315,2,,void
69794,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (PEM_write_bio_X509(bio.get(), cert->get()))
    args.GetReturnValue().Set(ToV8Value(env, bio));
}",68,,318,2,,void
69813,BLOCK,-1,,<empty>,,,,2,,<empty>
69828,BLOCK,-1,,<empty>,5,,325,2,,void
69843,BLOCK,-1,,"{
  X509Certificate* cert;
  ClearErrorOnReturn clear_error_on_return;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
}",72,,328,2,,void
69871,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();
  char* peername;

  switch (X509_check_host(
              cert->get(),
              *name,
              name.length(),
              flags,
              &peername)) {
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",74,,335,2,,void
69939,BLOCK,-1,,"{
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",27,,352,2,,void
69942,BLOCK,3,,"{  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }",14,,353,3,,void
69956,BLOCK,-1,,"{
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }",32,,355,2,,void
69994,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_email(
              cert->get(),
              *name,
              name.length(),
              flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",75,,370,2,,void
70059,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",23,,385,2,,void
70091,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // IP
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",72,,397,2,,void
70152,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",57,,408,2,,void
70184,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));

  X509Certificate* issuer;
  ASSIGN_OR_RETURN_UNWRAP(&issuer, args[0]);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
}",76,,420,2,,void
70250,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_check_private_key(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) == 1);
}",80,,437,2,,void
70311,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePublic);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_verify(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) > 0);
}",71,,454,2,,void
70372,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  Local<Value> ret;
  if (X509ToObject(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",73,,471,2,,void
70407,BLOCK,-1,,<empty>,5,,478,2,,void
70420,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  if (cert->issuer_cert_)
    args.GetReturnValue().Set(cert->issuer_cert_->object());
}",78,,481,2,,void
70433,BLOCK,-1,,<empty>,5,,485,2,,void
70452,BLOCK,-1,,"{
  tracker->TrackField(""cert"", cert_);
}",64,,509,2,,void
70465,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!X509Certificate::New(env, data_).ToLocal(&handle))
    return {};

  return BaseObjectPtr<BaseObject>(
      Unwrap<X509Certificate>(handle.As<Object>()));
}",49,,517,4,,void
70473,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,518,2,,void
70495,BLOCK,-1,,<empty>,5,,525,2,,void
70513,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,532,1,,void
70523,BLOCK,-1,,"{
  return std::make_unique<X509CertificateTransferData>(cert_);
}",11,,537,1,,void
70537,BLOCK,-1,,"{
  SetMethod(env->context(), target, ""parseX509"", X509Certificate::Parse);

  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);
}",74,,542,3,,void
70570,BLOCK,-1,,"{
  registry->Register(X509Certificate::Parse);
  registry->Register(Subject);
  registry->Register(SubjectAltName);
  registry->Register(InfoAccess);
  registry->Register(Issuer);
  registry->Register(ValidTo);
  registry->Register(ValidFrom);
  registry->Register(Fingerprint<EVP_sha1>);
  registry->Register(Fingerprint<EVP_sha256>);
  registry->Register(Fingerprint<EVP_sha512>);
  registry->Register(KeyUsage);
  registry->Register(SerialNumber);
  registry->Register(Pem);
  registry->Register(Raw);
  registry->Register(PublicKey);
  registry->Register(CheckCA);
  registry->Register(CheckHost);
  registry->Register(CheckEmail);
  registry->Register(CheckIP);
  registry->Register(CheckIssued);
  registry->Register(CheckPrivateKey);
  registry->Register(Verify);
  registry->Register(ToLegacy);
  registry->Register(GetIssuerCert);
}",42,,554,2,,void
70711,BLOCK,-1,,<empty>,1,,1,1,,ANY
70715,BLOCK,-1,,<empty>,73,,211,2,,void
70722,BLOCK,-1,,<empty>,75,,224,2,,void
70728,BLOCK,-1,,<empty>,59,,240,2,,void
70734,BLOCK,-1,,<empty>,62,,272,2,,void
70743,BLOCK,-1,,"{
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the fina...",80,,248,5,,void
70786,BLOCK,-1,,"{
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,256,2,,void
70808,BLOCK,-1,,"{
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            }",58,,263,2,,void
70813,BLOCK,-1,,"{
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }",20,,266,1,,void
70855,BLOCK,-1,,<empty>,73,,364,2,,void
70862,BLOCK,-1,,<empty>,77,,377,2,,void
70868,BLOCK,-1,,<empty>,67,,390,2,,void
70874,BLOCK,-1,,<empty>,73,,403,2,,void
70880,BLOCK,-1,,<empty>,59,,409,2,,void
70886,BLOCK,-1,,<empty>,62,,432,2,,void
70895,BLOCK,-1,,"{
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything on to the outer next.
          std::move(next)(status, vecs, count, std::move(done));
        }",80,,418,5,,void
70938,BLOCK,-1,,"{
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,427,2,,void
70965,BLOCK,-1,,<empty>,26,,431,2,,void
71006,BLOCK,-1,,<empty>,75,,516,2,,void
71013,BLOCK,-1,,<empty>,66,,522,2,,void
71019,BLOCK,-1,,<empty>,75,,586,2,,void
71027,BLOCK,-1,,"{
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",72,,638,3,,void
71032,BLOCK,-1,,"{
        return std::make_unique<EmptyEntry>();
      }",21,,639,2,,void
71056,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,791,1,,void
71066,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,853,1,,void
71075,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },39,,870,1,,void
71086,BLOCK,-1,,<empty>,69,,921,2,,void
71092,BLOCK,-1,,<empty>,77,,927,2,,void
71098,BLOCK,-1,,<empty>,67,,929,2,,void
71104,BLOCK,-1,,<empty>,60,,939,2,,void
71110,BLOCK,-1,,<empty>,67,,953,2,,void
71116,BLOCK,-1,,<empty>,61,,959,2,,void
71122,BLOCK,-1,,<empty>,75,,1000,2,,void
71127,BLOCK,-1,,{ pending_pulls_.pop_front(); },38,,1018,1,,void
71137,BLOCK,-1,,"{
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  }",46,,1037,2,,void
71148,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",52,,1038,2,,void
71159,BLOCK,-1,,"{
      size += item->size().value();
    }",35,,1047,2,,void
71170,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",12,,1049,1,,void
71220,BLOCK,-1,,<empty>,1,,1,1,,ANY
71227,BLOCK,-1,,<empty>,,,,1,,<empty>
71234,BLOCK,-1,,<empty>,25,,47,3,,void
71239,BLOCK,-1,,<empty>,57,,55,2,,void
71244,BLOCK,-1,,<empty>,,,,2,,<empty>
71249,BLOCK,-1,,<empty>,,,,2,,<empty>
71254,BLOCK,-1,,<empty>,,,,2,,<empty>
71259,BLOCK,-1,,<empty>,,,,2,,<empty>
71265,BLOCK,-1,,"{
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_bac...",65,,65,3,,void
71275,BLOCK,-1,,<empty>,45,,68,2,,void
71341,BLOCK,-1,,"{
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }
    }",24,,83,2,,void
71345,BLOCK,-1,,"{
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }",42,,84,3,,void
71360,BLOCK,-1,,"{
          start -= entrySize;
          continue;
        }",32,,88,2,,void
71402,BLOCK,-1,,<empty>,29,,99,2,,void
71422,BLOCK,-1,,{ return size_; },49,,106,1,,void
71428,BLOCK,-1,,{ return idempotent_; },39,,108,1,,void
71434,BLOCK,-1,,{ return capped_size_.has_value(); },35,,110,1,,void
71444,BLOCK,-1,,"{
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",69,,112,2,,void
71447,BLOCK,-1,,<empty>,22,,113,2,,void
71455,BLOCK,-1,,<empty>,17,,114,2,,void
71471,BLOCK,-1,,"{
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    }",57,,118,2,,void
71503,BLOCK,-1,,"{
        return false;
      }",54,,124,2,,void
71512,BLOCK,-1,,"{
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }",12,,128,1,,void
71533,BLOCK,-1,,"{
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",41,,138,2,,void
71536,BLOCK,-1,,<empty>,26,,139,2,,void
71543,BLOCK,-1,,"{
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }",35,,142,2,,void
71562,BLOCK,-1,,"{
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",62,,151,1,,void
71573,BLOCK,-1,,"{
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }",56,,152,2,,void
71605,BLOCK,-1,,"{
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",64,,160,2,,void
71616,BLOCK,-1,,<empty>,,,,1,,<empty>
71632,BLOCK,-1,,<empty>,,,,1,,<empty>
71650,BLOCK,-1,,"{
    CHECK(data_queue_->is_idempotent());
  }",44,,190,2,,void
71660,BLOCK,-1,,<empty>,,,,2,,<empty>
71665,BLOCK,-1,,<empty>,,,,2,,<empty>
71670,BLOCK,-1,,<empty>,,,,2,,<empty>
71675,BLOCK,-1,,<empty>,,,,2,,<empty>
71682,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }

    // We have current_index_, awesome, we are going to...",65,,205,6,,void
71696,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,210,2,,void
71723,BLOCK,-1,,"{
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }",38,,217,2,,void
71731,BLOCK,-1,,"{
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",42,,222,2,,void
71766,BLOCK,-1,,"{
      // Getting the current reader for an entry could fail for several
      // reasons. For an FdEntry, for instance, getting the reader may
      // fail if the file has been modified since the FdEntry was created.
      // We handle the case simply by erroring.
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,235,2,,void
71799,BLOCK,-1,,"{
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,285,2,,void
71803,BLOCK,-1,,<empty>,20,,286,2,,void
71815,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,308,1,,void
71828,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,311,2,,void
71867,BLOCK,-1,,<empty>,,,,1,,<empty>
71886,BLOCK,-1,,"{
    CHECK(!data_queue_->is_idempotent());
  }",44,,342,2,,void
71897,BLOCK,-1,,<empty>,,,,2,,<empty>
71902,BLOCK,-1,,<empty>,,,,2,,<empty>
71907,BLOCK,-1,,<empty>,,,,2,,<empty>
71912,BLOCK,-1,,<empty>,,,,2,,<empty>
71919,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depen...",65,,358,6,,void
71933,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,363,2,,void
71961,BLOCK,-1,,"{
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depend on whether the size
      // of the data_queue_ is known or not.

      if (data_queue_->size().has_value()) {
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLO...",40,,371,2,,void
71968,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }",38,,376,2,,void
71995,BLOCK,-1,,"{
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }

        // Otherwise, if size is equal to or greater than capped, we are done.
        // Fall through to allow the end handling to run.
      }",44,,384,2,,void
72011,BLOCK,-1,,"{
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }",78,,388,2,,void
72062,BLOCK,-1,,"{
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,408,2,,void
72095,BLOCK,-1,,"{
      // The callback was resolved synchronously. Let's check our status.
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,445,2,,void
72099,BLOCK,-1,,<empty>,20,,447,2,,void
72111,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,469,1,,void
72127,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,472,2,,void
72158,BLOCK,-1,,<empty>,,,,1,,<empty>
72171,BLOCK,-1,,"{
  if (is_idempotent()) {
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }

  if (locked_to_reader_) return nullptr;
  locked_to_reader_ = true;

  return std::make_shared<NonIdempotentDataQueueReader>(shared_from_this());
}",64,,490,1,,void
72174,BLOCK,-1,,"{
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }",24,,491,2,,void
72185,BLOCK,-1,,<empty>,26,,495,2,,void
72208,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }",67,,513,6,,void
72215,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,515,2,,void
72263,BLOCK,-1,,<empty>,,,,1,,<empty>
72268,BLOCK,-1,,<empty>,,,,2,,<empty>
72273,BLOCK,-1,,<empty>,,,,2,,<empty>
72278,BLOCK,-1,,<empty>,,,,2,,<empty>
72283,BLOCK,-1,,<empty>,,,,2,,<empty>
72287,BLOCK,-1,,"{
    return std::make_shared<EmptyReader>();
  }",60,,542,1,,void
72298,BLOCK,-1,,"{
    if (start != 0) return nullptr;
    return std::make_unique<EmptyEntry>();
  }",65,,548,3,,void
72303,BLOCK,-1,,<empty>,21,,549,2,,void
72314,BLOCK,-1,,{ return 0; },49,,553,1,,void
72320,BLOCK,-1,,{ return true; },39,,555,1,,void
72330,BLOCK,-1,,{ backing_store = nullptr; },31,,570,2,,void
72338,BLOCK,-1,,<empty>,58,,577,2,,void
72347,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",67,,583,6,,void
72354,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,585,2,,void
72427,BLOCK,-1,,<empty>,,,,1,,<empty>
72437,BLOCK,-1,,"{
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",35,,618,4,,void
72450,BLOCK,-1,,<empty>,,,,2,,<empty>
72455,BLOCK,-1,,<empty>,,,,2,,<empty>
72460,BLOCK,-1,,<empty>,,,,2,,<empty>
72465,BLOCK,-1,,<empty>,,,,2,,<empty>
72469,BLOCK,-1,,"{
    return std::make_shared<InMemoryReader>(*this);
  }",60,,630,1,,void
72483,BLOCK,-1,,"{
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    return makeEntry(start, byte_length_ - start);
  }",65,,636,3,,void
72506,BLOCK,-1,,"{
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }",31,,651,2,,void
72546,BLOCK,-1,,{ return byte_length_; },49,,665,1,,void
72552,BLOCK,-1,,{ return true; },39,,667,1,,void
72559,BLOCK,-1,,"{
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",64,,669,2,,void
72580,BLOCK,-1,,"{
    CHECK(data_queue_);
  }",44,,691,2,,void
72587,BLOCK,-1,,<empty>,,,,2,,<empty>
72592,BLOCK,-1,,<empty>,,,,2,,<empty>
72597,BLOCK,-1,,<empty>,,,,2,,<empty>
72602,BLOCK,-1,,<empty>,,,,2,,<empty>
72606,BLOCK,-1,,"{
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",60,,701,1,,void
72623,BLOCK,-1,,"{
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",76,,706,3,,void
72641,BLOCK,-1,,<empty>,18,,708,2,,void
72659,BLOCK,-1,,{ return data_queue_->size(); },49,,719,1,,void
72668,BLOCK,-1,,{ return data_queue_->is_idempotent(); },39,,727,1,,void
72678,BLOCK,-1,,"{
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",64,,729,2,,void
72689,BLOCK,-1,,{ return *data_queue_; },29,,734,1,,void
72703,BLOCK,-1,,<empty>,36,,746,2,,void
72712,BLOCK,-1,,"{
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }",46,,752,6,,void
72737,BLOCK,-1,,"{
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }",79,,788,3,,void
72774,BLOCK,-1,,<empty>,61,,794,2,,void
72809,BLOCK,-1,,<empty>,19,,809,6,,void
72813,BLOCK,-1,,"{
    return ReaderImpl::Create(this);
  }",60,,811,1,,void
72825,BLOCK,-1,,"{
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",76,,816,3,,void
72841,BLOCK,-1,,"{
      new_end = std::min(end.value(), end_);
    }",26,,819,2,,void
72878,BLOCK,-1,,{ return end_ - start_; },49,,829,1,,void
72886,BLOCK,-1,,{ return true; },39,,831,1,,void
72892,BLOCK,-1,,{ return env_; },28,,833,1,,void
72904,BLOCK,-1,,"{
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",44,,846,2,,void
72930,BLOCK,-1,,"{
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
    // TODO(jasnell): Note the use of a sync fs call here is a bit unfortunate.
    // Doing this asynchronously creates a bit of a race condition tho, a file
    // could be unmodified when we call the operation but then by the time the
    // async callback is triggered to give us that answer the file is modified.
    // While such silliness is still possible here, the sync call at least makes
    // it less likely to hit the race.
    if (uv_fs_fstat(nullptr, &req, fd, nullptr) < 0) return true;
    return entry->is_modified(req.statbuf);
  }",53,,851,3,,void
72948,BLOCK,-1,,<empty>,54,,860,2,,void
72963,BLOCK,-1,,"{
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",63,,868,2,,void
72996,BLOCK,-1,,"{
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }",60,,873,2,,void
73066,BLOCK,-1,,"{
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",74,,889,3,,void
73084,BLOCK,-1,,"{
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",28,,894,1,,void
73104,BLOCK,-1,,"{
      return env_->allocate_managed_buffer(suggested_size);
    }",60,,900,2,,void
73116,BLOCK,-1,,"{
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      DataQueue::Vec vec;
      vec.base = static_cast<uint8_t*>(store->D...",68,,904,3,,void
73134,BLOCK,-1,,"{
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }",19,,908,2,,void
73154,BLOCK,-1,,"{
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }",52,,918,2,,void
73173,BLOCK,-1,,"{
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }",22,,925,2,,void
73178,BLOCK,-1,,"{
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        }",30,,926,2,,void
73194,BLOCK,-1,,"{
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }",16,,928,1,,void
73247,BLOCK,-1,,"{
        reading_ = false;
        if (handle_->IsAlive()) handle_->ReadStop();
      }",35,,941,2,,void
73256,BLOCK,-1,,<empty>,33,,943,2,,void
73269,BLOCK,-1,,"{
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",67,,951,6,,void
73278,BLOCK,-1,,"{
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }",42,,952,2,,void
73305,BLOCK,-1,,"{
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }",61,,957,2,,void
73332,BLOCK,-1,,"{
        reading_ = true;
        handle_->ReadStart();
      }",22,,964,2,,void
73355,BLOCK,-1,,"{
      auto ptr = static_cast<ReaderImpl*>(self);
      ptr->DrainAndClose();
    }",37,,990,2,,void
73369,BLOCK,-1,,"{
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",26,,995,1,,void
73372,BLOCK,-1,,<empty>,19,,996,2,,void
73383,BLOCK,-1,,"{
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }",39,,998,2,,void
73426,BLOCK,-1,,"{
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",38,,1016,1,,void
73451,BLOCK,-1,,<empty>,,,,1,,<empty>
73462,BLOCK,-1,,<empty>,,,,1,,<empty>
73473,BLOCK,-1,,"{
  // Any entry is invalid for an idempotent DataQueue if any of the entries
  // are nullptr or is not idempotent.
  uint64_t size = 0;
  const auto isInvalid = [&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  };

  if (std::any_of(list.begin(), list.end(), isInvalid)) {
    return nullptr;
  }

  return std::make_shared<DataQueueImpl>(std::move(list), size);
}",47,,1033,2,,void
73495,BLOCK,-1,,"{
    return nullptr;
  }",57,,1056,2,,void
73517,BLOCK,-1,,"{
  return std::make_shared<DataQueueImpl>(capped);
}",78,,1063,2,,void
73530,BLOCK,-1,,"{
  // If the view is not detachable, we do not want to create an InMemoryEntry
  // from it. Why? Because if we're not able to detach the backing store from
  // the underlying buffer, something else could modify the buffer while we're
  // holding the reference, which means we cannot guarantee that reads will be
  // idempotent.
  if (!view->Buffer()->IsDetachable()) {
    return nullptr;
  }
  auto store = view->Buffer()->GetBackingStore();
  auto offset = view->ByteOffset();
  auto length = view->ByteLength();
  USE(view->Buffer()->Detach(Local<Value>()));
  return CreateInMemoryEntryFromBackingStore(std::move(store), offset, length);
}",34,,1068,2,,void
73540,BLOCK,-1,,"{
    return nullptr;
  }",40,,1074,2,,void
73591,BLOCK,-1,,"{
  CHECK(store);
  if (offset + length > store->ByteLength()) {
    return nullptr;
  }
  return std::make_unique<InMemoryEntry>(std::move(store), offset, length);
}",76,,1086,4,,void
73603,BLOCK,-1,,"{
    return nullptr;
  }",46,,1088,2,,void
73626,BLOCK,-1,,"{
  return std::make_unique<DataQueueEntry>(std::move(data_queue));
}",44,,1095,2,,void
73644,BLOCK,-1,,"{
  return FdEntry::Create(env, path);
}",79,,1100,3,,void
73657,BLOCK,-1,,"{
  // Nothing to do here currently.
}",76,,1104,3,,void
73662,BLOCK,-1,,"{
  // Nothing to do here currently.
}",42,,1109,2,,void
73691,BLOCK,-1,,<empty>,1,,1,1,,ANY
73702,BLOCK,-1,,<empty>,1,,1,1,,ANY
73707,BLOCK,-1,,"{
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, because for C++ code that is usually the virtual table pointer
    // and gives us information about the exact kind of object we're looking at.
    void* first_field = nullptr;
    // `handle->data` might be any value, including `nullptr`, or something
    // cast from a completely different type; therefore...",52,,338,3,,void
73800,BLOCK,-1,,<empty>,7,,362,2,,void
73813,BLOCK,-1,,"{
      fprintf(stream, ""\t(First field): %p %s\n"",
          first_field, sym_ctx->LookupSymbol(first_field).Display().c_str());
    }",33,,364,2,,void
73834,BLOCK,-1,,"{
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  }",30,,477,1,,void
73895,BLOCK,-1,,<empty>,1,,1,1,,ANY
73902,BLOCK,-1,,"{
  std::string cats;
  credentials::SafeGetenv(""NODE_DEBUG_NATIVE"", &cats, env_vars, isolate);
  Parse(cats);
}",52,,63,3,,void
73919,BLOCK,-1,,"{
  std::string debug_categories = cats;
  while (!debug_categories.empty()) {
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }
}",55,,69,2,,void
73930,BLOCK,-1,,"{
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }",37,,71,2,,void
73959,BLOCK,-1,,<empty>,41,,85,2,,void
73974,BLOCK,-1,,"{
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",33,,153,1,,void
73986,BLOCK,-1,,"{
    USE(SymCleanup(current_process_));
  }",43,,158,1,,void
73995,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }
    // End MSDN...",67,,163,2,,void
74025,BLOCK,-1,,"{
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    }",77,,178,2,,void
74033,BLOCK,-1,,"{
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }",12,,181,1,,void
74044,BLOCK,-1,,"{
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }
    // ...",54,,193,2,,void
74066,BLOCK,-1,,"{
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    }",55,,212,2,,void
74082,BLOCK,-1,,"{
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }",12,,216,1,,void
74093,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // return `szUndName` instead of `printf` on success
    char szUndName[MAX_SYM_NAME];
    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),
                             UNDNAME_COMPLETE)) {
      // UnDecorateSymbolName returned success
      return szUndName;
    } else {
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }
    return nullptr;
  }",67,,229,2,,void
74102,BLOCK,-1,,"{
      // UnDecorateSymbolName returned success
      return szUndName;
    }",49,,236,2,,void
74106,BLOCK,-1,,"{
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }",12,,239,1,,void
74117,BLOCK,-1,,"{
    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);
    SymbolInfo ret = WrappedGetLine(dw_address);
    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);
    if (!ret.name.empty()) {
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }
    return ret;
  }",51,,249,2,,void
74150,BLOCK,-1,,"{
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }",28,,253,2,,void
74168,BLOCK,-1,,"{
    MEMORY_BASIC_INFORMATION info;

    if (VirtualQuery(address, &info, sizeof(info)) != sizeof(info))
      return false;

    return info.State == MEM_COMMIT && info.Protect != 0;
  }",41,,259,2,,void
74180,BLOCK,-1,,<empty>,7,,263,2,,void
74200,BLOCK,-1,,"{
    return CaptureStackBackTrace(0, count, frames, nullptr);
  }",56,,268,3,,void
74211,BLOCK,-1,,<empty>,,,,2,,<empty>
74216,BLOCK,-1,,<empty>,,,,2,,<empty>
74221,BLOCK,-1,,<empty>,,,,2,,<empty>
74226,BLOCK,-1,,<empty>,,,,2,,<empty>
74231,BLOCK,-1,,"{
  return std::unique_ptr<NativeSymbolDebuggingContext>(
      new Win32SymbolDebuggingContext());
}",37,,284,1,,void
74244,BLOCK,-1,,"{
  std::ostringstream oss;
  oss << name;
  if (dis != 0) {
    oss << ""+"" << dis;
  }
  if (!filename.empty()) {
    oss << "" ["" << filename << ']';
  }
  if (line != 0) {
    oss << "":L"" << line;
  }
  return oss.str();
}",71,,291,1,,void
74253,BLOCK,-1,,"{
    oss << ""+"" << dis;
  }",17,,294,2,,void
74265,BLOCK,-1,,"{
    oss << "" ["" << filename << ']';
  }",26,,297,2,,void
74277,BLOCK,-1,,"{
    oss << "":L"" << line;
  }",18,,300,2,,void
74292,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",30,,306,2,,void
74312,BLOCK,-1,,<empty>,3,,310,1,,void
74323,BLOCK,4,,"{
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }",37,,310,4,,void
74354,BLOCK,-1,,"{
  if (uv_loop_close(loop) == 0) return;

  PrintLibuvHandleInformation(loop, stderr);

  fflush(stderr);
  // Finally, abort.
  UNREACHABLE(""uv_loop_close() while having open handles"");
}",42,,317,2,,void
74360,BLOCK,-1,,<empty>,33,,318,2,,void
74373,BLOCK,-1,,"{
  struct Info {
    std::unique_ptr<NativeSymbolDebuggingContext> ctx;
    FILE* stream;
    size_t num_handles;
  };

  Info info { NativeSymbolDebuggingContext::New(), stream, 0 };

  fprintf(stream, ""uv loop at [%p] has open handles:\n"", loop);

  uv_walk(loop, [](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, becaus...",65,,327,3,,void
74403,BLOCK,-1,,"{
  std::vector<std::string> list;
#if defined(__linux__) || defined(__FreeBSD__) || \
    defined(__OpenBSD__) || defined(__DragonFly__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t size, void* data) {
        auto list = static_cast<std::vector<std::string>*>(data);
        if (*info->dlpi_name != '\0') {
          list->emplace_back(info->dlpi_name);
        }
        return 0;
      },
      &list);
#elif __APPLE__
  uint32_t i = 0;
  for (const char* name = _dyld_get_image_name(i); name != nullptr;
       name = _dyld_get_image_name(++i)) {
    list.emplace_back(name);
  }

#elif _AIX
  // We can't tell in advance how large the buffer needs to be.
  // Retry until we reach too large a size (1Mb).
  const unsigned int kBufferGrowStep = 4096;
  MallocedBuffer<char> buffer(kBufferGrowStep);
  int rc = -1;
  do {
    rc = loadquery(L_GETINFO, buffer.data, buffer.size);
    if (rc == 0) break;
    buffer = MallocedBuffer<char>(buffer.size + kBufferGrowStep);
  } whi...",77,,374,1,,void
74418,BLOCK,-1,,"{
  auto simple_fwrite = [&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  };

  if (file != stderr && file != stdout) {
    simple_fwrite();
    return;
  }
#ifdef _WIN32
  HANDLE handle =
      GetStdHandle(file == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);

  // Check if stderr is something other than a tty/console
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr ||
      uv_guess_handle(_fileno(file)) != UV_TTY) {
    simple_fwrite();
    return;
  }

  // Get required wide buffer size
  int n = MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), nullptr, 0);

  std::vector<wchar_t> wbuf(n);
  MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), wbuf.data(), n);

  WriteConsoleW(handle, wbuf.data(), n, nullptr, nullptr);
  return;
#elif defined(__ANDROID__)
  if (file == stderr) {
    __android_log_print(ANDROID_LOG_ERROR, ""nodejs"", ""%s"", str.data());
    return;
  }
#endif
  s...",49,,476,3,,void
74431,BLOCK,-1,,"{
    simple_fwrite();
    return;
  }",41,,482,2,,void
74439,BLOCK,-1,,"{
  node::DumpBacktrace(fp);
}",43,,516,2,,void
74461,BLOCK,-1,,<empty>,1,,1,1,,ANY
74468,BLOCK,-1,,<empty>,1,,1,1,,ANY
74491,BLOCK,-1,,<empty>,1,,1,1,,ANY
74496,BLOCK,-1,,"{
  tracker->TrackField(""encode_into_results_buffer"",
                      encode_into_results_buffer_);
}",60,,28,2,,void
74509,BLOCK,-1,,"{
  if (info == nullptr) {
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  } else {
    encode_into_results_buffer_.Deserialize(realm->context());
  }
  encode_into_results_buffer_.MakeWeak();
}",62,,40,4,,void
74514,BLOCK,-1,,"{
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  }",24,,41,2,,void
74537,BLOCK,-1,,"{
    encode_into_results_buffer_.Deserialize(realm->context());
  }",10,,47,1,,void
74555,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->encode_into_results_buffer =
      encode_into_results_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,54,3,,void
74582,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,64,2,,void
74604,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,74,5,,void
74650,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsUint8Array());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);

  Local<String> source = args[0].As<String>();

  Local<Uint8Array> dest = args[1].As<Uint8Array>();
  Local<ArrayBuffer> buf = dest->Buffer();
  char* write_result = static_cast<char*>(buf->Data()) + dest->ByteOffset();
  size_t dest_length = dest->ByteLength();

  int nchars;
  int written = source->WriteUtf8(
      isolate,
      write_result,
      dest_length,
      &nchars,
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

  binding_data->encode_into_results_buffer_[0] = nchars;
  binding_data->encode_into_results_buffer_[1] = written;
}",71,,85,2,,void
74789,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Local<String> str = args[0].As<String>();
  size_t length = str->Utf8Length(isolate);

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  auto array = Uint8Array::New(ab, 0, length);
  args.GetReturnValue().Set(array);
}",77,,114,2,,void
74843,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,124,11,,void
74920,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);  // list, flags

  CHECK_GE(args.Length(), 1);

  if (!(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer() ||
        args[0]->IsArrayBufferView())) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }

  ArrayBufferViewContents<char> buffer(args[0]);

  bool ignore_bom = args[1]->IsTrue();
  bool has_fatal = args[2]->IsTrue();

  const char* data = buffer.data();
  size_t length = buffer.length();

  if (has_fatal) {
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }

  if (!ignore_bom && length >= 3) {
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  ...",71,,145,2,,void
74957,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }",40,,151,2,,void
75007,BLOCK,-1,,"{
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }",18,,166,2,,void
75021,BLOCK,-1,,"{
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }",23,,169,2,,void
75039,BLOCK,-1,,"{
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  }",35,,175,2,,void
75047,BLOCK,-1,,"{
      data += 3;
      length -= 3;
    }",47,,176,2,,void
75058,BLOCK,-1,,<empty>,20,,182,2,,void
75104,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",33,,189,2,,void
75132,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_ascii(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",76,,198,2,,void
75202,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_unicode(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",78,,209,2,,void
75273,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""encodeInto"", EncodeInto);
  SetMethodNoSideEffect(isolate, target, ""encodeUtf8String"", EncodeUtf8String);
  SetMethodNoSideEffect(isolate, target, ""decodeUTF8"", DecodeUTF8);
  SetMethodNoSideEffect(isolate, target, ""toASCII"", ToASCII);
  SetMethodNoSideEffect(isolate, target, ""toUnicode"", ToUnicode);
}",76,,221,3,,void
75313,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,233,5,,void
75336,BLOCK,-1,,"{
  registry->Register(EncodeInto);
  registry->Register(EncodeUtf8String);
  registry->Register(DecodeUTF8);
  registry->Register(ToASCII);
  registry->Register(ToUnicode);
}",42,,239,2,,void
75377,BLOCK,-1,,<empty>,1,,1,1,,ANY
75412,BLOCK,-1,,<empty>,1,,1,1,,ANY
75416,BLOCK,-1,,{ return el.IsEmpty(); },49,,216,2,,void
75428,BLOCK,-1,,"{
        Environment* env = ContainerOf(
            &Environment::task_queues_async_, async);
        HandleScope handle_scope(env->isolate());
        Context::Scope context_scope(env->context());
        env->RunAndClearNativeImmediates();
      }",29,,957,2,,void
75459,BLOCK,-1,,"{
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  }",47,,991,2,,void
75475,BLOCK,-1,,"{
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    }",54,,1002,2,,void
75483,BLOCK,-1,,"{
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  }",52,,999,4,,void
75500,BLOCK,-1,,"{
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  }",51,,1009,2,,void
75511,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  }",68,,1049,2,,void
75534,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  }",62,,1053,2,,void
75557,BLOCK,-1,,"{
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }
    return false;
  }",54,,1159,2,,void
75565,BLOCK,-1,,"{
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }",40,,1162,1,,void
75579,BLOCK,-1,,<empty>,9,,1165,2,,void
75587,BLOCK,-1,,<empty>,9,,1168,2,,void
75603,BLOCK,-1,,"{
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }",44,,1172,2,,void
75612,BLOCK,-1,,<empty>,11,,1174,2,,void
75631,BLOCK,-1,,"{
    std::unique_ptr<Environment*> env_ptr { static_cast<Environment**>(data) };
    Environment* env = *env_ptr;
    if (env == nullptr) {
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }
    env->interrupt_data_.store(nullptr);
    env->RunAndClearInterrupts();
  }",64,,1222,3,,void
75648,BLOCK,-1,,"{
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }",25,,1225,2,,void
75666,BLOCK,-1,,{ },58,,1342,2,,void
75730,BLOCK,-1,,<empty>,1,,1,1,,ANY
75752,BLOCK,-1,,"{
  js_promise_hooks_[0].Reset(env()->isolate(), init);
  js_promise_hooks_[1].Reset(env()->isolate(), before);
  js_promise_hooks_[2].Reset(env()->isolate(), after);
  js_promise_hooks_[3].Reset(env()->isolate(), resolve);
}",61,,71,5,,void
75804,BLOCK,-1,,"{
  async_hooks()->ResetPromiseHooks(init, before, after, resolve);

  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }
}",62,,81,5,,void
75814,BLOCK,-1,,<empty>,3,,84,1,,void
75830,BLOCK,4,,"{
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }",66,,84,4,,void
75836,BLOCK,-1,,"{
      contexts_.erase(it--);
      continue;
    }",24,,85,2,,void
75864,BLOCK,-1,,"{
  // Since async_hooks is experimental, do only perform the check
  // when async_hooks is enabled.
  if (fields_[kCheck] > 0) {
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }

  uint32_t offset = fields_[kStackLength];
  if (offset * 2 >= async_ids_stack_.Length()) grow_async_ids_stack();
  async_ids_stack_[2 * offset] = async_id_fields_[kExecutionAsyncId];
  async_ids_stack_[2 * offset + 1] = async_id_fields_[kTriggerAsyncId];
  fields_[kStackLength] += 1;
  async_id_fields_[kExecutionAsyncId] = async_id;
  async_id_fields_[kTriggerAsyncId] = trigger_async_id;

#ifdef DEBUG
  for (uint32_t i = offset; i < native_execution_async_resources_.size(); i++)
    CHECK(native_execution_async_resources_[i].IsEmpty());
#endif

  // When this call comes from JS (as a way of increasing the stack size),
  // `resource` will be empty, because JS caches these values anyway.
  if (!resource.IsEmpty()) {
    native_execution_async_resources_.resize(offset + 1);
    // Caveat...",61,,97,4,,void
75871,BLOCK,-1,,"{
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }",28,,100,2,,void
75895,BLOCK,-1,,<empty>,48,,106,2,,void
75938,BLOCK,-1,,"{
    native_execution_async_resources_.resize(offset + 1);
    // Caveat: This is a v8::Local<> assignment, we do not keep a v8::Global<>!
    native_execution_async_resources_[offset] = resource;
  }",28,,120,2,,void
75955,BLOCK,-1,,"{
  // In case of an exception then this may have already been reset, if the
  // stack was multiple MakeCallback()'s deep.
  if (UNLIKELY(fields_[kStackLength] == 0)) return false;

  // Ask for the async_id to be restored as a check that the stack
  // hasn't been corrupted.
  if (UNLIKELY(fields_[kCheck] > 0 &&
               async_id_fields_[kExecutionAsyncId] != async_id)) {
    FailWithCorruptedAsyncStack(async_id);
  }

  uint32_t offset = fields_[kStackLength] - 1;
  async_id_fields_[kExecutionAsyncId] = async_ids_stack_[2 * offset];
  async_id_fields_[kTriggerAsyncId] = async_ids_stack_[2 * offset + 1];
  fields_[kStackLength] = offset;

  if (LIKELY(offset < native_execution_async_resources_.size() &&
             !native_execution_async_resources_[offset].IsEmpty())) {
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_as...",53,,128,2,,void
75963,BLOCK,-1,,<empty>,45,,131,2,,void
75979,BLOCK,-1,,"{
    FailWithCorruptedAsyncStack(async_id);
  }",66,,136,2,,void
76031,BLOCK,-1,,"{
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_async_resources_.resize(offset);
    if (native_execution_async_resources_.size() <
            native_execution_async_resources_.capacity() / 2 &&
        native_execution_async_resources_.size() > 16) {
      native_execution_async_resources_.shrink_to_fit();
    }
  }",69,,146,2,,void
76056,BLOCK,-1,,"{
      native_execution_async_resources_.shrink_to_fit();
    }",56,,156,2,,void
76069,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(js_execution_async_resources()->Set(
        env()->context(),
        env()->length_string(),
        Integer::NewFromUnsigned(env()->isolate(), offset)));
  }",68,,161,2,,void
76107,BLOCK,-1,,"{
  if (!js_execution_async_resources_.IsEmpty() && env()->can_call_into_js()) {
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    USE(PersistentToLocal::Strong(js_execution_async_resources_)
            ->Set(env()->context(),
                  env()->length_string(),
                  Integer::NewFromUnsigned(isolate, 0)));
  }

  native_execution_async_resources_.clear();
  native_execution_async_resources_.shrink_to_fit();

  async_id_fields_[kExecutionAsyncId] = 0;
  async_id_fields_[kTriggerAsyncId] = 0;
  fields_[kStackLength] = 0;
}",41,,172,1,,void
76119,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    USE(PersistentToLocal::Strong(js_execution_async_resources_)
            ->Set(env()->context(),
                  env()->length_string(),
                  Integer::NewFromUnsigned(isolate, 0)));
  }",78,,173,2,,void
76180,BLOCK,-1,,"{
  ctx->SetPromiseHooks(js_promise_hooks_[0].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[0]),
                       js_promise_hooks_[1].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[1]),
                       js_promise_hooks_[2].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[2]),
                       js_promise_hooks_[3].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[3]));
}",58,,190,2,,void
76249,BLOCK,-1,,"{
  size_t id = contexts_.size();
  contexts_.resize(id + 1);
  contexts_[id].Reset(isolate_, context);
  contexts_[id].SetWeak();
}",56,,205,2,,void
76282,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  contexts_.erase(std::remove_if(contexts_.begin(),
                                 contexts_.end(),
                                 [&](auto&& el) { return el.IsEmpty(); }),
                  contexts_.end());
  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }
}",58,,212,2,,void
76308,BLOCK,-1,,<empty>,3,,218,1,,void
76324,BLOCK,4,,"{
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }",66,,218,4,,void
76342,BLOCK,-1,,"{
      it->Reset();
      contexts_.erase(it);
      break;
    }",35,,220,2,,void
76357,BLOCK,-1,,"{
  shadow_realms_.insert(realm);
}",70,,228,2,,void
76367,BLOCK,-1,,"{
  shadow_realms_.erase(realm);
}",72,,232,2,,void
76378,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kCheck] > 0) {
    CHECK_GE(default_trigger_async_id, 0);
  }

  old_default_trigger_async_id_ =
      async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId];
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      default_trigger_async_id;
}",40,,238,3,,void
76393,BLOCK,-1,,"{
    CHECK_GE(default_trigger_async_id, 0);
  }",61,,239,2,,void
76420,BLOCK,-1,,"{
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      old_default_trigger_async_id_;
}",71,,249,1,,void
76435,BLOCK,-1,,<empty>,62,,257,2,,void
76441,BLOCK,-1,,"{
  output << ""{ "";
  for (const SnapshotIndex i : v) {
    output << i << "", "";
  }
  output << "" }"";
  return output;
}",63,,260,3,,void
76448,BLOCK,-1,,"{
    output << i << "", "";
  }",35,,262,3,,void
76464,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- primitive begins --\n""
         << i.primitive_values << "",\n""
         << ""// -- primitive ends --\n""
         << ""// -- template_values begins --\n""
         << i.template_values << "",\n""
         << ""// -- template_values ends --\n""
         << ""}"";
  return output;
}",61,,270,3,,void
76497,BLOCK,-1,,"{
  output << ""{\n""
         << ""  ""
         << (i.type == SnapshotMetadata::Type::kDefault
                 ? ""SnapshotMetadata::Type::kDefault""
                 : ""SnapshotMetadata::Type::kFullyCustomized"")
         << "", // type\n""
         << ""  \"""" << i.node_version << ""\"", // node_version\n""
         << ""  \"""" << i.node_arch << ""\"", // node_arch\n""
         << ""  \"""" << i.node_platform << ""\"", // node_platform\n""
         << ""  "" << i.v8_cache_version_tag << "", // v8_cache_version_tag\n""
         << ""}"";
  return output;
}",75,,282,3,,void
76558,BLOCK,-1,,"{
  Isolate* isolate = creator->GetIsolate();
  IsolateDataSerializeInfo info;
  HandleScope handle_scope(isolate);
  // XXX(joyeecheung): technically speaking, the indexes here should be
  // consecutive and we could just return a range instead of an array,
  // but that's not part of the V8 API contract so we use an array
  // just to be safe.

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  info.primitive_values.push_back(                                             \
      creator->AddData(PropertyName##_.Get(isolate)));
  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
  PER_ISOLATE_SYMBOL_PROPERTIES(VY)
  PER_ISOLATE_STRING_PROPERTIES(VS)
  PER_REALM_STRONG_PERSISTENT_VALUES(VR)
#undef V
#undef...",75,,297,2,,void
76579,BLOCK,-1,,<empty>,3,,323,1,,void
76617,BLOCK,-1,,"{
  size_t i = 0;
  HandleScope handle_scope(isolate_);

  if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  do {                                                                         \
    MaybeLocal<TypeName> maybe_field =                                         \
        isolate_->GetDataFromSnapshotOnce<TypeName>(                           \
            info->primitive_values[i++]);                                      \
    Local<TypeName> field;                                                     \
    if (!maybe...",79,,344,2,,void
76635,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",75,,348,2,,void
76656,BLOCK,-1,,<empty>,3,,378,1,,void
76668,BLOCK,4,,"{
    MaybeLocal<String> maybe_field =
        isolate_->GetDataFromSnapshotOnce<String>(info->primitive_values[i++]);
    Local<String> field;
    if (!maybe_field.ToLocal(&field)) {
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }
    async_wrap_providers_[j].Set(isolate_, field);
  }",60,,378,4,,void
76700,BLOCK,-1,,"{
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }",39,,382,2,,void
76731,BLOCK,-1,,"{
  // Create string and private symbol properties as internalized one byte
  // strings after the platform is properly initialized.
  //
  // Internalized because it makes property lookups a little faster and
  // because the string is created in the old space straight away.  It's going
  // to end up in the old space sooner or later anyway but now it doesn't go
  // through v8::Eternal's new space handling first.
  //
  // One byte because our strings are ASCII and we can safely skip V8's UTF-8
  // decoding step.

  HandleScope handle_scope(isolate_);

#define V(PropertyName, StringValue)                                           \
  PropertyName##_.Set(                                                         \
      isolate_,                                                                \
      Private::New(isolate_,                                                   \
                   String::NewFromOneByte(                                     \
                       isolate...",38,,416,1,,void
76784,BLOCK,-1,,"{
  options_.reset(
      new PerIsolateOptions(*(per_process::cli_options->per_isolate)));

  if (snapshot_data == nullptr) {
    CreateProperties();
  } else {
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }
}",37,,510,6,,void
76801,BLOCK,-1,,"{
    CreateProperties();
  }",33,,514,2,,void
76804,BLOCK,-1,,"{
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }",10,,516,1,,void
76814,BLOCK,-1,,"{
#define V(PropertyName, StringValue)                                           \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_ISOLATE_SYMBOL_PROPERTIES(V)

  PER_ISOLATE_STRING_PROPERTIES(V)
#undef V

  tracker->TrackField(""async_wrap_providers"", async_wrap_providers_);

  if (node_allocator_ != nullptr) {
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }
  tracker->TrackFieldWithSize(
      ""platform"", sizeof(*platform_), ""MultiIsolatePlatform"");
  // TODO(joyeecheung): implement MemoryRetainer in the option classes.
}",60,,521,2,,void
76829,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }",35,,531,2,,void
76851,BLOCK,-1,,"{
  if (!env_->owns_process_state() || !env_->can_call_into_js()) {
    // Ideally, we’d have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }

  if (env_->principal_realm() == nullptr) {
    return;
  }

  bool async_hooks_enabled = (*(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
                                 TRACING_CATEGORY_NODE1(async_hooks)))) != 0;

  Isolate* isolate = env_->isolate();
  HandleScope handle_scope(isolate);
  Local<Function> cb = env_->trace_category_state_function();
  if (cb.IsEmpty())
    return;
  TryCatchScope try_catch(env_);
  try_catch.SetVerbose(true);
  Local<Value> args[] = ...",61,,540,1,,void
76864,BLOCK,-1,,"{
    // Ideally, we’d have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }",65,,541,2,,void
76873,BLOCK,-1,,"{
    return;
  }",43,,551,2,,void
76909,BLOCK,-1,,<empty>,5,,562,2,,void
76949,BLOCK,-1,,"{
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                           this);
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm, realm);
  // Used to retrieve bindings
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kBindingDataStoreIndex,
      realm->binding_data_store());

  // ContextifyContexts will update this to a pointer to the native object.
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, nullptr);

  // This must not be done before other context fields are initialized.
  ContextEmbedderTag::TagNodeContext(context);

#if HAVE_INSPECTOR
  inspector_agent()->ContextCreated(context, info);
#endif  // HAVE_INSPECTOR

  this->async_hooks()->InstallPromiseHooks(context);
  TrackContext(context);
}",60,,571,4,,void
77004,BLOCK,-1,,"{
  if (!context.IsEmpty()) {
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kBindingDataStoreIndex, nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kContextifyContext, nullptr);
  }
  UntrackContext(context);
}",67,,595,2,,void
77011,BLOCK,-1,,"{
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kBindingDataStoreIndex, nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kContextifyContext, nullptr);
  }",27,,596,2,,void
77052,BLOCK,-1,,"{
  loaded_addons_.emplace_back(filename, flags);
  if (!was_loaded(&loaded_addons_.back())) {
    loaded_addons_.pop_back();
  }
}",60,,612,4,,void
77067,BLOCK,-1,,"{
    loaded_addons_.pop_back();
  }",44,,614,2,,void
77075,BLOCK,-1,,"{
  char cwd[PATH_MAX_BYTES];
  size_t size = PATH_MAX_BYTES;
  const int err = uv_cwd(cwd, &size);

  if (err == 0) {
    CHECK_GT(size, 0);
    return cwd;
  }

  // This can fail if the cwd is deleted. In that case, fall back to
  // exec_path.
  const std::string& exec_path = exec_path_;
  return exec_path.substr(0, exec_path.find_last_of(kPathSeparator));
}",35,,619,1,,void
77092,BLOCK,-1,,"{
    CHECK_GT(size, 0);
    return cwd;
  }",17,,624,2,,void
77117,BLOCK,-1,,"{
  task_queues_async_refs_ += diff;
  CHECK_GE(task_queues_async_refs_, 0);
  if (task_queues_async_refs_ == 0)
    uv_unref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
  else
    uv_ref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",42,,635,2,,void
77128,BLOCK,-1,,<empty>,5,,639,2,,void
77135,BLOCK,-1,,<empty>,5,,641,1,,void
77145,BLOCK,-1,,"{
  NoArrayBufferZeroFillScope no_zero_fill_scope(isolate_data());
  std::unique_ptr<v8::BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(isolate(), suggested_size);
  uv_buf_t buf = uv_buf_init(static_cast<char*>(bs->Data()), bs->ByteLength());
  released_allocated_buffers_.emplace(buf.base, std::move(bs));
  return buf;
}",76,,644,2,,void
77199,BLOCK,-1,,"{
  std::unique_ptr<v8::BackingStore> bs;
  if (buf.base != nullptr) {
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }
  return bs;
}",26,,654,2,,void
77215,BLOCK,-1,,"{
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }",28,,656,2,,void
77252,BLOCK,-1,,"{
  char exec_path_buf[2 * PATH_MAX];
  size_t exec_path_len = sizeof(exec_path_buf);
  std::string exec_path;
  if (uv_exepath(exec_path_buf, &exec_path_len) == 0) {
    exec_path = std::string(exec_path_buf, exec_path_len);
  } else if (argv.size() > 0) {
    exec_path = argv[0];
  }

  // On OpenBSD process.execPath will be relative unless we
  // get the full path before process.execPath is used.
#if defined(__OpenBSD__)
  uv_fs_t req;
  req.ptr = nullptr;
  if (0 ==
      uv_fs_realpath(nullptr, &req, exec_path.c_str(), nullptr)) {
    CHECK_NOT_NULL(req.ptr);
    exec_path = std::string(static_cast<char*>(req.ptr));
  }
  uv_fs_req_cleanup(&req);
#endif

  return exec_path;
}",63,,665,2,,void
77267,BLOCK,-1,,"{
    exec_path = std::string(exec_path_buf, exec_path_len);
  }",55,,669,2,,void
77277,BLOCK,-1,,<empty>,10,,671,1,,void
77285,BLOCK,-1,,"{
    exec_path = argv[0];
  }",31,,671,2,,void
77303,BLOCK,-1,,"{
  constexpr bool is_shared_ro_heap =
#ifdef NODE_V8_SHARED_RO_HEAP
      true;
#else
      false;
#endif
  if (is_shared_ro_heap && !is_main_thread()) {
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  } else if (isolate_data->snapshot_data() != nullptr) {
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }

  // We'll be creating new objects so make sure we've entered the context.
  HandleScope handle_scope(isolate);

  // Set some flags if only kDefaultFlags was passed. This can make API version
  // transitions easier for embedders.
  if (flags_ & EnvironmentFlags::kDefaultFlags) {
    flags_ = flag...",38,,723,8,,void
77313,BLOCK,-1,,"{
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  }",47,,730,2,,void
77334,BLOCK,-1,,<empty>,10,,736,1,,void
77342,BLOCK,-1,,"{
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }",56,,736,2,,void
77362,BLOCK,-1,,"{
    flags_ = flags_ |
        EnvironmentFlags::kOwnsProcessState |
        EnvironmentFlags::kOwnsInspector;
  }",49,,747,2,,void
77429,BLOCK,-1,,"{
    set_abort_on_uncaught_exception(false);
  }",56,,768,2,,void
77433,BLOCK,-1,,<empty>,7,,777,1,,void
77438,BLOCK,-1,,"{
    trace_state_observer_ = std::make_unique<TrackingTraceStateObserver>(this);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->AddTraceStateObserver(trace_state_observer_.get());
  }",69,,777,2,,void
77449,BLOCK,-1,,<empty>,9,,779,1,,void
77457,BLOCK,-1,,<empty>,7,,780,2,,void
77494,BLOCK,-1,,"{
    auto traced_value = tracing::TracedValue::Create();
    traced_value->BeginArray(""args"");
    for (const std::string& arg : args) traced_value->AppendString(arg);
    traced_value->EndArray();
    traced_value->BeginArray(""exec_args"");
    for (const std::string& arg : exec_args) traced_value->AppendString(arg);
    traced_value->EndArray();
    TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE1(environment),
                                      ""Environment"",
                                      this,
                                      ""args"",
                                      std::move(traced_value));
  }",54,,789,2,,void
77553,BLOCK,-1,,"{
    permission()->EnablePermissions();
    // If any permission is set the process shouldn't be able to neither
    // spawn/worker nor use addons or enable inspector
    // unless explicitly allowed by the user
    if (!options_->allow_fs_read.empty() || !options_->allow_fs_write.empty()) {
      options_->allow_native_addons = false;
      flags_ = flags_ | EnvironmentFlags::kNoCreateInspector;
      permission()->Apply(""*"", permission::PermissionScope::kInspector);
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }

    if (!options_->allow_fs_read.empty()) {
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }

    if (!options_->allow_fs_write.empty()) {
      permission()->Apply(options...",42,,804,2,,void
77574,BLOCK,-1,,"{
      options_->allow_native_addons = false;
      flags_ = flags_ | EnvironmentFlags::kNoCreateInspector;
      permission()->Apply(""*"", permission::PermissionScope::kInspector);
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }",80,,809,2,,void
77602,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }",43,,813,2,,void
77618,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }",44,,816,2,,void
77637,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }",43,,821,2,,void
77658,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_write,
                          permission::PermissionScope::kFileSystemWrite);
    }",44,,826,2,,void
77676,BLOCK,-1,,"{
  principal_realm_ = std::make_unique<PrincipalRealm>(
      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
  if (env_info != nullptr) {
    DeserializeProperties(env_info);
  }

  if (!options_->force_async_hooks_checks) {
    async_hooks_.no_force_checks();
  }

  // By default, always abort when --abort-on-uncaught-exception was passed.
  should_abort_on_uncaught_toggle_[0] = 1;

  // The process is not exiting by default.
  set_exiting(false);

  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_ENVIRONMENT,
                           environment_start_);
  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_NODE_START,
                           per_process::node_start_time);

  if (per_process::v8_initialized) {
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }
}",75,,834,3,,void
77696,BLOCK,-1,,"{
    DeserializeProperties(env_info);
  }",28,,837,2,,void
77704,BLOCK,-1,,"{
    async_hooks_.no_force_checks();
  }",44,,841,2,,void
77738,BLOCK,-1,,"{
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }",36,,856,2,,void
77752,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Local<Context> ctx = context();

  if (Environment** interrupt_data = interrupt_data_.load()) {
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }

  // FreeEnvironment() should have set this.
  CHECK(is_stopping());

  if (heapsnapshot_near_heap_limit_callback_added_) {
    RemoveHeapSnaps...",29,,862,1,,void
77764,BLOCK,-1,,<empty>,7,,866,1,,void
77772,BLOCK,-1,,"{
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }",62,,866,2,,void
77807,BLOCK,-1,,<empty>,7,,885,2,,void
77818,BLOCK,-1,,"{
    RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",53,,893,2,,void
77842,BLOCK,-1,,"{
    tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
    CHECK_NOT_NULL(writer);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->RemoveTraceStateObserver(trace_state_observer_.get());
  }",30,,910,2,,void
77850,BLOCK,-1,,<empty>,9,,913,1,,void
77858,BLOCK,-1,,<empty>,7,,914,2,,void
77875,BLOCK,-1,,"{
    // Dereference all addons that were loaded into this environment.
    for (binding::DLib& addon : loaded_addons_) {
      addon.Close();
    }
  }",26,,925,2,,void
77879,BLOCK,-1,,"{
      addon.Close();
    }",49,,927,3,,void
77887,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Context::Scope context_scope(context());

  CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));

  CHECK_EQ(0, uv_check_init(event_loop(), immediate_check_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));

  CHECK_EQ(0, uv_idle_init(event_loop(), immediate_idle_handle()));

  CHECK_EQ(0, uv_check_start(immediate_check_handle(), CheckImmediate));

  // Inform V8's CPU profiler when we're idle.  The profiler is sampling-based
  // but not all samples are created equal; mark the wall clock time spent in
  // epoll_wait() and friends so profiling tools can filter it out.  The samples
  // still end up in v8.log but with state=IDLE rather than state=EXTERNAL.
  CHECK_EQ(0, uv_prepare_init(event_loop(), &idle_prepare_handle_));
  CHECK_EQ(0, uv_check_init(event_loop(), &idle_check_handle_));

  CHECK_EQ(0, uv_async_init(
      event_loop(),
      &ta...",37,,933,1,,void
77956,BLOCK,17,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = true;
    if (native_immediates_threadsafe_.size() > 0 ||
        native_immediates_interrupts_.size() > 0) {
      uv_async_send(&task_queues_async_);
    }
  }",3,,968,17,,void
77977,BLOCK,-1,,"{
      uv_async_send(&task_queues_async_);
    }",51,,972,2,,void
77985,BLOCK,-1,,"{
  // Should not access non-thread-safe methods here.
  set_stopping(true);
  if ((flags & StopFlags::kDoNotTerminateIsolate) == 0)
    isolate_->TerminateExecution();
  SetImmediateThreadsafe([](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  });
}",51,,986,2,,void
77996,BLOCK,-1,,<empty>,5,,990,2,,void
78006,BLOCK,-1,,"{
  HandleCleanupCb close_and_finish = [](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  };

  auto register_handle = [&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  };
  register_handle(reinterpret_cast<uv_handle_t*>(timer_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_idle_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_prepare_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_check_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",44,,997,1,,void
78044,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }

  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate(),
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);

  RunAndClearNativeImmediates(true /* skip unrefed SetImmediate()s */);

  for (ReqWrapBase* request : req_wrap_queue_)
    request->Cancel();

  for (HandleWrap* handle : handle_wrap_queue_)
    handle->Close();

  for (HandleCleanup& hc : handle_cleanup_queue_)
    hc.cb_(this, hc.handle_, hc.arg_);
  handle_cleanup_queue_.clear();

  while (handle_cleanup_waiting_ != 0 ||
         request_waiting_ != 0 ||
         !handle_wrap_queue_.IsEmpty()) {
    uv_run(event_loop(), UV_RUN_ONCE);
  }
}",36,,1020,1,,void
78045,BLOCK,1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }",3,,1021,1,,void
78108,BLOCK,-1,,"{
    uv_run(event_loop(), UV_RUN_ONCE);
  }",41,,1043,2,,void
78115,BLOCK,-1,,"{
  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  });
  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  });
}",47,,1048,1,,void
78127,BLOCK,-1,,"{
  if (!trace_sync_io_) return;

  HandleScope handle_scope(isolate());

  fprintf(
      stderr, ""(node:%d) WARNING: Detected use of sync API\n"", uv_os_getpid());
  PrintStackTrace(isolate(),
                  StackTrace::CurrentStackTrace(
                      isolate(), stack_trace_limit(), StackTrace::kDetailed));
}",42,,1059,1,,void
78131,BLOCK,-1,,<empty>,24,,1060,2,,void
78154,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_serialize_callback().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",69,,1071,1,,void
78164,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",49,,1073,2,,void
78195,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_deserialize_main().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",67,,1081,1,,void
78205,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",47,,1083,2,,void
78236,BLOCK,-1,,"{
  started_cleanup_ = true;
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunCleanup"");
  // Only BaseObject's cleanups are registered as per-realm cleanup hooks now.
  // Defer the BaseObject cleanup after handles are cleaned up.
  CleanupHandles();

  while (!cleanup_queue_.empty() || principal_realm_->HasCleanupHooks() ||
         native_immediates_.size() > 0 ||
         native_immediates_threadsafe_.size() > 0 ||
         native_immediates_interrupts_.size() > 0) {
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }

  for (const int fd : unmanaged_fds_) {
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }
}",32,,1091,1,,void
78277,BLOCK,-1,,"{
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }",52,,1101,2,,void
78290,BLOCK,-1,,"{
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }",39,,1108,3,,void
78304,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""AtExit"");
  for (ExitCallback at_exit : at_exit_functions_) {
    at_exit.cb_(at_exit.arg_);
  }
  at_exit_functions_.clear();
}",40,,1115,1,,void
78312,BLOCK,-1,,"{
    at_exit.cb_(at_exit.arg_);
  }",51,,1117,3,,void
78329,BLOCK,-1,,"{
  at_exit_functions_.push_front(ExitCallback{cb, arg});
}",60,,1123,3,,void
78341,BLOCK,-1,,"{
  while (native_immediates_interrupts_.size() > 0) {
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }
}",43,,1127,1,,void
78349,BLOCK,-1,,"{
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }",52,,1128,2,,void
78351,BLOCK,2,,"{
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }",5,,1130,2,,void
78376,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment),
               ""RunAndClearNativeImmediates"");
  HandleScope handle_scope(isolate_);
  // In case the Isolate is no longer accessible just use an empty Local. This
  // is not an issue for InternalCallbackScope as this case is already handled
  // in its constructor but we avoid calls into v8 which can crash the process
  // in debug builds.
  Local<Object> obj =
      can_call_into_js() ? Object::New(isolate_) : Local<Object>();
  InternalCallbackScope cb_scope(this, obj, {0, 0});

  size_t ref_count = 0;

  // Handle interrupts first. These functions are not allowed to throw
  // exceptions, so we do not need to handle that.
  RunAndClearInterrupts();

  auto drain_list = [&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_c...",64,,1141,2,,void
78417,BLOCK,-1,,<empty>,43,,1181,2,,void
78430,BLOCK,-1,,<empty>,5,,1186,2,,void
78441,BLOCK,-1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    threadsafe_immediates.ConcatMove(std::move(native_immediates_threadsafe_));
  }",49,,1196,2,,void
78458,BLOCK,-1,,<empty>,46,,1200,2,,void
78462,BLOCK,-1,,"{
  // The Isolate may outlive the Environment, so some logic to handle the
  // situation in which the Environment is destroyed before the handler runs
  // is required.

  // We allocate a new pointer to a pointer to this Environment instance, and
  // try to set it as interrupt_data_. If interrupt_data_ was already set, then
  // callbacks are already scheduled to run and we can delete our own pointer
  // and just return. If it was nullptr previously, the Environment** is stored;
  // ~Environment sets the Environment* contained in it to nullptr, so that
  // the callback can check whether ~Environment has already run and it is thus
  // not safe to access the Environment instance itself.
  Environment** interrupt_data = new Environment*(this);
  Environment** dummy = nullptr;
  if (!interrupt_data_.compare_exchange_strong(dummy, interrupt_data)) {
    delete interrupt_data;
    return;  // Already scheduled.
  }

  isolate()->RequestInterrupt([](Isolate* isolate, void* data) {
...",44,,1203,1,,void
78481,BLOCK,-1,,"{
    delete interrupt_data;
    return;  // Already scheduled.
  }",72,,1217,2,,void
78495,BLOCK,-1,,"{
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}",54,,1236,2,,void
78498,BLOCK,-1,,<empty>,25,,1237,2,,void
78509,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  } else {
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }
}",44,,1241,2,,void
78512,BLOCK,-1,,<empty>,25,,1242,2,,void
78516,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",12,,1244,2,,void
78522,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",10,,1246,1,,void
78531,BLOCK,-1,,"{
  Environment* env = Environment::from_timer_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunTimers"");

  if (!env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  InternalCallbackScope scope(env, process, {0, 0});

  Local<Function> cb = env->timers_callback_function();
  MaybeLocal<Value> ret;
  Local<Value> arg = env->GetNow();
  // This code will loop until all currently due timers will process. It is
  // impossible for us to end up in an infinite loop due to how the JS-side
  // is structured.
  do {
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  } while (ret.IsEmpty() && env->can_call_into_js());

  // NOTE(apapirovski): If it ever becomes possible that `call_into_js` above
  // is reset back to `true` after being previously set to `false` then this
...",49,,1251,2,,void
78550,BLOCK,-1,,<empty>,5,,1256,2,,void
78607,BLOCK,-1,,"{
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  }",6,,1270,1,,void
78644,BLOCK,-1,,<empty>,5,,1282,2,,void
78673,BLOCK,-1,,"{
    int64_t duration_ms =
        llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base());

    env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1);

    if (expiry_ms > 0)
      uv_ref(h);
    else
      uv_unref(h);
  }",23,,1296,2,,void
78704,BLOCK,-1,,<empty>,7,,1303,2,,void
78708,BLOCK,-1,,<empty>,7,,1305,1,,void
78712,BLOCK,-1,,"{
    uv_unref(h);
  }",10,,1306,1,,void
78719,BLOCK,-1,,"{
  Environment* env = Environment::from_immediate_check_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""CheckImmediate"");

  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  env->RunAndClearNativeImmediates();

  if (env->immediate_info()->count() == 0 || !env->can_call_into_js())
    return;

  do {
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());

  if (env->immediate_info()->ref_count() == 0)
    env->ToggleImmediateRef(false);
}",54,,1312,2,,void
78764,BLOCK,-1,,<empty>,5,,1322,2,,void
78767,BLOCK,-1,,"{
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  }",6,,1324,1,,void
78811,BLOCK,-1,,<empty>,5,,1334,2,,void
78821,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  } else {
    uv_idle_stop(immediate_idle_handle());
  }
}",48,,1337,2,,void
78824,BLOCK,-1,,<empty>,25,,1338,2,,void
78828,BLOCK,-1,,"{
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  }",12,,1340,2,,void
78833,BLOCK,-1,,"{
    uv_idle_stop(immediate_idle_handle());
  }",10,,1343,1,,void
78838,BLOCK,-1,,"{
  uv_update_time(event_loop());
  uint64_t now = uv_now(event_loop());
  CHECK_GE(now, timer_base());
  now -= timer_base();
  return now;
}",38,,1348,1,,void
78856,BLOCK,-1,,"{
  uint64_t now = GetNowUint64();
  if (now <= 0xffffffff)
    return Integer::NewFromUnsigned(isolate(), static_cast<uint32_t>(now));
  else
    return Number::New(isolate(), static_cast<double>(now));
}",36,,1356,1,,void
78865,BLOCK,-1,,<empty>,5,,1359,2,,void
78876,BLOCK,-1,,<empty>,5,,1361,1,,void
78897,BLOCK,-1,,"{
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest != nullptr) {
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }

  if (syscall != nullptr) {
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }
}",45,,1371,9,,void
78947,BLOCK,-1,,"{
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }",27,,1379,2,,void
78978,BLOCK,-1,,"{
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }",24,,1385,2,,void
79020,BLOCK,-1,,"{
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }",24,,1392,2,,void
79057,BLOCK,-1,,"{
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }",27,,1398,2,,void
79088,BLOCK,-1,,"{
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",60,,1409,7,,void
79099,BLOCK,-1,,<empty>,5,,1411,2,,void
79126,BLOCK,-1,,"{
    message = uv_strerror(errorno);
  }",49,,1416,2,,void
79148,BLOCK,-1,,<empty>,69,,1425,3,,void
79154,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",55,,1428,3,,void
79160,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",57,,1432,2,,void
79171,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",65,,1437,3,,void
79187,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",62,,1442,2,,void
79199,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",71,,1447,3,,void
79205,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",52,,1451,2,,void
79216,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",60,,1456,3,,void
79232,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",57,,1461,2,,void
79244,BLOCK,-1,,<empty>,79,,1467,3,,void
79250,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  if (info == nullptr) {
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kA...",19,,1474,3,,void
79258,BLOCK,-1,,"{
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kAsyncIdCounter] = 1;
  }",24,,1476,2,,void
79284,BLOCK,-1,,"{
  async_ids_stack_.Deserialize(context);
  fields_.Deserialize(context);
  async_id_fields_.Deserialize(context);

  Local<Array> js_execution_async_resources;
  if (info_->js_execution_async_resources != 0) {
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  } else {
    js_execution_async_resources = Array::New(context->GetIsolate());
  }
  js_execution_async_resources_.Reset(
      context->GetIsolate(), js_execution_async_resources);

  // The native_execution_async_resources_ field requires v8::Local<> instances
  // for async calls whose resources were on the stack as JS objects when they
  // were entered. We cannot recreate this here; however, storing these values
  // on the JS equivalent gives the same result, so we do that instead.
  for (size_t i = 0; i < info_->native_execution_async_resources.size(); ++i) {
    if (info_->native_execution_async_resources[i] == SIZE_...",54,,1498,2,,void
79311,BLOCK,-1,,"{
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  }",49,,1504,2,,void
79327,BLOCK,-1,,"{
    js_execution_async_resources = Array::New(context->GetIsolate());
  }",10,,1508,1,,void
79348,BLOCK,-1,,<empty>,3,,1518,1,,void
79363,BLOCK,4,,"{
    if (info_->native_execution_async_resources[i] == SIZE_MAX)
      continue;
    Local<Object> obj = context->GetDataFromSnapshotOnce<Object>(
                                   info_->native_execution_async_resources[i])
                               .ToLocalChecked();
    js_execution_async_resources->Set(context, i, obj).Check();
  }",79,,1518,4,,void
79372,BLOCK,-1,,<empty>,7,,1520,2,,void
79412,BLOCK,-1,,"{
  output << ""{\n""
         << ""  "" << i.async_ids_stack << "",  // async_ids_stack\n""
         << ""  "" << i.fields << "",  // fields\n""
         << ""  "" << i.async_id_fields << "",  // async_id_fields\n""
         << ""  "" << i.js_execution_async_resources
         << "",  // js_execution_async_resources\n""
         << ""  "" << i.native_execution_async_resources
         << "",  // native_execution_async_resources\n""
         << ""}"";
  return output;
}",62,,1530,3,,void
79465,BLOCK,-1,,"{
  SerializeInfo info;
  // TODO(joyeecheung): some of these probably don't need to be serialized.
  info.async_ids_stack = async_ids_stack_.Serialize(context, creator);
  info.fields = fields_.Serialize(context, creator);
  info.async_id_fields = async_id_fields_.Serialize(context, creator);
  if (!js_execution_async_resources_.IsEmpty()) {
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  } else {
    info.js_execution_async_resources = 0;
  }

  info.native_execution_async_resources.resize(
      native_execution_async_resources_.size());
  for (size_t i = 0; i < native_execution_async_resources_.size(); i++) {
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }

  // A...",75,,1544,3,,void
79503,BLOCK,-1,,"{
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  }",49,,1550,2,,void
79527,BLOCK,-1,,"{
    info.js_execution_async_resources = 0;
  }",10,,1554,1,,void
79544,BLOCK,-1,,<empty>,3,,1560,1,,void
79557,BLOCK,4,,"{
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }",73,,1560,4,,void
79614,BLOCK,-1,,"{
  tracker->TrackField(""async_ids_stack"", async_ids_stack_);
  tracker->TrackField(""fields"", fields_);
  tracker->TrackField(""async_id_fields"", async_id_fields_);
  tracker->TrackField(""js_promise_hooks"", js_promise_hooks_);
}",59,,1578,2,,void
79642,BLOCK,-1,,"{
  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);

  env()->async_hooks_binding()->Set(
      env()->context(),
      env()->async_ids_stack_string(),
      async_ids_stack_.GetJSArray()).Check();
}",41,,1585,1,,void
79679,BLOCK,-1,,"{
  fprintf(stderr,
          ""Error: async hook stack has become corrupted (""
          ""actual: %.f, expected: %.f)\n"",
          async_id_fields_.GetValue(kExecutionAsyncId),
          expected_async_id);
  DumpBacktrace(stderr);
  fflush(stderr);
  // TODO(joyeecheung): should this exit code be more specific?
  if (!env()->abort_on_uncaught_exception()) Exit(ExitCode::kGenericUserError);
  fprintf(stderr, ""\n"");
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",72,,1594,2,,void
79698,BLOCK,-1,,<empty>,46,,1603,2,,void
79713,BLOCK,-1,,"{
  if (options()->trace_exit) {
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }
  process_exit_handler_(this, exit_code);
}",44,,1609,2,,void
79718,BLOCK,-1,,"{
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }",30,,1610,2,,void
79732,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    }",27,,1615,2,,void
79738,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }",12,,1617,1,,void
79763,BLOCK,-1,,"{
  DCHECK_EQ(Isolate::GetCurrent(), isolate());

  while (!sub_worker_contexts_.empty()) {
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }
}",46,,1632,1,,void
79776,BLOCK,-1,,"{
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }",41,,1635,2,,void
79801,BLOCK,-1,,"{
  if (worker_context() == nullptr) return nullptr;
  return worker_context()->env();
}",53,,1643,1,,void
79806,BLOCK,-1,,<empty>,36,,1644,2,,void
79818,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  auto result = unmanaged_fds_.insert(fd);
  if (!result.second) {
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }
}",42,,1648,2,,void
79822,BLOCK,-1,,<empty>,32,,1649,2,,void
79837,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }",23,,1651,2,,void
79846,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  size_t removed_count = unmanaged_fds_.erase(fd);
  if (removed_count == 0) {
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }
}",45,,1657,2,,void
79850,BLOCK,-1,,<empty>,32,,1658,2,,void
79864,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }",27,,1660,2,,void
79872,BLOCK,-1,,"{
  if (enabled_debug_list()->enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }
}",49,,1666,1,,void
79881,BLOCK,-1,,"{
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }",65,,1667,2,,void
79893,BLOCK,-1,,"{
  EnvSerializeInfo info;
  Local<Context> ctx = context();

  info.async_hooks = async_hooks_.Serialize(ctx, creator);
  info.immediate_info = immediate_info_.Serialize(ctx, creator);
  info.timeout_info = timeout_info_.Serialize(ctx, creator);
  info.tick_info = tick_info_.Serialize(ctx, creator);
  info.performance_state = performance_state_->Serialize(ctx, creator);
  info.exit_info = exit_info_.Serialize(ctx, creator);
  info.stream_base_state = stream_base_state_.Serialize(ctx, creator);
  info.should_abort_on_uncaught_toggle =
      should_abort_on_uncaught_toggle_.Serialize(ctx, creator);

  info.principal_realm = principal_realm_->Serialize(creator);
  // For now we only support serialization of the main context.
  // TODO(joyeecheung): support de/serialization of vm contexts.
  CHECK_EQ(contexts_.size(), 1);
  CHECK_EQ(contexts_[0], context());
  return info;
}",67,,1673,2,,void
80011,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}",74,,1698,5,,void
80039,BLOCK,-1,,"{
  HandleScope scope(isolate());
  Local<Context> ctx = context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }
}",44,,1704,1,,void
80060,BLOCK,-1,,"{
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }",42,,1708,2,,void
80116,BLOCK,-1,,"{
  Local<Context> ctx = context();

  if (enabled_debug_list_.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

  // Deserialize the realm's properties before running the deserialize
  // requests as the requests may need to access the realm's properties.
  principal_realm_->DeserializeProperties(&info->principal_realm);
  RunDeserializeRequests();

  async_hooks_.Deserialize(ctx);
  immediate_info_.Deserialize(ctx);
  timeout_info_.Deserialize(ctx);
  tick_info_.Deserialize(ctx);
  performance_state_->Deserialize(ctx);
  exit_info_.Deserialize(ctx);
  stream_base_state_.Deserialize(ctx);
  should_abort_on_uncaught_toggle_.Deserialize(ctx);
}",71,,1718,2,,void
80132,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",63,,1721,2,,void
80196,BLOCK,-1,,"{
  uint64_t free_in_system = uv_get_free_memory();
  size_t allowed = uv_get_constrained_memory();
  if (allowed == 0) {
    return free_in_system;
  }
  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err) {
    return free_in_system;
  }
  if (allowed < rss) {
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }
  // There may still be room for swap, but we will just leave it here.
  return allowed - rss;
}",45,,1741,1,,void
80209,BLOCK,-1,,"{
    return free_in_system;
  }",21,,1744,2,,void
80221,BLOCK,-1,,"{
    return free_in_system;
  }",12,,1749,2,,void
80228,BLOCK,-1,,"{
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }",22,,1752,2,,void
80241,BLOCK,-1,,"{
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  // Start traversing embedder objects from the root Environment object.
  tracker.Track(env);
}",50,,1762,4,,void
80263,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  Debug(env,
        DebugCategory::DIAGNOSTICS,
        ""Invoked NearHeapLimitCallback, processing=%d, ""
        ""current_limit=%"" PRIu64 "", ""
        ""initial_limit=%"" PRIu64 ""\n"",
        env->is_in_heapsnapshot_heap_limit_callback_,
        static_cast<uint64_t>(current_heap_limit),
        static_cast<uint64_t>(initial_heap_limit));

  size_t max_young_gen_size = env->isolate_data()->max_young_gen_size;
  size_t young_gen_size = 0;
  size_t old_gen_size = 0;

  HeapSpaceStatistics stats;
  size_t num_heap_spaces = env->isolate()->NumberOfHeapSpaces();
  for (size_t i = 0; i < num_heap_spaces; ++i) {
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }

  Debug(env,
        DebugCa...",70,,1771,4,,void
80300,BLOCK,-1,,<empty>,3,,1789,1,,void
80310,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }",48,,1789,4,,void
80339,BLOCK,-1,,"{
      young_gen_size += stats.space_used_size();
    }",68,,1792,2,,void
80347,BLOCK,-1,,"{
      old_gen_size += stats.space_used_size();
    }",12,,1794,1,,void
80374,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots in nested callback. ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
    return new_limit;
  }",53,,1832,2,,void
80382,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots because it's too risky.\n"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
    // The new limit must be higher than current_heap_limit or V8 might
    // crash.
    return new_limit;
  }",39,,1844,2,,void
80415,BLOCK,-1,,"{
    dir = env->GetCwd();
  }",20,,1858,2,,void
80487,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Removing the near heap limit callback"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",79,,1879,2,,void
80524,BLOCK,-1,,"{
  size_t size = sizeof(*this);
  // Remove non pointer fields that will be tracked in MemoryInfo()
  // TODO(joyeecheung): refactor the MemoryTracker interface so
  // this can be done for common types within the Track* calls automatically
  // if a certain scope is entered.
  size -= sizeof(async_hooks_);
  size -= sizeof(cleanup_queue_);
  size -= sizeof(tick_info_);
  size -= sizeof(immediate_info_);
  return size;
}",45,,1898,1,,void
80553,BLOCK,-1,,"{
  // Iteratable STLs have their own sizes subtracted from the parent
  // by default.
  tracker->TrackField(""isolate_data"", isolate_data_);
  tracker->TrackField(""destroy_async_id_list"", destroy_async_id_list_);
  tracker->TrackField(""exec_argv"", exec_argv_);
  tracker->TrackField(""exit_info"", exit_info_);
  tracker->TrackField(""should_abort_on_uncaught_toggle"",
                      should_abort_on_uncaught_toggle_);
  tracker->TrackField(""stream_base_state"", stream_base_state_);
  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""async_hooks"", async_hooks_);
  tracker->TrackField(""immediate_info"", immediate_info_);
  tracker->TrackField(""timeout_info"", timeout_info_);
  tracker->TrackField(""tick_info"", tick_info_);
  tracker->TrackField(""principal_realm"", principal_realm_);
  tracker->TrackField(""shadow_realms"", shadow_realms_);

  // FIXME(joyeecheung): track other fields in Environment.
  // Currently MemoryTracker is unable to track these
  // corre...",60,,1911,2,,void
80635,BLOCK,-1,,"{
  isolate()->ClearKeptObjects();
}",39,,1940,1,,void
80714,BLOCK,-1,,<empty>,1,,1,1,,ANY
80719,BLOCK,-1,,<empty>,1,,1,1,,ANY
80738,BLOCK,-1,,<empty>,1,,1,1,,ANY
80747,BLOCK,-1,,<empty>,,,,5,,<empty>
80752,BLOCK,-1,,<empty>,,,,2,,<empty>
80757,BLOCK,-1,,<empty>,,,,2,,<empty>
80762,BLOCK,-1,,<empty>,,,,2,,<empty>
80767,BLOCK,-1,,<empty>,,,,2,,<empty>
80774,BLOCK,-1,,<empty>,,,,3,,<empty>
80778,BLOCK,-1,,<empty>,,,,1,,<empty>
80786,BLOCK,-1,,<empty>,,,,5,,<empty>
80793,BLOCK,-1,,<empty>,,,,1,,<empty>
80802,BLOCK,-1,,"{
  MarkAsUninitialized();
}",51,,84,3,,void
80808,BLOCK,-1,,"{
  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  args.GetReturnValue().Set(!wrap->IsHandleClosing());
}",75,,89,2,,void
80841,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      FSEventWrap::kInternalFieldCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, t, ""start"", Start);

  Local<FunctionTemplate> get_initialized_templ =
      FunctionTemplate::New(env->isolate(),
                            GetInitialized,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));

  t->PrototypeTemplate()->SetAccessorProperty(
      FIXED_ONE_BYTE_STRING(env->isolate(), ""initialized""),
      get_initialized_templ,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum));

  SetConstructorFunction(context, target, ""FSEvent"", t);
}",42,,98,5,,void
80946,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Start);
  registry->Register(GetInitialized);
}",42,,125,2,,void
80966,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new FSEventWrap(env, args.This());
}",64,,131,2,,void
80991,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }

  // Check for persistent argument
  if (!args[1]->IsTru...",66,,138,2,,void
81060,BLOCK,-1,,<empty>,5,,155,2,,void
81096,BLOCK,-1,,"{
    return args.GetReturnValue().Set(err);
  }",17,,160,2,,void
81125,BLOCK,-1,,"{
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }",17,,167,2,,void
81148,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&wrap->handle_));
  }",27,,173,2,,void
81171,BLOCK,-1,,"{
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> event_string;
  if (status) {
    event_string = String::Empty(env->isolate());
  } else if (events...",29,,182,5,,void
81215,BLOCK,-1,,"{
    event_string = String::Empty(env->isolate());
  }",15,,203,2,,void
81227,BLOCK,-1,,<empty>,10,,205,1,,void
81232,BLOCK,-1,,"{
    event_string = env->rename_string();
  }",34,,205,2,,void
81240,BLOCK,-1,,<empty>,10,,207,1,,void
81245,BLOCK,-1,,"{
    event_string = env->change_string();
  }",34,,207,2,,void
81253,BLOCK,-1,,"{
    UNREACHABLE(""bad fs events flag"");
  }",10,,209,1,,void
81279,BLOCK,-1,,"{
    Local<Value> error;
    MaybeLocal<Value> fn = StringBytes::Encode(env->isolate(),
                                               filename,
                                               wrap->encoding_,
                                               &error);
    if (fn.IsEmpty()) {
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    } else {
      argv[2] = fn.ToLocalChecked();
    }
  }",28,,219,2,,void
81310,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    }",23,,225,2,,void
81346,BLOCK,-1,,"{
      argv[2] = fn.ToLocalChecked();
    }",12,,232,1,,void
81383,BLOCK,-1,,<empty>,1,,1,1,,ANY
81387,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_ref(wrap->GetHandle());
}",63,,40,2,,void
81399,BLOCK,-1,,<empty>,5,,45,2,,void
81409,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_unref(wrap->GetHandle());
}",65,,49,2,,void
81421,BLOCK,-1,,<empty>,5,,54,2,,void
81431,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(HasRef(wrap));
}",66,,58,2,,void
81453,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->Close(args[0]);
}",65,,65,2,,void
81473,BLOCK,-1,,"{
  if (state_ != kInitialized)
    return;

  uv_close(handle_, OnClose);
  state_ = kClosing;

  if (!close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }
}",53,,72,2,,void
81478,BLOCK,-1,,<empty>,5,,74,2,,void
81503,BLOCK,-1,,"{
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }",32,,80,2,,void
81523,BLOCK,-1,,"{
  // When all references to a HandleWrap are lost and the object is supposed to
  // be destroyed, we first call Close() to clean up the underlying libuv
  // handle. The OnClose callback then acquires and destroys another reference
  // to that object, and when that reference is lost, we perform the default
  // action (i.e. destroying `this`).
  if (state_ != kClosed) {
    Close();
  } else {
    BaseObject::OnGCCollect();
  }
}",32,,88,1,,void
81528,BLOCK,-1,,"{
    Close();
  }",26,,94,2,,void
81531,BLOCK,-1,,"{
    BaseObject::OnGCCollect();
  }",10,,96,1,,void
81539,BLOCK,-1,,"{
  return IsWeakOrDetached() ||
         !HandleWrap::HasRef(this) ||
         !uv_is_active(GetHandle());
}",60,,102,1,,void
81556,BLOCK,-1,,"{
  env()->handle_wrap_queue()->PushBack(this);
  state_ = kInitialized;
}",38,,109,1,,void
81571,BLOCK,-1,,"{
  handle_wrap_queue_.Remove();
  state_ = kClosed;
}",40,,115,1,,void
81586,BLOCK,-1,,"{
  handle_->data = this;
  HandleScope scope(env->isolate());
  CHECK(env->has_run_bootstrapping_code());
  env->handle_wrap_queue()->PushBack(this);
}",23,,127,5,,void
81615,BLOCK,-1,,"{
  CHECK_NOT_NULL(handle->data);
  BaseObjectPtr<HandleWrap> wrap { static_cast<HandleWrap*>(handle->data) };
  wrap->Detach();

  Environment* env = wrap->env();
  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->state_, kClosing);

  wrap->state_ = kClosed;

  wrap->OnClose();
  wrap->handle_wrap_queue_.Remove();

  if (!wrap->persistent().IsEmpty() &&
      wrap->object()->Has(env->context(), env->handle_onclose_symbol())
      .FromMaybe(false)) {
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }
}",47,,135,2,,void
81703,BLOCK,-1,,"{
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }",26,,153,2,,void
81718,BLOCK,-1,,"{
  return GetConstructorTemplate(env->isolate_data());
}",78,,157,2,,void
81729,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->handle_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,162,2,,void
81745,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }",23,,164,2,,void
81816,BLOCK,-1,,"{
  registry->Register(HandleWrap::Close);
  registry->Register(HandleWrap::HasRef);
  registry->Register(HandleWrap::Ref);
  registry->Register(HandleWrap::Unref);
}",42,,180,2,,void
81860,BLOCK,-1,,<empty>,1,,1,1,,ANY
81879,BLOCK,-1,,<empty>,1,,1,1,,ANY
81884,BLOCK,-1,,"{ return ""<JS Node>""; }",31,,48,1,,void
81890,BLOCK,-1,,{ return 0; },33,,49,1,,void
81896,BLOCK,-1,,{ return false; },34,,50,1,,void
81902,BLOCK,-1,,{ return PersistentToLocal::Strong(persistent_); },26,,51,1,,void
81912,BLOCK,-1,,"{
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }",22,,53,1,,void
81925,BLOCK,-1,,<empty>,24,,55,2,,void
81939,BLOCK,-1,,<empty>,22,,56,2,,void
81953,BLOCK,-1,,<empty>,23,,57,2,,void
81969,BLOCK,-1,,"{
    CHECK(!val.IsEmpty());
  }",35,,62,3,,void
81981,BLOCK,-1,,"{
      return static_cast<size_t>(n->IdentityHash());
    }",54,,67,2,,void
81995,BLOCK,-1,,"{
      return a->JSValue()->SameValue(b->JSValue());
    }",70,,73,3,,void
82014,BLOCK,-1,,<empty>,58,,84,2,,void
82019,BLOCK,-1,,"{
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",52,,86,2,,void
82046,BLOCK,-1,,<empty>,7,,90,2,,void
82074,BLOCK,-1,,"{
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",54,,95,2,,void
82099,BLOCK,-1,,"{
    edges_[from].insert(std::make_pair(name, to));
  }",75,,101,4,,void
82115,BLOCK,-1,,"{
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj...",42,,105,1,,void
82234,BLOCK,16,,"{
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edg...",5,,123,16,,void
82245,BLOCK,-1,,"{
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edges_string, Array::New(isolate_)).IsNothing()) {
          return MaybeLocal<Array>();
        }
        if (nodes->S...",53,,126,3,,void
82275,BLOCK,-1,,"{
          name_str = n->Name();
        }",32,,131,2,,void
82283,BLOCK,-1,,"{
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }",16,,133,1,,void
82381,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",80,,149,2,,void
82396,BLOCK,-1,,<empty>,11,,153,2,,void
82405,BLOCK,-1,,"{
          value = static_cast<JSGraphJSNode*>(n.get())->JSValue();
          if (obj->Set(context, value_string, value).IsNothing())
            return MaybeLocal<Array>();
        }",35,,154,2,,void
82428,BLOCK,-1,,<empty>,13,,157,2,,void
82434,BLOCK,-1,,"{
      Node* wraps = n->WrapperNode();
      if (wraps == nullptr) continue;
      Local<Object> from = info_objects[n.get()];
      Local<Object> to = info_objects[wraps];
      if (from->Set(context, wraps_string, to).IsNothing())
        return MaybeLocal<Array>();
    }",51,,162,3,,void
82446,BLOCK,-1,,<empty>,29,,164,2,,void
82480,BLOCK,-1,,<empty>,9,,168,2,,void
82486,BLOCK,-1,,"{
      Node* source = edge_info.first;
      Local<Value> edges;
      if (!info_objects[source]->Get(context, edges_string).ToLocal(&edges) ||
          !edges->IsArray()) {
        return MaybeLocal<Array>();
      }

      size_t i = 0;
      size_t j = 0;
      for (const auto& edge : edge_info.second) {
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context,...",42,,171,3,,void
82519,BLOCK,-1,,"{
        return MaybeLocal<Array>();
      }",30,,175,2,,void
82535,BLOCK,-1,,"{
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context, i++, edge_obj).IsNothing()) {
          return MaybeLocal<Array>();
        }
      }",49,,181,3,,void
82573,BLOCK,-1,,"{
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        }",35,,186,2,,void
82587,BLOCK,-1,,"{
            return MaybeLocal<Array>();
          }",43,,188,2,,void
82591,BLOCK,-1,,"{
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }",16,,191,1,,void
82640,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",73,,196,2,,void
82657,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  JSGraph graph(env->isolate());
  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);
  Local<Array> ret;
  if (graph.CreateObject().ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",66,,213,2,,void
82698,BLOCK,-1,,<empty>,5,,219,2,,void
82714,BLOCK,-1,,<empty>,69,,225,3,,void
82718,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,227,1,,void
82724,BLOCK,-1,,<empty>,31,,231,1,,void
82730,BLOCK,-1,,"{
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",68,,233,3,,void
82742,BLOCK,-1,,"{
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }",27,,236,2,,void
82772,BLOCK,-1,,"{
        status_ = num_bytes_written;
        return kAbort;
      }",34,,246,2,,void
82796,BLOCK,-1,,{ return status_; },22,,257,1,,void
82805,BLOCK,-1,,<empty>,,,,1,,<empty>
82816,BLOCK,-1,,"{
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }",38,,275,4,,void
82822,BLOCK,-1,,<empty>,34,,280,1,,void
82826,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,282,1,,void
82832,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",31,,286,1,,void
82843,BLOCK,-1,,"{
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }
    return kContinue;
  }",62,,291,3,,void
82852,BLOCK,-1,,"{
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }",22,,293,2,,void
82870,BLOCK,-1,,<empty>,9,,297,2,,void
82898,BLOCK,-1,,"{
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",28,,306,1,,void
82915,BLOCK,-1,,"{
    return 0;
  }",27,,312,1,,void
82922,BLOCK,-1,,"{
    UNREACHABLE();
  }",51,,316,2,,void
82931,BLOCK,-1,,"{
    UNREACHABLE();
  }",50,,323,5,,void
82936,BLOCK,-1,,{ return snapshot_ != nullptr; },27,,327,1,,void
82944,BLOCK,-1,,{ return snapshot_ == nullptr; },29,,328,1,,void
82952,BLOCK,-1,,{ return this; },38,,329,1,,void
82959,BLOCK,-1,,"{
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",58,,331,2,,void
82964,BLOCK,-1,,"{
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }",31,,332,2,,void
82985,BLOCK,-1,,"{
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  snapshot->Serialize(out, HeapSnapshot::kJSON);
}",69,,347,4,,void
83015,BLOCK,-1,,"{
  uv_fs_t req;
  int err;

  const int fd = uv_fs_open(nullptr,
                            &req,
                            filename,
                            O_WRONLY | O_CREAT | O_TRUNC,
                            S_IWUSR | S_IRUSR,
                            nullptr);
  uv_fs_req_cleanup(&req);
  if ((err = fd) < 0) {
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }

  FileOutputStream stream(fd, &req);
  TakeSnapshot(env, &stream, options);
  if ((err = stream.status()) < 0) {
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }

  return JustVoid();
}",70,,357,4,,void
83044,BLOCK,-1,,"{
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }",23,,368,2,,void
83074,BLOCK,-1,,"{
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }",36,,375,2,,void
83100,BLOCK,-1,,"{
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }",16,,382,2,,void
83117,BLOCK,-1,,"{
  const_cast<HeapSnapshot*>(snapshot)->Delete();
}",55,,390,2,,void
83129,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  if (env->streambaseoutputstream_constructor_template().IsEmpty()) {
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }

  Local<Object> obj;
  if (!env->streambaseoutputstream_constructor_template()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return {};
  }
  return MakeBaseObject<HeapSnapshotStream>(env, std::move(snapshot), obj);
}",55,,395,3,,void
83144,BLOCK,-1,,"{
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }",69,,398,2,,void
83229,BLOCK,-1,,"{
    return {};
  }",28,,413,2,,void
83249,BLOCK,-1,,"{
  CHECK(options_value->IsUint8Array());
  Local<Uint8Array> arr = options_value.As<Uint8Array>();
  uint8_t* options =
      static_cast<uint8_t*>(arr->Buffer()->Data()) + arr->ByteOffset();
  HeapProfiler::HeapSnapshotOptions result;
  result.snapshot_mode = options[0]
                             ? HeapProfiler::HeapSnapshotMode::kExposeInternals
                             : HeapProfiler::HeapSnapshotMode::kRegular;
  result.numerics_mode = options[1]
                             ? HeapProfiler::NumericsMode::kExposeNumericValues
                             : HeapProfiler::NumericsMode::kHideNumericValues;
  return result;
}",33,,420,2,,void
83325,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  auto options = GetHeapSnapshotOptions(args[0]);
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  CHECK(snapshot);
  BaseObjectPtr<AsyncWrap> stream =
      CreateHeapSnapshotStream(env, std::move(snapshot));
  if (stream)
    args.GetReturnValue().Set(stream->object());
}",72,,435,2,,void
83379,BLOCK,-1,,<empty>,5,,445,2,,void
83395,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  CHECK_EQ(args.Length(), 2);
  Local<Value> filename_v = args[0];
  auto options = GetHeapSnapshotOptions(args[1]);

  if (filename_v->IsUndefined()) {
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }

  BufferValue path(isolate, filename_v);
  CHECK_NOT_NULL(*path);
  if (WriteSnapshot(env, *path, options).IsNothing()) return;
  return args.GetReturnValue().Set(filename_v);
}",67,,448,2,,void
83438,BLOCK,-1,,"{
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }",34,,455,2,,void
83453,BLOCK,-1,,<empty>,57,,457,2,,void
83468,BLOCK,-1,,"{
      args.GetReturnValue().Set(filename_v);
    }",67,,458,2,,void
83494,BLOCK,-1,,<empty>,55,,466,2,,void
83512,BLOCK,-1,,"{
  SetMethod(context, target, ""buildEmbedderGraph"", BuildEmbedderGraph);
  SetMethod(context, target, ""triggerHeapSnapshot"", TriggerHeapSnapshot);
  SetMethod(
      context, target, ""createHeapSnapshotStream"", CreateHeapSnapshotStream);
}",29,,473,5,,void
83532,BLOCK,-1,,"{
  registry->Register(BuildEmbedderGraph);
  registry->Register(TriggerHeapSnapshot);
  registry->Register(CreateHeapSnapshotStream);
}",70,,480,2,,void
83561,BLOCK,-1,,<empty>,1,,1,1,,ANY
83566,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,163,3,,void
83604,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,178,3,,void
83639,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,603,3,,void
83676,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,618,3,,void
83722,BLOCK,-1,,<empty>,1,,1,1,,ANY
83726,BLOCK,-1,,"{
  hdr_histogram* histogram;
  CHECK_EQ(0, hdr_init(options.lowest,
                       options.highest,
                       options.figures,
                       &histogram));
  histogram_.reset(histogram);
}",46,,24,2,,void
83751,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""histogram"", GetMemorySize());
}",58,,33,2,,void
83762,BLOCK,-1,,<empty>,42,,38,2,,void
83767,BLOCK,-1,,<empty>,40,,41,2,,void
83774,BLOCK,-1,,"{
  MakeWeak();
}",30,,48,4,,void
83782,BLOCK,-1,,"{
  MakeWeak();
}",43,,57,4,,void
83788,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",62,,61,2,,void
83799,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",79,,65,2,,void
83830,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,73,2,,void
83871,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",69,,81,2,,void
83902,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",75,,88,2,,void
83943,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",69,,95,2,,void
83974,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Max()));
}",75,,102,2,,void
84015,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",70,,110,2,,void
84040,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",73,,116,2,,void
84071,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Exceeds()));
}",79,,123,2,,void
84112,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",72,,131,2,,void
84137,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",76,,137,2,,void
84188,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,147,2,,void
84253,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",77,,157,2,,void
84298,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,172,2,,void
84343,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",70,,186,2,,void
84361,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->RecordDelta();
}",74,,192,2,,void
84379,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  bool lossless = true;
  int64_t value = args[0]->IsBigInt()
      ? args[0].As<BigInt>()->Int64Value(&lossless)
      : static_cast<int64_t>(args[0].As<Number>()->Value());
  if (!lossless || value < 1)
    return THROW_ERR_OUT_OF_RANGE(env, ""value is out of range"");
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Record(value);
}",69,,198,2,,void
84445,BLOCK,-1,,<empty>,5,,206,2,,void
84468,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());

  CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
  HistogramBase* other;
  ASSIGN_OR_RETURN_UNWRAP(&other, args[0]);

  double count = (*histogram)->Add(*(other->histogram()));
  args.GetReturnValue().Set(count);
}",66,,212,2,,void
84530,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }

  return MakeBaseObject<HistogramBase>(env, obj, options);
}",40,,227,3,,void
84558,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,232,2,,void
84576,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }
  return MakeBaseObject<HistogramBase>(env, obj, std::move(histogram));
}",43,,241,3,,void
84604,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,246,2,,void
84625,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);

  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  CHECK_IMPLIES(!args[1]->IsNumber(), args[1]->IsBigInt());
  CHECK(args[2]->IsUint32());

  int64_t lowest = 1;
  int64_t highest = std::numeric_limits<int64_t>::max();

  bool lossless_ignored;

  if (args[0]->IsNumber()) {
    lowest = args[0].As<Integer>()->Value();
  } else if (args[0]->IsBigInt()) {
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  if (args[1]->IsNumber()) {
    highest = args[1].As<Integer>()->Value();
  } else if (args[1]->IsBigInt()) {
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  int32_t figures = args[2].As<Uint32>()->Value();
  new HistogramBase(env, args.This(), Histogram::Options {
    lowest, highest, figures
  });
}",66,,252,2,,void
84699,BLOCK,-1,,"{
    lowest = args[0].As<Integer>()->Value();
  }",28,,265,2,,void
84712,BLOCK,-1,,<empty>,10,,267,1,,void
84720,BLOCK,-1,,"{
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,267,2,,void
84741,BLOCK,-1,,"{
    highest = args[1].As<Integer>()->Value();
  }",28,,271,2,,void
84754,BLOCK,-1,,<empty>,10,,273,1,,void
84762,BLOCK,-1,,"{
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,273,2,,void
84804,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->histogram_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMetho...",32,,284,2,,void
84820,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""stdd...",23,,286,2,,void
84958,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Record);
  registry->Register(RecordDelta);
  registry->Register(Add);
}",42,,321,2,,void
85059,BLOCK,-1,,"{
  SetConstructorFunction(isolate_data->isolate(),
                         target,
                         ""Histogram"",
                         GetConstructorTemplate(isolate_data),
                         SetConstructorFunctionFlag::NONE);
}",62,,344,3,,void
85078,BLOCK,-1,,"{
  return Create(env, std::move(histogram_));
}",49,,355,4,,void
85090,BLOCK,-1,,"{
  return std::make_unique<HistogramTransferData>(this);
}",80,,359,1,,void
85103,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram_);
}",35,,364,2,,void
85114,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->intervalhistogram_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    Se...",23,,369,2,,void
85130,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ...",23,,371,2,,void
85265,BLOCK,-1,,"{
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Start);
  registry->Register(Stop);
}",42,,404,2,,void
85360,BLOCK,-1,,"{
  MakeWeak();
  uv_timer_init(env->event_loop(), &timer_);
}",44,,438,7,,void
85376,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<IntervalHistogram>();
  }

  return MakeBaseObject<IntervalHistogram>(
      env,
      obj,
      AsyncWrap::PROVIDER_ELDHISTOGRAM,
      interval,
      std::move(on_interval),
      options);
}",40,,447,5,,void
85401,BLOCK,-1,,"{
    return BaseObjectPtr<IntervalHistogram>();
  }",56,,451,2,,void
85427,BLOCK,-1,,"{
  IntervalHistogram* histogram =
      ContainerOf(&IntervalHistogram::timer_, handle);

  Histogram* h = histogram->histogram().get();

  histogram->on_interval_(*h);
}",53,,464,2,,void
85457,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",66,,473,2,,void
85468,BLOCK,-1,,"{
  if (enabled_ || IsHandleClosing()) return;
  enabled_ = true;
  if (flags == StartFlags::RESET)
    histogram()->Reset();
  uv_timer_start(&timer_, TimerCB, interval_, interval_);
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",51,,477,2,,void
85473,BLOCK,-1,,<empty>,38,,478,2,,void
85484,BLOCK,-1,,<empty>,5,,481,2,,void
85503,BLOCK,-1,,"{
  if (!enabled_ || IsHandleClosing()) return;
  enabled_ = false;
  uv_timer_stop(&timer_);
}",34,,486,1,,void
85509,BLOCK,-1,,<empty>,39,,487,2,,void
85519,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
}",72,,492,2,,void
85549,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStop();
}",71,,498,2,,void
85566,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",75,,504,2,,void
85597,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,512,2,,void
85638,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",73,,520,2,,void
85669,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,527,2,,void
85710,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",73,,534,2,,void
85741,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,541,2,,void
85782,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",74,,548,2,,void
85807,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",77,,554,2,,void
85838,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Exceeds()));
}",46,,562,2,,void
85879,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",76,,570,2,,void
85904,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",80,,576,2,,void
85955,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,586,2,,void
86020,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",46,,597,2,,void
86065,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,612,2,,void
86110,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",74,,626,2,,void
86127,BLOCK,-1,,"{
  return std::make_unique<HistogramBase::HistogramTransferData>(histogram());
}",46,,633,1,,void
86166,BLOCK,-1,,<empty>,1,,1,1,,ANY
86170,BLOCK,-1,,"{
      delegate->SendMessageToFrontend(m->string());
    }",46,,188,2,,void
86185,BLOCK,-1,,"{
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    }",63,,214,2,,void
86187,BLOCK,-1,,<empty>,11,,215,1,,void
86195,BLOCK,-1,,<empty>,42,,215,2,,void
86219,BLOCK,-1,,<empty>,1,,1,1,,ANY
86226,BLOCK,-1,,<empty>,54,,21,2,,void
86230,BLOCK,-1,,<empty>,,,,1,,<empty>
86236,BLOCK,-1,,"{
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }",54,,24,3,,void
86255,BLOCK,-1,,"{
  return std::unique_ptr<DeletableWrapper<T>>(
      new DeletableWrapper<T>(std::move(object)));
}",71,,34,2,,void
86278,BLOCK,-1,,<empty>,77,,43,3,,void
86283,BLOCK,-1,,"{
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",51,,45,2,,void
86299,BLOCK,-1,,"{
  return std::unique_ptr<Request>(
      new CreateObjectRequest<Factory>(object_id, std::move(factory)));
}",75,,55,3,,void
86320,BLOCK,-1,,<empty>,65,,62,2,,void
86325,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,64,2,,void
86338,BLOCK,-1,,<empty>,60,,75,3,,void
86343,BLOCK,-1,,"{
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",51,,77,2,,void
86359,BLOCK,-1,,<empty>,48,,91,3,,void
86365,BLOCK,-1,,"{
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",69,,96,3,,void
86381,BLOCK,-1,,<empty>,,,,2,,<empty>
86385,BLOCK,-1,,"{
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",35,,101,1,,void
86401,BLOCK,-1,,"{
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",26,,107,2,,void
86426,BLOCK,-1,,"{
    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));
  }",53,,114,3,,void
86450,BLOCK,-1,,"{
    (target->*fn)(std::move(argument));
  }",59,,123,4,,void
86468,BLOCK,-1,,<empty>,64,,135,3,,void
86474,BLOCK,-1,,"{
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }",59,,138,3,,void
86490,BLOCK,-1,,"{
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",68,,142,2,,void
86502,BLOCK,-1,,<empty>,7,,145,2,,void
86519,BLOCK,-1,,"{
    session_->Dispatch(message->string());
  }",56,,148,2,,void
86539,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",53,,167,5,,void
86557,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",53,,171,2,,void
86577,BLOCK,-1,,<empty>,70,,183,3,,void
86582,BLOCK,-1,,"{
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",80,,185,2,,void
86594,BLOCK,-1,,<empty>,72,,200,2,,void
86598,BLOCK,-1,,"{
  if (handle_)
    handle_->Reset();
}",45,,202,1,,void
86601,BLOCK,-1,,<empty>,5,,204,2,,void
86610,BLOCK,-1,,"{
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",66,,207,2,,void
86634,BLOCK,-1,,"{
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }",21,,212,2,,void
86655,BLOCK,-1,,"{
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",50,,221,1,,void
86664,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }",43,,226,2,,void
86683,BLOCK,-1,,"{
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",46,,233,1,,void
86686,BLOCK,-1,,<empty>,5,,235,2,,void
86696,BLOCK,-1,,"{
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  }",6,,238,1,,void
86702,BLOCK,-1,,"{
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }",45,,239,2,,void
86724,BLOCK,-1,,"{
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }",49,,244,2,,void
86760,BLOCK,-1,,"{
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",68,,256,1,,void
86765,BLOCK,-1,,<empty>,5,,258,2,,void
86782,BLOCK,-1,,"{
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",72,,263,3,,void
86798,BLOCK,-1,,"{
  CHECK_EQ(1, managed_objects_.erase(id));
}",48,,268,2,,void
86810,BLOCK,-1,,"{
  Deletable* pointer = GetObjectIfExists(id);
  // This would mean the object is requested after it was disposed, which is
  // a coding error.
  CHECK_NOT_NULL(pointer);
  return pointer;
}",51,,272,2,,void
86824,BLOCK,-1,,"{
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",59,,280,2,,void
86840,BLOCK,-1,,"{
    return nullptr;
  }",43,,282,2,,void
86854,BLOCK,-1,,"{
  size_t expected_u16_length =
      simdutf::utf16_length_from_utf8(message.data(), message.length());
  MaybeStackBuffer<char16_t> buffer(expected_u16_length);
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      message.data(), message.length(), buffer.out());
  StringView view(reinterpret_cast<uint16_t*>(buffer.out()), utf16_length);
  return StringBuffer::create(view);
}",80,,288,2,,void
86912,BLOCK,-1,,"{
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",28,,300,3,,void
86935,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",63,,308,2,,void
86942,BLOCK,-1,,<empty>,5,,311,2,,void
86959,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",32,,316,1,,void
86970,BLOCK,-1,,"{
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",57,,323,2,,void
87000,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",34,,330,1,,void
87026,BLOCK,-1,,<empty>,1,,1,1,,ANY
87036,BLOCK,-1,,<empty>,,,,2,,<empty>
87040,BLOCK,-1,,<empty>,,,,1,,<empty>
87045,BLOCK,-1,,<empty>,,,,1,,<empty>
87050,BLOCK,-1,,<empty>,,,,2,,<empty>
87057,BLOCK,-1,,"{
  }",57,,44,2,,void
87061,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",23,,46,1,,void
87072,BLOCK,-1,,<empty>,,,,3,,<empty>
87076,BLOCK,-1,,"{
    return ++next_object_id_;
  }",21,,53,1,,void
87084,BLOCK,-1,,<empty>,,,,2,,<empty>
87089,BLOCK,-1,,<empty>,,,,2,,<empty>
87093,BLOCK,-1,,<empty>,,,,1,,<empty>
87097,BLOCK,-1,,<empty>,,,,1,,<empty>
87106,BLOCK,-1,,<empty>,,,,1,,<empty>
87119,BLOCK,-1,,<empty>,,,,2,,<empty>
87123,BLOCK,-1,,<empty>,,,,1,,<empty>
87127,BLOCK,-1,,<empty>,,,,1,,<empty>
87132,BLOCK,-1,,<empty>,,,,2,,<empty>
87136,BLOCK,-1,,<empty>,,,,1,,<empty>
87140,BLOCK,-1,,<empty>,,,,1,,<empty>
87144,BLOCK,-1,,"{
    return agent_;
  }",28,,82,1,,void
87152,BLOCK,-1,,<empty>,,,,3,,<empty>
87157,BLOCK,-1,,<empty>,,,,2,,<empty>
87162,BLOCK,-1,,<empty>,,,,2,,<empty>
87167,BLOCK,-1,,<empty>,,,,2,,<empty>
87179,BLOCK,-1,,<empty>,,,,1,,<empty>
87199,BLOCK,-1,,<empty>,1,,1,1,,ANY
87215,BLOCK,-1,,"{
  builder.put('""');
  if (!string.empty()) {
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }
  builder.put('""');
}",63,,16,3,,void
87227,BLOCK,-1,,"{
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }",24,,18,2,,void
87269,BLOCK,-1,,"{
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }",28,,27,2,,void
87292,BLOCK,-1,,"{
  if (string.empty())
    return nullptr;
  size_t expected_utf16_length =
      simdutf::utf16_length_from_utf8(string.data(), string.length());
  MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
  // simdutf::convert_utf8_to_utf16 returns zero in case of error.
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      string.data(), string.length(), buffer.out());
  // We have that utf16_length == expected_utf16_length if and only
  // if the input was a valid UTF-8 string.
  if (utf16_length == 0) return nullptr;  // We had an invalid UTF-8 input.
  CHECK_EQ(expected_utf16_length, utf16_length);
  return parseJSONCharacters(reinterpret_cast<const uint16_t*>(buffer.out()),
                             utf16_length);
}",65,,37,2,,void
87298,BLOCK,-1,,<empty>,5,,39,2,,void
87342,BLOCK,-1,,<empty>,26,,48,2,,void
87361,BLOCK,-1,,"{
  if (string.length() == 0)
    return nullptr;
  if (string.is8Bit())
    return parseJSONCharacters(string.characters8(), string.length());
  return parseJSONCharacters(string.characters16(), string.length());
}",67,,54,2,,void
87369,BLOCK,-1,,<empty>,5,,56,2,,void
87377,BLOCK,-1,,<empty>,5,,58,2,,void
87402,BLOCK,-1,,"{
  if (view.length() == 0)
    return """";
  if (view.is8Bit()) {
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }
  const char16_t* source =
      reinterpret_cast<const char16_t*>(view.characters16());
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(source, view.length());
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(source, view.length(), buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",56,,62,2,,void
87410,BLOCK,-1,,<empty>,5,,64,2,,void
87418,BLOCK,-1,,"{
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }",22,,65,2,,void
87493,BLOCK,-1,,"{
  std::ostringstream stream;
  stream.imbue(std::locale::classic());  // Ignore current locale
  stream << d;
  return stream.str();
}",29,,85,2,,void
87519,BLOCK,-1,,"{
  std::istringstream stream(std::string(buffer, length));
  stream.imbue(std::locale::classic());  // Ignore current locale
  double d;
  stream >> d;
  *ok = !stream.fail();
  return d;
}",62,,92,4,,void
87557,BLOCK,-1,,"{
  if (binary) {
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }
  return parseJSON(message);
}",50,,102,3,,void
87560,BLOCK,-1,,"{
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }",15,,103,2,,void
87583,BLOCK,-1,,"{
  return message;
}",47,,111,2,,void
87590,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(message.data()),
                     message.size());
}",63,,115,2,,void
87611,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(data), length);
}",53,,120,3,,void
87626,BLOCK,-1,,"{
  auto casted_data = reinterpret_cast<const char16_t*>(data);
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(casted_data, length);
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // simdutf::convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(casted_data, length, buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",55,,124,3,,void
87677,BLOCK,-1,,"{
  return reinterpret_cast<const uint8_t*>(s.data());
}",57,,140,2,,void
87689,BLOCK,-1,,"{
  // The utf32_length_from_utf8 function calls count_utf8.
  // The count_utf8 function counts the number of code points
  // (characters) in the string, assuming that the string is valid Unicode.
  // TODO(@anonrig): Test to make sure CharacterCount returns correctly.
  return simdutf::utf32_length_from_utf8(s.data(), s.length());
}",49,,144,2,,void
87719,BLOCK,-1,,<empty>,1,,1,1,,ANY
87731,BLOCK,-1,,"{
  builder.put(c);
}",59,,25,3,,void
87743,BLOCK,-1,,"{
  builder.write(value, length);
}",42,,31,4,,void
87755,BLOCK,-1,,"{
  builderAppend(builder, value, std::strlen(value));
}",70,,36,3,,void
87769,BLOCK,-1,,"{
  builder << string;
}",73,,41,3,,void
87778,BLOCK,-1,,"{
  // ostringstream does not have a counterpart
}",60,,46,3,,void
87785,BLOCK,-1,,"{
  return string.substr(start, count);
}",75,,49,4,,void
87797,BLOCK,-1,,"{
  return std::to_string(n);
}",34,,52,2,,void
87808,BLOCK,-1,,"{
  return builder.str();
}",61,,55,2,,void
87819,BLOCK,-1,,"{
  return string.find(substring);
}",65,,58,3,,void
87830,BLOCK,-1,,<empty>,,,,2,,<empty>
87837,BLOCK,-1,,<empty>,,,,4,,<empty>
87842,BLOCK,-1,,<empty>,,,,2,,<empty>
87848,BLOCK,-1,,<empty>,,,,3,,<empty>
87853,BLOCK,-1,,<empty>,,,,2,,<empty>
87859,BLOCK,-1,,<empty>,,,,3,,<empty>
87864,BLOCK,-1,,<empty>,,,,2,,<empty>
87869,BLOCK,-1,,<empty>,,,,2,,<empty>
87875,BLOCK,-1,,<empty>,,,,3,,<empty>
87881,BLOCK,-1,,<empty>,,,,3,,<empty>
87886,BLOCK,-1,,<empty>,,,,2,,<empty>
87891,BLOCK,-1,,<empty>,,,,2,,<empty>
87896,BLOCK,-1,,"{
  return nullptr;
}",60,,81,2,,void
87903,BLOCK,-1,,"{
  return nullptr;
}",66,,84,2,,void
87911,BLOCK,-1,,{ UNREACHABLE(); },31,,97,1,,void
87916,BLOCK,-1,,{ UNREACHABLE(); },23,,98,1,,void
87921,BLOCK,-1,,{ UNREACHABLE(); },27,,99,1,,void
87928,BLOCK,-1,,"{
    UNREACHABLE();
  }",74,,100,3,,void
87935,BLOCK,-1,,{ UNREACHABLE(); },60,,103,3,,void
87949,BLOCK,-1,,<empty>,1,,1,1,,ANY
87954,BLOCK,-1,,<empty>,48,,11,1,,void
87959,BLOCK,-1,,"{
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",53,,13,2,,void
87986,BLOCK,-1,,"{
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",77,,18,2,,void
87998,BLOCK,-1,,"{
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",49,,23,1,,void
88001,BLOCK,-1,,"{
    frontend_->waitingForDisconnect();
    return true;
  }",44,,24,2,,void
88020,BLOCK,-1,,<empty>,1,,1,1,,ANY
88027,BLOCK,-1,,<empty>,,,,1,,<empty>
88032,BLOCK,-1,,<empty>,,,,2,,<empty>
88037,BLOCK,-1,,<empty>,,,,2,,<empty>
88041,BLOCK,-1,,<empty>,,,,1,,<empty>
88064,BLOCK,-1,,<empty>,1,,1,1,,ANY
88072,BLOCK,-1,,<empty>,29,,21,2,,void
88076,BLOCK,-1,,{ return frontend_.lock().get(); },32,,25,1,,void
88092,BLOCK,-1,,"{
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",31,,35,3,,void
88106,BLOCK,-1,,"{
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",51,,39,2,,void
88124,BLOCK,-1,,<empty>,31,,51,2,,void
88129,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,53,2,,void
88142,BLOCK,-1,,<empty>,50,,64,3,,void
88147,BLOCK,-1,,"{
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",51,,66,2,,void
88162,BLOCK,-1,,<empty>,38,,70,2,,void
88175,BLOCK,-1,,"{
      frontend->sendRawJSONNotification(message_);
    }",30,,72,2,,void
88189,BLOCK,-1,,<empty>,76,,86,3,,void
88194,BLOCK,-1,,"{
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",65,,89,2,,void
88198,BLOCK,-1,,<empty>,7,,91,2,,void
88218,BLOCK,-1,,"{
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",29,,95,2,,void
88222,BLOCK,-1,,<empty>,7,,97,2,,void
88276,BLOCK,-1,,<empty>,44,,119,3,,void
88280,BLOCK,-1,,"{
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",31,,121,1,,void
88300,BLOCK,-1,,"{
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",53,,127,2,,void
88347,BLOCK,-1,,"{
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tr...",70,,137,2,,void
88354,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }",31,,138,2,,void
88367,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }",36,,142,2,,void
88399,BLOCK,-1,,<empty>,3,,150,1,,void
88426,BLOCK,-1,,<empty>,5,,154,2,,void
88441,BLOCK,-1,,"{
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tracing::Agent::kIgnoreDefaultCategories);
  }",26,,157,2,,void
88475,BLOCK,-1,,"{
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",39,,167,1,,void
88493,BLOCK,-1,,"{
  *categories = Array<String>::create();
  protocol::Array<String>* categories_list = categories->get();
  // In alphabetical order
  categories_list->addItem(""node"");
  categories_list->addItem(""node.async_hooks"");
  categories_list->addItem(""node.bootstrap"");
  categories_list->addItem(""node.console"");
  categories_list->addItem(""node.dns.native"");
  categories_list->addItem(""node.environment"");
  categories_list->addItem(""node.fs.async"");
  categories_list->addItem(""node.fs.sync"");
  categories_list->addItem(""node.fs_dir.async"");
  categories_list->addItem(""node.fs_dir.sync"");
  categories_list->addItem(""node.http"");
  categories_list->addItem(""node.net.native"");
  categories_list->addItem(""node.perf"");
  categories_list->addItem(""node.perf.timerify"");
  categories_list->addItem(""node.perf.usertiming"");
  categories_list->addItem(""node.promises.rejections"");
  categories_list->addItem(""node.threadpoolwork.async"");
  categories_list->addItem(""node.threadpoolwork.sync"");
  catego...",59,,174,2,,void
88635,BLOCK,-1,,<empty>,1,,1,1,,ANY
88645,BLOCK,-1,,<empty>,,,,3,,<empty>
88649,BLOCK,-1,,<empty>,,,,1,,<empty>
88654,BLOCK,-1,,<empty>,,,,2,,<empty>
88659,BLOCK,-1,,<empty>,,,,2,,<empty>
88663,BLOCK,-1,,<empty>,,,,1,,<empty>
88668,BLOCK,-1,,<empty>,,,,2,,<empty>
88677,BLOCK,-1,,<empty>,,,,1,,<empty>
88695,BLOCK,-1,,<empty>,1,,1,1,,ANY
88703,BLOCK,-1,,<empty>,62,,16,3,,void
88711,BLOCK,-1,,<empty>,,,,5,,<empty>
88717,BLOCK,-1,,<empty>,,,,3,,<empty>
88723,BLOCK,-1,,<empty>,,,,3,,<empty>
88728,BLOCK,-1,,<empty>,,,,2,,<empty>
88736,BLOCK,-1,,<empty>,,,,1,,<empty>
88746,BLOCK,-1,,<empty>,61,,36,2,,void
88754,BLOCK,-1,,"{
    workers_->WorkerCreated(title, url, waiting, target);
  }",73,,41,5,,void
88770,BLOCK,-1,,<empty>,63,,53,3,,void
88774,BLOCK,-1,,"{
    workers_->Detached(id_);
  }",46,,55,1,,void
88784,BLOCK,-1,,"{
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",76,,59,2,,void
88809,BLOCK,-1,,"{
  return NodeWorker::WorkerInfo::create()
      .setWorkerId(id)
      .setTitle(title)
      .setUrl(url)
      .setType(""worker"").build();
}",76,,71,4,,void
88840,BLOCK,-1,,<empty>,46,,81,2,,void
88845,BLOCK,-1,,"{
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",52,,84,2,,void
88893,BLOCK,-1,,"{
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",76,,94,3,,void
88909,BLOCK,-1,,"{
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",67,,99,2,,void
88920,BLOCK,-1,,"{
    return DispatchResponse::OK();
  }",17,,101,2,,void
88929,BLOCK,-1,,"{
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }",23,,104,2,,void
88959,BLOCK,-1,,"{
  event_handle_.reset();
  return DispatchResponse::OK();
}",41,,113,1,,void
88973,BLOCK,-1,,"{
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",63,,118,2,,void
88991,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (!frontend)
    return;
  std::string id = std::to_string(++next_target_id_);
  auto delegate = thread_->MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate>(
          new ParentInspectorSessionDelegate(id, shared_from_this())));
  sessions_[id] = target->Connect(std::move(delegate), true);
  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);
}",75,,126,5,,void
89002,BLOCK,-1,,<empty>,5,,129,2,,void
89059,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (frontend)
    frontend->receivedMessageFromWorker(id, message);
}",75,,138,3,,void
89069,BLOCK,-1,,<empty>,5,,141,2,,void
89081,BLOCK,-1,,"{
  auto it = sessions_.find(id);
  if (it != sessions_.end())
    it->second->Dispatch(Utf8ToStringView(message)->string());
}",78,,144,3,,void
89097,BLOCK,-1,,<empty>,5,,147,2,,void
89113,BLOCK,-1,,"{
  if (sessions_.erase(id) == 0)
    return;
  auto frontend = frontend_.lock();
  if (frontend) {
    frontend->detachedFromWorker(id);
  }
}",51,,150,2,,void
89122,BLOCK,-1,,<empty>,5,,152,2,,void
89133,BLOCK,-1,,"{
    frontend->detachedFromWorker(id);
  }",17,,154,2,,void
89149,BLOCK,-1,,<empty>,1,,1,1,,ANY
89159,BLOCK,-1,,<empty>,,,,2,,<empty>
89163,BLOCK,-1,,<empty>,,,,1,,<empty>
89168,BLOCK,-1,,<empty>,,,,2,,<empty>
89174,BLOCK,-1,,<empty>,,,,3,,<empty>
89179,BLOCK,-1,,<empty>,,,,2,,<empty>
89183,BLOCK,-1,,<empty>,,,,1,,<empty>
89188,BLOCK,-1,,<empty>,,,,2,,<empty>
89207,BLOCK,-1,,<empty>,1,,1,1,,ANY
89218,BLOCK,-1,,<empty>,27,,21,6,,void
89223,BLOCK,-1,,"{
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",51,,22,2,,void
89246,BLOCK,-1,,"{
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }",72,,28,3,,void
89275,BLOCK,-1,,"{
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",51,,40,4,,void
89280,BLOCK,-1,,<empty>,5,,42,2,,void
89300,BLOCK,-1,,<empty>,78,,47,2,,void
89305,BLOCK,-1,,"{
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",51,,49,2,,void
89326,BLOCK,-1,,<empty>,19,,68,6,,void
89330,BLOCK,-1,,"{
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",49,,70,1,,void
89349,BLOCK,-1,,"{
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",68,,76,3,,void
89373,BLOCK,-1,,"{
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",28,,84,3,,void
89389,BLOCK,-1,,"{
  children_.erase(session_id);
}",57,,88,2,,void
89401,BLOCK,-1,,"{
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",49,,94,4,,void
89409,BLOCK,-1,,<empty>,5,,96,2,,void
89420,BLOCK,-1,,"{
    Report(delegate.second, info, waiting);
  }",43,,98,3,,void
89433,BLOCK,-1,,"{
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",74,,104,4,,void
89460,BLOCK,-1,,"{
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",50,,110,2,,void
89475,BLOCK,-1,,"{
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",54,,116,2,,void
89499,BLOCK,-1,,"{
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }",40,,120,3,,void
89522,BLOCK,-1,,"{
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",66,,127,3,,void
89525,BLOCK,-1,,<empty>,5,,129,2,,void
89532,BLOCK,-1,,<empty>,5,,131,1,,void
89542,BLOCK,-1,,"{
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",67,,134,2,,void
89552,BLOCK,-1,,"{
  manager_->RemoveAttachDelegate(id_);
}",55,,138,1,,void
89572,BLOCK,-1,,<empty>,1,,1,1,,ANY
89585,BLOCK,-1,,<empty>,,,,5,,<empty>
89589,BLOCK,-1,,<empty>,,,,1,,<empty>
89596,BLOCK,-1,,<empty>,66,,33,3,,void
89601,BLOCK,-1,,<empty>,,,,2,,<empty>
89605,BLOCK,-1,,<empty>,,,,1,,<empty>
89615,BLOCK,-1,,<empty>,45,,48,4,,void
89628,BLOCK,-1,,<empty>,,,,6,,<empty>
89632,BLOCK,-1,,<empty>,,,,1,,<empty>
89639,BLOCK,-1,,"{
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",76,,63,4,,void
89659,BLOCK,-1,,<empty>,,,,3,,<empty>
89663,BLOCK,-1,,"{
    return wait_;
  }",25,,69,1,,void
89669,BLOCK,-1,,{ return url_; },34,,72,1,,void
89677,BLOCK,-1,,<empty>,,,,3,,<empty>
89688,BLOCK,-1,,<empty>,44,,88,2,,void
89695,BLOCK,-1,,<empty>,,,,4,,<empty>
89702,BLOCK,-1,,<empty>,,,,4,,<empty>
89707,BLOCK,-1,,<empty>,,,,2,,<empty>
89712,BLOCK,-1,,<empty>,,,,2,,<empty>
89718,BLOCK,-1,,<empty>,,,,3,,<empty>
89723,BLOCK,-1,,<empty>,,,,2,,<empty>
89727,BLOCK,-1,,"{
    return thread_;
  }",50,,98,1,,void
89738,BLOCK,-1,,<empty>,,,,1,,<empty>
89746,BLOCK,-1,,{ callback(data); },53,,552,1,,void
89756,BLOCK,-1,,"{
        CHECK(start_io_thread_async_initialized.exchange(false));
      }",64,,722,2,,void
89769,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }",48,,713,2,,void
89776,BLOCK,3,,"{
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }",7,,716,3,,void
89797,BLOCK,-1,,"{
    Agent* agent = static_cast<Environment*>(env)->inspector_agent();
    if (agent->IsActive()) {
      agent->WaitForDisconnect();
    }
  }",37,,728,2,,void
89812,BLOCK,-1,,"{
      agent->WaitForDisconnect();
    }",28,,730,2,,void
89822,BLOCK,-1,,"{
    StartIoThread();
  }",54,,955,2,,void
89885,BLOCK,-1,,<empty>,1,,1,1,,ANY
89899,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,67,3,,void
89920,BLOCK,-1,,"{
  static_cast<Agent*>(handle->data)->StartIoThread();
}",53,,73,2,,void
89937,BLOCK,-1,,"{
  std::ostringstream result;
  result << ""Worker["" << env->thread_id() << ""]"";
  return result.str();
}",52,,206,2,,void
89964,BLOCK,-1,,"{
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }
    runtime_agent_ = std::make_unique<protocol::RuntimeAgent>();
    runtime_agent_->Wire(node_dispatcher_.get());
  }",35,,222,7,,void
90014,BLOCK,-1,,"{
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }",25,,231,2,,void
90051,BLOCK,-1,,"{
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",27,,239,1,,void
90062,BLOCK,-1,,"{
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }",24,,242,2,,void
90083,BLOCK,-1,,"{
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",59,,250,2,,void
90153,BLOCK,-1,,"{
      session_->dispatchProtocolMessage(message);
    }",50,,262,2,,void
90160,BLOCK,-1,,"{
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }",12,,264,1,,void
90177,BLOCK,-1,,"{
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",64,,270,2,,void
90198,BLOCK,-1,,"{
    return prevent_shutdown_;
  }",26,,275,1,,void
90204,BLOCK,-1,,"{
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",37,,279,1,,void
90216,BLOCK,-1,,"{
    return retaining_context_;
  }",27,,284,1,,void
90224,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,291,3,,void
90234,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,296,2,,void
90243,BLOCK,-1,,{ },46,,300,1,,void
90248,BLOCK,-1,,"{
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",57,,302,2,,void
90259,BLOCK,-1,,"{
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }",47,,304,2,,void
90288,BLOCK,-1,,"{
    sendMessageToFrontend(Utf8ToStringView(message)->string());
  }",58,,313,2,,void
90301,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",77,,320,3,,void
90311,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",55,,324,2,,void
90323,BLOCK,-1,,"{
    DCHECK(false);
  }",57,,330,4,,void
90340,BLOCK,-1,,<empty>,50,,348,3,,void
90344,BLOCK,-1,,<empty>,,,,1,,<empty>
90349,BLOCK,-1,,<empty>,,,,2,,<empty>
90356,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();

  // Send message to enable debug in cluster workers
  Local<Object> message = Object::New(isolate);
  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""cmd""),
               FIXED_ONE_BYTE_STRING(isolate, ""NODE_DEBUG_ENABLED"")).Check();
  ProcessEmit(env, ""internalMessage"", message);
}",57,,357,2,,void
90410,BLOCK,-1,,"{
  return !path.empty() && path[0] == '/';
}",42,,382,2,,void
90427,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  const char* msg = ""This Environment was initialized without a V8::Inspector"";
  Local<Value> exception =
    v8::String::NewFromUtf8(env->isolate(), msg).ToLocalChecked();

  env->isolate()->ThrowException(exception);
}",57,,387,2,,void
90471,BLOCK,-1,,"{
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",38,,402,3,,void
90509,BLOCK,-1,,"{
    waiting_for_resume_ = true;
    runMessageLoop();
  }",61,,412,2,,void
90517,BLOCK,-1,,"{
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",36,,417,1,,void
90525,BLOCK,-1,,"{
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",26,,422,1,,void
90534,BLOCK,-1,,"{
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",58,,427,2,,void
90537,BLOCK,-1,,"{
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }",43,,428,2,,void
90540,BLOCK,-1,,<empty>,9,,433,1,,void
90548,BLOCK,-1,,"{
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }",47,,433,2,,void
90553,BLOCK,-1,,"{
        agent->DisableAsyncHook();
      }",23,,434,2,,void
90559,BLOCK,-1,,"{
        agent->EnableAsyncHook();
      }",14,,436,1,,void
90569,BLOCK,-1,,"{
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",72,,442,3,,void
90605,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    }",26,,451,2,,void
90611,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }",12,,453,1,,void
90633,BLOCK,-1,,"{
    client_->contextDestroyed(context);
  }",49,,461,2,,void
90642,BLOCK,-1,,"{
    waiting_for_resume_ = false;
  }",42,,465,1,,void
90650,BLOCK,-1,,"{
    waiting_for_frontend_ = false;
  }",63,,469,2,,void
90659,BLOCK,-1,,"{
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",46,,474,3,,void
90693,BLOCK,-1,,"{
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",43,,485,2,,void
90709,BLOCK,-1,,<empty>,7,,488,2,,void
90727,BLOCK,-1,,"{
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }",28,,491,2,,void
90731,BLOCK,-1,,"{
        if (id_channel.second->retainingContext())
          return;
      }",48,,492,3,,void
90739,BLOCK,-1,,<empty>,11,,494,2,,void
90751,BLOCK,-1,,<empty>,7,,499,2,,void
90760,BLOCK,-1,,"{
    channels_[session_id]->dispatchProtocolMessage(message);
  }",79,,502,3,,void
90772,BLOCK,-1,,"{
    return env_->context();
  }",75,,506,2,,void
90783,BLOCK,-1,,"{
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",71,,511,3,,void
90800,BLOCK,-1,,"{
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }",31,,513,2,,void
90821,BLOCK,-1,,"{
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",76,,520,3,,void
90886,BLOCK,-1,,"{
      script_id = 0;
    }",72,,529,2,,void
90953,BLOCK,-1,,"{
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",49,,549,4,,void
91001,BLOCK,-1,,"{
    timers_.erase(data);
  }",41,,558,2,,void
91013,BLOCK,-1,,"{
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",43,,564,4,,void
91025,BLOCK,-1,,"{
    client_->asyncTaskCanceled(task);
  }",38,,568,2,,void
91035,BLOCK,-1,,"{
    client_->asyncTaskStarted(task);
  }",37,,572,2,,void
91045,BLOCK,-1,,"{
    client_->asyncTaskFinished(task);
  }",38,,576,2,,void
91054,BLOCK,-1,,"{
    client_->allAsyncTasksCanceled();
  }",32,,580,1,,void
91063,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",64,,584,2,,void
91067,BLOCK,-1,,"{
      id_channel.second->schedulePauseOnNextStatement(reason);
    }",46,,585,3,,void
91078,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",31,,590,1,,void
91082,BLOCK,-1,,"{
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }",46,,591,3,,void
91090,BLOCK,-1,,<empty>,9,,594,2,,void
91098,BLOCK,-1,,"{
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",37,,599,1,,void
91106,BLOCK,-1,,"{
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }",46,,601,3,,void
91114,BLOCK,-1,,<empty>,9,,603,2,,void
91123,BLOCK,-1,,"{
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",55,,608,1,,void
91127,BLOCK,-1,,"{
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }",22,,609,2,,void
91148,BLOCK,-1,,"{
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",53,,616,1,,void
91152,BLOCK,-1,,"{
      return nullptr;
    }",20,,617,2,,void
91159,BLOCK,-1,,"{
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }",37,,620,2,,void
91174,BLOCK,-1,,"{
    return !channels_.empty();
  }",19,,627,1,,void
91184,BLOCK,-1,,"{
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",31,,632,1,,void
91187,BLOCK,-1,,<empty>,7,,634,2,,void
91194,BLOCK,-1,,"{
      return hasConnectedSessions();
    }",66,,635,2,,void
91202,BLOCK,-1,,"{
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",25,,641,1,,void
91205,BLOCK,-1,,<empty>,7,,643,2,,void
91212,BLOCK,-1,,"{
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }",36,,647,2,,void
91215,BLOCK,-1,,<empty>,23,,648,2,,void
91230,BLOCK,-1,,"{
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",35,,654,1,,void
91246,BLOCK,-1,,"{
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",54,,659,2,,void
91261,BLOCK,-1,,<empty>,7,,663,2,,void
91292,BLOCK,-1,,<empty>,,,,1,,<empty>
91312,BLOCK,-1,,<empty>,46,,688,2,,void
91316,BLOCK,-1,,<empty>,17,,690,1,,void
91324,BLOCK,-1,,"{
  path_ = path;
  debug_options_ = options;
  CHECK_NOT_NULL(host_port);
  host_port_ = host_port;

  client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);
  if (parent_env_->owns_inspector()) {
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will ...",33,,695,5,,void
91353,BLOCK,-1,,"{
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }, parent_env_);
  }",38,,702,2,,void
91404,BLOCK,-1,,"{
    wait_for_connect = parent_handle_->WaitForConnect();
    parent_handle_->WorkerStarted(client_->getThreadHandle(), wait_for_connect);
  }",23,,736,2,,void
91421,BLOCK,-1,,<empty>,10,,739,1,,void
91435,BLOCK,-1,,"{
    return false;
  }",32,,740,2,,void
91440,BLOCK,-1,,"{
    CHECK(!parent_env_->has_serialized_options());
    debug_options_.EnableBreakFirstLine();
    parent_env_->options()->get_debug_options()->EnableBreakFirstLine();
    client_->waitForFrontend();
  }",25,,746,2,,void
91470,BLOCK,-1,,"{
  if (io_ != nullptr)
    return true;

  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""StartIoThread"",
                                    false);
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }

  CHECK_NOT_NULL(client_);

  io_ = InspectorIo::Start(client_->getThreadHandle(),
                           path_,
                           host_port_,
                           debug_options_.inspect_publish_uid);
  if (io_ == nullptr) {
    return false;
  }
  NotifyClusterWorkersDebugEnabled(parent_env_);
  return true;
}",29,,755,1,,void
91475,BLOCK,-1,,<empty>,5,,757,2,,void
91496,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }",60,,763,2,,void
91520,BLOCK,-1,,"{
    return false;
  }",23,,774,2,,void
91529,BLOCK,-1,,"{
  io_.reset();
}",20,,781,1,,void
91539,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""Connect"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(client_);

  int session_id = client_->connectFrontend(std::move(delegate),
                                            prevent_shutdown);
  return std::unique_ptr<InspectorSession>(
      new SameThreadInspectorSession(session_id, client_));
}",28,,787,3,,void
91559,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,792,2,,void
91594,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""ConnectToMainThread"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(parent_handle_);
  CHECK_NOT_NULL(client_);
  auto thread_safe_delegate =
      client_->getThreadHandle()->MakeDelegateThreadSafe(std::move(delegate));
  return parent_handle_->Connect(std::move(thread_safe_delegate),
                                 prevent_shutdown);
}",28,,807,3,,void
91614,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,812,2,,void
91650,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""WaitForDisconnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  bool is_worker = parent_handle_ != nullptr;
  parent_handle_.reset();
  if (client_->hasConnectedSessions() && !is_worker) {
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }
  if (!client_->notifyWaitingForDisconnect()) {
    client_->contextDestroyed(parent_env_->context());
  } else if (is_worker) {
    client_->waitForSessionsDisconnect();
  }
  if (io_ != nullptr) {
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }
}",33,,825,1,,void
91668,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,829,2,,void
91690,BLOCK,-1,,"{
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }",54,,837,2,,void
91701,BLOCK,-1,,"{
    client_->contextDestroyed(parent_env_->context());
  }",47,,841,2,,void
91711,BLOCK,-1,,<empty>,10,,843,1,,void
91714,BLOCK,-1,,"{
    client_->waitForSessionsDisconnect();
  }",25,,843,2,,void
91723,BLOCK,-1,,"{
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }",23,,846,2,,void
91737,BLOCK,-1,,"{
  if (!IsListening())
    return;
  client_->ReportUncaughtException(error, message);
  WaitForDisconnect();
}",61,,853,3,,void
91741,BLOCK,-1,,<empty>,5,,855,2,,void
91754,BLOCK,-1,,"{
  client_->schedulePauseOnNextStatement(reason);
}",71,,860,2,,void
91766,BLOCK,-1,,"{
  parent_env_->set_inspector_enable_async_hooks(enable_function);
  parent_env_->set_inspector_disable_async_hooks(disable_function);
  if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }
}",65,,866,4,,void
91779,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  }",35,,869,2,,void
91788,BLOCK,-1,,<empty>,10,,873,1,,void
91791,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }",43,,873,2,,void
91802,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> enable = parent_env_->inspector_enable_async_hooks();
  if (!enable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), enable);
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  } else {
    pending_enable_async_hook_ = true;
  }
}",31,,880,1,,void
91825,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), enable);
  }",26,,883,2,,void
91833,BLOCK,-1,,<empty>,10,,885,1,,void
91836,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  }",43,,885,2,,void
91844,BLOCK,-1,,"{
    pending_enable_async_hook_ = true;
  }",10,,888,1,,void
91851,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> disable = parent_env_->inspector_enable_async_hooks();
  if (!disable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), disable);
  } else if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  } else {
    pending_disable_async_hook_ = true;
  }
}",32,,893,1,,void
91874,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), disable);
  }",27,,896,2,,void
91882,BLOCK,-1,,<empty>,10,,898,1,,void
91885,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  }",42,,898,2,,void
91893,BLOCK,-1,,"{
    pending_disable_async_hook_ = true;
  }",10,,901,1,,void
91902,BLOCK,-1,,"{
  // Guard against running this during cleanup -- no async events will be
  // emitted anyway at that point anymore, and calling into JS is not possible.
  // This should probably not be something we're attempting in the first place,
  // Refs: https://github.com/nodejs/node/pull/34362#discussion_r456006039
  if (!parent_env_->can_call_into_js()) return;
  CHECK(parent_env_->has_run_bootstrapping_code());
  HandleScope handle_scope(isolate);
  CHECK(!fn.IsEmpty());
  auto context = parent_env_->context();
  v8::TryCatch try_catch(isolate);
  USE(fn->Call(context, Undefined(isolate), 0, nullptr));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }
}",67,,906,3,,void
91909,BLOCK,-1,,<empty>,41,,911,2,,void
91956,BLOCK,-1,,"{
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }",60,,918,2,,void
91970,BLOCK,-1,,"{
  client_->AsyncTaskScheduled(task_name, task, recurring);
}",48,,926,4,,void
91982,BLOCK,-1,,"{
  client_->AsyncTaskCanceled(task);
}",43,,930,2,,void
91992,BLOCK,-1,,"{
  client_->AsyncTaskStarted(task);
}",42,,934,2,,void
92002,BLOCK,-1,,"{
  client_->AsyncTaskFinished(task);
}",43,,938,2,,void
92011,BLOCK,-1,,"{
  client_->AllAsyncTasksCanceled();
}",37,,942,1,,void
92019,BLOCK,-1,,"{
  // We need to attempt to interrupt V8 flow (in case Node is running
  // continuous JS code) and to wake up libuv thread (in case Node is waiting
  // for IO events)
  if (!options().allow_attaching_debugger) {
    return;
  }
  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
  parent_env_->RequestInterrupt([this](Environment*) {
    StartIoThread();
  });

  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
}",36,,946,1,,void
92025,BLOCK,-1,,"{
    return;
  }",44,,950,2,,void
92044,BLOCK,-1,,"{
  if (client_ == nullptr)  // This happens for a main context
    return;
  client_->contextCreated(context, info);
}",77,,963,3,,void
92049,BLOCK,-1,,<empty>,5,,965,2,,void
92060,BLOCK,-1,,"{
  if (client_ == nullptr)
    return false;
  return io_ != nullptr || client_->IsActive();
}",24,,969,1,,void
92065,BLOCK,-1,,<empty>,5,,971,2,,void
92081,BLOCK,-1,,"{
  parent_handle_ = std::move(parent_handle);
}",59,,976,2,,void
92095,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetParentHandle"",
                                    std::unique_ptr<ParentInspectorHandle>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }

  CHECK_NOT_NULL(client_);
  if (!parent_handle_) {
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  } else {
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }
}",74,,981,4,,void
92115,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }",60,,986,2,,void
92124,BLOCK,-1,,"{
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  }",24,,992,2,,void
92137,BLOCK,-1,,"{
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }",10,,994,1,,void
92149,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      parent_env_, permission::PermissionScope::kInspector, ""WaitForConnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  client_->waitForFrontend();
}",30,,999,1,,void
92167,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,1002,2,,void
92178,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetWorkerManager"",
                                    std::unique_ptr<WorkerManager>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }

  CHECK_NOT_NULL(client_);
  return client_->getWorkerManager();
}",58,,1011,1,,void
92198,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }",60,,1016,2,,void
92212,BLOCK,-1,,"{
  if (io_ == nullptr)
    return """";
  return io_->GetWsUrl();
}",37,,1025,1,,void
92217,BLOCK,-1,,<empty>,5,,1027,2,,void
92228,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->disconnectFrontend(session_id_);
}",59,,1031,1,,void
92238,BLOCK,-1,,<empty>,5,,1034,2,,void
92248,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->dispatchMessageFromFrontend(session_id_, message);
}",46,,1038,2,,void
92258,BLOCK,-1,,<empty>,5,,1041,2,,void
92279,BLOCK,-1,,<empty>,1,,1,1,,ANY
92283,BLOCK,-1,,"{
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",66,,101,2,,void
92306,BLOCK,-1,,"{
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",36,,376,2,,void
92365,BLOCK,-1,,<empty>,1,,1,1,,ANY
92376,BLOCK,-1,,"{
  std::string script_path;

  if (!script_name.empty()) {
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }

  return script_path;
}",73,,29,3,,void
92384,BLOCK,-1,,"{
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }",29,,32,2,,void
92403,BLOCK,-1,,"{
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }",72,,35,2,,void
92427,BLOCK,-1,,"{
  uint16_t buffer[8];
  CHECK(crypto::CSPRNG(buffer, sizeof(buffer)).is_ok());

  char uuid[256];
  snprintf(uuid, sizeof(uuid), ""%04x%04x-%04x-%04x-%04x-%04x%04x%04x"",
           buffer[0],  // time_low
           buffer[1],  // time_mid
           buffer[2],  // time_low
           (buffer[3] & 0x0fff) | 0x4000,  // time_hi_and_version
           (buffer[4] & 0x3fff) | 0x8000,  // clk_seq_hi clk_seq_low
           buffer[5],  // node
           buffer[6],
           buffer[7]);
  return uuid;
}",26,,47,1,,void
92487,BLOCK,-1,,<empty>,50,,71,4,,void
92492,BLOCK,-1,,"{
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",54,,73,2,,void
92495,BLOCK,-1,,"{
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }",22,,74,2,,void
92541,BLOCK,-1,,"{
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",77,,100,2,,void
92557,BLOCK,-1,,<empty>,,,,2,,<empty>
92564,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",52,,113,4,,void
92588,BLOCK,-1,,"{
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }",17,,117,2,,void
92602,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",15,,123,1,,void
92611,BLOCK,-1,,"{
      incoming_message_cond_.Wait(scoped_lock);
    }",28,,125,2,,void
92621,BLOCK,-1,,"{
    server_ = server;
  }",49,,130,2,,void
92628,BLOCK,-1,,"{
    return handle_;
  }",42,,134,1,,void
92634,BLOCK,-1,,<empty>,,,,1,,<empty>
92638,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",30,,141,1,,void
92653,BLOCK,-1,,"{
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",21,,148,1,,void
92658,BLOCK,-1,,<empty>,7,,150,2,,void
92663,BLOCK,-1,,"{
      request.Dispatch(server_);
    }",47,,151,3,,void
92678,BLOCK,-1,,<empty>,,,,1,,<empty>
92687,BLOCK,-1,,<empty>,63,,167,2,,void
92691,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",16,,169,1,,void
92704,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",52,,176,4,,void
92712,BLOCK,-1,,<empty>,7,,179,2,,void
92727,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",18,,182,1,,void
92743,BLOCK,-1,,{ },63,,195,3,,void
92748,BLOCK,-1,,"{
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",80,,196,2,,void
92773,BLOCK,-1,,<empty>,,,,6,,<empty>
92777,BLOCK,-1,,<empty>,,,,1,,<empty>
92783,BLOCK,-1,,<empty>,,,,3,,<empty>
92789,BLOCK,-1,,<empty>,,,,3,,<empty>
92794,BLOCK,-1,,<empty>,,,,2,,<empty>
92798,BLOCK,-1,,<empty>,,,,1,,<empty>
92803,BLOCK,-1,,<empty>,,,,2,,<empty>
92808,BLOCK,-1,,<empty>,,,,2,,<empty>
92813,BLOCK,-1,,"{
    request_queue_->SetServer(server);
  }",61,,224,2,,void
92832,BLOCK,-1,,"{
  auto io = std::unique_ptr<InspectorIo>(
      new InspectorIo(main_thread,
                      path,
                      host_port,
                      inspect_publish_uid));
  if (io->request_queue_->Expired()) {  // Thread is not running
    return nullptr;
  }
  return io;
}",51,,242,5,,void
92855,BLOCK,-1,,"{  // Thread is not running
    return nullptr;
  }",38,,248,2,,void
92867,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(thread_start_lock_);
  CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);
  thread_start_condition_.Wait(scoped_lock);
}",25,,263,5,,void
92888,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",29,,269,1,,void
92910,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",49,,275,1,,void
92924,BLOCK,-1,,"{
  static_cast<InspectorIo*>(io)->ThreadMain();
}",40,,280,2,,void
92934,BLOCK,-1,,"{
  uv_loop_t loop;
  loop.data = nullptr;
  int err = uv_loop_init(&loop);
  CHECK_EQ(err, 0);
  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),
                                          RequestQueueData::CloseAndFree);
  std::string script_path = ScriptPath(&loop, script_name_);
  std::unique_ptr<InspectorIoDelegate> delegate(
      new InspectorIoDelegate(queue, main_thread_, id_,
                              script_path, script_name_));
  std::string host;
  int port;
  {
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }
  InspectorSocketServer server(std::move(delegate),
                               &loop,
                               std::move(host),
                               port,
                               inspect_publish_uid_);
  request_queue_ = queue->handle();
  // Its lifetime is now that of the server delegate
  queue.reset();
  {
    Mutex::ScopedLock scoped_l...",32,,284,1,,void
92987,BLOCK,12,,"{
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }",3,,297,12,,void
93029,BLOCK,17,,"{
    Mutex::ScopedLock scoped_lock(thread_start_lock_);
    if (server.Start()) {
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }
    thread_start_condition_.Broadcast(scoped_lock);
  }",3,,310,17,,void
93038,BLOCK,-1,,"{
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }",25,,312,2,,void
93065,BLOCK,-1,,"{
  ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
  return FormatWsAddress(host_port->host(), host_port->port(), id_, true);
}",43,,322,1,,void
93089,BLOCK,-1,,<empty>,29,,335,6,,void
93095,BLOCK,-1,,"{
  auto session = main_thread_->Connect(
      std::unique_ptr<InspectorSessionDelegate>(
          new IoSessionDelegate(request_queue_->handle(), session_id)), true);
  if (session) {
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }
}",70,,338,3,,void
93119,BLOCK,-1,,"{
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }",16,,342,2,,void
93137,BLOCK,-1,,"{
  auto session = sessions_.find(session_id);
  if (session != sessions_.end())
    session->second->Dispatch(Utf8ToStringView(message)->string());
}",71,,349,3,,void
93153,BLOCK,-1,,<empty>,5,,352,2,,void
93169,BLOCK,-1,,"{
  sessions_.erase(session_id);
}",54,,355,2,,void
93178,BLOCK,-1,,"{
  return { target_id_ };
}",62,,359,1,,void
93184,BLOCK,-1,,"{
  return script_name_.empty() ? GetHumanReadableProcessName() : script_name_;
}",72,,363,2,,void
93197,BLOCK,-1,,"{
  return ""file://"" + script_path_;
}",70,,367,2,,void
93206,BLOCK,-1,,"{
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",62,,372,2,,void
93243,BLOCK,-1,,<empty>,1,,1,1,,ANY
93268,BLOCK,-1,,<empty>,1,,1,1,,ANY
93275,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,36,3,,void
93298,BLOCK,-1,,"{
    return inspector->Connect(std::move(delegate), false);
  }",77,,43,3,,void
93314,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }",55,,47,2,,void
93328,BLOCK,-1,,"{
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }",77,,54,3,,void
93344,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }",55,,58,2,,void
93359,BLOCK,-1,,"{
    }",57,,71,3,,void
93364,BLOCK,-1,,"{
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",18,,75,2,,void
93409,BLOCK,-1,,<empty>,73,,82,2,,void
93424,BLOCK,-1,,"{
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",62,,95,4,,void
93453,BLOCK,-1,,"{
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",38,,101,2,,void
93471,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> tmpl =
        NewFunctionTemplate(isolate, JSBindingsConnection::New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        JSBindingsConnection::kInternalFieldCount);
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));
    SetProtoMethod(isolate, tmpl, ""dispatch"", JSBindingsConnection::Dispatch);
    SetProtoMethod(
        isolate, tmpl, ""disconnect"", JSBindingsConnection::Disconnect);
    SetConstructorFunction(
        env->context(), target, ConnectionType::GetClassName(env), tmpl);
  }",60,,105,3,,void
93539,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    CHECK(info[0]->IsFunction());
    Local<Function> callback = info[0].As<Function>();
    new JSBindingsConnection(env, info.This(), callback);
  }",60,,119,2,,void
93578,BLOCK,-1,,"{
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",21,,127,1,,void
93595,BLOCK,-1,,"{
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    session->Disconnect();
  }",67,,133,2,,void
93612,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",65,,139,2,,void
93640,BLOCK,-1,,"{
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }",28,,145,2,,void
93662,BLOCK,-1,,"{
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",58,,151,2,,void
93685,BLOCK,-1,,"{
    return true;  // Binding connections emit events on their own.
  }",59,,160,1,,void
93694,BLOCK,-1,,"{
  Agent* agent = env->inspector_agent();
  return agent->IsActive();
}",48,,169,2,,void
93711,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(info);

  CHECK_EQ(info.Length(), 1);
  CHECK(info[0]->IsFunction());

  realm->set_inspector_console_extension_installer(info[0].As<Function>());
}",76,,174,2,,void
93747,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GT(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  SlicedArguments call_args(args, /* start */ 2);
  env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  v8::MaybeLocal<v8::Value> retval =
      args[0].As<v8::Function>()->Call(env->context(), args[1],
                                       call_args.length(), call_args.out());
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",71,,183,2,,void
93821,BLOCK,-1,,"{
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }",26,,192,2,,void
93837,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();
  CHECK_GE(info.Length(), 2);
  SlicedArguments call_args(info, /* start */ 2);
  if (InspectorEnabled(env)) {
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }

  Local<Value> node_method = info[1];
  CHECK(node_method->IsFunction());
  USE(node_method.As<Function>()->Call(context,
                                   info.H...",68,,197,2,,void
93876,BLOCK,-1,,"{
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }",30,,203,2,,void
93897,BLOCK,-1,,"{
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }",47,,206,2,,void
93939,BLOCK,-1,,<empty>,9,,215,2,,void
93980,BLOCK,-1,,"{
  // The inspector assumes that when other clients use its asyncTask* API,
  // they use real pointers, or at least something aligned like real pointer.
  // In general it means that our task_id should always be even.
  //
  // On 32bit platforms, the 64bit asyncId would get truncated when converted
  // to a 32bit pointer. However, the javascript part will never enable
  // the async_hook on 32bit platforms, therefore the truncation will never
  // happen in practice.
  return reinterpret_cast<void*>(asyncId << 1);
}",44,,227,2,,void
93991,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsNumber());
  int64_t task_id = args[0]->IntegerValue(env->context()).FromJust();
  (env->inspector_agent()->*asyncTaskFn)(GetAsyncTask(task_id));
}",78,,240,2,,void
94036,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  Local<String> task_name = args[0].As<String>();
  String::Value task_name_value(args.GetIsolate(), task_name);
  StringView task_name_view(*task_name_value, task_name_value.length());

  CHECK(args[1]->IsNumber());
  int64_t task_id = args[1]->IntegerValue(env->context()).FromJust();
  void* task = GetAsyncTask(task_id);

  CHECK(args[2]->IsBoolean());
  bool recurring = args[2]->BooleanValue(args.GetIsolate());

  env->inspector_agent()->AsyncTaskScheduled(task_name_view, task, recurring);
}",80,,247,2,,void
94141,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  Local<Function> enable_function = args[0].As<Function>();
  CHECK(args[1]->IsFunction());
  Local<Function> disable_function = args[1].As<Function>();
  env->inspector_agent()->RegisterAsyncHook(env->isolate(),
    enable_function, disable_function);
}",79,,265,2,,void
94205,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(env->inspector_agent()->IsListening());
}",57,,276,2,,void
94232,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();

  if (args.Length() > 0 && args[0]->IsUint32()) {
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }

  if (args.Length() > 1 && args[1]->IsString()) {
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }

  agent->StartIoThread();
}",52,,281,2,,void
94262,BLOCK,-1,,"{
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }",49,,285,2,,void
94314,BLOCK,-1,,"{
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }",49,,292,2,,void
94347,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();
  if (agent->IsActive())
    agent->WaitForConnect();
  args.GetReturnValue().Set(agent->IsActive());
}",63,,301,2,,void
94368,BLOCK,-1,,<empty>,5,,305,2,,void
94388,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string url = env->inspector_agent()->GetWsUrl();
  if (url.empty()) {
    return;
  }
  args.GetReturnValue().Set(OneByteString(env->isolate(), url.c_str()));
}",51,,309,2,,void
94412,BLOCK,-1,,"{
    return;
  }",20,,312,2,,void
94437,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  v8::Local<v8::Function> consoleCallFunc =
      NewFunctionTemplate(isolate,
                          InspectorConsoleCall,
                          v8::Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  auto name_string = FIXED_ONE_BYTE_STRING(isolate, ""consoleCall"");
  target->Set(context, name_string, consoleCallFunc).Check();
  consoleCallFunc->SetName(name_string);

  SetMethod(context,
            target,
            ""setConsoleExtensionInstaller"",
            SetConsoleExtensionInstaller);
  SetMethod(context, target, ""callAndPauseOnStart"", CallAndPauseOnStart);
  SetMethod(context, target, ""open"", Open);
  SetMethodNoSideEffect(context, target, ""url"", Url);
  SetMethod(context, target, ""waitForDebugger"", WaitForDebugger);
...",53,,319,5,,void
94616,BLOCK,-1,,"{
  registry->Register(InspectorConsoleCall);
  registry->Register(SetConsoleExtensionInstaller);
  registry->Register(CallAndPauseOnStart);
  registry->Register(Open);
  registry->Register(Url);
  registry->Register(WaitForDebugger);

  registry->Register(AsyncTaskScheduledWrapper);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskCanceled>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskStarted>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskFinished>);

  registry->Register(RegisterAsyncHookWrapper);
  registry->Register(IsEnabled);

  registry->Register(JSBindingsConnection<LocalConnection>::New);
  registry->Register(JSBindingsConnection<LocalConnection>::Dispatch);
  registry->Register(JSBindingsConnection<LocalConnection>::Disconnect);
  registry->Register(JSBindingsConnection<MainThreadConnection>::New);
  registry->Register(JSBindingsConnection<MainThreadConnection>::Dispatch);
  registry->Register(JSBindingsConnection<MainThrea...",70,,378,2,,void
94725,BLOCK,-1,,"{
    EndStartedProfilers(static_cast<Environment*>(env));
  }",29,,417,2,,void
94763,BLOCK,-1,,<empty>,1,,1,1,,ANY
94768,BLOCK,-1,,<empty>,17,,39,2,,void
94775,BLOCK,-1,,"{
  std::stringstream ss;
  uint32_t id = next_id();
  ss << R""({ ""id"": )"" << id;
  DCHECK(method != nullptr);
  ss << R""(, ""method"": "")"" << method << '""';
  if (params != nullptr) {
    ss << R""(, ""params"": )"" << params;
  }
  ss << "" }"";
  std::string message = ss.str();
  const uint8_t* message_data =
      reinterpret_cast<const uint8_t*>(message.c_str());
  // Save the id of the profile request to identify its response.
  if (is_profile_request) {
    profile_ids_.insert(id);
  }
  Debug(env(),
        DebugCategory::INSPECTOR_PROFILER,
        ""Dispatching message %s\n"",
        message.c_str());
  session_->Dispatch(StringView(message_data, message.length()));
  return id;
}",73,,43,4,,void
94801,BLOCK,-1,,"{
    ss << R""(, ""params"": )"" << params;
  }",26,,49,2,,void
94828,BLOCK,-1,,"{
    profile_ids_.insert(id);
  }",27,,57,2,,void
94862,BLOCK,-1,,"{
  int ret = WriteFileSync(env->isolate(), path, result);
  if (ret != 0) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Written result to %s\n"", path);
}",47,,70,4,,void
94877,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }",17,,72,2,,void
94901,BLOCK,-1,,"{
  Environment* env = connection_->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  const char* type = connection_->type();
  // Convert StringView to a Local<String>.
  Local<String> message_str;
  if (!String::NewFromTwoByte(isolate,
                              message.characters16(),
                              NewStringType::kNormal,
                              message.length())
           .ToLocal(&message_str)) {
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""Receive %s profile message\n"",
        type);

  Local<Value> parsed;
  if (!v8::JSON::Parse(context, message_str).ToLocal(&parsed) ||
      !parsed->IsObject()) {
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }

  Local<Objec...",46,,82,2,,void
94967,BLOCK,-1,,"{
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }",36,,96,2,,void
95006,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }",28,,109,2,,void
95048,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    fprintf(
        stderr, ""Cannot retrieve id from the response message:\n%s\n"", *str);
    return;
  }",26,,118,2,,void
95076,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""%s\n"", *str);
    return;
  }",39,,126,2,,void
95091,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::INSPECTOR_PROFILER,
          ""Writing profile response (id = %"" PRIu64 "")\n"",
          static_cast<uint64_t>(id));
  }",10,,130,1,,void
95113,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to get 'result' from %s profile response\n"", type);
    return;
  }",33,,140,2,,void
95125,BLOCK,-1,,"{
    fprintf(
        stderr, ""'result' from %s profile response is not an object\n"", type);
    return;
  }",30,,145,2,,void
95149,BLOCK,-1,,"{
  fs::FSReqWrapSync req_wrap_sync;
  int ret = fs::MKDirpSync(nullptr, &req_wrap_sync.req, directory, 0777,
                           nullptr);
  if (ret < 0 && ret != UV_EEXIST) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }
  return true;
}",77,,155,3,,void
95174,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }",36,,159,2,,void
95197,BLOCK,-1,,"{
  uint64_t timestamp =
      static_cast<uint64_t>(GetCurrentTimeInMicroseconds() / 1000);
  return SPrintF(""coverage-%s-%s-%s.json"",
      uv_os_getpid(),
      timestamp,
      env()->thread_id());
}",55,,172,1,,void
95219,BLOCK,-1,,"{
  Local<Context> context = env_->context();

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  Local<String> result_s;
  if (!v8::JSON::Stringify(context, profile).ToLocal(&result_s)) {
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }

  // Create the directory if necessary.
  std::string directory = GetDirectory();
  DCHECK(!directory.empty());
  if (!EnsureDirectory(directory, type())) {
    return;
  }

  std::string filename = GetFilename();
  DCHECK(!filename.empty());
  std::string path = directory + kPathSeparator + filename;

  WriteResult(env_, path.c_str(), result_s);
}",63,,181,2,,void
95244,BLOCK,-1,,"{
    return;
  }",46,,186,2,,void
95266,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,191,2,,void
95287,BLOCK,-1,,"{
    return;
  }",44,,199,2,,void
95318,BLOCK,-1,,"{
  Isolate* isolate = env_->isolate();
  Local<Context> context = env_->context();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(context);

  // This is only set up during pre-execution (when the environment variables
  // becomes available in the JS land). If it's empty, we don't have coverage
  // directory path (which is resolved in JS land at the moment) either, so
  // the best we could to is to just discard the profile and do nothing.
  // This should only happen in half-baked Environments created using the
  // embedder API.
  if (env_->source_map_cache_getter().IsEmpty()) {
    return;
  }

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  // append source-map cache information to coverage object:
  Local<Value> source_map_cache_v;
  {
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Func...",63,,210,2,,void
95350,BLOCK,-1,,"{
    return;
  }",50,,222,2,,void
95366,BLOCK,-1,,"{
    return;
  }",46,,228,2,,void
95373,BLOCK,12,,"{
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      PrintCaughtException(isolate, context, try_catch);
    }
  }",3,,234,12,,void
95377,BLOCK,3,,"{
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }",5,,236,3,,void
95407,BLOCK,-1,,"{
        return;
      }",46,,241,2,,void
95420,BLOCK,-1,,"{
      PrintCaughtException(isolate, context, try_catch);
    }",62,,245,2,,void
95431,BLOCK,-1,,"{
    profile->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""source-map-cache""),
                source_map_cache_v).ToChecked();
  }",43,,250,2,,void
95464,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,256,2,,void
95485,BLOCK,-1,,"{
    return;
  }",44,,264,2,,void
95516,BLOCK,-1,,"{
  return result;
}",75,,275,2,,void
95522,BLOCK,-1,,"{
  return env()->coverage_directory();
}",56,,279,1,,void
95531,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  DispatchMessage(""Profiler.startPreciseCoverage"",
                  R""({ ""callCount"": true, ""detailed"": true })"");
}",36,,283,1,,void
95540,BLOCK,-1,,"{
  DispatchMessage(""Profiler.takePreciseCoverage"", nullptr, true);
}",43,,289,1,,void
95548,BLOCK,-1,,"{
  DispatchMessage(""Profiler.stopPreciseCoverage"");
}",43,,293,1,,void
95554,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CoverageConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  TakeCoverage();
}",34,,297,1,,void
95564,BLOCK,-1,,"{
    return;
  }",16,,301,2,,void
95573,BLOCK,-1,,"{
  return env()->cpu_prof_dir();
}",59,,308,1,,void
95582,BLOCK,-1,,"{
  return env()->cpu_prof_name();
}",58,,312,1,,void
95592,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",78,,316,2,,void
95619,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,321,2,,void
95631,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,325,2,,void
95645,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  std::string params = R""({ ""interval"": )"";
  params += std::to_string(env()->cpu_prof_interval());
  params += "" }"";
  DispatchMessage(""Profiler.setSamplingInterval"", params.c_str());
  DispatchMessage(""Profiler.start"");
}",39,,332,1,,void
95676,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CpuProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""Profiler.stop"", nullptr, true);
}",37,,341,1,,void
95686,BLOCK,-1,,"{
    return;
  }",16,,345,2,,void
95698,BLOCK,-1,,"{
  return env()->heap_prof_dir();
}",60,,352,1,,void
95707,BLOCK,-1,,"{
  return env()->heap_prof_name();
}",59,,356,1,,void
95717,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",79,,360,2,,void
95744,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,365,2,,void
95756,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,369,2,,void
95770,BLOCK,-1,,"{
  DispatchMessage(""HeapProfiler.enable"");
  std::string params = R""({ ""samplingInterval"": )"";
  params += std::to_string(env()->heap_prof_interval());
  params += "" }"";
  DispatchMessage(""HeapProfiler.startSampling"", params.c_str());
}",40,,376,1,,void
95799,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8HeapProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""HeapProfiler.stopSampling"", nullptr, true);
}",38,,384,1,,void
95809,BLOCK,-1,,"{
    return;
  }",16,,388,2,,void
95822,BLOCK,-1,,"{
  // TODO(joyeechueng): merge these connections and use one session per env.
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""EndStartedProfilers\n"");
  V8ProfilerConnection* connection = env->cpu_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->heap_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->coverage_connection();
  if (connection != nullptr) {
    connection->End();
  }
}",51,,397,2,,void
95840,BLOCK,-1,,"{
    connection->End();
  }",30,,401,2,,void
95855,BLOCK,-1,,"{
    connection->End();
  }",30,,406,2,,void
95870,BLOCK,-1,,"{
    connection->End();
  }",30,,411,2,,void
95878,BLOCK,-1,,"{
  AtExit(env, [](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }, env);

  Isolate* isolate = env->isolate();
  Local<String> coverage_str = env->env_vars()->Get(
      isolate, FIXED_ONE_BYTE_STRING(isolate, ""NODE_V8_COVERAGE""))
      .FromMaybe(Local<String>());
  if ((!coverage_str.IsEmpty() && coverage_str->Length() > 0) ||
      env->options()->test_runner_coverage) {
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }
  if (env->options()->cpu_prof) {
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->optio...",39,,416,2,,void
95931,BLOCK,-1,,"{
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }",45,,426,2,,void
95962,BLOCK,-1,,"{
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }
    CHECK_NULL(env->cpu_profiler_connection());
    env->set_cpu_profiler_connection(
        std::make_unique<V8CpuProfilerConnection>(env));
    env->cpu_profiler_connection()->Start();
  }",33,,431,2,,void
96006,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    }",48,,435,2,,void
96019,BLOCK,-1,,"{
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }",12,,438,1,,void
96060,BLOCK,-1,,"{
    const std::string& dir = env->options()->heap_prof_dir;
    env->set_heap_prof_interval(env->options()->heap_prof_interval);
    env->set_heap_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->heap_prof_name.empty()) {
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    } else {
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }
    env->set_heap_profiler_connection(
        std::make_unique<profiler::V8HeapProfilerConnection>(env));
    env->heap_profiler_connection()->Start();
  }",34,,446,2,,void
96104,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    }",49,,450,2,,void
96117,BLOCK,-1,,"{
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }",12,,453,1,,void
96152,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  node::Utf8Value directory(env->isolate(), args[0].As<String>());
  env->set_coverage_directory(*directory);
}",75,,462,2,,void
96190,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  Environment* env = Environment::GetCurrent(args);
  env->set_source_map_cache_getter(args[0].As<Function>());
}",78,,470,2,,void
96220,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(
    env,
    DebugCategory::INSPECTOR_PROFILER,
    ""TakeCoverage, connection %s nullptr\n"",
    connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }
}",67,,476,2,,void
96252,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }",30,,486,2,,void
96267,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""StopCoverage, connection %s nullptr\n"",
        connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }
}",67,,492,2,,void
96299,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }",30,,501,2,,void
96317,BLOCK,-1,,"{
  SetMethod(context, target, ""setCoverageDirectory"", SetCoverageDirectory);
  SetMethod(
      context, target, ""setSourceMapCacheGetter"", SetSourceMapCacheGetter);
  SetMethod(context, target, ""takeCoverage"", TakeCoverage);
  SetMethod(context, target, ""stopCoverage"", StopCoverage);
}",36,,510,5,,void
96342,BLOCK,-1,,"{
  registry->Register(SetCoverageDirectory);
  registry->Register(SetSourceMapCacheGetter);
  registry->Register(TakeCoverage);
  registry->Register(StopCoverage);
}",70,,518,2,,void
96374,BLOCK,-1,,<empty>,1,,1,1,,ANY
96378,BLOCK,-1,,{ return b == 0; },59,,204,2,,void
96405,BLOCK,-1,,<empty>,1,,1,1,,ANY
96411,BLOCK,-1,,<empty>,,,,2,,<empty>
96418,BLOCK,-1,,<empty>,,,,3,,<empty>
96423,BLOCK,-1,,<empty>,,,,2,,<empty>
96429,BLOCK,-1,,<empty>,,,,3,,<empty>
96433,BLOCK,-1,,"{
    return &tcp_;
  }",19,,30,1,,void
96440,BLOCK,-1,,<empty>,,,,1,,<empty>
96445,BLOCK,-1,,"{
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",40,,36,2,,void
96462,BLOCK,-1,,<empty>,,,,2,,<empty>
96469,BLOCK,-1,,<empty>,,,,4,,<empty>
96474,BLOCK,-1,,<empty>,,,,2,,<empty>
96478,BLOCK,-1,,<empty>,,,,1,,<empty>
96484,BLOCK,-1,,<empty>,,,,3,,<empty>
96495,BLOCK,-1,,<empty>,,,,3,,<empty>
96500,BLOCK,-1,,<empty>,,,,2,,<empty>
96505,BLOCK,-1,,<empty>,,,,2,,<empty>
96509,BLOCK,-1,,<empty>,,,,1,,<empty>
96514,BLOCK,-1,,<empty>,,,,2,,<empty>
96518,BLOCK,-1,,<empty>,,,,1,,<empty>
96522,BLOCK,-1,,<empty>,,,,1,,<empty>
96526,BLOCK,-1,,"{
    return inspector_;
  }",32,,66,1,,void
96532,BLOCK,-1,,<empty>,,,,1,,<empty>
96536,BLOCK,-1,,<empty>,,,,1,,<empty>
96542,BLOCK,-1,,<empty>,,,,3,,<empty>
96546,BLOCK,-1,,<empty>,,,,1,,<empty>
96556,BLOCK,-1,,<empty>,58,,114,3,,void
96561,BLOCK,-1,,"{
    return node::ContainerOf(&WriteRequest::req, req);
  }",56,,116,2,,void
96577,BLOCK,-1,,"{
    delete WriteRequest::from_write_req(req);
  }",52,,120,3,,void
96594,BLOCK,-1,,"{
  *buf = uv_buf_init(new char[len], len);
}",70,,130,4,,void
96607,BLOCK,-1,,"{
  buffer->erase(buffer->begin(), buffer->begin() + count);
}",76,,134,3,,void
96638,BLOCK,-1,,"{
  // Magic string from websockets spec.
  static const char ws_magic[] = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
  std::string input(client_key + ws_magic);
  char hash[SHA_DIGEST_LENGTH];
  USE(SHA1(reinterpret_cast<const unsigned char*>(input.data()),
           input.size(),
           reinterpret_cast<unsigned char*>(hash)));
  node::base64_encode(hash, sizeof(hash), *buffer, sizeof(*buffer));
}",71,,145,3,,void
96680,BLOCK,-1,,"{
  size_t last_colon_pos = host.rfind(':');
  if (last_colon_pos == std::string::npos)
    return host;
  size_t bracket = host.rfind(']');
  if (bracket == std::string::npos || last_colon_pos > bracket)
    return host.substr(0, last_colon_pos);
  return host;
}",54,,156,2,,void
96697,BLOCK,-1,,<empty>,5,,159,2,,void
96720,BLOCK,-1,,<empty>,5,,162,2,,void
96734,BLOCK,-1,,"{
  // To avoid DNS rebinding attacks, we are aware of the following requirements:
  // * the host name must be an IP address (CVE-2018-7160, CVE-2022-32212),
  // * the IP address must be routable (hackerone.com/reports/1632921), and
  // * the IP address must be formatted unambiguously (CVE-2022-43548).

  // The logic below assumes that the string is null-terminated, so ensure that
  // we did not somehow end up with null characters within the string.
  if (host.find('\0') != std::string::npos) return false;

  // All IPv6 addresses must be enclosed in square brackets, and anything
  // enclosed in square brackets must be an IPv6 address.
  if (host.length() >= 4 && host.front() == '[' && host.back() == ']') {
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRS...",50,,166,2,,void
96747,BLOCK,-1,,<empty>,45,,174,2,,void
96771,BLOCK,-1,,"{
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRSTRLEN) return false;

    // Annoyingly, libuv's implementation of inet_pton() deviates from other
    // implementations of the function in that it allows '%' in IPv6 addresses.
    if (host.find('%') != std::string::npos) return false;

    // Parse the IPv6 address to ensure it is syntactically valid.
    char ipv6_str[INET6_ADDRSTRLEN];
    std::copy(host.begin() + 1, host.end() - 1, ipv6_str);
    ipv6_str[host.length()] = '\0';
    unsigned char ipv6[sizeof(struct in6_addr)];
    if (uv_inet_pton(AF_INET6, ipv6_str, ipv6) != 0) return false;

    // The only non-routable IPv6 address is ::/128. It should not be necessary
    // to explicitly reject it because it will still be enclosed in square
    // brac...",72,,178,2,,void
96781,BLOCK,-1,,<empty>,48,,182,2,,void
96796,BLOCK,-1,,<empty>,46,,186,2,,void
96833,BLOCK,-1,,<empty>,54,,193,2,,void
96847,BLOCK,-1,,"{
      return false;
    }",80,,204,2,,void
96863,BLOCK,-1,,<empty>,55,,219,2,,void
96872,BLOCK,-1,,<empty>,21,,226,2,,void
96950,BLOCK,-1,,"{
  std::vector<char> frame;
  OpCode op_code = kOpCodeText;
  frame.push_back(kFinalBit | op_code);
  const size_t data_length = message.size();
  if (data_length <= kMaxSingleBytePayloadLength) {
    frame.push_back(static_cast<char>(data_length));
  } else if (data_length <= 0xFFFF) {
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  } else {
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }
  frame.insert(frame.end(), message.begin(), message.end());
  return frame;
}",80,,256,2,,void
96974,BLOCK,-1,,"{
    frame.push_back(static_cast<char>(data_length));
  }",51,,261,2,,void
96983,BLOCK,-1,,<empty>,10,,263,1,,void
96988,BLOCK,-1,,"{
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  }",37,,263,2,,void
97011,BLOCK,-1,,"{
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }",10,,267,1,,void
97023,BLOCK,-1,,<empty>,5,,272,1,,void
97033,BLOCK,4,,"{
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }",33,,272,4,,void
97087,BLOCK,-1,,"{
  *bytes_consumed = 0;
  if (buffer.size() < 2)
    return FRAME_INCOMPLETE;

  auto it = buffer.begin();

  unsigned char first_byte = *it++;
  unsigned char second_byte = *it++;

  bool final = (first_byte & kFinalBit) != 0;
  bool reserved1 = (first_byte & kReserved1Bit) != 0;
  bool reserved2 = (first_byte & kReserved2Bit) != 0;
  bool reserved3 = (first_byte & kReserved3Bit) != 0;
  int op_code = first_byte & kOpCodeMask;
  bool masked = (second_byte & kMaskBit) != 0;
  *compressed = reserved1;
  if (!final || reserved2 || reserved3)
    return FRAME_ERROR;  // Only compression extension is supported.

  bool closed = false;
  switch (op_code) {
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // ...",63,,288,6,,void
97099,BLOCK,-1,,<empty>,5,,291,2,,void
97178,BLOCK,-1,,<empty>,5,,306,2,,void
97187,BLOCK,-1,,"{
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // We don't support binary frames yet.
    default:
      return FRAME_ERROR;
  }",20,,309,2,,void
97213,BLOCK,-1,,"{
    return FRAME_ERROR;
  }",32,,324,2,,void
97226,BLOCK,-1,,"{
    int extended_payload_length_size;
    if (payload_length64 == kTwoBytePayloadLengthField) {
      extended_payload_length_size = 2;
    } else if (payload_length64 == kEightBytePayloadLengthField) {
      extended_payload_length_size = 8;
    } else {
      return FRAME_ERROR;
    }
    if ((buffer.end() - it) < extended_payload_length_size)
      return FRAME_INCOMPLETE;
    payload_length64 = 0;
    for (int i = 0; i < extended_payload_length_size; ++i) {
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }
  }",55,,329,2,,void
97232,BLOCK,-1,,"{
      extended_payload_length_size = 2;
    }",57,,331,2,,void
97237,BLOCK,-1,,<empty>,12,,333,1,,void
97242,BLOCK,-1,,"{
      extended_payload_length_size = 8;
    }",66,,333,2,,void
97247,BLOCK,-1,,"{
      return FRAME_ERROR;
    }",12,,335,1,,void
97259,BLOCK,-1,,<empty>,7,,339,2,,void
97266,BLOCK,-1,,<empty>,5,,341,1,,void
97276,BLOCK,4,,"{
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }",60,,341,4,,void
97305,BLOCK,-1,,"{
    // WebSocket frame length too large.
    return FRAME_ERROR;
  }",64,,350,2,,void
97323,BLOCK,-1,,<empty>,5,,357,2,,void
97337,BLOCK,-1,,<empty>,3,,361,1,,void
97392,BLOCK,-1,,{ },31,,377,3,,void
97397,BLOCK,-1,,{ },62,,379,2,,void
97401,BLOCK,-1,,<empty>,35,,380,1,,void
97405,BLOCK,-1,,"{
    tcp_.reset();
    if (dispose_)
      delete this;
  }",25,,382,1,,void
97412,BLOCK,-1,,<empty>,7,,385,2,,void
97419,BLOCK,-1,,"{
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }",49,,388,2,,void
97425,BLOCK,-1,,"{
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    }",8,,391,1,,void
97435,BLOCK,-1,,"{
        remove_from_beginning(data, processed);
      }",26,,394,2,,void
97452,BLOCK,-1,,"{
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }",53,,400,2,,void
97466,BLOCK,-1,,"{
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",28,,406,1,,void
97469,BLOCK,-1,,"{
      dispose_ = true;
      SendClose();
    }",15,,407,2,,void
97475,BLOCK,-1,,"{
      delete this;
    }",12,,410,1,,void
97484,BLOCK,-1,,"{
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",64,,418,3,,void
97516,BLOCK,-1,,"{
    OnCloseReceived = &WsHandler::OnEof;
  }",28,,426,1,,void
97526,BLOCK,-1,,"{
    WriteRaw(std::vector<char>(CLOSE_FRAME, CLOSE_FRAME + sizeof(CLOSE_FRAME)),
             OnCloseFrameWritten);
  }",20,,430,1,,void
97541,BLOCK,-1,,"{
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",29,,435,1,,void
97553,BLOCK,-1,,"{
    int bytes_consumed = 0;
    std::vector<char> output;
    bool compressed = false;

    ws_decode_result r =  decode_frame_hybi17(buffer,
                                              true /* client_frame */,
                                              &bytes_consumed, &output,
                                              &compressed);
    // Compressed frame means client is ignoring the headers and misbehaves
    if (compressed || r == FRAME_ERROR) {
      OnEof();
      bytes_consumed = 0;
    } else if (r == FRAME_CLOSE) {
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    } else if (r == FRAME_OK) {
      delegate()->OnWsFrame(output);
    }
    return bytes_consumed;
  }",54,,440,2,,void
97581,BLOCK,-1,,"{
      OnEof();
      bytes_consumed = 0;
    }",41,,450,2,,void
97587,BLOCK,-1,,<empty>,12,,453,1,,void
97592,BLOCK,-1,,"{
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    }",34,,453,2,,void
97601,BLOCK,-1,,<empty>,12,,456,1,,void
97606,BLOCK,-1,,"{
      delegate()->OnWsFrame(output);
    }",31,,456,2,,void
97626,BLOCK,-1,,{ },26,,474,6,,void
97638,BLOCK,-1,,"{
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",48,,487,3,,void
97672,BLOCK,-1,,"{
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char accept_ws_suffix[] = ""\r\n\r\n"";
    std::vector<char> reply(accept_ws_prefix,
                            accept_ws_prefix + sizeof(accept_ws_prefix) - 1);
    reply.insert(reply.end(), accept_string,
                 accept_string + sizeof(accept_string));
    reply.insert(reply.end(), accept_ws_suffix,
                 accept_ws_suffix + sizeof(accept_ws_suffix) - 1);
    if (WriteRaw(reply, WriteRequest::Cleanup) >= 0) {
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    } else {
      tcp_.reset();
    }
  }",62,,496,2,,void
97731,BLOCK,-1,,"{
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    }",54,,510,2,,void
97745,BLOCK,-1,,"{
      tcp_.reset();
    }",12,,512,1,,void
97753,BLOCK,-1,,"{
    const char HANDSHAKE_FAILED_RESPONSE[] =
        ""HTTP/1.0 400 Bad Request\r\n""
        ""Content-Type: text/html; charset=UTF-8\r\n\r\n""
        ""WebSockets request was expected\r\n"";
    WriteRaw(std::vector<char>(HANDSHAKE_FAILED_RESPONSE,
             HANDSHAKE_FAILED_RESPONSE + sizeof(HANDSHAKE_FAILED_RESPONSE) - 1),
             ThenCloseAndReportFailure);
  }",35,,517,1,,void
97774,BLOCK,-1,,"{
    tcp_.reset();
  }",25,,528,1,,void
97783,BLOCK,-1,,"{
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",49,,532,2,,void
97802,BLOCK,-1,,"{
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }",36,,536,2,,void
97817,BLOCK,-1,,"{
      CancelHandshake();
    }",24,,541,2,,void
97829,BLOCK,-1,,"{
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }",43,,547,3,,void
97841,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",55,,548,2,,void
97845,BLOCK,-1,,<empty>,14,,551,1,,void
97851,BLOCK,-1,,"{
        delegate()->OnHttpGet(event.host, event.path);
      }",34,,551,2,,void
97863,BLOCK,-1,,<empty>,14,,553,1,,void
97871,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",40,,553,2,,void
97875,BLOCK,-1,,"{
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }",14,,556,1,,void
97893,BLOCK,-1,,"{
    WriteRaw(data, WriteRequest::Cleanup);
  }",53,,562,2,,void
97902,BLOCK,-1,,"{
    delete this;
  }",28,,567,1,,void
97910,BLOCK,-1,,"{
    ProtocolHandler* handler = WriteRequest::from_write_req(req)->handler;
    WriteRequest::Cleanup(req, status);
    handler->inspector()->SwitchProtocol(nullptr);
  }",70,,572,3,,void
97941,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",77,,578,4,,void
97972,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",77,,585,4,,void
97982,BLOCK,-1,,"{
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }",34,,587,2,,void
98010,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",70,,595,4,,void
98030,BLOCK,-1,,"{
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",46,,601,2,,void
98045,BLOCK,-1,,"{
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",50,,605,2,,void
98105,BLOCK,-1,,"{
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",60,,620,2,,void
98114,BLOCK,-1,,"{
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }",47,,623,3,,void
98134,BLOCK,-1,,"{
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }",54,,625,2,,void
98137,BLOCK,-1,,<empty>,11,,627,2,,void
98154,BLOCK,-1,,"{
    std::string host = TrimPort(host_with_port);
    return host.empty() || IsIPAddress(host)
           || node::StringEqualNoCase(host.data(), ""localhost"");
  }",63,,635,2,,void
98190,BLOCK,-1,,"{
  CHECK_NOT_NULL(tcp_);
  tcp_->SetHandler(this);
}",80,,655,3,,void
98203,BLOCK,-1,,"{
  return tcp_->WriteRaw(buffer, write_cb);
}",53,,661,3,,void
98214,BLOCK,-1,,"{
  return tcp_->delegate();
}",56,,665,1,,void
98223,BLOCK,-1,,"{
  char ip[INET6_ADDRSTRLEN];
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(tcp_->tcp(),
                               reinterpret_cast<struct sockaddr*>(&addr),
                               &len);
  if (err != 0)
    return """";
  if (addr.ss_family == AF_INET6) {
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  } else {
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }
  if (err != 0)
    return """";
  return ip;
}",46,,669,1,,void
98249,BLOCK,-1,,<empty>,5,,677,2,,void
98258,BLOCK,-1,,"{
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  }",35,,678,2,,void
98274,BLOCK,-1,,"{
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }",10,,681,1,,void
98293,BLOCK,-1,,<empty>,5,,686,2,,void
98302,BLOCK,-1,,{ },42,,694,2,,void
98308,BLOCK,-1,,"{
  TcpHolder* result = new TcpHolder(std::move(delegate));
  uv_stream_t* tcp = reinterpret_cast<uv_stream_t*>(&result->tcp_);
  int err = uv_tcp_init(server->loop, &result->tcp_);
  if (err == 0) {
    err = uv_accept(server, tcp);
  }
  if (err == 0) {
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }
  if (err == 0) {
    return TcpHolder::Pointer(result);
  } else {
    delete result;
    return nullptr;
  }
}",48,,699,3,,void
98343,BLOCK,-1,,"{
    err = uv_accept(server, tcp);
  }",17,,703,2,,void
98353,BLOCK,-1,,"{
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }",17,,706,2,,void
98364,BLOCK,-1,,"{
    return TcpHolder::Pointer(result);
  }",17,,709,2,,void
98372,BLOCK,-1,,"{
    delete result;
    return nullptr;
  }",10,,711,1,,void
98381,BLOCK,-1,,"{
  handler_ = handler;
}",54,,717,2,,void
98390,BLOCK,-1,,"{
#if DUMP_WRITES
  printf(""%s (%ld bytes):\n"", __FUNCTION__, buffer.size());
  dump_hex(buffer.data(), buffer.size());
  printf(""\n"");
#endif

  // Freed in write_request_cleanup
  WriteRequest* wr = new WriteRequest(handler_, buffer);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(&tcp_);
  int err = uv_write(&wr->req, stream, &wr->buf, 1, write_cb);
  if (err < 0)
    delete wr;
  return err < 0;
}",80,,721,3,,void
98424,BLOCK,-1,,<empty>,5,,733,2,,void
98434,BLOCK,-1,,"{
  return delegate_.get();
}",50,,737,1,,void
98444,BLOCK,-1,,"{
  delete From(handle);
}",47,,742,2,,void
98454,BLOCK,-1,,"{
#if DUMP_READS
  if (nread >= 0) {
    printf(""%s (%ld bytes)\n"", __FUNCTION__, nread);
    dump_hex(buf->base, nread);
  } else {
    printf(""[%s:%d] %s\n"", __FUNCTION__, __LINE__, uv_err_name(nread));
  }
#endif
  TcpHolder* holder = From(tcp);
  holder->ReclaimUvBuf(buf, nread);
  if (nread < 0 || nread == UV_EOF) {
    holder->handler_->OnEof();
  } else {
    holder->handler_->OnData(&holder->buffer);
  }
}",55,,747,4,,void
98474,BLOCK,-1,,"{
    holder->handler_->OnEof();
  }",37,,758,2,,void
98482,BLOCK,-1,,"{
    holder->handler_->OnData(&holder->buffer);
  }",10,,760,1,,void
98497,BLOCK,-1,,"{
  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&holder->tcp_);
  uv_close(handle, OnClosed);
}",57,,766,2,,void
98515,BLOCK,-1,,"{
  if (read > 0) {
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }
  delete[] buf->base;
}",65,,771,3,,void
98520,BLOCK,-1,,"{
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }",17,,772,2,,void
98544,BLOCK,-1,,<empty>,,,,1,,<empty>
98549,BLOCK,-1,,"{
  handler->Shutdown();
}",58,,781,2,,void
98559,BLOCK,-1,,"{
  auto tcp = TcpHolder::Accept(server, std::move(delegate));
  if (tcp) {
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  } else {
    return InspectorSocket::Pointer(nullptr);
  }
}",76,,787,3,,void
98575,BLOCK,-1,,"{
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  }",12,,789,2,,void
98600,BLOCK,-1,,"{
    return InspectorSocket::Pointer(nullptr);
  }",10,,793,1,,void
98611,BLOCK,-1,,"{
  protocol_handler_->AcceptUpgrade(ws_key);
}",64,,798,2,,void
98620,BLOCK,-1,,"{
  protocol_handler_->CancelHandshake();
}",41,,802,1,,void
98628,BLOCK,-1,,"{
  return protocol_handler_->GetHost();
}",40,,806,1,,void
98638,BLOCK,-1,,"{
  protocol_handler_.reset(std::move(handler));
}",64,,810,2,,void
98653,BLOCK,-1,,"{
  protocol_handler_->Write(std::vector<char>(data, data + len));
}",59,,814,3,,void
98680,BLOCK,-1,,<empty>,1,,1,1,,ANY
98705,BLOCK,-1,,<empty>,1,,1,1,,ANY
98713,BLOCK,-1,,<empty>,,,,5,,<empty>
98723,BLOCK,-1,,"{
  for (char& c : *string) {
    c = (c == '\""' || c == '\\') ? '_' : c;
  }
}",34,,27,2,,void
98728,BLOCK,-1,,"{
    c = (c == '\""' || c == '\\') ? '_' : c;
  }",27,,28,3,,void
98746,BLOCK,-1,,"{
  // Host is valid (socket was bound) so colon means it's a v6 IP address
  bool v6 = host.find(':') != std::string::npos;
  std::ostringstream url;
  if (v6) {
    url << '[';
  }
  url << host;
  if (v6) {
    url << ']';
  }
  url << ':' << port;
  return url.str();
}",63,,33,3,,void
98764,BLOCK,-1,,"{
    url << '[';
  }",11,,37,2,,void
98773,BLOCK,-1,,"{
    url << ']';
  }",11,,41,2,,void
98793,BLOCK,-1,,"{
  std::ostringstream url;
  if (include_protocol)
    url << ""ws://"";
  url << host << '/' << target_id;
  return url.str();
}",50,,50,4,,void
98797,BLOCK,-1,,<empty>,5,,53,2,,void
98817,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""{\n"";
  for (const auto& name_value : object) {
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }
  json << ""\n} "";
  return json.str();
}",75,,58,2,,void
98829,BLOCK,-1,,"{
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }",41,,62,3,,void
98833,BLOCK,-1,,<empty>,7,,64,2,,void
98868,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""[ "";
  for (const auto& object : array) {
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }
  json << ""]\n\n"";
  return json.str();
}",67,,74,2,,void
98880,BLOCK,-1,,"{
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }",36,,78,3,,void
98884,BLOCK,-1,,<empty>,7,,80,2,,void
98908,BLOCK,-1,,"{
  size_t len = strlen(expected);
  if (StringEqualNoCaseN(path, expected, len)) {
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }
  return nullptr;
}",70,,88,3,,void
98919,BLOCK,-1,,"{
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }",48,,90,2,,void
98926,BLOCK,-1,,<empty>,27,,91,2,,void
98939,BLOCK,-1,,<empty>,28,,92,2,,void
98952,BLOCK,-1,,"{
  const char HEADERS[] = ""HTTP/1.0 %d OK\r\n""
                         ""Content-Type: application/json; charset=UTF-8\r\n""
                         ""Cache-Control: no-cache\r\n""
                         ""Content-Length: %zu\r\n""
                         ""\r\n"";
  char header[sizeof(HEADERS) + 20];
  int header_len = snprintf(header,
                            sizeof(header),
                            HEADERS,
                            code,
                            response.size());
  socket->Write(header, header_len);
  socket->Write(response.data(), response.size());
}",33,,99,4,,void
98993,BLOCK,-1,,"{
  std::map<std::string, std::string> response;
  response[""Browser""] = ""node.js/"" NODE_VERSION;
  response[""Protocol-Version""] = ""1.1"";
  SendHttpResponse(socket, MapToString(response), 200);
}",51,,115,2,,void
99026,BLOCK,-1,,"{
  SendHttpResponse(socket, """", 404);
}",48,,122,2,,void
99035,BLOCK,-1,,"{
  z_stream strm;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  strm.opaque = Z_NULL;
  CHECK_EQ(Z_OK, inflateInit(&strm));
  static const size_t kDecompressedSize =
      PROTOCOL_JSON[0] * 0x10000u +
      PROTOCOL_JSON[1] * 0x100u +
      PROTOCOL_JSON[2];
  strm.next_in = const_cast<uint8_t*>(PROTOCOL_JSON + 3);
  strm.avail_in = sizeof(PROTOCOL_JSON) - 3;
  std::string data(kDecompressedSize, '\0');
  strm.next_out = reinterpret_cast<Byte*>(data.data());
  strm.avail_out = data.size();
  CHECK_EQ(Z_STREAM_END, inflate(&strm, Z_FINISH));
  CHECK_EQ(0, strm.avail_out);
  CHECK_EQ(Z_OK, inflateEnd(&strm));
  SendHttpResponse(socket, data, 200);
}",48,,126,2,,void
99141,BLOCK,-1,,"{
  return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);
}",52,,150,5,,void
99156,BLOCK,-1,,<empty>,,,,4,,<empty>
99160,BLOCK,-1,,"{
    ws_socket_.reset();
  }",16,,157,1,,void
99169,BLOCK,-1,,<empty>,,,,2,,<empty>
99174,BLOCK,-1,,"{
    ws_socket_ = std::move(ws_socket);
  }",48,,161,2,,void
99185,BLOCK,-1,,{ return id_; },18,,164,1,,void
99191,BLOCK,-1,,"{
    return server_port_;
  }",21,,165,1,,void
99197,BLOCK,-1,,"{
    return ws_socket_.get();
  }",32,,168,1,,void
99207,BLOCK,-1,,"{
    ws_socket_->AcceptUpgrade(ws_key);
  }",42,,171,2,,void
99216,BLOCK,-1,,"{
    ws_socket_->CancelHandshake();
  }",18,,174,1,,void
99227,BLOCK,-1,,{ },57,,181,3,,void
99231,BLOCK,-1,,"{
      server_->SessionTerminated(session_id_);
    }",26,,182,1,,void
99242,BLOCK,-1,,<empty>,,,,3,,<empty>
99249,BLOCK,-1,,<empty>,,,,4,,<empty>
99254,BLOCK,-1,,<empty>,,,,2,,<empty>
99258,BLOCK,-1,,"{
      return server_->Session(session_id_);
    }",30,,191,1,,void
99275,BLOCK,-1,,<empty>,68,,208,2,,void
99281,BLOCK,-1,,<empty>,,,,3,,<empty>
99285,BLOCK,-1,,"{
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",16,,210,1,,void
99295,BLOCK,-1,,{ return port_; },20,,213,1,,void
99302,BLOCK,-1,,"{
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",56,,217,2,,void
99320,BLOCK,-1,,<empty>,,,,3,,<empty>
99325,BLOCK,-1,,"{
    delete FromTcpSocket(tcp_socket_);
  }",61,,222,2,,void
99332,BLOCK,-1,,<empty>,,,,1,,<empty>
99336,BLOCK,-1,,<empty>,,,,1,,<empty>
99343,BLOCK,-1,,<empty>,,,,1,,<empty>
99357,BLOCK,-1,,"{
  if (!publish_uid_stderr || out == nullptr) {
    return;
  }
  for (const auto& server_socket : server_sockets) {
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }
  fprintf(out, ""For help, see: %s\n"",
          ""https://nodejs.org/en/docs/inspector"");
  fflush(out);
}",16,,239,7,,void
99365,BLOCK,-1,,"{
    return;
  }",46,,240,2,,void
99370,BLOCK,-1,,"{
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }",52,,243,3,,void
99374,BLOCK,-1,,"{
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }",39,,244,3,,void
99405,BLOCK,-1,,"{
  delegate_->AssignServer(this);
  state_ = ServerState::kNew;
}",17,,265,7,,void
99419,BLOCK,-1,,<empty>,,,,1,,<empty>
99424,BLOCK,-1,,"{
  auto it = connected_sessions_.find(session_id);
  return it == connected_sessions_.end() ? nullptr : it->second.second.get();
}",63,,272,2,,void
99456,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (!TargetExists(id)) {
    session->Decline();
    return;
  }
  connected_sessions_[session_id].first = id;
  session->Accept(ws_key);
  delegate_->StartSession(session_id, id);
}",71,,279,4,,void
99466,BLOCK,-1,,"{
    session->Decline();
    return;
  }",26,,281,2,,void
99494,BLOCK,-1,,"{
  if (Session(session_id) == nullptr) {
    return;
  }
  bool was_attached = connected_sessions_[session_id].first != """";
  if (was_attached) {
    delegate_->EndSession(session_id);
  }
  connected_sessions_.erase(session_id);
  if (connected_sessions_.empty()) {
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }
}",63,,290,2,,void
99500,BLOCK,-1,,"{
    return;
  }",39,,291,2,,void
99514,BLOCK,-1,,"{
    delegate_->EndSession(session_id);
  }",21,,295,2,,void
99530,BLOCK,-1,,"{
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }",36,,299,2,,void
99545,BLOCK,-1,,"{
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }",38,,301,2,,void
99564,BLOCK,-1,,"{
      delegate_.reset();
    }",42,,309,2,,void
99575,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  InspectorSocket* socket = session->ws_socket();
  if (!inspect_publish_uid_.http) {
    SendHttpNotFound(socket);
    return true;
  }
  const char* command = MatchPathSegment(path.c_str(), ""/json"");
  if (command == nullptr)
    return false;

  if (MatchPathSegment(command, ""list"") || command[0] == '\0') {
    SendListResponse(socket, host, session);
    return true;
  } else if (MatchPathSegment(command, ""protocol"")) {
    SendProtocolJson(socket);
    return true;
  } else if (MatchPathSegment(command, ""version"")) {
    SendVersionResponse(socket);
    return true;
  }
  return false;
}",71,,317,4,,void
99593,BLOCK,-1,,"{
    SendHttpNotFound(socket);
    return true;
  }",35,,320,2,,void
99611,BLOCK,-1,,<empty>,5,,326,2,,void
99624,BLOCK,-1,,"{
    SendListResponse(socket, host, session);
    return true;
  }",64,,328,2,,void
99632,BLOCK,-1,,<empty>,10,,331,1,,void
99637,BLOCK,-1,,"{
    SendProtocolJson(socket);
    return true;
  }",53,,331,2,,void
99643,BLOCK,-1,,<empty>,10,,334,1,,void
99648,BLOCK,-1,,"{
    SendVersionResponse(socket);
    return true;
  }",52,,334,2,,void
99661,BLOCK,-1,,"{
  std::vector<std::map<std::string, std::string>> response;
  for (const std::string& id : delegate_->GetTargetIds()) {
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
   ...",70,,343,4,,void
99669,BLOCK,-1,,"{
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
    std::string formatted_address = FormatAddress(detected_host, id, false);
    target_map[""devtoolsFrontendUrl""] = GetFro...",59,,345,3,,void
99750,BLOCK,-1,,"{
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }",32,,361,2,,void
99801,BLOCK,-1,,"{
  std::ostringstream frontend_url;
  frontend_url << ""devtools://devtools/bundled/"";
  frontend_url << (is_compat ? ""inspector"" : ""js_app"");
  frontend_url << "".html?experiments=true&v8only=true&ws="";
  frontend_url << formatted_address;
  return frontend_url.str();
}",43,,377,3,,void
99826,BLOCK,-1,,"{
  CHECK_NOT_NULL(delegate_);
  CHECK_EQ(state_, ServerState::kNew);
  std::unique_ptr<SocketServerDelegate> delegate_holder;
  // We will return it if startup is successful
  delegate_.swap(delegate_holder);
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = AI_NUMERICSERV;
  hints.ai_socktype = SOCK_STREAM;
  uv_getaddrinfo_t req;
  const std::string port_string = std::to_string(port_);
  int err = uv_getaddrinfo(loop_, &req, nullptr, host_.c_str(),
                           port_string.c_str(), &hints);
  if (err < 0) {
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }
  for (addrinfo* address = req.addrinfo; address != nullptr;
       address = address->ai_next) {
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::mov...",37,,386,1,,void
99893,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }",16,,400,2,,void
99898,BLOCK,-1,,"{
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }",26,,401,2,,void
99911,BLOCK,-1,,<empty>,3,,407,1,,void
99926,BLOCK,4,,"{
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::move(server_socket));
  }",36,,408,4,,void
99948,BLOCK,-1,,<empty>,7,,412,2,,void
99967,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }
    return false;
  }",32,,418,2,,void
99972,BLOCK,-1,,"{
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }",26,,419,2,,void
100013,BLOCK,-1,,"{
  if (state_ == ServerState::kStopped)
    return;
  CHECK_EQ(state_, ServerState::kRunning);
  state_ = ServerState::kStopped;
  server_sockets_.clear();
  if (done())
    delegate_.reset();
}",36,,437,1,,void
100020,BLOCK,-1,,<empty>,5,,439,2,,void
100038,BLOCK,-1,,<empty>,5,,444,2,,void
100046,BLOCK,-1,,"{
  for (const auto& key_value : connected_sessions_)
    key_value.second.second->Close();
}",52,,447,1,,void
100062,BLOCK,-1,,"{
  const std::vector<std::string>& target_ids = delegate_->GetTargetIds();
  const auto& found = std::find(target_ids.begin(), target_ids.end(), id);
  return found != target_ids.end();
}",65,,452,2,,void
100096,BLOCK,-1,,"{
  if (!server_sockets_.empty()) {
    return server_sockets_[0]->port();
  }
  return port_;
}",41,,458,1,,void
100103,BLOCK,-1,,"{
    return server_sockets_[0]->port();
  }",33,,459,2,,void
100118,BLOCK,-1,,"{
  std::unique_ptr<SocketSession> session(
      new SocketSession(this, next_session_id_++, server_port));

  InspectorSocket::DelegatePointer delegate =
      InspectorSocket::DelegatePointer(
          new SocketSession::Delegate(this, session->id()));

  InspectorSocket::Pointer inspector =
      InspectorSocket::Accept(server_socket, std::move(delegate));
  if (inspector) {
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }
}",64,,466,3,,void
100161,BLOCK,-1,,"{
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }",18,,476,2,,void
100190,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (session != nullptr) {
    session->Send(message);
  }
}",78,,482,3,,void
100200,BLOCK,-1,,"{
    session->Send(message);
  }",27,,484,2,,void
100210,BLOCK,-1,,"{
  server->Close();
}",69,,489,2,,void
100221,BLOCK,-1,,<empty>,42,,496,4,,void
100226,BLOCK,-1,,"{
  ws_socket_->Write(message.data(), message.length());
}",54,,498,2,,void
100244,BLOCK,-1,,"{
  if (!server_->HandleGetRequest(session_id_, host, path))
    Session()->ws_socket()->CancelHandshake();
}",66,,503,3,,void
100254,BLOCK,-1,,<empty>,5,,505,2,,void
100268,BLOCK,-1,,"{
  std::string id = path.empty() ? path : path.substr(1);
  server_->SessionStarted(session_id_, id, ws_key);
}",74,,510,4,,void
100294,BLOCK,-1,,"{
  server_->MessageReceived(session_id_,
                           std::string(data.data(), data.size()));
}",72,,515,2,,void
100315,BLOCK,-1,,"{
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(&tcp_socket_,
                               reinterpret_cast<struct sockaddr*>(&addr), &len);
  if (err != 0)
    return err;
  int port;
  if (addr.ss_family == AF_INET6)
    port = reinterpret_cast<const sockaddr_in6*>(&addr)->sin6_port;
  else
    port = reinterpret_cast<const sockaddr_in*>(&addr)->sin_port;
  port_ = ntohs(port);
  return err;
}",32,,521,1,,void
100338,BLOCK,-1,,<empty>,5,,527,2,,void
100348,BLOCK,-1,,<empty>,5,,530,2,,void
100358,BLOCK,-1,,<empty>,5,,532,1,,void
100378,BLOCK,-1,,"{
  uv_tcp_t* server = &tcp_socket_;
  CHECK_EQ(0, uv_tcp_init(loop, server));
  int err = uv_tcp_bind(server, addr, 0);
  if (err == 0) {
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }
  if (err == 0) {
    err = DetectPort();
  }
  return err;
}",59,,537,3,,void
100400,BLOCK,-1,,"{
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }",17,,541,2,,void
100415,BLOCK,-1,,"{
    err = DetectPort();
  }",17,,546,2,,void
100426,BLOCK,-1,,"{
  if (status == 0) {
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }
}",56,,554,3,,void
100431,BLOCK,-1,,"{
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }",20,,555,2,,void
100468,BLOCK,-1,,<empty>,1,,1,1,,ANY
100479,BLOCK,-1,,<empty>,1,,1,1,,ANY
100483,BLOCK,-1,,<empty>,,,,3,,<empty>
100489,BLOCK,-1,,<empty>,,,,3,,<empty>
100495,BLOCK,-1,,<empty>,,,,3,,<empty>
100501,BLOCK,-1,,<empty>,,,,3,,<empty>
100508,BLOCK,-1,,<empty>,,,,4,,<empty>
100514,BLOCK,-1,,<empty>,,,,3,,<empty>
100520,BLOCK,-1,,<empty>,,,,3,,<empty>
100527,BLOCK,-1,,<empty>,,,,4,,<empty>
100534,BLOCK,-1,,<empty>,,,,4,,<empty>
100541,BLOCK,-1,,<empty>,,,,4,,<empty>
100548,BLOCK,-1,,<empty>,,,,4,,<empty>
100555,BLOCK,-1,,<empty>,,,,4,,<empty>
100563,BLOCK,-1,,<empty>,,,,5,,<empty>
100571,BLOCK,-1,,<empty>,,,,5,,<empty>
100579,BLOCK,-1,,<empty>,,,,5,,<empty>
100586,BLOCK,-1,,<empty>,,,,4,,<empty>
100596,BLOCK,-1,,<empty>,,,,7,,<empty>
100604,BLOCK,-1,,<empty>,,,,5,,<empty>
100612,BLOCK,-1,,<empty>,,,,5,,<empty>
100620,BLOCK,-1,,<empty>,,,,5,,<empty>
100627,BLOCK,-1,,<empty>,,,,4,,<empty>
100634,BLOCK,-1,,<empty>,,,,4,,<empty>
100641,BLOCK,-1,,<empty>,,,,4,,<empty>
100648,BLOCK,-1,,<empty>,,,,4,,<empty>
100655,BLOCK,-1,,<empty>,,,,4,,<empty>
100662,BLOCK,-1,,<empty>,,,,4,,<empty>
100671,BLOCK,-1,,<empty>,,,,6,,<empty>
100680,BLOCK,-1,,<empty>,,,,6,,<empty>
100689,BLOCK,-1,,<empty>,,,,6,,<empty>
100696,BLOCK,-1,,<empty>,,,,4,,<empty>
100703,BLOCK,-1,,<empty>,,,,4,,<empty>
100710,BLOCK,-1,,<empty>,,,,4,,<empty>
100717,BLOCK,-1,,<empty>,,,,4,,<empty>
100724,BLOCK,-1,,<empty>,,,,4,,<empty>
100731,BLOCK,-1,,<empty>,,,,4,,<empty>
100739,BLOCK,-1,,<empty>,,,,5,,<empty>
100747,BLOCK,-1,,<empty>,,,,5,,<empty>
100755,BLOCK,-1,,<empty>,,,,5,,<empty>
100763,BLOCK,-1,,<empty>,,,,5,,<empty>
100771,BLOCK,-1,,<empty>,,,,5,,<empty>
100779,BLOCK,-1,,<empty>,,,,5,,<empty>
100787,BLOCK,-1,,<empty>,,,,5,,<empty>
100795,BLOCK,-1,,<empty>,,,,5,,<empty>
100803,BLOCK,-1,,<empty>,,,,5,,<empty>
100811,BLOCK,-1,,<empty>,,,,5,,<empty>
100819,BLOCK,-1,,<empty>,,,,5,,<empty>
100827,BLOCK,-1,,<empty>,,,,5,,<empty>
100835,BLOCK,-1,,<empty>,,,,5,,<empty>
100842,BLOCK,-1,,<empty>,,,,4,,<empty>
100849,BLOCK,-1,,<empty>,,,,4,,<empty>
100857,BLOCK,-1,,<empty>,,,,5,,<empty>
100867,BLOCK,-1,,<empty>,,,,7,,<empty>
100876,BLOCK,-1,,<empty>,,,,6,,<empty>
100884,BLOCK,-1,,<empty>,,,,5,,<empty>
100894,BLOCK,-1,,<empty>,,,,7,,<empty>
100901,BLOCK,-1,,<empty>,,,,4,,<empty>
100913,BLOCK,-1,,<empty>,,,,9,,<empty>
100923,BLOCK,-1,,<empty>,,,,7,,<empty>
100930,BLOCK,-1,,<empty>,,,,4,,<empty>
100937,BLOCK,-1,,<empty>,,,,4,,<empty>
100946,BLOCK,-1,,<empty>,,,,6,,<empty>
100953,BLOCK,-1,,<empty>,,,,4,,<empty>
100961,BLOCK,-1,,<empty>,,,,5,,<empty>
100967,BLOCK,-1,,<empty>,,,,3,,<empty>
100974,BLOCK,-1,,<empty>,,,,4,,<empty>
100981,BLOCK,-1,,<empty>,,,,4,,<empty>
100988,BLOCK,-1,,<empty>,,,,4,,<empty>
100994,BLOCK,-1,,<empty>,,,,3,,<empty>
101000,BLOCK,-1,,<empty>,,,,3,,<empty>
101006,BLOCK,-1,,<empty>,,,,3,,<empty>
101012,BLOCK,-1,,<empty>,,,,3,,<empty>
101020,BLOCK,-1,,<empty>,,,,5,,<empty>
101026,BLOCK,-1,,<empty>,,,,3,,<empty>
101033,BLOCK,-1,,<empty>,,,,4,,<empty>
101040,BLOCK,-1,,<empty>,,,,4,,<empty>
101047,BLOCK,-1,,<empty>,,,,4,,<empty>
101054,BLOCK,-1,,<empty>,,,,4,,<empty>
101060,BLOCK,-1,,<empty>,,,,3,,<empty>
101066,BLOCK,-1,,<empty>,,,,3,,<empty>
101073,BLOCK,-1,,<empty>,,,,4,,<empty>
101081,BLOCK,-1,,<empty>,,,,5,,<empty>
101091,BLOCK,-1,,<empty>,,,,7,,<empty>
101099,BLOCK,-1,,<empty>,,,,5,,<empty>
101106,BLOCK,-1,,<empty>,,,,4,,<empty>
101116,BLOCK,-1,,<empty>,,,,7,,<empty>
101127,BLOCK,-1,,<empty>,,,,8,,<empty>
101136,BLOCK,-1,,<empty>,,,,6,,<empty>
101143,BLOCK,-1,,<empty>,,,,4,,<empty>
101153,BLOCK,-1,,<empty>,,,,7,,<empty>
101159,BLOCK,-1,,<empty>,,,,3,,<empty>
101166,BLOCK,-1,,<empty>,,,,4,,<empty>
101173,BLOCK,-1,,<empty>,,,,4,,<empty>
101180,BLOCK,-1,,<empty>,,,,4,,<empty>
101187,BLOCK,-1,,<empty>,,,,4,,<empty>
101194,BLOCK,-1,,<empty>,,,,4,,<empty>
101201,BLOCK,-1,,<empty>,,,,4,,<empty>
101208,BLOCK,-1,,<empty>,,,,4,,<empty>
101215,BLOCK,-1,,<empty>,,,,4,,<empty>
101222,BLOCK,-1,,<empty>,,,,4,,<empty>
101232,BLOCK,-1,,<empty>,,,,7,,<empty>
101239,BLOCK,-1,,<empty>,,,,4,,<empty>
101246,BLOCK,-1,,<empty>,,,,4,,<empty>
101255,BLOCK,-1,,<empty>,,,,6,,<empty>
101263,BLOCK,-1,,<empty>,,,,5,,<empty>
101271,BLOCK,-1,,<empty>,,,,5,,<empty>
101280,BLOCK,-1,,<empty>,,,,6,,<empty>
101290,BLOCK,-1,,<empty>,,,,7,,<empty>
101298,BLOCK,-1,,<empty>,,,,5,,<empty>
101304,BLOCK,-1,,<empty>,,,,3,,<empty>
101310,BLOCK,-1,,<empty>,,,,3,,<empty>
101317,BLOCK,-1,,<empty>,,,,4,,<empty>
101324,BLOCK,-1,,<empty>,,,,4,,<empty>
101332,BLOCK,-1,,<empty>,,,,5,,<empty>
101338,BLOCK,-1,,<empty>,,,,3,,<empty>
101344,BLOCK,-1,,<empty>,,,,3,,<empty>
101355,BLOCK,-1,,<empty>,1,,1,1,,ANY
101377,BLOCK,-1,,<empty>,,,,1,,<empty>
101458,BLOCK,-1,,<empty>,,,,3,,<empty>
101465,BLOCK,-1,,<empty>,,,,4,,<empty>
101487,BLOCK,-1,,"{ result = cb(env, cbinfo_wrapper); }",43,,441,2,,void
101503,BLOCK,-1,,"{
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        }",71,,442,3,,void
101512,BLOCK,-1,,"{
                            return;
                          }",63,,444,2,,void
101527,BLOCK,-1,,"{
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",80,,1530,2,,void
101553,BLOCK,-1,,"{
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  }",80,,1542,2,,void
101578,BLOCK,-1,,"{
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",80,,1552,2,,void
101603,BLOCK,-1,,"{
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      }",33,,1577,2,,void
101608,BLOCK,1,,<empty>,,,,1,,void
101610,BLOCK,-1,,"{
          length = (std::string_view(str)).length();
        }",41,,1578,2,,void
101650,BLOCK,-1,,"{
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      }",33,,1604,2,,void
101655,BLOCK,1,,<empty>,,,,1,,void
101657,BLOCK,-1,,"{
          length = (std::u16string_view(str)).length();
        }",41,,1605,2,,void
101711,BLOCK,-1,,<empty>,1,,1,1,,ANY
101720,BLOCK,-1,,"{
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = string_maker(isolate);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",49,,69,6,,void
101723,BLOCK,1,,<empty>,,,,2,,void
101725,BLOCK,-1,,CHECK_ENV(env),3,,70,1,,void
101730,BLOCK,-1,,CHECK_ENV(env),3,,70,2,,void
101738,BLOCK,-1,,<empty>,19,,71,2,,void
101742,BLOCK,1,,<empty>,,,,3,,void
101744,BLOCK,-1,,"CHECK_ARG(env, str)",19,,71,1,,void
101750,BLOCK,-1,,"CHECK_ARG(env, str)",19,,71,2,,void
101759,BLOCK,1,,<empty>,,,,3,,void
101761,BLOCK,-1,,"CHECK_ARG(env, result)",3,,72,1,,void
101767,BLOCK,-1,,"CHECK_ARG(env, result)",3,,72,2,,void
101776,BLOCK,1,,<empty>,,,,3,,void
101778,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,73,1,,void
101788,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,73,2,,void
101809,BLOCK,1,,<empty>,,,,5,,void
101811,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,78,1,,void
101819,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,78,2,,void
101851,BLOCK,-1,,"{
  napi_status status;
#if defined(V8_ENABLE_SANDBOX)
  status = create_api(env, str, length, result);
  if (status == napi_ok) {
    if (copied != nullptr) {
      *copied = true;
    }
    if (finalize_callback) {
      env->CallFinalizer(
          finalize_callback, static_cast<CharType*>(str), finalize_hint);
    }
  }
#else
  status = NewString(env, str, length, result, string_maker);
  if (status == napi_ok && copied != nullptr) {
    *copied = false;
  }
#endif  // V8_ENABLE_SANDBOX
  return status;
}",57,,92,10,,void
101869,BLOCK,-1,,"{
    *copied = false;
  }",47,,107,2,,void
101884,BLOCK,-1,,"{
    Link(finalize_callback == nullptr ? &env->reflist
                                      : &env->finalizing_reflist);
  }",64,,120,5,,void
101901,BLOCK,-1,,"{
    Unlink();
    env_ = nullptr;
  }",28,,131,1,,void
101909,BLOCK,-1,,"{
    if (finalize_callback_ == nullptr) return;
    if (env_ == nullptr) {
      // The environment is dead. Call the finalizer directly.
      finalize_callback_(nullptr, finalize_data_, finalize_hint_);
    } else {
      // The environment is still alive. Let's remove ourselves from its list
      // of references and call the user's finalizer.
      Unlink();
      env_->CallFinalizer(finalize_callback_, finalize_data_, finalize_hint_);
    }
  }",28,,136,1,,void
101914,BLOCK,-1,,<empty>,40,,137,2,,void
101920,BLOCK,-1,,"{
      // The environment is dead. Call the finalizer directly.
      finalize_callback_(nullptr, finalize_data_, finalize_hint_);
    }",26,,138,2,,void
101926,BLOCK,-1,,"{
      // The environment is still alive. Let's remove ourselves from its list
      // of references and call the user's finalizer.
      Unlink();
      env_->CallFinalizer(finalize_callback_, finalize_data_, finalize_hint_);
    }",12,,141,1,,void
101944,BLOCK,-1,,<empty>,25,,161,6,,void
101948,BLOCK,-1,,{ return string_; },37,,163,1,,void
101954,BLOCK,-1,,{ return length_; },34,,164,1,,void
101968,BLOCK,-1,,<empty>,25,,181,6,,void
101972,BLOCK,-1,,{ return string_; },41,,183,1,,void
101978,BLOCK,-1,,{ return length_; },34,,184,1,,void
101989,BLOCK,-1,,"{
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",34,,194,4,,void
101996,BLOCK,-1,,"{
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  }",31,,195,2,,void
102005,BLOCK,1,,<empty>,,,,6,,void
102007,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
102017,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
102027,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
102034,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
102042,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
102072,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
102080,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
102095,BLOCK,-1,,"{
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }",10,,197,1,,void
102120,BLOCK,1,,<empty>,,,,4,,void
102122,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,201,1,,void
102129,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,201,2,,void
102148,BLOCK,-1,,"{
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",49,,210,2,,void
102177,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }",54,,216,2,,void
102193,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }",56,,220,2,,void
102209,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }",58,,223,2,,void
102225,BLOCK,-1,,"{
  return reinterpret_cast<napi_deferred>(local);
}",43,,231,2,,void
102234,BLOCK,-1,,"{
  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);
}",26,,236,2,,void
102244,BLOCK,-1,,<empty>,70,,242,2,,void
102251,BLOCK,-1,,<empty>,47,,256,2,,void
102255,BLOCK,-1,,{ return escape_called_; },30,,257,1,,void
102262,BLOCK,-1,,"{
    escape_called_ = true;
    return scope.Escape(handle);
  }",44,,259,2,,void
102278,BLOCK,-1,,"{
  return reinterpret_cast<napi_handle_scope>(s);
}",80,,269,2,,void
102287,BLOCK,-1,,"{
  return reinterpret_cast<HandleScopeWrapper*>(s);
}",80,,273,2,,void
102296,BLOCK,-1,,"{
  return reinterpret_cast<napi_escapable_handle_scope>(s);
}",37,,279,2,,void
102305,BLOCK,-1,,"{
  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);
}",36,,285,2,,void
102317,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",55,,292,5,,void
102320,BLOCK,1,,<empty>,,,,2,,void
102322,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102327,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102332,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102341,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102348,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102355,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102376,BLOCK,1,,<empty>,,,,3,,void
102378,BLOCK,-1,,"CHECK_ARG(env, result)",3,,294,1,,void
102384,BLOCK,-1,,"CHECK_ARG(env, result)",3,,294,2,,void
102478,BLOCK,1,,<empty>,,,,5,,void
102480,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,312,1,,void
102488,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,312,2,,void
102497,BLOCK,1,,<empty>,,,,3,,void
102518,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } e...",48,,322,5,,void
102521,BLOCK,1,,<empty>,,,,2,,void
102523,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102528,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102533,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102542,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102549,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102556,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102577,BLOCK,1,,<empty>,,,,3,,void
102579,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,324,1,,void
102585,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,324,2,,void
102595,BLOCK,-1,,"{
    CHECK_ARG(env, result);
  }",27,,325,2,,void
102599,BLOCK,1,,<empty>,,,,3,,void
102601,BLOCK,-1,,"CHECK_ARG(env, result)",5,,326,1,,void
102607,BLOCK,-1,,"CHECK_ARG(env, result)",5,,326,2,,void
102649,BLOCK,1,,<empty>,,,,4,,void
102651,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,332,1,,void
102658,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,332,2,,void
102690,BLOCK,1,,<empty>,,,,2,,void
102709,BLOCK,1,,<empty>,,,,5,,void
102711,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,337,1,,void
102718,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,337,2,,void
102738,BLOCK,-1,,"{
    *result = reference->Data();
  }",15,,341,2,,void
102750,BLOCK,-1,,"{
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } else {
      delete reference;
    }
  }",29,,345,2,,void
102761,BLOCK,1,,<empty>,,,,2,,void
102782,BLOCK,-1,,"{
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    }",57,,348,2,,void
102788,BLOCK,-1,,"{
      delete reference;
    }",12,,351,1,,void
102794,BLOCK,1,,<empty>,,,,3,,void
102812,BLOCK,-1,,"{
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",54,,373,4,,void
102877,BLOCK,-1,,"{
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }",60,,389,4,,void
102893,BLOCK,-1,,<empty>,65,,400,4,,void
102897,BLOCK,-1,,<empty>,,,,1,,<empty>
102903,BLOCK,-1,,<empty>,,,,3,,<empty>
102908,BLOCK,-1,,<empty>,,,,2,,<empty>
102912,BLOCK,-1,,{ return _this; },21,,406,1,,void
102918,BLOCK,-1,,{ return _args_length; },23,,408,1,,void
102924,BLOCK,-1,,{ return _data; },16,,410,1,,void
102935,BLOCK,-1,,"{
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",25,,424,3,,void
102958,BLOCK,-1,,"{
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",32,,431,1,,void
102996,BLOCK,-1,,"{
      this->SetReturnValue(result);
    }",52,,450,2,,void
103009,BLOCK,-1,,"{
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }",71,,461,2,,void
103024,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",74,,469,5,,void
103052,BLOCK,1,,<empty>,,,,4,,void
103054,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,471,1,,void
103062,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,471,2,,void
103094,BLOCK,1,,<empty>,,,,4,,void
103096,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,475,1,,void
103104,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,475,2,,void
103128,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",66,,486,6,,void
103156,BLOCK,1,,<empty>,,,,4,,void
103158,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,488,1,,void
103166,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,488,2,,void
103194,BLOCK,-1,,<empty>,54,,496,2,,void
103198,BLOCK,-1,,"{
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",38,,498,1,,void
103204,BLOCK,-1,,"{
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    }",36,,499,2,,void
103215,BLOCK,-1,,"{
      return nullptr;
    }",12,,501,1,,void
103223,BLOCK,-1,,"{
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",64,,507,3,,void
103238,BLOCK,-1,,<empty>,5,,511,1,,void
103245,BLOCK,4,,"{
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }",29,,511,4,,void
103261,BLOCK,-1,,"{
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }",28,,515,2,,void
103278,BLOCK,-1,,<empty>,7,,518,1,,void
103285,BLOCK,4,,"{
        buffer[i] = undefined;
      }",41,,518,4,,void
103295,BLOCK,-1,,"{
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",50,,525,2,,void
103328,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
...",43,,536,7,,void
103331,BLOCK,1,,<empty>,,,,2,,void
103333,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103338,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103343,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103352,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103359,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103366,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103387,BLOCK,1,,<empty>,,,,3,,void
103389,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,538,1,,void
103395,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,538,2,,void
103437,BLOCK,1,,<empty>,,,,4,,void
103439,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,543,1,,void
103446,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,543,2,,void
103469,BLOCK,1,,<empty>,,,,3,,void
103471,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,547,1,,void
103493,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,547,2,,void
103507,BLOCK,-1,,"{
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
                                       0,
                                       v8impl::Ownership::kUserland,
                                       finalize_cb,
                                       native_object,
                                       finalize_hint);
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,553,2,,void
103511,BLOCK,1,,<empty>,,,,3,,void
103513,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,558,1,,void
103519,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,558,2,,void
103551,BLOCK,-1,,"{
    // Create a self-deleting reference.
    reference = v8impl::Reference::New(
        env,
        obj,
        0,
        v8impl::Ownership::kRuntime,
        finalize_cb,
        native_object,
        finalize_cb == nullptr ? nullptr : finalize_hint);
  }",10,,567,1,,void
103586,BLOCK,1,,<empty>,,,,2,,void
103611,BLOCK,1,,<empty>,,,,3,,void
103626,BLOCK,-1,,"{
  return value->IsObject() || value->IsSymbol();
}",57,,595,2,,void
103640,BLOCK,-1,,"{
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",34,,601,1,,void
103659,BLOCK,-1,,"{
  Link(finalize_callback == nullptr ? &env->reflist : &env->finalizing_reflist);
}",29,,616,7,,void
103676,BLOCK,-1,,"{
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",21,,622,1,,void
103692,BLOCK,-1,,"{
  return new RefBase(env,
                     initial_refcount,
                     ownership,
                     finalize_callback,
                     finalize_data,
                     finalize_hint);
}",44,,634,7,,void
103705,BLOCK,-1,,"{
  return finalize_data_;
}",23,,643,1,,void
103711,BLOCK,-1,,"{
  return ++refcount_;
}",25,,647,1,,void
103718,BLOCK,-1,,"{
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",27,,651,1,,void
103723,BLOCK,-1,,"{
    return 0;
  }",23,,652,2,,void
103732,BLOCK,-1,,"{
  return refcount_;
}",30,,658,1,,void
103738,BLOCK,-1,,"{
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime.
  if (ownership == Owne...",26,,662,1,,void
103761,BLOCK,-1,,"{
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }",37,,678,2,,void
103775,BLOCK,-1,,"{
    delete this;
  }",41,,685,2,,void
103784,BLOCK,-1,,"{
  if (RefCount() == 0) {
    SetWeak();
  }
}",44,,694,4,,void
103789,BLOCK,-1,,"{
    SetWeak();
  }",24,,695,2,,void
103794,BLOCK,-1,,"{
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",25,,700,1,,void
103809,BLOCK,-1,,"{
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",48,,711,8,,void
103823,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",27,,721,1,,void
103829,BLOCK,-1,,"{
    return 0;
  }",30,,724,2,,void
103845,BLOCK,-1,,"{
    persistent_.ClearWeak();
  }",38,,728,2,,void
103855,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",29,,734,1,,void
103861,BLOCK,-1,,"{
    return 0;
  }",30,,737,2,,void
103883,BLOCK,-1,,"{
    SetWeak();
  }",43,,742,2,,void
103890,BLOCK,-1,,"{
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",39,,748,1,,void
103896,BLOCK,-1,,"{
    return v8::Local<v8::Value>();
  }",30,,749,2,,void
103903,BLOCK,-1,,"{
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }",10,,751,1,,void
103924,BLOCK,-1,,"{
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",28,,756,1,,void
103936,BLOCK,-1,,"{
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",27,,767,1,,void
103939,BLOCK,-1,,"{
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",21,,768,2,,void
103952,BLOCK,-1,,"{
    persistent_.Reset();
  }",10,,770,1,,void
103961,BLOCK,-1,,"{
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",75,,778,2,,void
104015,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  // The value of the constant below must be updated to reference the last
  // message in the `napi_status` enum each time a new error message is added.
  // We don't have a napi_status_last as this would result in an ABI
  // change each time a message was added.
  const int last_status = napi_cannot_run_js;

  static_assert(NAPI_ARRAYSIZE(error_messages) == last_status + 1,
                ""Count of error messages must match count of error values"");
  CHECK_LE(env->last_error.error_code, last_status);
  // Wait until someone requests the last error information to fetch the error
  // message string
  env->last_error.error_message = error_messages[env->last_error.error_code];

  if (env->last_error.error_code == napi_ok) {
    napi_clear_last_error(env);
  }
  *result = &(env->last_error);
  return napi_ok;
}",60,,816,3,,void
104018,BLOCK,1,,<empty>,,,,2,,void
104020,BLOCK,-1,,CHECK_ENV(env),3,,817,1,,void
104025,BLOCK,-1,,CHECK_ENV(env),3,,817,2,,void
104032,BLOCK,1,,<empty>,,,,3,,void
104034,BLOCK,-1,,"CHECK_ARG(env, result)",3,,818,1,,void
104040,BLOCK,-1,,"CHECK_ARG(env, result)",3,,818,2,,void
104054,BLOCK,1,,<empty>,,,,3,,void
104092,BLOCK,-1,,"{
    napi_clear_last_error(env);
  }",46,,833,2,,void
104113,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, cb);

  v8::Local<v8::Function> return_value;
  v8::EscapableHandleScope scope(env->isolate);
  v8::Local<v8::Function> fn;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn));
  return_value = scope.Escape(fn);

  if (utf8name != nullptr) {
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }

  *result = v8impl::JsValueFromV8LocalValue(return_value);

  return GET_RETURN_STATUS(env);
}",65,,845,7,,void
104116,BLOCK,1,,<empty>,,,,2,,void
104118,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
104123,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
104128,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
104137,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
104144,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
104151,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
104172,BLOCK,1,,<empty>,,,,3,,void
104174,BLOCK,-1,,"CHECK_ARG(env, result)",3,,847,1,,void
104180,BLOCK,-1,,"CHECK_ARG(env, result)",3,,847,2,,void
104189,BLOCK,1,,<empty>,,,,3,,void
104191,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,848,1,,void
104197,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,848,2,,void
104228,BLOCK,1,,<empty>,,,,3,,void
104230,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn))",3,,853,1,,void
104249,BLOCK,-1,,<empty>,3,,853,2,,void
104264,BLOCK,-1,,"{
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }",28,,857,2,,void
104280,BLOCK,1,,<empty>,,,,7,,void
104282,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104292,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104302,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104309,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104315,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104343,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104351,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104380,BLOCK,1,,<empty>,,,,3,,void
104402,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, constructor);

  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Isolate* isolate = env->isolate;

  v8::EscapableHandleScope scope(isolate);
  v8::Local<v8::FunctionTemplate> tpl;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl));

  v8::Local<v8::String> name_string;
  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
  tpl->SetClassName(name_string);

  size_t static_property_count = 0;
  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAtt...",39,,876,9,,void
104405,BLOCK,1,,<empty>,,,,2,,void
104407,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104412,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104417,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104426,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104433,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104440,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104461,BLOCK,1,,<empty>,,,,3,,void
104463,BLOCK,-1,,"CHECK_ARG(env, result)",3,,878,1,,void
104469,BLOCK,-1,,"CHECK_ARG(env, result)",3,,878,2,,void
104478,BLOCK,1,,<empty>,,,,3,,void
104480,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,879,1,,void
104486,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,879,2,,void
104496,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,881,2,,void
104500,BLOCK,1,,<empty>,,,,3,,void
104502,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,882,1,,void
104508,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,882,2,,void
104534,BLOCK,1,,<empty>,,,,3,,void
104536,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl))",3,,889,1,,void
104555,BLOCK,-1,,<empty>,3,,889,2,,void
104574,BLOCK,1,,<empty>,,,,7,,void
104576,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104586,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104596,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104603,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104609,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104637,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104645,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104668,BLOCK,-1,,<empty>,3,,897,1,,void
104678,BLOCK,4,,"{
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAttributesFromDescriptor(p);

    // This code is similar to that in napi_define_properties(); the
    // difference is it applies to a template instead of an object,
    // and preferred PropertyAttribute for lack of PropertyDescriptor
    // support on ObjectTemplate.
    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (...",47,,897,4,,void
104693,BLOCK,-1,,"{
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }",45,,900,2,,void
104708,BLOCK,1,,<empty>,,,,4,,void
104710,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,907,1,,void
104726,BLOCK,-1,,<empty>,5,,907,2,,void
104750,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }

      tpl->PrototypeTemplate()->SetAccessorProperty(property_name,
                                                    getter_tpl,
                                                    setter_tpl,
                                                    attributes,
                                                    v8::AccessControl::DEFAULT);
    }",55,,916,2,,void
104775,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }",33,,919,2,,void
104778,BLOCK,1,,<empty>,,,,5,,void
104780,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl))",9,,920,1,,void
104803,BLOCK,-1,,<empty>,9,,920,2,,void
104813,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }",33,,923,2,,void
104816,BLOCK,1,,<empty>,,,,5,,void
104818,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl))",9,,924,1,,void
104841,BLOCK,-1,,<empty>,9,,924,2,,void
104862,BLOCK,-1,,<empty>,12,,933,1,,void
104869,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> t;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)));

      tpl->PrototypeTemplate()->Set(property_name, t, attributes);
    }",38,,933,2,,void
104881,BLOCK,1,,<empty>,,,,6,,void
104883,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)))",7,,935,1,,void
104914,BLOCK,-1,,<empty>,7,,935,2,,void
104929,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);
      tpl->PrototypeTemplate()->Set(property_name, value, attributes);
    }",12,,939,1,,void
104994,BLOCK,-1,,"{
    std::vector<napi_property_descriptor> static_descriptors;
    static_descriptors.reserve(static_property_count);

    for (size_t i = 0; i < property_count; i++) {
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }

    STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()));
  }",34,,949,2,,void
105002,BLOCK,-1,,<empty>,5,,953,1,,void
105012,BLOCK,4,,"{
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }",49,,953,4,,void
105027,BLOCK,-1,,"{
        static_descriptors.push_back(*p);
      }",47,,955,2,,void
105036,BLOCK,1,,<empty>,,,,5,,void
105038,BLOCK,-1,,"STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()))",5,,960,1,,void
105058,BLOCK,-1,,<empty>,5,,960,2,,void
105065,BLOCK,1,,<empty>,,,,3,,void
105082,BLOCK,-1,,"{
  return napi_get_all_property_names(
      env,
      object,
      napi_key_include_prototypes,
      static_cast<napi_key_filter>(napi_key_enumerable | napi_key_skip_symbols),
      napi_key_numbers_to_strings,
      result);
}",68,,969,4,,void
105104,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::PropertyFilter filter = v8::PropertyFilter::ALL_PROPERTIES;
  if (key_filter & napi_key_writable) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }
  if (key_filter & napi_key_enumerable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }
  if (key_filter & napi_key_configurable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }
  if (key_filter & napi_key_skip_strings) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }
  if (key_filter & napi_key_skip_symbols) {
    filter = static_cast<v8::PropertyFilter>(filte...",49,,985,7,,void
105107,BLOCK,1,,<empty>,,,,2,,void
105109,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
105114,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
105119,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
105128,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
105135,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
105142,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
105163,BLOCK,1,,<empty>,,,,3,,void
105165,BLOCK,-1,,"CHECK_ARG(env, result)",3,,987,1,,void
105171,BLOCK,-1,,"CHECK_ARG(env, result)",3,,987,2,,void
105206,BLOCK,1,,<empty>,,,,7,,void
105208,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
105210,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
105216,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,2,,void
105235,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
105243,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,2,,void
105268,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }",39,,994,2,,void
105284,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }",41,,998,2,,void
105300,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }",43,,1002,2,,void
105316,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }",43,,1006,2,,void
105332,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_SYMBOLS);
  }",43,,1010,2,,void
105348,BLOCK,-1,,"{
    case napi_key_include_prototypes:
      collection_mode = v8::KeyCollectionMode::kIncludePrototypes;
      break;
    case napi_key_own_only:
      collection_mode = v8::KeyCollectionMode::kOwnOnly;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",21,,1017,2,,void
105376,BLOCK,-1,,"{
    case napi_key_keep_numbers:
      conversion_mode = v8::KeyConversionMode::kKeepNumbers;
      break;
    case napi_key_numbers_to_strings:
      conversion_mode = v8::KeyConversionMode::kConvertToString;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",27,,1028,2,,void
105429,BLOCK,1,,<empty>,,,,5,,void
105431,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,1046,1,,void
105439,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,1046,2,,void
105465,BLOCK,1,,<empty>,,,,3,,void
105483,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",60,,1057,5,,void
105486,BLOCK,1,,<empty>,,,,2,,void
105488,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105493,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105498,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105507,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105514,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105521,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105542,BLOCK,1,,<empty>,,,,3,,void
105544,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1059,1,,void
105550,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1059,2,,void
105559,BLOCK,1,,<empty>,,,,3,,void
105561,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1060,1,,void
105567,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1060,2,,void
105602,BLOCK,1,,<empty>,,,,7,,void
105604,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105606,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105612,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,2,,void
105631,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105639,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,2,,void
105700,BLOCK,1,,<empty>,,,,5,,void
105702,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1072,1,,void
105710,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1072,2,,void
105719,BLOCK,1,,<empty>,,,,3,,void
105737,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Maybe<bool> has_maybe = obj->Has(context, k);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",56,,1079,5,,void
105740,BLOCK,1,,<empty>,,,,2,,void
105742,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105747,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105752,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105761,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105768,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105775,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105796,BLOCK,1,,<empty>,,,,3,,void
105798,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1081,1,,void
105804,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1081,2,,void
105813,BLOCK,1,,<empty>,,,,3,,void
105815,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1082,1,,void
105821,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1082,2,,void
105856,BLOCK,1,,<empty>,,,,7,,void
105858,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105860,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105866,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,2,,void
105885,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105893,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,2,,void
105934,BLOCK,1,,<empty>,,,,5,,void
105936,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1092,1,,void
105944,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1092,2,,void
105961,BLOCK,1,,<empty>,,,,3,,void
105979,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, k);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",62,,1101,5,,void
105982,BLOCK,1,,<empty>,,,,2,,void
105984,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
105989,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
105994,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
106003,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
106010,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
106017,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
106038,BLOCK,1,,<empty>,,,,3,,void
106040,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1103,1,,void
106046,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1103,2,,void
106055,BLOCK,1,,<empty>,,,,3,,void
106057,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1104,1,,void
106063,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1104,2,,void
106113,BLOCK,1,,<empty>,,,,7,,void
106115,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
106117,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
106123,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,2,,void
106142,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
106150,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,2,,void
106176,BLOCK,1,,<empty>,,,,5,,void
106178,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1114,1,,void
106186,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1114,2,,void
106217,BLOCK,1,,<empty>,,,,3,,void
106235,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",59,,1124,5,,void
106238,BLOCK,1,,<empty>,,,,2,,void
106240,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106245,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106250,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106259,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106266,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106273,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106294,BLOCK,1,,<empty>,,,,3,,void
106296,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1126,1,,void
106302,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1126,2,,void
106352,BLOCK,1,,<empty>,,,,7,,void
106354,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106356,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106362,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,2,,void
106381,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106389,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,2,,void
106415,BLOCK,1,,<empty>,,,,5,,void
106417,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1134,1,,void
106425,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1134,2,,void
106435,BLOCK,-1,,<empty>,26,,1136,2,,void
106447,BLOCK,1,,<empty>,,,,3,,void
106465,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);
  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());
  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);
  *result = has_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",60,,1144,5,,void
106468,BLOCK,1,,<empty>,,,,2,,void
106470,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106475,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106480,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106489,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106496,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106503,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106524,BLOCK,1,,<empty>,,,,3,,void
106526,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1146,1,,void
106532,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1146,2,,void
106541,BLOCK,1,,<empty>,,,,3,,void
106543,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1147,1,,void
106549,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1147,2,,void
106584,BLOCK,1,,<empty>,,,,7,,void
106586,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106588,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106594,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,2,,void
106613,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106621,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,2,,void
106656,BLOCK,1,,<empty>,,,,4,,void
106658,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1154,1,,void
106665,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1154,2,,void
106687,BLOCK,1,,<empty>,,,,5,,void
106689,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1156,1,,void
106697,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1156,2,,void
106714,BLOCK,1,,<empty>,,,,3,,void
106732,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",66,,1165,5,,void
106735,BLOCK,1,,<empty>,,,,2,,void
106737,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106742,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106747,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106756,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106763,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106770,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106791,BLOCK,1,,<empty>,,,,3,,void
106793,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1167,1,,void
106799,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1167,2,,void
106834,BLOCK,1,,<empty>,,,,7,,void
106836,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106838,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106844,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,2,,void
106863,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106871,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,2,,void
106898,BLOCK,1,,<empty>,,,,6,,void
106900,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106910,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106920,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
106927,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106933,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
106961,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106969,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
107015,BLOCK,1,,<empty>,,,,5,,void
107017,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1181,1,,void
107025,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1181,2,,void
107034,BLOCK,1,,<empty>,,,,3,,void
107052,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Maybe<bool> has_maybe = obj->Has(context, key);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",62,,1188,5,,void
107055,BLOCK,1,,<empty>,,,,2,,void
107057,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
107062,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
107067,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
107076,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
107083,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
107090,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
107111,BLOCK,1,,<empty>,,,,3,,void
107113,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1190,1,,void
107119,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1190,2,,void
107154,BLOCK,1,,<empty>,,,,7,,void
107156,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
107158,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
107164,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,2,,void
107183,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
107191,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,2,,void
107218,BLOCK,1,,<empty>,,,,6,,void
107220,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107230,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107240,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107247,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107253,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107281,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107289,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107315,BLOCK,1,,<empty>,,,,5,,void
107317,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1202,1,,void
107325,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1202,2,,void
107342,BLOCK,1,,<empty>,,,,3,,void
107360,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, key);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",68,,1211,5,,void
107363,BLOCK,1,,<empty>,,,,2,,void
107365,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107370,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107375,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107384,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107391,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107398,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107419,BLOCK,1,,<empty>,,,,3,,void
107421,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1213,1,,void
107427,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1213,2,,void
107461,BLOCK,1,,<empty>,,,,6,,void
107463,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107473,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107483,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107490,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107496,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107524,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107532,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107560,BLOCK,1,,<empty>,,,,7,,void
107562,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107564,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107570,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,2,,void
107589,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107597,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,2,,void
107623,BLOCK,1,,<empty>,,,,5,,void
107625,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1226,1,,void
107633,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1226,2,,void
107664,BLOCK,1,,<empty>,,,,3,,void
107682,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  auto set_maybe = obj->Set(context, index, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",59,,1236,5,,void
107685,BLOCK,1,,<empty>,,,,2,,void
107687,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107692,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107697,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107706,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107713,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107720,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107741,BLOCK,1,,<empty>,,,,3,,void
107743,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1238,1,,void
107749,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1238,2,,void
107784,BLOCK,1,,<empty>,,,,7,,void
107786,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107788,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107794,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,2,,void
107813,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107821,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,2,,void
107867,BLOCK,1,,<empty>,,,,5,,void
107869,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1248,1,,void
107877,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1248,2,,void
107886,BLOCK,1,,<empty>,,,,3,,void
107904,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> has_maybe = obj->Has(context, index);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",55,,1256,5,,void
107907,BLOCK,1,,<empty>,,,,2,,void
107909,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107914,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107919,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107928,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107935,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107942,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107963,BLOCK,1,,<empty>,,,,3,,void
107965,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1258,1,,void
107971,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1258,2,,void
108006,BLOCK,1,,<empty>,,,,7,,void
108008,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
108010,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
108016,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,2,,void
108035,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
108043,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,2,,void
108069,BLOCK,1,,<empty>,,,,5,,void
108071,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1267,1,,void
108079,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1267,2,,void
108096,BLOCK,1,,<empty>,,,,3,,void
108114,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, index);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",61,,1276,5,,void
108117,BLOCK,1,,<empty>,,,,2,,void
108119,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
108124,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
108129,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
108138,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
108145,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
108152,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
108173,BLOCK,1,,<empty>,,,,3,,void
108175,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1278,1,,void
108181,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1278,2,,void
108216,BLOCK,1,,<empty>,,,,7,,void
108218,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
108220,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
108226,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,2,,void
108245,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
108253,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,2,,void
108279,BLOCK,1,,<empty>,,,,5,,void
108281,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1287,1,,void
108289,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1287,2,,void
108309,BLOCK,1,,<empty>,,,,3,,void
108327,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",58,,1296,5,,void
108330,BLOCK,1,,<empty>,,,,2,,void
108332,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108337,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108342,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108351,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108358,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108365,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108412,BLOCK,1,,<empty>,,,,7,,void
108414,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108416,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108422,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,2,,void
108441,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108449,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,2,,void
108475,BLOCK,1,,<empty>,,,,5,,void
108477,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1304,1,,void
108485,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1304,2,,void
108495,BLOCK,-1,,<empty>,26,,1306,2,,void
108507,BLOCK,1,,<empty>,,,,3,,void
108525,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor....",68,,1315,5,,void
108528,BLOCK,1,,<empty>,,,,2,,void
108530,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108535,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108540,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108549,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108556,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108563,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108585,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,1317,2,,void
108589,BLOCK,1,,<empty>,,,,3,,void
108591,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1318,1,,void
108597,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1318,2,,void
108632,BLOCK,1,,<empty>,,,,7,,void
108634,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108636,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108642,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,2,,void
108661,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108669,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,2,,void
108683,BLOCK,-1,,<empty>,3,,1326,1,,void
108693,BLOCK,4,,"{
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(f...",47,,1326,4,,void
108712,BLOCK,1,,<empty>,,,,4,,void
108714,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,1330,1,,void
108730,BLOCK,-1,,<empty>,5,,1330,2,,void
108746,BLOCK,-1,,"{
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_invalid_arg);
      }
    }",55,,1332,2,,void
108771,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }",33,,1336,2,,void
108774,BLOCK,1,,<empty>,,,,5,,void
108776,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter))",9,,1337,1,,void
108799,BLOCK,-1,,<empty>,9,,1337,2,,void
108809,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }",33,,1340,2,,void
108812,BLOCK,1,,<empty>,,,,5,,void
108814,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter))",9,,1341,1,,void
108837,BLOCK,-1,,<empty>,9,,1341,2,,void
108884,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",43,,1352,2,,void
108890,BLOCK,-1,,<empty>,12,,1355,1,,void
108897,BLOCK,-1,,"{
      v8::Local<v8::Function> method;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method));
      v8::PropertyDescriptor descriptor(method,
                                        (p->attributes & napi_writable) != 0);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_generic_failure);
      }
    }",38,,1355,2,,void
108909,BLOCK,1,,<empty>,,,,5,,void
108911,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method))",7,,1357,1,,void
108934,BLOCK,-1,,<empty>,7,,1357,2,,void
108987,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_generic_failure);
      }",43,,1367,2,,void
108993,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);
      bool defined_successfully = false;

      if ((p->attributes & napi_enumerable) &&
          (p->attributes & napi_writable) &&
          (p->attributes & napi_configurable)) {
        // Use a fast path for this type of data property.
        auto define_maybe =
            obj->CreateDataProperty(context, property_name, value);
        defined_successfully = define_maybe.FromMaybe(false);
      } else {
        v8::PropertyDescriptor descriptor(value,
                                          (p->attributes & napi_writable) != 0);
        descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
        descriptor.set_configurable((p->attributes & napi_configurable) != 0);

        auto define_maybe =
            obj->DefineProperty(context, property_name, descriptor);
        defined_successfully = define_maybe.FromMaybe(false);
      }

      if (!defined_successfully) {
        return...",12,,1370,1,,void
109033,BLOCK,-1,,"{
        // Use a fast path for this type of data property.
        auto define_maybe =
            obj->CreateDataProperty(context, property_name, value);
        defined_successfully = define_maybe.FromMaybe(false);
      }",48,,1376,2,,void
109052,BLOCK,-1,,"{
        v8::PropertyDescriptor descriptor(value,
                                          (p->attributes & napi_writable) != 0);
        descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
        descriptor.set_configurable((p->attributes & napi_configurable) != 0);

        auto define_maybe =
            obj->DefineProperty(context, property_name, descriptor);
        defined_successfully = define_maybe.FromMaybe(false);
      }",14,,1381,1,,void
109105,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",34,,1392,2,,void
109113,BLOCK,1,,<empty>,,,,3,,void
109129,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_frozen =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,1401,3,,void
109132,BLOCK,1,,<empty>,,,,2,,void
109134,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
109139,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
109144,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
109153,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
109160,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
109167,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
109214,BLOCK,1,,<empty>,,,,7,,void
109216,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
109218,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
109224,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,2,,void
109243,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
109251,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,2,,void
109285,BLOCK,1,,<empty>,,,,6,,void
109287,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1412,1,,void
109295,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1412,2,,void
109310,BLOCK,1,,<empty>,,,,3,,void
109326,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_sealed =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kSealed);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",74,,1418,3,,void
109329,BLOCK,1,,<empty>,,,,2,,void
109331,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109336,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109341,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109350,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109357,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109364,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109411,BLOCK,1,,<empty>,,,,7,,void
109413,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109415,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109421,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,2,,void
109440,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109448,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,2,,void
109482,BLOCK,1,,<empty>,,,,6,,void
109484,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1429,1,,void
109492,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1429,2,,void
109507,BLOCK,1,,<empty>,,,,3,,void
109524,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  *result = val->IsArray();
  return napi_clear_last_error(env);
}",52,,1437,4,,void
109527,BLOCK,1,,<empty>,,,,2,,void
109529,BLOCK,-1,,CHECK_ENV(env),3,,1438,1,,void
109534,BLOCK,-1,,CHECK_ENV(env),3,,1438,2,,void
109541,BLOCK,1,,<empty>,,,,3,,void
109543,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1439,1,,void
109549,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1439,2,,void
109558,BLOCK,1,,<empty>,,,,3,,void
109560,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1440,1,,void
109566,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1440,2,,void
109603,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);

  v8::Local<v8::Array> arr = val.As<v8::Array>();
  *result = arr->Length();

  return GET_RETURN_STATUS(env);
}",64,,1450,4,,void
109606,BLOCK,1,,<empty>,,,,2,,void
109608,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109613,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109618,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109627,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109634,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109641,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109662,BLOCK,1,,<empty>,,,,3,,void
109664,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1452,1,,void
109670,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1452,2,,void
109679,BLOCK,1,,<empty>,,,,3,,void
109681,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,1,,void
109687,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,2,,void
109715,BLOCK,1,,<empty>,,,,4,,void
109717,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1456,1,,void
109724,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1456,2,,void
109754,BLOCK,1,,<empty>,,,,3,,void
109772,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, lhs);
  CHECK_ARG(env, rhs);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);
  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);

  *result = a->StrictEquals(b);
  return GET_RETURN_STATUS(env);
}",57,,1467,5,,void
109775,BLOCK,1,,<empty>,,,,2,,void
109777,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109782,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109787,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109796,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109803,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109810,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109831,BLOCK,1,,<empty>,,,,3,,void
109833,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1469,1,,void
109839,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1469,2,,void
109848,BLOCK,1,,<empty>,,,,3,,void
109850,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1470,1,,void
109856,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1470,2,,void
109865,BLOCK,1,,<empty>,,,,3,,void
109867,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1471,1,,void
109873,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1471,2,,void
109920,BLOCK,1,,<empty>,,,,3,,void
109937,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = obj->GetPrototype();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",63,,1482,4,,void
109940,BLOCK,1,,<empty>,,,,2,,void
109942,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109947,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109952,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109961,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109968,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109975,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109996,BLOCK,1,,<empty>,,,,3,,void
109998,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1484,1,,void
110004,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1484,2,,void
110039,BLOCK,1,,<empty>,,,,7,,void
110041,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
110043,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
110049,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,2,,void
110068,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
110076,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,2,,void
110114,BLOCK,1,,<empty>,,,,3,,void
110130,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Object::New(env->isolate));

  return napi_clear_last_error(env);
}",77,,1496,3,,void
110133,BLOCK,1,,<empty>,,,,2,,void
110135,BLOCK,-1,,CHECK_ENV(env),3,,1497,1,,void
110140,BLOCK,-1,,CHECK_ENV(env),3,,1497,2,,void
110147,BLOCK,1,,<empty>,,,,3,,void
110149,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1498,1,,void
110155,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1498,2,,void
110185,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate));

  return napi_clear_last_error(env);
}",76,,1505,3,,void
110188,BLOCK,1,,<empty>,,,,2,,void
110190,BLOCK,-1,,CHECK_ENV(env),3,,1506,1,,void
110195,BLOCK,-1,,CHECK_ENV(env),3,,1506,2,,void
110202,BLOCK,1,,<empty>,,,,3,,void
110204,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1507,1,,void
110210,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1507,2,,void
110241,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate, length));

  return napi_clear_last_error(env);
}",74,,1516,4,,void
110244,BLOCK,1,,<empty>,,,,2,,void
110246,BLOCK,-1,,CHECK_ENV(env),3,,1517,1,,void
110251,BLOCK,-1,,CHECK_ENV(env),3,,1517,2,,void
110258,BLOCK,1,,<empty>,,,,3,,void
110260,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1518,1,,void
110266,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1518,2,,void
110297,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",70,,1529,5,,void
110313,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  });
}",68,,1541,5,,void
110329,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",69,,1551,5,,void
110345,BLOCK,-1,,"{
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_latin1,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      });
}",54,,1567,8,,void
110365,BLOCK,-1,,"{
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_utf16,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      });
}",53,,1594,8,,void
110386,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Number::New(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1616,4,,void
110389,BLOCK,1,,<empty>,,,,2,,void
110391,BLOCK,-1,,CHECK_ENV(env),3,,1617,1,,void
110396,BLOCK,-1,,CHECK_ENV(env),3,,1617,2,,void
110403,BLOCK,1,,<empty>,,,,3,,void
110405,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1618,1,,void
110411,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1618,2,,void
110443,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Integer::New(env->isolate, value));

  return napi_clear_last_error(env);
}",62,,1628,4,,void
110446,BLOCK,1,,<empty>,,,,2,,void
110448,BLOCK,-1,,CHECK_ENV(env),3,,1629,1,,void
110453,BLOCK,-1,,CHECK_ENV(env),3,,1629,2,,void
110460,BLOCK,1,,<empty>,,,,3,,void
110462,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1630,1,,void
110468,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1630,2,,void
110500,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Integer::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1640,4,,void
110503,BLOCK,1,,<empty>,,,,2,,void
110505,BLOCK,-1,,CHECK_ENV(env),3,,1641,1,,void
110510,BLOCK,-1,,CHECK_ENV(env),3,,1641,2,,void
110517,BLOCK,1,,<empty>,,,,3,,void
110519,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1642,1,,void
110525,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1642,2,,void
110557,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Number::New(env->isolate, static_cast<double>(value)));

  return napi_clear_last_error(env);
}",62,,1652,4,,void
110560,BLOCK,1,,<empty>,,,,2,,void
110562,BLOCK,-1,,CHECK_ENV(env),3,,1653,1,,void
110567,BLOCK,-1,,CHECK_ENV(env),3,,1653,2,,void
110574,BLOCK,1,,<empty>,,,,3,,void
110576,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1654,1,,void
110582,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1654,2,,void
110616,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::BigInt::New(env->isolate, value));

  return napi_clear_last_error(env);
}",69,,1664,4,,void
110619,BLOCK,1,,<empty>,,,,2,,void
110621,BLOCK,-1,,CHECK_ENV(env),3,,1665,1,,void
110626,BLOCK,-1,,CHECK_ENV(env),3,,1665,2,,void
110633,BLOCK,1,,<empty>,,,,3,,void
110635,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1666,1,,void
110641,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1666,2,,void
110673,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::BigInt::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",70,,1676,4,,void
110676,BLOCK,1,,<empty>,,,,2,,void
110678,BLOCK,-1,,CHECK_ENV(env),3,,1677,1,,void
110683,BLOCK,-1,,CHECK_ENV(env),3,,1677,2,,void
110690,BLOCK,1,,<empty>,,,,3,,void
110692,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1678,1,,void
110698,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1678,2,,void
110732,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, words);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg);

  v8::MaybeLocal<v8::BigInt> b =
      v8::BigInt::NewFromWords(context, sign_bit, word_count, words);

  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",69,,1690,6,,void
110735,BLOCK,1,,<empty>,,,,2,,void
110737,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110742,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110747,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110756,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110763,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110770,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110791,BLOCK,1,,<empty>,,,,3,,void
110793,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1692,1,,void
110799,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1692,2,,void
110808,BLOCK,1,,<empty>,,,,3,,void
110810,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1693,1,,void
110816,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1693,2,,void
110839,BLOCK,1,,<empty>,,,,3,,void
110841,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1697,1,,void
110847,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1697,2,,void
110877,BLOCK,1,,<empty>,,,,5,,void
110879,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1702,1,,void
110887,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1702,2,,void
110913,BLOCK,1,,<empty>,,,,3,,void
110930,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (value) {
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  } else {
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }

  return napi_clear_last_error(env);
}",61,,1710,4,,void
110933,BLOCK,1,,<empty>,,,,2,,void
110935,BLOCK,-1,,CHECK_ENV(env),3,,1711,1,,void
110940,BLOCK,-1,,CHECK_ENV(env),3,,1711,2,,void
110947,BLOCK,1,,<empty>,,,,3,,void
110949,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1712,1,,void
110955,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1712,2,,void
110969,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  }",14,,1716,2,,void
110983,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }",10,,1718,1,,void
111005,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (description == nullptr) {
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  } else {
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }

  return napi_clear_last_error(env);
}",63,,1727,4,,void
111008,BLOCK,1,,<empty>,,,,2,,void
111010,BLOCK,-1,,CHECK_ENV(env),3,,1728,1,,void
111015,BLOCK,-1,,CHECK_ENV(env),3,,1728,2,,void
111022,BLOCK,1,,<empty>,,,,3,,void
111024,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1729,1,,void
111030,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1729,2,,void
111046,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  }",31,,1733,2,,void
111062,BLOCK,-1,,"{
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }",10,,1735,1,,void
111085,BLOCK,1,,<empty>,,,,4,,void
111087,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1737,1,,void
111094,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1737,2,,void
111128,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",64,,1749,5,,void
111131,BLOCK,1,,<empty>,,,,2,,void
111133,BLOCK,-1,,CHECK_ENV(env),3,,1750,1,,void
111138,BLOCK,-1,,CHECK_ENV(env),3,,1750,2,,void
111145,BLOCK,1,,<empty>,,,,3,,void
111147,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,1,,void
111153,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,2,,void
111162,BLOCK,1,,<empty>,,,,4,,void
111164,BLOCK,-1,,"STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string))",3,,1754,1,,void
111178,BLOCK,-1,,<empty>,3,,1754,2,,void
111227,BLOCK,-1,,"{
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }
  return napi_ok;
}",68,,1768,5,,void
111236,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }",55,,1769,2,,void
111284,BLOCK,-1,,"{
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    }",26,,1774,2,,void
111299,BLOCK,1,,<empty>,,,,4,,void
111301,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1776,1,,void
111308,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1776,2,,void
111315,BLOCK,-1,,"{
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }",12,,1777,1,,void
111321,BLOCK,1,,<empty>,,,,6,,void
111323,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111333,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111343,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111350,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111356,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111384,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111392,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111419,BLOCK,1,,<empty>,,,,6,,void
111421,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111431,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111441,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111448,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111454,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111482,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111490,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111521,BLOCK,1,,<empty>,,,,5,,void
111523,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1785,1,,void
111531,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1785,2,,void
111546,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::Error(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",62,,1794,5,,void
111549,BLOCK,1,,<empty>,,,,2,,void
111551,BLOCK,-1,,CHECK_ENV(env),3,,1795,1,,void
111556,BLOCK,-1,,CHECK_ENV(env),3,,1795,2,,void
111563,BLOCK,1,,<empty>,,,,3,,void
111565,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1796,1,,void
111571,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1796,2,,void
111580,BLOCK,1,,<empty>,,,,3,,void
111582,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1797,1,,void
111588,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1797,2,,void
111616,BLOCK,1,,<empty>,,,,4,,void
111618,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1800,1,,void
111625,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1800,2,,void
111653,BLOCK,1,,<empty>,,,,3,,void
111655,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1804,1,,void
111668,BLOCK,-1,,<empty>,3,,1804,2,,void
111690,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::TypeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",67,,1814,5,,void
111693,BLOCK,1,,<empty>,,,,2,,void
111695,BLOCK,-1,,CHECK_ENV(env),3,,1815,1,,void
111700,BLOCK,-1,,CHECK_ENV(env),3,,1815,2,,void
111707,BLOCK,1,,<empty>,,,,3,,void
111709,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1816,1,,void
111715,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1816,2,,void
111724,BLOCK,1,,<empty>,,,,3,,void
111726,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1817,1,,void
111732,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1817,2,,void
111760,BLOCK,1,,<empty>,,,,4,,void
111762,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1820,1,,void
111769,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1820,2,,void
111797,BLOCK,1,,<empty>,,,,3,,void
111799,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1824,1,,void
111812,BLOCK,-1,,<empty>,3,,1824,2,,void
111834,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::RangeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",68,,1834,5,,void
111837,BLOCK,1,,<empty>,,,,2,,void
111839,BLOCK,-1,,CHECK_ENV(env),3,,1835,1,,void
111844,BLOCK,-1,,CHECK_ENV(env),3,,1835,2,,void
111851,BLOCK,1,,<empty>,,,,3,,void
111853,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1836,1,,void
111859,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1836,2,,void
111868,BLOCK,1,,<empty>,,,,3,,void
111870,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1837,1,,void
111876,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1837,2,,void
111904,BLOCK,1,,<empty>,,,,4,,void
111906,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1840,1,,void
111913,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1840,2,,void
111941,BLOCK,1,,<empty>,,,,3,,void
111943,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1844,1,,void
111956,BLOCK,-1,,<empty>,3,,1844,2,,void
111978,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",73,,1854,5,,void
111981,BLOCK,1,,<empty>,,,,2,,void
111983,BLOCK,-1,,CHECK_ENV(env),3,,1855,1,,void
111988,BLOCK,-1,,CHECK_ENV(env),3,,1855,2,,void
111995,BLOCK,1,,<empty>,,,,3,,void
111997,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1856,1,,void
112003,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1856,2,,void
112012,BLOCK,1,,<empty>,,,,3,,void
112014,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1857,1,,void
112020,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1857,2,,void
112048,BLOCK,1,,<empty>,,,,4,,void
112050,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1860,1,,void
112057,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1860,2,,void
112085,BLOCK,1,,<empty>,,,,3,,void
112087,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1864,1,,void
112100,BLOCK,-1,,<empty>,3,,1864,2,,void
112121,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);

  if (v->IsNumber()) {
    *result = napi_number;
  } else if (v->IsBigInt()) {
    *result = napi_bigint;
  } else if (v->IsString()) {
    *result = napi_string;
  } else if (v->IsFunction()) {
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  } else if (v->IsExternal()) {
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  } else if (v->IsObject()) {
    *result = napi_object;
  } else if (v->IsBoolean()) {
    *result = napi_boolean;
  } else if (v->IsUndefined()) {
    *result = napi_undefined;
  } else if (v->IsSymbol()) {
    *result = napi_symbol;
  } else if (v->IsNull()) {
    *result = napi_null;
  } e...",60,,1873,4,,void
112124,BLOCK,1,,<empty>,,,,2,,void
112126,BLOCK,-1,,CHECK_ENV(env),3,,1876,1,,void
112131,BLOCK,-1,,CHECK_ENV(env),3,,1876,2,,void
112138,BLOCK,1,,<empty>,,,,3,,void
112140,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1877,1,,void
112146,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1877,2,,void
112155,BLOCK,1,,<empty>,,,,3,,void
112157,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1878,1,,void
112163,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1878,2,,void
112189,BLOCK,-1,,"{
    *result = napi_number;
  }",22,,1882,2,,void
112195,BLOCK,-1,,<empty>,10,,1884,1,,void
112201,BLOCK,-1,,"{
    *result = napi_bigint;
  }",29,,1884,2,,void
112207,BLOCK,-1,,<empty>,10,,1886,1,,void
112213,BLOCK,-1,,"{
    *result = napi_string;
  }",29,,1886,2,,void
112219,BLOCK,-1,,<empty>,10,,1888,1,,void
112225,BLOCK,-1,,"{
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  }",31,,1888,2,,void
112231,BLOCK,-1,,<empty>,10,,1892,1,,void
112237,BLOCK,-1,,"{
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  }",31,,1892,2,,void
112243,BLOCK,-1,,<empty>,10,,1896,1,,void
112249,BLOCK,-1,,"{
    *result = napi_object;
  }",29,,1896,2,,void
112255,BLOCK,-1,,<empty>,10,,1898,1,,void
112261,BLOCK,-1,,"{
    *result = napi_boolean;
  }",30,,1898,2,,void
112267,BLOCK,-1,,<empty>,10,,1900,1,,void
112273,BLOCK,-1,,"{
    *result = napi_undefined;
  }",32,,1900,2,,void
112279,BLOCK,-1,,<empty>,10,,1902,1,,void
112285,BLOCK,-1,,"{
    *result = napi_symbol;
  }",29,,1902,2,,void
112291,BLOCK,-1,,<empty>,10,,1904,1,,void
112297,BLOCK,-1,,"{
    *result = napi_null;
  }",27,,1904,2,,void
112303,BLOCK,-1,,"{
    // Should not get here unless V8 has added some new kind of value.
    return napi_set_last_error(env, napi_invalid_arg);
  }",10,,1906,1,,void
112316,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",77,,1914,3,,void
112319,BLOCK,1,,<empty>,,,,2,,void
112321,BLOCK,-1,,CHECK_ENV(env),3,,1915,1,,void
112326,BLOCK,-1,,CHECK_ENV(env),3,,1915,2,,void
112333,BLOCK,1,,<empty>,,,,3,,void
112335,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1916,1,,void
112341,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1916,2,,void
112369,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Null(env->isolate));

  return napi_clear_last_error(env);
}",72,,1923,3,,void
112372,BLOCK,1,,<empty>,,,,2,,void
112374,BLOCK,-1,,CHECK_ENV(env),3,,1924,1,,void
112379,BLOCK,-1,,CHECK_ENV(env),3,,1924,2,,void
112386,BLOCK,1,,<empty>,,,,3,,void
112388,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1925,1,,void
112394,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1925,2,,void
112426,BLOCK,-1,,"{         // [out] Receives the data pointer for the callback.
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  if (argv != nullptr) {
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }
  if (argc != nullptr) {
    *argc = info->ArgsLength();
  }
  if (this_arg != nullptr) {
    *this_arg = info->This();
  }
  if (data != nullptr) {
    *data = info->Data();
  }

  return napi_clear_last_error(env);
}",18,,1940,7,,void
112429,BLOCK,1,,<empty>,,,,2,,void
112431,BLOCK,-1,,CHECK_ENV(env),3,,1941,1,,void
112436,BLOCK,-1,,CHECK_ENV(env),3,,1941,2,,void
112443,BLOCK,1,,<empty>,,,,3,,void
112445,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1942,1,,void
112451,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1942,2,,void
112467,BLOCK,-1,,"{
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }",24,,1947,2,,void
112471,BLOCK,1,,<empty>,,,,3,,void
112473,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1948,1,,void
112479,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1948,2,,void
112496,BLOCK,-1,,"{
    *argc = info->ArgsLength();
  }",24,,1951,2,,void
112508,BLOCK,-1,,"{
    *this_arg = info->This();
  }",28,,1954,2,,void
112520,BLOCK,-1,,"{
    *data = info->Data();
  }",24,,1957,2,,void
112537,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);
  CHECK_ARG(env, result);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  *result = info->GetNewTarget();
  return napi_clear_last_error(env);
}",64,,1966,4,,void
112540,BLOCK,1,,<empty>,,,,2,,void
112542,BLOCK,-1,,CHECK_ENV(env),3,,1967,1,,void
112547,BLOCK,-1,,CHECK_ENV(env),3,,1967,2,,void
112554,BLOCK,1,,<empty>,,,,3,,void
112556,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1968,1,,void
112562,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1968,2,,void
112571,BLOCK,1,,<empty>,,,,3,,void
112573,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1969,1,,void
112579,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1969,2,,void
112610,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }
}",63,,1983,7,,void
112613,BLOCK,1,,<empty>,,,,2,,void
112615,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112620,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112625,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112634,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112641,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112648,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112669,BLOCK,1,,<empty>,,,,3,,void
112671,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1985,1,,void
112677,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1985,2,,void
112687,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,1986,2,,void
112691,BLOCK,1,,<empty>,,,,3,,void
112693,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1987,1,,void
112699,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1987,2,,void
112747,BLOCK,1,,<empty>,,,,4,,void
112749,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112751,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112757,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,2,,void
112779,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112786,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,2,,void
112819,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,2003,2,,void
112825,BLOCK,-1,,"{
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }",10,,2005,1,,void
112830,BLOCK,-1,,"{
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }",28,,2006,2,,void
112835,BLOCK,1,,<empty>,,,,5,,void
112837,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,2007,1,,void
112845,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,2007,2,,void
112870,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());

  return napi_clear_last_error(env);
}",74,,2014,3,,void
112873,BLOCK,1,,<empty>,,,,2,,void
112875,BLOCK,-1,,CHECK_ENV(env),3,,2015,1,,void
112880,BLOCK,-1,,CHECK_ENV(env),3,,2015,2,,void
112887,BLOCK,1,,<empty>,,,,3,,void
112889,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2016,1,,void
112895,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2016,2,,void
112923,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, error);

  v8::Isolate* isolate = env->isolate;

  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",67,,2023,3,,void
112926,BLOCK,1,,<empty>,,,,2,,void
112928,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112933,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112938,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112947,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112954,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112961,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112982,BLOCK,1,,<empty>,,,,3,,void
112984,BLOCK,-1,,"CHECK_ARG(env, error)",3,,2025,1,,void
112990,BLOCK,-1,,"CHECK_ARG(env, error)",3,,2025,2,,void
113020,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",58,,2037,4,,void
113023,BLOCK,1,,<empty>,,,,2,,void
113025,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
113030,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
113035,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
113044,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
113051,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
113058,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
113096,BLOCK,1,,<empty>,,,,6,,void
113098,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
113108,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
113118,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
113125,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
113131,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
113159,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
113167,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
113199,BLOCK,1,,<empty>,,,,3,,void
113201,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2045,1,,void
113214,BLOCK,-1,,<empty>,3,,2045,2,,void
113232,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",63,,2055,4,,void
113235,BLOCK,1,,<empty>,,,,2,,void
113237,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113242,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113247,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113256,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113263,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113270,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113308,BLOCK,1,,<empty>,,,,6,,void
113310,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113320,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113330,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113337,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113343,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113371,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113379,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113411,BLOCK,1,,<empty>,,,,3,,void
113413,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2063,1,,void
113426,BLOCK,-1,,<empty>,3,,2063,2,,void
113444,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",64,,2073,4,,void
113447,BLOCK,1,,<empty>,,,,2,,void
113449,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113454,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113459,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113468,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113475,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113482,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113520,BLOCK,1,,<empty>,,,,6,,void
113522,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113532,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113542,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113549,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113555,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113583,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113591,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113623,BLOCK,1,,<empty>,,,,3,,void
113625,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2081,1,,void
113638,BLOCK,-1,,<empty>,3,,2081,2,,void
113656,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",69,,2091,4,,void
113659,BLOCK,1,,<empty>,,,,2,,void
113661,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113666,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113671,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113680,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113687,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113694,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113732,BLOCK,1,,<empty>,,,,6,,void
113734,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113744,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113754,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113761,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113767,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113795,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113803,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113835,BLOCK,1,,<empty>,,,,3,,void
113837,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2099,1,,void
113850,BLOCK,-1,,<empty>,3,,2099,2,,void
113868,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot
  // throw JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsNativeError();

  return napi_clear_last_error(env);
}",52,,2109,4,,void
113871,BLOCK,1,,<empty>,,,,2,,void
113873,BLOCK,-1,,CHECK_ENV(env),3,,2112,1,,void
113878,BLOCK,-1,,CHECK_ENV(env),3,,2112,2,,void
113885,BLOCK,1,,<empty>,,,,3,,void
113887,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2113,1,,void
113893,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2113,2,,void
113902,BLOCK,1,,<empty>,,,,3,,void
113904,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2114,1,,void
113910,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2114,2,,void
113947,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  *result = val.As<v8::Number>()->Value();

  return napi_clear_last_error(env);
}",62,,2124,4,,void
113950,BLOCK,1,,<empty>,,,,2,,void
113952,BLOCK,-1,,CHECK_ENV(env),3,,2127,1,,void
113957,BLOCK,-1,,CHECK_ENV(env),3,,2127,2,,void
113964,BLOCK,1,,<empty>,,,,3,,void
113966,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,1,,void
113972,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,2,,void
113981,BLOCK,1,,<empty>,,,,3,,void
113983,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,1,,void
113989,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,2,,void
114017,BLOCK,1,,<empty>,,,,4,,void
114019,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2132,1,,void
114026,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2132,2,,void
114051,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",62,,2141,4,,void
114054,BLOCK,1,,<empty>,,,,2,,void
114056,BLOCK,-1,,CHECK_ENV(env),3,,2144,1,,void
114061,BLOCK,-1,,CHECK_ENV(env),3,,2144,2,,void
114068,BLOCK,1,,<empty>,,,,3,,void
114070,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2145,1,,void
114076,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2145,2,,void
114085,BLOCK,1,,<empty>,,,,3,,void
114087,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2146,1,,void
114093,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2146,2,,void
114119,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
  }",23,,2150,2,,void
114131,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }",10,,2152,1,,void
114139,BLOCK,1,,<empty>,,,,4,,void
114141,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2153,1,,void
114148,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2153,2,,void
114183,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsUint32()) {
    *result = val.As<v8::Uint32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",64,,2165,4,,void
114186,BLOCK,1,,<empty>,,,,2,,void
114188,BLOCK,-1,,CHECK_ENV(env),3,,2168,1,,void
114193,BLOCK,-1,,CHECK_ENV(env),3,,2168,2,,void
114200,BLOCK,1,,<empty>,,,,3,,void
114202,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2169,1,,void
114208,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2169,2,,void
114217,BLOCK,1,,<empty>,,,,3,,void
114219,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2170,1,,void
114225,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2170,2,,void
114251,BLOCK,-1,,"{
    *result = val.As<v8::Uint32>()->Value();
  }",24,,2174,2,,void
114263,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }",10,,2176,1,,void
114271,BLOCK,1,,<empty>,,,,4,,void
114273,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2177,1,,void
114280,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2177,2,,void
114315,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  // This is still a fast path very likely to be taken.
  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }

  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,
  // inconsistent with v8::Value::Int32Value() which converts those values to 0.
  // Special-case all non-finite values to match that behavior.
  double doubleValue = val.As<v8::Number>()->Value();
  if (std::isfinite(doubleValue)) {
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  } else {
    *result = 0;
  }

  return napi_clea...",62,,2189,4,,void
114318,BLOCK,1,,<empty>,,,,2,,void
114320,BLOCK,-1,,CHECK_ENV(env),3,,2192,1,,void
114325,BLOCK,-1,,CHECK_ENV(env),3,,2192,2,,void
114332,BLOCK,1,,<empty>,,,,3,,void
114334,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2193,1,,void
114340,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2193,2,,void
114349,BLOCK,1,,<empty>,,,,3,,void
114351,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2194,1,,void
114357,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2194,2,,void
114383,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }",23,,2199,2,,void
114404,BLOCK,1,,<empty>,,,,4,,void
114406,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2204,1,,void
114413,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2204,2,,void
114435,BLOCK,-1,,"{
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  }",35,,2210,2,,void
114457,BLOCK,-1,,"{
    *result = 0;
  }",10,,2214,1,,void
114472,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Int64Value(lossless);

  return napi_clear_last_error(env);
}",68,,2224,5,,void
114475,BLOCK,1,,<empty>,,,,2,,void
114477,BLOCK,-1,,CHECK_ENV(env),3,,2225,1,,void
114482,BLOCK,-1,,CHECK_ENV(env),3,,2225,2,,void
114489,BLOCK,1,,<empty>,,,,3,,void
114491,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2226,1,,void
114497,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2226,2,,void
114506,BLOCK,1,,<empty>,,,,3,,void
114508,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2227,1,,void
114514,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2227,2,,void
114523,BLOCK,1,,<empty>,,,,3,,void
114525,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2228,1,,void
114531,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2228,2,,void
114559,BLOCK,1,,<empty>,,,,4,,void
114561,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2232,1,,void
114568,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2232,2,,void
114595,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Uint64Value(lossless);

  return napi_clear_last_error(env);
}",69,,2242,5,,void
114598,BLOCK,1,,<empty>,,,,2,,void
114600,BLOCK,-1,,CHECK_ENV(env),3,,2243,1,,void
114605,BLOCK,-1,,CHECK_ENV(env),3,,2243,2,,void
114612,BLOCK,1,,<empty>,,,,3,,void
114614,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2244,1,,void
114620,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2244,2,,void
114629,BLOCK,1,,<empty>,,,,3,,void
114631,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2245,1,,void
114637,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2245,2,,void
114646,BLOCK,1,,<empty>,,,,3,,void
114648,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2246,1,,void
114654,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2246,2,,void
114682,BLOCK,1,,<empty>,,,,4,,void
114684,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2250,1,,void
114691,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2250,2,,void
114719,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, word_count);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();

  int word_count_int = *word_count;

  if (sign_bit == nullptr && words == nullptr) {
    word_count_int = big->WordCount();
  } else {
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }

  *word_count = word_count_int;

  return napi_clear_last_error(env);
}",69,,2261,6,,void
114722,BLOCK,1,,<empty>,,,,2,,void
114724,BLOCK,-1,,CHECK_ENV(env),3,,2262,1,,void
114729,BLOCK,-1,,CHECK_ENV(env),3,,2262,2,,void
114736,BLOCK,1,,<empty>,,,,3,,void
114738,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2263,1,,void
114744,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2263,2,,void
114753,BLOCK,1,,<empty>,,,,3,,void
114755,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2264,1,,void
114761,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2264,2,,void
114789,BLOCK,1,,<empty>,,,,4,,void
114791,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2268,1,,void
114798,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2268,2,,void
114831,BLOCK,-1,,"{
    word_count_int = big->WordCount();
  }",48,,2274,2,,void
114839,BLOCK,-1,,"{
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }",10,,2276,1,,void
114843,BLOCK,1,,<empty>,,,,3,,void
114845,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2277,1,,void
114851,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2277,2,,void
114860,BLOCK,1,,<empty>,,,,3,,void
114862,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2278,1,,void
114868,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2278,2,,void
114895,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);

  *result = val.As<v8::Boolean>()->Value();

  return napi_clear_last_error(env);
}",58,,2289,4,,void
114898,BLOCK,1,,<empty>,,,,2,,void
114900,BLOCK,-1,,CHECK_ENV(env),3,,2292,1,,void
114905,BLOCK,-1,,CHECK_ENV(env),3,,2292,2,,void
114912,BLOCK,1,,<empty>,,,,3,,void
114914,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2293,1,,void
114920,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2293,2,,void
114929,BLOCK,1,,<empty>,,,,3,,void
114931,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2294,1,,void
114937,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2294,2,,void
114965,BLOCK,1,,<empty>,,,,4,,void
114967,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2297,1,,void
114974,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2297,2,,void
115001,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2313,6,,void
115004,BLOCK,1,,<empty>,,,,2,,void
115006,BLOCK,-1,,CHECK_ENV(env),3,,2314,1,,void
115011,BLOCK,-1,,CHECK_ENV(env),3,,2314,2,,void
115018,BLOCK,1,,<empty>,,,,3,,void
115020,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2315,1,,void
115026,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2315,2,,void
115054,BLOCK,1,,<empty>,,,,4,,void
115056,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2318,1,,void
115063,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2318,2,,void
115072,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  }",13,,2320,2,,void
115076,BLOCK,1,,<empty>,,,,3,,void
115078,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2321,1,,void
115084,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2321,2,,void
115101,BLOCK,-1,,<empty>,10,,2323,1,,void
115106,BLOCK,-1,,"{
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2323,2,,void
115141,BLOCK,-1,,"{
      *result = copied;
    }",28,,2332,2,,void
115147,BLOCK,-1,,<empty>,10,,2335,1,,void
115152,BLOCK,-1,,"{
    *result = 0;
  }",33,,2335,2,,void
115168,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2351,6,,void
115171,BLOCK,1,,<empty>,,,,2,,void
115173,BLOCK,-1,,CHECK_ENV(env),3,,2352,1,,void
115178,BLOCK,-1,,CHECK_ENV(env),3,,2352,2,,void
115185,BLOCK,1,,<empty>,,,,3,,void
115187,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2353,1,,void
115193,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2353,2,,void
115221,BLOCK,1,,<empty>,,,,4,,void
115223,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2356,1,,void
115230,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2356,2,,void
115239,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  }",13,,2358,2,,void
115243,BLOCK,1,,<empty>,,,,3,,void
115245,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2359,1,,void
115251,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2359,2,,void
115271,BLOCK,-1,,<empty>,10,,2361,1,,void
115276,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2361,2,,void
115315,BLOCK,-1,,"{
      *result = copied;
    }",28,,2370,2,,void
115321,BLOCK,-1,,<empty>,10,,2373,1,,void
115326,BLOCK,-1,,"{
    *result = 0;
  }",33,,2373,2,,void
115342,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",68,,2392,6,,void
115345,BLOCK,1,,<empty>,,,,2,,void
115347,BLOCK,-1,,CHECK_ENV(env),3,,2393,1,,void
115352,BLOCK,-1,,CHECK_ENV(env),3,,2393,2,,void
115359,BLOCK,1,,<empty>,,,,3,,void
115361,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2394,1,,void
115367,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2394,2,,void
115395,BLOCK,1,,<empty>,,,,4,,void
115397,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2397,1,,void
115404,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2397,2,,void
115413,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  }",13,,2399,2,,void
115417,BLOCK,1,,<empty>,,,,3,,void
115419,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2400,1,,void
115425,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2400,2,,void
115442,BLOCK,-1,,<empty>,10,,2403,1,,void
115447,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2403,2,,void
115482,BLOCK,-1,,"{
      *result = copied;
    }",28,,2411,2,,void
115488,BLOCK,-1,,<empty>,10,,2414,1,,void
115493,BLOCK,-1,,"{
    *result = 0;
  }",33,,2414,2,,void
115507,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Boolean> b =
      v8impl::V8LocalValueFromJsValue(value)->ToBoolean(isolate);
  *result = v8impl::JsValueFromV8LocalValue(b);
  return GET_RETURN_STATUS(env);
}",64,,2423,4,,void
115510,BLOCK,1,,<empty>,,,,2,,void
115512,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115517,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115522,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115531,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115538,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115545,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115566,BLOCK,1,,<empty>,,,,3,,void
115568,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2425,1,,void
115574,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2425,2,,void
115583,BLOCK,1,,<empty>,,,,3,,void
115585,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2426,1,,void
115591,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2426,2,,void
115633,BLOCK,1,,<empty>,,,,3,,void
115650,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,4,,void
115652,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115657,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115662,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115671,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115678,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115685,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115704,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115710,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115717,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115723,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115753,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115755,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115761,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115780,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115788,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115826,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,4,,void
115828,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115833,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115838,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115847,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115854,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115861,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115880,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115886,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115893,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115899,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115929,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115931,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115937,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115956,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115964,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
116002,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,4,,void
116004,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116009,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116014,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116023,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116030,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116037,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116056,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116062,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116069,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116075,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116105,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116107,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116113,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116132,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
116140,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
116181,BLOCK,-1,,"{
  return v8impl::Wrap(
      env, js_object, native_object, finalize_cb, finalize_hint, result);
}",52,,2462,7,,void
116199,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);
}",51,,2469,4,,void
116217,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);
}",56,,2475,4,,void
116237,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);

  if (finalize_cb) {
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }

  *result = v8impl::JsValueFromV8LocalValue(external_value);

  return napi_clear_last_error(env);
}",65,,2483,6,,void
116240,BLOCK,1,,<empty>,,,,2,,void
116242,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116247,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116252,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116261,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116268,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116275,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116296,BLOCK,1,,<empty>,,,,3,,void
116298,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2485,1,,void
116304,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2485,2,,void
116336,BLOCK,-1,,"{
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }",20,,2491,2,,void
116371,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);

  auto key = NAPI_PRIVATE_KEY(context, type_tag);
  auto maybe_has = obj->HasPrivate(context, key);
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg);

  auto tag = v8::BigInt::NewFromWords(
      context, 0, 2, reinterpret_cast<const uint64_t*>(type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure);

  auto maybe_set = obj->SetPrivate(context, key, tag.ToLocalChecked());
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,2510,4,,void
116374,BLOCK,1,,<empty>,,,,2,,void
116376,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116381,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116386,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116395,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116402,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116409,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116456,BLOCK,1,,<empty>,,,,9,,void
116458,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116460,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116466,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,2,,void
116491,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116499,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,2,,void
116521,BLOCK,1,,<empty>,,,,4,,void
116523,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2515,1,,void
116529,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2515,2,,void
116546,BLOCK,1,,<empty>,,,,2,,void
116570,BLOCK,1,,<empty>,,,,6,,void
116572,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2519,1,,void
116580,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2519,2,,void
116600,BLOCK,1,,<empty>,,,,6,,void
116602,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2520,1,,void
116610,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2520,2,,void
116641,BLOCK,1,,<empty>,,,,6,,void
116643,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2525,1,,void
116651,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2525,2,,void
116680,BLOCK,1,,<empty>,,,,6,,void
116682,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2528,1,,void
116690,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2528,2,,void
116709,BLOCK,1,,<empty>,,,,6,,void
116711,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2529,1,,void
116718,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2529,2,,void
116733,BLOCK,1,,<empty>,,,,3,,void
116751,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);
  CHECK_ARG_WITH_PREAMBLE(env, result);

  auto maybe_value =
      obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure);
  v8::Local<v8::Value> val = maybe_value.ToLocalChecked();

  // We consider the type check to have failed unless we reach the line below
  // where we set whether the type check succeeded or not based on the
  // comparison of the two type tags.
  *result = false;
  if (val->IsBigInt()) {
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
   ...",65,,2538,5,,void
116754,BLOCK,1,,<empty>,,,,2,,void
116756,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116761,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116766,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116775,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116782,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116789,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116836,BLOCK,1,,<empty>,,,,9,,void
116838,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116840,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116846,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,2,,void
116871,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116879,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,2,,void
116901,BLOCK,1,,<empty>,,,,4,,void
116903,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2543,1,,void
116909,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2543,2,,void
116924,BLOCK,1,,<empty>,,,,4,,void
116926,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2544,1,,void
116932,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2544,2,,void
116954,BLOCK,1,,<empty>,,,,2,,void
116969,BLOCK,1,,<empty>,,,,6,,void
116971,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2548,1,,void
116979,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2548,2,,void
117014,BLOCK,-1,,"{
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }
  }",24,,2555,2,,void
117040,BLOCK,-1,,"{
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }",20,,2561,2,,void
117045,BLOCK,-1,,"{
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      }",22,,2562,2,,void
117065,BLOCK,-1,,<empty>,14,,2565,1,,void
117070,BLOCK,-1,,"{
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      }",29,,2565,2,,void
117088,BLOCK,-1,,<empty>,14,,2567,1,,void
117093,BLOCK,-1,,"{
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }",29,,2567,2,,void
117111,BLOCK,1,,<empty>,,,,3,,void
117128,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);

  v8::Local<v8::External> external_value = val.As<v8::External>();
  *result = external_value->Value();

  return napi_clear_last_error(env);
}",63,,2578,4,,void
117131,BLOCK,1,,<empty>,,,,2,,void
117133,BLOCK,-1,,CHECK_ENV(env),3,,2579,1,,void
117138,BLOCK,-1,,CHECK_ENV(env),3,,2579,2,,void
117145,BLOCK,1,,<empty>,,,,3,,void
117147,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2580,1,,void
117153,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2580,2,,void
117162,BLOCK,1,,<empty>,,,,3,,void
117164,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2581,1,,void
117170,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2581,2,,void
117198,BLOCK,1,,<empty>,,,,4,,void
117200,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2584,1,,void
117207,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2584,2,,void
117244,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);
  if (env->module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }

  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, initial_refcount, v8impl::Ownership::kUserland);

  *result = reinterpret_cast<napi_ref>(reference);
  return napi_clear_last_error(env);
}",64,,2596,5,,void
117247,BLOCK,1,,<empty>,,,,2,,void
117249,BLOCK,-1,,CHECK_ENV(env),3,,2599,1,,void
117254,BLOCK,-1,,CHECK_ENV(env),3,,2599,2,,void
117261,BLOCK,1,,<empty>,,,,3,,void
117263,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2600,1,,void
117269,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2600,2,,void
117278,BLOCK,1,,<empty>,,,,3,,void
117280,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2601,1,,void
117286,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2601,2,,void
117313,BLOCK,1,,<empty>,,,,1,,void
117315,BLOCK,-1,,"{
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }",61,,2604,2,,void
117332,BLOCK,-1,,"{
      return napi_set_last_error(env, napi_invalid_arg);
    }",34,,2606,2,,void
117368,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  delete reinterpret_cast<v8impl::Reference*>(ref);

  return napi_clear_last_error(env);
}",74,,2620,3,,void
117371,BLOCK,1,,<empty>,,,,2,,void
117373,BLOCK,-1,,CHECK_ENV(env),3,,2623,1,,void
117378,BLOCK,-1,,CHECK_ENV(env),3,,2623,2,,void
117385,BLOCK,1,,<empty>,,,,3,,void
117387,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2624,1,,void
117393,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2624,2,,void
117412,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  uint32_t count = reference->Ref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",61,,2638,4,,void
117415,BLOCK,1,,<empty>,,,,2,,void
117417,BLOCK,-1,,CHECK_ENV(env),3,,2641,1,,void
117422,BLOCK,-1,,CHECK_ENV(env),3,,2641,2,,void
117429,BLOCK,1,,<empty>,,,,3,,void
117431,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2642,1,,void
117437,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2642,2,,void
117460,BLOCK,-1,,"{
    *result = count;
  }",26,,2647,2,,void
117474,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);

  if (reference->RefCount() == 0) {
    return napi_set_last_error(env, napi_generic_failure);
  }

  uint32_t count = reference->Unref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",63,,2660,4,,void
117477,BLOCK,1,,<empty>,,,,2,,void
117479,BLOCK,-1,,CHECK_ENV(env),3,,2663,1,,void
117484,BLOCK,-1,,CHECK_ENV(env),3,,2663,2,,void
117491,BLOCK,1,,<empty>,,,,3,,void
117493,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2664,1,,void
117499,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2664,2,,void
117518,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_generic_failure);
  }",35,,2668,2,,void
117534,BLOCK,-1,,"{
    *result = count;
  }",26,,2674,2,,void
117548,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);
  CHECK_ARG(env, result);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  *result = v8impl::JsValueFromV8LocalValue(reference->Get());

  return napi_clear_last_error(env);
}",69,,2686,4,,void
117551,BLOCK,1,,<empty>,,,,2,,void
117553,BLOCK,-1,,CHECK_ENV(env),3,,2689,1,,void
117558,BLOCK,-1,,CHECK_ENV(env),3,,2689,2,,void
117565,BLOCK,1,,<empty>,,,,3,,void
117567,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2690,1,,void
117573,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2690,2,,void
117582,BLOCK,1,,<empty>,,,,3,,void
117584,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2691,1,,void
117590,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2691,2,,void
117621,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsHandleScopeFromV8HandleScope(
      new v8impl::HandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",74,,2700,3,,void
117624,BLOCK,1,,<empty>,,,,2,,void
117626,BLOCK,-1,,CHECK_ENV(env),3,,2703,1,,void
117631,BLOCK,-1,,CHECK_ENV(env),3,,2703,2,,void
117638,BLOCK,1,,<empty>,,,,3,,void
117640,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,1,,void
117646,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,2,,void
117676,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  env->open_handle_scopes--;
  delete v8impl::V8HandleScopeFromJsHandleScope(scope);
  return napi_clear_last_error(env);
}",73,,2713,3,,void
117679,BLOCK,1,,<empty>,,,,2,,void
117681,BLOCK,-1,,CHECK_ENV(env),3,,2716,1,,void
117686,BLOCK,-1,,CHECK_ENV(env),3,,2716,2,,void
117693,BLOCK,1,,<empty>,,,,3,,void
117695,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2717,1,,void
117701,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2717,2,,void
117713,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2718,2,,void
117734,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(
      new v8impl::EscapableHandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",56,,2728,3,,void
117737,BLOCK,1,,<empty>,,,,2,,void
117739,BLOCK,-1,,CHECK_ENV(env),3,,2731,1,,void
117744,BLOCK,-1,,CHECK_ENV(env),3,,2731,2,,void
117751,BLOCK,1,,<empty>,,,,3,,void
117753,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2732,1,,void
117759,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2732,2,,void
117789,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  env->open_handle_scopes--;
  return napi_clear_last_error(env);
}",54,,2741,3,,void
117792,BLOCK,1,,<empty>,,,,2,,void
117794,BLOCK,-1,,CHECK_ENV(env),3,,2744,1,,void
117799,BLOCK,-1,,CHECK_ENV(env),3,,2744,2,,void
117806,BLOCK,1,,<empty>,,,,3,,void
117808,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2745,1,,void
117814,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2745,2,,void
117826,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2746,2,,void
117849,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  CHECK_ARG(env, escapee);
  CHECK_ARG(env, result);

  v8impl::EscapableHandleScopeWrapper* s =
      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  if (!s->escape_called()) {
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }
  return napi_set_last_error(env, napi_escape_called_twice);
}",63,,2758,5,,void
117852,BLOCK,1,,<empty>,,,,2,,void
117854,BLOCK,-1,,CHECK_ENV(env),3,,2761,1,,void
117859,BLOCK,-1,,CHECK_ENV(env),3,,2761,2,,void
117866,BLOCK,1,,<empty>,,,,3,,void
117868,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2762,1,,void
117874,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2762,2,,void
117883,BLOCK,1,,<empty>,,,,3,,void
117885,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2763,1,,void
117891,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2763,2,,void
117900,BLOCK,1,,<empty>,,,,3,,void
117902,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2764,1,,void
117908,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2764,2,,void
117928,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }",28,,2768,2,,void
117960,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, constructor);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Function> ctor;
  CHECK_TO_FUNCTION(env, ctor, constructor);

  auto maybe = ctor->NewInstance(
      context,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",62,,2780,6,,void
117963,BLOCK,1,,<empty>,,,,2,,void
117965,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117970,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
117975,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117984,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
117991,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117998,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
118019,BLOCK,1,,<empty>,,,,3,,void
118021,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2782,1,,void
118027,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2782,2,,void
118037,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,2783,2,,void
118041,BLOCK,1,,<empty>,,,,3,,void
118043,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2784,1,,void
118049,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2784,2,,void
118058,BLOCK,1,,<empty>,,,,3,,void
118060,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2786,1,,void
118066,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2786,2,,void
118099,BLOCK,1,,<empty>,,,,4,,void
118101,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
118103,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
118109,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,2,,void
118131,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
118138,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,2,,void
118169,BLOCK,1,,<empty>,,,,5,,void
118171,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2798,1,,void
118179,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2798,2,,void
118199,BLOCK,1,,<empty>,,,,3,,void
118217,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, object);
  CHECK_ARG(env, result);

  *result = false;

  v8::Local<v8::Object> ctor;
  v8::Local<v8::Context> context = env->context();

  CHECK_TO_OBJECT(env, context, ctor, constructor);

  if (!ctor->IsFunction()) {
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }

  napi_status status = napi_generic_failure;

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);
  auto maybe_result = val->InstanceOf(context, ctor);
  CHECK_MAYBE_NOTHING(env, maybe_result, status);
  *result = maybe_result.FromJust();
  return GET_RETURN_STATUS(env);
}",54,,2807,5,,void
118220,BLOCK,1,,<empty>,,,,2,,void
118222,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
118227,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
118232,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
118241,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
118248,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
118255,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
118276,BLOCK,1,,<empty>,,,,3,,void
118278,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2809,1,,void
118284,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2809,2,,void
118293,BLOCK,1,,<empty>,,,,3,,void
118295,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2810,1,,void
118301,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2810,2,,void
118340,BLOCK,1,,<empty>,,,,7,,void
118342,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118344,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118350,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,2,,void
118369,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118377,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,2,,void
118396,BLOCK,-1,,"{
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }",28,,2819,2,,void
118437,BLOCK,1,,<empty>,,,,6,,void
118439,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2830,1,,void
118447,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2830,2,,void
118463,BLOCK,1,,<empty>,,,,3,,void
118479,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = !env->last_exception.IsEmpty();
  return napi_clear_last_error(env);
}",78,,2836,3,,void
118482,BLOCK,1,,<empty>,,,,2,,void
118484,BLOCK,-1,,CHECK_ENV(env),3,,2839,1,,void
118489,BLOCK,-1,,CHECK_ENV(env),3,,2839,2,,void
118496,BLOCK,1,,<empty>,,,,3,,void
118498,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2840,1,,void
118504,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2840,2,,void
118528,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  if (env->last_exception.IsEmpty()) {
    return napi_get_undefined(env, result);
  } else {
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }

  return napi_clear_last_error(env);
}",78,,2847,3,,void
118531,BLOCK,1,,<empty>,,,,2,,void
118533,BLOCK,-1,,CHECK_ENV(env),3,,2850,1,,void
118538,BLOCK,-1,,CHECK_ENV(env),3,,2850,2,,void
118545,BLOCK,1,,<empty>,,,,3,,void
118547,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2851,1,,void
118553,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2851,2,,void
118566,BLOCK,-1,,"{
    return napi_get_undefined(env, result);
  }",38,,2853,2,,void
118572,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }",10,,2855,1,,void
118613,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsArrayBuffer();

  return napi_clear_last_error(env);
}",58,,2866,4,,void
118616,BLOCK,1,,<empty>,,,,2,,void
118618,BLOCK,-1,,CHECK_ENV(env),3,,2867,1,,void
118623,BLOCK,-1,,CHECK_ENV(env),3,,2867,2,,void
118630,BLOCK,1,,<empty>,,,,3,,void
118632,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2868,1,,void
118638,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2868,2,,void
118647,BLOCK,1,,<empty>,,,,3,,void
118649,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2869,1,,void
118655,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2869,2,,void
118693,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::ArrayBuffer> buffer =
      v8::ArrayBuffer::New(isolate, byte_length);

  // Optionally return a pointer to the buffer's data, to avoid another call to
  // retrieve it.
  if (data != nullptr) {
    *data = buffer->Data();
  }

  *result = v8impl::JsValueFromV8LocalValue(buffer);
  return GET_RETURN_STATUS(env);
}",68,,2880,5,,void
118696,BLOCK,1,,<empty>,,,,2,,void
118698,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118703,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118708,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118717,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118724,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118731,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118752,BLOCK,1,,<empty>,,,,3,,void
118754,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2882,1,,void
118760,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2882,2,,void
118794,BLOCK,-1,,"{
    *data = buffer->Data();
  }",24,,2890,2,,void
118813,BLOCK,1,,<empty>,,,,3,,void
118833,BLOCK,-1,,"{
  // The API contract here is that the cleanup function runs on the JS thread,
  // and is able to use napi_env. Implementing that properly is hard, so use the
  // `Buffer` variant for easier implementation.
  napi_value buffer;
  STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer));
  return napi_get_typedarray_info(
      env, buffer, nullptr, nullptr, nullptr, result, nullptr);
}",54,,2904,7,,void
118837,BLOCK,1,,<empty>,,,,4,,void
118839,BLOCK,-1,,"STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer))",3,,2909,1,,void
118855,BLOCK,-1,,<empty>,3,,2909,2,,void
118875,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> ab = value.As<v8::ArrayBuffer>();

  if (data != nullptr) {
    *data = ab->Data();
  }

  if (byte_length != nullptr) {
    *byte_length = ab->ByteLength();
  }

  return napi_clear_last_error(env);
}",71,,2918,5,,void
118878,BLOCK,1,,<empty>,,,,2,,void
118880,BLOCK,-1,,CHECK_ENV(env),3,,2919,1,,void
118885,BLOCK,-1,,CHECK_ENV(env),3,,2919,2,,void
118892,BLOCK,1,,<empty>,,,,3,,void
118894,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2920,1,,void
118900,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2920,2,,void
118928,BLOCK,1,,<empty>,,,,4,,void
118930,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2923,1,,void
118937,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2923,2,,void
118961,BLOCK,-1,,"{
    *data = ab->Data();
  }",24,,2927,2,,void
118973,BLOCK,-1,,"{
    *byte_length = ab->ByteLength();
  }",31,,2931,2,,void
118990,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsTypedArray();

  return napi_clear_last_error(env);
}",57,,2940,4,,void
118993,BLOCK,1,,<empty>,,,,2,,void
118995,BLOCK,-1,,CHECK_ENV(env),3,,2941,1,,void
119000,BLOCK,-1,,CHECK_ENV(env),3,,2941,2,,void
119007,BLOCK,1,,<empty>,,,,3,,void
119009,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2942,1,,void
119015,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2942,2,,void
119024,BLOCK,1,,<empty>,,,,3,,void
119026,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2943,1,,void
119032,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2943,2,,void
119072,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  v8::Local<v8::TypedArray> typedArray;

  switch (type) {
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint...",67,,2956,7,,void
119075,BLOCK,1,,<empty>,,,,2,,void
119077,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
119082,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
119087,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
119096,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
119103,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
119110,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
119131,BLOCK,1,,<empty>,,,,3,,void
119133,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2958,1,,void
119139,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2958,2,,void
119148,BLOCK,1,,<empty>,,,,3,,void
119150,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2959,1,,void
119156,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2959,2,,void
119184,BLOCK,1,,<empty>,,,,4,,void
119186,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2962,1,,void
119193,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2962,2,,void
119224,BLOCK,-1,,"{
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_int32_array:
      CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint32_array:
      CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case nap...",17,,2967,2,,void
119234,BLOCK,1,,<empty>,,,,7,,void
119236,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119241,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119243,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119251,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119262,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119275,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119307,BLOCK,1,,<empty>,,,,7,,void
119309,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119314,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119316,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119324,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119335,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119348,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119380,BLOCK,1,,<empty>,,,,7,,void
119382,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119387,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119389,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119397,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119408,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119421,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119453,BLOCK,1,,<empty>,,,,7,,void
119455,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119460,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119462,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119470,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119481,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119494,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119526,BLOCK,1,,<empty>,,,,7,,void
119528,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119533,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119535,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119543,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119554,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119567,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119599,BLOCK,1,,<empty>,,,,7,,void
119601,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119606,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119608,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119616,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119627,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119640,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119672,BLOCK,1,,<empty>,,,,7,,void
119674,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119679,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119681,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119689,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119700,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119713,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119745,BLOCK,1,,<empty>,,,,7,,void
119747,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119752,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119754,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119762,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119773,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119786,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119818,BLOCK,1,,<empty>,,,,7,,void
119820,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119825,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119827,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119835,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119846,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119859,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119891,BLOCK,1,,<empty>,,,,7,,void
119893,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119898,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119900,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119908,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119919,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119932,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119964,BLOCK,1,,<empty>,,,,7,,void
119966,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
119971,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
119973,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
119981,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
119992,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
120005,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
120044,BLOCK,1,,<empty>,,,,3,,void
120065,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, typedarray);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);
  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);

  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();

  if (type != nullptr) {
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) ...",70,,3026,8,,void
120068,BLOCK,1,,<empty>,,,,2,,void
120070,BLOCK,-1,,CHECK_ENV(env),3,,3027,1,,void
120075,BLOCK,-1,,CHECK_ENV(env),3,,3027,2,,void
120082,BLOCK,1,,<empty>,,,,3,,void
120084,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,3028,1,,void
120090,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,3028,2,,void
120118,BLOCK,1,,<empty>,,,,4,,void
120120,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,3031,1,,void
120127,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,3031,2,,void
120151,BLOCK,-1,,"{
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) {
      *type = napi_bigint64_array;
    } else if (value->IsBigUint64Array()) {
      *type = napi_biguint64_array;
    }
  }",24,,3035,2,,void
120157,BLOCK,-1,,"{
      *type = napi_int8_array;
    }",31,,3036,2,,void
120163,BLOCK,-1,,<empty>,12,,3038,1,,void
120169,BLOCK,-1,,"{
      *type = napi_uint8_array;
    }",39,,3038,2,,void
120175,BLOCK,-1,,<empty>,12,,3040,1,,void
120181,BLOCK,-1,,"{
      *type = napi_uint8_clamped_array;
    }",46,,3040,2,,void
120187,BLOCK,-1,,<empty>,12,,3042,1,,void
120193,BLOCK,-1,,"{
      *type = napi_int16_array;
    }",39,,3042,2,,void
120199,BLOCK,-1,,<empty>,12,,3044,1,,void
120205,BLOCK,-1,,"{
      *type = napi_uint16_array;
    }",40,,3044,2,,void
120211,BLOCK,-1,,<empty>,12,,3046,1,,void
120217,BLOCK,-1,,"{
      *type = napi_int32_array;
    }",39,,3046,2,,void
120223,BLOCK,-1,,<empty>,12,,3048,1,,void
120229,BLOCK,-1,,"{
      *type = napi_uint32_array;
    }",40,,3048,2,,void
120235,BLOCK,-1,,<empty>,12,,3050,1,,void
120241,BLOCK,-1,,"{
      *type = napi_float32_array;
    }",41,,3050,2,,void
120247,BLOCK,-1,,<empty>,12,,3052,1,,void
120253,BLOCK,-1,,"{
      *type = napi_float64_array;
    }",41,,3052,2,,void
120259,BLOCK,-1,,<empty>,12,,3054,1,,void
120265,BLOCK,-1,,"{
      *type = napi_bigint64_array;
    }",42,,3054,2,,void
120271,BLOCK,-1,,<empty>,12,,3056,1,,void
120277,BLOCK,-1,,"{
      *type = napi_biguint64_array;
    }",43,,3056,2,,void
120286,BLOCK,-1,,"{
    *length = array->Length();
  }",26,,3061,2,,void
120311,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }",50,,3066,2,,void
120322,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,3072,2,,void
120341,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,3076,2,,void
120354,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,3080,2,,void
120373,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  if (byte_length + byte_offset > buffer->ByteLength()) {
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }
  v8::Local<v8::DataView> DataView =
      v8::DataView::New(buffer, byte_offset, byte_length);

  *result = v8impl::JsValueFromV8LocalValue(DataView);
  return GET_RETURN_STATUS(env);
}",65,,3091,6,,void
120376,BLOCK,1,,<empty>,,,,2,,void
120378,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120383,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120388,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120397,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120404,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120411,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120432,BLOCK,1,,<empty>,,,,3,,void
120434,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3093,1,,void
120440,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3093,2,,void
120449,BLOCK,1,,<empty>,,,,3,,void
120451,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3094,1,,void
120457,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3094,2,,void
120485,BLOCK,1,,<empty>,,,,4,,void
120487,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,3097,1,,void
120494,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,3097,2,,void
120523,BLOCK,-1,,"{
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }",57,,3100,2,,void
120562,BLOCK,1,,<empty>,,,,3,,void
120579,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsDataView();

  return napi_clear_last_error(env);
}",55,,3116,4,,void
120582,BLOCK,1,,<empty>,,,,2,,void
120584,BLOCK,-1,,CHECK_ENV(env),3,,3117,1,,void
120589,BLOCK,-1,,CHECK_ENV(env),3,,3117,2,,void
120596,BLOCK,1,,<empty>,,,,3,,void
120598,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3118,1,,void
120604,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3118,2,,void
120613,BLOCK,1,,<empty>,,,,3,,void
120615,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3119,1,,void
120621,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3119,2,,void
120661,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, dataview);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);
  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);

  v8::Local<v8::DataView> array = value.As<v8::DataView>();

  if (byte_length != nullptr) {
    *byte_length = array->ByteLength();
  }

  v8::Local<v8::ArrayBuffer> buffer;
  if (data != nullptr || arraybuffer != nullptr) {
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }

  if (data != nullptr) {
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }

  if (arraybuffer != nullptr) {
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }

  if (byte_offset != nullptr) {
    *byte_offset = array->ByteOffset();
  }

  return napi_clear_last_error(env);
}",68,,3132,7,,void
120664,BLOCK,1,,<empty>,,,,2,,void
120666,BLOCK,-1,,CHECK_ENV(env),3,,3133,1,,void
120671,BLOCK,-1,,CHECK_ENV(env),3,,3133,2,,void
120678,BLOCK,1,,<empty>,,,,3,,void
120680,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,3134,1,,void
120686,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,3134,2,,void
120714,BLOCK,1,,<empty>,,,,4,,void
120716,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,3137,1,,void
120723,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,3137,2,,void
120747,BLOCK,-1,,"{
    *byte_length = array->ByteLength();
  }",31,,3141,2,,void
120772,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }",50,,3146,2,,void
120783,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,3152,2,,void
120802,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,3156,2,,void
120815,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,3160,2,,void
120831,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  *result = NAPI_VERSION;
  return napi_clear_last_error(env);
}",73,,3167,3,,void
120834,BLOCK,1,,<empty>,,,,2,,void
120836,BLOCK,-1,,CHECK_ENV(env),3,,3168,1,,void
120841,BLOCK,-1,,CHECK_ENV(env),3,,3168,2,,void
120848,BLOCK,1,,<empty>,,,,3,,void
120850,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3169,1,,void
120856,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3169,2,,void
120866,BLOCK,1,,<empty>,,,,1,,void
120877,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, deferred);
  CHECK_ARG(env, promise);

  auto maybe = v8::Promise::Resolver::New(env->context());
  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  auto v8_resolver = maybe.ToLocalChecked();
  auto v8_deferred = new v8impl::Persistent<v8::Value>();
  v8_deferred->Reset(env->isolate, v8_resolver);

  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);
  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());
  return GET_RETURN_STATUS(env);
}",65,,3176,4,,void
120880,BLOCK,1,,<empty>,,,,2,,void
120882,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120887,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120892,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120901,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120908,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120915,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120936,BLOCK,1,,<empty>,,,,3,,void
120938,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3178,1,,void
120944,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3178,2,,void
120953,BLOCK,1,,<empty>,,,,3,,void
120955,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3179,1,,void
120961,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3179,2,,void
120986,BLOCK,1,,<empty>,,,,5,,void
120988,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3182,1,,void
120996,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3182,2,,void
121044,BLOCK,1,,<empty>,,,,3,,void
121061,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, true);
}",69,,3195,4,,void
121077,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, false);
}",68,,3201,4,,void
121093,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_promise);

  *is_promise = v8impl::V8LocalValueFromJsValue(value)->IsPromise();

  return napi_clear_last_error(env);
}",58,,3207,4,,void
121096,BLOCK,1,,<empty>,,,,2,,void
121098,BLOCK,-1,,CHECK_ENV(env),3,,3208,1,,void
121103,BLOCK,-1,,CHECK_ENV(env),3,,3208,2,,void
121110,BLOCK,1,,<empty>,,,,3,,void
121112,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3209,1,,void
121118,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3209,2,,void
121127,BLOCK,1,,<empty>,,,,3,,void
121129,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3210,1,,void
121135,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3210,2,,void
121161,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Value> maybe_date = v8::Date::New(env->context(), time);
  CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe_date.ToLocalChecked());

  return GET_RETURN_STATUS(env);
}",61,,3219,4,,void
121164,BLOCK,1,,<empty>,,,,2,,void
121166,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
121171,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
121176,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
121185,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
121192,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
121199,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
121220,BLOCK,1,,<empty>,,,,3,,void
121222,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3221,1,,void
121228,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3221,2,,void
121259,BLOCK,1,,<empty>,,,,4,,void
121261,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3224,1,,void
121269,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3224,2,,void
121289,BLOCK,1,,<empty>,,,,3,,void
121306,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}",52,,3233,4,,void
121309,BLOCK,1,,<empty>,,,,2,,void
121311,BLOCK,-1,,CHECK_ENV(env),3,,3234,1,,void
121316,BLOCK,-1,,CHECK_ENV(env),3,,3234,2,,void
121323,BLOCK,1,,<empty>,,,,3,,void
121325,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3235,1,,void
121331,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3235,2,,void
121340,BLOCK,1,,<empty>,,,,3,,void
121342,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3236,1,,void
121348,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3236,2,,void
121374,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected);

  v8::Local<v8::Date> date = val.As<v8::Date>();
  *result = date->ValueOf();

  return GET_RETURN_STATUS(env);
}",60,,3245,4,,void
121377,BLOCK,1,,<empty>,,,,2,,void
121379,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121384,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121389,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121398,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121405,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121412,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121433,BLOCK,1,,<empty>,,,,3,,void
121435,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3247,1,,void
121441,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3247,2,,void
121450,BLOCK,1,,<empty>,,,,3,,void
121452,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3248,1,,void
121458,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3248,2,,void
121486,BLOCK,1,,<empty>,,,,4,,void
121488,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3251,1,,void
121495,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3251,2,,void
121525,BLOCK,1,,<empty>,,,,3,,void
121542,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, script);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);

  if (!v8_script->IsString()) {
    return napi_set_last_error(env, napi_string_expected);
  }

  v8::Local<v8::Context> context = env->context();

  auto maybe_script = v8::Script::Compile(context, v8_script.As<v8::String>());
  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);

  auto script_result = maybe_script.ToLocalChecked()->Run(context);
  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",60,,3261,4,,void
121545,BLOCK,1,,<empty>,,,,2,,void
121547,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121552,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121557,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121566,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121573,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121580,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121601,BLOCK,1,,<empty>,,,,3,,void
121603,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3263,1,,void
121609,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3263,2,,void
121618,BLOCK,1,,<empty>,,,,3,,void
121620,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3264,1,,void
121626,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3264,2,,void
121653,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_string_expected);
  }",31,,3268,2,,void
121690,BLOCK,1,,<empty>,,,,5,,void
121692,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3275,1,,void
121700,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3275,2,,void
121721,BLOCK,1,,<empty>,,,,5,,void
121723,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3278,1,,void
121731,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3278,2,,void
121751,BLOCK,1,,<empty>,,,,3,,void
121771,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, js_object);
  CHECK_ARG(env, finalize_cb);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg);

  // Create a self-deleting reference if the optional out-param result is not
  // set.
  v8impl::Ownership ownership = result == nullptr
                                    ? v8impl::Ownership::kRuntime
                                    : v8impl::Ownership::kUserland;
  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, 0, ownership, finalize_cb, finalize_data, finalize_hint);

  if (result != nullptr) {
    *result = reinterpret_cast<napi_ref>(reference);
  }
  return napi_clear_last_error(env);
}",61,,3289,7,,void
121774,BLOCK,1,,<empty>,,,,2,,void
121776,BLOCK,-1,,CHECK_ENV(env),3,,3292,1,,void
121781,BLOCK,-1,,CHECK_ENV(env),3,,3292,2,,void
121788,BLOCK,1,,<empty>,,,,3,,void
121790,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3293,1,,void
121796,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3293,2,,void
121805,BLOCK,1,,<empty>,,,,3,,void
121807,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3294,1,,void
121813,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3294,2,,void
121841,BLOCK,1,,<empty>,,,,4,,void
121843,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3297,1,,void
121850,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3297,2,,void
121893,BLOCK,-1,,"{
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,3307,2,,void
121909,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, adjusted_value);

  *adjusted_value =
      env->isolate->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

  return napi_clear_last_error(env);
}",77,,3315,4,,void
121912,BLOCK,1,,<empty>,,,,2,,void
121914,BLOCK,-1,,CHECK_ENV(env),3,,3316,1,,void
121919,BLOCK,-1,,CHECK_ENV(env),3,,3316,2,,void
121926,BLOCK,1,,<empty>,,,,3,,void
121928,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3317,1,,void
121934,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3317,2,,void
121960,BLOCK,-1,,"{
  CHECK_ENV(env);

  v8impl::RefBase* old_data = static_cast<v8impl::RefBase*>(env->instance_data);
  if (old_data != nullptr) {
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }

  env->instance_data = v8impl::RefBase::New(
      env, 0, v8impl::Ownership::kRuntime, finalize_cb, data, finalize_hint);

  return napi_clear_last_error(env);
}",68,,3328,5,,void
121963,BLOCK,1,,<empty>,,,,2,,void
121965,BLOCK,-1,,CHECK_ENV(env),3,,3329,1,,void
121970,BLOCK,-1,,CHECK_ENV(env),3,,3329,2,,void
121986,BLOCK,-1,,"{
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }",28,,3332,2,,void
122017,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, data);

  v8impl::RefBase* idata = static_cast<v8impl::RefBase*>(env->instance_data);

  *data = (idata == nullptr ? nullptr : idata->Data());

  return napi_clear_last_error(env);
}",74,,3344,3,,void
122020,BLOCK,1,,<empty>,,,,2,,void
122022,BLOCK,-1,,CHECK_ENV(env),3,,3345,1,,void
122027,BLOCK,-1,,CHECK_ENV(env),3,,3345,2,,void
122034,BLOCK,1,,<empty>,,,,3,,void
122036,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3346,1,,void
122042,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3346,2,,void
122076,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected);

  v8::Local<v8::ArrayBuffer> it = value.As<v8::ArrayBuffer>();
  RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected);

  it->Detach(v8::Local<v8::Value>()).Check();

  return napi_clear_last_error(env);
}",72,,3356,3,,void
122079,BLOCK,1,,<empty>,,,,2,,void
122081,BLOCK,-1,,CHECK_ENV(env),3,,3357,1,,void
122086,BLOCK,-1,,CHECK_ENV(env),3,,3357,2,,void
122093,BLOCK,1,,<empty>,,,,3,,void
122095,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3358,1,,void
122101,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3358,2,,void
122129,BLOCK,1,,<empty>,,,,4,,void
122131,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3361,1,,void
122138,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3361,2,,void
122165,BLOCK,1,,<empty>,,,,4,,void
122167,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3365,1,,void
122174,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3365,2,,void
122200,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);

  *result =
      value->IsArrayBuffer() && value.As<v8::ArrayBuffer>()->WasDetached();

  return napi_clear_last_error(env);
}",67,,3375,4,,void
122203,BLOCK,1,,<empty>,,,,2,,void
122205,BLOCK,-1,,CHECK_ENV(env),3,,3376,1,,void
122210,BLOCK,-1,,CHECK_ENV(env),3,,3376,2,,void
122217,BLOCK,1,,<empty>,,,,3,,void
122219,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3377,1,,void
122225,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3377,2,,void
122234,BLOCK,1,,<empty>,,,,3,,void
122236,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3378,1,,void
122242,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3378,2,,void
122286,BLOCK,-1,,"{ cb(env, data, hint); }",38,,105,2,,void
122304,BLOCK,-1,,<empty>,1,,1,1,,ANY
122307,BLOCK,-1,,<empty>,,,,2,,<empty>
122313,BLOCK,-1,,<empty>,16,,13,1,,void
122317,BLOCK,-1,,<empty>,25,,14,1,,void
122321,BLOCK,-1,,<empty>,27,,15,1,,void
122327,BLOCK,-1,,"{
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",35,,19,2,,void
122340,BLOCK,-1,,"{
      next_->prev_ = this;
    }",27,,22,2,,void
122354,BLOCK,-1,,"{
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",24,,28,1,,void
122359,BLOCK,-1,,"{
      prev_->next_ = next_;
    }",27,,29,2,,void
122369,BLOCK,-1,,"{
      next_->prev_ = prev_;
    }",27,,32,2,,void
122385,BLOCK,-1,,"{
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",42,,39,2,,void
122392,BLOCK,-1,,"{
      list->next_->Finalize();
    }",36,,40,2,,void
122404,BLOCK,-1,,<empty>,,,,1,,<empty>
122417,BLOCK,-1,,"{
    napi_clear_last_error(this);
  }",48,,58,3,,void
122423,BLOCK,-1,,"{
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",49,,62,1,,void
122435,BLOCK,-1,,{ refs++; },21,,66,1,,void
122441,BLOCK,-1,,"{
    if (--refs == 0) DeleteMe();
  }",23,,67,1,,void
122447,BLOCK,-1,,<empty>,22,,68,2,,void
122452,BLOCK,-1,,{ return true; },41,,71,1,,void
122460,BLOCK,-1,,"{
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }",76,,73,3,,void
122466,BLOCK,-1,,"{
      return;
    }",41,,74,2,,void
122478,BLOCK,-1,,"{
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",41,,81,1,,void
122494,BLOCK,-1,,"{
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",76,,89,3,,void
122519,BLOCK,-1,,"{
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }",36,,96,2,,void
122537,BLOCK,-1,,"{
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",72,,103,4,,void
122547,BLOCK,-1,,"{
    pending_finalizers.emplace(finalizer);
  }",64,,112,2,,void
122557,BLOCK,-1,,"{
    pending_finalizers.erase(finalizer);
  }",64,,118,2,,void
122566,BLOCK,-1,,"{
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",27,,122,1,,void
122600,BLOCK,-1,,<empty>,,,,1,,<empty>
122604,BLOCK,-1,,<empty>,,,,1,,<empty>
122620,BLOCK,1,,<empty>,,,,1,,void
122626,BLOCK,-1,,"{
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",56,,158,2,,void
122664,BLOCK,-1,,"{
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",73,,169,5,,void
122700,BLOCK,-1,,"{
  return reinterpret_cast<napi_value>(*local);
}",71,,297,2,,void
122710,BLOCK,-1,,"{
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",67,,301,2,,void
122739,BLOCK,-1,,<empty>,39,,317,5,,void
122743,BLOCK,-1,,<empty>,,,,1,,<empty>
122751,BLOCK,-1,,"{
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }",56,,325,5,,void
122762,BLOCK,-1,,{ return finalize_callback_; },28,,329,1,,void
122768,BLOCK,-1,,{ return finalize_data_; },16,,330,1,,void
122774,BLOCK,-1,,{ return finalize_hint_; },16,,331,1,,void
122780,BLOCK,-1,,<empty>,,,,1,,<empty>
122790,BLOCK,-1,,<empty>,75,,344,2,,void
122794,BLOCK,-1,,"{
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",15,,346,1,,void
122797,BLOCK,-1,,"{
      _env->last_exception.Reset(_env->isolate, Exception());
    }",22,,347,2,,void
122822,BLOCK,-1,,<empty>,,,,7,,<empty>
122832,BLOCK,-1,,<empty>,,,,7,,<empty>
122836,BLOCK,-1,,<empty>,,,,1,,<empty>
122840,BLOCK,-1,,<empty>,,,,1,,<empty>
122844,BLOCK,-1,,<empty>,,,,1,,<empty>
122848,BLOCK,-1,,<empty>,,,,1,,<empty>
122852,BLOCK,-1,,<empty>,,,,1,,<empty>
122856,BLOCK,-1,,{ return ownership_; },25,,390,1,,void
122862,BLOCK,-1,,<empty>,,,,1,,<empty>
122872,BLOCK,-1,,<empty>,,,,4,,<empty>
122883,BLOCK,-1,,<empty>,,,,8,,<empty>
122887,BLOCK,-1,,<empty>,,,,1,,<empty>
122891,BLOCK,-1,,<empty>,,,,1,,<empty>
122895,BLOCK,-1,,<empty>,,,,1,,<empty>
122899,BLOCK,-1,,<empty>,,,,1,,<empty>
122903,BLOCK,-1,,<empty>,,,,1,,<empty>
122908,BLOCK,-1,,<empty>,,,,2,,<empty>
122912,BLOCK,-1,,<empty>,,,,1,,<empty>
122929,BLOCK,-1,,<empty>,1,,1,1,,ANY
122951,BLOCK,-1,,<empty>,1,,1,1,,ANY
122956,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(obj);
}",23,,28,3,,void
122966,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",37,,34,1,,void
122974,BLOCK,-1,,"{
  return true;
}",26,,39,1,,void
122980,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }
  return value->IsTrue();
}",28,,44,1,,void
123015,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }",77,,49,2,,void
123027,BLOCK,-1,,<empty>,7,,51,2,,void
123047,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,58,1,,void
123101,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,65,2,,void
123113,BLOCK,-1,,<empty>,7,,67,2,,void
123128,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",26,,73,1,,void
123182,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,80,2,,void
123194,BLOCK,-1,,<empty>,7,,82,2,,void
123210,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  Local<Value> argv[] = {
    req_wrap->object()
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onshutdown_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",50,,88,2,,void
123273,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,102,2,,void
123285,BLOCK,-1,,<empty>,7,,104,2,,void
123304,BLOCK,-1,,"{
  CHECK_NULL(send_handle);

  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  MaybeStackBuffer<Local<Value>, 16> bufs_arr(count);
  for (size_t i = 0; i < count; i++) {
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }

  Local<Value> argv[] = {
    w->object(),
    Array::New(env()->isolate(), bufs_arr.out(), count)
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onwrite_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",49,,113,5,,void
123323,BLOCK,-1,,<empty>,3,,120,1,,void
123333,BLOCK,4,,"{
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }",38,,120,4,,void
123419,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,136,2,,void
123431,BLOCK,-1,,<empty>,7,,138,2,,void
123447,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new JSStream(env, args.This());
}",61,,144,2,,void
123472,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));

  CHECK(args[1]->IsInt32());
  w->Done(args[1].As<Int32>()->Value());
}",64,,155,2,,void
123519,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }
}",68,,164,2,,void
123551,BLOCK,-1,,"{
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }",20,,174,2,,void
123572,BLOCK,-1,,<empty>,7,,178,2,,void
123602,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->EmitRead(UV_EOF);
}",65,,188,2,,void
123623,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""finishWrite"", Finish<WriteWrap>);
  SetProtoMethod(isolate, t, ""finishShutdown"", Finish<ShutdownWrap>);
  SetProtoMethod(isolate, t, ""readBuffer"", ReadBuffer);
  SetProtoMethod(isolate, t, ""emitEOF"", EmitEOF);

  StreamBase::AddMethods(env, t);
  SetConstructorFunction(context, target, ""JSStream"", t);
}",39,,199,5,,void
123709,BLOCK,-1,,<empty>,1,,1,1,,ANY
123724,BLOCK,-1,,<empty>,1,,1,1,,ANY
123730,BLOCK,-1,,<empty>,,,,3,,<empty>
123734,BLOCK,-1,,<empty>,,,,1,,<empty>
123738,BLOCK,-1,,<empty>,,,,1,,<empty>
123745,BLOCK,-1,,<empty>,,,,4,,<empty>
123749,BLOCK,-1,,<empty>,,,,1,,<empty>
123753,BLOCK,-1,,<empty>,,,,1,,<empty>
123757,BLOCK,-1,,{ return this; },38,,38,1,,void
123764,BLOCK,-1,,<empty>,,,,2,,<empty>
123769,BLOCK,-1,,<empty>,,,,2,,<empty>
123774,BLOCK,-1,,<empty>,,,,2,,<empty>
123779,BLOCK,-1,,<empty>,,,,2,,<empty>
123787,BLOCK,-1,,<empty>,,,,5,,<empty>
123794,BLOCK,-1,,"{
  MakeWeak();

  obj->SetAlignedPointerInInternalField(
      kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));
}",45,,55,3,,void
123807,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",28,,62,1,,void
123832,BLOCK,1,,<empty>,,,,1,,void
123863,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,69,2,,void
123875,BLOCK,-1,,<empty>,7,,71,2,,void
123890,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,76,1,,void
123915,BLOCK,1,,<empty>,,,,1,,void
123946,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,83,2,,void
123958,BLOCK,-1,,<empty>,7,,85,2,,void
123976,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int64_t value_int = JS_EXCEPTION_PENDING;
  size_t total_len = 0;

  MaybeStackBuffer<Local<Value>, 16> buffers(nbufs);
  for (size_t i = 0; i < nbufs; i++) {
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }

  Local<Object> address;
  if (!AddressToJS(env(), addr).ToLocal(&address)) return value_int;

  Local<Value> args[] = {
    listener()->CreateSendWrap(total_len)->object(),
    Array::New(env()->isolate(), buffers.out(), nbufs),
    address,
  };

  if (!MakeCallback(env()->onwrite_string(), arraysize(args), args)
          .ToLocal(&value) ||
      !value->IntegerValue(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",47,,92,4,,void
124001,BLOCK,1,,<empty>,,,,1,,void
124011,BLOCK,-1,,<empty>,3,,101,1,,void
124021,BLOCK,4,,"{
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }",38,,101,4,,void
124066,BLOCK,-1,,<empty>,52,,108,2,,void
124125,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",62,,118,2,,void
124137,BLOCK,-1,,<empty>,7,,120,2,,void
124152,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,125,1,,void
124169,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,131,1,,void
124187,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  new JSUDPWrap(env, args.Holder());
}",62,,137,2,,void
124212,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  CHECK(args[1]->IsInt32());   // family
  CHECK(args[2]->IsString());  // address
  CHECK(args[3]->IsInt32());   // port
  CHECK(args[4]->IsInt32());   // flags
  int family = args[1].As<Int32>()->Value() == 4 ? AF_INET : AF_INET6;
  Utf8Value address(env->isolate(), args[2]);
  int port = args[3].As<Int32>()->Value();
  int flags = args[3].As<Int32>()->Value();

  sockaddr_storage addr;
  CHECK_EQ(sockaddr_for_family(family, *address, port, &addr), 0);

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
...",71,,143,2,,void
124339,BLOCK,-1,,"{
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->listener()->OnRecv(
        avail, buf, reinterpret_cast<sockaddr*>(&addr), flags);
  }",20,,166,2,,void
124398,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsInt32());
  ReqWrap<uv_udp_send_t>* req_wrap;
  ASSIGN_OR_RETURN_UNWRAP(&req_wrap, args[0].As<Object>());
  int status = args[1].As<Int32>()->Value();

  wrap->listener()->OnSendDone(req_wrap, status);
}",69,,177,2,,void
124461,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->listener()->OnAfterBind();
}",70,,190,2,,void
124484,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(UDPWrapBase::kUDPWrapBaseField + 1);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""emitReceived"", EmitReceived);
  SetProtoMethod(isolate, t, ""onSendDone"", OnSendDone);
  SetProtoMethod(isolate, t, ""onAfterBind"", OnAfterBind);

  SetConstructorFunction(context, target, ""JSUDPWrap"", t);
}",40,,200,5,,void
124571,BLOCK,-1,,<empty>,1,,1,1,,ANY
124575,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  CHECK_NOT_NULL(isolate);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  params.array_buffer_allocator = allocator;
  Isolate::Initialize(isolate, params);
  return isolate;
}",67,,15,2,,void
124614,BLOCK,-1,,"{
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  isolate->Dispose();
}",48,,26,2,,void
124632,BLOCK,-1,,<empty>,52,,36,1,,void
124637,BLOCK,-1,,"{
  DCHECK(!parsed_);

  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);

  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> json_string_value;
  Local<Value> result_value;
  if (!ToV8Value(context, content).ToLocal(&json_string_value) ||
      !json_string_value->IsString() ||
      !v8::JSON::Parse(context, json_string_value.As<String>())
           .ToLocal(&result_value) ||
      !result_value->IsObject()) {
    return false;
  }
  content_.Reset(isolate, result_value.As<Object>());
  parsed_ = true;
  return true;
}",52,,38,2,,void
124717,BLOCK,-1,,"{
    return false;
  }",34,,53,2,,void
124738,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsString()) {
    return {};
  }
  Utf8Value utf8_value(isolate, value);
  return utf8_value.ToString();
}",29,,62,2,,void
124797,BLOCK,-1,,"{
    return {};
  }",66,,71,2,,void
124818,BLOCK,-1,,"{
    return {};
  }",27,,75,2,,void
124833,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  bool has_field;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Has(context, field_local).To(&has_field)) {
    return {};
  }
  if (!has_field) {
    return false;
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsBoolean()) {
    return {};
  }
  return value->BooleanValue(isolate);
}",78,,82,2,,void
124893,BLOCK,-1,,"{
    return {};
  }",66,,92,2,,void
124908,BLOCK,-1,,"{
    return {};
  }",66,,95,2,,void
124913,BLOCK,-1,,"{
    return false;
  }",19,,98,2,,void
124935,BLOCK,-1,,"{
    return {};
  }",28,,102,2,,void
124959,BLOCK,-1,,<empty>,1,,1,1,,ANY
124966,BLOCK,-1,,<empty>,1,,1,1,,ANY
124970,BLOCK,-1,,"{
  // 'static constexpr' is slightly better than static const
  // since the initialization occurs at compile time.
  // See https://lemire.me/blog/I3Cah
  static constexpr std::string_view control_symbols[0x20] = {
      ""\\u0000"", ""\\u0001"", ""\\u0002"", ""\\u0003"", ""\\u0004"", ""\\u0005"",
      ""\\u0006"", ""\\u0007"", ""\\b"",     ""\\t"",     ""\\n"",     ""\\u000b"",
      ""\\f"",     ""\\r"",     ""\\u000e"", ""\\u000f"", ""\\u0010"", ""\\u0011"",
      ""\\u0012"", ""\\u0013"", ""\\u0014"", ""\\u0015"", ""\\u0016"", ""\\u0017"",
      ""\\u0018"", ""\\u0019"", ""\\u001a"", ""\\u001b"", ""\\u001c"", ""\\u001d"",
      ""\\u001e"", ""\\u001f""};

  std::string ret;
  size_t last_pos = 0;
  size_t pos = 0;
  for (; pos < str.size(); ++pos) {
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
 ...",51,,5,2,,void
125017,BLOCK,-1,,<empty>,3,,20,1,,void
125026,BLOCK,4,,"{
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }
  }",35,,20,4,,void
125038,BLOCK,-1,,"{
      replace = ""\\\\"";
    }",21,,23,2,,void
125043,BLOCK,-1,,<empty>,12,,25,1,,void
125048,BLOCK,-1,,"{
      replace = ""\\\"""";
    }",28,,25,2,,void
125053,BLOCK,-1,,"{
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }",12,,27,1,,void
125064,BLOCK,-1,,<empty>,23,,29,2,,void
125076,BLOCK,-1,,"{
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }",27,,31,2,,void
125081,BLOCK,-1,,"{
        ret += str.substr(last_pos, pos - last_pos);
      }",27,,32,2,,void
125107,BLOCK,-1,,"{
    ret += str.substr(last_pos, pos - last_pos);
  }",30,,40,2,,void
125125,BLOCK,-1,,"{
  if (indent_depth <= 0) return str;
  const std::string indent(indent_depth, ' ');
  std::string out;
  std::string::size_type pos = 0;
  for (;;) {
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }

  return out;
}",64,,46,3,,void
125130,BLOCK,-1,,<empty>,26,,47,2,,void
125143,BLOCK,-1,,<empty>,3,,51,1,,void
125144,BLOCK,4,,"{
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }",12,,51,4,,void
125170,BLOCK,-1,,"{
      out.append(str, prev_pos, std::string::npos);
      break;
    }",35,,57,2,,void
125184,BLOCK,-1,,"{
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }",12,,60,1,,void
125214,BLOCK,-1,,<empty>,1,,1,1,,ANY
125251,BLOCK,-1,,<empty>,1,,1,1,,ANY
125254,BLOCK,-1,,"{
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",33,,417,1,,void
125261,BLOCK,-1,,"{
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",41,,441,2,,void
125264,BLOCK,-1,,"{
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }",19,,442,2,,void
125295,BLOCK,-1,,<empty>,1,,1,1,,ANY
125304,BLOCK,-1,,<empty>,1,,1,1,,ANY
125323,BLOCK,-1,,<empty>,1,,1,1,,ANY
125326,BLOCK,-1,,"{
    MaybeLocal<Value> result = module->Evaluate(context);
    if (!result.IsEmpty() && microtask_queue)
      microtask_queue->PerformCheckpoint(isolate);
    return result;
  }",20,,384,1,,void
125346,BLOCK,-1,,<empty>,7,,387,2,,void
125385,BLOCK,-1,,<empty>,1,,1,1,,ANY
125393,BLOCK,-1,,"{
  env->id_to_module_map.emplace(id_, this);

  Local<Value> undefined = Undefined(env->isolate());
  object->SetInternalField(kURLSlot, url);
  object->SetInternalField(kSyntheticEvaluationStepsSlot, undefined);
  object->SetInternalField(kContextObjectSlot, undefined);
}",36,,58,5,,void
125434,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Module> module = module_.Get(env()->isolate());
  env()->id_to_module_map.erase(id_);
  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }
}",27,,67,1,,void
125476,BLOCK,-1,,<empty>,3,,72,1,,void
125490,BLOCK,4,,"{
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }",57,,72,4,,void
125497,BLOCK,-1,,"{
      env()->hash_to_module_map.erase(it);
      break;
    }",29,,73,2,,void
125509,BLOCK,-1,,"{
  Local<Value> obj = object()->GetInternalField(kContextObjectSlot);
  if (obj.IsEmpty()) return {};
  return obj.As<Object>()->GetCreationContext().ToLocalChecked();
}",44,,80,1,,void
125526,BLOCK,-1,,<empty>,22,,82,2,,void
125544,BLOCK,-1,,"{
  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second->module_ == module) {
      return it->second;
    }
  }
  return nullptr;
}",61,,87,3,,void
125559,BLOCK,-1,,<empty>,3,,89,1,,void
125573,BLOCK,4,,"{
    if (it->second->module_ == module) {
      return it->second;
    }
  }",57,,89,4,,void
125582,BLOCK,-1,,"{
      return it->second;
    }",40,,90,2,,void
125594,BLOCK,-1,,"{
  auto module_wrap_it = env->id_to_module_map.find(id);
  if (module_wrap_it == env->id_to_module_map.end()) {
    return nullptr;
  }
  return module_wrap_it->second;
}",66,,97,3,,void
125614,BLOCK,-1,,"{
    return nullptr;
  }",54,,99,2,,void
125625,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_GE(args.Length(), 3);

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Local<Object> that = args.This();

  CHECK(args[0]->IsString());
  Local<String> url = args[0].As<String>();

  Local<Context> context;
  ContextifyContext* contextify_context = nullptr;
  if (args[1]->IsUndefined()) {
    context = that->GetCreationContext().ToLocalChecked();
  } else {
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }

  int line_offset = 0;
  int column_offset = 0;

  bool synthetic = args[2]->IsArray();
  if (synthetic) {
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  } else {
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CH...",63,,107,2,,void
125697,BLOCK,-1,,"{
    context = that->GetCreationContext().ToLocalChecked();
  }",31,,121,2,,void
125708,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }",10,,123,1,,void
125756,BLOCK,-1,,"{
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  }",18,,135,2,,void
125765,BLOCK,-1,,"{
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CHECK(args[2]->IsString());
    CHECK(args[3]->IsNumber());
    line_offset = args[3].As<Int32>()->Value();
    CHECK(args[4]->IsNumber());
    column_offset = args[4].As<Int32>()->Value();
  }",10,,138,1,,void
125850,BLOCK,28,,"{
    Context::Scope context_scope(context);
    if (synthetic) {
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    } else {
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            ...",3,,157,28,,void
125856,BLOCK,-1,,"{
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    }",20,,159,2,,void
125894,BLOCK,-1,,<empty>,7,,165,1,,void
125904,BLOCK,4,,"{
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }",42,,165,4,,void
125944,BLOCK,-1,,"{
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }

      Local<String> source_text = args[2].As<String>();
      ScriptOrigin origin(isolate,
                          url,
                          line_offset,
                          column_offset,
                          true,                             // is cross origin
                          -1,                               // script id
                          Local<Value>(),                   // source map URL
                          false,                            // ...",12,,174,1,,void
125957,BLOCK,-1,,"{
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }",36,,176,2,,void
126042,BLOCK,-1,,"{
        options = ScriptCompiler::kNoCompileOptions;
      }",46,,200,2,,void
126049,BLOCK,-1,,"{
        options = ScriptCompiler::kConsumeCodeCache;
      }",14,,202,1,,void
126070,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }
        return;
      }",35,,206,2,,void
126082,BLOCK,-1,,"{
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }",66,,207,2,,void
126132,BLOCK,-1,,"{
        THROW_ERR_VM_MODULE_CACHED_DATA_REJECTED(
            env, ""cachedData buffer was rejected"");
        try_catch.ReThrow();
        return;
      }",45,,217,2,,void
126157,BLOCK,-1,,"{
    return;
  }",69,,226,2,,void
126170,BLOCK,-1,,"{
    obj->synthetic_ = true;
    obj->object()->SetInternalField(kSyntheticEvaluationStepsSlot, args[3]);
  }",18,,232,2,,void
126254,BLOCK,-1,,"{
  Local<Object> assertions =
        Object::New(isolate, v8::Null(env->isolate()), nullptr, nullptr, 0);
  for (int i = 0; i < raw_assertions->Length(); i += 3) {
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }

  return assertions;
}",55,,254,4,,void
126278,BLOCK,-1,,<empty>,3,,257,1,,void
126292,BLOCK,4,,"{
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }",57,,257,4,,void
126336,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());

  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  if (obj->linked_)
    return;
  obj->linked_ = true;

  Local<Function> resolver_arg = args[0].As<Function>();

  Local<Context> mod_context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  const int module_requests_length = module_requests->Length();
  MaybeStackBuffer<Local<Value>, 16> promises(module_requests_length);

  // call the dependency resolve callbacks
  for (int i = 0; i < module_requests_length; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
  ...",64,,268,2,,void
126384,BLOCK,-1,,<empty>,5,,281,2,,void
126447,BLOCK,-1,,<empty>,3,,294,1,,void
126457,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
    std::string specifier_std(*specifier_utf8, specifier_utf8.length());

    Local<FixedArray> raw_assertions = module_request->GetImportAssertions();
    Local<Object> assertions =
      createImportAssertionContainer(env, isolate, raw_assertions);

    Local<Value> argv[] = {
        specifier,
        assertions,
    };

    MaybeLocal<Value> maybe_resolve_return_value =
        resolver_arg->Call(mod_context, that, arraysize(argv), argv);
    if (maybe_resolve_return_value.IsEmpty()) {
      return;
    }
    Local<Value> resolve_return_value =
        maybe_resolve_return_value.ToLocalChecked();
    if (!resolve_return_value->IsPromise()) {
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std)...",52,,294,4,,void
126547,BLOCK,-1,,"{
      return;
    }",47,,312,2,,void
126565,BLOCK,-1,,"{
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std);
      return;
    }",45,,317,2,,void
126623,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);
  TryCatchScope try_catch(env);
  USE(module->InstantiateModule(context, ResolveModuleCallback));

  // clear resolve cache on instantiate
  obj->resolve_cache_.clear();

  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }
}",71,,332,2,,void
126697,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }",60,,345,2,,void
126738,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  ContextifyContext* contextify_context = obj->contextify_context_;
  std::shared_ptr<MicrotaskQueue> microtask_queue;
  if (contextify_context != nullptr)
      microtask_queue = contextify_context->microtask_queue();

  // module.evaluate(timeout, breakOnSigint)
  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsNumber());
  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();

  CHECK(args[1]->IsBoolean());
  bool break_on_sigint = args[1]->IsTrue();

  ShouldNotAbortOnUncaughtScope no_abort_scope(env);
  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());

  bool timed_out = false;
  bool received_signal = false;
  MaybeLocal<Value> result;
  auto run = [&]() {
    Ma...",68,,355,2,,void
126801,BLOCK,-1,,<empty>,7,,366,2,,void
126889,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",41,,390,2,,void
126905,BLOCK,-1,,<empty>,10,,394,1,,void
126908,BLOCK,-1,,"{
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",31,,394,2,,void
126918,BLOCK,-1,,<empty>,10,,397,1,,void
126924,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    result = run();
  }",29,,397,2,,void
126935,BLOCK,-1,,"{
    result = run();
  }",10,,400,1,,void
126944,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",25,,404,2,,void
126954,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,409,2,,void
126966,BLOCK,-1,,<empty>,7,,411,2,,void
126977,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,416,2,,void
126982,BLOCK,-1,,<empty>,12,,418,1,,void
126985,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,418,2,,void
126993,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,423,2,,void
127000,BLOCK,-1,,<empty>,7,,425,2,,void
127021,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  switch (module->GetStatus()) {
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> result = module->GetModuleNamespace();
  args.GetReturnValue().Set(result);
}",72,,432,2,,void
127063,BLOCK,-1,,"{
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }",32,,440,2,,void
127143,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  args.GetReturnValue().Set(module->GetStatus());
}",69,,458,2,,void
127187,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(env->isolate());

  Local<FixedArray> module_requests = module->GetModuleRequests();
  int count = module_requests->Length();

  MaybeStackBuffer<Local<Value>, 16> specifiers(count);

  for (int i = 0; i < count; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), specifiers.out(), count));
}",46,,469,2,,void
127241,BLOCK,-1,,<empty>,3,,481,1,,void
127251,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }",35,,481,4,,void
127302,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);
  args.GetReturnValue().Set(module->GetException());
}",68,,491,2,,void
127349,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }

  Isolate* isolate = env->isolate();

  Utf8Value specifier_utf8(isolate, specifier);
  std::string specifier_std(*specifier_utf8, specifier_utf8.length());

  ModuleWrap* dependent = GetFromModule(env, referrer);
  if (dependent == nullptr) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }

  if (dependent->resolve_cache_.count(specifier_std) != 1) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }

  Local<Promise> resolve_promise =
      dependent->resolve_cache_[specifier_std].Get(isolate);

  if (resolve_promise->State() != Promise::kFulfilled) {
    THROW_ERR_VM_MODULE_...",29,,504,5,,void
127362,BLOCK,-1,,"{
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }",23,,506,2,,void
127403,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }",29,,518,2,,void
127420,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }",60,,524,2,,void
127451,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not yet fulfilled"", specifier_std);
    return MaybeLocal<Module>();
  }",56,,533,2,,void
127482,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' did not return an object"", specifier_std);
    return MaybeLocal<Module>();
  }",62,,540,2,,void
127511,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }

  EscapableHandleScope handle_scope(isolate);

  Local<Function> import_callback =
    env->host_import_module_dynamically_callback();

  Local<FixedArray> options = host_defined_options.As<FixedArray>();
  if (options->Length() != HostDefinedOptions::kLength) {
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }

  Local<Value> object;

  int type = options->Get(context, HostDefinedOptions::kType)
                 .As<Number>()
                 ...",42,,556,6,,void
127531,BLOCK,-1,,"{
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }",23,,559,2,,void
127568,BLOCK,-1,,"{
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }",57,,570,2,,void
127590,BLOCK,-1,,<empty>,62,,572,2,,void
127674,BLOCK,-1,,"{
    contextify::ContextifyScript* wrap = env->id_to_script_map.find(id)->second;
    object = wrap->object();
  }",36,,591,2,,void
127694,BLOCK,-1,,<empty>,10,,594,1,,void
127701,BLOCK,-1,,"{
    ModuleWrap* wrap = ModuleWrap::GetFromID(env, id);
    object = wrap->object();
  }",43,,594,2,,void
127718,BLOCK,-1,,<empty>,10,,597,1,,void
127725,BLOCK,-1,,"{
    auto it = env->id_to_function_map.find(id);
    CHECK_NE(it, env->id_to_function_map.end());
    object = it->second->object();
  }",45,,597,2,,void
127753,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,601,1,,void
127797,BLOCK,-1,,"{
    CHECK(result->IsPromise());
    return handle_scope.Escape(result.As<Promise>());
  }",40,,619,2,,void
127818,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(isolate);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_callback = args[0].As<Function>();
  env->set_host_import_module_dynamically_callback(import_callback);

  isolate->SetHostImportModuleDynamicallyCallback(ImportModuleDynamically);
}",46,,628,2,,void
127878,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr)
    return;
  ModuleWrap* module_wrap = GetFromModule(env, module);

  if (module_wrap == nullptr) {
    return;
  }

  Local<Object> wrap = module_wrap->object();
  Local<Function> callback =
      env->host_initialize_import_meta_object_callback();
  Local<Value> args[] = { wrap, meta };
  TryCatchScope try_catch(env);
  USE(callback->Call(
        context, Undefined(env->isolate()), arraysize(args), args));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
  }
}",71,,642,4,,void
127891,BLOCK,-1,,<empty>,5,,645,2,,void
127903,BLOCK,-1,,"{
    return;
  }",31,,648,2,,void
127959,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,659,2,,void
127968,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_meta_callback = args[0].As<Function>();
  env->set_host_initialize_import_meta_object_callback(import_meta_callback);

  isolate->SetHostInitializeImportMetaObjectCallback(
      HostInitializeImportMetaObjectCallback);
}",46,,665,2,,void
128024,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  ModuleWrap* obj = GetFromModule(env, module);

  TryCatchScope try_catch(env);
  Local<Function> synthetic_evaluation_steps =
      obj->object()->GetInternalField(kSyntheticEvaluationStepsSlot)
          .As<Function>();
  obj->object()->SetInternalField(
      kSyntheticEvaluationStepsSlot, Undefined(isolate));
  MaybeLocal<Value> ret = synthetic_evaluation_steps->Call(context,
      obj->object(), 0, nullptr);
  if (ret.IsEmpty()) {
    CHECK(try_catch.HasCaught());
  }
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }

  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {
    return MaybeLocal<Value>();
  }

  resolver->Resolve(context, Undefined(isolate)).ToChecked();
  return resol...",51,,679,3,,void
128098,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",22,,693,2,,void
128115,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }",60,,696,2,,void
128161,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",60,,704,2,,void
128183,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(obj->synthetic_);

  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsString());
  Local<String> export_name = args[0].As<String>();

  Local<Value> export_value = args[1];

  Local<Module> module = obj->module_.Get(isolate);
  USE(module->SetSyntheticModuleExport(isolate, export_name, export_value));
}",78,,712,2,,void
128269,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(!obj->synthetic_);

  Local<Module> module = obj->module_.Get(isolate);

  CHECK_LT(module->GetStatus(), v8::Module::Status::kEvaluating);

  Local<UnboundModuleScript> unbound_module_script =
      module->GetUnboundModuleScript();
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));
  Environment* env = Environment::GetCurrent(args);
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",76,,732,2,,void
128334,BLOCK,-1,,<empty>,,,,2,,<empty>
128348,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,750,2,,void
128366,BLOCK,-1,,"{
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,752,1,,void
128404,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tpl = NewFunctionTemplate(isolate, New);
  tpl->InstanceTemplate()->SetInternalFieldCount(
      ModuleWrap::kInternalFieldCount);

  SetProtoMethod(isolate, tpl, ""link"", Link);
  SetProtoMethod(isolate, tpl, ""instantiate"", Instantiate);
  SetProtoMethod(isolate, tpl, ""evaluate"", Evaluate);
  SetProtoMethod(isolate, tpl, ""setExport"", SetSyntheticExport);
  SetProtoMethodNoSideEffect(
      isolate, tpl, ""createCachedData"", CreateCachedData);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getNamespace"", GetNamespace);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getStatus"", GetStatus);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getError"", GetError);
  SetProtoMethodNoSideEffect(isolate,
                             tpl,
                             ""getStaticDependencySpecifiers"",
                             GetStaticDependencySpecifiers);

  SetConstructorFunction(c...",41,,764,5,,void
128500,BLOCK,1,,<empty>,,,,3,,void
128529,BLOCK,1,,<empty>,,,,3,,void
128558,BLOCK,1,,<empty>,,,,3,,void
128587,BLOCK,1,,<empty>,,,,3,,void
128616,BLOCK,1,,<empty>,,,,3,,void
128645,BLOCK,1,,<empty>,,,,3,,void
128677,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Link);
  registry->Register(Instantiate);
  registry->Register(Evaluate);
  registry->Register(SetSyntheticExport);
  registry->Register(CreateCachedData);
  registry->Register(GetNamespace);
  registry->Register(GetStatus);
  registry->Register(GetError);
  registry->Register(GetStaticDependencySpecifiers);

  registry->Register(SetImportModuleDynamicallyCallback);
  registry->Register(SetInitializeImportMetaObjectCallback);
}",42,,812,2,,void
128753,BLOCK,-1,,<empty>,1,,1,1,,ANY
128757,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }",35,,255,2,,void
128778,BLOCK,-1,,{ env->set_embedder_entry_point({}); },28,,284,1,,void
128789,BLOCK,-1,,"{
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  }",45,,1265,1,,void
128805,BLOCK,-1,,"{
      delete snapshot_data;
    }",79,,1269,2,,void
128920,BLOCK,-1,,<empty>,1,,1,1,,ANY
128947,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  const char* message = ""(unknown event)"";
  switch (event) {
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }

  fprintf(stderr,
          ""(node:%d) [Thread %"" PRIu64 ""] Atomics.wait(%p + %zx, %"" PRId64
          "", %.f) %s\n"",
          static_cast<int>(uv_os_getpid()),
          env->thread_id(),
          array_buffer->Data(),
          offset_in_bytes,
          value,
          timeout_in_ms,
          message);
}",45,,220,8,,void
128960,BLOCK,-1,,"{
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }",18,,224,2,,void
128962,BLOCK,1,,<empty>,,,,1,,void
129027,BLOCK,-1,,"{
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
  if (heap_snapshot_near_heap_limit_ > 0) {
    AddHeapSnapshotNearHeapLimitCallback();
  }
  if (options_->trace_uncaught)
    isolate_->SetCaptureStackTraceForUncaughtExceptions(true);
  if (options_->trace_atomics_wait) {
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }
}",43,,245,1,,void
129043,BLOCK,-1,,"{
    AddHeapSnapshotNearHeapLimitCallback();
  }",43,,248,2,,void
129049,BLOCK,-1,,<empty>,5,,252,2,,void
129059,BLOCK,-1,,"{
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }",37,,253,2,,void
129074,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  CHECK_NOT_NULL(main_script_id);
  Realm* realm = env->principal_realm();

  return scope.EscapeMaybe(realm->ExecuteBootstrapper(main_script_id));
}",80,,263,3,,void
129104,BLOCK,-1,,"{
  InternalCallbackScope callback_scope(
      env,
      Object::New(env->isolate()),
      { 1, 0 },
      InternalCallbackScope::kSkipAsyncHooks);

  if (cb != nullptr) {
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->is_building_snapshot()
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }

  CHECK(!env->isolate_data()->is_building_snapshot());

  // TODO(joyeecheung): move these conditions into JS land and let the
  // deserialize main function take precedence. For workers, we need to
  // move the pre-execution part into a ...",79,,271,3,,void
129126,BLOCK,-1,,"{
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->is_building_snapshot()
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }",22,,278,2,,void
129186,BLOCK,-1,,"{
    return env->RunSnapshotDeserializeMain();
  }",52,,299,2,,void
129199,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/worker_thread"");
  }",41,,303,2,,void
129215,BLOCK,-1,,"{
    first_argv = env->argv()[1];
  }",31,,308,2,,void
129228,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/inspect"");
  }",32,,312,2,,void
129239,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/print_help"");
  }",45,,316,2,,void
129251,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/prof_process"");
  }",37,,320,2,,void
129271,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/eval_string"");
  }",71,,325,2,,void
129283,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/check_syntax"");
  }",42,,329,2,,void
129295,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/test_runner"");
  }",36,,333,2,,void
129307,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/watch_mode"");
  }",35,,337,2,,void
129322,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/run_main_module"");
  }",49,,341,2,,void
129339,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/repl"");
  }",78,,345,2,,void
129351,BLOCK,-1,,"{
#ifdef __POSIX__
  // Restore signal dispositions, the parent process may have changed them.
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
  // it evaluates to 32, 34 or 64, depending on whether RT signals are enabled.
  // Counting up to SIGRTMIN doesn't work for the same reason.
  for (unsigned nr = 1; nr < kMaxSignal; nr += 1) {
    if (nr == SIGKILL || nr == SIGSTOP)
      continue;
    act.sa_handler = (nr == SIGPIPE || nr == SIGXFSZ) ? SIG_IGN : SIG_DFL;
    if (act.sa_handler == SIG_DFL) {
      // The only bad handler value we can inhert from before exec is SIG_IGN
      // (any actual function pointer is reset to SIG_DFL during exec).
      // If that's the case, we want to reset it back to SIG_DFL.
      // However, it's also possible that an embeder (or an LD_PRELOAD-ed
      // library) has set up own signal handler for own purposes
      // (e.g. profiling). If that's the case, ...",28,,435,1,,void
129364,BLOCK,-1,,"{
  // init_process_flags is accessed in ResetStdio(),
  // which can be called from signal handlers.
  CHECK(init_process_flags.is_lock_free());
  init_process_flags.store(flags);

  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    atexit(ResetStdio);
  }

#ifdef __POSIX__
  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    // Disable stdio buffering, it interacts poorly with printf()
    // calls elsewhere in the program (e.g., any logging from V8.)
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);

    // Make sure file descriptors 0-2 are valid before we start logging
    // anything.
    for (auto& s : stdio) {
      const int fd = &s - stdio;
      if (fstat(fd, &s.stat) == 0) continue;

      // Anything but EBADF means something is seriously wrong.  We don't
      // have to special-case EINTR, fstat() is not interruptible.
      if (errno != EBADF) ABORT();

      // If EBADF (file descriptor doe...",67,,472,2,,void
129382,BLOCK,-1,,"{
    atexit(ResetStdio);
  }",70,,478,2,,void
129387,BLOCK,-1,,"{
  if (init_process_flags.load() &
      ProcessInitializationFlags::kNoStdioInitialization) {
    return;
  }

  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }

    bool is_same_file =
        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);
    if (!is_same_file) continue;  // Program reopened file descriptor.

    int flags;
    do
      flags = fcntl(fd, F_GETFL);
    while (flags == -1 && errno == EINTR);  // NOLINT
    CHECK_NE(flags, -1);

    // Restore the O_NONBLOCK flag if it changed.
    if (O_NONBLOCK & (flags ^ s.flags)) {
      flags &= ~O_NONBLOCK;
      flags |= s.flags & O_NONBLOCK;

      int err;
      do
        err = fcntl(fd, F_SETFL, flags);
      while (err == -1 && errno == EINTR);  // NOLINT
      CHECK_NE(err, -1);
    }

    if (s.isatty) {
      sigset...",19,,630,1,,void
129397,BLOCK,-1,,"{
    return;
  }",59,,632,2,,void
129407,BLOCK,-1,,"{
  // Parse a few arguments which are specific to Node.
  std::vector<std::string> v8_args;

  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  options_parser::Parse(
      args,
      exec_args,
      &v8_args,
      per_process::cli_options.get(),
      settings,
      errors);

  if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

  std::string revert_error;
  for (const std::string& cve : per_process::cli_options->security_reverts) {
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }

  if (per_process::cli_options->disable_proto != ""delete"" &&
      per_process::cli_options->disable_proto != ""throw"" &&
      per_process::cli_options->disable_proto != """") {
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): ...",74,,695,5,,void
129444,BLOCK,-1,,<empty>,25,,708,2,,void
129457,BLOCK,-1,,"{
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }",77,,711,3,,void
129471,BLOCK,-1,,"{
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }",32,,713,2,,void
129509,BLOCK,-1,,"{
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
    return ExitCode::kInvalidCommandLineArgument2;
  }",54,,722,2,,void
129538,BLOCK,-1,,"{
    v8_args.emplace_back(""--harmony-import-assertions"");
  }",69,,731,2,,void
129592,BLOCK,-1,,"{
    env_opts->abort_on_uncaught_exception = true;
  }",68,,739,2,,void
129611,BLOCK,-1,,"{
    for (size_t i = 0; i < v8_args.size(); ++i)
      v8_args_as_char_ptr[i] = v8_args[i].data();
    int argc = v8_args.size();
    V8::SetFlagsFromCommandLine(&argc, v8_args_as_char_ptr.data(), true);
    v8_args_as_char_ptr.resize(argc);
  }",27,,753,2,,void
129613,BLOCK,-1,,<empty>,5,,754,1,,void
129660,BLOCK,-1,,<empty>,3,,762,1,,void
129693,BLOCK,-1,,<empty>,5,,766,2,,void
129709,BLOCK,-1,,"{
  return static_cast<int>(
      ProcessGlobalArgsInternal(args, exec_args, errors, settings));
}",54,,774,5,,void
129730,BLOCK,-1,,"{
  // Make sure InitializeNodeWithArgs() is called only once.
  CHECK(!init_called.exchange(true));

  // Initialize node_start_time to get relative uptime.
  per_process::node_start_time = uv_hrtime();

  // Register built-in bindings
  binding::RegisterBuiltinBindings();

  // Make inherited handles noninheritable.
  if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
      !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    uv_disable_stdio_inheritance();
  }

  // Cache the original command line to be
  // used in diagnostic reports.
  per_process::cli_options->cmdline = *argv;

  // Node provides a ""v8.setFlagsFromString"" method to dynamically change flags.
  // Hence do not freeze flags when initializing V8. In a browser setting, this
  // is security relevant, for Node it's less important.
  V8::SetFlagsFromString(""--no-freeze-flags-after-init"");

#if defined(NODE_V8_OPTIONS)
  // Should come before the call to V8::SetFlagsFromCommandLine()...",46,,787,5,,void
129761,BLOCK,-1,,"{
    uv_disable_stdio_inheritance();
  }",70,,799,2,,void
129791,BLOCK,-1,,"{
    std::string node_options;

    if (credentials::SafeGetenv(""NODE_OPTIONS"", &node_options)) {
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }
  }",70,,822,2,,void
129801,BLOCK,-1,,"{
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }",65,,825,2,,void
129821,BLOCK,-1,,<empty>,29,,829,2,,void
129854,BLOCK,-1,,<empty>,46,,836,2,,void
129864,BLOCK,-1,,"{
    const ExitCode exit_code =
        ProcessGlobalArgsInternal(argv, exec_argv, errors, kDisallowedInEnvvar);
    if (exit_code != ExitCode::kNoFailure) return exit_code;
  }",66,,841,2,,void
129879,BLOCK,-1,,<empty>,44,,844,2,,void
129892,BLOCK,-1,,<empty>,5,,849,2,,void
129916,BLOCK,-1,,"{
  return static_cast<int>(
      InitializeNodeWithArgsInternal(argv, exec_argv, errors, flags));
}",69,,905,5,,void
129930,BLOCK,-1,,"{
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_process::cli_options->use_largepages == ""on"" ||
       per_process::cli_options->use_largepages == ""silent"")) {
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_...",76,,913,3,,void
129950,BLOCK,-1,,"{
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }",76,,917,2,,void
129959,BLOCK,6,,"{
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }",3,,926,6,,void
129987,BLOCK,-1,,"{
      result->early_return_ = true;
      return result;
    }",59,,929,2,,void
130018,BLOCK,-1,,"{
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }
  }",63,,937,2,,void
130038,BLOCK,-1,,"{
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }",77,,939,2,,void
130057,BLOCK,-1,,"{
    if (per_process::cli_options->print_version) {
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_bash_completion) {
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_v8_help) {
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }
  }",75,,944,2,,void
130064,BLOCK,-1,,"{
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,945,2,,void
130068,BLOCK,1,,<empty>,,,,1,,void
130090,BLOCK,-1,,"{
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",58,,952,2,,void
130124,BLOCK,-1,,"{
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,960,2,,void
130154,BLOCK,-1,,"{
#if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
    auto GetOpenSSLErrorString = []() -> std::string {
      std::string ret;
      ERR_print_errors_cb(
          [](const char* str, size_t len, void* opaque) {
            std::string* ret = static_cast<std::string*>(opaque);
            ret->append(str, len);
            ret->append(""\n"");
            return 0;
          },
          static_cast<void*>(&ret));
      return ret;
    };

    // In the case of FIPS builds we should make sure
    // the random source is properly initialized first.
#if OPENSSL_VERSION_MAJOR >= 3
    // Call OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
    // avoid the default behavior where errors raised during the parsing of the
    // OpenSSL configuration file are not propagated and cannot be detected.
    //
    // If FIPS is configured the OpenSSL configuration file will have an
    // .include pointing to the fipsmodule.cnf file generated by the openssl
    // fipsinstall com...",62,,968,2,,void
130162,BLOCK,-1,,"{
    per_process::v8_platform.Initialize(
        static_cast<int>(per_process::cli_options->v8_thread_pool_size));
    result->platform_ = per_process::v8_platform.Platform();
  }",75,,1078,2,,void
130193,BLOCK,-1,,"{
    V8::Initialize();
  }",63,,1084,2,,void
130215,BLOCK,-1,,"{
  return InitializeOncePerProcessInternal(args, flags);
}",46,,1096,3,,void
130223,BLOCK,-1,,"{
  const uint32_t flags = init_process_flags.load();
  ResetStdio();
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    ResetSignalHandlers();
  }

  per_process::v8_initialized = false;
  if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
    V8::Dispose();
  }

#if NODE_USE_V8_WASM_TRAP_HANDLER && defined(_WIN32)
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    RemoveVectoredExceptionHandler(per_process::old_vectored_exception_handler);
  }
#endif

  if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platfor...",31,,1100,1,,void
130239,BLOCK,-1,,"{
    ResetSignalHandlers();
  }",72,,1103,2,,void
130253,BLOCK,-1,,"{
    V8::Dispose();
  }",63,,1108,2,,void
130265,BLOCK,-1,,"{
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platform
    // will never be fully cleaned up.
    per_process::v8_platform.Dispose();
  }",75,,1118,2,,void
130279,BLOCK,-1,,<empty>,47,,1130,1,,void
130283,BLOCK,-1,,<empty>,55,,1131,1,,void
130289,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);

  // node:embedded_snapshot_main indicates that we are using the
  // embedded snapshot and we are not supposed to clean it up.
  const std::string& main_script = result->args()[1];
  if (main_script == ""node:embedded_snapshot_main"") {
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  } else {
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    std::str...",79,,1134,3,,void
130313,BLOCK,-1,,"{
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  }",53,,1142,2,,void
130326,BLOCK,-1,,"{
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }",40,,1144,2,,void
130338,BLOCK,-1,,"{
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    std::string main_script_content;
    int r = ReadFileSync(&main_script_content, main_script.c_str());
    if (r != 0) {
      FPrintF(stderr,
              ""Cannot read main script %s for building snapshot. %s: %s"",
              main_script,
              uv_err_name(r),
              uv_strerror(r));
      return ExitCode::kGenericUserError;
    }

    exit_code = node::SnapshotBuilder::Generate(generated_data.get(),
                                                result->args(),
                                                result->exec_args(),
                                                main_script_content);
    if (exit_code == ExitCode::kNoFailure) {
      *snapshot_data_ptr = generated_data.release();
    } else {
      return exit_code;
    }
  }",10,,1153,1,,void
130361,BLOCK,-1,,"{
      FPrintF(stderr,
              ""Cannot read main script %s for building snapshot. %s: %s"",
              main_script,
              uv_err_name(r),
              uv_strerror(r));
      return ExitCode::kGenericUserError;
    }",17,,1159,2,,void
130401,BLOCK,-1,,"{
      *snapshot_data_ptr = generated_data.release();
    }",44,,1172,2,,void
130410,BLOCK,-1,,"{
      return exit_code;
    }",12,,1174,1,,void
130424,BLOCK,-1,,"{
    snapshot_blob_path = per_process::cli_options->snapshot_blob;
  }",57,,1181,2,,void
130433,BLOCK,-1,,"{
    // Defaults to snapshot.blob in the current working directory.
    snapshot_blob_path = std::string(""snapshot.blob"");
  }",10,,1183,1,,void
130454,BLOCK,-1,,"{
    (*snapshot_data_ptr)->ToFile(fp);
    fclose(fp);
  }",22,,1189,2,,void
130464,BLOCK,-1,,"{
    fprintf(stderr,
            ""Cannot open %s for writing a snapshot.\n"",
            snapshot_blob_path.c_str());
    exit_code = ExitCode::kStartupSnapshotFailure;
  }",10,,1192,1,,void
130484,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);
  // --snapshot-blob indicates that we are reading a customized snapshot.
  if (!per_process::cli_options->snapshot_blob.empty()) {
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  } else if (per_process::cli_options->node_sn...",73,,1202,3,,void
130505,BLOCK,-1,,"{
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  }",57,,1207,2,,void
130527,BLOCK,-1,,"{
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",24,,1210,2,,void
130566,BLOCK,-1,,"{
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",14,,1218,2,,void
130582,BLOCK,-1,,<empty>,10,,1225,1,,void
130589,BLOCK,-1,,"{
    // If --snapshot-blob is not specified, we are reading the embedded
    // snapshot, but we will skip it if --no-node-snapshot is specified.
    const node::SnapshotData* read_data =
        SnapshotBuilder::GetEmbeddedSnapshotData();
    if (read_data != nullptr && read_data->Check()) {
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }
  }",55,,1225,2,,void
130606,BLOCK,-1,,"{
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }",53,,1230,2,,void
130643,BLOCK,-1,,"{
  CHECK_GT(argc, 0);

  // Hack around with the argv pointer. Used for process.title = ""blah"".
  argv = uv_setup_args(argc, argv);

  std::unique_ptr<InitializationResultImpl> result =
      InitializeOncePerProcessInternal(
          std::vector<std::string>(argv, argv + argc));
  for (const std::string& error : result->errors()) {
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }
  if (result->early_return()) {
    return result->exit_code_enum();
  }

  DCHECK_EQ(result->exit_code_enum(), ExitCode::kNoFailure);
  const SnapshotData* snapshot_data = nullptr;

  auto cleanup_process = OnScopeLeave([&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  });

  uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);

  std::string sea_config = per_process::cli_options->experimental_sea_config;
  if (!sea_config.empty()) {
    ret...",54,,1246,3,,void
130676,BLOCK,-1,,"{
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }",53,,1255,3,,void
130694,BLOCK,-1,,"{
    return result->exit_code_enum();
  }",31,,1258,2,,void
130733,BLOCK,-1,,"{
    return sea::BuildSingleExecutableBlob(sea_config);
  }",28,,1277,2,,void
130748,BLOCK,-1,,"{
    if (result->args().size() < 2) {
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }
    return GenerateAndWriteSnapshotData(&snapshot_data, result.get());
  }",62,,1282,2,,void
130759,BLOCK,-1,,"{
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }",36,,1283,2,,void
130788,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",34,,1296,3,,void
130813,BLOCK,-1,,"{
  env->ExitEnv(flags);
  return 0;
}",52,,1303,3,,void
130824,BLOCK,-1,,<empty>,19,,1311,1,,void
130831,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }",64,,913,2,,void
130856,BLOCK,-1,,"{
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }",64,,936,2,,void
130902,BLOCK,-1,,<empty>,1,,1,1,,ANY
130914,BLOCK,-1,,<empty>,,,,6,,<empty>
130924,BLOCK,-1,,<empty>,,,,7,,<empty>
130932,BLOCK,-1,,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8::Local<v8::Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8::Isolate::GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",1,,151,5,,void
130952,BLOCK,-1,,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8::Local<v8::Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8::Isolate::GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",1,,164,5,,void
130973,BLOCK,-1,,<empty>,,,,6,,<empty>
130982,BLOCK,-1,,<empty>,,,,6,,<empty>
131008,BLOCK,-1,,<empty>,,,,1,,<empty>
131104,BLOCK,-1,,<empty>,,,,1,,<empty>
131117,BLOCK,-1,,<empty>,,,,1,,<empty>
131121,BLOCK,-1,,<empty>,,,,1,,<empty>
131125,BLOCK,-1,,<empty>,,,,1,,<empty>
131129,BLOCK,-1,,<empty>,,,,1,,<empty>
131133,BLOCK,-1,,<empty>,,,,1,,<empty>
131137,BLOCK,-1,,<empty>,,,,1,,<empty>
131141,BLOCK,-1,,<empty>,,,,1,,<empty>
131145,BLOCK,-1,,<empty>,,,,1,,<empty>
131152,BLOCK,-1,,<empty>,,,,3,,<empty>
131158,BLOCK,-1,,<empty>,,,,3,,<empty>
131166,BLOCK,-1,,<empty>,,,,5,,<empty>
131172,BLOCK,-1,,<empty>,,,,3,,<empty>
131176,BLOCK,-1,,<empty>,,,,1,,<empty>
131182,BLOCK,-1,,"{
  uint64_t flags_accum = ProcessInitializationFlags::kNoFlags;
  for (const auto flag : list) flags_accum |= static_cast<uint64_t>(flag);
  return InitializeOncePerProcess(
      args, static_cast<ProcessInitializationFlags::Flags>(flags_accum));
}",68,,356,3,,void
131211,BLOCK,-1,,<empty>,,,,1,,<empty>
131231,BLOCK,-1,,<empty>,,,,5,,<empty>
131238,BLOCK,-1,,<empty>,,,,2,,<empty>
131242,BLOCK,-1,,<empty>,,,,1,,<empty>
131247,BLOCK,-1,,<empty>,,,,1,,<empty>
131252,BLOCK,-1,,<empty>,,,,2,,<empty>
131257,BLOCK,-1,,<empty>,,,,1,,<empty>
131261,BLOCK,-1,,<empty>,,,,1,,<empty>
131266,BLOCK,-1,,<empty>,,,,1,,<empty>
131271,BLOCK,-1,,<empty>,,,,2,,<empty>
131276,BLOCK,-1,,<empty>,,,,2,,<empty>
131282,BLOCK,-1,,<empty>,,,,3,,<empty>
131288,BLOCK,-1,,<empty>,,,,3,,<empty>
131293,BLOCK,-1,,<empty>,,,,2,,<empty>
131300,BLOCK,-1,,<empty>,,,,4,,<empty>
131307,BLOCK,-1,,<empty>,,,,4,,<empty>
131317,BLOCK,-1,,<empty>,,,,1,,<empty>
131353,BLOCK,-1,,<empty>,,,,1,,<empty>
131390,BLOCK,-1,,<empty>,,,,2,,<empty>
131395,BLOCK,-1,,<empty>,,,,1,,<empty>
131400,BLOCK,-1,,<empty>,,,,2,,<empty>
131405,BLOCK,-1,,<empty>,,,,2,,<empty>
131410,BLOCK,-1,,<empty>,,,,2,,<empty>
131414,BLOCK,-1,,<empty>,,,,1,,<empty>
131418,BLOCK,-1,,<empty>,,,,1,,<empty>
131423,BLOCK,-1,,<empty>,,,,2,,<empty>
131428,BLOCK,-1,,<empty>,,,,2,,<empty>
131433,BLOCK,-1,,<empty>,,,,2,,<empty>
131438,BLOCK,-1,,<empty>,,,,2,,<empty>
131444,BLOCK,-1,,<empty>,,,,3,,<empty>
131454,BLOCK,-1,,<empty>,,,,3,,<empty>
131459,BLOCK,-1,,<empty>,,,,2,,<empty>
131468,BLOCK,-1,,<empty>,,,,6,,<empty>
131477,BLOCK,-1,,<empty>,,,,6,,<empty>
131483,BLOCK,-1,,<empty>,,,,3,,<empty>
131488,BLOCK,-1,,<empty>,,,,2,,<empty>
131497,BLOCK,-1,,<empty>,,,,6,,<empty>
131502,BLOCK,-1,,<empty>,,,,2,,<empty>
131508,BLOCK,-1,,<empty>,,,,1,,<empty>
131518,BLOCK,-1,,<empty>,,,,1,,<empty>
131535,BLOCK,-1,,<empty>,,,,1,,<empty>
131593,BLOCK,-1,,<empty>,,,,1,,<empty>
131604,BLOCK,-1,,<empty>,,,,8,,<empty>
131611,BLOCK,-1,,<empty>,,,,4,,<empty>
131619,BLOCK,-1,,<empty>,,,,5,,<empty>
131630,BLOCK,-1,,<empty>,,,,3,,<empty>
131636,BLOCK,-1,,<empty>,,,,3,,<empty>
131641,BLOCK,-1,,<empty>,,,,2,,<empty>
131647,BLOCK,-1,,<empty>,,,,3,,<empty>
131653,BLOCK,-1,,<empty>,,,,3,,<empty>
131658,BLOCK,-1,,<empty>,,,,2,,<empty>
131663,BLOCK,-1,,<empty>,,,,2,,<empty>
131668,BLOCK,-1,,<empty>,,,,2,,<empty>
131673,BLOCK,-1,,<empty>,,,,2,,<empty>
131679,BLOCK,-1,,<empty>,,,,3,,<empty>
131684,BLOCK,-1,,<empty>,,,,2,,<empty>
131690,BLOCK,-1,,<empty>,,,,3,,<empty>
131695,BLOCK,-1,,<empty>,,,,2,,<empty>
131702,BLOCK,-1,,<empty>,,,,4,,<empty>
131711,BLOCK,-1,,<empty>,,,,6,,<empty>
131720,BLOCK,-1,,<empty>,,,,6,,<empty>
131729,BLOCK,-1,,<empty>,,,,6,,<empty>
131738,BLOCK,-1,,<empty>,,,,6,,<empty>
131743,BLOCK,-1,,<empty>,,,,2,,<empty>
131748,BLOCK,-1,,<empty>,,,,2,,<empty>
131754,BLOCK,-1,,<empty>,,,,3,,<empty>
131759,BLOCK,-1,,<empty>,,,,2,,<empty>
131763,BLOCK,-1,,<empty>,,,,1,,<empty>
131768,BLOCK,-1,,<empty>,,,,2,,<empty>
131773,BLOCK,-1,,<empty>,,,,2,,<empty>
131778,BLOCK,-1,,<empty>,,,,2,,<empty>
131783,BLOCK,-1,,<empty>,,,,2,,<empty>
131788,BLOCK,-1,,<empty>,,,,2,,<empty>
131793,BLOCK,-1,,<empty>,,,,2,,<empty>
131800,BLOCK,-1,,<empty>,,,,2,,<empty>
131804,BLOCK,-1,,<empty>,,,,1,,<empty>
131809,BLOCK,-1,,<empty>,,,,1,,<empty>
131816,BLOCK,-1,,<empty>,,,,4,,<empty>
131824,BLOCK,-1,,<empty>,,,,5,,<empty>
131832,BLOCK,-1,,<empty>,,,,5,,<empty>
131836,BLOCK,-1,,<empty>,,,,1,,<empty>
131842,BLOCK,-1,,<empty>,,,,1,,<empty>
131846,BLOCK,-1,,<empty>,,,,1,,<empty>
131850,BLOCK,-1,,<empty>,,,,1,,<empty>
131854,BLOCK,-1,,<empty>,,,,1,,<empty>
131858,BLOCK,-1,,<empty>,,,,1,,<empty>
131862,BLOCK,-1,,<empty>,,,,1,,<empty>
131867,BLOCK,-1,,<empty>,,,,2,,<empty>
131872,BLOCK,-1,,<empty>,,,,2,,<empty>
131877,BLOCK,-1,,<empty>,,,,2,,<empty>
131882,BLOCK,-1,,<empty>,,,,2,,<empty>
131889,BLOCK,-1,,<empty>,,,,1,,<empty>
131904,BLOCK,-1,,<empty>,,,,4,,<empty>
131913,BLOCK,-1,,<empty>,,,,6,,<empty>
131919,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform, errors,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,910,4,,void
131940,BLOCK,-1,,<empty>,25,,918,2,,void
131953,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      snapshot_data,
      Flags::kNoFlags,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,930,5,,void
131978,BLOCK,-1,,<empty>,25,,941,2,,void
131989,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::New() directly"",
                inline v8::Local<v8::Value> NODE_UNIXTIME_V8(double time) {
                  return v8::Date::New(
                             v8::Isolate::GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",1,,946,2,,void
132016,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8::Local<v8::Date> date) {
  return date->ValueOf() / 1000;
})",1,,954,2,,void
132030,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->Set(fn_name, t);
}",60,,1002,4,,void
132104,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::Function> fn = t->GetFunction(context).ToLocalChecked();
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  fn->SetName(fn_name);
  recv->Set(context, fn_name, fn).Check();
}",60,,1016,4,,void
132214,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
  v8::Local<v8::FunctionTemplate> t =
      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->PrototypeTemplate()->Set(fn_name, t);
}",70,,1034,4,,void
132321,BLOCK,-1,,<empty>,,,,1,,<empty>
132332,BLOCK,-1,,<empty>,,,,3,,<empty>
132340,BLOCK,-1,,<empty>,,,,5,,<empty>
132347,BLOCK,-1,,<empty>,,,,4,,<empty>
132354,BLOCK,-1,,<empty>,,,,4,,<empty>
132363,BLOCK,-1,,<empty>,,,,6,,<empty>
132368,BLOCK,-1,,<empty>,,,,2,,<empty>
132375,BLOCK,-1,,<empty>,,,,4,,<empty>
132383,BLOCK,-1,,<empty>,,,,5,,<empty>
132389,BLOCK,-1,,<empty>,,,,1,,<empty>
132408,BLOCK,-1,,<empty>,,,,2,,<empty>
132414,BLOCK,-1,,<empty>,,,,3,,<empty>
132420,BLOCK,-1,,<empty>,,,,3,,<empty>
132428,BLOCK,-1,,<empty>,,,,5,,<empty>
132436,BLOCK,-1,,<empty>,,,,5,,<empty>
132443,BLOCK,-1,,<empty>,,,,4,,<empty>
132454,BLOCK,-1,,<empty>,,,,4,,<empty>
132461,BLOCK,-1,,<empty>,,,,4,,<empty>
132468,BLOCK,-1,,<empty>,,,,2,,<empty>
132476,BLOCK,-1,,<empty>,,,,4,,<empty>
132483,BLOCK,-1,,"{
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",16,,1302,4,,void
132494,BLOCK,-1,,<empty>,,,,2,,<empty>
132499,BLOCK,-1,,"{
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",73,,1310,2,,void
132511,BLOCK,-1,,<empty>,,,,4,,<empty>
132516,BLOCK,-1,,<empty>,,,,2,,<empty>
132521,BLOCK,-1,,<empty>,,,,2,,<empty>
132529,BLOCK,-1,,<empty>,,,,5,,<empty>
132537,BLOCK,-1,,<empty>,,,,5,,<empty>
132543,BLOCK,-1,,<empty>,,,,3,,<empty>
132549,BLOCK,-1,,<empty>,,,,3,,<empty>
132558,BLOCK,-1,,<empty>,,,,4,,<empty>
132565,BLOCK,-1,,<empty>,,,,4,,<empty>
132569,BLOCK,-1,,<empty>,,,,1,,<empty>
132574,BLOCK,-1,,<empty>,,,,2,,<empty>
132579,BLOCK,-1,,<empty>,,,,2,,<empty>
132584,BLOCK,-1,,<empty>,,,,2,,<empty>
132589,BLOCK,-1,,<empty>,,,,2,,<empty>
132601,BLOCK,-1,,<empty>,,,,7,,<empty>
132611,BLOCK,-1,,<empty>,,,,7,,<empty>
132620,BLOCK,-1,,<empty>,,,,5,,<empty>
132624,BLOCK,-1,,<empty>,,,,1,,<empty>
132629,BLOCK,-1,,<empty>,,,,2,,<empty>
132634,BLOCK,-1,,<empty>,,,,2,,<empty>
132641,BLOCK,-1,,<empty>,,,,4,,<empty>
132648,BLOCK,-1,,<empty>,,,,4,,<empty>
132652,BLOCK,-1,,<empty>,,,,1,,<empty>
132656,BLOCK,-1,,<empty>,,,,1,,<empty>
132660,BLOCK,-1,,<empty>,,,,1,,<empty>
132666,BLOCK,-1,,<empty>,,,,2,,<empty>
132676,BLOCK,-1,,<empty>,,,,4,,<empty>
132682,BLOCK,-1,,"{ cb(env, data, hint); }",25,,48,2,,void
132695,BLOCK,-1,,"{
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",66,,60,2,,void
132707,BLOCK,-1,,"{
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",74,,90,3,,void
132719,BLOCK,-1,,"{
      return;
    }",41,,92,2,,void
132739,BLOCK,-1,,"{
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }",42,,97,2,,void
132755,BLOCK,-1,,{ static_cast<napi_env>(arg)->Unref(); },21,,193,2,,void
132767,BLOCK,-1,,"{
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",43,,318,2,,void
132790,BLOCK,-1,,"{ call_js_cb(env, js_callback, context, data); }",29,,416,2,,void
132803,BLOCK,-1,,"{
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",41,,446,2,,void
132827,BLOCK,-1,,"{
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",41,,726,2,,void
132845,BLOCK,-1,,{ env->Unref(); },42,,801,2,,void
132856,BLOCK,-1,,"{
      _complete(env, ConvertUVErrorCode(status), _data);
    }",54,,1195,2,,void
132905,BLOCK,-1,,<empty>,1,,1,1,,ANY
132910,BLOCK,-1,,"{
  CHECK_NOT_NULL(node_env());
}",74,,25,4,,void
132916,BLOCK,-1,,"{
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",34,,29,1,,void
132928,BLOCK,-1,,"{
  return node_env()->can_call_into_js();
}",48,,35,1,,void
132940,BLOCK,-1,,"{
  CallFinalizer<true>(cb, data, hint);
}",79,,39,4,,void
132949,BLOCK,-1,,"{
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context());
  CallbackIntoModule<enforceUncaughtExceptionPolicy>(
      [&](napi_env env) { cb(env, data, hint); });
}",79,,44,4,,void
132962,BLOCK,-1,,"{
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",71,,51,2,,void
132974,BLOCK,-1,,"{
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }",48,,57,2,,void
132987,BLOCK,-1,,"{
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",45,,68,1,,void
132994,BLOCK,-1,,"{
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }",39,,72,2,,void
133016,BLOCK,-1,,"{
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",79,,79,2,,void
133048,BLOCK,-1,,"{
  CallIntoModule(call, [](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  });
}",52,,89,2,,void
133062,BLOCK,-1,,"{
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }",62,,122,5,,void
133075,BLOCK,-1,,"{
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }",62,,127,3,,void
133094,BLOCK,-1,,<empty>,51,,133,2,,void
133116,BLOCK,-1,,{ delete finalizer; },49,,140,2,,void
133126,BLOCK,-1,,"{
    env_->Ref();
  }",73,,148,5,,void
133134,BLOCK,-1,,{ env_->Unref(); },22,,152,1,,void
133145,BLOCK,-1,,"{
  std::string error_message;
  error_message += module_name;
  error_message += "" requires Node-API version "";
  error_message += std::to_string(module_api_version);
  error_message += "", but this version of Node.js only supports version "";
  error_message += NODE_STRINGIFY(NAPI_VERSION) "" add-ons."";
  node_env->ThrowError(error_message.c_str());
}",59,,157,4,,void
133166,BLOCK,1,,<empty>,,,,1,,void
133182,BLOCK,-1,,"{
  node_napi_env result;

  // Validate module_api_version.
  if (module_api_version < NODE_API_DEFAULT_MODULE_API_VERSION) {
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  } else if (module_api_version > NAPI_VERSION &&
             module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }

  result = new node_napi_env__(context, module_filename, module_api_version);
  // TODO(addaleax): There was previously code that tried to delete the
  // napi_env when its v8::Context was garbage collected;
  // However, as long as N-API addons using this napi_env are in place,
  // the Context needs to be accessible and alive.
  // Ideally, we'd want an on-addon-unload hook that takes care of this
  // once all N-API addons using this napi_env are unloaded.
  // Fo...",52,,169,4,,void
133188,BLOCK,1,,<empty>,,,,1,,void
133190,BLOCK,-1,,"{
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  }",65,,173,2,,void
133194,BLOCK,1,,<empty>,,,,1,,void
133197,BLOCK,-1,,<empty>,10,,175,1,,void
133203,BLOCK,1,,<empty>,,,,1,,void
133208,BLOCK,1,,<empty>,,,,1,,void
133210,BLOCK,-1,,"{
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }",63,,176,2,,void
133265,BLOCK,-1,,"{
    ref.Reset(env->isolate, func);
    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Ref();
  }",32,,223,11,,void
133290,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",34,,229,1,,void
133309,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",73,,236,3,,void
133329,BLOCK,-1,,"{
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }",25,,240,2,,void
133334,BLOCK,-1,,"{
        return napi_queue_full;
      }",42,,241,2,,void
133344,BLOCK,-1,,"{
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    }",21,,247,2,,void
133349,BLOCK,-1,,"{
        return napi_invalid_arg;
      }",30,,248,2,,void
133353,BLOCK,-1,,"{
        thread_count--;
        return napi_closing;
      }",14,,250,1,,void
133359,BLOCK,-1,,"{
      queue.push(data);
      Send();
      return napi_ok;
    }",12,,254,1,,void
133371,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",25,,261,1,,void
133379,BLOCK,-1,,"{
      return napi_closing;
    }",21,,264,2,,void
133390,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",67,,273,2,,void
133400,BLOCK,-1,,"{
      return napi_invalid_arg;
    }",28,,276,2,,void
133413,BLOCK,-1,,"{
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }",55,,282,2,,void
133417,BLOCK,-1,,"{
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }",24,,283,2,,void
133429,BLOCK,-1,,"{
          cond->Signal(lock);
        }",47,,285,2,,void
133441,BLOCK,-1,,"{
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",30,,295,1,,void
133443,BLOCK,-1,,<empty>,5,,296,1,,void
133453,BLOCK,4,,"{
      call_js_cb(nullptr, nullptr, context, queue.front());
    }",41,,296,4,,void
133467,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",22,,304,1,,void
133490,BLOCK,-1,,"{
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }",52,,308,2,,void
133495,BLOCK,-1,,"{
        cond = std::make_unique<node::ConditionVariable>();
      }",31,,309,2,,void
133508,BLOCK,-1,,"{
        return napi_ok;
      }",40,,312,2,,void
133533,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",23,,335,1,,void
133544,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",21,,341,1,,void
133555,BLOCK,-1,,{ return context; },26,,347,1,,void
133561,BLOCK,-1,,"{
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",19,,350,1,,void
133577,BLOCK,-1,,"{
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }",48,,356,2,,void
133592,BLOCK,-1,,"{
        has_more = true;
      }",71,,361,2,,void
133598,BLOCK,-1,,"{
      Send();
    }",19,,366,2,,void
133603,BLOCK,-1,,"{
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Func...",22,,371,1,,void
133615,BLOCK,7,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }",5,,376,7,,void
133623,BLOCK,-1,,"{
        CloseHandlesAndMaybeDelete();
      }",23,,378,2,,void
133626,BLOCK,-1,,"{
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }",14,,380,1,,void
133638,BLOCK,-1,,"{
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }",23,,382,2,,void
133660,BLOCK,-1,,"{
            cond->Signal(lock);
          }",61,,386,2,,void
133672,BLOCK,-1,,"{
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        }",24,,392,2,,void
133677,BLOCK,-1,,"{
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }",34,,393,2,,void
133685,BLOCK,-1,,"{
              cond->Signal(lock);
            }",37,,395,2,,void
133693,BLOCK,-1,,"{
          has_more = true;
        }",16,,400,1,,void
133699,BLOCK,-1,,"{
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }
      env->CallbackIntoModule<false>(
          [&](napi_env env) { call_js_cb(env, js_callback, context, data); });
    }",23,,406,2,,void
133717,BLOCK,-1,,"{
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }",27,,410,2,,void
133761,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",19,,422,1,,void
133769,BLOCK,-1,,"{
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }",22,,424,2,,void
133785,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",61,,431,2,,void
133793,BLOCK,-1,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }",22,,433,2,,void
133806,BLOCK,-1,,"{
        cond->Signal(lock);
      }",31,,436,2,,void
133814,BLOCK,-1,,"{
      return;
    }",26,,440,2,,void
133834,BLOCK,-1,,"{
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",15,,454,1,,void
133849,BLOCK,-1,,"{
      return;
    }",65,,457,2,,void
133863,BLOCK,-1,,"{
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",78,,466,5,,void
133873,BLOCK,-1,,"{
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }",45,,467,2,,void
133886,BLOCK,-1,,"{
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }",30,,472,2,,void
133909,BLOCK,-1,,"{
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }",66,,480,2,,void
133919,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",42,,488,2,,void
133940,BLOCK,-1,,"{
    reinterpret_cast<ThreadSafeFunction*>(data)->CloseHandlesAndMaybeDelete(
        true);
  }",35,,494,2,,void
133970,BLOCK,-1,,<empty>,,,,1,,<empty>
133995,BLOCK,-1,,"{
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",19,,541,5,,void
134022,BLOCK,-1,,"{
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }",38,,546,2,,void
134050,BLOCK,-1,,"{
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",19,,558,1,,void
134073,BLOCK,-1,,"{
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",36,,568,5,,void
134092,BLOCK,-1,,"{
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",50,,579,1,,void
134111,BLOCK,-1,,"{
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",33,,587,1,,void
134114,BLOCK,-1,,"{
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }",26,,588,2,,void
134145,BLOCK,-1,,{ return env_->node_env(); },40,,596,1,,void
134154,BLOCK,-1,,"{
    return resource_.Get(node_env()->isolate());
  }",43,,597,1,,void
134167,BLOCK,-1,,"{
    return {async_id_, trigger_async_id_};
  }",46,,600,1,,void
134174,BLOCK,-1,,"{
    CallbackScope* callback_scope = reinterpret_cast<CallbackScope*>(s);
    delete callback_scope;
    env->open_callback_scopes--;
  }",64,,605,3,,void
134191,BLOCK,-1,,"{
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",76,,611,2,,void
134215,BLOCK,-1,,<empty>,63,,624,2,,void
134228,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",49,,644,5,,void
134245,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",56,,656,5,,void
134260,BLOCK,-1,,"{
  static_assert(
      NAPI_VERSION == 9,
      ""New version of Node-API requires adding another else-if statement below ""
      ""for the new version and updating this assert condition."");
  if (module_api_version <= NODE_API_DEFAULT_MODULE_API_VERSION) {
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  } else if (module_api_version == 9) {
    return node_api_context_register_func<9>;
  } else if (module_api_version == NAPI_VERSION_EXPERIMENTAL) {
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  } else {
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }
}",33,,674,4,,void
134264,BLOCK,1,,<empty>,,,,1,,void
134272,BLOCK,1,,<empty>,,,,1,,void
134274,BLOCK,-1,,"{
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  }",66,,679,2,,void
134278,BLOCK,-1,,<empty>,10,,681,1,,void
134283,BLOCK,-1,,"{
    return node_api_context_register_func<9>;
  }",39,,681,2,,void
134287,BLOCK,-1,,<empty>,10,,683,1,,void
134292,BLOCK,1,,<empty>,,,,1,,void
134294,BLOCK,-1,,"{
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  }",63,,683,2,,void
134298,BLOCK,-1,,"{
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }",10,,685,1,,void
134315,BLOCK,-1,,"{
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
      modobj->Get(context, node_env->filename_string()).ToLocal(&filename_js) &&
      filename_js->IsString()) {
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filena...",65,,695,6,,void
134334,BLOCK,-1,,"{
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }",24,,698,2,,void
134392,BLOCK,-1,,"{
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filename` through unchanged if/when we
    // receive it as a URL already.
    module_filename = node::url::FromFilePath(filename.ToStringView());
  }",32,,712,2,,void
134441,BLOCK,-1,,"{
    napi_value _module = v8impl::JsValueFromV8LocalValue(module);
    napi_set_named_property(env, _module, ""exports"", _exports);
  }",61,,734,2,,void
134460,BLOCK,-1,,"{
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",64,,741,2,,void
134466,BLOCK,-1,,"{
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",56,,757,2,,void
134488,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",61,,765,4,,void
134491,BLOCK,1,,<empty>,,,,2,,void
134493,BLOCK,-1,,CHECK_ENV(env),3,,766,1,,void
134498,BLOCK,-1,,CHECK_ENV(env),3,,766,2,,void
134505,BLOCK,1,,<empty>,,,,3,,void
134507,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,767,1,,void
134513,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,767,2,,void
134536,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",64,,776,4,,void
134539,BLOCK,1,,<empty>,,,,2,,void
134541,BLOCK,-1,,CHECK_ENV(env),3,,777,1,,void
134546,BLOCK,-1,,CHECK_ENV(env),3,,777,2,,void
134553,BLOCK,1,,<empty>,,,,3,,void
134555,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,778,1,,void
134561,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,778,2,,void
134584,BLOCK,-1,,"{
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",65,,789,4,,void
134603,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",39,,794,1,,void
134617,BLOCK,-1,,<empty>,30,,796,2,,void
134636,BLOCK,-1,,"{
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",73,,804,4,,void
134669,BLOCK,-1,,<empty>,,,,2,,<empty>
134674,BLOCK,-1,,<empty>,,,,1,,<empty>
134697,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",76,,824,5,,void
134700,BLOCK,1,,<empty>,,,,2,,void
134702,BLOCK,-1,,CHECK_ENV(env),3,,825,1,,void
134707,BLOCK,-1,,CHECK_ENV(env),3,,825,2,,void
134714,BLOCK,1,,<empty>,,,,3,,void
134716,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,826,1,,void
134722,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,826,2,,void
134740,BLOCK,-1,,<empty>,33,,831,2,,void
134752,BLOCK,-1,,"{
  if (remove_handle == nullptr) return napi_invalid_arg;

  delete remove_handle;

  return napi_ok;
}",78,,837,2,,void
134757,BLOCK,-1,,<empty>,33,,838,2,,void
134769,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",75,,845,3,,void
134772,BLOCK,1,,<empty>,,,,2,,void
134774,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134779,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134784,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134793,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134800,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134807,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134828,BLOCK,1,,<empty>,,,,3,,void
134830,BLOCK,-1,,"CHECK_ARG(env, err)",3,,847,1,,void
134836,BLOCK,-1,,"CHECK_ARG(env, err)",3,,847,2,,void
134874,BLOCK,-1,,"{
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",69,,858,5,,void
134881,BLOCK,1,,<empty>,,,,1,,void
134883,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), location_len);
  }",41,,862,2,,void
134893,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), strlen(location));
  }",10,,864,1,,void
134907,BLOCK,1,,<empty>,,,,1,,void
134909,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), message_len);
  }",40,,868,2,,void
134919,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), strlen(message));
  }",10,,870,1,,void
134948,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",55,,881,5,,void
134951,BLOCK,1,,<empty>,,,,2,,void
134953,BLOCK,-1,,CHECK_ENV(env),3,,884,1,,void
134958,BLOCK,-1,,CHECK_ENV(env),3,,884,2,,void
134965,BLOCK,1,,<empty>,,,,3,,void
134967,BLOCK,-1,,"CHECK_ARG(env, result)",3,,885,1,,void
134973,BLOCK,-1,,"CHECK_ARG(env, result)",3,,885,2,,void
135000,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",77,,896,3,,void
135003,BLOCK,1,,<empty>,,,,2,,void
135005,BLOCK,-1,,CHECK_ENV(env),3,,899,1,,void
135010,BLOCK,-1,,CHECK_ENV(env),3,,899,2,,void
135017,BLOCK,1,,<empty>,,,,3,,void
135019,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,900,1,,void
135025,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,900,2,,void
135037,BLOCK,-1,,"{
    return napi_callback_scope_mismatch;
  }",39,,901,2,,void
135060,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                               v8_resource,
                               v8_resource_name,
                               externally_managed_resource);

  *result = reinterpret_cast<napi_async_context>(async_context);

  return napi_clear_last_error(env);
}",68,,914,5,,void
135063,BLOCK,1,,<empty>,,,,2,,void
135065,BLOCK,-1,,CHECK_ENV(env),3,,915,1,,void
135070,BLOCK,-1,,CHECK_ENV(env),3,,915,2,,void
135077,BLOCK,1,,<empty>,,,,3,,void
135079,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,916,1,,void
135085,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,916,2,,void
135094,BLOCK,1,,<empty>,,,,3,,void
135096,BLOCK,-1,,"CHECK_ARG(env, result)",3,,917,1,,void
135102,BLOCK,-1,,"CHECK_ARG(env, result)",3,,917,2,,void
135142,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  }",34,,924,2,,void
135149,BLOCK,1,,<empty>,,,,7,,void
135151,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
135153,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
135159,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,2,,void
135178,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
135186,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,2,,void
135203,BLOCK,-1,,"{
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }",10,,927,1,,void
135231,BLOCK,1,,<empty>,,,,7,,void
135233,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
135235,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
135241,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,2,,void
135260,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
135268,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,2,,void
135306,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",77,,947,3,,void
135309,BLOCK,1,,<empty>,,,,2,,void
135311,BLOCK,-1,,CHECK_ENV(env),3,,948,1,,void
135316,BLOCK,-1,,CHECK_ENV(env),3,,948,2,,void
135323,BLOCK,1,,<empty>,,,,3,,void
135325,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,949,1,,void
135331,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,949,2,,void
135358,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  } else {
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } ...",63,,965,8,,void
135361,BLOCK,1,,<empty>,,,,2,,void
135363,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135368,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135373,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135382,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135389,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135396,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135417,BLOCK,1,,<empty>,,,,3,,void
135419,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,967,1,,void
135425,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,967,2,,void
135435,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,968,2,,void
135439,BLOCK,1,,<empty>,,,,3,,void
135441,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,969,1,,void
135447,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,969,2,,void
135482,BLOCK,1,,<empty>,,,,7,,void
135484,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135486,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135492,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,2,,void
135511,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135519,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,2,,void
135545,BLOCK,1,,<empty>,,,,4,,void
135547,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135549,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135555,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,2,,void
135577,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135584,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,2,,void
135610,BLOCK,-1,,"{
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  }",33,,982,2,,void
135632,BLOCK,-1,,"{
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }",10,,990,1,,void
135658,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,1000,2,,void
135664,BLOCK,-1,,"{
    CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure);
    if (result != nullptr) {
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }
  }",10,,1002,1,,void
135669,BLOCK,1,,<empty>,,,,4,,void
135671,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1003,1,,void
135679,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1003,2,,void
135689,BLOCK,-1,,"{
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }",28,,1004,2,,void
135704,BLOCK,1,,<empty>,,,,3,,void
135722,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",63,,1016,5,,void
135725,BLOCK,1,,<empty>,,,,2,,void
135727,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135732,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135737,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135746,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135753,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135760,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135781,BLOCK,1,,<empty>,,,,3,,void
135783,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1018,1,,void
135789,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1018,2,,void
135819,BLOCK,1,,<empty>,,,,4,,void
135821,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1022,1,,void
135829,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1022,2,,void
135861,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1028,2,,void
135875,BLOCK,1,,<empty>,,,,3,,void
135895,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferFinalizer::FinalizeBufferCallback,
                        finalizer);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
  // Tell coverity that 'finalizer' should not be freed when we return
  // as it will be deleted when the buffer to which it is associated
  // is finalized.
  // coverity[leaked_storag...",72,,1040,7,,void
135898,BLOCK,1,,<empty>,,,,2,,void
135900,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135905,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135910,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135919,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135926,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135933,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135954,BLOCK,1,,<empty>,,,,3,,void
135956,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1042,1,,void
135962,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1042,2,,void
136018,BLOCK,1,,<empty>,,,,4,,void
136020,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1061,1,,void
136028,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1061,2,,void
136048,BLOCK,1,,<empty>,,,,3,,void
136067,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",68,,1075,6,,void
136070,BLOCK,1,,<empty>,,,,2,,void
136072,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
136077,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
136082,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
136091,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
136098,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
136105,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
136126,BLOCK,1,,<empty>,,,,3,,void
136128,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1077,1,,void
136134,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1077,2,,void
136167,BLOCK,1,,<empty>,,,,4,,void
136169,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1082,1,,void
136177,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1082,2,,void
136209,BLOCK,-1,,"{
    *result_data = node::Buffer::Data(buffer);
  }",31,,1087,2,,void
136223,BLOCK,1,,<empty>,,,,3,,void
136240,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",53,,1096,4,,void
136243,BLOCK,1,,<empty>,,,,2,,void
136245,BLOCK,-1,,CHECK_ENV(env),3,,1097,1,,void
136250,BLOCK,-1,,CHECK_ENV(env),3,,1097,2,,void
136257,BLOCK,1,,<empty>,,,,3,,void
136259,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1098,1,,void
136265,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1098,2,,void
136274,BLOCK,1,,<empty>,,,,3,,void
136276,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1099,1,,void
136282,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1099,2,,void
136312,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",61,,1108,5,,void
136315,BLOCK,1,,<empty>,,,,2,,void
136317,BLOCK,-1,,CHECK_ENV(env),3,,1109,1,,void
136322,BLOCK,-1,,CHECK_ENV(env),3,,1109,2,,void
136329,BLOCK,1,,<empty>,,,,3,,void
136331,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,1,,void
136337,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,2,,void
136362,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1114,2,,void
136377,BLOCK,-1,,"{
    *length = node::Buffer::Length(buffer);
  }",26,,1117,2,,void
136396,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",80,,1125,3,,void
136399,BLOCK,1,,<empty>,,,,2,,void
136401,BLOCK,-1,,CHECK_ENV(env),3,,1126,1,,void
136406,BLOCK,-1,,CHECK_ENV(env),3,,1126,2,,void
136413,BLOCK,1,,<empty>,,,,3,,void
136415,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1127,1,,void
136421,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1127,2,,void
136432,BLOCK,1,,<empty>,,,,1,,void
136435,BLOCK,1,,<empty>,,,,1,,void
136438,BLOCK,1,,<empty>,,,,1,,void
136441,BLOCK,1,,<empty>,,,,1,,void
136457,BLOCK,-1,,"{
  switch (code) {
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }
}",49,,1137,2,,void
136460,BLOCK,-1,,"{
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }",17,,1138,2,,void
136485,BLOCK,-1,,<empty>,29,,1167,7,,void
136489,BLOCK,-1,,<empty>,,,,1,,<empty>
136499,BLOCK,-1,,"{
    return new Work(
        env, async_resource, async_resource_name, execute, complete, data);
  }",32,,1177,7,,void
136513,BLOCK,-1,,{ delete work; },34,,1182,2,,void
136519,BLOCK,-1,,"{ _execute(_env, _data); }",36,,1184,1,,void
136526,BLOCK,-1,,"{
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",49,,1186,2,,void
136531,BLOCK,-1,,<empty>,31,,1187,2,,void
136560,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
                                         execute,
                                         complete,
                                         data);

  *result = reinterpret_cast<napi_async_work>(work);

  return napi_clear_last_error(env);
}",49,,1229,8,,void
136563,BLOCK,1,,<empty>,,,,2,,void
136565,BLOCK,-1,,CHECK_ENV(env),3,,1230,1,,void
136570,BLOCK,-1,,CHECK_ENV(env),3,,1230,2,,void
136577,BLOCK,1,,<empty>,,,,3,,void
136579,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1231,1,,void
136585,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1231,2,,void
136594,BLOCK,1,,<empty>,,,,3,,void
136596,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1232,1,,void
136602,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1232,2,,void
136635,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  }",34,,1237,2,,void
136642,BLOCK,1,,<empty>,,,,7,,void
136644,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136646,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136652,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,2,,void
136671,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136679,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,2,,void
136693,BLOCK,-1,,"{
    resource = v8::Object::New(env->isolate);
  }",10,,1239,1,,void
136720,BLOCK,1,,<empty>,,,,7,,void
136722,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136724,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136730,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,2,,void
136749,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136757,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,2,,void
136801,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",69,,1259,3,,void
136804,BLOCK,1,,<empty>,,,,2,,void
136806,BLOCK,-1,,CHECK_ENV(env),3,,1260,1,,void
136811,BLOCK,-1,,CHECK_ENV(env),3,,1260,2,,void
136818,BLOCK,1,,<empty>,,,,3,,void
136820,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1261,1,,void
136826,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1261,2,,void
136849,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",79,,1268,3,,void
136852,BLOCK,1,,<empty>,,,,2,,void
136854,BLOCK,-1,,CHECK_ENV(env),3,,1269,1,,void
136859,BLOCK,-1,,CHECK_ENV(env),3,,1269,2,,void
136866,BLOCK,1,,<empty>,,,,3,,void
136868,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1270,1,,void
136874,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1270,2,,void
136900,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",68,,1276,3,,void
136903,BLOCK,1,,<empty>,,,,2,,void
136905,BLOCK,-1,,CHECK_ENV(env),3,,1277,1,,void
136910,BLOCK,-1,,CHECK_ENV(env),3,,1277,2,,void
136917,BLOCK,1,,<empty>,,,,3,,void
136919,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1278,1,,void
136925,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1278,2,,void
136937,BLOCK,1,,<empty>,,,,4,,void
136939,BLOCK,-1,,"STATUS_CALL(napi_get_uv_event_loop(env, &event_loop))",3,,1281,1,,void
136951,BLOCK,-1,,<empty>,3,,1281,2,,void
136973,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",69,,1291,3,,void
136976,BLOCK,1,,<empty>,,,,2,,void
136978,BLOCK,-1,,CHECK_ENV(env),3,,1292,1,,void
136983,BLOCK,-1,,CHECK_ENV(env),3,,1292,2,,void
136990,BLOCK,1,,<empty>,,,,3,,void
136992,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1293,1,,void
136998,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1293,2,,void
137018,BLOCK,1,,<empty>,,,,8,,void
137020,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1297,1,,void
137040,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1297,2,,void
137064,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, v8_func, func);
  }

  v8::Local<v8::Context> v8_context = env->context();

  v8::Local<v8::Object> v8_resource;
  if (async_resource == nullptr) {
    v8_resource = v8::Object::New(env->isolate);
  } else {
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }

  v8::Local<v8::String> v8_name;
  CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name);

  v8impl::ThreadSafeFunction* ts_fn =
      new v8impl::ThreadSafeFunction(v8_func,
                                     v8_resource,
                                     v8_name,
                                     initial_thread_count,
                                     context,
        ...",67,,1313,12,,void
137067,BLOCK,1,,<empty>,,,,2,,void
137069,BLOCK,-1,,CHECK_ENV(env),3,,1314,1,,void
137074,BLOCK,-1,,CHECK_ENV(env),3,,1314,2,,void
137081,BLOCK,1,,<empty>,,,,3,,void
137083,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1315,1,,void
137089,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1315,2,,void
137098,BLOCK,1,,<empty>,,,,3,,void
137100,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1316,1,,void
137106,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1316,2,,void
137115,BLOCK,1,,<empty>,,,,3,,void
137117,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1317,1,,void
137123,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1317,2,,void
137146,BLOCK,-1,,"{
    CHECK_ARG(env, call_js_cb);
  }",24,,1322,2,,void
137150,BLOCK,1,,<empty>,,,,3,,void
137152,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1323,1,,void
137158,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1323,2,,void
137165,BLOCK,-1,,"{
    CHECK_TO_FUNCTION(env, v8_func, func);
  }",10,,1324,1,,void
137170,BLOCK,1,,<empty>,,,,4,,void
137172,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
137174,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
137180,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,2,,void
137202,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
137209,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,2,,void
137249,BLOCK,-1,,"{
    v8_resource = v8::Object::New(env->isolate);
  }",34,,1331,2,,void
137262,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }",10,,1333,1,,void
137269,BLOCK,1,,<empty>,,,,7,,void
137271,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137273,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137279,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,2,,void
137298,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137306,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,2,,void
137334,BLOCK,1,,<empty>,,,,7,,void
137336,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137338,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137344,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,2,,void
137363,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137371,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,2,,void
137405,BLOCK,-1,,"{
    status = napi_generic_failure;
  }",25,,1352,2,,void
137410,BLOCK,-1,,"{
    // Init deletes ts_fn upon failure.
    status = ts_fn->Init();
    if (status == napi_ok) {
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }
  }",10,,1354,1,,void
137421,BLOCK,-1,,"{
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }",28,,1357,2,,void
137437,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  CHECK_NOT_NULL(result);

  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();
  return napi_ok;
}",51,,1366,3,,void
137459,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,
                                                                   is_blocking);
}",79,,1377,4,,void
137475,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();
}",65,,1384,2,,void
137490,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);
}",80,,1390,3,,void
137506,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();
}",77,,1396,3,,void
137521,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();
}",75,,1402,3,,void
137536,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",75,,1408,3,,void
137539,BLOCK,1,,<empty>,,,,2,,void
137541,BLOCK,-1,,CHECK_ENV(env),3,,1409,1,,void
137546,BLOCK,-1,,CHECK_ENV(env),3,,1409,2,,void
137553,BLOCK,1,,<empty>,,,,3,,void
137555,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1410,1,,void
137561,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1410,2,,void
137589,BLOCK,-1,,<empty>,1,,1,1,,ANY
137594,BLOCK,-1,,<empty>,,,,3,,<empty>
137598,BLOCK,-1,,<empty>,,,,1,,<empty>
137610,BLOCK,-1,,<empty>,,,,1,,<empty>
137618,BLOCK,-1,,<empty>,,,,2,,<empty>
137626,BLOCK,-1,,<empty>,,,,5,,<empty>
137634,BLOCK,-1,,<empty>,,,,5,,<empty>
137640,BLOCK,-1,,<empty>,,,,3,,<empty>
137651,BLOCK,-1,,<empty>,,,,8,,<empty>
137659,BLOCK,-1,,<empty>,,,,5,,<empty>
137669,BLOCK,-1,,<empty>,,,,7,,<empty>
137678,BLOCK,-1,,<empty>,,,,6,,<empty>
137685,BLOCK,-1,,<empty>,,,,4,,<empty>
137693,BLOCK,-1,,<empty>,,,,5,,<empty>
137704,BLOCK,-1,,<empty>,,,,8,,<empty>
137710,BLOCK,-1,,<empty>,,,,3,,<empty>
137716,BLOCK,-1,,<empty>,,,,3,,<empty>
137722,BLOCK,-1,,<empty>,,,,3,,<empty>
137728,BLOCK,-1,,<empty>,,,,3,,<empty>
137734,BLOCK,-1,,<empty>,,,,3,,<empty>
137740,BLOCK,-1,,<empty>,,,,3,,<empty>
137747,BLOCK,-1,,<empty>,,,,4,,<empty>
137754,BLOCK,-1,,<empty>,,,,4,,<empty>
137762,BLOCK,-1,,<empty>,,,,5,,<empty>
137768,BLOCK,-1,,<empty>,,,,3,,<empty>
137783,BLOCK,-1,,<empty>,,,,12,,<empty>
137789,BLOCK,-1,,<empty>,,,,3,,<empty>
137796,BLOCK,-1,,<empty>,,,,4,,<empty>
137801,BLOCK,-1,,<empty>,,,,2,,<empty>
137807,BLOCK,-1,,<empty>,,,,3,,<empty>
137813,BLOCK,-1,,<empty>,,,,3,,<empty>
137819,BLOCK,-1,,<empty>,,,,3,,<empty>
137827,BLOCK,-1,,<empty>,,,,5,,<empty>
137832,BLOCK,-1,,<empty>,,,,2,,<empty>
137849,BLOCK,-1,,<empty>,1,,1,1,,ANY
137855,BLOCK,-1,,<empty>,,,,4,,<empty>
137859,BLOCK,-1,,<empty>,,,,1,,<empty>
137866,BLOCK,-1,,<empty>,,,,4,,<empty>
137873,BLOCK,-1,,<empty>,,,,4,,<empty>
137878,BLOCK,-1,,<empty>,,,,2,,<empty>
137882,BLOCK,-1,,<empty>,,,,1,,<empty>
137887,BLOCK,-1,,<empty>,,,,2,,<empty>
137892,BLOCK,-1,,<empty>,,,,2,,<empty>
137896,BLOCK,-1,,<empty>,,,,1,,<empty>
137900,BLOCK,-1,,"{
    return node::Environment::GetCurrent(context());
  }",46,,30,1,,void
137912,BLOCK,-1,,{ return filename.c_str(); },42,,33,1,,void
137924,BLOCK,-1,,<empty>,,,,1,,<empty>
137940,BLOCK,-1,,<empty>,1,,1,1,,ANY
137950,BLOCK,-1,,<empty>,,,,3,,<empty>
137957,BLOCK,-1,,<empty>,,,,4,,<empty>
137969,BLOCK,-1,,"{
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      d...",55,,456,2,,void
137991,BLOCK,-1,,"{
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }",21,,468,2,,void
138018,BLOCK,-1,,"{
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      dlib->SaveInGlobalHandleMap(mp);
    }",24,,479,2,,void
138025,BLOCK,-1,,"{
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }",52,,480,2,,void
138031,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }",41,,481,2,,void
138053,BLOCK,-1,,"{
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      } else if (auto napi_callback = GetNapiInitializerCallback(dlib)) {
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      } else {
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }
    }",12,,489,1,,void
138055,BLOCK,-1,,<empty>,11,,490,1,,void
138061,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,490,2,,void
138069,BLOCK,-1,,<empty>,14,,493,1,,void
138071,BLOCK,-1,,<empty>,18,,493,1,,void
138077,BLOCK,-1,,"{
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      }",73,,493,2,,void
138083,BLOCK,-1,,<empty>,13,,495,1,,void
138089,BLOCK,-1,,"{
          module_api_version = get_version();
        }",73,,495,2,,void
138102,BLOCK,-1,,"{
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }",14,,501,1,,void
138119,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }",71,,503,2,,void
138144,BLOCK,-1,,"{
      // Even if the module did self-register, it may have done so with the
      // wrong version. We must only give up after having checked to see if it
      // has an appropriate initializer callback.
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      }

      const int actual_nm_version = mp->nm_version;
      // NOTE: `mp` is allocated inside of the shared library's memory, calling
      // `dlclose` will deallocate it
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(
          env,
          ""The module '%s'""
          ""\nwas compiled against a different Node.js version using""
          ""\nNODE_MODULE_VERSION %d. This version of Node.js requires""
          ""\nNODE_MODULE_VERSION %d. Please try re-compiling or ""
          ""re-installing\nthe module (for instance, using `npm rebuild` ""
          ""or `npm install`)."",
          *filename,
          actual_nm_version,
          NODE_MODULE_VERSION);...",76,,513,2,,void
138146,BLOCK,-1,,<empty>,11,,517,1,,void
138152,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,517,2,,void
138194,BLOCK,-1,,"{
      mp->nm_context_register_func(exports, module, context, mp->nm_priv);
    }",50,,543,2,,void
138206,BLOCK,-1,,<empty>,12,,545,1,,void
138213,BLOCK,-1,,"{
      mp->nm_register_func(exports, module, mp->nm_priv);
    }",49,,545,2,,void
138224,BLOCK,-1,,"{
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(env, ""Module has no declared entry point."");
      return false;
    }",12,,547,1,,void
138262,BLOCK,-1,,<empty>,1,,1,1,,ANY
138264,BLOCK,-1,,<empty>,,,,1,,<empty>
138268,BLOCK,-1,,<empty>,,,,1,,<empty>
138272,BLOCK,-1,,<empty>,,,,1,,<empty>
138276,BLOCK,-1,,<empty>,,,,1,,<empty>
138280,BLOCK,-1,,<empty>,,,,1,,<empty>
138284,BLOCK,-1,,<empty>,,,,1,,<empty>
138288,BLOCK,-1,,<empty>,,,,1,,<empty>
138292,BLOCK,-1,,<empty>,,,,1,,<empty>
138296,BLOCK,-1,,<empty>,,,,1,,<empty>
138300,BLOCK,-1,,<empty>,,,,1,,<empty>
138304,BLOCK,-1,,<empty>,,,,1,,<empty>
138308,BLOCK,-1,,<empty>,,,,1,,<empty>
138312,BLOCK,-1,,<empty>,,,,1,,<empty>
138316,BLOCK,-1,,<empty>,,,,1,,<empty>
138320,BLOCK,-1,,<empty>,,,,1,,<empty>
138324,BLOCK,-1,,<empty>,,,,1,,<empty>
138328,BLOCK,-1,,<empty>,,,,1,,<empty>
138332,BLOCK,-1,,<empty>,,,,1,,<empty>
138336,BLOCK,-1,,<empty>,,,,1,,<empty>
138340,BLOCK,-1,,<empty>,,,,1,,<empty>
138344,BLOCK,-1,,<empty>,,,,1,,<empty>
138348,BLOCK,-1,,<empty>,,,,1,,<empty>
138352,BLOCK,-1,,<empty>,,,,1,,<empty>
138356,BLOCK,-1,,<empty>,,,,1,,<empty>
138360,BLOCK,-1,,<empty>,,,,1,,<empty>
138364,BLOCK,-1,,<empty>,,,,1,,<empty>
138368,BLOCK,-1,,<empty>,,,,1,,<empty>
138372,BLOCK,-1,,<empty>,,,,1,,<empty>
138376,BLOCK,-1,,<empty>,,,,1,,<empty>
138380,BLOCK,-1,,<empty>,,,,1,,<empty>
138384,BLOCK,-1,,<empty>,,,,1,,<empty>
138388,BLOCK,-1,,<empty>,,,,1,,<empty>
138392,BLOCK,-1,,<empty>,,,,1,,<empty>
138396,BLOCK,-1,,<empty>,,,,1,,<empty>
138400,BLOCK,-1,,<empty>,,,,1,,<empty>
138404,BLOCK,-1,,<empty>,,,,1,,<empty>
138408,BLOCK,-1,,<empty>,,,,1,,<empty>
138412,BLOCK,-1,,<empty>,,,,1,,<empty>
138416,BLOCK,-1,,<empty>,,,,1,,<empty>
138420,BLOCK,-1,,<empty>,,,,1,,<empty>
138424,BLOCK,-1,,<empty>,,,,1,,<empty>
138428,BLOCK,-1,,<empty>,,,,1,,<empty>
138432,BLOCK,-1,,<empty>,,,,1,,<empty>
138436,BLOCK,-1,,<empty>,,,,1,,<empty>
138440,BLOCK,-1,,<empty>,,,,1,,<empty>
138444,BLOCK,-1,,<empty>,,,,1,,<empty>
138448,BLOCK,-1,,<empty>,,,,1,,<empty>
138452,BLOCK,-1,,<empty>,,,,1,,<empty>
138456,BLOCK,-1,,<empty>,,,,1,,<empty>
138460,BLOCK,-1,,<empty>,,,,1,,<empty>
138464,BLOCK,-1,,<empty>,,,,1,,<empty>
138468,BLOCK,-1,,<empty>,,,,1,,<empty>
138472,BLOCK,-1,,<empty>,,,,1,,<empty>
138476,BLOCK,-1,,<empty>,,,,1,,<empty>
138480,BLOCK,-1,,<empty>,,,,1,,<empty>
138484,BLOCK,-1,,<empty>,,,,1,,<empty>
138500,BLOCK,-1,,"{
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",47,,255,2,,void
138513,BLOCK,-1,,"{
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  }",37,,258,2,,void
138523,BLOCK,-1,,<empty>,10,,261,1,,void
138527,BLOCK,-1,,"{
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  }",36,,261,2,,void
138542,BLOCK,-1,,"{
    thread_local_modpending = mp;
  }",10,,267,1,,void
138553,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",44,,276,3,,void
138588,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",56,,291,2,,void
138610,BLOCK,-1,,<empty>,27,,296,2,,void
138629,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",28,,301,2,,void
138651,BLOCK,-1,,<empty>,27,,306,2,,void
138669,BLOCK,-1,,"{
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }",37,,308,2,,void
138676,BLOCK,-1,,<empty>,9,,310,2,,void
138700,BLOCK,-1,,<empty>,60,,326,3,,void
138704,BLOCK,-1,,"{
  int ret = uv_dlopen(filename_.c_str(), &lib_);
  if (ret == 0) {
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }
  errmsg_ = uv_dlerror(&lib_);
  uv_dlclose(&lib_);
  return false;
}",19,,360,1,,void
138719,BLOCK,-1,,"{
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }",17,,362,2,,void
138740,BLOCK,-1,,"{
  if (handle_ == nullptr) return;
  if (has_entry_in_global_handle_map_)
    global_handle_map.erase(handle_);
  uv_dlclose(&lib_);
  handle_ = nullptr;
}",20,,371,1,,void
138745,BLOCK,-1,,<empty>,27,,372,2,,void
138749,BLOCK,-1,,<empty>,5,,374,2,,void
138763,BLOCK,-1,,"{
  void* address;
  if (0 == uv_dlsym(&lib_, name, &address)) return address;
  return nullptr;
}",48,,379,2,,void
138774,BLOCK,-1,,<empty>,45,,381,2,,void
138783,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  global_handle_map.set(handle_, mp);
}",51,,386,2,,void
138796,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  return global_handle_map.get_and_increase_refcount(handle_);
}",56,,391,1,,void
138811,BLOCK,-1,,"{
  const char* name = ""node_register_module_v"" STRINGIFY(NODE_MODULE_VERSION);
  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));
}",63,,400,2,,void
138830,BLOCK,-1,,"{
  const char* name =
      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);
  return reinterpret_cast<napi_addon_register_func>(
      dlib->GetSymbolAddress(name));
}",72,,405,2,,void
138850,BLOCK,-1,,"{
  return reinterpret_cast<node_api_addon_get_api_version_func>(
      dlib->GetSymbolAddress(STRINGIFY(NODE_API_MODULE_GET_API_VERSION)));
}",17,,413,2,,void
138864,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (env->no_native_addons()) {
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }

  auto context = env->context();

  CHECK_NULL(thread_local_modpending);

  if (args.Length() < 2) {
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }

  int32_t flags = DLib::kDefaultFlags;
  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }

  Local<Object> module;
  Local<Object> exports;
  Local<Value> exports_v;
  if (!args[0]->ToObject(context).ToLocal(&module) ||
      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||
      !exports_v->ToObject(context).ToLocal(&exports)) {
    return;  // Exception pending.
  }

  node::Utf8Value filename(env->isolate(), args[1]);  // Cast
  env->TryLoadAddon(*filename, f...",54,,424,2,,void
138877,BLOCK,-1,,"{
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }",32,,427,2,,void
138897,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }",26,,436,2,,void
138929,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }",70,,442,2,,void
138991,BLOCK,-1,,"{
    return;  // Exception pending.
  }",56,,451,2,,void
139015,BLOCK,-1,,"{
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",49,,562,4,,void
139018,BLOCK,-1,,<empty>,3,,565,1,,void
139030,BLOCK,4,,"{
    if (strcmp(mp->nm_modname, name) == 0) break;
  }",52,,565,4,,void
139039,BLOCK,-1,,<empty>,44,,566,2,,void
139059,BLOCK,-1,,"{
#define V(modname)                                                             \
  do {                                                                         \
    Local<ObjectTemplate> templ =                                              \
        ObjectTemplate::New(isolate_data->isolate());                          \
    templ->SetInternalFieldCount(BaseObject::kInternalFieldCount);             \
    _register_isolate_##modname(isolate_data, templ);                          \
    isolate_data->set_##modname##_binding_template(templ);                     \
  } while (0);
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
}",64,,573,2,,void
139068,BLOCK,-1,,"{
  Local<ObjectTemplate> templ;

#define V(name)                                                                \
  if (strcmp(mod_name, #name) == 0) {                                          \
    templ = isolate_data->name##_binding_template();                           \
  } else  // NOLINT(readability/braces)
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
  {
    // Default template.
    templ = isolate_data->binding_data_default_template();
  }

  Local<Object> obj = templ->NewInstance(context).ToLocalChecked();
  return obj;
}",77,,588,4,,void
139077,BLOCK,4,,"{
    // Default template.
    templ = isolate_data->binding_data_default_template();
  }",3,,597,4,,void
139105,BLOCK,-1,,"{
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",74,,606,3,,void
139176,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  HandleScope scope(isolate);

  CHECK(args[0]->IsString());

  Local<String> module = args[0].As<String>();
  node::Utf8Value module_v(isolate, module);
  Local<Object> exports;

  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
  if (mod != nullptr) {
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  } else {
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }

  args.GetReturnValue().Set(exports);
}",66,,619,2,,void
139235,BLOCK,-1,,"{
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  }",23,,631,2,,void
139249,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }",10,,634,1,,void
139268,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = Object::New(env->isolate());
  Local<Object> exports = Object::...",64,,641,2,,void
139324,BLOCK,-1,,"{
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }",48,,655,2,,void
139350,BLOCK,-1,,<empty>,5,,662,2,,void
139361,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }",23,,664,2,,void
139430,BLOCK,-1,,"{
    mod->nm_context_register_func(
        exports, module, env->context(), mod->nm_priv);
  }",49,,675,2,,void
139445,BLOCK,-1,,<empty>,10,,678,1,,void
139452,BLOCK,-1,,"{
    mod->nm_register_func(exports, module, mod->nm_priv);
  }",48,,678,2,,void
139463,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""Linked binding has no declared entry point."");
  }",10,,680,1,,void
139494,BLOCK,-1,,"{
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",32,,693,1,,void
139496,BLOCK,1,,<empty>,,,,1,,void
139499,BLOCK,1,,<empty>,,,,1,,void
139561,BLOCK,-1,,"{
  registry->Register(GetLinkedBinding);
  registry->Register(GetInternalBinding);
}",70,,699,2,,void
139587,BLOCK,-1,,<empty>,1,,1,1,,ANY
139593,BLOCK,-1,,"{
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0, byte_length);
    }",69,,186,4,,void
139599,BLOCK,-1,,"{
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }",32,,187,2,,void
139686,BLOCK,-1,,"{
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader-...",48,,343,5,,void
139731,BLOCK,-1,,<empty>,36,,349,2,,void
139743,BLOCK,-1,,"{
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader->MakeCallback(fn, arraysize(argv), argv);
      return;
    }",20,,351,2,,void
139749,BLOCK,-1,,<empty>,7,,354,1,,void
139795,BLOCK,-1,,<empty>,7,,359,1,,void
139805,BLOCK,4,,"{
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }",42,,359,4,,void
139912,BLOCK,-1,,<empty>,1,,1,1,,ANY
139917,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());
  Local<Array> array = args[0].As<Array>();

  struct View {
    std::shared_ptr<BackingStore> store;
    size_t length;
    size_t offset = 0;
  };

  std::vector<View> views;
  size_t total = 0;

  for (uint32_t n = 0; n < array->Length(); n++) {
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }

  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), total);
  ui...",54,,43,2,,void
139951,BLOCK,-1,,<empty>,3,,57,1,,void
139964,BLOCK,4,,"{
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }",50,,57,4,,void
139986,BLOCK,-1,,<empty>,55,,59,2,,void
139993,BLOCK,-1,,"{
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    }",31,,60,2,,void
140023,BLOCK,-1,,"{
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }",12,,64,1,,void
140090,BLOCK,-1,,<empty>,3,,77,1,,void
140103,BLOCK,4,,"{
    uint8_t* from =
        static_cast<uint8_t*>(views[n].store->Data()) + views[n].offset;
    std::copy(from, from + views[n].length, ptr);
    ptr += views[n].length;
  }",45,,77,4,,void
140167,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());
  auto entry = DataQueue::CreateFdEntry(env, args[0]);
  if (entry == nullptr) {
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }

  std::vector<std::unique_ptr<DataQueue::Entry>> entries;
  entries.push_back(std::move(entry));

  auto blob =
      Blob::Create(env, DataQueue::CreateIdempotent(std::move(entries)));

  if (blob) {
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }
}",64,,87,2,,void
140214,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }",25,,94,2,,void
140260,BLOCK,-1,,"{
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }",13,,104,2,,void
140322,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""createBlob"", New);
  SetMethod(isolate, target, ""storeDataObject"", StoreDataObject);
  SetMethod(isolate, target, ""getDataObject"", GetDataObject);
  SetMethod(isolate, target, ""revokeObjectURL"", RevokeObjectURL);
  SetMethod(isolate, target, ""concat"", Concat);
  SetMethod(isolate, target, ""createBlobFromFilePath"", BlobFromFilePath);
}",69,,117,3,,void
140367,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BlobBindingData>(context, target);
}",51,,131,5,,void
140390,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }
  return tmpl;
}",72,,136,2,,void
140406,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }",23,,138,2,,void
140461,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",71,,152,3,,void
140474,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  Local<Function> ctor;
  if (!GetConstructorTemplate(env)->GetFunction(env->context()).ToLocal(&ctor))
    return BaseObjectPtr<Blob>();

  Local<Object> obj;
  if (!ctor->NewInstance(env->context()).ToLocal(&obj))
    return BaseObjectPtr<Blob>();

  return MakeBaseObject<Blob>(env, obj, data_queue);
}",73,,157,3,,void
140502,BLOCK,-1,,<empty>,5,,162,2,,void
140525,BLOCK,-1,,<empty>,5,,166,2,,void
140542,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());  // sources

  Local<Array> array = args[0].As<Array>();
  std::vector<std::unique_ptr<DataQueue::Entry>> entries(array->Length());

  for (size_t i = 0; i < array->Length(); i++) {
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingSt...",57,,171,2,,void
140587,BLOCK,-1,,<empty>,3,,178,1,,void
140600,BLOCK,4,,"{
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0...",48,,178,4,,void
140622,BLOCK,-1,,"{
      return;
    }",57,,180,2,,void
140633,BLOCK,-1,,"{
      Local<ArrayBuffer> buf = entry.As<ArrayBuffer>();
      entries[i] = entryFromArrayBuffer(buf, buf->ByteLength());
    }",33,,212,2,,void
140655,BLOCK,-1,,<empty>,12,,215,1,,void
140661,BLOCK,-1,,"{
      Local<ArrayBufferView> view = entry.As<ArrayBufferView>();
      entries[i] = entryFromArrayBuffer(
          view->Buffer(), view->ByteLength(), view->ByteOffset());
    }",44,,215,2,,void
140690,BLOCK,-1,,<empty>,12,,219,1,,void
140698,BLOCK,-1,,"{
      Blob* blob;
      ASSIGN_OR_RETURN_UNWRAP(&blob, entry);
      entries[i] = DataQueue::CreateDataQueueEntry(blob->data_queue_);
    }",47,,219,2,,void
140716,BLOCK,-1,,"{
      UNREACHABLE(""Incorrect Blob initialization type"");
    }",12,,223,1,,void
140735,BLOCK,-1,,<empty>,5,,230,2,,void
140751,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());

  BaseObjectPtr<Blob::Reader> reader =
      Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
  if (reader) args.GetReturnValue().Set(reader->object());
}",63,,233,2,,void
140790,BLOCK,-1,,<empty>,15,,240,2,,void
140806,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsUint32());
  size_t start = args[0].As<Uint32>()->Value();
  size_t end = args[1].As<Uint32>()->Value();
  BaseObjectPtr<Blob> slice = blob->Slice(env, start, end);
  if (slice)
    args.GetReturnValue().Set(slice->object());
}",61,,243,2,,void
140876,BLOCK,-1,,<empty>,5,,253,2,,void
140892,BLOCK,-1,,"{
  tracker->TrackField(""data_queue_"", data_queue_, ""std::shared_ptr<DataQueue>"");
}",53,,256,2,,void
140906,BLOCK,-1,,"{
  return Create(env,
                this->data_queue_->slice(start, static_cast<uint64_t>(end)));
}",77,,260,4,,void
140926,BLOCK,-1,,"{
  MakeWeak();
}",53,,268,4,,void
140934,BLOCK,-1,,"{
  MakeWeak();
}",42,,277,4,,void
140941,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,281,3,,void
140953,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_reader_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }
  return tmpl;
}",80,,285,2,,void
140969,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }",23,,287,2,,void
141022,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<Blob::Reader>();
  }

  return MakeBaseObject<Blob::Reader>(env, obj, std::move(blob));
}",76,,300,3,,void
141047,BLOCK,-1,,"{
    return BaseObjectPtr<Blob::Reader>();
  }",28,,305,2,,void
141071,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = [impl](int status,
                     const DataQueue::Vec* vec...",66,,312,2,,void
141117,BLOCK,-1,,"{
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }",21,,321,2,,void
141220,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  return Blob::Create(env, data_queue);
}",49,,386,4,,void
141228,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,387,2,,void
141242,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",56,,394,1,,void
141252,BLOCK,-1,,"{
  return std::make_unique<BlobTransferData>(data_queue_);
}",71,,398,1,,void
141265,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  CHECK(args[0]->IsString());  // ID key
  CHECK(Blob::HasInstance(env, args[1]));  // Blob
  CHECK(args[2]->IsUint32());  // Length
  CHECK(args[3]->IsString());  // Type

  Utf8Value key(env->isolate(), args[0]);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args[1]);

  size_t length = args[2].As<Uint32>()->Value();
  Utf8Value type(env->isolate(), args[3]);

  binding_data->store_data_object(
      std::string(*key, key.length()),
      BlobBindingData::StoredDataObject(
        BaseObjectPtr<Blob>(blob),
        length,
        std::string(*type, type.length())));
}",77,,402,2,,void
141389,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Utf8Value input(env->isolate(), args[0].As<String>());
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());

  if (!out) {
    return;
  }

  auto pathname = out->get_pathname();
  auto start_index = pathname.find(':');

  if (start_index != std::string_view::npos && start_index != pathname.size()) {
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }
}",69,,427,2,,void
141451,BLOCK,-1,,"{
    return;
  }",13,,435,2,,void
141483,BLOCK,-1,,"{
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }",80,,442,2,,void
141503,BLOCK,-1,,"{
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }",46,,444,2,,void
141527,BLOCK,-1,,"{
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  Utf8Value key(env->isolate(), args[0]);

  BlobBindingData::StoredDataObject stored =
      binding_data->get_data_object(std::string(*key, key.length()));
  if (stored.blob) {
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }
}",75,,451,2,,void
141583,BLOCK,-1,,"{
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }",20,,461,2,,void
141623,BLOCK,-1,,"{
      return;
    }",69,,467,2,,void
141669,BLOCK,-1,,"{
  tracker->TrackField(""blob"", blob, ""BaseObjectPtr<Blob>"");
}",35,,486,2,,void
141683,BLOCK,-1,,<empty>,19,,496,4,,void
141689,BLOCK,-1,,"{
  MakeWeak();
}",49,,499,3,,void
141695,BLOCK,-1,,"{
  tracker->TrackField(""data_objects_"",
                      data_objects_,
                      ""std::unordered_map<std::string, StoredDataObject>"");
}",64,,503,2,,void
141708,BLOCK,-1,,"{
  data_objects_[uuid] = object;
}",54,,511,3,,void
141718,BLOCK,-1,,"{
  if (data_objects_.find(uuid) == data_objects_.end()) {
    return;
  }
  data_objects_.erase(uuid);
  CHECK_EQ(data_objects_.find(uuid), data_objects_.end());
}",67,,515,2,,void
141730,BLOCK,-1,,"{
    return;
  }",56,,516,2,,void
141751,BLOCK,-1,,"{
  auto entry = data_objects_.find(uuid);
  if (entry == data_objects_.end())
    return BlobBindingData::StoredDataObject {};
  return entry->second;
}",30,,524,2,,void
141767,BLOCK,-1,,<empty>,5,,527,2,,void
141782,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BlobBindingData* binding =
      realm->AddBindingData<BlobBindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",64,,534,5,,void
141822,BLOCK,-1,,"{
  // Stored blob objects are not actually persisted.
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",77,,544,3,,void
141829,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",62,,551,2,,void
141851,BLOCK,-1,,"{
  registry->Register(Blob::New);
  registry->Register(Blob::GetReader);
  registry->Register(Blob::ToSlice);
  registry->Register(Blob::StoreDataObject);
  registry->Register(Blob::GetDataObject);
  registry->Register(Blob::RevokeObjectURL);
  registry->Register(Blob::Reader::Pull);
  registry->Register(Concat);
  registry->Register(BlobFromFilePath);
}",76,,558,2,,void
141948,BLOCK,-1,,<empty>,1,,1,1,,ANY
141952,BLOCK,-1,,<empty>,56,,22,2,,void
141963,BLOCK,-1,,<empty>,1,,1,1,,ANY
141972,BLOCK,-1,,"{

  int status;
  if (eos_) {
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }

  status = DoPull(std::move(next), options, data, count, max_count_hint);

  if (status == bob::Status::STATUS_EOS) eos_ = true;

  return status;
}",28,,17,6,,void
141976,BLOCK,-1,,"{
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }",13,,20,2,,void
142016,BLOCK,-1,,<empty>,42,,28,2,,void
142030,BLOCK,-1,,<empty>,1,,1,1,,ANY
142043,BLOCK,-1,,<empty>,,,,1,,<empty>
142063,BLOCK,-1,,<empty>,,,,1,,<empty>
142079,BLOCK,-1,,<empty>,,,,1,,<empty>
142088,BLOCK,-1,,<empty>,,,,6,,<empty>
142098,BLOCK,-1,,<empty>,,,,6,,<empty>
142102,BLOCK,-1,,{ return eos_; },23,,90,1,,void
142113,BLOCK,-1,,<empty>,,,,6,,<empty>
142118,BLOCK,-1,,<empty>,,,,1,,<empty>
142129,BLOCK,-1,,"{
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }",79,,122,4,,void
142142,BLOCK,-1,,"{
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  }",75,,198,2,,void
142160,BLOCK,-1,,"{
    free(data);
  }",74,,509,4,,void
142171,BLOCK,-1,,<empty>,63,,1179,4,,void
142209,BLOCK,-1,,<empty>,1,,1,1,,ANY
142220,BLOCK,-1,,<empty>,,,,6,,<empty>
142225,BLOCK,-1,,<empty>,,,,2,,<empty>
142230,BLOCK,-1,,<empty>,,,,2,,<empty>
142235,BLOCK,-1,,<empty>,,,,2,,<empty>
142239,BLOCK,-1,,<empty>,,,,1,,<empty>
142243,BLOCK,-1,,<empty>,,,,1,,<empty>
142251,BLOCK,-1,,<empty>,,,,5,,<empty>
142266,BLOCK,-1,,"{
  CHECK_NOT_NULL(callback);
  CHECK_IMPLIES(data == nullptr, length == 0);

  CallbackInfo* self = new CallbackInfo(env, callback, data, hint);
  std::unique_ptr<BackingStore> bs =
      ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }, self);
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));

  // V8 simply ignores the BackingStore deleter callback if data == nullptr,
  // but our API contract requires it being called.
  if (data == nullptr) {
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  } else {
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }

  return ab;
}",17,,116,6,,void
142324,BLOCK,-1,,"{
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  }",24,,129,2,,void
142338,BLOCK,-1,,"{
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }",10,,132,1,,void
142365,BLOCK,-1,,"{
  env->AddCleanupHook(CleanupHook, this);
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(sizeof(*this));
}",17,,149,5,,void
142386,BLOCK,-1,,"{
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",44,,154,2,,void
142393,BLOCK,3,,"{
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }",3,,157,3,,void
142431,BLOCK,-1,,"{
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }",46,,160,2,,void
142453,BLOCK,-1,,"{
  FreeCallback callback;
  {
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }
  if (callback != nullptr) {
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }
}",43,,171,1,,void
142455,BLOCK,2,,"{
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }",3,,173,2,,void
142469,BLOCK,-1,,"{
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }",28,,178,2,,void
142499,BLOCK,-1,,"{
  // This method should always release the memory for `this`.
  std::unique_ptr<CallbackInfo> self { this };
  Mutex::ScopedLock lock(mutex_);
  // If callback_ == nullptr, that means that the callback has already run from
  // the cleanup hook, and there is nothing left to do here besides to clean
  // up the memory involved. In particular, the underlying `Environment` may
  // be gone at this point, so don’t attempt to call SetImmediateThreadsafe().
  if (callback_ == nullptr) return;

  env_->SetImmediateThreadsafe([self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  });
}",41,,188,1,,void
142511,BLOCK,-1,,<empty>,29,,196,2,,void
142523,BLOCK,-1,,"{
  return val->IsArrayBufferView();
}",36,,237,2,,void
142533,BLOCK,-1,,"{
  return obj->IsArrayBufferView();
}",37,,242,2,,void
142543,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return static_cast<char*>(ui->Buffer()->Data()) + ui->ByteOffset();
}",30,,247,2,,void
142578,BLOCK,-1,,"{
  return Data(obj.As<Value>());
}",31,,254,2,,void
142589,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return ui->ByteLength();
}",33,,259,2,,void
142614,BLOCK,-1,,"{
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",34,,266,2,,void
142642,BLOCK,-1,,"{
  CHECK(!env->buffer_prototype_object().IsEmpty());
  Local<Uint8Array> ui = Uint8Array::New(ab, byte_offset, length);
  Maybe<bool> mb =
      ui->SetPrototype(env->context(), env->buffer_prototype_object());
  if (mb.IsNothing())
    return MaybeLocal<Uint8Array>();
  return ui;
}",43,,276,5,,void
142685,BLOCK,-1,,<empty>,5,,282,2,,void
142697,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }
  return New(env, ab, byte_offset, length);
}",43,,289,5,,void
142710,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }",23,,291,2,,void
142727,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  size_t length;
  if (!StringBytes::Size(isolate, string, enc).To(&length))
    return Local<Object>();
  size_t actual = 0;
  std::unique_ptr<BackingStore> store;

  if (length > 0) {
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }

  return scope.EscapeMaybe(New(isolate, 0));
}",43,,301,4,,void
142746,BLOCK,-1,,<empty>,5,,306,2,,void
142764,BLOCK,-1,,"{
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }",19,,310,2,,void
142777,BLOCK,-1,,"{
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }",27,,313,2,,void
142807,BLOCK,-1,,"{
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }",29,,326,2,,void
142812,BLOCK,-1,,<empty>,9,,328,2,,void
142860,BLOCK,-1,,<empty>,9,,332,2,,void
142882,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Local<Object> obj;
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  if (Buffer::New(env, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",57,,341,3,,void
142903,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,345,2,,void
142920,BLOCK,-1,,<empty>,5,,350,2,,void
142934,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",57,,355,3,,void
142948,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,360,2,,void
142962,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,366,7,,void
143026,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::Copy(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",76,,384,4,,void
143042,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,387,2,,void
143065,BLOCK,-1,,<empty>,5,,393,2,,void
143080,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",76,,398,4,,void
143094,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,403,2,,void
143108,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,409,7,,void
143181,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  return handle_scope.EscapeMaybe(
      Buffer::New(env, data, length, callback, hint));
}",36,,433,6,,void
143197,BLOCK,-1,,"{
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,436,2,,void
143227,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  if (length > kMaxLength) {
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }

  Local<ArrayBuffer> ab =
      CallbackInfo::CreateTrackedArrayBuffer(env, data, length, callback, hint);
  if (ab->SetPrivate(env->context(),
                     env->untransferable_object_private_symbol(),
                     True(env->isolate())).IsNothing()) {
    return Local<Object>();
  }
  MaybeLocal<Uint8Array> maybe_ui = Buffer::New(env, ab, 0, length);

  Local<Uint8Array> ui;
  if (!maybe_ui.ToLocal(&ui))
    return MaybeLocal<Object>();

  return scope.Escape(ui);
}",36,,450,6,,void
143238,BLOCK,-1,,"{
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }",28,,453,2,,void
143292,BLOCK,-1,,"{
    return Local<Object>();
  }",57,,463,2,,void
143322,BLOCK,-1,,<empty>,5,,470,2,,void
143337,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::New(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",69,,477,4,,void
143353,BLOCK,-1,,"{
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,480,2,,void
143378,BLOCK,-1,,<empty>,5,,487,2,,void
143392,BLOCK,-1,,"{
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",39,,495,4,,void
143397,BLOCK,-1,,"{
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }",19,,496,2,,void
143404,BLOCK,-1,,"{
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }",30,,499,2,,void
143489,BLOCK,-1,,<empty>,5,,519,2,,void
143503,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsInt32());

  enum encoding enc = static_cast<enum encoding>(args[1].As<Int32>()->Value());
  Local<Object> buf;
  if (New(args.GetIsolate(), args[0].As<String>(), enc).ToLocal(&buf))
    args.GetReturnValue().Set(buf);
}",64,,525,2,,void
143555,BLOCK,-1,,<empty>,5,,532,2,,void
143568,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  ArrayBufferViewContents<char> buffer(args.This());

  if (buffer.length() == 0)
    return args.GetReturnValue().SetEmptyString();

  size_t start = 0;
  size_t end = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end));
  if (end < start) end = start;
  THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length()));
  size_t length = end - start;

  Local<Value> error;
  MaybeLocal<Value> maybe_ret =
      StringBytes::Encode(isolate,
                          buffer.data() + start,
                          length,
                          encoding,
                          &error);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(ret);
}",59,,537,2,,void
143590,BLOCK,1,,<empty>,,,,4,,void
143611,BLOCK,-1,,<empty>,5,,545,2,,void
143630,BLOCK,1,,<empty>,,,,6,,void
143632,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start))",3,,549,1,,void
143649,BLOCK,-1,,<empty>,3,,549,2,,void
143657,BLOCK,-1,,<empty>,3,,549,2,,void
143668,BLOCK,1,,<empty>,,,,7,,void
143670,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end))",3,,550,1,,void
143690,BLOCK,-1,,<empty>,3,,550,2,,void
143698,BLOCK,-1,,<empty>,3,,550,2,,void
143711,BLOCK,-1,,<empty>,20,,551,2,,void
143717,BLOCK,1,,<empty>,,,,6,,void
143719,BLOCK,-1,,THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length())),3,,552,1,,void
143735,BLOCK,-1,,<empty>,3,,552,2,,void
143743,BLOCK,-1,,<empty>,3,,552,2,,void
143797,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }",33,,563,2,,void
143822,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  Local<Object> target_obj = args[1].As<Object>();
  SPREAD_BUFFER_ARG(target_obj, target);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end));

  // Copy 0 bytes; we're done
  if (target_start >= target_length || source_start >= source_end)
    return args.GetReturnValue().Set(0);

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");

  if (source_end - source_start > target_length - target_start)
 ...",52,,572,2,,void
143836,BLOCK,1,,<empty>,,,,4,,void
143848,BLOCK,1,,<empty>,,,,4,,void
143889,BLOCK,1,,<empty>,,,,6,,void
143891,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,585,1,,void
143908,BLOCK,-1,,<empty>,3,,585,2,,void
143916,BLOCK,-1,,<empty>,3,,585,2,,void
143927,BLOCK,1,,<empty>,,,,6,,void
143929,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,586,1,,void
143946,BLOCK,-1,,<empty>,3,,586,2,,void
143954,BLOCK,-1,,<empty>,3,,586,2,,void
143965,BLOCK,1,,<empty>,,,,7,,void
143967,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end))",3,,587,1,,void
143987,BLOCK,-1,,<empty>,3,,587,2,,void
143995,BLOCK,-1,,<empty>,3,,587,2,,void
144012,BLOCK,-1,,<empty>,5,,592,2,,void
144029,BLOCK,-1,,<empty>,5,,595,2,,void
144042,BLOCK,-1,,<empty>,5,,599,2,,void
144096,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> ctx = env->context();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);

  size_t start = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start));
  size_t end;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end));

  size_t fill_length = end - start;
  Local<String> str_obj;
  size_t str_length;
  enum encoding enc;

  // OOB Check. Throw the error in JS.
  if (start > end || fill_length + start > ts_obj_length)
    return args.GetReturnValue().Set(-2);

  // First check if Buffer has been passed.
  if (Buffer::HasInstance(args[1])) {
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }

  // Then coerce everything that's not a string.
  if (!args[1]->IsString()) {
    uint32_t val;
    if (!args[1]->Uint32Valu...",52,,610,2,,void
144120,BLOCK,1,,<empty>,,,,4,,void
144138,BLOCK,1,,<empty>,,,,6,,void
144140,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start))",3,,618,1,,void
144157,BLOCK,-1,,<empty>,3,,618,2,,void
144165,BLOCK,-1,,<empty>,3,,618,2,,void
144177,BLOCK,1,,<empty>,,,,6,,void
144179,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end))",3,,620,1,,void
144196,BLOCK,-1,,<empty>,3,,620,2,,void
144204,BLOCK,-1,,<empty>,3,,620,2,,void
144236,BLOCK,-1,,<empty>,5,,629,2,,void
144255,BLOCK,-1,,"{
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }",37,,632,2,,void
144284,BLOCK,-1,,"{
    uint32_t val;
    if (!args[1]->Uint32Value(ctx).To(&val)) return;
    int value = val & 255;
    memset(ts_obj_data + start, value, fill_length);
    return;
  }",29,,641,2,,void
144300,BLOCK,-1,,<empty>,46,,643,2,,void
144345,BLOCK,-1,,"{
    str_length = str_obj->Utf8Length(env->isolate());
    node::Utf8Value str(env->isolate(), args[1]);
    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",20,,654,2,,void
144378,BLOCK,-1,,<empty>,10,,659,1,,void
144383,BLOCK,-1,,"{
    str_length = str_obj->Length() * sizeof(uint16_t);
    node::TwoByteValue str(env->isolate(), args[1]);
    if (IsBigEndian())
      SwapBytes16(reinterpret_cast<char*>(&str[0]), str_length);

    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",27,,659,2,,void
144404,BLOCK,-1,,<empty>,7,,663,2,,void
144426,BLOCK,-1,,"{
    // Write initial String to Buffer, then use that memory to copy remainder
    // of string. Correct the string length for cases like HEX where less than
    // the total string length is written.
    str_length = StringBytes::Write(
        env->isolate(), ts_obj_data + start, fill_length, str_obj, enc);
  }",10,,667,1,,void
144448,BLOCK,-1,,<empty>,5,,678,2,,void
144454,BLOCK,-1,,<empty>,5,,686,2,,void
144483,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, in_there);
    ptr += in_there;
    in_there *= 2;
  }",45,,691,2,,void
144500,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, fill_length - in_there);
  }",31,,697,2,,void
144513,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  SPREAD_BUFFER_ARG(args.This(), ts_obj);

  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""argument"");

  Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();

  size_t offset = 0;
  size_t max_length = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));
  if (offset > ts_obj_length) {
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length));

  max_length = std::min(ts_obj_length - offset, max_length);

  if (max_length == 0)
    return args.GetReturnValue().Set(0);

  uint32_t written = StringBytes::Write(
      env->isolate(), ts_obj_data + offset, max_length, str, encoding);
  args.GetReturnValue().Set(written);
}",59,,704,2,,void
144528,BLOCK,1,,<empty>,,,,4,,void
144577,BLOCK,1,,<empty>,,,,6,,void
144579,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset))",3,,717,1,,void
144596,BLOCK,-1,,<empty>,3,,717,2,,void
144604,BLOCK,-1,,<empty>,3,,717,2,,void
144617,BLOCK,-1,,"{
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }",31,,718,2,,void
144627,BLOCK,1,,<empty>,,,,7,,void
144629,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length))",3,,723,1,,void
144648,BLOCK,-1,,<empty>,3,,723,2,,void
144656,BLOCK,-1,,<empty>,3,,723,2,,void
144679,BLOCK,-1,,<empty>,5,,729,2,,void
144718,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  // Fast case: avoid StringBytes on UTF8 string. Jump to v8.
  args.GetReturnValue().Set(args[0].As<String>()->Utf8Length(env->isolate()));
}",66,,736,2,,void
144759,BLOCK,-1,,"{
  uint32_t result = 0;
  uint32_t length = source.length;
  const uint8_t* data = reinterpret_cast<const uint8_t*>(source.data);
  for (uint32_t i = 0; i < length; ++i) {
    result += (data[i] >> 7);
  }
  result += length;
  return result;
}",66,,745,3,,void
144779,BLOCK,-1,,<empty>,3,,749,1,,void
144789,BLOCK,4,,"{
    result += (data[i] >> 7);
  }",41,,749,4,,void
144806,BLOCK,-1,,<empty>,,,,2,,<empty>
144813,BLOCK,-1,,"{
  if (val == 0) {
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  } else {
    if (val > 0)
      return 1;
    else
      return -1;
  }
  return val;
}",75,,761,4,,void
144818,BLOCK,-1,,"{
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  }",17,,762,2,,void
144823,BLOCK,-1,,<empty>,7,,764,2,,void
144827,BLOCK,-1,,<empty>,10,,765,1,,void
144832,BLOCK,-1,,<empty>,7,,766,2,,void
144837,BLOCK,-1,,"{
    if (val > 0)
      return 1;
    else
      return -1;
  }",10,,767,1,,void
144842,BLOCK,-1,,<empty>,7,,769,2,,void
144846,BLOCK,-1,,<empty>,7,,771,1,,void
144856,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  ArrayBufferViewContents<char> target(args[1]);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;
  size_t target_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end));

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");
  if (target_start > target.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The va...",61,,776,2,,void
144870,BLOCK,1,,<empty>,,,,4,,void
144882,BLOCK,1,,<empty>,,,,4,,void
144917,BLOCK,1,,<empty>,,,,6,,void
144919,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,789,1,,void
144936,BLOCK,-1,,<empty>,3,,789,2,,void
144944,BLOCK,-1,,<empty>,3,,789,2,,void
144955,BLOCK,1,,<empty>,,,,6,,void
144957,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,790,1,,void
144974,BLOCK,-1,,<empty>,3,,790,2,,void
144982,BLOCK,-1,,<empty>,3,,790,2,,void
144993,BLOCK,1,,<empty>,,,,7,,void
144995,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end))",3,,791,1,,void
145015,BLOCK,-1,,<empty>,3,,791,2,,void
145023,BLOCK,-1,,<empty>,3,,791,2,,void
145034,BLOCK,1,,<empty>,,,,7,,void
145036,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end))",3,,793,1,,void
145056,BLOCK,-1,,<empty>,3,,793,2,,void
145064,BLOCK,-1,,<empty>,3,,793,2,,void
145080,BLOCK,-1,,<empty>,5,,797,2,,void
145092,BLOCK,-1,,<empty>,5,,800,2,,void
145167,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> a(args[0]);
  ArrayBufferViewContents<char> b(args[1]);

  size_t cmp_length = std::min(a.length(), b.length());

  int val = normalizeCompareVal(cmp_length > 0 ?
                                memcmp(a.data(), b.data(), cmp_length) : 0,
                                a.length(), b.length());
  args.GetReturnValue().Set(val);
}",55,,820,2,,void
145181,BLOCK,1,,<empty>,,,,4,,void
145193,BLOCK,1,,<empty>,,,,4,,void
145267,BLOCK,-1,,"{
  int64_t length_i64 = static_cast<int64_t>(length);
  if (offset_i64 < 0) {
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  } else {
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }
}",40,,843,5,,void
145278,BLOCK,-1,,"{
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  }",23,,845,2,,void
145285,BLOCK,-1,,"{
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    }",39,,846,2,,void
145291,BLOCK,-1,,<empty>,12,,849,1,,void
145298,BLOCK,-1,,"{
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    }",50,,849,2,,void
145302,BLOCK,-1,,"{
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }",12,,852,1,,void
145307,BLOCK,-1,,"{
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }",10,,856,1,,void
145314,BLOCK,-1,,"{
      // Valid positive offset.
      return offset_i64;
    }",51,,857,2,,void
145318,BLOCK,-1,,<empty>,12,,860,1,,void
145323,BLOCK,-1,,"{
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    }",36,,860,2,,void
145327,BLOCK,-1,,<empty>,12,,863,1,,void
145330,BLOCK,-1,,"{
      // indexOf from past the end of the buffer: no match.
      return -1;
    }",28,,863,2,,void
145335,BLOCK,-1,,"{
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }",12,,866,1,,void
145344,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[1]->IsString());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  Local<String> needle = args[1].As<String>();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = buffer.data();
  // Round down to the nearest multiple of 2 in case of UCS2.
  const size_t haystack_length = (enc == UCS2) ?
      buffer.length() &~ 1 : buffer.length();  // NOLINT(whitespace/operators)

  size_t needle_length;
  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                             ...",61,,873,2,,void
145407,BLOCK,1,,<empty>,,,,4,,void
145492,BLOCK,-1,,<empty>,68,,897,2,,void
145506,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,904,2,,void
145522,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,910,2,,void
145538,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,914,2,,void
145570,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,920,2,,void
145589,BLOCK,-1,,"{
    String::Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    if (haystack_length < 2 || needle_value.length() < 1) {
      return args.GetReturnValue().Set(-1);
    }

    if (IsBigEndian()) {
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    } else {
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
           ...",20,,926,2,,void
145599,BLOCK,-1,,<empty>,7,,929,2,,void
145621,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",59,,931,2,,void
145634,BLOCK,-1,,"{
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    }",24,,935,2,,void
145647,BLOCK,-1,,<empty>,57,,937,2,,void
145662,BLOCK,-1,,<empty>,9,,942,2,,void
145694,BLOCK,-1,,"{
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            reinterpret_cast<const uint16_t*>(*needle_value),
                            needle_value.length(),
                            offset / 2,
                            is_forward);
    }",12,,950,1,,void
145720,BLOCK,-1,,<empty>,10,,959,1,,void
145725,BLOCK,-1,,"{
    String::Utf8Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          reinterpret_cast<const uint8_t*>(*needle_value),
                          needle_length,
                          offset,
                          is_forward);
  }",27,,959,2,,void
145735,BLOCK,-1,,<empty>,7,,962,2,,void
145761,BLOCK,-1,,<empty>,10,,970,1,,void
145766,BLOCK,-1,,"{
    uint8_t* needle_data = node::UncheckedMalloc<uint8_t>(needle_length);
    if (needle_data == nullptr) {
      return args.GetReturnValue().Set(-1);
    }
    needle->WriteOneByte(
        isolate, needle_data, 0, needle_length, String::NO_NULL_TERMINATION);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          needle_data,
                          needle_length,
                          offset,
                          is_forward);
    free(needle_data);
  }",29,,970,2,,void
145781,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",33,,972,2,,void
145836,BLOCK,-1,,"{
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[1]);
  ArrayBufferViewContents<char> haystack_contents(args[0]);
  ArrayBufferViewContents<char> needle_contents(args[1]);
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = haystack_contents.data();
  const size_t haystack_length = haystack_contents.length();
  const char* needle = needle_contents.data();
  const size_t needle_length = needle_contents.length();

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                                     needle_length,
                                     is_forward);

  if (nee...",61,,991,2,,void
145888,BLOCK,1,,<empty>,,,,3,,void
145908,BLOCK,1,,<empty>,,,,3,,void
145990,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,1016,2,,void
146006,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,1022,2,,void
146022,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,1026,2,,void
146054,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,1032,2,,void
146073,BLOCK,-1,,"{
    if (haystack_length < 2 || needle_length < 2) {
      return args.GetReturnValue().Set(-1);
    }
    result = SearchString(
        reinterpret_cast<const uint16_t*>(haystack),
        haystack_length / 2,
        reinterpret_cast<const uint16_t*>(needle),
        needle_length / 2,
        offset / 2,
        is_forward);
    result *= 2;
  }",20,,1038,2,,void
146082,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",51,,1039,2,,void
146116,BLOCK,-1,,"{
    result = SearchString(
        reinterpret_cast<const uint8_t*>(haystack),
        haystack_length,
        reinterpret_cast<const uint8_t*>(needle),
        needle_length,
        offset,
        is_forward);
  }",10,,1050,1,,void
146150,BLOCK,-1,,"{
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsBoolean());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  uint32_t needle = args[1].As<Uint32>()->Value();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[3]->IsTrue();

  int64_t opt_offset =
      IndexOfOffset(buffer.length(), offset_i64, 1, is_forward);
  if (opt_offset <= -1 || buffer.length() == 0) {
    return args.GetReturnValue().Set(-1);
  }
  size_t offset = static_cast<size_t>(opt_offset);
  CHECK_LT(offset, buffer.length());

  const void* ptr;
  if (is_forward) {
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  } else {
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }
  const char* ptr_char = static_cast<const char*>(ptr);
  args.GetReturnValue().Set(ptr ? static_cast<int>(ptr_char - buffer.data())
                   ...",61,,1064,2,,void
146181,BLOCK,1,,<empty>,,,,3,,void
146253,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",49,,1078,2,,void
146279,BLOCK,-1,,"{
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  }",19,,1085,2,,void
146297,BLOCK,-1,,"{
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }",10,,1087,1,,void
146343,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes16(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1096,2,,void
146357,BLOCK,1,,<empty>,,,,4,,void
146386,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes32(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1105,2,,void
146400,BLOCK,1,,<empty>,,,,4,,void
146429,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes64(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1114,2,,void
146443,BLOCK,1,,<empty>,,,,4,,void
146472,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_utf8(abv.data(), abv.length()));
}",61,,1122,2,,void
146518,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1129,2,,void
146549,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_ascii(abv.data(), abv.length()));
}",62,,1137,2,,void
146595,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1144,2,,void
146626,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);

  // TODO(legendecas): Remove this check once the binding supports sub-realms.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);

  CHECK(args[0]->IsObject());
  Local<Object> proto = args[0].As<Object>();
  realm->set_buffer_prototype_object(proto);
}",66,,1152,2,,void
146673,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  NodeArrayBufferAllocator* allocator = env->isolate_data()->node_allocator();
  Local<ArrayBuffer> ab;
  // It can be a nullptr when running inside an isolate where we
  // do not own the ArrayBuffer allocator.
  if (allocator == nullptr) {
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  } else {
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }

  ab->SetPrivate(
      env->context(),...",65,,1163,2,,void
146701,BLOCK,-1,,"{
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  }",29,,1169,2,,void
146715,BLOCK,-1,,"{
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }",10,,1174,1,,void
146794,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (args[0]->IsArrayBuffer()) {
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }
}",65,,1192,2,,void
146810,BLOCK,-1,,"{
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }",33,,1194,2,,void
146828,BLOCK,-1,,"{
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }",30,,1196,2,,void
146870,BLOCK,-1,,"{
  void* pointer;
  size_t byte_length;
  if (buffer->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else if (buffer->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else {
    UNREACHABLE();  // Caller must validate.
  }
  return {pointer, byte_length};
}",70,,1206,2,,void
146878,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",32,,1209,2,,void
146902,BLOCK,-1,,<empty>,10,,1213,1,,void
146908,BLOCK,-1,,"{
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",45,,1213,2,,void
146932,BLOCK,-1,,"{
    UNREACHABLE();  // Caller must validate.
  }",10,,1217,1,,void
146939,BLOCK,-1,,"{
  // args[0] == Destination ArrayBuffer
  // args[1] == Destination ArrayBuffer Offset
  // args[2] == Source ArrayBuffer
  // args[3] == Source ArrayBuffer Offset
  // args[4] == bytesToCopy

  CHECK(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsArrayBuffer() || args[2]->IsSharedArrayBuffer());
  CHECK(args[3]->IsUint32());
  CHECK(args[4]->IsUint32());

  void* destination;
  size_t destination_byte_length;
  std::tie(destination, destination_byte_length) =
      DecomposeBufferToParts(args[0]);

  void* source;
  size_t source_byte_length;
  std::tie(source, source_byte_length) = DecomposeBufferToParts(args[2]);

  uint32_t destination_offset = args[1].As<Uint32>()->Value();
  uint32_t source_offset = args[3].As<Uint32>()->Value();
  size_t bytes_to_copy = args[4].As<Uint32>()->Value();

  CHECK_GE(destination_byte_length - destination_offset, bytes_to_copy);
  CHECK_GE(source_byte_length - source_offset, bytes_to_...",63,,1225,2,,void
147088,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""setBufferPrototype"", SetBufferPrototype);
  SetMethodNoSideEffect(context, target, ""createFromString"", CreateFromString);

  SetFastMethodNoSideEffect(context,
                            target,
                            ""byteLengthUtf8"",
                            SlowByteLengthUtf8,
                            &fast_byte_length_utf8);
  SetMethod(context, target, ""copy"", Copy);
  SetMethodNoSideEffect(context, target, ""compare"", Compare);
  SetMethodNoSideEffect(context, target, ""compareOffset"", CompareOffset);
  SetMethod(context, target, ""fill"", Fill);
  SetMethodNoSideEffect(context, target, ""indexOfBuffer"", IndexOfBuffer);
  SetMethodNoSideEffect(context, target, ""indexOfNumber"", IndexOfNumber);
  SetMethodNoSideEffect(context, target, ""indexOfString"", IndexOfString);

  SetMethod(context, target, ""detachArrayBuffer"", DetachArrayBuffer);
  SetMethod(...",29,,1262,5,,void
147306,BLOCK,-1,,"{
  registry->Register(SetBufferPrototype);
  registry->Register(CreateFromString);

  registry->Register(SlowByteLengthUtf8);
  registry->Register(fast_byte_length_utf8.GetTypeInfo());
  registry->Register(FastByteLengthUtf8);
  registry->Register(Copy);
  registry->Register(Compare);
  registry->Register(CompareOffset);
  registry->Register(Fill);
  registry->Register(IndexOfBuffer);
  registry->Register(IndexOfNumber);
  registry->Register(IndexOfString);

  registry->Register(Swap16);
  registry->Register(Swap32);
  registry->Register(Swap64);

  registry->Register(IsUtf8);
  registry->Register(IsAscii);

  registry->Register(StringSlice<ASCII>);
  registry->Register(StringSlice<BASE64>);
  registry->Register(StringSlice<BASE64URL>);
  registry->Register(StringSlice<LATIN1>);
  registry->Register(StringSlice<HEX>);
  registry->Register(StringSlice<UCS2>);
  registry->Register(StringSlice<UTF8>);

  registry->Register(StringWrite<ASCII>);
  registry->Register(StringWrite<BASE64>)...",70,,1326,2,,void
147491,BLOCK,-1,,<empty>,1,,1,1,,ANY
147505,BLOCK,-1,,<empty>,,,,3,,<empty>
147510,BLOCK,-1,,<empty>,,,,2,,<empty>
147515,BLOCK,-1,,<empty>,,,,2,,<empty>
147520,BLOCK,-1,,<empty>,,,,2,,<empty>
147527,BLOCK,-1,,<empty>,,,,4,,<empty>
147533,BLOCK,-1,,<empty>,,,,3,,<empty>
147540,BLOCK,-1,,<empty>,,,,4,,<empty>
147549,BLOCK,-1,,<empty>,,,,6,,<empty>
147556,BLOCK,-1,,<empty>,,,,4,,<empty>
147564,BLOCK,-1,,<empty>,,,,5,,<empty>
147571,BLOCK,-1,,"{
  // Asking to seek too far into the buffer
  // check to avoid wrapping in subsequent subtraction
  if (off > max)
    return false;

  // Asking for more than is left over in the buffer
  if (max - off < len)
    return false;

  // Otherwise we're in bounds
  return true;
}",71,,75,4,,void
147576,BLOCK,-1,,<empty>,5,,79,2,,void
147585,BLOCK,-1,,<empty>,5,,83,2,,void
147612,BLOCK,-1,,<empty>,1,,1,1,,ANY
147616,BLOCK,-1,,"{
  LoadJavaScriptSource();
#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/dist/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  AddExternalizedBuiltin(""internal/deps/undici/undici"",
                         STRINGIFY(NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH));
#endif  // NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
}",79,,36,1,,void
147622,BLOCK,-1,,"{
  auto source = source_.read();
  return source->find(id) != source->end();
}",44,,56,2,,void
147646,BLOCK,-1,,"{
  auto result = source_.write()->emplace(id, source);
  return result.second;
}",67,,61,3,,void
147668,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<Object> out = Object::New(isolate);
  auto source = env->builtin_loader()->source_.read();
  for (auto const& x : *source) {
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }
  info.GetReturnValue().Set(out);
}",73,,67,3,,void
147721,BLOCK,-1,,"{
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }",33,,74,3,,void
147770,BLOCK,-1,,"{
  return config_.ToStringChecked(isolate);
}",64,,81,2,,void
147780,BLOCK,-1,,"{
  std::vector<std::string> ids;
  auto source = source_.read();
  ids.reserve(source->size());
  for (auto const& x : *source) {
    ids.emplace_back(x.first);
  }
  return ids;
}",63,,85,1,,void
147809,BLOCK,-1,,"{
    ids.emplace_back(x.first);
  }",33,,89,3,,void
147822,BLOCK,-1,,"{
  BuiltinCategories builtin_categories;

  std::vector<std::string> prefixes = {
#if !HAVE_OPENSSL
    ""internal/crypto/"",
    ""internal/debugger/"",
#endif  // !HAVE_OPENSSL

    ""internal/bootstrap/"",
    ""internal/per_context/"",
    ""internal/deps/"",
    ""internal/main/""
  };

  builtin_categories.can_be_required.emplace(
      ""internal/deps/cjs-module-lexer/lexer"");

  builtin_categories.cannot_be_required = std::set<std::string> {
#if !HAVE_INSPECTOR
    ""inspector"", ""inspector/promises"", ""internal/util/inspector"",
#endif  // !HAVE_INSPECTOR

#if !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)
        ""trace_events"",
#endif  // !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)

#if !HAVE_OPENSSL
        ""crypto"", ""crypto/promises"", ""https"", ""http2"", ""tls"", ""_tls_common"",
        ""_tls_wrap"", ""internal/tls/secure-pair"",
        ""internal/tls/parse-cert-string"", ""internal/tls/secure-context"",
        ""internal/http2/core"", ""internal/http2/compat"",
        ""int...",78,,95,1,,void
147882,BLOCK,-1,,"{
    const std::string& id = x.first;
    for (auto const& prefix : prefixes) {
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }
  }",33,,137,3,,void
147892,BLOCK,-1,,"{
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }",41,,139,3,,void
147903,BLOCK,-1,,"{
        continue;
      }",42,,140,2,,void
147923,BLOCK,-1,,"{
        builtin_categories.cannot_be_required.emplace(id);
      }",62,,144,2,,void
147935,BLOCK,-1,,"{
    const std::string& id = x.first;
    if (0 == builtin_categories.cannot_be_required.count(id)) {
      builtin_categories.can_be_required.emplace(id);
    }
  }",33,,150,3,,void
147952,BLOCK,-1,,"{
      builtin_categories.can_be_required.emplace(id);
    }",63,,152,2,,void
147967,BLOCK,-1,,"{
  auto source = source_.read();
#ifndef NODE_BUILTIN_MODULES_PATH
  const auto source_it = source->find(id);
  if (UNLIKELY(source_it == source->end())) {
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }
  return source_it->second.ToStringChecked(isolate);
#else   // !NODE_BUILTIN_MODULES_PATH
  std::string filename = OnDiskFileName(id);

  std::string contents;
  int r = ReadFileSync(&contents, filename.c_str());
  if (r != 0) {
    const std::string buf = SPrintF(""Cannot read local builtin. %s: %s \""%s\"""",
                                    uv_err_name(r),
                                    uv_strerror(r),
                                    filename);
    Local<String> message = OneByteString(isolate, buf.c_str());
    isolate->ThrowException(v8::Exception::Error(message));
    return MaybeLocal<String>();
  }
  return String::NewFromUtf8(
      isolate, contents.c_str(), v8::NewStringType::kNormal, contents.length());
#endif  // NODE_BUILTIN...",75,,178,3,,void
147991,BLOCK,-1,,"{
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }",45,,182,2,,void
148013,BLOCK,-1,,"{
  StaticExternalTwoByteResource* resource;
  {
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              ou...",66,,213,3,,void
148015,BLOCK,2,,"{
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(resu...",3,,215,2,,void
148034,BLOCK,-1,,"{
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(result.second);
      it = result.first;
    }",51,,218,2,,void
148047,BLOCK,-1,,"{
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }",19,,221,2,,void
148162,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope scope(isolate);

  Local<String> source;
  if (!LoadBuiltinSource(isolate, id).ToLocal(&source)) {
    return {};
  }

  std::string filename_s = std::string(""node:"") + id;
  Local<String> filename =
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  ScriptOrigin origin(isolate, filename, 0, 0, true);

  BuiltinCodeCacheData cached_data{};
  {
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }

  const bool has_cache = cached_data.data ...",36,,257,5,,void
148188,BLOCK,-1,,"{
    return {};
  }",57,,262,2,,void
148227,BLOCK,14,,"{
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }",3,,272,14,,void
148252,BLOCK,-1,,"{
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }",45,,279,2,,void
148341,BLOCK,-1,,"{
    // In the case of early errors, v8 is already capable of
    // decorating the stack for us - note that we use CompileFunction
    // so there is no need to worry about wrappers.
    return MaybeLocal<Function>();
  }",33,,311,2,,void
148365,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::CODE_CACHE,
                       ""Code cache of %s (%s) %s\n"",
                       id,
                       script_source.GetCachedData()->buffer_policy ==
                               ScriptCompiler::CachedData::BufferNotOwned
                           ? ""BufferNotOwned""
                           : ""BufferOwned"",
                       script_source.GetCachedData()->rejected ? ""is rejected""
                                                               : ""is accepted"");
  }",18,,327,2,,void
148406,BLOCK,-1,,"{
    // We failed to accept this cache, maybe because it was rejected, maybe
    // because it wasn't present. Either way, we'll attempt to replace this
    // code cache info with a new one.
    std::shared_ptr<ScriptCompiler::CachedData> new_cached_data(
        ScriptCompiler::CreateCodeCacheForFunction(fun));
    CHECK_NOT_NULL(new_cached_data);

    {
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }
  }",41,,339,2,,void
148409,BLOCK,-1,,<empty>,,,,2,,<empty>
148414,BLOCK,3,,"{
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }",5,,347,3,,void
148445,BLOCK,-1,,"{
  Result result;
  std::vector<Local<String>> parameters;
  Isolate* isolate = context->GetIsolate();
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id,
                     ""internal/per_context/"",
                     strlen(""internal/per_context/"")) == 0) {
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id, ""internal/main/"", strlen(""internal/main/"")) == 0 ||
   ...",77,,359,4,,void
148469,BLOCK,-1,,"{
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",52,,366,2,,void
148473,BLOCK,-1,,<empty>,10,,373,1,,void
148482,BLOCK,-1,,"{
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",61,,375,2,,void
148486,BLOCK,-1,,<empty>,10,,381,1,,void
148503,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",59,,384,2,,void
148507,BLOCK,-1,,"{
    // others: exports, require, module, process, internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""module""),
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",10,,393,1,,void
148527,BLOCK,-1,,"{
    DCHECK_EQ(this, optional_realm->env()->builtin_loader());
    RecordResult(id, result, optional_realm);
  }",34,,407,2,,void
148549,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  std::vector<Local<Value>> arguments;
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  } else if ...",63,,416,4,,void
148572,BLOCK,-1,,"{
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  }",52,,424,2,,void
148615,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",47,,432,2,,void
148621,BLOCK,-1,,<empty>,10,,439,1,,void
148638,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    arguments = {realm->process_object(),
                 realm->builtin_module_require(),
                 realm->internal_binding_loader(),
                 realm->primordials()};
  }",59,,442,2,,void
148642,BLOCK,-1,,"{
    // This should be invoked with the other CompileAndCall() methods, as
    // we are unable to generate the arguments.
    // Currently there are two cases:
    // internal/per_context/*: the arguments are generated in
    //                         InitializePrimordials()
    // all the other cases: the arguments are generated in the JS-land loader.
    UNREACHABLE();
  }",10,,449,1,,void
148665,BLOCK,-1,,"{
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  MaybeLocal<Function> maybe_fn = LookupAndCompile(context, id, optional_realm);
  Local<Function> fn;
  if (!maybe_fn.ToLocal(&fn)) {
    return MaybeLocal<Value>();
  }
  Local<Value> undefined = Undefined(context->GetIsolate());
  return fn->Call(context, undefined, argc, argv);
}",72,,465,6,,void
148689,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",31,,470,2,,void
148716,BLOCK,-1,,"{
  std::vector<std::string> ids = GetBuiltinIds();
  bool all_succeeded = true;
  std::string v8_tools_prefix = ""internal/deps/v8/tools/"";
  for (const auto& id : ids) {
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }
  return all_succeeded;
}",64,,477,2,,void
148739,BLOCK,-1,,"{
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }",30,,481,3,,void
148753,BLOCK,-1,,"{
      continue;
    }",70,,482,2,,void
148774,BLOCK,-1,,"{
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }",37,,487,2,,void
148803,BLOCK,-1,,"{
  RwLock::ScopedReadLock lock(code_cache_->mutex);
  for (auto const& item : code_cache_->map) {
    out->push_back({item.first, item.second});
  }
}",74,,498,2,,void
148814,BLOCK,-1,,"{
    out->push_back({item.first, item.second});
  }",45,,500,3,,void
148830,BLOCK,-1,,"{
  RwLock::ScopedLock lock(code_cache_->mutex);
  code_cache_->map.reserve(in.size());
  DCHECK(code_cache_->map.empty());
  for (auto const& item : in) {
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }
  code_cache_->has_code_cache = true;
}",76,,505,2,,void
148856,BLOCK,-1,,"{
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }",31,,509,3,,void
148890,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<Object> result = Object::New(isolate);

  BuiltinCategories builtin_categories =
      env->builtin_loader()->GetBuiltinCategories();

  if (!env->owns_process_state()) {
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }

  Local<Value> cannot_be_required_js;
  Local<Value> can_be_required_js;

  if (!ToV8Value(context, builtin_categories.cannot_be_required)
           .ToLocal(&cannot_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteString(isolate, ""cannotBeRequired""),
                cannot_be_required_js)
          .IsNothing())
    return;
  if (!ToV8Value(context, builtin_categories.can_be_required)
           .ToLocal(&can_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteStrin...",68,,518,3,,void
148943,BLOCK,-1,,"{
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }",35,,527,2,,void
148980,BLOCK,-1,,<empty>,5,,537,2,,void
148995,BLOCK,-1,,<empty>,5,,543,2,,void
149009,BLOCK,-1,,<empty>,5,,546,2,,void
149024,BLOCK,-1,,"{
    return;
  }",25,,551,2,,void
149038,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<Object> result = Object::New(isolate);

  Local<Value> builtins_with_cache_js;
  Local<Value> builtins_without_cache_js;
  Local<Value> builtins_in_snapshot_js;
  if (!ToV8Value(context, realm->builtins_with_cache)
           .ToLocal(&builtins_with_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithCache""),
                builtins_with_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_without_cache)
           .ToLocal(&builtins_without_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithoutCache""),
                builtins_without_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_in_snapshot)
           .ToLocal(&builtins_in_...",76,,557,2,,void
149102,BLOCK,-1,,"{
    return;
  }",47,,567,2,,void
149117,BLOCK,-1,,"{
    return;
  }",25,,574,2,,void
149131,BLOCK,-1,,"{
    return;
  }",50,,579,2,,void
149146,BLOCK,-1,,"{
    return;
  }",25,,586,2,,void
149160,BLOCK,-1,,"{
    return;
  }",48,,591,2,,void
149175,BLOCK,-1,,"{
    return;
  }",25,,598,2,,void
149190,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();

  std::vector<std::string> ids = env->builtin_loader()->GetBuiltinIds();
  info.GetReturnValue().Set(
      ToV8Value(isolate->GetCurrentContext(), ids).ToLocalChecked());
}",79,,606,3,,void
149244,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->builtin_loader()->GetConfigString(info.GetIsolate()));
}",68,,616,3,,void
149277,BLOCK,-1,,"{
  if (result == BuiltinLoader::Result::kWithCache) {
    realm->builtins_with_cache.insert(id);
  } else {
    realm->builtins_without_cache.insert(id);
  }
}",48,,624,4,,void
149286,BLOCK,-1,,"{
    realm->builtins_with_cache.insert(id);
  }",52,,625,2,,void
149295,BLOCK,-1,,"{
    realm->builtins_without_cache.insert(id);
  }",10,,627,1,,void
149307,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsString());
  node::Utf8Value id_v(realm->isolate(), args[0].As<String>());
  const char* id = *id_v;
  MaybeLocal<Function> maybe = realm->env()->builtin_loader()->LookupAndCompile(
      realm->context(), id, realm);
  Local<Function> fn;
  if (maybe.ToLocal(&fn)) {
    args.GetReturnValue().Set(fn);
  }
}",78,,632,2,,void
149374,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",27,,640,2,,void
149387,BLOCK,-1,,"{
  auto instance = Environment::GetCurrent(args)->builtin_loader();
  RwLock::ScopedReadLock lock(instance->code_cache_->mutex);
  args.GetReturnValue().Set(v8::Boolean::New(
      args.GetIsolate(), instance->code_cache_->has_code_cache));
}",80,,645,2,,void
149432,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  DCHECK(realm->internal_binding_loader().IsEmpty());
  DCHECK(realm->builtin_module_require().IsEmpty());
  realm->set_internal_binding_loader(args[0].As<Function>());
  realm->set_builtin_module_require(args[1].As<Function>());
}",66,,652,2,,void
149495,BLOCK,-1,,"{
  code_cache_ = other->code_cache_;
  source_ = other->source_;
}",33,,663,2,,void
149511,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  target->SetAccessor(isolate_data->config_string(),
                      ConfigStringGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinIds""),
                      BuiltinIdsGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinCategories""),
                      GetBuiltinCategories,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""natives""),
   ...",78,,669,3,,void
149611,BLOCK,-1,,"{
  // internalBinding('builtins') should be frozen
  target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();
}",60,,713,5,,void
149627,BLOCK,-1,,"{
  registry->Register(ConfigStringGetter);
  registry->Register(BuiltinIdsGetter);
  registry->Register(GetBuiltinCategories);
  registry->Register(GetCacheUsage);
  registry->Register(CompileFunction);
  registry->Register(HasCachedBuiltins);
  registry->Register(SetInternalLoaders);
  registry->Register(GetNatives);

  RegisterExternalReferencesForInternalizedBuiltinCode(registry);
}",42,,719,2,,void
149701,BLOCK,-1,,<empty>,1,,1,1,,ANY
149720,BLOCK,-1,,<empty>,1,,1,1,,ANY
149727,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#if defined(DEBUG) && DEBUG
  READONLY_TRUE_PROPERTY(target, ""isDebugBuild"");
#else
  READONLY_FALSE_PROPERTY(target, ""isDebugBuild"");
#endif  // defined(DEBUG) && DEBUG

#if HAVE_OPENSSL
  READONLY_TRUE_PROPERTY(target, ""hasOpenSSL"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasOpenSSL"");
#endif  // HAVE_OPENSSL

  READONLY_TRUE_PROPERTY(target, ""fipsMode"");

#ifdef NODE_HAVE_I18N_SUPPORT

  READONLY_TRUE_PROPERTY(target, ""hasIntl"");

#ifdef NODE_HAVE_SMALL_ICU
  READONLY_TRUE_PROPERTY(target, ""hasSmallICU"");
#endif  // NODE_HAVE_SMALL_ICU

#if NODE_USE_V8_PLATFORM
  READONLY_TRUE_PROPERTY(target, ""hasTracing"");
#endif

#if !defined(NODE_WITHOUT_NODE_OPTIONS)
  READONLY_TRUE_PROPERTY(target, ""hasNodeOptions"");
#endif

#endif  // NODE_HAVE_I18N_SUPPORT

#if HAVE_INSPECTOR
  READONLY_TRUE_PROPERTY(target, ""hasInspector"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasInspector"");
#endif

// c...",36,,29,5,,void
149811,BLOCK,-1,,<empty>,1,,1,1,,ANY
149816,BLOCK,-1,,"{
#ifdef E2BIG
  NODE_DEFINE_CONSTANT(target, E2BIG);
#endif

#ifdef EACCES
  NODE_DEFINE_CONSTANT(target, EACCES);
#endif

#ifdef EADDRINUSE
  NODE_DEFINE_CONSTANT(target, EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
  NODE_DEFINE_CONSTANT(target, EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
  NODE_DEFINE_CONSTANT(target, EAFNOSUPPORT);
#endif

#ifdef EAGAIN
  NODE_DEFINE_CONSTANT(target, EAGAIN);
#endif

#ifdef EALREADY
  NODE_DEFINE_CONSTANT(target, EALREADY);
#endif

#ifdef EBADF
  NODE_DEFINE_CONSTANT(target, EBADF);
#endif

#ifdef EBADMSG
  NODE_DEFINE_CONSTANT(target, EBADMSG);
#endif

#ifdef EBUSY
  NODE_DEFINE_CONSTANT(target, EBUSY);
#endif

#ifdef ECANCELED
  NODE_DEFINE_CONSTANT(target, ECANCELED);
#endif

#ifdef ECHILD
  NODE_DEFINE_CONSTANT(target, ECHILD);
#endif

#ifdef ECONNABORTED
  NODE_DEFINE_CONSTANT(target, ECONNABORTED);
#endif

#ifdef ECONNREFUSED
  NODE_DEFINE_CONSTANT(target, ECONNREFUSED);
#endif

#ifdef ECONNRESET
  NODE_DEFINE_CONSTANT(target, ECONNRESET);
#...",49,,75,2,,void
149821,BLOCK,-1,,"{
#ifdef WSAEINTR
  NODE_DEFINE_CONSTANT(target, WSAEINTR);
#endif

#ifdef WSAEBADF
  NODE_DEFINE_CONSTANT(target, WSAEBADF);
#endif

#ifdef WSAEACCES
  NODE_DEFINE_CONSTANT(target, WSAEACCES);
#endif

#ifdef WSAEFAULT
  NODE_DEFINE_CONSTANT(target, WSAEFAULT);
#endif

#ifdef WSAEINVAL
  NODE_DEFINE_CONSTANT(target, WSAEINVAL);
#endif

#ifdef WSAEMFILE
  NODE_DEFINE_CONSTANT(target, WSAEMFILE);
#endif

#ifdef WSAEWOULDBLOCK
  NODE_DEFINE_CONSTANT(target, WSAEWOULDBLOCK);
#endif

#ifdef WSAEINPROGRESS
  NODE_DEFINE_CONSTANT(target, WSAEINPROGRESS);
#endif

#ifdef WSAEALREADY
  NODE_DEFINE_CONSTANT(target, WSAEALREADY);
#endif

#ifdef WSAENOTSOCK
  NODE_DEFINE_CONSTANT(target, WSAENOTSOCK);
#endif

#ifdef WSAEDESTADDRREQ
  NODE_DEFINE_CONSTANT(target, WSAEDESTADDRREQ);
#endif

#ifdef WSAEMSGSIZE
  NODE_DEFINE_CONSTANT(target, WSAEMSGSIZE);
#endif

#ifdef WSAEPROTOTYPE
  NODE_DEFINE_CONSTANT(target, WSAEPROTOTYPE);
#endif

#ifdef WSAENOPROTOOPT
  NODE_DEFINE_CONSTANT(target, WSAENOPROT...",56,,393,2,,void
149826,BLOCK,-1,,"{
#ifdef SIGHUP
  NODE_DEFINE_CONSTANT(target, SIGHUP);
#endif

#ifdef SIGINT
  NODE_DEFINE_CONSTANT(target, SIGINT);
#endif

#ifdef SIGQUIT
  NODE_DEFINE_CONSTANT(target, SIGQUIT);
#endif

#ifdef SIGILL
  NODE_DEFINE_CONSTANT(target, SIGILL);
#endif

#ifdef SIGTRAP
  NODE_DEFINE_CONSTANT(target, SIGTRAP);
#endif

#ifdef SIGABRT
  NODE_DEFINE_CONSTANT(target, SIGABRT);
#endif

#ifdef SIGIOT
  NODE_DEFINE_CONSTANT(target, SIGIOT);
#endif

#ifdef SIGBUS
  NODE_DEFINE_CONSTANT(target, SIGBUS);
#endif

#ifdef SIGFPE
  NODE_DEFINE_CONSTANT(target, SIGFPE);
#endif

#ifdef SIGKILL
  NODE_DEFINE_CONSTANT(target, SIGKILL);
#endif

#ifdef SIGUSR1
  NODE_DEFINE_CONSTANT(target, SIGUSR1);
#endif

#ifdef SIGSEGV
  NODE_DEFINE_CONSTANT(target, SIGSEGV);
#endif

#ifdef SIGUSR2
  NODE_DEFINE_CONSTANT(target, SIGUSR2);
#endif

#ifdef SIGPIPE
  NODE_DEFINE_CONSTANT(target, SIGPIPE);
#endif

#ifdef SIGALRM
  NODE_DEFINE_CONSTANT(target, SIGALRM);
#endif

  NODE_DEFINE_CONSTANT(target, SIGTERM);

#ifde...",50,,627,2,,void
149834,BLOCK,-1,,"{
#ifdef UV_PRIORITY_LOW
# define PRIORITY_LOW UV_PRIORITY_LOW
  NODE_DEFINE_CONSTANT(target, PRIORITY_LOW);
# undef PRIORITY_LOW
#endif

#ifdef UV_PRIORITY_BELOW_NORMAL
# define PRIORITY_BELOW_NORMAL UV_PRIORITY_BELOW_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_BELOW_NORMAL);
# undef PRIORITY_BELOW_NORMAL
#endif

#ifdef UV_PRIORITY_NORMAL
# define PRIORITY_NORMAL UV_PRIORITY_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_NORMAL);
# undef PRIORITY_NORMAL
#endif

#ifdef UV_PRIORITY_ABOVE_NORMAL
# define PRIORITY_ABOVE_NORMAL UV_PRIORITY_ABOVE_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_ABOVE_NORMAL);
# undef PRIORITY_ABOVE_NORMAL
#endif

#ifdef UV_PRIORITY_HIGH
# define PRIORITY_HIGH UV_PRIORITY_HIGH
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGH);
# undef PRIORITY_HIGH
#endif

#ifdef UV_PRIORITY_HIGHEST
# define PRIORITY_HIGHEST UV_PRIORITY_HIGHEST
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGHEST);
# undef PRIORITY_HIGHEST
#endif
}",52,,776,2,,void
149839,BLOCK,-1,,"{
#ifdef OPENSSL_VERSION_NUMBER
    NODE_DEFINE_CONSTANT(target, OPENSSL_VERSION_NUMBER);
#endif

#ifdef SSL_OP_ALL
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALL);
#endif

#ifdef SSL_OP_ALLOW_NO_DHE_KEX
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_NO_DHE_KEX);
#endif

#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
#endif

#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
    NODE_DEFINE_CONSTANT(target, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

#ifdef SSL_OP_CISCO_ANYCONNECT
    NODE_DEFINE_CONSTANT(target, SSL_OP_CISCO_ANYCONNECT);
#endif

#ifdef SSL_OP_COOKIE_EXCHANGE
    NODE_DEFINE_CONSTANT(target, SSL_OP_COOKIE_EXCHANGE);
#endif

#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
    NODE_DEFINE_CONSTANT(target, SSL_OP_CRYPTOPRO_TLSEXT_BUG);
#endif

#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    NODE_DEFINE_CONSTANT(target, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
#endif

#ifdef SSL_OP_LEGACY_SERVER_CONNECT
    NODE_DEFINE_CONSTANT(ta...",50,,814,2,,void
149844,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_DIR);
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_JUNCTION);
  // file access modes
  NODE_DEFINE_CONSTANT(target, O_RDONLY);
  NODE_DEFINE_CONSTANT(target, O_WRONLY);
  NODE_DEFINE_CONSTANT(target, O_RDWR);

  // file types from readdir
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);

  NODE_DEFINE_CONSTANT(target, S_IFMT);
  NODE_DEFINE_CONSTANT(target, S_IFREG);
  NODE_DEFINE_CONSTANT(target, S_IFDIR);
  NODE_DEFINE_CONSTANT(target, S_IFCHR);
#ifdef S_IFBLK
  NODE_DEFINE_CONSTANT(target, S_IFBLK);
#endif

#ifdef S_IFIFO
  NODE_DEFINE_CONSTANT(target, S_IFIFO);
#endif

#ifdef S_IFLNK
  NODE_DEFINE_C...",50,,1043,2,,void
149903,BLOCK,-1,,"{
#ifdef RTLD_LAZY
  NODE_DEFINE_CONSTANT(target, RTLD_LAZY);
#endif

#ifdef RTLD_NOW
  NODE_DEFINE_CONSTANT(target, RTLD_NOW);
#endif

#ifdef RTLD_GLOBAL
  NODE_DEFINE_CONSTANT(target, RTLD_GLOBAL);
#endif

#ifdef RTLD_LOCAL
  NODE_DEFINE_CONSTANT(target, RTLD_LOCAL);
#endif

#ifdef RTLD_DEEPBIND
  NODE_DEFINE_CONSTANT(target, RTLD_DEEPBIND);
#endif
}",50,,1226,2,,void
149908,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_COMPLETE);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_INTO);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_PAST);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_STEP);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_METADATA);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHAS...",49,,1248,2,,void
149994,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);

  CHECK(target->SetPrototype(env->context(), Null(env->isolate())).FromJust());

  Local<Object> os_constants = Object::New(isolate);
  CHECK(os_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> err_constants = Object::New(isolate);
  CHECK(err_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> sig_constants = Object::New(isolate);
  CHECK(sig_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> priority_constants = Object::New(isolate);
  CHECK(priority_constants->SetPrototype(env->context(),
                                         Null(env->isolate())).FromJust());

  Local<Object> fs_constants = Object::New(isolate);
  CHECK(fs_constants->SetPrototype(en...",45,,1280,5,,void
150438,BLOCK,-1,,<empty>,1,,1,1,,ANY
150447,BLOCK,-1,,<empty>,1,,1,1,,ANY
150451,BLOCK,-1,,"{
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
          desc_for_sandbox->set_configurable(desc.configurable());
        }
        // Set the property on the sandbox.
        USE(sandbox->DefineProperty(context, property, *desc_for_sandbox));
      }",50,,598,2,,void
150457,BLOCK,-1,,"{
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }",36,,599,2,,void
150471,BLOCK,-1,,"{
          desc_for_sandbox->set_configurable(desc.configurable());
        }",38,,602,2,,void
150496,BLOCK,-1,,"{
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() && mtask_queue)
      mtask_queue->PerformCheckpoint(env->isolate());
    return result;
  }",20,,1053,1,,void
150516,BLOCK,-1,,<empty>,7,,1056,2,,void
150557,BLOCK,-1,,<empty>,1,,1,1,,ANY
150564,BLOCK,-1,,"{
  return Uint32::New(context->GetIsolate(), index)->ToString(context)
      .ToLocalChecked();
}",66,,105,3,,void
150588,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  Local<ObjectTemplate> object_template = env->contextify_global_template();
  DCHECK(!object_template.IsEmpty());
  const SnapshotData* snapshot_data = env->isolate_data()->snapshot_data();

  MicrotaskQueue* queue =
      options.microtask_queue_wrap
          ? options.microtask_queue_wrap->microtask_queue().get()
          : env->isolate()->GetCurrentContext()->GetMicrotaskQueue();

  Local<Context> v8_context;
  if (!(CreateV8Context(env->isolate(), object_template, snapshot_data, queue)
            .ToLocal(&v8_context))) {
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }
  return New(v8_context, env, sandbox_obj, options);
}",36,,115,4,,void
150667,BLOCK,-1,,"{
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }",37,,128,2,,void
150680,BLOCK,-1,,"{
  if (microtask_queue_wrap_) {
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }
}",66,,135,2,,void
150683,BLOCK,-1,,"{
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }",30,,136,2,,void
150700,BLOCK,-1,,"{
  context_.Reset(env->isolate(), v8_context);
  // This should only be done after the initial initializations of the context
  // global object is finished.
  DCHECK_NULL(v8_context->GetAlignedPointerFromEmbedderData(
      ContextEmbedderIndex::kContextifyContext));
  v8_context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, this);
  // It's okay to make this reference weak - V8 would create an internal
  // reference to this context via the constructor of the wrapper.
  // As long as the wrapper is alive, it's constructor is alive, and so
  // is the context.
  context_.SetWeak();
}",59,,147,5,,void
150733,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);

  env()->UnassignFromContext(PersistentToLocal::Weak(isolate, context_));
  context_.Reset();
}",41,,162,1,,void
150762,BLOCK,-1,,"{
  DCHECK(isolate_data->contextify_wrapper_template().IsEmpty());
  Local<FunctionTemplate> global_func_template =
      FunctionTemplate::New(isolate_data->isolate());
  Local<ObjectTemplate> global_object_template =
      global_func_template->InstanceTemplate();

  NamedPropertyHandlerConfiguration config(
      PropertyGetterCallback,
      PropertySetterCallback,
      PropertyDescriptorCallback,
      PropertyDeleterCallback,
      PropertyEnumeratorCallback,
      PropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  IndexedPropertyHandlerConfiguration indexed_config(
      IndexedPropertyGetterCallback,
      IndexedPropertySetterCallback,
      IndexedPropertyDescriptorCallback,
      IndexedPropertyDeleterCallback,
      PropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  global_object_template->SetHandler(config);
  global_object_template->SetHandler(indexed_config);
...",78,,170,2,,void
150867,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  Local<Context> ctx;
  if (snapshot_data == nullptr) {
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  } else if (!Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeVMContextIndex,
                                    {},       // deserialization callback
                                    nullptr,  // extensions
                                    {},       // global object
                                    queue)
                  .ToLocal(&ctx)) {
    return MaybeLocal<Context>();
  }

  return scope.Escape(ctx);
}",28,,212,5,,void
150880,BLOCK,-1,,"{
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  }",33,,216,2,,void
150904,BLOCK,-1,,"{
      return MaybeLocal<Context>();
    }",77,,223,2,,void
150908,BLOCK,-1,,<empty>,10,,226,1,,void
150928,BLOCK,-1,,"{
    return MaybeLocal<Context>();
  }",35,,232,2,,void
150944,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  // This only initializes part of the context. The primordials are
  // only initialized when needed because even deserializing them slows
  // things down significantly and they are only needed in rare occasions
  // in the vm contexts.
  if (InitializeContextRuntime(v8_context).IsNothing()) {
    return BaseObjectPtr<ContextifyContext>();
  }

  Local<Context> main_context = env->context();
  Local<Object> new_context_global = v8_context->Global();
  v8_context->SetSecurityToken(main_context->GetSecurityToken());

  // We need to tie the lifetime of the sandbox object with the lifetime of
  // newly created context. We do this by making them hold references to each
  // other. The context can directly hold a reference to the sandbox as an
  // embedder data field. The sandbox uses a private symbol to hold a reference
  // to the ContextifyContext wrapper which in turn internally references
  // the context from its constructor.
  v8_context-...",36,,243,5,,void
150957,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",57,,249,2,,void
151042,BLOCK,-1,,"{
    Utf8Value origin_val(env->isolate(), options.origin);
    info.origin = *origin_val;
  }",34,,277,2,,void
151068,BLOCK,18,,"{
    Context::Scope context_scope(v8_context);
    Local<String> ctor_name = sandbox_obj->GetConstructorName();
    if (!ctor_name->Equals(v8_context, env->object_string()).FromMaybe(false) &&
        new_context_global
            ->DefineOwnProperty(
                v8_context,
                v8::Symbol::GetToStringTag(env->isolate()),
                ctor_name,
                static_cast<v8::PropertyAttribute>(v8::DontEnum))
            .IsNothing()) {
      return BaseObjectPtr<ContextifyContext>();
    }
    env->AssignToContext(v8_context, nullptr, info);

    if (!env->contextify_wrapper_template()
             ->NewInstance(v8_context)
             .ToLocal(&wrapper)) {
      return BaseObjectPtr<ContextifyContext>();
    }

    result =
        MakeBaseObject<ContextifyContext>(env, wrapper, v8_context, options);
    // The only strong reference to the wrapper will come from the sandbox.
    result->MakeWeak();
  }",3,,284,18,,void
151122,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",27,,294,2,,void
151147,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",34,,301,2,,void
151180,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",25,,314,2,,void
151190,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""makeContext"", MakeContext);
  SetMethod(isolate, target, ""isContext"", IsContext);
  SetMethod(isolate, target, ""compileFunction"", CompileFunction);
}",62,,322,3,,void
151217,BLOCK,-1,,"{
  registry->Register(MakeContext);
  registry->Register(IsContext);
  registry->Register(CompileFunction);
  registry->Register(PropertyGetterCallback);
  registry->Register(PropertySetterCallback);
  registry->Register(PropertyDescriptorCallback);
  registry->Register(PropertyDeleterCallback);
  registry->Register(PropertyEnumeratorCallback);
  registry->Register(PropertyDefinerCallback);
  registry->Register(IndexedPropertyGetterCallback);
  registry->Register(IndexedPropertySetterCallback);
  registry->Register(IndexedPropertyDescriptorCallback);
  registry->Register(IndexedPropertyDeleterCallback);
  registry->Register(IndexedPropertyDefinerCallback);
}",42,,330,2,,void
151292,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 6);
  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  // Don't allow contextifying a sandbox multiple times.
  CHECK(
      !sandbox->HasPrivate(
          env->context(),
          env->contextify_context_private_symbol()).FromJust());

  ContextOptions options;

  CHECK(args[1]->IsString());
  options.name = args[1].As<String>();

  CHECK(args[2]->IsString() || args[2]->IsUndefined());
  if (args[2]->IsString()) {
    options.origin = args[2].As<String>();
  }

  CHECK(args[3]->IsBoolean());
  options.allow_code_gen_strings = args[3].As<Boolean>();

  CHECK(args[4]->IsBoolean());
  options.allow_code_gen_wasm = args[4].As<Boolean>();

  if (args[5]->IsObject() &&
      !env->microtask_queue_ctor_template().IsEmpty() &&
      env->microtask_queue_ctor_template()->HasInstance(args[5])) {
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<...",78,,348,2,,void
151382,BLOCK,-1,,"{
    options.origin = args[2].As<String>();
  }",28,,367,2,,void
151454,BLOCK,-1,,"{
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<Object>()));
  }",67,,379,2,,void
151492,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,388,2,,void
151499,BLOCK,-1,,<empty>,7,,390,2,,void
151509,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  Maybe<bool> result =
      sandbox->HasPrivate(env->context(),
                          env->contextify_context_private_symbol());
  args.GetReturnValue().Set(result.FromJust());
}",76,,396,2,,void
151567,BLOCK,-1,,"{
  ContextifyContext* context = data.GetParameter();
  delete context;
}",54,,410,2,,void
151582,BLOCK,-1,,"{
  Local<Value> context_global;
  if (sandbox
          ->GetPrivate(env->context(), env->contextify_context_private_symbol())
          .ToLocal(&context_global) &&
      context_global->IsObject()) {
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }
  return nullptr;
}",35,,418,3,,void
151611,BLOCK,-1,,"{
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }",35,,423,2,,void
151627,BLOCK,-1,,"{
  return Get(args.This());
}",80,,430,2,,void
151638,BLOCK,-1,,"{
  Local<Context> context;
  if (!object->GetCreationContext().ToLocal(&context)) {
    return nullptr;
  }
  if (!ContextEmbedderTag::IsNodeContext(context)) {
    return nullptr;
  }
  return static_cast<ContextifyContext*>(
      context->GetAlignedPointerFromEmbedderData(
          ContextEmbedderIndex::kContextifyContext));
}",65,,434,2,,void
151655,BLOCK,-1,,"{
    return nullptr;
  }",56,,436,2,,void
151665,BLOCK,-1,,"{
    return nullptr;
  }",52,,439,2,,void
151682,BLOCK,-1,,"{
  return ctx == nullptr || ctx->context_.IsEmpty();
}",75,,447,2,,void
151699,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Local<Object> sandbox = ctx->sandbox();
  MaybeLocal<Value> maybe_rv =
      sandbox->GetRealNamedProperty(context, property);
  if (maybe_rv.IsEmpty()) {
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }

  Local<Value> rv;
  if (maybe_rv.ToLocal(&rv)) {
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }
}",46,,454,3,,void
151711,BLOCK,-1,,<empty>,33,,458,2,,void
151750,BLOCK,-1,,"{
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }",27,,464,2,,void
151774,BLOCK,-1,,"{
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }",30,,470,2,,void
151779,BLOCK,-1,,<empty>,7,,472,2,,void
151800,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared_on_global_proxy = ctx->global_proxy()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly);

  bool is_declared_on_sandbox = ctx->sandbox()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  read_only = read_only ||
      (static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly));

  if (read_only)
    return;

  // true for x = 5
  // false for this.x = 5
  // false for Object.defineProperty(this, 'foo', ...)
  // false for vmResult.x = 5 where vmResult = vm.runInContext();
  bool is_contextual_store = ctx->global_proxy() != args.This();

  // Indic...",46,,482,4,,void
151812,BLOCK,-1,,<empty>,33,,486,2,,void
151891,BLOCK,-1,,<empty>,5,,505,2,,void
151931,BLOCK,-1,,<empty>,5,,525,2,,void
151941,BLOCK,-1,,<empty>,45,,527,2,,void
151957,BLOCK,-1,,<empty>,66,,528,2,,void
151987,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Local<Object> desc_obj = desc.As<Object>();

    // We have to specify the return value for any contextual or get/set
    // property
    if (desc_obj->HasOwnProperty(context, env->get_string()).FromMaybe(false) ||
        desc_obj->HasOwnProperty(context, env->set_string()).FromMaybe(false))
      args.GetReturnValue().Set(value);
  }",29,,535,2,,void
152034,BLOCK,-1,,<empty>,7,,543,2,,void
152048,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();

  Local<Object> sandbox = ctx->sandbox();

  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }
}",46,,550,3,,void
152060,BLOCK,-1,,<empty>,33,,554,2,,void
152093,BLOCK,-1,,"{
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }",68,,560,2,,void
152111,BLOCK,-1,,"{
      args.GetReturnValue().Set(desc);
    }",78,,562,2,,void
152124,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Isolate* isolate = context->GetIsolate();

  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared =
      ctx->global_proxy()->GetRealNamedPropertyAttributes(context,
                                                          property)
          .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
          static_cast<int>(PropertyAttribute::ReadOnly);

  // If the property is set on the global as read_only, don't change it on
  // the global or sandbox.
  if (is_declared && read_only)
    return;

  Local<Object> sandbox = ctx->sandbox();

  auto define_prop_on_sandbox =
      [&] (PropertyDescriptor* desc_for_sandbox) {
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
     ...",46,,572,4,,void
152136,BLOCK,-1,,<empty>,33,,576,2,,void
152194,BLOCK,-1,,<empty>,5,,593,2,,void
152220,BLOCK,-1,,"{
    PropertyDescriptor desc_for_sandbox(
        desc.has_get() ? desc.get() : Undefined(isolate).As<Value>(),
        desc.has_set() ? desc.set() : Undefined(isolate).As<Value>());

    define_prop_on_sandbox(&desc_for_sandbox);
  }",41,,609,2,,void
152255,BLOCK,-1,,"{
    Local<Value> value =
        desc.has_value() ? desc.value() : Undefined(isolate).As<Value>();

    if (desc.has_writable()) {
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    } else {
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }
  }",10,,615,1,,void
152281,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    }",30,,619,2,,void
152293,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }",12,,622,1,,void
152305,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,632,3,,void
152317,BLOCK,-1,,<empty>,33,,636,2,,void
152340,BLOCK,-1,,<empty>,5,,641,2,,void
152354,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Array> properties;

  if (!ctx->sandbox()->GetPropertyNames(ctx->context()).ToLocal(&properties))
    return;

  args.GetReturnValue().Set(properties);
}",46,,650,2,,void
152366,BLOCK,-1,,<empty>,33,,654,2,,void
152391,BLOCK,-1,,<empty>,5,,659,2,,void
152406,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyGetterCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,667,3,,void
152418,BLOCK,-1,,<empty>,33,,671,2,,void
152437,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertySetterCallback(
      Uint32ToName(ctx->context(), index), value, args);
}",46,,681,4,,void
152449,BLOCK,-1,,<empty>,33,,685,2,,void
152468,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDescriptorCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,694,3,,void
152480,BLOCK,-1,,<empty>,33,,698,2,,void
152499,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDefinerCallback(
      Uint32ToName(ctx->context(), index), desc, args);
}",46,,708,4,,void
152511,BLOCK,-1,,<empty>,33,,712,2,,void
152530,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,721,3,,void
152542,BLOCK,-1,,<empty>,33,,725,2,,void
152565,BLOCK,-1,,<empty>,5,,730,2,,void
152580,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<String> class_name = FIXED_ONE_BYTE_STRING(isolate, ""ContextifyScript"");

  Local<FunctionTemplate> script_tmpl = NewFunctionTemplate(isolate, New);
  script_tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  script_tmpl->SetClassName(class_name);
  SetProtoMethod(isolate, script_tmpl, ""createCachedData"", CreateCachedData);
  SetProtoMethod(isolate, script_tmpl, ""runInContext"", RunInContext);

  target->Set(isolate, ""ContextifyScript"", script_tmpl);
  isolate_data->set_script_context_constructor_template(script_tmpl);
}",62,,738,3,,void
152647,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(CreateCachedData);
  registry->Register(RunInContext);
}",42,,754,2,,void
152667,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args.IsConstructCall());

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  int line_offset = 0;
  int column_offset = 0;
  Local<ArrayBufferView> cached_data_buf;
  bool produce_cached_data = false;
  Local<Context> parsing_context = context;

  if (argc > 2) {
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_b...",69,,760,2,,void
152774,BLOCK,-1,,"{
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }
    CHECK(args[5]->IsBoolean());
    produce_cached_data = args[5]->IsTrue();
    if (!args[6]->IsUndefined()) {
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }
  }",17,,782,2,,void
152822,BLOCK,-1,,"{
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }",34,,790,2,,void
152861,BLOCK,-1,,"{
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }",34,,796,2,,void
152909,BLOCK,-1,,"{
    Utf8Value fn(isolate, filename);
    TRACE_EVENT_BEGIN1(TRACING_CATEGORY_NODE2(vm, script),
                       ""ContextifyScript::New"",
                       ""filename"",
                       TRACE_STR_COPY(*fn));
  }",53,,810,2,,void
152933,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
        data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,819,2,,void
153047,BLOCK,-1,,<empty>,5,,848,2,,void
153089,BLOCK,-1,,"{
    errors::DecorateErrorStack(env, try_catch);
    no_abort_scope.Close();
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    TRACE_EVENT_END0(TRACING_CATEGORY_NODE2(vm, script),
                     ""ContextifyScript::New"");
    return;
  }",45,,858,2,,void
153106,BLOCK,-1,,<empty>,7,,862,2,,void
153136,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCache(v8_script));
  }",28,,870,2,,void
153164,BLOCK,-1,,"{
    return;
  }",25,,880,2,,void
153189,BLOCK,-1,,<empty>,5,,889,2,,void
153205,BLOCK,-1,,"{
  Local<Context> context;
  if (!target->GetCreationContext().ToLocal(&context)) {
    return Nothing<bool>();
  }
  if (compile_options == ScriptCompiler::kConsumeCodeCache) {
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (produce_cached_data) {
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
 ...",66,,900,7,,void
153222,BLOCK,-1,,"{
    return Nothing<bool>();
  }",56,,902,2,,void
153231,BLOCK,-1,,"{
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",61,,905,2,,void
153259,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,911,2,,void
153264,BLOCK,-1,,"{
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
                  Boolean::New(env->isolate(), cached_data_produced))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",28,,915,2,,void
153273,BLOCK,-1,,"{
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }",31,,917,2,,void
153310,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,923,2,,void
153335,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,931,2,,void
153346,BLOCK,-1,,"{
  return !value.IsEmpty() &&
         env->script_context_constructor_template()->HasInstance(value);
}",62,,939,3,,void
153366,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",46,,945,2,,void
153402,BLOCK,-1,,<empty>,,,,2,,<empty>
153408,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,953,2,,void
153426,BLOCK,-1,,"{
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,955,1,,void
153461,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());

  CHECK_EQ(args.Length(), 5);
  CHECK(args[0]->IsObject() || args[0]->IsNull());

  Local<Context> context;
  std::shared_ptr<MicrotaskQueue> microtask_queue;

  if (args[0]->IsObject()) {
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  } else {
    context = env->context();
  }

  TRACE_EVENT0(TRACING_CATEGORY_NODE2(vm, script), ""RunInContext"");

  CHECK(args[1]->IsNumber());
  int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();

  CHE...",78,,964,2,,void
153517,BLOCK,-1,,"{
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  }",28,,976,2,,void
153558,BLOCK,-1,,<empty>,28,,985,2,,void
153567,BLOCK,-1,,"{
    context = env->context();
  }",10,,988,1,,void
153667,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  if (!env->can_call_into_js())
    return false;
  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }

  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  Local<Script> script = unbound_script->BindToCurrentContext();

#if HAVE_INSPECTOR
  if (break_on_first_line) {
    env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  }
#endif

  MaybeLocal<Value> result;
  bool timed_out = false;
  bool received_signal = false;
  auto run = [&]() {
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() &...",77,,1024,9,,void
153677,BLOCK,-1,,<empty>,5,,1028,2,,void
153691,BLOCK,-1,,"{
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }",58,,1029,2,,void
153766,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",41,,1059,2,,void
153788,BLOCK,-1,,<empty>,10,,1063,1,,void
153791,BLOCK,-1,,"{
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",31,,1063,2,,void
153804,BLOCK,-1,,<empty>,10,,1066,1,,void
153810,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    result = run();
  }",29,,1066,2,,void
153824,BLOCK,-1,,"{
    result = run();
  }",10,,1069,1,,void
153832,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return false;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,1074,2,,void
153844,BLOCK,-1,,<empty>,7,,1076,2,,void
153856,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,1081,2,,void
153864,BLOCK,-1,,<empty>,12,,1083,1,,void
153867,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,1083,2,,void
153878,BLOCK,-1,,"{
    if (!timed_out && !received_signal && display_errors) {
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }

    // If there was an exception thrown during script execution, re-throw it.
    // If one of the above checks threw, re-throw the exception instead of
    // letting try_catch catch it.
    // If execution has been terminated, but not by one of the watchdogs from
    // this invocation, this will re-throw a `null` value.
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();

    return false;
  }",30,,1088,2,,void
153887,BLOCK,-1,,"{
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }",59,,1089,2,,void
153900,BLOCK,-1,,<empty>,7,,1100,2,,void
153925,BLOCK,-1,,"{
  MakeWeak();
  env->id_to_script_map.emplace(id_, this);
}",38,,1112,3,,void
153938,BLOCK,-1,,"{
  env()->id_to_script_map.erase(id_);
}",39,,1118,1,,void
153950,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Argument 1: source code
  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  // Argument 2: filename
  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  // Argument 3: line offset
  CHECK(args[2]->IsNumber());
  int line_offset = args[2].As<Int32>()->Value();

  // Argument 4: column offset
  CHECK(args[3]->IsNumber());
  int column_offset = args[3].As<Int32>()->Value();

  // Argument 5: cached data (optional)
  Local<ArrayBufferView> cached_data_buf;
  if (!args[4]->IsUndefined()) {
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }

  // Argument 6: produce cache data
  CHECK(args[5]->IsBoolean());
  bool produce_cached_data = args[5]->IsTrue();

  // Argument 7: parsing context (optional)
  Local<Context> parsing_context;
  if (!args[6]->IsU...",46,,1124,2,,void
154065,BLOCK,-1,,"{
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }",32,,1147,2,,void
154110,BLOCK,-1,,"{
    CHECK(args[6]->IsObject());
    ContextifyContext* sandbox =
        ContextifyContext::ContextFromContextifiedSandbox(
            env, args[6].As<Object>());
    CHECK_NOT_NULL(sandbox);
    parsing_context = sandbox->context();
  }",32,,1158,2,,void
154141,BLOCK,-1,,"{
    parsing_context = context;
  }",10,,1165,1,,void
154158,BLOCK,-1,,"{
    CHECK(args[7]->IsArray());
    context_extensions_buf = args[7].As<Array>();
  }",32,,1171,2,,void
154187,BLOCK,-1,,"{
    CHECK(args[8]->IsArray());
    params_buf = args[8].As<Array>();
  }",32,,1178,2,,void
154213,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
      data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,1185,2,,void
154326,BLOCK,-1,,"{
    options = ScriptCompiler::kNoCompileOptions;
  }",42,,1218,2,,void
154333,BLOCK,-1,,"{
    options = ScriptCompiler::kConsumeCodeCache;
  }",10,,1220,1,,void
154360,BLOCK,-1,,"{
    for (uint32_t n = 0; n < context_extensions_buf->Length(); n++) {
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }
  }",42,,1229,2,,void
154362,BLOCK,-1,,<empty>,5,,1230,1,,void
154375,BLOCK,4,,"{
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }",69,,1230,4,,void
154394,BLOCK,-1,,<empty>,67,,1232,2,,void
154424,BLOCK,-1,,"{
    for (uint32_t n = 0; n < params_buf->Length(); n++) {
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }
  }",30,,1240,2,,void
154426,BLOCK,-1,,<empty>,5,,1241,1,,void
154439,BLOCK,4,,"{
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }",57,,1241,4,,void
154458,BLOCK,-1,,<empty>,55,,1243,2,,void
154523,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }
    return;
  }",31,,1260,2,,void
154535,BLOCK,-1,,"{
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }",62,,1261,2,,void
154567,BLOCK,-1,,"{
    return;
  }",42,,1270,2,,void
154611,BLOCK,-1,,<empty>,5,,1278,2,,void
154627,BLOCK,-1,,<empty>,5,,1281,2,,void
154649,BLOCK,-1,,<empty>,5,,1287,2,,void
154662,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCacheForFunction(fn));
  }",28,,1290,2,,void
154687,BLOCK,-1,,"{
    return;
  }",25,,1299,2,,void
154701,BLOCK,-1,,"{
  CompiledFnEntry* entry = data.GetParameter();
  delete entry;
}",52,,1307,2,,void
154718,BLOCK,-1,,"{
  fn_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
}",65,,1316,5,,void
154733,BLOCK,-1,,"{
  env()->id_to_function_map.erase(id_);
  fn_.ClearWeak();
}",37,,1320,1,,void
154749,BLOCK,-1,,"{
  int ret = SigintWatchdogHelper::GetInstance()->Start();
  args.GetReturnValue().Set(ret == 0);
}",74,,1325,2,,void
154774,BLOCK,-1,,"{
  bool had_pending_signals = SigintWatchdogHelper::GetInstance()->Stop();
  args.GetReturnValue().Set(had_pending_signals);
}",73,,1330,2,,void
154797,BLOCK,-1,,"{
  bool ret = SigintWatchdogHelper::GetInstance()->HasPendingSignal();
  args.GetReturnValue().Set(ret);
}",79,,1335,2,,void
154820,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  int32_t mode = args[0].As<v8::Int32>()->Value();
  int32_t execution = args[1].As<v8::Int32>()->Value();
  Isolate* isolate = args.GetIsolate();

  Local<Context> current_context = isolate->GetCurrentContext();
  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(current_context).ToLocal(&resolver)) return;
  std::unique_ptr<v8::MeasureMemoryDelegate> delegate =
      v8::MeasureMemoryDelegate::Default(
          isolate,
          current_context,
          resolver,
          static_cast<v8::MeasureMemoryMode>(mode));
  isolate->MeasureMemory(std::move(delegate),
                         static_cast<v8::MeasureMemoryExecution>(execution));
  Local<Promise> promise = resolver->GetPromise();

  args.GetReturnValue().Set(promise);
}",68,,1340,2,,void
154897,BLOCK,-1,,<empty>,68,,1349,2,,void
154956,BLOCK,-1,,"{
  MakeWeak();
}",75,,1366,3,,void
154961,BLOCK,-1,,"{
  return microtask_queue_;
}",45,,1371,1,,void
154968,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new MicrotaskQueueWrap(Environment::GetCurrent(args), args.This());
}",71,,1375,2,,void
154990,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);
  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  isolate_data->set_microtask_queue_ctor_template(tmpl);
  SetConstructorFunction(isolate, target, ""MicrotaskQueue"", tmpl);
}",62,,1381,3,,void
155034,BLOCK,-1,,"{
  registry->Register(New);
}",42,,1392,2,,void
155045,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  ContextifyContext::CreatePerIsolateProperties(isolate_data, target);
  ContextifyScript::CreatePerIsolateProperties(isolate_data, target);
  MicrotaskQueueWrap::CreatePerIsolateProperties(isolate_data, target);

  SetMethod(isolate, target, ""startSigintWatchdog"", StartSigintWatchdog);
  SetMethod(isolate, target, ""stopSigintWatchdog"", StopSigintWatchdog);
  // Used in tests.
  SetMethodNoSideEffect(
      isolate, target, ""watchdogHasPendingSigint"", WatchdogHasPendingSigint);

  {
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }
  SetMethod(isolate, target, ""measureMemory"", MeasureMemory);
}",63,,1397,3,,void
155086,BLOCK,9,,"{
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }",3,,1410,9,,void
155135,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<Object> constants = Object::New(env->isolate());
  Local<Object> measure_memory = Object::New(env->isolate());
  Local<Object> memory_execution = Object::New(env->isolate());

  {
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }

  {
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }

  READONLY_PROPERTY(constants, ""measureMemory""...",52,,1424,5,,void
155193,BLOCK,8,,"{
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }",3,,1432,8,,void
155230,BLOCK,9,,"{
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }",3,,1441,9,,void
155274,BLOCK,-1,,"{
  ContextifyContext::RegisterExternalReferences(registry);
  ContextifyScript::RegisterExternalReferences(registry);
  MicrotaskQueueWrap::RegisterExternalReferences(registry);

  registry->Register(StartSigintWatchdog);
  registry->Register(StopSigintWatchdog);
  registry->Register(WatchdogHasPendingSigint);
  registry->Register(MeasureMemory);
}",70,,1454,2,,void
155323,BLOCK,-1,,<empty>,1,,1,1,,ANY
155348,BLOCK,-1,,<empty>,1,,1,1,,ANY
155351,BLOCK,-1,,"{
  // This could reasonably be a static variable, but this way
  // we can guarantee that this function is always usable
  // and returns the correct value,  e.g. even in static
  // initialization code in other files.
#ifdef __linux__
  static const bool value = getauxval(AT_SECURE);
  return value;
#else
  return false;
#endif
}",24,,35,1,,void
155362,BLOCK,-1,,"{
#if !defined(__CloudABI__) && !defined(_WIN32)
#if defined(__linux__)
  if ((!HasOnly(CAP_NET_BIND_SERVICE) && linux_at_secure()) ||
      getuid() != geteuid() || getgid() != getegid())
#else
  if (linux_at_secure() || getuid() != geteuid() || getgid() != getegid())
#endif
    goto fail;
#endif

  if (env_vars != nullptr) {
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_...",39,,80,5,,void
155373,BLOCK,-1,,<empty>,5,,88,2,,void
155379,BLOCK,-1,,"{
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }",28,,91,2,,void
155421,BLOCK,-1,,<empty>,39,,98,2,,void
155432,BLOCK,-1,,<empty>,33,,100,2,,void
155449,BLOCK,3,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_ENOBUFS) {
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }

    if (ret >= 0) {  // Env key value fetch success.
      *text = *val;
      return true;
    }
  }",3,,105,3,,void
155473,BLOCK,-1,,"{
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }",28,,112,2,,void
155491,BLOCK,-1,,"{  // Env key value fetch success.
      *text = *val;
      return true;
    }",19,,119,2,,void
155510,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Utf8Value strenvtag(isolate, args[0]);
  std::string text;
  if (!SafeGetenv(*strenvtag, &text, env->env_vars(), isolate)) return;
  Local<Value> result =
      ToV8Value(isolate->GetCurrentContext(), text).ToLocalChecked();
  args.GetReturnValue().Set(result);
}",65,,130,2,,void
155552,BLOCK,-1,,<empty>,65,,136,2,,void
155581,BLOCK,-1,,"{
  registry->Register(SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  registry->Register(GetUid);
  registry->Register(GetEUid);
  registry->Register(GetGid);
  registry->Register(GetEGid);
  registry->Register(GetGroups);

  registry->Register(InitGroups);
  registry->Register(SetEGid);
  registry->Register(SetEUid);
  registry->Register(SetGid);
  registry->Register(SetUid);
  registry->Register(SetGroups);
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",70,,436,2,,void
155594,BLOCK,-1,,"{
  SetMethod(context, target, ""safeGetenv"", SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  READONLY_TRUE_PROPERTY(target, ""implementsPosixCredentials"");
  SetMethodNoSideEffect(context, target, ""getuid"", GetUid);
  SetMethodNoSideEffect(context, target, ""geteuid"", GetEUid);
  SetMethodNoSideEffect(context, target, ""getgid"", GetGid);
  SetMethodNoSideEffect(context, target, ""getegid"", GetEGid);
  SetMethodNoSideEffect(context, target, ""getgroups"", GetGroups);

  if (env->owns_process_state()) {
    SetMethod(context, target, ""initgroups"", InitGroups);
    SetMethod(context, target, ""setegid"", SetEGid);
    SetMethod(context, target, ""seteuid"", SetEUid);
    SetMethod(context, target, ""setgid"", SetGid);
    SetMethod(context, target, ""setuid"", SetUid);
    SetMethod(context, target, ""setgroups"", SetGroups);
  }
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",36,,458,5,,void
155621,BLOCK,-1,,<empty>,1,,1,1,,ANY
155629,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  if (!InitCryptoOnce(env->isolate())) {
    return;
  }

#define V(Namespace) Namespace::Initialize(env, target);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",29,,75,5,,void
155645,BLOCK,-1,,"{
    return;
  }",40,,78,2,,void
155648,BLOCK,1,,<empty>,,,,2,,void
155785,BLOCK,-1,,"{
#define V(Namespace) Namespace::RegisterExternalReferences(registry);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",70,,87,2,,void
155787,BLOCK,1,,<empty>,,,,1,,void
155949,BLOCK,-1,,<empty>,1,,1,1,,ANY
155953,BLOCK,-1,,"{
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,152,2,,void
155980,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing directory handle on garbage collection"");
  }",44,,168,2,,void
156021,BLOCK,-1,,<empty>,1,,1,1,,ANY
156026,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }
}",67,,46,2,,void
156029,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }",21,,47,2,,void
156031,BLOCK,1,,<empty>,,,,1,,void
156037,BLOCK,1,,<empty>,,,,1,,void
156043,BLOCK,1,,<empty>,,,,1,,void
156057,BLOCK,-1,,"{
  MakeWeak();

  dir_->nentries = 0;
  dir_->dirents = nullptr;
}",17,,100,4,,void
156074,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->dir_instance_template()
          ->NewInstance(env->context())
          .ToLocal(&obj)) {
    return nullptr;
  }

  return new DirHandle(env, obj, dir);
}",60,,107,3,,void
156098,BLOCK,-1,,"{
    return nullptr;
  }",27,,111,2,,void
156111,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
}",62,,118,2,,void
156120,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  GCClose();         // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",25,,122,1,,void
156130,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dir"", sizeof(*dir_));
}",58,,128,2,,void
156142,BLOCK,-1,,"{
  if (closed_) return;
  uv_fs_t req;
  FS_DIR_SYNC_TRACE_BEGIN(closedir);
  int ret = uv_fs_closedir(nullptr, &req, dir_, nullptr);
  FS_DIR_SYNC_TRACE_END(closedir);
  uv_fs_req_cleanup(&req);
  closing_ = false;
  closed_ = true;

  struct err_detail { int ret; };

  err_detail detail { ret };

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the close was successful, we still want to emit a process warning
  // to notify that the file descri...",34,,136,1,,void
156145,BLOCK,-1,,<empty>,16,,137,2,,void
156151,BLOCK,1,,<empty>,,,,9,,void
156167,BLOCK,-1,,<empty>,3,,139,2,,void
156169,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,1,,void
156187,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
156215,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
156256,BLOCK,1,,<empty>,,,,9,,void
156272,BLOCK,-1,,<empty>,3,,141,2,,void
156274,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,1,,void
156292,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
156320,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
156366,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,150,2,,void
156385,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",31,,174,2,,void
156413,BLOCK,1,,<empty>,,,,18,,void
156415,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,1,,void
156433,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
156461,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
156517,BLOCK,-1,,<empty>,5,,180,2,,void
156534,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 1);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  dir->closing_ = false;
  dir->closed_ = true;

  FSReqBase* req_wrap_async = GetReqWrap(args, 0);
  if (req_wrap_async != nullptr) {  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  } else {  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }
}",64,,183,2,,void
156581,BLOCK,-1,,"{  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  }",34,,196,2,,void
156589,BLOCK,1,,<empty>,,,,16,,void
156591,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,1,,void
156609,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
156637,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
156693,BLOCK,-1,,"{  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }",10,,200,1,,void
156701,BLOCK,1,,<empty>,,,,9,,void
156717,BLOCK,-1,,<empty>,5,,203,2,,void
156719,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,1,,void
156737,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
156765,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
156810,BLOCK,1,,<empty>,,,,9,,void
156826,BLOCK,-1,,<empty>,5,,206,2,,void
156828,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,1,,void
156846,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
156874,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
156911,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 64> entries(num * 2);

  // Return an array of all read filenames.
  int j = 0;
  for (int i = 0; i < num; i++) {
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }

  return Array::New(env->isolate(), entries.out(), j);
}",28,,215,6,,void
156922,BLOCK,-1,,<empty>,3,,220,1,,void
156932,BLOCK,4,,"{
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }",33,,220,4,,void
156976,BLOCK,-1,,"{
      *err_out = error;
      return MaybeLocal<Array>();
    }",58,,228,2,,void
157025,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> req_wrap { FSReqBase::from_req(req) };
  FSReqAfterScope after(req_wrap.get(), req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();

  if (req->result == 0) {
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);

  Local<Value> error;
  Local<Array> js_array;
  if (!DirentListToArray(env,
                         dir->dirents,
                         static_cast<int>(req->result),
                         req_wrap->encoding(),
                         &error)
           .ToLocal(&js_array)) {
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return r...",40,,240,2,,void
157059,BLOCK,1,,<empty>,,,,17,,void
157061,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,1,,void
157079,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
157107,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
157164,BLOCK,-1,,"{
    return;
  }",25,,245,2,,void
157186,BLOCK,-1,,"{
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }",25,,252,2,,void
157246,BLOCK,-1,,"{
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return req_wrap->Reject(error);
  }",33,,269,2,,void
157270,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  CHECK(args[1]->IsNumber());
  uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());

  if (buffer_size != dir->dirents_.size()) {
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  } else {  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
 ...",63,,281,2,,void
157343,BLOCK,-1,,"{
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }",44,,296,2,,void
157380,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  }",34,,303,2,,void
157388,BLOCK,1,,<empty>,,,,16,,void
157390,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,1,,void
157408,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
157436,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
157492,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readdir"", uv_fs_readdir,
                       dir->dir());
    FS_DIR_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    if (req_wrap_sync.req.result == 0) {
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }

    CHECK_GE(req_wrap_sync.req.result, 0);

    Local<Value> error;
    Local<Array> js_array;
    if (!DirentListToArray(env,
                           dir->dir()->dirents,
                           static_cast<int>(req_wrap_sync.req.result),
                           encoding,
                           &error)
             .ToLocal(&js_array)) {
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env-...",10,,307,1,,void
157500,BLOCK,1,,<empty>,,,,9,,void
157516,BLOCK,-1,,<empty>,5,,310,2,,void
157518,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,1,,void
157536,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
157564,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
157612,BLOCK,1,,<empty>,,,,9,,void
157628,BLOCK,-1,,<empty>,5,,313,2,,void
157630,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,1,,void
157648,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
157676,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
157709,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,314,2,,void
157719,BLOCK,-1,,"{
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }",40,,318,2,,void
157779,BLOCK,-1,,"{
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env->error_string(), error));
      return;
    }",35,,334,2,,void
157819,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
  DirHandle* handle = DirHandle::New(env, dir);

  req_wrap->Resolve(handle->object().As<Value>());
}",33,,344,2,,void
157847,BLOCK,1,,<empty>,,,,18,,void
157849,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,1,,void
157867,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
157895,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
157952,BLOCK,-1,,"{
    return;
  }",25,,349,2,,void
157993,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  } else {  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path)...",62,,361,2,,void
158058,BLOCK,-1,,"{  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  }",34,,376,2,,void
158067,BLOCK,1,,<empty>,,,,18,,void
158069,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,1,,void
158087,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
158115,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
158178,BLOCK,-1,,"{  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path);
    FS_DIR_SYNC_TRACE_END(opendir);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    uv_fs_t* req = &req_wrap_sync.req;
    uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
    DirHandle* handle = DirHandle::New(env, dir);

    args.GetReturnValue().Set(handle->object().As<Value>());
  }",10,,381,1,,void
158186,BLOCK,1,,<empty>,,,,9,,void
158202,BLOCK,-1,,<empty>,5,,384,2,,void
158204,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,1,,void
158222,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
158250,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
158296,BLOCK,1,,<empty>,,,,9,,void
158312,BLOCK,-1,,<empty>,5,,387,2,,void
158314,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,1,,void
158332,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
158360,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
158393,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,388,2,,void
158440,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""opendir"", OpenDir);

  // Create FunctionTemplate for DirHandle
  Local<FunctionTemplate> dir = NewFunctionTemplate(isolate, DirHandle::New);
  dir->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, dir, ""read"", DirHandle::Read);
  SetProtoMethod(isolate, dir, ""close"", DirHandle::Close);
  Local<ObjectTemplate> dirt = dir->InstanceTemplate();
  dirt->SetInternalFieldCount(DirHandle::kInternalFieldCount);
  SetConstructorFunction(context, target, ""DirHandle"", dir);
  env->set_dir_instance_template(dirt);
}",29,,403,5,,void
158526,BLOCK,-1,,"{
  registry->Register(OpenDir);
  registry->Register(DirHandle::New);
  registry->Register(DirHandle::Read);
  registry->Register(DirHandle::Close);
}",70,,420,2,,void
158562,BLOCK,-1,,<empty>,1,,1,1,,ANY
158565,BLOCK,-1,,"{ uv_os_free_environ(items, count); }",37,,193,1,,void
158591,BLOCK,-1,,<empty>,1,,1,1,,ANY
158597,BLOCK,-1,,<empty>,,,,3,,<empty>
158602,BLOCK,-1,,<empty>,,,,2,,<empty>
158609,BLOCK,-1,,<empty>,,,,4,,<empty>
158615,BLOCK,-1,,<empty>,,,,3,,<empty>
158620,BLOCK,-1,,<empty>,,,,2,,<empty>
158626,BLOCK,-1,,<empty>,,,,3,,<empty>
158631,BLOCK,-1,,<empty>,,,,2,,<empty>
158638,BLOCK,-1,,<empty>,,,,3,,<empty>
158643,BLOCK,-1,,<empty>,,,,2,,<empty>
158650,BLOCK,-1,,<empty>,,,,4,,<empty>
158656,BLOCK,-1,,<empty>,,,,3,,<empty>
158661,BLOCK,-1,,<empty>,,,,2,,<empty>
158667,BLOCK,-1,,<empty>,,,,3,,<empty>
158672,BLOCK,-1,,<empty>,,,,2,,<empty>
158677,BLOCK,-1,,<empty>,,,,2,,<empty>
158681,BLOCK,-1,,<empty>,,,,1,,<empty>
158686,BLOCK,-1,,<empty>,69,,61,2,,void
158704,BLOCK,-1,,"{
  if (key.length() == 2 && key[0] == 'T' && key[1] == 'Z') {
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }
}",32,,77,4,,void
158724,BLOCK,-1,,"{
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }",60,,78,2,,void
158739,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  size_t init_sz = 256;
  MaybeStackBuffer<char, 256> val;
  int ret = uv_os_getenv(key, *val, &init_sz);

  if (ret == UV_ENOBUFS) {
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }

  if (ret >= 0) {  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }

  return Nothing<std::string>();
}",61,,103,2,,void
158763,BLOCK,-1,,"{
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }",26,,110,2,,void
158781,BLOCK,-1,,"{  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }",17,,117,2,,void
158799,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  Maybe<std::string> value = Get(*key);

  if (value.IsJust()) {
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }

  return MaybeLocal<String>();
}",68,,125,3,,void
158820,BLOCK,-1,,"{
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }",23,,129,2,,void
158853,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  node::Utf8Value val(isolate, value);

#ifdef _WIN32
  if (key.length() > 0 && key[0] == '=') return;
#endif
  uv_os_setenv(*key, *val);
  DateTimeConfigurationChangeNotification(isolate, key, *val);
}",45,,140,4,,void
158881,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  char val[2];
  size_t init_sz = sizeof(val);
  int ret = uv_os_getenv(key, val, &init_sz);

  if (ret == UV_ENOENT) {
    return -1;
  }

#ifdef _WIN32
  if (key[0] == '=') {
    return static_cast<int32_t>(ReadOnly) |
           static_cast<int32_t>(DontDelete) |
           static_cast<int32_t>(DontEnum);
  }
#endif

  return 0;
}",52,,153,2,,void
158905,BLOCK,-1,,"{
    return -1;
  }",25,,160,2,,void
158916,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  return Query(*key);
}",77,,175,3,,void
158930,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  uv_os_unsetenv(*key);
  DateTimeConfigurationChangeNotification(isolate, key);
}",69,,180,3,,void
158950,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);
  uv_env_item_t* items;
  int count;

  auto cleanup = OnScopeLeave([&]() { uv_os_free_environ(items, count); });
  CHECK_EQ(uv_os_environ(&items, &count), 0);

  MaybeStackBuffer<Local<Value>, 256> env_v(count);
  int env_v_index = 0;
  for (int i = 0; i < count; i++) {
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }

  return Array::New(isolate, env_v.out(), env_v_index);
}",62,,188,2,,void
158976,BLOCK,-1,,<empty>,3,,198,1,,void
158986,BLOCK,4,,"{
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }",35,,198,4,,void
159008,BLOCK,-1,,"{
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }",24,,204,2,,void
159041,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  std::shared_ptr<KVStore> copy = KVStore::CreateMapKVStore();
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }
  return copy;
}",65,,214,2,,void
159083,BLOCK,-1,,<empty>,3,,221,1,,void
159093,BLOCK,4,,"{
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }",46,,221,4,,void
159138,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = map_.find(key);
  return it == map_.end() ? Nothing<std::string>() : Just(it->second);
}",59,,231,2,,void
159169,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  Maybe<std::string> value = Get(*str);
  if (value.IsNothing()) return Local<String>();
  std::string val = value.FromJust();
  return String::NewFromUtf8(
      isolate, val.data(), NewStringType::kNormal, val.size());
}",79,,237,3,,void
159190,BLOCK,-1,,<empty>,26,,240,2,,void
159223,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value key_str(isolate, key);
  Utf8Value value_str(isolate, value);
  if (*key_str != nullptr && key_str.length() > 0 && *value_str != nullptr) {
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }
}",80,,246,4,,void
159252,BLOCK,-1,,"{
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }",77,,250,2,,void
159280,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  return map_.find(key) == map_.end() ? -1 : 0;
}",50,,256,2,,void
159304,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  return Query(*str);
}",70,,261,3,,void
159318,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value str(isolate, key);
  map_.erase(std::string(*str, str.length()));
}",62,,266,3,,void
159344,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> values;
  values.reserve(map_.size());
  for (const auto& pair : map_) {
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }
  return Array::New(isolate, values.data(), values.size());
}",60,,272,2,,void
159368,BLOCK,-1,,"{
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }",33,,276,3,,void
159414,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>(*this);
}",68,,285,2,,void
159427,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>();
}",54,,289,1,,void
159438,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Array> keys;
  if (!entries->GetOwnPropertyNames(context).ToLocal(&keys))
    return Nothing<bool>();
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }
  return Just(true);
}",62,,294,3,,void
159466,BLOCK,-1,,<empty>,5,,299,2,,void
159477,BLOCK,-1,,<empty>,3,,301,1,,void
159487,BLOCK,4,,"{
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }",46,,301,4,,void
159506,BLOCK,-1,,<empty>,7,,304,2,,void
159515,BLOCK,-1,,<empty>,27,,305,2,,void
159552,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,310,2,,void
159571,BLOCK,-1,,"{
  HandleScope scope(isolate);
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }
  return Just(true);
}",67,,323,4,,void
159591,BLOCK,-1,,<empty>,3,,327,1,,void
159601,BLOCK,4,,"{
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }",46,,327,4,,void
159668,BLOCK,-1,,<empty>,14,,334,2,,void
159679,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsSymbol()) {
    return info.GetReturnValue().SetUndefined();
  }
  CHECK(property->IsString());
  MaybeLocal<String> value_string =
      env->env_vars()->Get(env->isolate(), property.As<String>());
  if (!value_string.IsEmpty()) {
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }
}",64,,340,3,,void
159698,BLOCK,-1,,"{
    return info.GetReturnValue().SetUndefined();
  }",29,,343,2,,void
159739,BLOCK,-1,,"{
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }",32,,349,2,,void
159757,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  // calling env->EmitProcessEnvWarning() sets a variable indicating that
  // warnings have been emitted. It should be called last after other
  // conditions leading to a warning have been met.
  if (env->options()->pending_deprecation && !value->IsString() &&
      !value->IsNumber() && !value->IsBoolean() &&
      env->EmitProcessEnvWarning()) {
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }

  Local<String> key;
  Local<String> value_string;
  if (!property->ToString(env->context()).ToLocal(&key) ||
      !value->ToString(env->context()).ToLocal(&value_string)) {
 ...",64,,356,4,,void
159801,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }",37,,364,2,,void
159810,BLOCK,-1,,<empty>,7,,373,2,,void
159852,BLOCK,-1,,"{
    return;
  }",64,,379,2,,void
159880,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }
}",65,,390,3,,void
159899,BLOCK,-1,,"{
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }",29,,393,2,,void
159923,BLOCK,-1,,<empty>,19,,395,2,,void
159937,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }

  // process.env never has non-configurable properties, so always
  // return true like the tc39 delete operator.
  info.GetReturnValue().Set(true);
}",67,,400,3,,void
159956,BLOCK,-1,,"{
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }",29,,403,2,,void
159984,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());

  info.GetReturnValue().Set(
      env->env_vars()->Enumerate(env->isolate()));
}",68,,412,2,,void
160022,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  if (desc.has_value()) {
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvS...",65,,422,4,,void
160036,BLOCK,-1,,"{
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvSetter(property, desc.value(), info);
    }
  }",25,,424,2,,void
160055,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",35,,427,2,,void
160060,BLOCK,-1,,<empty>,12,,433,1,,void
160079,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",34,,435,2,,void
160084,BLOCK,-1,,"{
      return EnvSetter(property, desc.value(), info);
    }",12,,441,1,,void
160094,BLOCK,-1,,<empty>,10,,444,1,,void
160105,BLOCK,-1,,"{
    // we don't accept a getter/setter in 'process.env'
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' does not accept an""
                                             "" accessor(getter/setter)""
                                             "" descriptor"");
  }",48,,444,2,,void
160110,BLOCK,-1,,"{
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' only accepts a ""
                                             ""configurable, writable,""
                                             "" and enumerable ""
                                             ""data descriptor"");
  }",10,,450,1,,void
160119,BLOCK,-1,,"{
  HandleScope scope(isolate);
  if (!isolate_data->env_proxy_template().IsEmpty()) return;
  Local<FunctionTemplate> env_proxy_ctor_template =
      FunctionTemplate::New(isolate);
  Local<ObjectTemplate> env_proxy_template =
      ObjectTemplate::New(isolate, env_proxy_ctor_template);
  env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration(
      EnvGetter,
      EnvSetter,
      EnvQuery,
      EnvDeleter,
      EnvEnumerator,
      EnvDefiner,
      nullptr,
      Local<Value>(),
      PropertyHandlerFlags::kHasNoSideEffect));
  isolate_data->set_env_proxy_template(env_proxy_template);
  isolate_data->set_env_proxy_ctor_template(env_proxy_ctor_template);
}",74,,459,3,,void
160132,BLOCK,-1,,<empty>,54,,461,2,,void
160187,BLOCK,-1,,"{
  registry->Register(EnvGetter);
  registry->Register(EnvSetter);
  registry->Register(EnvQuery);
  registry->Register(EnvDeleter);
  registry->Register(EnvEnumerator);
  registry->Register(EnvDefiner);
}",76,,480,2,,void
160223,BLOCK,-1,,"{
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  }",36,,376,1,,void
160230,BLOCK,-1,,"{
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    }",55,,396,2,,void
160266,BLOCK,-1,,"{
        stack_trace = enhanced;
      }",36,,402,2,,void
160297,BLOCK,-1,,<empty>,1,,1,1,,ANY
160302,BLOCK,-1,,"{
  if (!er.IsEmpty() && er->IsObject()) {
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }
  return false;
}",62,,37,3,,void
160314,BLOCK,-1,,"{
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }",40,,38,2,,void
160368,BLOCK,-1,,"{
  v8::TryCatch try_catch(isolate);
  HandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(context);

  // The ScriptResourceName of the message may be different from the one we use
  // to compile the script. V8 replaces it when it detects magic comments in
  // the source texts.
  Local<Value> script_resource_name = message->GetScriptResourceName();
  int linenum = message->GetLineNumber(context).FromJust();
  int columnum = message->GetStartColumn(context).FromJust();

  Local<Value> argv[] = {script_resource_name,
                         v8::Int32::New(isolate, linenum),
                         v8::Int32::New(isolate, columnum)};
  MaybeLocal<Value> maybe_ret = env->get_source_map_error_source()->Call(
      context, Undefined(isolate), arraysize(argv), argv);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }
  if (!ret->IsString()) {
    return...",72,,55,5,,void
160468,BLOCK,-1,,"{
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }",33,,73,2,,void
160485,BLOCK,-1,,"{
    return std::string();
  }",25,,78,2,,void
160512,BLOCK,-1,,"{
  MaybeLocal<String> source_line_maybe = message->GetSourceLine(context);
  node::Utf8Value encoded_source(isolate, source_line_maybe.ToLocalChecked());
  std::string sourceline(*encoded_source, encoded_source.length());
  *added_exception_line = false;

  if (sourceline.find(""node-do-not-add-exception-line"") != std::string::npos) {
    return sourceline;
  }

  // If source maps have been enabled, the exception line will instead be
  // added in the JavaScript context:
  Environment* env = Environment::GetCurrent(isolate);
  const bool has_source_map_url =
      !message->GetScriptOrigin().SourceMapUrl().IsEmpty() &&
      !message->GetScriptOrigin().SourceMapUrl()->IsUndefined();
  if (has_source_map_url && env != nullptr && env->source_maps_enabled()) {
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }

  // Because of how node modules work, all scripts are ...",63,,89,5,,void
160555,BLOCK,-1,,"{
    return sourceline;
  }",79,,95,2,,void
160603,BLOCK,-1,,"{
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }",75,,105,2,,void
160615,BLOCK,-1,,"{
      return source;
    }",32,,108,2,,void
160693,BLOCK,-1,,"{
    CHECK_GE(end, start);
    start -= script_start;
    end -= script_start;
  }",30,,145,2,,void
160741,BLOCK,-1,,"{
    return buf;
  }",53,,160,2,,void
160754,BLOCK,-1,,<empty>,3,,168,1,,void
160764,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = (sourceline[i] == '\t') ? '\t' : ' ';
  }",35,,168,4,,void
160775,BLOCK,-1,,"{
      break;
    }",60,,169,2,,void
160794,BLOCK,-1,,<empty>,3,,175,1,,void
160804,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = '^';
  }",37,,175,4,,void
160815,BLOCK,-1,,"{
      break;
    }",60,,176,2,,void
160849,BLOCK,-1,,"{
  std::string result;
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
  ...",80,,188,3,,void
160852,BLOCK,-1,,<empty>,3,,190,1,,void
160865,BLOCK,4,,"{
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at ...",52,,190,4,,void
160911,BLOCK,-1,,"{
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }",32,,197,2,,void
160921,BLOCK,-1,,"{
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      }",67,,198,2,,void
160929,BLOCK,-1,,"{
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }",14,,200,1,,void
160970,BLOCK,-1,,"{
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s:%i:%i\n"",
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",34,,213,2,,void
161004,BLOCK,-1,,"{
      std::vector<char> buf(fn_name_s.length() + script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s (%s:%i:%i)\n"",
               *fn_name_s,
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",12,,222,1,,void
161050,BLOCK,-1,,"{
  FPrintF(stderr, ""%s\n"", str);
  fflush(stderr);
}",59,,237,2,,void
161061,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatStackTrace(isolate, stack));
}",65,,242,3,,void
161074,BLOCK,-1,,"{
  std::string result;
  node::Utf8Value reason(isolate,
                         err->ToDetailString(context)
                             .FromMaybe(Local<String>()));
  if (add_source_line) {
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }
  result += reason.ToString() + '\n';

  Local<v8::StackTrace> stack = message->GetStackTrace();
  if (!stack.IsEmpty()) result += FormatStackTrace(isolate, stack);
  return result;
}",64,,250,6,,void
161090,BLOCK,-1,,"{
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }",24,,255,2,,void
161135,BLOCK,-1,,<empty>,25,,264,2,,void
161149,BLOCK,-1,,"{
  CHECK(try_catch.HasCaught());
  return FormatCaughtException(
      isolate, context, try_catch.Exception(), try_catch.Message());
}",66,,270,4,,void
161173,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatCaughtException(isolate, context, try_catch));
}",58,,278,4,,void
161186,BLOCK,-1,,"{
  if (message.IsEmpty()) return;

  HandleScope scope(env->isolate());
  Local<Object> err_obj;
  if (!er.IsEmpty() && er->IsObject()) {
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }

  bool added_exception_line = false;
  std::string source = GetErrorSource(
      env->isolate(), env->context(), message, &added_exception_line);
  if (!added_exception_line) {
    return;
  }
  MaybeLocal<Value> arrow_str = ToV8Value(env->context(), source);

  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();
  // If allocating arrow_str failed, print it out. There's not much else to do.
  // If it's not an error, but something needs to be printed out because
  // it's a fatal exception, also print it out fr...",55,,285,5,,void
161192,BLOCK,-1,,<empty>,26,,286,2,,void
161216,BLOCK,-1,,"{
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }",40,,290,2,,void
161256,BLOCK,-1,,<empty>,7,,297,2,,void
161280,BLOCK,-1,,"{
    return;
  }",30,,303,2,,void
161321,BLOCK,-1,,"{
    if (env->printed_error()) return;
    Mutex::ScopedLock lock(per_process::tty_mutex);
    env->set_printed_error(true);

    ResetStdio();
    FPrintF(stderr, ""\n%s"", source);
    return;
  }",77,,314,2,,void
161327,BLOCK,-1,,<empty>,31,,315,2,,void
161369,BLOCK,-1,,"{
  DumpBacktrace(stderr);
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",27,,331,1,,void
161378,BLOCK,-1,,"{
  std::string name = GetHumanReadableProcessName();

  fprintf(stderr,
          ""%s: %s:%s%s Assertion `%s' failed.\n"",
          name.c_str(),
          info.file_line,
          info.function,
          *info.function ? "":"" : """",
          info.message);
  fflush(stderr);

  Abort();
}",53,,337,2,,void
161417,BLOCK,-1,,"{
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  } else {
    Local<Object> err_obj = error.As<Object>();

    auto enhance_...",71,,365,5,,void
161424,BLOCK,-1,,<empty>,5,,367,2,,void
161482,BLOCK,-1,,"{  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  }",27,,386,2,,void
161489,BLOCK,-1,,"{
    Local<Object> err_obj = error.As<Object>();

    auto enhance_with = [&](Local<Function> enhancer) {
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    };

    switch (enhance_stack) {
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }

    arrow =
        err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol()...",10,,393,1,,void
161506,BLOCK,-1,,"{
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }",28,,407,2,,void
161511,BLOCK,3,,"{
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }",45,,408,3,,void
161528,BLOCK,6,,"{
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }",49,,414,6,,void
161592,BLOCK,-1,,"{
    if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
      FPrintF(stderr, ""%s\n"", trace);
    } else {
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }
  }",58,,433,2,,void
161606,BLOCK,-1,,"{
      FPrintF(stderr, ""%s\n"", trace);
    }",61,,434,2,,void
161612,BLOCK,-1,,"{
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }",12,,436,1,,void
161626,BLOCK,-1,,"{
    // this really only happens for RangeErrors, since they're the only
    // kind that won't have all this info in the trace, or when non-Error
    // objects are thrown manually.
    MaybeLocal<Value> message;
    MaybeLocal<Value> name;

    if (error->IsObject()) {
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }

    if (message.IsEmpty() || message.ToLocalChecked()->IsUndefined() ||
        name.IsEmpty() || name.ToLocalChecked()->IsUndefined()) {
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    } else {
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked()...",10,,440,1,,void
161642,BLOCK,-1,,"{
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }",28,,447,2,,void
161707,BLOCK,-1,,"{
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    }",65,,454,2,,void
161727,BLOCK,-1,,"{
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked());
      // Update the report message if it is an object has message property.
      report_message = message_string.ToString();

      if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      } else {
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }
    }",12,,462,1,,void
161767,BLOCK,-1,,"{
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      }",63,,468,2,,void
161774,BLOCK,-1,,"{
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }",14,,470,1,,void
161796,BLOCK,-1,,"{
      std::string argv0;
      if (!env->argv().empty()) argv0 = env->argv()[0];
      if (argv0.empty()) argv0 = ""node"";
      FPrintF(stderr,
              ""(Use `%s --trace-uncaught ...` to show where the exception ""
              ""was thrown)\n"",
              fs::Basename(argv0, "".exe""));
    }",42,,477,2,,void
161807,BLOCK,-1,,<empty>,33,,479,2,,void
161821,BLOCK,-1,,<empty>,26,,480,2,,void
161844,BLOCK,-1,,"{
    TriggerNodeReport(env, report_message.c_str(), ""Exception"", """", error);
  }",66,,488,2,,void
161861,BLOCK,-1,,"{
    Local<StackTrace> trace = message->GetStackTrace();
    if (!trace.IsEmpty()) {
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }
  }",39,,492,2,,void
161878,BLOCK,-1,,"{
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }",27,,494,2,,void
161895,BLOCK,-1,,"{
    FPrintF(stderr, ""\nNode.js %s\n"", NODE_VERSION);
  }",54,,500,2,,void
161906,BLOCK,-1,,"{
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",75,,507,3,,void
161909,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,508,2,,void
161916,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,510,1,,void
161929,BLOCK,5,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,516,5,,void
161946,BLOCK,-1,,"{
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }",29,,521,2,,void
161960,BLOCK,-1,,"{
  const char* message =
      details.is_heap_oom ? ""Allocation failed - JavaScript heap out of memory""
                          : ""Allocation failed - process out of memory"";
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",66,,530,3,,void
161972,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,534,2,,void
161979,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,536,1,,void
161992,BLOCK,7,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,542,7,,void
162009,BLOCK,-1,,"{
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }",29,,547,2,,void
162024,BLOCK,-1,,"{
  HandleScope scope(context->GetIsolate());

  Environment* env = Environment::GetCurrent(context);
  if (env->source_maps_enabled()) {
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }

  Local<Value> allow_code_gen = context->GetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings);
  bool codegen_allowed =
      allow_code_gen->IsUndefined() || allow_code_gen->IsTrue();
  return {
      codegen_allowed,
      {},
  };
}",24,,563,4,,void
162044,BLOCK,-1,,"{
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }",35,,567,2,,void
162089,BLOCK,-1,,"{
      DCHECK(try_catch.HasCaught());
    }",33,,577,2,,void
162125,BLOCK,-1,,"{
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",33,,594,1,,void
162137,BLOCK,-1,,"{
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }",70,,595,2,,void
162178,BLOCK,-1,,<empty>,7,,602,2,,void
162206,BLOCK,-1,,"{
#define ERRNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (errorno) {
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET)...",39,,608,2,,void
162209,BLOCK,-1,,"{
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET);
#endif

#ifdef EDEADLK
    ERRNO_CASE(EDEADLK);
#endif

#ifdef EDESTADDRREQ
    ERRNO_CASE(EDESTADDRREQ);
#endif

#ifdef EDOM
    ERRNO_CASE(EDOM);
#endif

#ifdef EDQUOT
    ERRNO_CASE(EDQUOT);
#e...",20,,612,2,,void
162218,BLOCK,-1,,"{
  Isolate* isolate = message->GetIsolate();
  switch (message->ErrorLevel()) {
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }
}",76,,936,3,,void
162231,BLOCK,-1,,"{
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }",34,,938,2,,void
162238,BLOCK,3,,"{
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }",55,,939,3,,void
162250,BLOCK,-1,,"{
        break;
      }",17,,941,2,,void
162326,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  realm->set_prepare_stack_trace_callback(args[0].As<Function>());
}",76,,962,2,,void
162356,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsBoolean());
  env->set_source_maps_enabled(args[0].As<Boolean>()->Value());
}",75,,968,2,,void
162389,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_get_source_map_error_source(args[0].As<Function>());
}",46,,975,2,,void
162419,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_maybe_cache_generated_source_map(args[0].As<Function>());
}",46,,982,2,,void
162449,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  realm->set_enhance_fatal_stack_before_inspector(args[0].As<Function>());
  realm->set_enhance_fatal_stack_after_inspector(args[1].As<Function>());
}",46,,989,2,,void
162496,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Local<String> detail_string;
  if (args[0]->ToDetailString(context).ToLocal(&detail_string))
    args.GetReturnValue().Set(detail_string);
}",76,,998,2,,void
162528,BLOCK,-1,,<empty>,5,,1002,2,,void
162541,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(isolate);
  Local<Value> exception = args[0];
  Local<Message> message = Exception::CreateMessage(isolate, exception);
  if (env != nullptr && env->abort_on_uncaught_exception()) {
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }
  bool from_promise = args[1]->IsTrue();
  errors::TriggerUncaughtException(isolate, exception, message, from_promise);
}",79,,1005,2,,void
162587,BLOCK,-1,,"{
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }",61,,1010,2,,void
162617,BLOCK,-1,,"{
  registry->Register(SetPrepareStackTraceCallback);
  registry->Register(SetGetSourceMapErrorSource);
  registry->Register(SetSourceMapsEnabled);
  registry->Register(SetMaybeCacheGeneratedSourceMap);
  registry->Register(SetEnhanceStackForFatalException);
  registry->Register(NoSideEffectsToString);
  registry->Register(TriggerUncaughtException);
}",70,,1019,2,,void
162660,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""setPrepareStackTraceCallback"",
            SetPrepareStackTraceCallback);
  SetMethod(context,
            target,
            ""setGetSourceMapErrorSource"",
            SetGetSourceMapErrorSource);
  SetMethod(context, target, ""setSourceMapsEnabled"", SetSourceMapsEnabled);
  SetMethod(context,
            target,
            ""setMaybeCacheGeneratedSourceMap"",
            SetMaybeCacheGeneratedSourceMap);
  SetMethod(context,
            target,
            ""setEnhanceStackForFatalException"",
            SetEnhanceStackForFatalException);
  SetMethodNoSideEffect(
      context, target, ""noSideEffectsToString"", NoSideEffectsToString);
  SetMethod(
      context, target, ""triggerUncaughtException"", TriggerUncaughtException);

  Isolate* isolate = context->GetIsolate();
  Local<Object> exit_codes = Object::New(isolate);
  READONLY_PROPERTY(target, ""exitCodes"", exit_codes);

#define V(Name, Code)                                     ...",29,,1032,5,,void
162725,BLOCK,-1,,"{
  Local<Value> exception = try_catch.Exception();

  if (!exception->IsObject()) return;

  Local<Object> err_obj = exception.As<Object>();

  if (IsExceptionDecorated(env, err_obj)) return;

  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);
  TryCatchScope try_catch_scope(env);  // Ignore exceptions below.
  MaybeLocal<Value> stack = err_obj->Get(env->context(), env->stack_string());
  MaybeLocal<Value> maybe_value =
      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());

  Local<Value> arrow;
  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {
    return;
  }

  if (stack.IsEmpty() || !stack.ToLocalChecked()->IsString()) {
    return;
  }

  Local<String> decorated_stack = String::Concat(
      env->isolate(),
      String::Concat(env->isolate(),
                     arrow.As<String>(),
                     FIXED_ONE_BYTE_STRING(env->isolate(), ""\n"")),
      stack.ToLocalChecked().As<String>());
  USE(err_obj->Set(env...",65,,1068,3,,void
162742,BLOCK,-1,,<empty>,31,,1071,2,,void
162758,BLOCK,-1,,<empty>,43,,1075,2,,void
162825,BLOCK,-1,,"{
    return;
  }",60,,1084,2,,void
162841,BLOCK,-1,,"{
    return;
  }",63,,1088,2,,void
162920,BLOCK,-1,,"{
  CHECK(!error.IsEmpty());
  HandleScope scope(isolate);

  if (message.IsEmpty()) message = Exception::CreateMessage(isolate, error);

  CHECK(isolate->InContext());
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }

  // Invoke process._fatalException() to give user a chance to handle it.
  // We have to grab it from the process object since this has been
  // monkey-patchable.
  L...",50,,1106,5,,void
162935,BLOCK,-1,,<empty>,26,,1110,2,,void
162971,BLOCK,-1,,"{
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }",23,,1115,2,,void
163023,BLOCK,-1,,"{
    ReportFatalException(
        env, error, message, EnhanceFatalException::kDontEnhance);
    env->Exit(ExitCode::kInvalidFatalExceptionMonkeyPatching);
    return;
  }",48,,1138,2,,void
163049,BLOCK,-1,,"{
    // We do not expect the global uncaught exception itself to throw any more
    // exceptions. If it does, exit the current Node.js instance.
    errors::TryCatchScope try_catch(env,
                                    errors::TryCatchScope::CatchMode::kFatal);
    // Explicitly disable verbose exception reporting -
    // if process._fatalException() throws an error, we don't want it to
    // trigger the per-isolate message listener which will call this
    // function and recurse.
    try_catch.SetVerbose(false);
    Local<Value> argv[2] = { error,
                             Boolean::New(env->isolate(), from_promise) };

    maybe_handled = fatal_exception_function.As<Function>()->Call(
        env->context(), process_object, arraysize(argv), argv);
  }",32,,1146,2,,void
163103,BLOCK,-1,,"{
    return;
  }",41,,1168,2,,void
163111,BLOCK,-1,,"{
    return;
  }",28,,1178,2,,void
163138,BLOCK,-1,,"{
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",80,,1191,3,,void
163144,BLOCK,-1,,"{
    return;
  }",30,,1195,2,,void
163174,BLOCK,-1,,"{
  if (!HasCaught()) {
    return;
  }
  std::string str =
      FormatCaughtException(isolate_,
                            isolate_->GetCurrentContext(),
                            Exception(),
                            Message(),
                            print_source_line_ == kPrintSourceLine);
  PrintToStderrAndFlush(str);
}",37,,1212,1,,void
163178,BLOCK,-1,,"{
    return;
  }",21,,1213,2,,void
163211,BLOCK,-1,,<empty>,1,,1,1,,ANY
163216,BLOCK,-1,,<empty>,1,,1,1,,ANY
163231,BLOCK,-1,,<empty>,1,,1,1,,ANY
163234,BLOCK,-1,,"{
  if (!is_finalized_) {
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }

  return external_references_;
}",79,,9,1,,void
163238,BLOCK,-1,,"{
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }",23,,10,2,,void
163254,BLOCK,-1,,"{
  this->Register(BaseObject::LazilyInitializedJSTemplateConstructor);

#define V(modname) _register_external_reference_##modname(this);
  EXTERNAL_REFERENCE_BINDING_LIST(V)
#undef V
  // TODO(joyeecheung): collect more external references here.
}",56,,18,1,,void
163278,BLOCK,-1,,<empty>,1,,1,1,,ANY
163287,BLOCK,-1,,<empty>,1,,1,1,,ANY
163291,BLOCK,-1,,"{
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,359,2,,void
163323,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing file descriptor %d on garbage collection"",
                       detail.fd);
    if (env->filehandle_close_warning()) {
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }
  }",50,,378,2,,void
163335,BLOCK,-1,,"{
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }",42,,382,2,,void
163351,BLOCK,-1,,"{
    CloseReq* req_wrap = CloseReq::from_req(req);
    FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
    BaseObjectPtr<CloseReq> close(req_wrap);
    CHECK(close);
    close->file_handle()->AfterClose();
    if (!close->env()->can_call_into_js()) return;
    Isolate* isolate = close->env()->isolate();
    if (req->result < 0) {
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    } else {
      close->Resolve();
    }
  }",55,,480,2,,void
163376,BLOCK,1,,<empty>,,,,20,,void
163378,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,1,,void
163396,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,2,,void
163424,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,2,,void
163498,BLOCK,-1,,<empty>,44,,487,2,,void
163516,BLOCK,-1,,"{
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    }",26,,489,2,,void
163533,BLOCK,-1,,"{
      close->Resolve();
    }",12,,493,1,,void
163543,BLOCK,-1,,"{
    FileHandle* handle;
    {
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }

    // ReadStart() checks whether current_read_ is set to determine whether
    // a read is in progress. Moving it into a local variable makes sure that
    // the ReadStart() call below doesn't think we're still actively reading.
    BaseObjectPtr<FileHandleReadWrap> read_wrap =
        std::move(handle->current_read_);

    ssize_t result = req->result;
    uv_buf_t buffer = read_wrap->buffer_;

    uv_fs_req_cleanup(req);

    // Push the read wrap back to the freelist, or let it be destroyed
    // once we’re exiting the current scope.
    constexpr size_t kWantedFreelistFill = 100;
    auto& freelist = handle->binding_data_->file_handle_read_wrap_freelist;
    if (freelist.si...",61,,605,2,,void
163545,BLOCK,2,,"{
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }",5,,607,2,,void
163569,BLOCK,1,,<empty>,,,,18,,void
163571,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,1,,void
163589,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,2,,void
163617,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,2,,void
163727,BLOCK,-1,,"{
      read_wrap->Reset();
      freelist.emplace_back(std::move(read_wrap));
    }",48,,630,2,,void
163745,BLOCK,-1,,"{
      // Read at most as many bytes as we originally planned to.
      if (handle->read_length_ >= 0 && handle->read_length_ < result)
        result = handle->read_length_;

      // If we read data and we have an expected length, decrease it by
      // how much we have read.
      if (handle->read_length_ >= 0)
        handle->read_length_ -= result;

      // If we have an offset, increase it by how much we have read.
      if (handle->read_offset_ >= 0)
        handle->read_offset_ += result;
    }",22,,635,2,,void
163758,BLOCK,-1,,<empty>,9,,638,2,,void
163770,BLOCK,-1,,<empty>,9,,643,2,,void
163782,BLOCK,-1,,<empty>,9,,647,2,,void
163792,BLOCK,-1,,<empty>,7,,653,2,,void
163806,BLOCK,-1,,<empty>,7,,659,2,,void
163816,BLOCK,-1,,"{
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }",70,,685,2,,void
163842,BLOCK,1,,<empty>,,,,18,,void
163844,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,1,,void
163862,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,2,,void
163890,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,2,,void
163973,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",48,,1047,1,,void
163993,BLOCK,-1,,"{
            FSReqBase* req_wrap = FSReqBase::from_req(req);
            int err = static_cast<int>(req->result);
            if (reinterpret_cast<intptr_t>(req->data) == UV_EEXIST &&
                  req_wrap->continuation_data()->paths().size() > 0) {
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }
            // verify that the path pointed to is actually a directory.
            if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;
            req_wrap->continuation_data()->Done(err);
          }",66,,1721,2,,void
164031,BLOCK,-1,,"{
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }",70,,1725,2,,void
164043,BLOCK,1,,<empty>,,,,2,,void
164053,BLOCK,-1,,"{
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }",62,,1726,2,,void
164107,BLOCK,1,,<empty>,,,,2,,void
164117,BLOCK,-1,,<empty>,61,,1738,2,,void
164135,BLOCK,-1,,"{
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
        ...",59,,1672,2,,void
164174,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->conti...",18,,1679,2,,void
164177,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushP...",20,,1680,2,,void
164180,BLOCK,3,,"{
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }",17,,1683,3,,void
164194,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          }",67,,1684,2,,void
164212,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }",18,,1687,1,,void
164245,BLOCK,10,,"{
          req_wrap->continuation_data()->Done(err);
          break;
        }",24,,1697,10,,void
164257,BLOCK,13,,"{
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          uv_fs_req_cleanup(req);
          MKDirpAsync(loop, req, path.c_str(),
                      req_wrap->continuation_data()->mode(), nullptr);
          break;
        }",25,,1701,13,,void
164275,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",32,,1704,2,,void
164297,BLOCK,-1,,<empty>,18,,1707,1,,void
164311,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1707,2,,void
164363,BLOCK,-1,,<empty>,24,,1741,2,,void
164424,BLOCK,-1,,<empty>,1,,1,1,,ANY
164433,BLOCK,-1,,"{
  // Remove everything leading up to and including the final path separator.
  std::string::size_type pos = str.find_last_of(kPathSeparator);

  // Starting index for the resulting string
  std::size_t start_pos = 0;
  // String size to return
  std::size_t str_size = str.size();
  if (pos != std::string::npos) {
    start_pos = pos + 1;
    str_size -= start_pos;
  }

  // Strip away the extension, if any.
  if (str_size >= extension.size() &&
      str.compare(str.size() - extension.size(),
        extension.size(), extension) == 0) {
    str_size -= extension.size();
  }

  return str.substr(start_pos, str_size);
}",76,,90,3,,void
164461,BLOCK,-1,,"{
    start_pos = pos + 1;
    str_size -= start_pos;
  }",33,,98,2,,void
164498,BLOCK,-1,,"{
    str_size -= extension.size();
  }",44,,106,2,,void
164516,BLOCK,-1,,"{
  return IsSafeJsInt(value) ? value.As<Integer>()->Value() : -1;
}",46,,113,2,,void
164534,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_T...",66,,117,2,,void
164537,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_TYPE_TO_NAME(SCANDIR, ""...",21,,118,2,,void
164539,BLOCK,1,,<empty>,,,,1,,void
164545,BLOCK,1,,<empty>,,,,1,,void
164551,BLOCK,1,,<empty>,,,,1,,void
164557,BLOCK,1,,<empty>,,,,1,,void
164563,BLOCK,1,,<empty>,,,,1,,void
164569,BLOCK,1,,<empty>,,,,1,,void
164575,BLOCK,1,,<empty>,,,,1,,void
164581,BLOCK,1,,<empty>,,,,1,,void
164587,BLOCK,1,,<empty>,,,,1,,void
164593,BLOCK,1,,<empty>,,,,1,,void
164599,BLOCK,1,,<empty>,,,,1,,void
164605,BLOCK,1,,<empty>,,,,1,,void
164611,BLOCK,1,,<empty>,,,,1,,void
164617,BLOCK,1,,<empty>,,,,1,,void
164623,BLOCK,1,,<empty>,,,,1,,void
164629,BLOCK,1,,<empty>,,,,1,,void
164635,BLOCK,1,,<empty>,,,,1,,void
164641,BLOCK,1,,<empty>,,,,1,,void
164647,BLOCK,1,,<empty>,,,,1,,void
164653,BLOCK,1,,<empty>,,,,1,,void
164659,BLOCK,1,,<empty>,,,,1,,void
164665,BLOCK,1,,<empty>,,,,1,,void
164671,BLOCK,1,,<empty>,,,,1,,void
164677,BLOCK,1,,<empty>,,,,1,,void
164683,BLOCK,1,,<empty>,,,,1,,void
164689,BLOCK,1,,<empty>,,,,1,,void
164695,BLOCK,1,,<empty>,,,,1,,void
164701,BLOCK,1,,<empty>,,,,1,,void
164707,BLOCK,1,,<empty>,,,,1,,void
164713,BLOCK,1,,<empty>,,,,1,,void
164719,BLOCK,1,,<empty>,,,,1,,void
164725,BLOCK,1,,<empty>,,,,1,,void
164731,BLOCK,1,,<empty>,,,,1,,void
164743,BLOCK,-1,,<empty>,,,,2,,<empty>
164748,BLOCK,-1,,"{
  tracker->TrackField(""paths"", paths_);
}",67,,222,2,,void
164758,BLOCK,-1,,<empty>,,,,1,,<empty>
164762,BLOCK,-1,,<empty>,,,,1,,<empty>
164767,BLOCK,-1,,"{
  tracker->TrackField(""continuation_data"", continuation_data_);
}",58,,230,2,,void
164780,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
}",35,,242,4,,void
164791,BLOCK,-1,,"{
  Environment* env = binding_data->env();
  if (obj.IsEmpty() && !env->fd_constructor_template()
                            ->NewInstance(env->context())
                            .ToLocal(&obj)) {
    return nullptr;
  }
  auto handle = new FileHandle(binding_data, obj, fd);
  if (maybeOffset.has_value()) handle->read_offset_ = maybeOffset.value();
  if (maybeLength.has_value()) handle->read_length_ = maybeLength.value();
  return handle;
}",65,,251,6,,void
164822,BLOCK,-1,,"{
    return nullptr;
  }",45,,255,2,,void
164838,BLOCK,-1,,<empty>,32,,259,2,,void
164852,BLOCK,-1,,<empty>,32,,260,2,,void
164867,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());

  std::optional<int64_t> maybeOffset = std::nullopt;
  std::optional<int64_t> maybeLength = std::nullopt;
  if (args[1]->IsNumber())
    maybeOffset = args[1]->IntegerValue(env->context()).FromJust();
  if (args[2]->IsNumber())
    maybeLength = args[2]->IntegerValue(env->context()).FromJust();

  FileHandle::New(binding_data,
                  args[0].As<Int32>()->Value(),
                  args.This(),
                  maybeOffset,
                  maybeLength);
}",63,,264,2,,void
164926,BLOCK,-1,,<empty>,5,,273,2,,void
164949,BLOCK,-1,,<empty>,5,,275,2,,void
164988,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  Close();           // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",27,,284,1,,void
165001,BLOCK,-1,,"{
  return UV_ENOSYS;  // Not implemented (yet).
}",51,,293,5,,void
165008,BLOCK,-1,,"{
  tracker->TrackField(""current_read"", current_read_);
}",59,,297,2,,void
165018,BLOCK,-1,,"{
  return reading_ || closing_ || closed_ ?
      TransferMode::kUntransferable : TransferMode::kTransferable;
}",62,,301,1,,void
165035,BLOCK,-1,,"{
  CHECK_NE(GetTransferMode(), TransferMode::kUntransferable);
  auto ret = std::make_unique<TransferData>(fd_);
  closed_ = true;
  return ret;
}",74,,306,1,,void
165060,BLOCK,-1,,<empty>,58,,313,2,,void
165064,BLOCK,-1,,"{
  if (fd_ > 0) {
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }
}",43,,315,1,,void
165069,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }",16,,316,2,,void
165078,BLOCK,1,,<empty>,,,,9,,void
165094,BLOCK,-1,,<empty>,5,,319,2,,void
165096,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,1,,void
165114,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,2,,void
165142,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,2,,void
165182,BLOCK,1,,<empty>,,,,9,,void
165198,BLOCK,-1,,<empty>,5,,321,2,,void
165200,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,1,,void
165218,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,2,,void
165246,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,2,,void
165284,BLOCK,-1,,"{
  BindingData* bd = Realm::GetBindingData<BindingData>(context);
  if (bd == nullptr) return {};

  int fd = fd_;
  fd_ = -1;
  return BaseObjectPtr<BaseObject> { FileHandle::New(bd, fd) };
}",49,,329,4,,void
165299,BLOCK,-1,,<empty>,22,,331,2,,void
165321,BLOCK,-1,,"{
  if (closed_ || closing_) return;
  uv_fs_t req;
  CHECK_NE(fd_, -1);
  FS_SYNC_TRACE_BEGIN(close);
  int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);
  FS_SYNC_TRACE_END(close);
  uv_fs_req_cleanup(&req);

  struct err_detail { int ret; int fd; };

  err_detail detail { ret, fd_ };

  AfterClose();

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the clos...",33,,342,1,,void
165326,BLOCK,-1,,<empty>,28,,343,2,,void
165336,BLOCK,1,,<empty>,,,,9,,void
165352,BLOCK,-1,,<empty>,3,,346,2,,void
165354,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,1,,void
165372,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,2,,void
165400,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,2,,void
165444,BLOCK,1,,<empty>,,,,9,,void
165460,BLOCK,-1,,<empty>,3,,348,2,,void
165462,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,1,,void
165480,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,2,,void
165508,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,2,,void
165550,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,357,2,,void
165568,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Resolve(env()->context(), Undefined(isolate)).Check();
}",38,,395,1,,void
165628,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Reject(env()->context(), reason).Check();
}",56,,405,2,,void
165686,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Value> val = ref_.Get(isolate);
  Local<Object> obj = val.As<Object>();
  return Unwrap<FileHandle>(obj);
}",49,,415,1,,void
165731,BLOCK,-1,,"{
  promise_.Reset(env->isolate(), promise);
  ref_.Reset(env->isolate(), ref);
}",63,,427,5,,void
165753,BLOCK,-1,,"{
  uv_fs_req_cleanup(req());
  promise_.Reset();
  ref_.Reset();
}",35,,432,1,,void
165767,BLOCK,-1,,"{
  tracker->TrackField(""promise"", promise_);
  tracker->TrackField(""ref"", ref_);
}",69,,438,2,,void
165783,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = env()->context();

  Local<Value> close_resolver =
      object()->GetInternalField(FileHandle::kClosingPromiseSlot);
  if (!close_resolver.IsEmpty() && !close_resolver->IsUndefined()) {
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }

  CHECK(!closed_);
  CHECK(!closing_);
  CHECK(!reading_);

  auto maybe_resolver = Promise::Resolver::New(context);
  CHECK(!maybe_resolver.IsEmpty());
  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();
  Local<Promise> promise = resolver.As<Promise>();

  Local<Object> close_req_obj;
  if (!env()->fdclose_constructor_template()
          ->NewInstance(env()->context()).ToLocal(&close_req_obj)) {
    return MaybeLocal<Promise>();
  }
  closing_ = true;
  object()->SetInternalField(FileHandle::kClosingPromiseSlot, promise);

  CloseReq* req = new CloseReq(env(), close_req_obj, promise, obje...",48,,450,1,,void
165829,BLOCK,-1,,"{
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }",68,,457,2,,void
165910,BLOCK,-1,,"{
    return MaybeLocal<Promise>();
  }",68,,473,2,,void
165949,BLOCK,1,,<empty>,,,,16,,void
165951,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,1,,void
165969,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,2,,void
165997,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,2,,void
166054,BLOCK,-1,,"{
    req->Reject(UVException(isolate, ret, ""close""));
    delete req;
  }",16,,500,2,,void
166075,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  Local<Promise> ret;
  if (!fd->ClosePromise().ToLocal(&ret)) return;
  args.GetReturnValue().Set(ret);
}",65,,508,2,,void
166100,BLOCK,-1,,<empty>,42,,512,2,,void
166114,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  fd->Release();
}",69,,517,2,,void
166130,BLOCK,-1,,"{
  int fd = GetFD();
  // Just pretend that Close was called and we're all done.
  AfterClose();
  return fd;
}",27,,523,1,,void
166141,BLOCK,-1,,"{
  closing_ = false;
  closed_ = true;
  fd_ = -1;
  if (reading_ && !persistent().IsEmpty())
    EmitRead(UV_EOF);
}",31,,530,1,,void
166160,BLOCK,-1,,<empty>,5,,535,2,,void
166166,BLOCK,-1,,"{
  tracker->TrackField(""buffer"", buffer_);
  tracker->TrackField(""file_handle"", this->file_handle_);
}",67,,538,2,,void
166186,BLOCK,-1,,<empty>,26,,545,3,,void
166190,BLOCK,-1,,"{
  if (!IsAlive() || IsClosing())
    return UV_EOF;

  reading_ = true;

  if (current_read_)
    return 0;

  BaseObjectPtr<FileHandleReadWrap> read_wrap;

  if (read_length_ == 0) {
    EmitRead(UV_EOF);
    return 0;
  }

  {
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_...",29,,547,1,,void
166196,BLOCK,-1,,<empty>,5,,549,2,,void
166204,BLOCK,-1,,<empty>,5,,554,2,,void
166216,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    return 0;
  }",26,,558,2,,void
166220,BLOCK,6,,"{
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    } else {
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBU...",3,,563,6,,void
166243,BLOCK,-1,,"{
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    }",30,,571,2,,void
166300,BLOCK,-1,,"{
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBUSY;
      }
      read_wrap = MakeDetachedBaseObject<FileHandleReadWrap>(this, wrap_obj);
    }",12,,581,1,,void
166324,BLOCK,-1,,"{
        return UV_EBUSY;
      }",37,,586,2,,void
166349,BLOCK,-1,,<empty>,5,,594,2,,void
166376,BLOCK,1,,<empty>,,,,15,,void
166378,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,1,,void
166396,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,2,,void
166424,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,2,,void
166490,BLOCK,-1,,"{
  reading_ = false;
  return 0;
}",28,,665,1,,void
166501,BLOCK,-1,,"{
  return new FileHandleCloseWrap(this, object);
}",68,,672,2,,void
166511,BLOCK,-1,,"{
  if (closing_ || closed_) {
    req_wrap->Done(0);
    return 1;
  }
  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);
  closing_ = true;
  CHECK_NE(fd_, -1);
  FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)
  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }});

  return 0;
}",52,,676,2,,void
166516,BLOCK,-1,,"{
    req_wrap->Done(0);
    return 1;
  }",28,,677,2,,void
166544,BLOCK,1,,<empty>,,,,16,,void
166546,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,1,,void
166564,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,2,,void
166592,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,2,,void
166650,BLOCK,-1,,"{
  MakeCallback(env()->oncomplete_string(), 1, &reject);
}",49,,702,2,,void
166663,BLOCK,-1,,"{
  Resolve(FillGlobalStatsArray(binding_data(), use_bigint(), stat));
}",56,,706,2,,void
166673,BLOCK,-1,,"{
  Resolve(FillGlobalStatFsArray(binding_data(), use_bigint(), stat));
}",60,,710,2,,void
166683,BLOCK,-1,,"{
  Local<Value> argv[2] {
    Null(env()->isolate()),
    value
  };
  MakeCallback(env()->oncomplete_string(),
               value->IsUndefined() ? 1 : arraysize(argv),
               argv);
}",49,,714,2,,void
166712,BLOCK,-1,,"{
  args.GetReturnValue().SetUndefined();
}",77,,724,2,,void
166724,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  new FSReqCallback(binding_data, args.This(), args[0]->IsTrue());
}",64,,728,2,,void
166758,BLOCK,-1,,"{
  CHECK_EQ(wrap_->req(), req);
}",46,,738,3,,void
166768,BLOCK,-1,,"{
  Clear();
}",37,,742,1,,void
166773,BLOCK,-1,,"{
  if (!wrap_) return;

  uv_fs_req_cleanup(wrap_->req());
  wrap_->Detach();
  wrap_.reset();
}",31,,746,1,,void
166777,BLOCK,-1,,<empty>,15,,747,2,,void
166796,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> wrap { wrap_ };
  Local<Value> exception = UVException(wrap_->env()->isolate(),
                                       static_cast<int>(req->result),
                                       wrap_->syscall(),
                                       nullptr,
                                       req->path,
                                       wrap_->data());
  Clear();
  wrap->Reject(exception);
}",44,,763,2,,void
166844,BLOCK,-1,,"{
  if (!wrap_->env()->can_call_into_js()) {
    return false;
  }

  if (req_->result < 0) {
    Reject(req_);
    return false;
  }
  return true;
}",33,,775,1,,void
166854,BLOCK,-1,,"{
    return false;
  }",42,,776,2,,void
166863,BLOCK,-1,,"{
    Reject(req_);
    return false;
  }",25,,780,2,,void
166873,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",32,,787,2,,void
166901,BLOCK,1,,<empty>,,,,18,,void
166903,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,1,,void
166921,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,2,,void
166949,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,2,,void
167005,BLOCK,-1,,<empty>,5,,793,2,,void
167022,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStat(&req->statbuf);
  }
}",30,,796,2,,void
167050,BLOCK,1,,<empty>,,,,18,,void
167052,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,1,,void
167070,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,2,,void
167098,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,2,,void
167154,BLOCK,-1,,"{
    req_wrap->ResolveStat(&req->statbuf);
  }",24,,801,2,,void
167167,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }
}",32,,806,2,,void
167195,BLOCK,1,,<empty>,,,,18,,void
167197,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,1,,void
167215,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,2,,void
167243,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,2,,void
167299,BLOCK,-1,,"{
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }",24,,811,2,,void
167313,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  int result = static_cast<int>(req->result);
  if (result >= 0 && req_wrap->is_plain_open())
    req_wrap->env()->AddUnmanagedFd(result);

  if (after.Proceed())
    req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), result));
}",33,,816,2,,void
167341,BLOCK,1,,<empty>,,,,18,,void
167343,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,1,,void
167361,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,2,,void
167389,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,2,,void
167457,BLOCK,-1,,<empty>,5,,823,2,,void
167471,BLOCK,-1,,<empty>,5,,826,2,,void
167492,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }
}",40,,829,2,,void
167520,BLOCK,1,,<empty>,,,,18,,void
167522,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,1,,void
167540,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,2,,void
167568,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,2,,void
167624,BLOCK,-1,,"{
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }",24,,834,2,,void
167645,BLOCK,-1,,<empty>,24,,837,2,,void
167659,BLOCK,-1,,"{
#ifdef _WIN32
  if (path->compare(0, 8, ""\\\\?\\UNC\\"", 8) == 0) {
    *path = path->substr(8);
    path->insert(0, ""\\\\"");
  } else if (path->compare(0, 4, ""\\\\?\\"", 4) == 0) {
    *path = path->substr(4);
  }
#endif
}",44,,844,2,,void
167664,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }
}",32,,855,2,,void
167692,BLOCK,1,,<empty>,,,,18,,void
167694,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,1,,void
167712,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,2,,void
167740,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,2,,void
167796,BLOCK,-1,,"{
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }",24,,860,2,,void
167811,BLOCK,-1,,<empty>,7,,863,2,,void
167866,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",54,,869,2,,void
167883,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",36,,876,2,,void
167911,BLOCK,1,,<empty>,,,,18,,void
167913,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,1,,void
167931,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,2,,void
167959,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,2,,void
168025,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,884,2,,void
168053,BLOCK,-1,,<empty>,7,,890,2,,void
168060,BLOCK,-1,,<empty>,7,,892,1,,void
168073,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",35,,896,2,,void
168101,BLOCK,1,,<empty>,,,,18,,void
168103,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,1,,void
168121,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,2,,void
168149,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,2,,void
168215,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,904,2,,void
168245,BLOCK,-1,,<empty>,7,,910,2,,void
168252,BLOCK,-1,,<empty>,7,,912,1,,void
168265,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();
  Local<Value> error;
  int r;

  std::vector<Local<Value>> name_v;
  std::vector<Local<Value>> type_v;

  const bool with_file_types = req_wrap->with_file_types();

  for (;;) {
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, e...",33,,916,2,,void
168293,BLOCK,1,,<empty>,,,,18,,void
168295,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,1,,void
168313,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,2,,void
168341,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,2,,void
168398,BLOCK,-1,,"{
    return;
  }",25,,921,2,,void
168446,BLOCK,-1,,<empty>,3,,935,1,,void
168447,BLOCK,4,,"{
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, ent.type));
  }",12,,935,4,,void
168459,BLOCK,-1,,<empty>,7,,940,2,,void
168465,BLOCK,-1,,"{
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }",17,,941,2,,void
168508,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",35,,948,2,,void
168522,BLOCK,-1,,<empty>,26,,953,2,,void
168537,BLOCK,-1,,"{
    Local<Value> result[] = {Array::New(isolate, name_v.data(), name_v.size()),
                             Array::New(isolate, type_v.data(), type_v.size())};
    req_wrap->Resolve(Array::New(isolate, result, arraysize(result)));
  }",24,,956,2,,void
168581,BLOCK,-1,,"{
    req_wrap->Resolve(Array::New(isolate, name_v.data(), name_v.size()));
  }",10,,960,1,,void
168603,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  } else {  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(a...",54,,965,2,,void
168681,BLOCK,-1,,"{  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  }",34,,983,2,,void
168690,BLOCK,1,,<empty>,,,,18,,void
168692,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,1,,void
168710,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,2,,void
168738,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,2,,void
168802,BLOCK,-1,,"{  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(access);
  }",10,,988,1,,void
168810,BLOCK,1,,<empty>,,,,9,,void
168826,BLOCK,-1,,<empty>,5,,991,2,,void
168828,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,1,,void
168846,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,2,,void
168874,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,2,,void
168918,BLOCK,1,,<empty>,,,,9,,void
168934,BLOCK,-1,,<empty>,5,,993,2,,void
168936,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,1,,void
168954,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,2,,void
168982,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,2,,void
169015,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();
  env->RemoveUnmanagedFd(fd);

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  } else {  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }
}",53,,998,2,,void
169068,BLOCK,-1,,"{  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  }",34,,1009,2,,void
169076,BLOCK,1,,<empty>,,,,16,,void
169078,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,1,,void
169096,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,2,,void
169124,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,2,,void
169177,BLOCK,-1,,"{  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }",10,,1013,1,,void
169185,BLOCK,1,,<empty>,,,,9,,void
169201,BLOCK,-1,,<empty>,5,,1016,2,,void
169203,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,1,,void
169221,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,2,,void
169249,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,2,,void
169291,BLOCK,1,,<empty>,,,,9,,void
169307,BLOCK,-1,,<empty>,5,,1018,2,,void
169309,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,1,,void
169327,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,2,,void
169355,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,2,,void
169388,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_loop_t* loop = env->event_loop();

  CHECK(args[0]->IsString());
  node::Utf8Value path(isolate, args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  if (strlen(*path) != path.length()) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }
  uv_fs_t open_req;
  const int fd = uv_fs_open(loop, &open_req, *path, O_RDONLY, 0, nullptr);
  uv_fs_req_cleanup(&open_req);

  if (fd < 0) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }

  auto defer_close = OnScopeLeave([fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  const size_t kBlockSize = 32 << 10;
  std::vector<char> chars;
  int64_t offset = 0;
  ssize_t numchars;
  do {
    const size_t start = chars.size();
   ...",77,,1024,2,,void
169443,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }",39,,1034,2,,void
169476,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }",15,,1042,2,,void
169508,BLOCK,-1,,"{
    const size_t start = chars.size();
    chars.resize(start + kBlockSize);

    uv_buf_t buf;
    buf.base = &chars[start];
    buf.len = kBlockSize;

    uv_fs_t read_req;
    numchars = uv_fs_read(loop, &read_req, fd, &buf, 1, offset, nullptr);
    uv_fs_req_cleanup(&read_req);

    if (numchars < 0) {
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }
    offset += numchars;
  }",6,,1057,1,,void
169557,BLOCK,-1,,"{
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }",23,,1069,2,,void
169597,BLOCK,-1,,"{
    start = 3;  // Skip UTF-8 BOM.
  }",68,,1077,2,,void
169633,BLOCK,-1,,"{
    char c = *p++;
    if (c == '\\' && p < pe && *p == '""') p++;
    if (c != '""') continue;
    *ppos++ = p;
    if (ppos < &pos[2]) continue;
    ppos = &pos[0];

    char* s = &pos[0][0];
    char* se = &pos[1][-1];  // Exclude quote.
    size_t n = se - s;

    if (n == 4) {
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    } else if (n == 7) {
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }
  }",18,,1088,2,,void
169653,BLOCK,-1,,<empty>,43,,1090,2,,void
169660,BLOCK,-1,,<empty>,19,,1091,2,,void
169674,BLOCK,-1,,<empty>,25,,1093,2,,void
169711,BLOCK,-1,,"{
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    }",17,,1100,2,,void
169719,BLOCK,-1,,<empty>,38,,1101,2,,void
169728,BLOCK,-1,,<empty>,38,,1102,2,,void
169737,BLOCK,-1,,<empty>,38,,1103,2,,void
169740,BLOCK,-1,,<empty>,12,,1104,1,,void
169745,BLOCK,-1,,"{
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }",24,,1104,2,,void
169753,BLOCK,-1,,<empty>,41,,1105,2,,void
169762,BLOCK,-1,,<empty>,41,,1106,2,,void
169816,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  node::Utf8Value path(env->isolate(), args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  uv_fs_t req;
  int rc = uv_fs_stat(env->event_loop(), &req, *path, nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }
  uv_fs_req_cleanup(&req);

  args.GetReturnValue().Set(rc);
}",73,,1123,2,,void
169870,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }",16,,1133,2,,void
169903,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  } else {  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
   ...",59,,1142,2,,void
169974,BLOCK,-1,,"{  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  }",34,,1156,2,,void
169983,BLOCK,1,,<empty>,,,,18,,void
169985,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1157,1,,void
170003,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1157,2,,void
170031,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1157,2,,void
170094,BLOCK,-1,,"{  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1161,1,,void
170102,BLOCK,1,,<empty>,,,,9,,void
170118,BLOCK,-1,,<empty>,5,,1164,2,,void
170120,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1164,1,,void
170138,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1164,2,,void
170166,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1164,2,,void
170212,BLOCK,1,,<empty>,,,,9,,void
170228,BLOCK,-1,,<empty>,5,,1166,2,,void
170230,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1166,1,,void
170248,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1166,2,,void
170276,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1166,2,,void
170309,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1167,2,,void
170339,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  } else {  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArr...",60,,1177,2,,void
170399,BLOCK,-1,,"{  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  }",34,,1189,2,,void
170408,BLOCK,1,,<empty>,,,,18,,void
170410,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1190,1,,void
170428,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1190,2,,void
170456,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1190,2,,void
170519,BLOCK,-1,,"{  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1194,1,,void
170527,BLOCK,1,,<empty>,,,,9,,void
170543,BLOCK,-1,,<empty>,5,,1197,2,,void
170545,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1197,1,,void
170563,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1197,2,,void
170591,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1197,2,,void
170637,BLOCK,1,,<empty>,,,,9,,void
170653,BLOCK,-1,,<empty>,5,,1200,2,,void
170655,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1200,1,,void
170673,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1200,2,,void
170701,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1200,2,,void
170734,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1201,2,,void
170764,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  } else {  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wr...",60,,1211,2,,void
170831,BLOCK,-1,,"{  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  }",34,,1223,2,,void
170839,BLOCK,1,,<empty>,,,,16,,void
170841,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1224,1,,void
170859,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1224,2,,void
170887,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1224,2,,void
170940,BLOCK,-1,,"{  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1227,1,,void
170948,BLOCK,1,,<empty>,,,,9,,void
170964,BLOCK,-1,,<empty>,5,,1230,2,,void
170966,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1230,1,,void
170984,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1230,2,,void
171012,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1230,2,,void
171057,BLOCK,1,,<empty>,,,,9,,void
171073,BLOCK,-1,,<empty>,5,,1232,2,,void
171075,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1232,1,,void
171093,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1232,2,,void
171121,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1232,2,,void
171154,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1233,2,,void
171184,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  } else {  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      r...",61,,1243,2,,void
171244,BLOCK,-1,,"{  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  }",34,,1255,2,,void
171253,BLOCK,1,,<empty>,,,,18,,void
171255,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1256,1,,void
171273,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1256,2,,void
171301,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1256,2,,void
171364,BLOCK,-1,,"{  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatFsArray(
        binding_data,
        use_bigint,
        static_cast<const uv_statfs_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1266,1,,void
171372,BLOCK,1,,<empty>,,,,9,,void
171388,BLOCK,-1,,<empty>,5,,1269,2,,void
171390,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1269,1,,void
171408,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1269,2,,void
171436,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1269,2,,void
171482,BLOCK,1,,<empty>,,,,9,,void
171498,BLOCK,-1,,<empty>,5,,1272,2,,void
171500,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1272,1,,void
171518,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1272,2,,void
171546,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1272,2,,void
171579,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1273,2,,void
171609,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue target(isolate, args[0]);
  CHECK_NOT_NULL(*target);
  auto target_view = target.ToStringView();
  // To avoid bypass the symlink target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, target_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, target_view);

  BufferValue path(isolate, args[1]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[2]->IsInt32());
  int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                        ...",62,,1285,2,,void
171716,BLOCK,-1,,"{  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))
    AsyncDestCall(env, req_wrap_async, args, ""symlink"", *path, path.length(),
                  UTF8, AfterNoArgs, uv_fs_symlink, *target, *path, flags);
  }",34,,1310,2,,void
171726,BLOCK,1,,<empty>,,,,20,,void
171728,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1311,1,,void
171746,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1311,2,,void
171774,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1311,2,,void
171855,BLOCK,-1,,"{  // symlink(target, path, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(symlink);
    SyncCall(env, args[4], &req_wrap_sync, ""symlink"",
             uv_fs_symlink, *target, *path, flags);
    FS_SYNC_TRACE_END(symlink);
  }",10,,1319,1,,void
171863,BLOCK,1,,<empty>,,,,9,,void
171879,BLOCK,-1,,<empty>,5,,1322,2,,void
171881,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1322,1,,void
171899,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1322,2,,void
171927,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1322,2,,void
171973,BLOCK,1,,<empty>,,,,9,,void
171989,BLOCK,-1,,<empty>,5,,1325,2,,void
171991,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1325,1,,void
172009,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1325,2,,void
172037,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1325,2,,void
172070,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);

  const auto src_view = src.ToStringView();
  // To avoid bypass the link target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, src_view);

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  const auto dest_view = dest.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest_view);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                 ...",59,,1329,2,,void
172162,BLOCK,-1,,"{  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""link"", *dest, dest.length(), UTF8,
                  AfterNoArgs, uv_fs_link, *src, *dest);
  }",34,,1353,2,,void
172172,BLOCK,1,,<empty>,,,,20,,void
172174,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1354,1,,void
172192,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1354,2,,void
172220,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1354,2,,void
172300,BLOCK,-1,,"{  // link(src, dest)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(link);
    SyncCall(env, args[3], &req_wrap_sync, ""link"",
             uv_fs_link, *src, *dest);
    FS_SYNC_TRACE_END(link);
  }",10,,1362,1,,void
172308,BLOCK,1,,<empty>,,,,9,,void
172324,BLOCK,-1,,<empty>,5,,1365,2,,void
172326,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1365,1,,void
172344,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1365,2,,void
172372,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1365,2,,void
172417,BLOCK,1,,<empty>,,,,9,,void
172433,BLOCK,-1,,<empty>,5,,1368,2,,void
172435,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1368,1,,void
172453,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1368,2,,void
172481,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1368,2,,void
172514,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < ...",63,,1372,2,,void
172579,BLOCK,-1,,"{  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  }",34,,1387,2,,void
172588,BLOCK,1,,<empty>,,,,18,,void
172590,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1388,1,,void
172608,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1388,2,,void
172636,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1388,2,,void
172699,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1392,1,,void
172707,BLOCK,1,,<empty>,,,,9,,void
172723,BLOCK,-1,,<empty>,5,,1395,2,,void
172725,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1395,1,,void
172743,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1395,2,,void
172771,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1395,2,,void
172817,BLOCK,1,,<empty>,,,,9,,void
172833,BLOCK,-1,,<empty>,5,,1398,2,,void
172835,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1398,1,,void
172853,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1398,2,,void
172881,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1398,2,,void
172914,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1399,2,,void
172951,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1409,2,,void
172996,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue old_path(isolate, args[0]);
  CHECK_NOT_NULL(*old_path);
  auto view_old_path = old_path.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, view_old_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, view_old_path);

  BufferValue new_path(isolate, args[1]);
  CHECK_NOT_NULL(*new_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemWrite,
      new_path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
      ...",61,,1419,2,,void
173084,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))
    AsyncDestCall(env, req_wrap_async, args, ""rename"", *new_path,
                  new_path.length(), UTF8, AfterNoArgs, uv_fs_rename,
                  *old_path, *new_path);
  }",34,,1442,2,,void
173094,BLOCK,1,,<empty>,,,,20,,void
173096,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1443,1,,void
173114,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1443,2,,void
173142,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1443,2,,void
173222,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rename);
    SyncCall(env, args[3], &req_wrap_sync, ""rename"", uv_fs_rename,
             *old_path, *new_path);
    FS_SYNC_TRACE_END(rename);
  }",10,,1452,1,,void
173230,BLOCK,1,,<empty>,,,,9,,void
173246,BLOCK,-1,,<empty>,5,,1455,2,,void
173248,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1455,1,,void
173266,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1455,2,,void
173294,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1455,2,,void
173339,BLOCK,1,,<empty>,,,,9,,void
173355,BLOCK,-1,,<empty>,5,,1458,2,,void
173357,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1458,1,,void
173375,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1458,2,,void
173403,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1458,2,,void
173436,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const int64_t len = args[1].As<Integer>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }
}",64,,1462,2,,void
173501,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  }",34,,1475,2,,void
173509,BLOCK,1,,<empty>,,,,16,,void
173511,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1476,1,,void
173529,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1476,2,,void
173557,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1476,2,,void
173611,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }",10,,1479,1,,void
173619,BLOCK,1,,<empty>,,,,9,,void
173635,BLOCK,-1,,<empty>,5,,1482,2,,void
173637,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1482,1,,void
173655,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1482,2,,void
173683,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1482,2,,void
173726,BLOCK,1,,<empty>,,,,9,,void
173742,BLOCK,-1,,<empty>,5,,1485,2,,void
173744,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1485,1,,void
173762,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1485,2,,void
173790,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1485,2,,void
173823,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }
}",64,,1489,2,,void
173871,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  }",34,,1499,2,,void
173879,BLOCK,1,,<empty>,,,,16,,void
173881,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1500,1,,void
173899,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1500,2,,void
173927,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1500,2,,void
173980,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }",10,,1503,1,,void
173988,BLOCK,1,,<empty>,,,,9,,void
174004,BLOCK,-1,,<empty>,5,,1506,2,,void
174006,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1506,1,,void
174024,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1506,2,,void
174052,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1506,2,,void
174094,BLOCK,1,,<empty>,,,,9,,void
174110,BLOCK,-1,,<empty>,5,,1508,2,,void
174112,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1508,1,,void
174130,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1508,2,,void
174158,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1508,2,,void
174191,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }
}",60,,1512,2,,void
174239,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  }",34,,1522,2,,void
174247,BLOCK,1,,<empty>,,,,16,,void
174249,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1523,1,,void
174267,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1523,2,,void
174295,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1523,2,,void
174348,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }",10,,1526,1,,void
174356,BLOCK,1,,<empty>,,,,9,,void
174372,BLOCK,-1,,<empty>,5,,1529,2,,void
174374,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1529,1,,void
174392,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1529,2,,void
174420,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1529,2,,void
174462,BLOCK,1,,<empty>,,,,9,,void
174478,BLOCK,-1,,<empty>,5,,1531,2,,void
174480,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1531,1,,void
174498,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1531,2,,void
174526,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1531,2,,void
174559,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }
}",61,,1535,2,,void
174611,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  }",34,,1547,2,,void
174620,BLOCK,1,,<empty>,,,,18,,void
174622,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1548,1,,void
174640,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1548,2,,void
174668,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1548,2,,void
174731,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }",10,,1552,1,,void
174739,BLOCK,1,,<empty>,,,,9,,void
174755,BLOCK,-1,,<empty>,5,,1555,2,,void
174757,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1555,1,,void
174775,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1555,2,,void
174803,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1555,2,,void
174846,BLOCK,1,,<empty>,,,,9,,void
174862,BLOCK,-1,,<empty>,5,,1557,2,,void
174864,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1557,1,,void
174882,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1557,2,,void
174910,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1557,2,,void
174943,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);  // rmdir(path, req)
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  } else {  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }
}",60,,1561,2,,void
174995,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  }",34,,1573,2,,void
175004,BLOCK,1,,<empty>,,,,18,,void
175006,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1574,1,,void
175024,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1574,2,,void
175052,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1574,2,,void
175115,BLOCK,-1,,"{  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }",10,,1578,1,,void
175123,BLOCK,1,,<empty>,,,,9,,void
175139,BLOCK,-1,,<empty>,5,,1581,2,,void
175141,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1581,1,,void
175159,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1581,2,,void
175187,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1581,2,,void
175230,BLOCK,1,,<empty>,,,,9,,void
175246,BLOCK,-1,,<empty>,5,,1584,2,,void
175248,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1584,1,,void
175266,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1584,2,,void
175294,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1584,2,,void
175331,BLOCK,-1,,"{
  FSReqWrapSync* req_wrap = ContainerOf(&FSReqWrapSync::req, req);

  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  while (req_wrap->continuation_data()->paths().size() > 0) {
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM...",29,,1592,6,,void
175348,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1596,2,,void
175389,BLOCK,-1,,"{
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->c...",61,,1602,2,,void
175414,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          u...",18,,1605,2,,void
175417,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          uv_fs_req_cleanup(req)...",20,,1606,2,,void
175441,BLOCK,-1,,"{
            return 0;
          }",67,,1611,2,,void
175453,BLOCK,14,,"{
          return err;
        }",24,,1618,14,,void
175458,BLOCK,17,,"{
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }",25,,1621,17,,void
175476,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",37,,1624,2,,void
175502,BLOCK,-1,,<empty>,18,,1627,1,,void
175516,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1627,2,,void
175551,BLOCK,1,,<empty>,,,,2,,void
175561,BLOCK,-1,,"{
            uv_fs_req_cleanup(req);
            if (orig_err == UV_EEXIST &&
              req_wrap->continuation_data()->paths().size() > 0) {
              return UV_ENOTDIR;
            }
            return UV_EEXIST;
          }",59,,1637,2,,void
175581,BLOCK,-1,,"{
              return UV_ENOTDIR;
            }",66,,1640,2,,void
175590,BLOCK,-1,,<empty>,24,,1645,2,,void
175606,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  // on each iteration of algorithm, mkdir directory on top of stack.
  std::string next_path = req_wrap->continuation_data()->PopPath();
  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,
                        uv_fs_callback_t{[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (r...",30,,1660,6,,void
175622,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1663,2,,void
175684,BLOCK,-1,,"{
  env->PrintSyncTrace();
  int err = MKDirpSync(env->event_loop(), &req_wrap->req, path, mode,
                       nullptr);
  if (err < 0) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }
  return err;
}",73,,1752,6,,void
175708,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }",16,,1756,2,,void
175787,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsBoolean());
  bool mkdirp = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  } else {  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = Ca...",60,,1770,2,,void
175874,BLOCK,-1,,"{  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  }",34,,1788,2,,void
175883,BLOCK,1,,<empty>,,,,18,,void
175885,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1789,1,,void
175903,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1789,2,,void
175931,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1789,2,,void
176001,BLOCK,-1,,"{  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    } else {
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
            ...",10,,1794,1,,void
176009,BLOCK,1,,<empty>,,,,9,,void
176025,BLOCK,-1,,<empty>,5,,1797,2,,void
176027,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1797,1,,void
176045,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1797,2,,void
176073,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1797,2,,void
176104,BLOCK,-1,,"{
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    }",17,,1798,2,,void
176132,BLOCK,-1,,"{
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }",69,,1801,2,,void
176176,BLOCK,-1,,"{
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }",29,,1808,2,,void
176218,BLOCK,-1,,"{
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
               uv_fs_mkdir, *path, mode);
    }",12,,1815,1,,void
176234,BLOCK,1,,<empty>,,,,9,,void
176250,BLOCK,-1,,<empty>,5,,1819,2,,void
176252,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1819,1,,void
176270,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1819,2,,void
176298,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1819,2,,void
176331,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  } else {  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info ...",63,,1823,2,,void
176385,BLOCK,-1,,"{  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  }",34,,1836,2,,void
176394,BLOCK,1,,<empty>,,,,18,,void
176396,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1837,1,,void
176414,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1837,2,,void
176442,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1837,2,,void
176505,BLOCK,-1,,"{  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1841,1,,void
176513,BLOCK,1,,<empty>,,,,9,,void
176529,BLOCK,-1,,<empty>,5,,1844,2,,void
176531,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1844,1,,void
176549,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1844,2,,void
176577,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1844,2,,void
176623,BLOCK,1,,<empty>,,,,9,,void
176639,BLOCK,-1,,<empty>,5,,1847,2,,void
176641,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1847,1,,void
176659,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1847,2,,void
176687,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1847,2,,void
176720,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1848,2,,void
176757,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1859,2,,void
176802,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  bool with_types = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  } else {  // readdir(path, encoding, withTypes, un...",62,,1869,2,,void
176876,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  }",34,,1886,2,,void
176890,BLOCK,1,,<empty>,,,,18,,void
176892,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1888,1,,void
176910,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1888,2,,void
176938,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1888,2,,void
177002,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[4], &req_wrap_sync, ""scandir"",
                       uv_fs_scandir, *path, 0 /*flags*/);
    FS_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    CHECK_GE(req_wrap_sync.req.result, 0);
    int r;
    std::vector<Local<Value>> name_v;
    std::vector<Local<Value>> type_v;

    for (;;) {
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Loc...",10,,1899,1,,void
177010,BLOCK,1,,<empty>,,,,9,,void
177026,BLOCK,-1,,<empty>,5,,1902,2,,void
177028,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1902,1,,void
177046,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1902,2,,void
177074,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1902,2,,void
177121,BLOCK,1,,<empty>,,,,9,,void
177137,BLOCK,-1,,<empty>,5,,1905,2,,void
177139,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1905,1,,void
177157,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1905,2,,void
177185,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1905,2,,void
177218,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1906,2,,void
177247,BLOCK,-1,,<empty>,5,,1915,1,,void
177248,BLOCK,4,,"{
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Local<Value> error;
      MaybeLocal<Value> filename = StringBytes::Encode(isolate,
                                                       ent.name,
                                                       encoding,
                                                       &error);

      if (filename.IsEmpty()) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }

      name_v.push_back(filename.ToLocalChecked());

      if (with_types) {
        type_v.empl...",14,,1915,4,,void
177263,BLOCK,-1,,<empty>,9,,1920,2,,void
177269,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }",19,,1921,2,,void
177349,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }",31,,1936,2,,void
177389,BLOCK,-1,,"{
        type_v.emplace_back(Integer::New(isolate, ent.type));
      }",23,,1944,2,,void
177423,BLOCK,-1,,"{
      Local<Value> result[] = {
        names,
        Array::New(isolate, type_v.data(), type_v.size())
      };
      args.GetReturnValue().Set(Array::New(isolate, result, arraysize(result)));
    }",21,,1951,2,,void
177458,BLOCK,-1,,"{
      args.GetReturnValue().Set(names);
    }",12,,1957,1,,void
177473,BLOCK,-1,,"{
  // These flags capture the intention of the open() call.
  const int rwflags = flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);

  // These flags have write-like side effects even with O_RDONLY, at least on
  // some operating systems. On Windows, for example, O_RDONLY | O_TEMPORARY
  // can be used to delete a file. Bizarre.
  const int write_as_side_effect = flags & (UV_FS_O_APPEND | UV_FS_O_CREAT |
                                            UV_FS_O_TRUNC | UV_FS_O_TEMPORARY);

  // TODO(rafaelgss): it can be optimized to avoid two permission checks
  auto pathView = path.ToStringView();
  if (rwflags != UV_FS_O_WRONLY) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }
  if (rwflags != UV_FS_O_RDONLY || write_as_side_effect) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothi...",59,,1965,4,,void
177507,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }",34,,1977,2,,void
177523,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothing<void>());
  }",58,,1984,2,,void
177539,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  } else {  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
         ...",59,,1994,2,,void
177616,BLOCK,-1,,<empty>,59,,2009,2,,void
177628,BLOCK,-1,,"{  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  }",34,,2012,2,,void
177642,BLOCK,1,,<empty>,,,,18,,void
177644,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2014,1,,void
177662,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2014,2,,void
177690,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2014,2,,void
177755,BLOCK,-1,,"{  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result >= 0) env->AddUnmanagedFd(result);
    args.GetReturnValue().Set(result);
  }",10,,2018,1,,void
177763,BLOCK,1,,<empty>,,,,9,,void
177779,BLOCK,-1,,<empty>,5,,2021,2,,void
177781,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2021,1,,void
177799,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2021,2,,void
177827,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2021,2,,void
177875,BLOCK,1,,<empty>,,,,9,,void
177891,BLOCK,-1,,<empty>,5,,2024,2,,void
177893,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2024,1,,void
177911,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2024,2,,void
177939,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2024,2,,void
177972,BLOCK,-1,,<empty>,22,,2025,2,,void
177990,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  } else {  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);...",69,,2030,2,,void
178080,BLOCK,-1,,<empty>,59,,2047,2,,void
178092,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  }",34,,2050,2,,void
178101,BLOCK,1,,<empty>,,,,18,,void
178103,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2051,1,,void
178121,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2051,2,,void
178149,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2051,2,,void
178214,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    FileHandle* fd = FileHandle::New(binding_data, result);
    if (fd == nullptr) return;
    args.GetReturnValue().Set(fd->object());
  }",10,,2055,1,,void
178222,BLOCK,1,,<empty>,,,,9,,void
178238,BLOCK,-1,,<empty>,5,,2058,2,,void
178240,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2058,1,,void
178258,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2058,2,,void
178286,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2058,2,,void
178334,BLOCK,1,,<empty>,,,,9,,void
178350,BLOCK,-1,,<empty>,5,,2061,2,,void
178352,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2061,1,,void
178370,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2061,2,,void
178398,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2061,2,,void
178431,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,2062,2,,void
178446,BLOCK,-1,,<empty>,24,,2066,2,,void
178463,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src.ToStringView());

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest.ToStringView());

  CHECK(args[2]->IsInt32());
  const int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, ar...",63,,2071,2,,void
178558,BLOCK,-1,,"{  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""copyfile"",
                  *dest, dest.length(), UTF8, AfterNoArgs,
                  uv_fs_copyfile, *src, *dest, flags);
  }",34,,2092,2,,void
178568,BLOCK,1,,<empty>,,,,20,,void
178570,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2093,1,,void
178588,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2093,2,,void
178616,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2093,2,,void
178697,BLOCK,-1,,"{  // copyFile(src, dest, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(copyfile);
    SyncCall(env, args[4], &req_wrap_sync, ""copyfile"",
             uv_fs_copyfile, *src, *dest, flags);
    FS_SYNC_TRACE_END(copyfile);
  }",10,,2102,1,,void
178705,BLOCK,1,,<empty>,,,,9,,void
178721,BLOCK,-1,,<empty>,5,,2105,2,,void
178723,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2105,1,,void
178741,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2105,2,,void
178769,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2105,2,,void
178815,BLOCK,1,,<empty>,,,,9,,void
178831,BLOCK,-1,,<empty>,5,,2108,2,,void
178833,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2108,1,,void
178851,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2108,2,,void
178879,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2108,2,,void
178912,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LE(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));
  CHECK_LE(len, buffer_length);
  CHECK_GE(off + len, off);

  const int64_t pos = GetOffset(args[4]);

  char* buf = buffer_data + off;
  uv_buf_t uvbuf = uv_buf_init(buf, len);

  FSReqBase* req_wrap_async = GetReqWrap(args, 5);
  if (r...",66,,2122,2,,void
179083,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, &uvbuf, 1, pos);
  }",34,,2154,2,,void
179091,BLOCK,1,,<empty>,,,,16,,void
179093,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2155,1,,void
179111,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2155,2,,void
179139,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2155,2,,void
179196,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[6], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2158,1,,void
179204,BLOCK,1,,<empty>,,,,9,,void
179220,BLOCK,-1,,<empty>,5,,2161,2,,void
179222,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2161,1,,void
179240,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2161,2,,void
179268,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2161,2,,void
179317,BLOCK,1,,<empty>,,,,10,,void
179333,BLOCK,-1,,<empty>,5,,2164,2,,void
179335,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2164,1,,void
179353,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2164,2,,void
179381,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2164,2,,void
179424,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> chunks = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);

  MaybeStackBuffer<uv_buf_t> iovs(chunks->Length());

  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  } else {  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWra...",67,,2177,2,,void
179498,BLOCK,-1,,<empty>,3,,2193,1,,void
179511,BLOCK,4,,"{
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }",48,,2193,4,,void
179561,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  }",34,,2200,2,,void
179569,BLOCK,1,,<empty>,,,,16,,void
179571,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2201,1,,void
179589,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2201,2,,void
179617,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2201,2,,void
179677,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[4], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2204,1,,void
179685,BLOCK,1,,<empty>,,,,9,,void
179701,BLOCK,-1,,<empty>,5,,2207,2,,void
179703,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2207,1,,void
179721,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2207,2,,void
179749,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2207,2,,void
179801,BLOCK,1,,<empty>,,,,10,,void
179817,BLOCK,-1,,<empty>,5,,2210,2,,void
179819,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2210,1,,void
179837,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2210,2,,void
179865,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2210,2,,void
179908,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);
  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  const int64_t pos = GetOffset(args[2]);

  const auto enc = ParseEncoding(isolate, args[3], UTF8);

  Local<Value> value = args[1];
  char* buf = nullptr;
  size_t len;

  FSReqBase* req_wrap_async = GetReqWrap(args, 4);
  const bool is_async = req_wrap_async != nullptr;

  // Avoid copying the string when it is externalized but only when:
  // 1. The target encoding is compatible with the string's encoding, and
  // 2. The write is synchronous, otherwise the string might get neutered
  //    while the request is in flight, and
  // 3. For UCS2, when the host system is little-endian.  Big-endian systems
  //    need to call StringBytes::Write() to ensure proper byte swapping.
  // The const_casts are conceptually sound: memory is read but not written.
  if (!is...",66,,2224,2,,void
180003,BLOCK,-1,,"{
    auto string = value.As<String>();
    if ((enc == ASCII || enc == LATIN1) && string->IsExternalOneByte()) {
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    } else if (enc == UCS2 && IsLittleEndian() && string->IsExternalTwoByte()) {
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }
  }",39,,2251,2,,void
180024,BLOCK,-1,,"{
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    }",73,,2253,2,,void
180047,BLOCK,-1,,<empty>,12,,2257,1,,void
180059,BLOCK,-1,,"{
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }",80,,2257,2,,void
180092,BLOCK,-1,,"{  // write(fd, string, pos, enc, req)
    CHECK_NOT_NULL(req_wrap_async);
    if (!StringBytes::StorageSize(isolate, value, enc).To(&len)) return;
    FSReqBase::FSReqBuffer& stack_buffer =
        req_wrap_async->Init(""write"", len, enc);
    // StorageSize may return too large a char, so correct the actual length
    // by the write size
    len = StringBytes::Write(isolate, *stack_buffer, len, args[1], enc);
    stack_buffer.SetLengthAndZeroTerminate(len);
    uv_buf_t uvbuf = uv_buf_init(*stack_buffer, len);
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    int err = req_wrap_async->Dispatch(uv_fs_write,
                                       fd,
                                       &uvbuf,
                                       1,
                                       pos,
                                       AfterInteger);
    if (err < 0) {
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger...",17,,2264,2,,void
180109,BLOCK,-1,,<empty>,66,,2266,2,,void
180154,BLOCK,1,,<empty>,,,,16,,void
180156,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2274,1,,void
180174,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2274,2,,void
180202,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2274,2,,void
180263,BLOCK,-1,,"{
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger(uv_req);  // after may delete req_wrap_async if there is
                             // an error
    }",18,,2281,2,,void
180284,BLOCK,-1,,"{
      req_wrap_async->SetReturnValue(args);
    }",12,,2287,1,,void
180291,BLOCK,-1,,"{  // write(fd, string, pos, enc, undefined, ctx)
    CHECK_EQ(argc, 6);
    FSReqWrapSync req_wrap_sync;
    FSReqBase::FSReqBuffer stack_buffer;
    if (buf == nullptr) {
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }
    uv_buf_t uvbuf = uv_buf_init(buf, len);
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[5], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2290,1,,void
180301,BLOCK,-1,,"{
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }",25,,2294,2,,void
180316,BLOCK,-1,,<empty>,9,,2296,2,,void
180357,BLOCK,1,,<empty>,,,,9,,void
180373,BLOCK,-1,,<empty>,5,,2306,2,,void
180375,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2306,1,,void
180393,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2306,2,,void
180421,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2306,2,,void
180470,BLOCK,1,,<empty>,,,,10,,void
180486,BLOCK,-1,,<empty>,5,,2309,2,,void
180488,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2309,1,,void
180506,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2309,2,,void
180534,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2309,2,,void
180577,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 5);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LT(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));

  CHECK(IsSafeJsInt(args[4]) || args[4]->IsBigInt());
  const int64_t pos = args[4]->IsNumber() ?
                      args[4].As<Integer>()->Value() :
                      args[4].As<BigInt>()->Int64Value();

  char* buf = buffer_data...",59,,2326,2,,void
180773,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, &uvbuf, 1, pos);
  }",34,,2359,2,,void
180781,BLOCK,1,,<empty>,,,,16,,void
180783,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2360,1,,void
180801,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2360,2,,void
180829,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2360,2,,void
180886,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, ""read"",
                                   uv_fs_read, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2363,1,,void
180894,BLOCK,1,,<empty>,,,,9,,void
180910,BLOCK,-1,,<empty>,5,,2366,2,,void
180912,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2366,1,,void
180930,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2366,2,,void
180958,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2366,2,,void
181007,BLOCK,1,,<empty>,,,,10,,void
181023,BLOCK,-1,,<empty>,5,,2369,2,,void
181025,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2369,1,,void
181043,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2369,2,,void
181071,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2369,2,,void
181114,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> buffers = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);  // -1 if not a valid JS int

  MaybeStackBuffer<uv_buf_t> iovs(buffers->Length());

  // Init uv buffers from ArrayBufferViews
  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  } else {  // readB...",66,,2382,2,,void
181188,BLOCK,-1,,<empty>,3,,2399,1,,void
181201,BLOCK,4,,"{
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }",48,,2399,4,,void
181251,BLOCK,-1,,"{  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  }",34,,2406,2,,void
181259,BLOCK,1,,<empty>,,,,16,,void
181261,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2407,1,,void
181279,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2407,2,,void
181307,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2407,2,,void
181367,BLOCK,-1,,"{  // readBuffers(fd, buffers, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    int bytesRead = SyncCall(env, /* ctx */ args[4], &req_wrap_sync, ""read"",
                             uv_fs_read, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2410,1,,void
181375,BLOCK,1,,<empty>,,,,9,,void
181391,BLOCK,-1,,<empty>,5,,2413,2,,void
181393,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2413,1,,void
181411,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2413,2,,void
181439,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2413,2,,void
181491,BLOCK,1,,<empty>,,,,10,,void
181507,BLOCK,-1,,<empty>,5,,2416,2,,void
181509,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2416,1,,void
181527,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2416,2,,void
181555,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2416,2,,void
181598,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  } else {  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }
}",60,,2425,2,,void
181669,BLOCK,-1,,"{  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  }",34,,2440,2,,void
181678,BLOCK,1,,<empty>,,,,18,,void
181680,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2441,1,,void
181698,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2441,2,,void
181726,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2441,2,,void
181790,BLOCK,-1,,"{  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }",10,,2445,1,,void
181798,BLOCK,1,,<empty>,,,,9,,void
181814,BLOCK,-1,,<empty>,5,,2448,2,,void
181816,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2448,1,,void
181834,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2448,2,,void
181862,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2448,2,,void
181906,BLOCK,1,,<empty>,,,,9,,void
181922,BLOCK,-1,,<empty>,5,,2451,2,,void
181924,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2451,1,,void
181942,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2451,2,,void
181970,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2451,2,,void
182003,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  } else {  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }
}",61,,2459,2,,void
182070,BLOCK,-1,,"{  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  }",34,,2472,2,,void
182078,BLOCK,1,,<empty>,,,,16,,void
182080,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2473,1,,void
182098,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2473,2,,void
182126,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2473,2,,void
182180,BLOCK,-1,,"{  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }",10,,2476,1,,void
182188,BLOCK,1,,<empty>,,,,9,,void
182204,BLOCK,-1,,<empty>,5,,2479,2,,void
182206,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2479,1,,void
182224,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2479,2,,void
182252,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2479,2,,void
182295,BLOCK,1,,<empty>,,,,9,,void
182311,BLOCK,-1,,<empty>,5,,2482,2,,void
182313,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2482,1,,void
182331,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2482,2,,void
182359,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2482,2,,void
182392,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  } else {  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCal...",60,,2490,2,,void
182482,BLOCK,-1,,"{  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  }",34,,2508,2,,void
182491,BLOCK,1,,<empty>,,,,18,,void
182493,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2509,1,,void
182511,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2509,2,,void
182539,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2509,2,,void
182604,BLOCK,-1,,"{  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCall(env, args[4], &req_wrap_sync, ""chown"",
             uv_fs_chown, *path, uid, gid);
    FS_SYNC_TRACE_END(chown);
  }",10,,2513,1,,void
182612,BLOCK,1,,<empty>,,,,9,,void
182628,BLOCK,-1,,<empty>,5,,2516,2,,void
182630,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2516,1,,void
182648,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2516,2,,void
182676,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2516,2,,void
182721,BLOCK,1,,<empty>,,,,9,,void
182737,BLOCK,-1,,<empty>,5,,2519,2,,void
182739,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2519,1,,void
182757,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2519,2,,void
182785,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2519,2,,void
182818,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  } else {  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }
}",61,,2527,2,,void
182904,BLOCK,-1,,"{  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  }",34,,2543,2,,void
182912,BLOCK,1,,<empty>,,,,16,,void
182914,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2544,1,,void
182932,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2544,2,,void
182960,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2544,2,,void
183015,BLOCK,-1,,"{  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }",10,,2547,1,,void
183023,BLOCK,1,,<empty>,,,,9,,void
183039,BLOCK,-1,,<empty>,5,,2550,2,,void
183041,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2550,1,,void
183059,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2550,2,,void
183087,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2550,2,,void
183131,BLOCK,1,,<empty>,,,,9,,void
183147,BLOCK,-1,,<empty>,5,,2553,2,,void
183149,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2553,1,,void
183167,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2553,2,,void
183195,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2553,2,,void
183228,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  } else {  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    S...",61,,2558,2,,void
183318,BLOCK,-1,,"{  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  }",34,,2576,2,,void
183327,BLOCK,1,,<empty>,,,,18,,void
183329,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2577,1,,void
183347,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2577,2,,void
183375,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2577,2,,void
183440,BLOCK,-1,,"{  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    SyncCall(env, args[4], &req_wrap_sync, ""lchown"",
             uv_fs_lchown, *path, uid, gid);
    FS_SYNC_TRACE_END(lchown);
  }",10,,2581,1,,void
183448,BLOCK,1,,<empty>,,,,9,,void
183464,BLOCK,-1,,<empty>,5,,2584,2,,void
183466,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2584,1,,void
183484,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2584,2,,void
183512,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2584,2,,void
183557,BLOCK,1,,<empty>,,,,9,,void
183573,BLOCK,-1,,<empty>,5,,2587,2,,void
183575,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2587,1,,void
183593,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2587,2,,void
183621,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2587,2,,void
183654,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  } else {  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""ut...",61,,2592,2,,void
183744,BLOCK,-1,,"{  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  }",34,,2610,2,,void
183753,BLOCK,1,,<empty>,,,,18,,void
183755,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2611,1,,void
183773,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2611,2,,void
183801,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2611,2,,void
183866,BLOCK,-1,,"{  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""utime"",
             uv_fs_utime, *path, atime, mtime);
    FS_SYNC_TRACE_END(utimes);
  }",10,,2615,1,,void
183874,BLOCK,1,,<empty>,,,,9,,void
183890,BLOCK,-1,,<empty>,5,,2618,2,,void
183892,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2618,1,,void
183910,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2618,2,,void
183938,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2618,2,,void
183983,BLOCK,1,,<empty>,,,,9,,void
183999,BLOCK,-1,,<empty>,5,,2621,2,,void
184001,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2621,1,,void
184019,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2621,2,,void
184047,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2621,2,,void
184080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  } else {  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }
}",62,,2625,2,,void
184166,BLOCK,-1,,"{  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  }",34,,2641,2,,void
184174,BLOCK,1,,<empty>,,,,16,,void
184176,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2642,1,,void
184194,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2642,2,,void
184222,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2642,2,,void
184277,BLOCK,-1,,"{  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }",10,,2645,1,,void
184285,BLOCK,1,,<empty>,,,,9,,void
184301,BLOCK,-1,,<empty>,5,,2648,2,,void
184303,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2648,1,,void
184321,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2648,2,,void
184349,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2648,2,,void
184393,BLOCK,1,,<empty>,,,,9,,void
184409,BLOCK,-1,,<empty>,5,,2651,2,,void
184411,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2651,1,,void
184429,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2651,2,,void
184457,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2651,2,,void
184490,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  } else {  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_syn...",62,,2655,2,,void
184580,BLOCK,-1,,"{  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  }",34,,2673,2,,void
184589,BLOCK,1,,<empty>,,,,18,,void
184591,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2674,1,,void
184609,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2674,2,,void
184637,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2674,2,,void
184702,BLOCK,-1,,"{  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_sync, ""lutime"",
             uv_fs_lutime, *path, atime, mtime);
    FS_SYNC_TRACE_END(lutimes);
  }",10,,2678,1,,void
184710,BLOCK,1,,<empty>,,,,9,,void
184726,BLOCK,-1,,<empty>,5,,2681,2,,void
184728,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2681,1,,void
184746,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2681,2,,void
184774,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2681,2,,void
184819,BLOCK,1,,<empty>,,,,9,,void
184835,BLOCK,-1,,<empty>,5,,2684,2,,void
184837,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2684,1,,void
184855,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2684,2,,void
184883,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2684,2,,void
184916,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue tmpl(isolate, args[0]);
  CHECK_NOT_NULL(*tmpl);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, tmpl.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  } else {  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtem...",62,,2688,2,,void
184981,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  }",34,,2703,2,,void
184990,BLOCK,1,,<empty>,,,,18,,void
184992,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2704,1,,void
185010,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2704,2,,void
185038,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2704,2,,void
185101,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtemp);
    const char* path = req_wrap_sync.req.path;

    Local<Value> error;
    MaybeLocal<Value> rc =
        StringBytes::Encode(isolate, path, encoding, &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }
    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,2708,1,,void
185109,BLOCK,1,,<empty>,,,,9,,void
185125,BLOCK,-1,,<empty>,5,,2711,2,,void
185127,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2711,1,,void
185145,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2711,2,,void
185173,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2711,2,,void
185216,BLOCK,1,,<empty>,,,,9,,void
185232,BLOCK,-1,,<empty>,5,,2714,2,,void
185234,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2714,1,,void
185252,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2714,2,,void
185280,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2714,2,,void
185342,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,2720,2,,void
185387,BLOCK,-1,,"{
  tracker->TrackField(""stats_field_array"", stats_field_array);
  tracker->TrackField(""stats_field_bigint_array"", stats_field_bigint_array);
  tracker->TrackField(""statfs_field_array"", statfs_field_array);
  tracker->TrackField(""statfs_field_bigint_array"", statfs_field_bigint_array);
  tracker->TrackField(""file_handle_read_wrap_freelist"",
                      file_handle_read_wrap_freelist);
}",60,,2729,2,,void
185424,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();

  if (info == nullptr) {
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  } else {
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }
  stats_field_array...",61,,2754,4,,void
185446,BLOCK,-1,,"{
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  }",24,,2758,2,,void
185508,BLOCK,-1,,"{
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }",10,,2778,1,,void
185564,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,2793,5,,void
185611,BLOCK,-1,,"{
  CHECK(file_handle_read_wrap_freelist.empty());
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->stats_field_array =
      stats_field_array.Serialize(context, creator);
  internal_field_info_->stats_field_bigint_array =
      stats_field_bigint_array.Serialize(context, creator);
  internal_field_info_->statfs_field_array =
      statfs_field_array.Serialize(context, creator);
  internal_field_info_->statfs_field_bigint_array =
      statfs_field_bigint_array.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,2804,3,,void
185673,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,2821,2,,void
185693,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""access"", Access);
  SetMethod(isolate, target, ""close"", Close);
  SetMethod(isolate, target, ""open"", Open);
  SetMethod(isolate, target, ""openFileHandle"", OpenFileHandle);
  SetMethod(isolate, target, ""read"", Read);
  SetMethod(isolate, target, ""readBuffers"", ReadBuffers);
  SetMethod(isolate, target, ""fdatasync"", Fdatasync);
  SetMethod(isolate, target, ""fsync"", Fsync);
  SetMethod(isolate, target, ""rename"", Rename);
  SetMethod(isolate, target, ""ftruncate"", FTruncate);
  SetMethod(isolate, target, ""rmdir"", RMDir);
  SetMethod(isolate, target, ""mkdir"", MKDir);
  SetMethod(isolate, target, ""readdir"", ReadDir);
  SetMethod(isolate, target, ""internalModuleReadJSON"", InternalModuleReadJSON);
  SetMethod(isolate, target, ""internalModuleStat"", InternalModuleStat);
  SetMethod(isolate, target, ""stat"", Stat);
  SetMethod(isolate, target, ""lstat"", LStat);
  SetMethod(isolate, target, ""fstat"", FStat);
  SetMethod(...",70,,2829,3,,void
186183,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,2935,5,,void
186205,BLOCK,-1,,"{
  return binding_data_.get();
}",40,,2940,1,,void
186215,BLOCK,-1,,"{
  registry->Register(Access);
  StatWatcher::RegisterExternalReferences(registry);

  registry->Register(Close);
  registry->Register(Open);
  registry->Register(OpenFileHandle);
  registry->Register(Read);
  registry->Register(ReadBuffers);
  registry->Register(Fdatasync);
  registry->Register(Fsync);
  registry->Register(Rename);
  registry->Register(FTruncate);
  registry->Register(RMDir);
  registry->Register(MKDir);
  registry->Register(ReadDir);
  registry->Register(InternalModuleReadJSON);
  registry->Register(InternalModuleStat);
  registry->Register(Stat);
  registry->Register(LStat);
  registry->Register(FStat);
  registry->Register(StatFs);
  registry->Register(Link);
  registry->Register(Symlink);
  registry->Register(ReadLink);
  registry->Register(Unlink);
  registry->Register(WriteBuffer);
  registry->Register(WriteBuffers);
  registry->Register(WriteString);
  registry->Register(RealPath);
  registry->Register(CopyFile);

  registry->Register(Chmod);
  registry->Re...",70,,2944,2,,void
186454,BLOCK,-1,,<empty>,1,,1,1,,ANY
186458,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,646,2,,void
186462,BLOCK,-1,,<empty>,7,,648,2,,void
186474,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,666,2,,void
186478,BLOCK,-1,,<empty>,7,,668,2,,void
186489,BLOCK,-1,,"{
          ping->Done(false);
        }",52,,718,2,,void
186501,BLOCK,-1,,"{
    headers_v[i * 2] = header.GetName(this).ToLocalChecked();
    headers_v[i * 2 + 1] = header.GetValue(this).ToLocalChecked();
    if (header.flags() & NGHTTP2_NV_FLAG_NO_INDEX)
      sensitive_v[sensitive_count++] = headers_v[i * 2];
  }",68,,1352,3,,void
186539,BLOCK,-1,,<empty>,7,,1356,2,,void
186558,BLOCK,-1,,"{
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    }",62,,1628,2,,void
186565,BLOCK,-1,,"{
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }",47,,1629,2,,void
186572,BLOCK,-1,,"{
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }",36,,1638,2,,void
186588,BLOCK,-1,,"{
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    }",27,,2141,2,,void
186595,BLOCK,-1,,"{
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }",31,,2145,2,,void
186607,BLOCK,-1,,<empty>,11,,2148,2,,void
186634,BLOCK,-1,,"{
        // Delete once strong_ref goes out of scope.
        Detach();
      }",57,,2156,2,,void
186641,BLOCK,-1,,"{
    return code == NGHTTP2_CANCEL;
  }",51,,2275,2,,void
186690,BLOCK,-1,,<empty>,1,,1,1,,ANY
186700,BLOCK,-1,,"{
  AliasedUint32Array& observers = env->performance_state()->observers;
  return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;
}",41,,54,2,,void
186730,BLOCK,-1,,<empty>,77,,79,2,,void
186735,BLOCK,-1,,"{
  if (!session_) return;

  // If there is another scope further below on the stack, or
  // a write is already scheduled, there's nothing to do.
  if (session_->is_in_scope() || session_->is_write_scheduled()) {
    session_.reset();
    return;
  }
  session_->set_in_scope();
}",67,,81,2,,void
186739,BLOCK,-1,,<empty>,18,,82,2,,void
186751,BLOCK,-1,,"{
    session_.reset();
    return;
  }",66,,86,2,,void
186764,BLOCK,-1,,"{
  if (!session_) return;
  session_->set_in_scope(false);
  if (!session_->is_write_scheduled())
    session_->MaybeScheduleWrite();
}",27,,93,1,,void
186768,BLOCK,-1,,<empty>,18,,94,2,,void
186781,BLOCK,-1,,<empty>,5,,97,2,,void
186791,BLOCK,-1,,"{
  nghttp2_option* option;
  CHECK_EQ(nghttp2_option_new(&option), 0);
  CHECK_NOT_NULL(option);
  options_.reset(option);

  // Make sure closed connections aren't kept around, taking up memory.
  // Note that this breaks the priority tree, which we don't use.
  nghttp2_option_set_no_closed_streams(option, 1);

  // We manually handle flow control within a session in order to
  // implement backpressure -- that is, we only send WINDOW_UPDATE
  // frames to the remote peer as data is actually consumed by user
  // code. This ensures that the flow of data over the connection
  // does not move too quickly and limits the amount of data we
  // are required to buffer.
  nghttp2_option_set_no_auto_window_update(option, 1);

  // Enable built in support for receiving ALTSVC and ORIGIN frames (but
  // only on client side sessions
  if (type == NGHTTP2_SESSION_CLIENT) {
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extensi...",71,,104,3,,void
186815,BLOCK,-1,,"{
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ORIGIN);
  }",39,,124,2,,void
186840,BLOCK,-1,,"{
    nghttp2_option_set_max_deflate_dynamic_table_size(
        option,
        buffer[IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE]);
  }",66,,132,2,,void
186852,BLOCK,-1,,"{
    nghttp2_option_set_max_reserved_remote_streams(
        option,
        buffer[IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS]);
  }",63,,138,2,,void
186864,BLOCK,-1,,"{
    nghttp2_option_set_max_send_header_block_length(
        option,
        buffer[IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH]);
  }",64,,144,2,,void
186879,BLOCK,-1,,"{
    nghttp2_option_set_peer_max_concurrent_streams(
        option,
        buffer[IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS]);
  }",63,,152,2,,void
186891,BLOCK,-1,,"{
    PaddingStrategy strategy =
        static_cast<PaddingStrategy>(
            buffer.GetValue(IDX_OPTIONS_PADDING_STRATEGY));
    set_padding_strategy(strategy);
  }",52,,162,2,,void
186910,BLOCK,-1,,<empty>,5,,174,2,,void
186921,BLOCK,-1,,<empty>,5,,182,2,,void
186932,BLOCK,-1,,<empty>,5,,190,2,,void
186943,BLOCK,-1,,<empty>,5,,201,2,,void
186958,BLOCK,-1,,"{
    nghttp2_option_set_max_settings(
        option,
        static_cast<size_t>(buffer[IDX_OPTIONS_MAX_SETTINGS]));
  }",48,,204,2,,void
186971,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = buffer[IDX_SETTINGS_COUNT];

  size_t count = 0;

#define V(name) GRABSETTING(entries, count, name);
  HTTP2_SETTINGS(V)
#undef V

  return count;
}",38,,221,3,,void
186999,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
  count_ = Init(session->http2_state(), entries_);
}",30,,244,5,,void
187020,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",49,,249,1,,void
187034,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",62,,253,2,,void
187044,BLOCK,-1,,"{
  return Pack(session_->env(), count_, entries_);
}",36,,260,1,,void
187057,BLOCK,-1,,"{
  nghttp2_settings_entry entries[IDX_SETTINGS_COUNT];
  size_t count = Init(state, entries);
  return Pack(state->env(), count, entries);
}",53,,264,2,,void
187079,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }
  if (nghttp2_pack_settings_payload(static_cast<uint8_t*>(bs->Data()),
                                    bs->ByteLength(),
                                    entries,
                                    count) < 0) {
    return scope.Escape(Undefined(env->isolate()));
  }
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return scope.Escape(Buffer::New(env, ab, 0, ab->ByteLength())
                          .FromMaybe(Local<Value>()));
}",44,,273,4,,void
187093,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }",3,,276,4,,void
187129,BLOCK,-1,,"{
    return scope.Escape(Undefined(env->isolate()));
  }",49,,283,2,,void
187184,BLOCK,-1,,"{
  AliasedUint32Array& buffer = session->http2_state()->settings_buffer;

#define V(name)                                                                \
  buffer[IDX_SETTINGS_ ## name] =                                              \
      fn(session->session(), NGHTTP2_SETTINGS_ ## name);
  HTTP2_SETTINGS(V)
#undef V
}",67,,293,3,,void
187200,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = 0;

#define V(name)                                                            \
  do {                                                                     \
    buffer[IDX_SETTINGS_ ## name] = DEFAULT_SETTINGS_ ## name;             \
    flags |= 1 << IDX_SETTINGS_ ## name;                                   \
  } while (0);
  HTTP2_SETTINGS(V)
#undef V

  buffer[IDX_SETTINGS_COUNT] = flags;
}",62,,304,2,,void
187221,BLOCK,-1,,"{
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_settings(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      &entries_[0],
      count_), 0);
}",28,,320,1,,void
187245,BLOCK,-1,,"{
  uint64_t end = uv_hrtime();
  double duration = (end - startTime_) / 1e6;

  Local<Value> argv[] = {Boolean::New(env()->isolate(), ack),
                         Number::New(env()->isolate(), duration)};
  MakeCallback(callback(), arraysize(argv), argv);
}",36,,329,2,,void
187292,BLOCK,-1,,"{
  Local<Context> context = env->context();
  int32_t parent_ = parent->Int32Value(context).ToChecked();
  int32_t weight_ = weight->Int32Value(context).ToChecked();
  bool exclusive_ = exclusive->IsTrue();
  Debug(env, DebugCategory::HTTP2STREAM,
        ""Http2Priority: parent: %d, weight: %d, exclusive: %s\n"",
        parent_, weight_, exclusive_ ? ""yes"" : ""no"");
  nghttp2_priority_spec_init(this, parent_, weight_, exclusive_ ? 1 : 0);
}",54,,344,5,,void
187355,BLOCK,-1,,"{
  switch (session_type_) {
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }
}",44,,356,1,,void
187358,BLOCK,-1,,"{
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }",26,,357,2,,void
187375,BLOCK,-1,,"{
  int origin_string_len = origin_string->Length();
  if (count_ == 0) {
    CHECK_EQ(origin_string_len, 0);
    return;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }

  // Make sure the start address is aligned appropriately for an nghttp2_nv*.
  char* start = AlignUp(static_cast<char*>(bs_->Data()),
                        alignof(nghttp2_origin_entry));
  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));
  nghttp2_origin_entry* const nva =
      reinterpret_cast<nghttp2_origin_entry*>(start);

  CHECK_LE(origin_contents + origin_string_len,
           static_cast<char*>(bs_->Data()) + bs_->ByteLength());
  CHECK_EQ(origin_string->WriteOneByte(
           ...",28,,370,4,,void
187387,BLOCK,-1,,"{
    CHECK_EQ(origin_string_len, 0);
    return;
  }",20,,372,2,,void
187392,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }",3,,377,4,,void
187486,BLOCK,-1,,<empty>,3,,404,1,,void
187497,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }

    nva[n].origin = reinterpret_cast<uint8_t*>(p);
    nva[n].origin_len = strlen(p);
    p += nva[n].origin_len + 1;
  }",75,,404,4,,void
187502,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }",22,,405,2,,void
187556,BLOCK,-1,,"{
  nghttp2_session_callbacks* callbacks_;
  CHECK_EQ(nghttp2_session_callbacks_new(&callbacks_), 0);
  callbacks.reset(callbacks_);

  nghttp2_session_callbacks_set_on_begin_headers_callback(
    callbacks_, OnBeginHeadersCallback);
  nghttp2_session_callbacks_set_on_header_callback2(
    callbacks_, OnHeaderCallback);
  nghttp2_session_callbacks_set_on_frame_recv_callback(
    callbacks_, OnFrameReceive);
  nghttp2_session_callbacks_set_on_stream_close_callback(
    callbacks_, OnStreamClose);
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
    callbacks_, OnDataChunkReceived);
  nghttp2_session_callbacks_set_on_frame_not_send_callback(
    callbacks_, OnFrameNotSent);
  nghttp2_session_callbacks_set_on_invalid_header_callback2(
    callbacks_, OnInvalidHeader);
  nghttp2_session_callbacks_set_error_callback2(callbacks_, OnNghttpError);
  nghttp2_session_callbacks_set_send_data_callback(
    callbacks_, OnSendData);
  nghttp2_session_callbacks_set_on_invalid_frame_rec...",65,,421,2,,void
187603,BLOCK,-1,,"{
    nghttp2_session_callbacks_set_select_padding_callback(
      callbacks_, OnSelectPadding);
  }",31,,448,2,,void
187611,BLOCK,-1,,"{
  StopTrackingMemory(buf);
}",58,,454,2,,void
187618,BLOCK,-1,,"{
  CHECK_GE(current_nghttp2_memory_, previous_size);
}",67,,458,2,,void
187626,BLOCK,-1,,"{
  current_nghttp2_memory_ += size;
}",55,,462,2,,void
187634,BLOCK,-1,,"{
  current_nghttp2_memory_ -= size;
}",55,,466,2,,void
187644,BLOCK,-1,,"{
  MakeWeak();
  statistics_.session_type = type;
  statistics_.start_time = uv_hrtime();

  // Capture the configuration options for this session
  Http2Options opts(http2_state, type);

  max_session_memory_ = opts.max_session_memory();

  uint32_t maxHeaderPairs = opts.max_header_pairs();
  max_header_pairs_ =
      type == NGHTTP2_SESSION_SERVER
          ? GetServerMaxHeaderPairs(maxHeaderPairs)
          : GetClientMaxHeaderPairs(maxHeaderPairs);

  max_outstanding_pings_ = opts.max_outstanding_pings();
  max_outstanding_settings_ = opts.max_outstanding_settings();

  padding_strategy_ = opts.padding_strategy();

  bool hasGetPaddingCallback =
      padding_strategy_ != PADDING_STRATEGY_NONE;

  auto fn = type == NGHTTP2_SESSION_SERVER ?
      nghttp2_session_server_new3 :
      nghttp2_session_client_new3;

  nghttp2_mem alloc_info = MakeAllocator();

  // This should fail only if the system is out of memory, which
  // is going to cause lots of other problems anyway, or if ...",33,,476,4,,void
187790,BLOCK,-1,,"{
  CHECK(!is_in_scope());
  Debug(this, ""freeing nghttp2 session"");
  // Explicitly reset session_ so the subsequent
  // current_nghttp2_memory_ check passes.
  session_.reset();
  CHECK_EQ(current_nghttp2_memory_, 0);
}",31,,528,1,,void
187808,BLOCK,-1,,"{
  tracker->TrackField(""streams"", streams_);
  tracker->TrackField(""outstanding_pings"", outstanding_pings_);
  tracker->TrackField(""outstanding_settings"", outstanding_settings_);
  tracker->TrackField(""outgoing_buffers"", outgoing_buffers_);
  tracker->TrackFieldWithSize(""stream_buf"", stream_buf_.len);
  tracker->TrackFieldWithSize(""outgoing_storage"", outgoing_storage_.size());
  tracker->TrackFieldWithSize(""pending_rst_streams"",
                              pending_rst_streams_.size() * sizeof(int32_t));
  tracker->TrackFieldWithSize(""nghttp2_memory"", current_nghttp2_memory_);
}",61,,537,2,,void
187871,BLOCK,-1,,"{
  return std::string(""Http2Session "") + TypeName() + "" ("" +
      std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
}",51,,549,1,,void
187897,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_read_string, received_bytes)
  SET(bytes_written_string, sent_bytes)
  SET(id_string, id)
#undef SET

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env-...",47,,556,3,,void
187913,BLOCK,1,,<empty>,,,,1,,void
187946,BLOCK,-1,,"SET(bytes_read_string, received_bytes)",3,,569,2,,void
187950,BLOCK,1,,<empty>,,,,1,,void
187983,BLOCK,-1,,"SET(bytes_written_string, sent_bytes)",3,,570,2,,void
187987,BLOCK,1,,<empty>,,,,1,,void
188020,BLOCK,-1,,"SET(id_string, id)",3,,571,2,,void
188024,BLOCK,1,,<empty>,,,,1,,void
188063,BLOCK,-1,,"SET(time_to_first_byte_string, first_byte)",3,,585,2,,void
188067,BLOCK,1,,<empty>,,,,1,,void
188106,BLOCK,-1,,"SET(time_to_first_byte_sent_string, first_byte_sent)",3,,586,2,,void
188110,BLOCK,1,,<empty>,,,,1,,void
188149,BLOCK,-1,,"SET(time_to_first_header_string, first_header)",3,,587,2,,void
188159,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_written_string, data_sent)
  SET(bytes_read_string, data_received)
  SET(frames_received_string, frame_count)
  SET(frames_sent_string, frame_sent)
  SET(max_concurrent_streams_string, max_concurrent_streams)
  SET(ping_rtt_string, ping_rtt)
  SET(stream_average_duration_string...",48,,595,3,,void
188175,BLOCK,1,,<empty>,,,,1,,void
188208,BLOCK,-1,,"SET(bytes_written_string, data_sent)",3,,608,2,,void
188212,BLOCK,1,,<empty>,,,,1,,void
188245,BLOCK,-1,,"SET(bytes_read_string, data_received)",3,,609,2,,void
188249,BLOCK,1,,<empty>,,,,1,,void
188282,BLOCK,-1,,"SET(frames_received_string, frame_count)",3,,610,2,,void
188286,BLOCK,1,,<empty>,,,,1,,void
188319,BLOCK,-1,,"SET(frames_sent_string, frame_sent)",3,,611,2,,void
188323,BLOCK,1,,<empty>,,,,1,,void
188356,BLOCK,-1,,"SET(max_concurrent_streams_string, max_concurrent_streams)",3,,612,2,,void
188360,BLOCK,1,,<empty>,,,,1,,void
188393,BLOCK,-1,,"SET(ping_rtt_string, ping_rtt)",3,,613,2,,void
188397,BLOCK,1,,<empty>,,,,1,,void
188430,BLOCK,-1,,"SET(stream_average_duration_string, stream_average_duration)",3,,614,2,,void
188434,BLOCK,1,,<empty>,,,,1,,void
188467,BLOCK,-1,,"SET(stream_count_string, stream_count)",3,,615,2,,void
188502,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",53,,623,2,,void
188510,BLOCK,-1,,"{
  CHECK_NOT_NULL(session());
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2StreamPerformanceEntry> entry =
      std::make_unique<Http2StreamPerformanceEntry>(
          ""Http2Stream"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",36,,631,1,,void
188517,BLOCK,-1,,<empty>,5,,634,2,,void
188570,BLOCK,-1,,"{
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2SessionPerformanceEntry> entry =
      std::make_unique<Http2SessionPerformanceEntry>(
          ""Http2Session"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",37,,652,1,,void
188576,BLOCK,-1,,<empty>,5,,654,2,,void
188631,BLOCK,-1,,"{
  Debug(this, ""closing session"");

  if (is_closing())
    return;
  set_closing();

  // Stop reading on the i/o stream
  if (stream_ != nullptr) {
    set_reading_stopped();
    stream_->ReadStop();
  }

  // If the socket is not closed, then attempt to send a closing GOAWAY
  // frame. There is no guarantee that this GOAWAY will be received by
  // the peer but the HTTP/2 spec recommends sending it anyway. We'll
  // make a best effort.
  if (!socket_closed) {
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  } else if (stream_ != nullptr) {
    stream_->RemoveStreamListener(this);
  }

  set_destroyed();

  // If we are writing we will get to make the callback in OnStreamAfterWrite.
  if (!is_write_in_progress()) {
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ ...",61,,673,3,,void
188637,BLOCK,-1,,<empty>,5,,677,2,,void
188644,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",27,,681,2,,void
188653,BLOCK,-1,,"{
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  }",23,,690,2,,void
188668,BLOCK,-1,,<empty>,10,,694,1,,void
188673,BLOCK,-1,,"{
    stream_->RemoveStreamListener(this);
  }",34,,694,2,,void
188683,BLOCK,-1,,"{
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
  }",32,,701,2,,void
188704,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,705,2,,void
188719,BLOCK,-1,,"{
    ping->DetachFromSession();
    env()->SetImmediate(
        [ping = std::move(ping)](Environment* env) {
          ping->Done(false);
        });
  }",53,,715,2,,void
188739,BLOCK,-1,,"{
  auto s = streams_.find(id);
  return s != streams_.end() ? s->second : BaseObjectPtr<Http2Stream>();
}",65,,729,2,,void
188763,BLOCK,-1,,"{
  uint32_t maxConcurrentStreams =
      nghttp2_session_get_local_settings(
          session_.get(), NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
  size_t maxSize =
      std::min(streams_.max_size(), static_cast<size_t>(maxConcurrentStreams));
  // We can add a new stream so long as we are less than the current
  // maximum on concurrent streams and there's enough available memory
  return streams_.size() < maxSize &&
         has_available_session_memory(sizeof(Http2Stream));
}",35,,734,1,,void
188802,BLOCK,-1,,"{
  CHECK_GE(++statistics_.stream_count, 0);
  streams_[stream->id()] = BaseObjectPtr<Http2Stream>(stream);
  size_t size = streams_.size();
  if (size > statistics_.max_concurrent_streams)
    statistics_.max_concurrent_streams = size;
  IncrementCurrentSessionMemory(sizeof(*stream));
}",51,,746,2,,void
188834,BLOCK,-1,,<empty>,5,,751,2,,void
188848,BLOCK,-1,,"{
  BaseObjectPtr<Http2Stream> stream;
  if (streams_.empty())
    return stream;
  stream = FindStream(id);
  if (stream) {
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }
  return stream;
}",67,,756,2,,void
188859,BLOCK,-1,,<empty>,5,,759,2,,void
188868,BLOCK,-1,,"{
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }",15,,761,2,,void
188885,BLOCK,-1,,"{
  size_t r = (frameLen + 9) % 8;
  if (r == 0) return frameLen;  // If already a multiple of 8, return.

  size_t pad = frameLen + (8 - r);

  // If maxPayloadLen happens to be less than the calculated pad length,
  // use the max instead, even tho this means the frame will not be
  // aligned.
  pad = std::min(maxPayloadLen, pad);
  Debug(this, ""using frame size padding: %d"", pad);
  return pad;
}",67,,773,3,,void
188898,BLOCK,-1,,<empty>,15,,775,2,,void
188928,BLOCK,-1,,"{
  Debug(this, ""using max frame size padding: %d"", maxPayloadLen);
  return maxPayloadLen;
}",67,,790,3,,void
188938,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_buf_.base);
  CHECK_LE(stream_buf_offset_, stream_buf_.len);
  size_t read_len = stream_buf_.len - stream_buf_offset_;

  // multiple side effects.
  Debug(this, ""receiving %d bytes [wants data? %d]"",
        read_len,
        nghttp2_session_want_read(session_.get()));
  set_receive_paused(false);
  custom_recv_error_code_ = nullptr;
  ssize_t ret =
    nghttp2_session_mem_recv(session_.get(),
                             reinterpret_cast<uint8_t*>(stream_buf_.base) +
                                 stream_buf_offset_,
                             read_len);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  CHECK_IMPLIES(custom_recv_error_code_ != nullptr, ret < 0);

  if (is_receive_paused()) {
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_r...",39,,800,1,,void
188998,BLOCK,-1,,"{
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_recv_callback which may have an END_STREAM flag.
    stream_buf_offset_ += ret;
    goto done;
  }",28,,819,2,,void
189039,BLOCK,-1,,"{
    SendPendingData();
  }",36,,840,2,,void
189047,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Debug(this,
        ""fatal error receiving data: %d (%s)"",
        ret,
        custom_recv_error_code_ != nullptr ?
            custom_recv_error_code_ : ""(no custom error code)"");
    Local<Value> args[] = {
      Integer::New(isolate, static_cast<int32_t>(ret)),
      Null(isolate)
    };
    if (custom_recv_error_code_ != nullptr) {
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }
    MakeCallback(
        env()->http2session_on_error_function(),
        arraysize(args),
        args);
  }",26,,845,2,,void
189083,BLOCK,-1,,"{
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }",45,,856,2,,void
189112,BLOCK,-1,,"{
  // If this is a push promise, we want to grab the id of the promised stream
  return (frame->hd.type == NGHTTP2_PUSH_PROMISE) ?
      frame->push_promise.promised_stream_id :
      frame->hd.stream_id;
}",48,,870,2,,void
189138,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  Debug(session, ""beginning headers for stream %d"", id);

  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // The common case is that we're creating a new stream. The less likely
  // case is that we're receiving a set of trailers
  if (LIKELY(!stream)) {
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  } else if (!stream->is_destroyed()) ...",59,,884,4,,void
189169,BLOCK,-1,,"{
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  }",24,,892,2,,void
189191,BLOCK,-1,,"{
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }",32,,895,2,,void
189203,BLOCK,-1,,<empty>,9,,898,2,,void
189222,BLOCK,-1,,<empty>,10,,909,1,,void
189229,BLOCK,-1,,"{
    stream->StartHeaders(frame->headers.cat);
  }",39,,909,2,,void
189250,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // If stream is null at this point, either something odd has happened
  // or the stream was closed locally while header processing was occurring.
  // either way, do not proceed and close the stream.
  if (UNLIKELY(!stream))
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;

  // If the stream has already been destroyed, ignore.
  if (!stream->is_destroyed() && !stream->AddHeader(name, value, flags)) {
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }
  return 0;
}",53,,923,7,,void
189277,BLOCK,-1,,<empty>,5,,931,2,,void
189295,BLOCK,-1,,"{
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }",74,,934,2,,void
189311,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  Debug(session, ""complete frame received: type: %d"",
        frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }
  return 0;
}",51,,948,4,,void
189338,BLOCK,-1,,"{
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }",27,,953,2,,void
189416,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  const uint32_t max_invalid_frames = session->js_fields_->max_invalid_frames;

  Debug(session,
        ""invalid frame received (%u/%u), code: %d"",
        session->invalid_frame_count_,
        max_invalid_frames,
        lib_error_code);
  if (session->invalid_frame_count_++ > max_invalid_frames) {
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }

  // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error
  if (nghttp2_is_fatal(lib_error_code) ||
      lib_error_code == NGHTTP2_ERR_STREAM_CLOSED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",51,,988,5,,void
189446,BLOCK,-1,,"{
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }",61,,997,2,,void
189461,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",52,,1004,2,,void
189521,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream && !stream->is_destroyed() && stream->headers_count() > 0) {
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }
}",62,,1018,2,,void
189550,BLOCK,-1,,"{
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }",73,,1022,2,,void
189578,BLOCK,-1,,"{
  switch (libErrorCode) {
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }
}",60,,1031,2,,void
189581,BLOCK,-1,,"{
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }",25,,1032,2,,void
189620,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Debug(session, ""frame type %d was not sent, code: %d"",
        frame->hd.type, error_code);

  // Do not report if the frame was not sent due to the session closing
  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||
      error_code == NGHTTP2_ERR_STREAM_CLOSED ||
      error_code == NGHTTP2_ERR_STREAM_CLOSING) {
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  Local<Value> argv[3] = {
    Integer::New(isolate, frame->hd.stream_id),
    Integer::New(iso...",51,,1061,5,,void
189655,BLOCK,-1,,"{
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }",49,,1070,2,,void
189713,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_sent += 1;
  return 0;
}",48,,1097,4,,void
189736,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  Debug(session, ""stream %d closed with code: %d"", id, code);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // Intentionally ignore the callback if the stream does not exist or has
  // already been destroyed
  if (!stream || stream->is_destroyed())
    return 0;

  stream->Close(code);

  // It is possible for the stream close to occur before the stream is
  // ever passed on to the javascript side. If that happens, the callback
  // will return false.
  if (env->can_call_into_js()) {
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()...",50,,1107,5,,void
189797,BLOCK,-1,,<empty>,5,,1119,2,,void
189810,BLOCK,-1,,"{
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()->IsFalse()) {
      // Skip to destroy
      stream->Destroy();
    }
  }",32,,1126,2,,void
189853,BLOCK,-1,,"{
      // Skip to destroy
      stream->Destroy();
    }",65,,1130,2,,void
189869,BLOCK,-1,,"{
  // Ignore invalid header fields by default.
  return 0;
}",52,,1147,7,,void
189881,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""buffering data chunk for stream %d, size: ""
        ""%d, flags: %d"", id, len, flags);
  Environment* env = session->env();
  HandleScope scope(env->isolate());

  // We should never actually get a 0-length chunk so this check is
  // only a precaution at this point.
  if (len == 0)
    return 0;

  // Notify nghttp2 that we've consumed a chunk of data on the connection
  // so that it can send a WINDOW_UPDATE frame. This is a critical part of
  // the flow control process in http2
  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);

  // If the stream has been destroyed, ignore this chunk
  if (!stream || stream->is_destroyed())
    return 0;

  stream->statistics_.received_bytes += len;

  // Repeatedly ask the stream's owner for memory, and copy the read data
  // into those buffers.
  // The typical case is actually the ex...",56,,1161,7,,void
189911,BLOCK,-1,,<empty>,5,,1171,2,,void
189938,BLOCK,-1,,<empty>,5,,1181,2,,void
189949,BLOCK,-1,,"{
    uv_buf_t buf = stream->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    // `buf.base == nullptr` is the default Http2StreamListener's way
    // of saying that it wants a pointer to the raw original.
    // Since it has access to the original socket buffer from which the data
    // was read in the first place, it can use that to minimize ArrayBuffer
    // allocations.
    if (LIKELY(buf.base == nullptr))
      buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));
    else
      memcpy(buf.base, data, avail);
    data += avail;
    len -= avail;
    stream->EmitRead(avail, buf);

    // If the stream owner (e.g. the JS Http2Stream) wants more data, just
    // tell nghttp2 that all data has been consumed. Otherwise, defer until
    // more data is being requested.
    if (stream->is_reading())
      nghttp2_session_consume_stream(handle, id, avail);
    else
      stream->inbound_consumed_data_while_...",6,,1190,1,,void
189970,BLOCK,-1,,<empty>,7,,1194,2,,void
189983,BLOCK,-1,,<empty>,7,,1202,2,,void
189994,BLOCK,-1,,<empty>,7,,1204,1,,void
190018,BLOCK,-1,,<empty>,7,,1213,2,,void
190024,BLOCK,-1,,<empty>,7,,1215,1,,void
190042,BLOCK,-1,,"{
      session->SendPendingData();
    }",52,,1219,2,,void
190055,BLOCK,-1,,"{
    CHECK(session->is_reading_stopped());
    session->set_receive_paused();
    Debug(session, ""receive paused"");
    return NGHTTP2_ERR_PAUSE;
  }",40,,1226,2,,void
190079,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  ssize_t padding = frame->hd.length;

  switch (session->padding_strategy_) {
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }
  return padding;
}",56,,1241,5,,void
190098,BLOCK,-1,,"{
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }",39,,1245,2,,void
190134,BLOCK,-1,,"{
  // Unfortunately, this is currently the only way for us to know if
  // the session errored because the peer is not an http2 peer.
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""Error '%s'"", message);
  if (lib_error_code == NGHTTP2_ERR_SETTINGS_EXPECTED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",50,,1265,6,,void
190149,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",56,,1270,2,,void
190209,BLOCK,-1,,"{
  // See the comments in Http2Session::OnDataChunkReceived
  // (which is the only possible call site for this method).
  return uv_buf_init(nullptr, size);
}",58,,1282,2,,void
190219,BLOCK,-1,,"{
  Http2Stream* stream = static_cast<Http2Stream*>(stream_);
  Http2Session* session = stream->session();
  Environment* env = stream->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (nread < 0) {
    PassReadErrorToPreviousListener(nread);
    return;
  }

  Local<ArrayBuffer> ab;
  if (session->stream_buf_ab_.IsEmpty()) {
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  } else {
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }

  // There is a single large array buffer for the entire data read from the
  // network; create a slice of that array buffer and emit it as the
  // received data buffer.
  size_t offset = buf.base - session->stream_buf_.base;

  // Verify that the data offset is inside the current read buffer.
  CHECK_GE(offset, session->stream_buf_offset_);
  CHECK_LE(offset, ses...",76,,1288,3,,void
190256,BLOCK,-1,,"{
    PassReadErrorToPreviousListener(nread);
    return;
  }",18,,1295,2,,void
190272,BLOCK,-1,,"{
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  }",42,,1301,2,,void
190302,BLOCK,-1,,"{
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }",10,,1305,1,,void
190358,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);
  Debug(this, ""handle headers frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  // If the stream has already been destroyed, ignore.
  if (!stream || stream->is_destroyed())
    return;

  // The headers are stored as a vector of Http2Header instances.
  // The following converts that into a JS array with the structure:
  // [name1, value1, name2, value2, name3, value3, name3, value4] and so on.
  // That array is passed up to the JS layer and converted into an Object form
  // like {name1: value1, name2: value2, name3: [value3, value4]}. We do it
  // this way for performance reasons (it's faster to generate and pass an
  // array than it is to generate and pass the object).

  MaybeStackBuffer<Local<Value>, 64> headers_v(stream->headers_count() * 2);
  MaybeS...",67,,1326,2,,void
190407,BLOCK,-1,,<empty>,5,,1338,2,,void
190512,BLOCK,-1,,"{
  if (js_fields_->priority_listener_count == 0) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_priority priority_frame = frame->priority;
  int32_t id = GetFrameID(frame);
  Debug(this, ""handle priority frame for stream %d"", id);
  // Priority frame stream ID should never be <= 0. nghttp2 handles this for us
  nghttp2_priority_spec spec = priority_frame.pri_spec;

  Local<Value> argv[4] = {
    Integer::New(isolate, id),
    Integer::New(isolate, spec.stream_id),
    Integer::New(isolate, spec.weight),
    Boolean::New(isolate, spec.exclusive)
  };
  MakeCallback(env()->http2session_on_priority_function(),
               arraysize(argv), argv);
}",68,,1380,2,,void
190519,BLOCK,-1,,<empty>,49,,1381,2,,void
190585,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  Debug(this, ""handling data frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream &&
      !stream->is_destroyed() &&
      frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
    stream->EmitRead(UV_EOF);
  } else if (frame->hd.length == 0) {
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }
  return 0;
}",63,,1407,2,,void
190619,BLOCK,-1,,"{
    stream->EmitRead(UV_EOF);
  }",50,,1414,2,,void
190626,BLOCK,-1,,<empty>,10,,1416,1,,void
190635,BLOCK,-1,,"{
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }",37,,1416,2,,void
190643,BLOCK,-1,,"{
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }",66,,1417,2,,void
190658,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",66,,1429,2,,void
190709,BLOCK,-1,,"{
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }",19,,1445,2,,void
190740,BLOCK,-1,,"{
  if (!(js_fields_->bitfield & (1 << kSessionHasAltsvcListeners))) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);
  Debug(this, ""handling altsvc frame"");

  Local<Value> argv[3] = {
    Integer::New(isolate, id),
    OneByteString(isolate, altsvc->origin, altsvc->origin_len),
    OneByteString(isolate, altsvc->field_value, altsvc->field_value_len)
  };

  MakeCallback(env()->http2session_on_altsvc_function(),
               arraysize(argv), argv);
}",66,,1459,2,,void
190750,BLOCK,-1,,<empty>,68,,1460,2,,void
190817,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  Debug(this, ""handling origin frame"");

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);

  size_t nov = origin->nov;
  std::vector<Local<Value>> origin_v(nov);

  for (size_t i = 0; i < nov; ++i) {
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }
  Local<Value> holder = Array::New(isolate, origin_v.data(), origin_v.size());
  MakeCallback(env()->http2session_on_origin_function(), 1, &holder);
}",66,,1482,2,,void
190875,BLOCK,-1,,<empty>,3,,1496,1,,void
190885,BLOCK,4,,"{
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }",36,,1496,4,,void
190937,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cas...",64,,1505,2,,void
190978,BLOCK,-1,,"{
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }",12,,1512,2,,void
190989,BLOCK,-1,,"{
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }",16,,1515,2,,void
191027,BLOCK,-1,,<empty>,66,,1530,2,,void
191059,BLOCK,-1,,"{
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (!ack) {
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }

  // If this is an acknowledgement, we should have an Http2Settings
  // object for it.
  BaseObjectPtr<Http2Settings> settings = PopSettings();
  if (settings) {
    settings->Done(true);
    return;
  }
  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2
  // spec does not require this, but there is no legitimate reason to
  // receive an unsolicited SETTINGS ack on a connection. Either the peer
  // is buggy or malicious, and we're not going to tolerate such
  // nonsense.
  // Note that nghttp2 currently prevents this from happening for SETTINGS
  // frames, so this block is purely ...",68,,1540,2,,void
191073,BLOCK,-1,,"{
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }",13,,1542,2,,void
191091,BLOCK,-1,,<empty>,7,,1545,2,,void
191110,BLOCK,-1,,"{
    settings->Done(true);
    return;
  }",17,,1554,2,,void
191165,BLOCK,-1,,"{
  Debug(this, ""write finished with status %d"", status);

  CHECK(is_write_in_progress());
  set_write_in_progress(false);

  // Inform all pending writes about their completion.
  ClearOutgoing(status);

  if (is_reading_stopped() &&
      !is_write_in_progress() &&
      nghttp2_session_want_read(session_.get())) {
    set_reading_stopped(false);
    stream_->ReadStart();
  }

  if (is_destroyed()) {
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }

  // If there is more incoming data queued up, consume it.
  if (stream_buf_offset_ > 0) {
    ConsumeHTTP2Data();
  }

  if (!is_write_scheduled() && !is_destroyed()) {
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }
}",65,,1576,3,,void
191186,BLOCK,-1,,"{
    set_reading_stopped(false);
    stream_->ReadStart();
  }",50,,1587,2,,void
191195,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }",23,,1592,2,,void
191213,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,1595,2,,void
191225,BLOCK,-1,,"{
    ConsumeHTTP2Data();
  }",31,,1604,2,,void
191233,BLOCK,-1,,"{
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }",49,,1608,2,,void
191238,BLOCK,-1,,"{
  CHECK(!is_write_scheduled());
  if (UNLIKELY(!session_))
    return;

  if (nghttp2_session_want_write(session_.get())) {
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }
}",41,,1618,1,,void
191246,BLOCK,-1,,<empty>,5,,1621,2,,void
191254,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }",51,,1623,2,,void
191280,BLOCK,-1,,"{
  // If the session is already closing we don't want to stop reading as we want
  // to detect when the other peer is actually closed.
  if (is_reading_stopped() || is_closing()) return;
  int want_read = nghttp2_session_want_read(session_.get());
  Debug(this, ""wants read? %d"", want_read);
  if (want_read == 0 || is_write_in_progress()) {
    set_reading_stopped();
    stream_->ReadStop();
  }
}",39,,1647,1,,void
191285,BLOCK,-1,,<empty>,45,,1650,2,,void
191305,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",49,,1653,2,,void
191315,BLOCK,-1,,"{
  CHECK(is_sending());

  set_sending(false);

  if (!outgoing_buffers_.empty()) {
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }

  // Now that we've finished sending queued data, if there are any pending
  // RstStreams we should try sending again and then flush them one by one.
  if (!pending_rst_streams_.empty()) {
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (in...",46,,1661,2,,void
191325,BLOCK,-1,,"{
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }",35,,1666,2,,void
191348,BLOCK,-1,,"{
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }",68,,1672,3,,void
191364,BLOCK,-1,,"{
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }",17,,1674,2,,void
191380,BLOCK,-1,,"{
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (int32_t stream_id : current_pending_rst_streams) {
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }
  }",38,,1685,2,,void
191397,BLOCK,-1,,"{
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }",59,,1691,3,,void
191407,BLOCK,-1,,<empty>,11,,1693,1,,void
191409,BLOCK,-1,,<empty>,9,,1694,2,,void
191418,BLOCK,-1,,"{
  outgoing_length_ += write.buf.len;
  outgoing_buffers_.emplace_back(std::move(write));
}",67,,1699,2,,void
191440,BLOCK,-1,,"{
  size_t offset = outgoing_storage_.size();
  outgoing_storage_.resize(offset + src_length);
  memcpy(&outgoing_storage_[offset], src, src_length);

  // Store with a base of `nullptr` initially, since future resizes
  // of the outgoing_buffers_ vector may invalidate the pointer.
  // The correct base pointers will be set later, before writing to the
  // underlying socket.
  PushOutgoingBuffer(NgHttp2StreamWrite {
    uv_buf_init(nullptr, src_length)
  });
}",80,,1707,3,,void
191471,BLOCK,-1,,"{
  Debug(this, ""sending pending data"");
  // Do not attempt to send data on the socket if the destroying flag has
  // been set. That means everything is shutting down and the socket
  // will not be usable.
  if (is_destroyed())
    return 0;
  set_write_scheduled(false);

  // SendPendingData should not be called recursively.
  if (is_sending())
    return 1;
  // This is cleared by ClearOutgoing().
  set_sending();

  ssize_t src_length;
  const uint8_t* src;

  CHECK(outgoing_buffers_.empty());
  CHECK(outgoing_storage_.empty());

  // Part One: Gather data from nghttp2

  while ((src_length = nghttp2_session_mem_send(session_.get(), &src)) > 0) {
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }

  CHECK_NE(src_length, NGHTTP2_ERR_NOMEM);

  if (stream_ == nullptr) {
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
 ...",41,,1726,1,,void
191477,BLOCK,-1,,<empty>,5,,1732,2,,void
191484,BLOCK,-1,,<empty>,5,,1737,2,,void
191512,BLOCK,-1,,"{
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }",77,,1749,2,,void
191527,BLOCK,-1,,"{
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
    // a socket has been torn down, so we still need to call it.
    ClearOutgoing(UV_ECANCELED);
    return 0;
  }",27,,1756,2,,void
191542,BLOCK,-1,,"{
    ClearOutgoing(0);
    return 0;
  }",19,,1767,2,,void
191570,BLOCK,-1,,"{
    statistics_.data_sent += write.buf.len;
    if (write.buf.base == nullptr) {
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    } else {
      bufs[i++] = write.buf;
    }
  }",61,,1779,3,,void
191588,BLOCK,-1,,"{
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    }",36,,1781,2,,void
191616,BLOCK,-1,,"{
      bufs[i++] = write.buf;
    }",12,,1786,1,,void
191646,BLOCK,-1,,"{
    set_write_in_progress(false);
    ClearOutgoing(res.err);
  }",19,,1796,2,,void
191665,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(frame->hd.stream_id);
  if (!stream) return 0;

  // Send the frame header + a byte that indicates padding length.
  session->CopyDataIntoOutgoing(framehd, 9);
  if (frame->data.padlen > 0) {
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }

  Debug(session, ""nghttp2 has %d bytes to send directly"", length);
  while (length > 0) {
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::m...",24,,1817,7,,void
191690,BLOCK,-1,,<empty>,16,,1820,2,,void
191707,BLOCK,-1,,"{
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }",31,,1824,2,,void
191742,BLOCK,-1,,"{
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }

    // Slice off `length` bytes of the first write in the queue.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(write.buf.base, length)
    });
    write.buf.base += length;
    write.buf.len -= length;
    break;
  }",22,,1831,2,,void
191768,BLOCK,-1,,"{
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }",34,,1837,2,,void
191828,BLOCK,-1,,"{
    // Send padding if that was requested.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(const_cast<char*>(zero_bytes_256), frame->data.padlen - 1)
    });
  }",31,,1854,2,,void
191855,BLOCK,-1,,"{
  Debug(this, ""submitting request"");
  Http2Scope h2scope(this);
  Http2Stream* stream = nullptr;
  Http2Stream::Provider::Stream prov(options);
  *ret = nghttp2_submit_request(
      session_.get(),
      &priority,
      headers.data(),
      headers.length(),
      *prov,
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  if (LIKELY(*ret > 0))
    stream = Http2Stream::New(this, *ret, NGHTTP2_HCAT_HEADERS, options);
  return stream;
}",18,,1869,5,,void
191900,BLOCK,-1,,<empty>,5,,1883,2,,void
191918,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",61,,1887,2,,void
191930,BLOCK,-1,,"{
  HandleScope handle_scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  Http2Scope h2scope(this);
  CHECK_NOT_NULL(stream_);
  Debug(this, ""receiving %d bytes, offset %d"", nread, stream_buf_offset_);
  std::unique_ptr<BackingStore> bs = env()->release_managed_buffer(buf_);

  // Only pass data on if nread > 0
  if (nread <= 0) {
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());

  statistics_.data_received += nread;

  if (LIKELY(stream_buf_offset_ == 0)) {
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  } else {
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the a...",70,,1892,3,,void
191969,BLOCK,-1,,"{
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }",19,,1901,2,,void
191974,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
    }",20,,1902,2,,void
191996,BLOCK,-1,,"{
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  }",40,,1912,2,,void
192014,BLOCK,-1,,"{
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the already processed part.
    size_t pending_len = stream_buf_.len - stream_buf_offset_;
    std::unique_ptr<BackingStore> new_bs;
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }
    memcpy(static_cast<char*>(new_bs->Data()),
           stream_buf_.base + stream_buf_offset_,
           pending_len);
    memcpy(static_cast<char*>(new_bs->Data()) + pending_len,
           bs->Data(),
           nread);

    bs = std::move(new_bs);
    nread = bs->ByteLength();
    stream_buf_offset_ = 0;
    stream_buf_ab_.Reset();

    // We have now fully processed t...",10,,1915,1,,void
192030,BLOCK,4,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }",5,,1922,4,,void
192128,BLOCK,-1,,"{
  for (const NgHttp2StreamWrite& wr : outgoing_buffers_) {
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }
  return false;
}",68,,1961,2,,void
192132,BLOCK,-1,,"{
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }",58,,1962,3,,void
192150,BLOCK,-1,,<empty>,7,,1964,2,,void
192159,BLOCK,-1,,"{
  StreamBase* stream = StreamBase::FromObject(stream_obj);
  stream->PushStreamListener(this);
  Debug(this, ""i/o stream consumed"");
}",54,,1973,2,,void
192180,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(session, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer
  while (len > 0) {
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",69,,1983,2,,void
192223,BLOCK,-1,,"{
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",19,,1994,2,,void
192275,BLOCK,-1,,"{
  Local<Object> obj;
  if (!session->env()
           ->http2stream_constructor_template()
           ->NewInstance(session->env()->context())
           .ToLocal(&obj)) {
    return nullptr;
  }
  return new Http2Stream(session, obj, id, category, options);
}",44,,2009,5,,void
192305,BLOCK,-1,,"{
    return nullptr;
  }",28,,2014,2,,void
192324,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
  statistics_.id = id;
  statistics_.start_time = uv_hrtime();

  // Limit the number of header pairs
  max_header_pairs_ = session->max_header_pairs();
  if (max_header_pairs_ == 0) {
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }
  current_headers_.reserve(std::min(max_header_pairs_, 12u));

  // Limit the number of header octets
  max_header_length_ =
      std::min(
        nghttp2_session_get_local_settings(
          session->session(),
          NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE),
      MAX_MAX_HEADER_LIST_SIZE);

  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  PushStreamListener(&stream_listener_);

  if (options & STREAM_OPTION_EMPTY_PAYLOAD)
    Shutdown();
  session->AddStream(this);
}",43,,2029,6,,void
192347,BLOCK,-1,,"{
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }",31,,2037,2,,void
192378,BLOCK,-1,,<empty>,5,,2051,2,,void
192385,BLOCK,-1,,<empty>,5,,2056,2,,void
192395,BLOCK,-1,,"{
  Debug(this, ""tearing down stream"");
}",29,,2060,1,,void
192403,BLOCK,-1,,"{
  tracker->TrackField(""current_headers"", current_headers_);
  tracker->TrackField(""queue"", queue_);
}",60,,2064,2,,void
192419,BLOCK,-1,,"{
  const Http2Session* sess = session();
  const std::string sname =
      sess ? sess->diagnostic_name() : ""session already destroyed"";
  return ""HttpStream "" + std::to_string(id()) + "" ("" +
         std::to_string(static_cast<int64_t>(get_async_id())) + "") ["" + sname +
         ""]"";
}",50,,2069,1,,void
192462,BLOCK,-1,,"{
  Debug(this, ""starting headers, category: %d"", category);
  CHECK(!this->is_destroyed());
  session_->DecrementCurrentSessionMemory(current_headers_length_);
  current_headers_length_ = 0;
  current_headers_.clear();
  current_headers_category_ = category;
}",67,,2079,2,,void
192491,BLOCK,-1,,{ return stream(); },48,,2089,1,,void
192497,BLOCK,-1,,"{
  return nghttp2_session_find_stream(session_->session(), id_);
}",45,,2091,1,,void
192509,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  set_closed();
  code_ = code;
  Debug(this, ""closed with code %d"", code);
}",39,,2095,2,,void
192528,BLOCK,-1,,"{
  // DoShutdown() always finishes synchronously, so there's no need to create
  // a structure to store asynchronous context.
  return nullptr;
}",69,,2102,2,,void
192535,BLOCK,-1,,"{
  if (is_destroyed())
    return UV_EPIPE;

  {
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }
  return 1;
}",53,,2108,2,,void
192538,BLOCK,-1,,<empty>,5,,2110,2,,void
192541,BLOCK,2,,"{
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }",3,,2112,2,,void
192562,BLOCK,-1,,"{
  // Do nothing if this stream instance is already destroyed
  if (is_destroyed())
    return;
  if (session_->has_pending_rststream(id_))
    FlushRstStream();
  set_destroyed();

  Debug(this, ""destroying stream"");

  // Wait until the start of the next loop to delete because there
  // may still be some pending operations queued for this stream.
  BaseObjectPtr<Http2Stream> strong_ref = session_->RemoveStream(id_);
  if (strong_ref) {
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are ...",29,,2126,1,,void
192565,BLOCK,-1,,<empty>,5,,2129,2,,void
192573,BLOCK,-1,,<empty>,5,,2131,2,,void
192592,BLOCK,-1,,"{
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    });
  }",19,,2139,2,,void
192630,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""submitting response"");
  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  if (!is_writable())
    options |= STREAM_OPTION_EMPTY_PAYLOAD;

  Http2Stream::Provider::Stream prov(this, options);
  int ret = nghttp2_submit_response(
      session_->session(),
      id_,
      headers.data(),
      headers.length(),
      *prov);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",75,,2173,3,,void
192647,BLOCK,-1,,<empty>,5,,2178,2,,void
192652,BLOCK,-1,,<empty>,5,,2181,2,,void
192688,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d informational headers"", headers.length());
  int ret = nghttp2_submit_headers(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      nullptr,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",58,,2196,2,,void
192733,BLOCK,-1,,"{
  Debug(this, ""let javascript know we are ready for trailers"");
  CHECK(!this->is_destroyed());
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  set_has_trailers(false);
  MakeCallback(env()->http2session_on_stream_trailers_function(), 0, nullptr);
}",32,,2212,1,,void
192779,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d trailers"", headers.length());
  int ret;
  // Sending an empty trailers frame poses problems in Safari, Edge & IE.
  // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM
  // to indicate that the stream is ready to be closed.
  if (headers.length() == 0) {
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  } else {
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",62,,2224,2,,void
192804,BLOCK,-1,,"{
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  }",30,,2232,2,,void
192821,BLOCK,-1,,"{
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }",10,,2239,1,,void
192848,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending priority spec"");
  int ret = silent ?
      nghttp2_session_change_stream_priority(
          session_->session(),
          id_,
          &priority) :
      nghttp2_submit_priority(
          session_->session(),
          NGHTTP2_FLAG_NONE,
          id_, &priority);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",46,,2252,3,,void
192891,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  code_ = code;

  auto is_stream_cancel = [](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  };

  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,
  // add it to the pending list and don't force purge the data. It is
  // to avoids the double free error due to unwanted behavior of nghttp2.

  // Add stream to the pending list only if it is received with scope
  // below in the stack. The pending list may not get processed
  // if RST_STREAM received is not in scope and added to the list
  // causing endpoint to hang.
  if (session_->is_in_scope() && is_stream_cancel(code)) {
      session_->AddPendingRstStream(id_);
      return;
  }


  // If possible, force a purge of any currently pending data here to make sure
  // it is sent before closing the stream. If it returns non-zero then we need
  // to wait until the current write finishes and try again to avoid nghttp2
  // behaviour where it prioritizes RstStream over ...",56,,2271,2,,void
192913,BLOCK,-1,,"{
      session_->AddPendingRstStream(id_);
      return;
  }",58,,2287,2,,void
192927,BLOCK,-1,,"{
    session_->AddPendingRstStream(id_);
    return;
  }",41,,2297,2,,void
192938,BLOCK,-1,,"{
  if (is_destroyed())
    return;
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_rst_stream(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      code_), 0);
}",36,,2305,1,,void
192941,BLOCK,-1,,<empty>,5,,2307,2,,void
192962,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending push promise"");
  *ret = nghttp2_submit_push_promise(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  Http2Stream* stream = nullptr;
  if (*ret > 0) {
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }

  return stream;
}",58,,2320,4,,void
193007,BLOCK,-1,,"{
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }",17,,2333,2,,void
193027,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",30,,2343,1,,void
193056,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  if (!is_reading())
    return 0;
  set_paused();
  Debug(this, ""reading stopped"");
  return 0;
}",29,,2362,1,,void
193066,BLOCK,-1,,<empty>,5,,2365,2,,void
193082,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Http2Scope h2scope(this);
  if (!is_writable() || is_destroyed()) {
    return UV_EOF;
  }
  Debug(this, ""queuing %d buffers to send"", nbufs);
  for (size_t i = 0; i < nbufs; ++i) {
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }
  CHECK_NE(nghttp2_session_resume_data(
      session_->session(),
      id_), NGHTTP2_ERR_NOMEM);
  return 0;
}",52,,2384,5,,void
193093,BLOCK,-1,,"{
    return UV_EOF;
  }",41,,2387,2,,void
193101,BLOCK,-1,,<empty>,3,,2391,1,,void
193111,BLOCK,4,,"{
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }",38,,2391,4,,void
193158,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());

  if (Http2RcBufferPointer::IsZeroLength(name))
    return true;  // Ignore empty headers.

  Http2Header header(env(), name, value, flags);
  size_t length = header.length() + 32;
  // A header can only be added if we have not exceeded the maximum number
  // of headers and the session has memory available for it.
  if (!session_->has_available_session_memory(length) ||
      current_headers_.size() == max_header_pairs_ ||
      current_headers_length_ + length > max_header_length_) {
    return false;
  }

  if (statistics_.first_header == 0)
    statistics_.first_header = uv_hrtime();

  current_headers_.push_back(std::move(header));

  current_headers_length_ += length;
  session_->IncrementCurrentSessionMemory(length);
  return true;
}",44,,2414,4,,void
193171,BLOCK,-1,,<empty>,5,,2418,2,,void
193209,BLOCK,-1,,"{
    return false;
  }",62,,2426,2,,void
193218,BLOCK,-1,,<empty>,5,,2431,2,,void
193248,BLOCK,-1,,"{
  CHECK(!stream->is_destroyed());
  provider_.source.ptr = stream;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",67,,2441,3,,void
193271,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",46,,2447,2,,void
193287,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
}",36,,2452,1,,void
193299,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",38,,2459,2,,void
193316,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",46,,2464,3,,void
193338,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""reading outbound data for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  if (!stream) return 0;
  if (stream->statistics_.first_byte_sent == 0)
    stream->statistics_.first_byte_sent = uv_hrtime();
  CHECK_EQ(id, stream->id());

  size_t amount = 0;          // amount of data being sent in this data frame.

  // Remove all empty chunks from the head of the queue.
  // This is done here so that .write('', cb) is still a meaningful way to
  // find out when the HTTP2 stream wants to consume data, and because the
  // StreamBase API allows empty input chunks.
  while (!stream->queue_.empty() && stream->queue_.front().buf.len == 0) {
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }

  if (!stream->queue_.empty()) {
    Debug(sessio...",64,,2474,8,,void
193363,BLOCK,-1,,<empty>,16,,2478,2,,void
193374,BLOCK,-1,,<empty>,5,,2480,2,,void
193413,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }",74,,2489,2,,void
193440,BLOCK,-1,,<empty>,7,,2494,2,,void
193458,BLOCK,-1,,"{
    Debug(session, ""stream %d has pending outbound data"", id);
    amount = std::min(stream->available_outbound_length_, length);
    Debug(session, ""sending %d bytes for data frame on stream %d"", amount, id);
    if (amount > 0) {
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }
  }",32,,2497,2,,void
193482,BLOCK,-1,,"{
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }",21,,2501,2,,void
193501,BLOCK,-1,,"{
    CHECK(stream->queue_.empty());
    Debug(session, ""deferring stream %d"", id);
    stream->EmitWantsWrite(length);
    if (stream->available_outbound_length_ > 0 || !stream->is_writable()) {
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }
    return NGHTTP2_ERR_DEFERRED;
  }",45,,2509,2,,void
193530,BLOCK,-1,,"{
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }",75,,2513,2,,void
193554,BLOCK,-1,,"{
    Debug(session, ""no more data for stream %d"", id);
    *flags |= NGHTTP2_DATA_FLAG_EOF;
    if (stream->has_trailers()) {
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }
  }",74,,2520,2,,void
193568,BLOCK,-1,,"{
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }",33,,2523,2,,void
193590,BLOCK,-1,,"{
  available_outbound_length_ += amount;
  session_->IncrementCurrentSessionMemory(amount);
}",67,,2533,2,,void
193603,BLOCK,-1,,"{
  available_outbound_length_ -= amount;
  session_->DecrementCurrentSessionMemory(amount);
}",67,,2538,2,,void
193616,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t val = args[0]->Uint32Value(env->context()).ToChecked();
  args.GetReturnValue().Set(
      OneByteString(
          env->isolate(),
          reinterpret_cast<const uint8_t*>(nghttp2_strerror(val))));
}",63,,2548,2,,void
193661,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  args.GetReturnValue().Set(Http2Settings::Pack(state));
}",60,,2561,2,,void
193688,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Http2Settings::RefreshDefaults(state);
}",70,,2569,2,,void
193708,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  int32_t id = args[0]->Int32Value(env->context()).ToChecked();
  if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }
  args.GetReturnValue().Set(true);
  Debug(session, ""set next stream id to %d"", id);
}",77,,2575,2,,void
193750,BLOCK,-1,,"{
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }",71,,2580,2,,void
193780,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();

  int result = nghttp2_session_set_local_window_size(
      session->session(), NGHTTP2_FLAG_NONE, 0, window_size);

  args.GetReturnValue().Set(result);

  Debug(session, ""set local window size to %d"", window_size);
}",46,,2592,2,,void
193840,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Http2Settings::Update(session, fn);
  Debug(session, ""settings refreshed for session"");
}",77,,2611,2,,void
193862,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""refreshing state"");

  AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;

  nghttp2_session* s = session->session();

  buffer[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_effective_local_window_size(s);
  buffer[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH] =
      nghttp2_session_get_effective_recv_data_length(s);
  buffer[IDX_SESSION_STATE_NEXT_STREAM_ID] =
      nghttp2_session_get_next_stream_id(s);
  buffer[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_local_window_size(s);
  buffer[IDX_SESSION_STATE_LAST_PROC_STREAM_ID] =
      nghttp2_session_get_last_proc_stream_id(s);
  buffer[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE] =
      nghttp2_session_get_remote_window_size(s);
  buffer[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE] =
      static_cast<double>(nghttp2_session_get_outbound_queue_size(s));
  buffer[IDX_SESSION_...",74,,2621,2,,void
193954,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Environment* env = state->env();
  CHECK(args.IsConstructCall());
  SessionType type =
      static_cast<SessionType>(
          args[0]->Int32Value(env->context()).ToChecked());
  Http2Session* session = new Http2Session(state, args.This(), type);
  Debug(session, ""session created"");
}",65,,2652,2,,void
194013,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());
  session->Consume(args[0].As<Object>());
}",69,,2665,2,,void
194043,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""destroying session"");
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  session->Close(code, args[1]->IsTrue());
}",69,,2673,2,,void
194101,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Environment* env = session->env();

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(session, ""request submitted"");

  int32_t ret = 0;
  Http2Stream* stream =
      session->Http2Session::SubmitRequest(
          Http2Priority(env, args[2], args[3], args[4]),
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }

  Debug(session, ""request submitted, new stream id %d"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",69,,2686,2,,void
194186,BLOCK,-1,,"{
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }",38,,2704,2,,void
194226,BLOCK,-1,,"{
  if (is_destroyed())
    return;

  Http2Scope h2scope(this);
  // the last proc stream id is the most recently created Http2Stream.
  if (lastStreamID <= 0)
    lastStreamID = nghttp2_session_get_last_proc_stream_id(session_.get());
  Debug(this, ""submitting goaway"");
  nghttp2_submit_goaway(session_.get(), NGHTTP2_FLAG_NONE,
                        lastStreamID, code, data, len);
}",39,,2719,5,,void
194229,BLOCK,-1,,<empty>,5,,2721,2,,void
194238,BLOCK,-1,,<empty>,5,,2726,2,,void
194263,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
  ArrayBufferViewContents<uint8_t> opaque_data;

  if (args[2]->IsArrayBufferView()) {
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }

  session->Goaway(code, lastStreamID, opaque_data.data(), opaque_data.length());
}",68,,2735,2,,void
194328,BLOCK,-1,,"{
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }",37,,2745,2,,void
194357,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t length = session->chunks_sent_since_last_write_;

  session->object()->Set(env->context(),
                         env->chunks_sent_since_last_write_string(),
                         Integer::NewFromUnsigned(isolate, length)).Check();

  args.GetReturnValue().Set(length);
}",78,,2754,2,,void
194426,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  Debug(stream, ""sending rst_stream with code %d"", code);
  stream->SubmitRstStream(code);
}",70,,2773,2,,void
194479,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  args.GetReturnValue().Set(
      stream->SubmitResponse(
          Http2Headers(env, headers),
          static_cast<int>(options)));
  Debug(stream, ""response submitted"");
}",68,,2785,2,,void
194548,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(stream->SubmitInfo(Http2Headers(env, headers)));
}",65,,2802,2,,void
194595,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(
      stream->SubmitTrailers(Http2Headers(env, headers)));
}",69,,2813,2,,void
194642,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  args.GetReturnValue().Set(stream->id());
}",66,,2825,2,,void
194666,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  Debug(stream, ""destroying stream"");
  stream->Destroy();
}",68,,2832,2,,void
194686,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* parent;
  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(parent, ""creating push promise"");

  int32_t ret = 0;
  Http2Stream* stream =
      parent->SubmitPushPromise(
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }
  Debug(parent, ""push stream %d created"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",72,,2840,2,,void
194761,BLOCK,-1,,"{
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }",38,,2857,2,,void
194797,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  CHECK_EQ(stream->SubmitPriority(
      Http2Priority(env, args[0], args[1], args[2]),
      args[3]->IsTrue()), 0);
  Debug(stream, ""priority submitted"");
}",69,,2866,2,,void
194844,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Debug(stream, ""refreshing state"");

  CHECK_NOT_NULL(stream->session());
  AliasedFloat64Array& buffer =
      stream->session()->http2_state()->stream_state_buffer;

  nghttp2_stream* str = stream->stream();
  nghttp2_session* s = stream->session()->session();

  if (str == nullptr) {
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  } else {
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_s...",73,,2880,2,,void
194894,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  }",23,,2893,2,,void
194922,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_session_get_stream_local_close(s, stream->id());
    buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        nghttp2_session_get_stream_remote_close(s, stream->id());
    buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] =
        nghttp2_session_get_stream_local_window_size(s, stream->id());
  }",10,,2900,1,,void
194979,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_altsvc(session_.get(), NGHTTP2_FLAG_NONE, id,
                                 origin, origin_len, value, value_len), 0);
}",45,,2920,6,,void
195000,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_origin(
      session_.get(),
      NGHTTP2_FLAG_NONE,
      *origins,
      origins.length()), 0);
}",51,,2926,2,,void
195022,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t id = args[0]->Int32Value(env->context()).ToChecked();

  // origin and value are both required to be ASCII, handle them as such.
  Local<String> origin_str = args[1]->ToString(env->context()).ToLocalChecked();
  Local<String> value_str = args[2]->ToString(env->context()).ToLocalChecked();

  if (origin_str.IsEmpty() || value_str.IsEmpty())
    return;

  size_t origin_len = origin_str->Length();
  size_t value_len = value_str->Length();

  CHECK_LE(origin_len + value_len, 16382);  // Max permitted for ALTSVC
  // Verify that origin len != 0 if stream id == 0, or
  // that origin len == 0 if stream id != 0
  CHECK((origin_len != 0 && id == 0) || (origin_len == 0 && id != 0));

  MaybeStackBuffer<uint8_t> origin(origin_len);
  MaybeStackBuffer<uint8_t> value(value_len);
  origin_str->WriteOneByte(env->isolate(), *origin);
  value_str->WriteOneBy...",68,,2936,2,,void
195103,BLOCK,-1,,<empty>,5,,2948,2,,void
195187,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  Local<String> origin_string = args[0].As<String>();
  size_t count = args[1]->Int32Value(context).ToChecked();

  session->Origin(Origins(env, origin_string, count));
}",68,,2966,2,,void
195251,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  // A PING frame may have exactly 8 bytes of payload data. If not provided,
  // then the current hrtime will be used as the payload.
  ArrayBufferViewContents<uint8_t, 8> payload;
  if (args[0]->IsArrayBufferView()) {
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }

  CHECK(args[1]->IsFunction());
  args.GetReturnValue().Set(
      session->AddPing(payload.data(), args[1].As<Function>()));
}",66,,2979,2,,void
195274,BLOCK,-1,,"{
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }",37,,2986,2,,void
195323,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsFunction());
  args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
}",70,,2997,2,,void
195359,BLOCK,-1,,"{
  BaseObjectPtr<Http2Ping> ping;
  if (!outstanding_pings_.empty()) {
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }
  return ping;
}",50,,3004,1,,void
195371,BLOCK,-1,,"{
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }",36,,3006,2,,void
195397,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2ping_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Ping> ping =
      MakeDetachedBaseObject<Http2Ping>(this, obj, callback);
  if (!ping)
    return false;

  if (outstanding_pings_.size() == max_outstanding_pings_) {
    ping->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*ping));
  // The Ping itself is an Async resource. When the acknowledgement is received,
  // the callback will be invoked and a notification sent out to JS land. The
  // notification will include the duration of the ping, allowing the round
  // trip to be measured.
  ping->Send(payload);

  outstanding_pings_.emplace(std::move(ping));
  return true;
}",78,,3014,3,,void
195421,BLOCK,-1,,"{
    return false;
  }",31,,3018,2,,void
195442,BLOCK,-1,,<empty>,5,,3025,2,,void
195452,BLOCK,-1,,"{
    ping->Done(false);
    return false;
  }",60,,3027,2,,void
195483,BLOCK,-1,,"{
  BaseObjectPtr<Http2Settings> settings;
  if (!outstanding_settings_.empty()) {
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }
  return settings;
}",58,,3043,1,,void
195495,BLOCK,-1,,"{
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }",39,,3045,2,,void
195520,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2settings_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Settings> settings =
      MakeDetachedBaseObject<Http2Settings>(this, obj, callback, 0);
  if (!settings)
    return false;

  if (outstanding_settings_.size() == max_outstanding_settings_) {
    settings->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*settings));
  settings->Send();
  outstanding_settings_.emplace(std::move(settings));
  return true;
}",58,,3053,2,,void
195544,BLOCK,-1,,"{
    return false;
  }",31,,3057,2,,void
195566,BLOCK,-1,,<empty>,5,,3064,2,,void
195576,BLOCK,-1,,"{
    settings->Done(false);
    return false;
  }",66,,3066,2,,void
195609,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
}",31,,3083,4,,void
195623,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",58,,3087,2,,void
195633,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",45,,3091,1,,void
195647,BLOCK,-1,,"{
  CHECK(session_);
  uint8_t data[8];
  if (payload == nullptr) {
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_ping(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      payload), 0);
}",46,,3095,2,,void
195654,BLOCK,-1,,"{
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }",27,,3098,2,,void
195685,BLOCK,-1,,"{
  uint64_t duration_ns = uv_hrtime() - startTime_;
  double duration_ms = duration_ns / 1e6;
  if (session_) session_->statistics_.ping_rtt = duration_ns;

  Isolate* isolate = env()->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env()->context());

  Local<Value> buf = Undefined(isolate);
  if (payload != nullptr) {
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }

  Local<Value> argv[] = {
      Boolean::New(isolate, ack), Number::New(isolate, duration_ms), buf};
  MakeCallback(callback(), arraysize(argv), argv);
}",56,,3109,3,,void
195700,BLOCK,-1,,<empty>,17,,3112,2,,void
195736,BLOCK,-1,,"{
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }",27,,3119,2,,void
195776,BLOCK,-1,,"{
  session_.reset();
}",37,,3130,1,,void
195785,BLOCK,-1,,"{
  if (req_wrap)
    tracker->TrackField(""req_wrap"", req_wrap);
  tracker->TrackField(""buf"", buf);
}",67,,3134,2,,void
195788,BLOCK,-1,,<empty>,5,,3136,2,,void
195805,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 11);

#define SET_FUNCTION(arg, name)                                               \
  CHECK(args[arg]->IsFunction());                                             \
  env->set_http2session_on_ ## name ## _function(args[arg].As<Function>());

  SET_FUNCTION(0, error)
  SET_FUNCTION(1, priority)
  SET_FUNCTION(2, settings)
  SET_FUNCTION(3, ping)
  SET_FUNCTION(4, headers)
  SET_FUNCTION(5, frame_error)
  SET_FUNCTION(6, goaway_data)
  SET_FUNCTION(7, altsvc)
  SET_FUNCTION(8, origin)
  SET_FUNCTION(9, stream_trailers)
  SET_FUNCTION(10, stream_close)

#undef SET_FUNCTION
}",68,,3140,2,,void
195822,BLOCK,1,,<empty>,,,,2,,void
195842,BLOCK,1,,<empty>,,,,2,,void
195862,BLOCK,1,,<empty>,,,,2,,void
195882,BLOCK,1,,<empty>,,,,2,,void
195902,BLOCK,1,,<empty>,,,,2,,void
195922,BLOCK,1,,<empty>,,,,2,,void
195942,BLOCK,1,,<empty>,,,,2,,void
195962,BLOCK,1,,<empty>,,,,2,,void
195982,BLOCK,1,,<empty>,,,,2,,void
196002,BLOCK,1,,<empty>,,,,2,,void
196022,BLOCK,1,,<empty>,,,,2,,void
196044,BLOCK,-1,,"{
  tracker->TrackField(""root_buffer"", root_buffer);
}",59,,3169,2,,void
196058,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);

  Http2State* const state = realm->AddBindingData<Http2State>(context, target);
  if (state == nullptr) return;

#define SET_STATE_TYPEDARRAY(name, field)             \
  target->Set(context,                                \
              FIXED_ONE_BYTE_STRING(isolate, (name)), \
              (field)).FromJust()

  // Initialize the buffer used to store the session state
  SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray());
  // Initialize the buffer used to store the stream state
  SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""optionsBuffer"", state->options_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""streamStats"", state->stream_stats_buffer...",29,,3177,5,,void
196101,BLOCK,-1,,<empty>,25,,3184,2,,void
196111,BLOCK,1,,<empty>,,,,5,,void
196137,BLOCK,1,,<empty>,,,,5,,void
196163,BLOCK,1,,<empty>,,,,5,,void
196189,BLOCK,1,,<empty>,,,,5,,void
196215,BLOCK,1,,<empty>,,,,5,,void
196241,BLOCK,1,,<empty>,,,,5,,void
196264,BLOCK,1,,<empty>,,,,7,,void
196266,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBitfield)",3,,3207,1,,void
196363,BLOCK,1,,<empty>,,,,7,,void
196365,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionPriorityListenerCount)",3,,3208,1,,void
196462,BLOCK,1,,<empty>,,,,7,,void
196464,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionFrameErrorListenerCount)",3,,3209,1,,void
196561,BLOCK,1,,<empty>,,,,7,,void
196563,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxInvalidFrames)",3,,3210,1,,void
196660,BLOCK,1,,<empty>,,,,7,,void
196662,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxRejectedStreams)",3,,3211,1,,void
196759,BLOCK,1,,<empty>,,,,7,,void
196761,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionUint8FieldCount)",3,,3212,1,,void
196858,BLOCK,1,,<empty>,,,,7,,void
196860,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasRemoteSettingsListeners)",3,,3214,1,,void
196957,BLOCK,1,,<empty>,,,,7,,void
196959,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionRemoteSettingsIsUpToDate)",3,,3215,1,,void
197056,BLOCK,1,,<empty>,,,,7,,void
197058,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasPingListeners)",3,,3216,1,,void
197155,BLOCK,1,,<empty>,,,,7,,void
197157,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasAltsvcListeners)",3,,3217,1,,void
197680,BLOCK,1,,<empty>,,,,7,,void
197682,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NGHTTP2_DEFAULT_WEIGHT)",3,,3318,1,,void
197824,BLOCK,-1,,<empty>,1,,1,1,,ANY
197831,BLOCK,-1,,<empty>,1,,1,1,,ANY
197848,BLOCK,-1,,<empty>,1,,1,1,,ANY
197853,BLOCK,-1,,"{
  v8::Local<v8::Value> header_string =
      headers->Get(env->context(), 0).ToLocalChecked();
  v8::Local<v8::Value> header_count =
      headers->Get(env->context(), 1).ToLocalChecked();
  CHECK(header_count->IsUint32());
  CHECK(header_string->IsString());
  count_ = header_count.As<v8::Uint32>()->Value();
  int header_string_len = header_string.As<v8::String>()->Length();

  if (count_ == 0) {
    CHECK_EQ(header_string_len, 0);
    return;
  }

  buf_.AllocateSufficientStorage((alignof(nv_t) - 1) +
                                 count_ * sizeof(nv_t) +
                                 header_string_len);

  char* start = AlignUp(buf_.out(), alignof(nv_t));
  char* header_contents = start + (count_ * sizeof(nv_t));
  nv_t* const nva = reinterpret_cast<nv_t*>(start);

  CHECK_LE(header_contents + header_string_len, *buf_ + buf_.length());
  CHECK_EQ(header_string.As<v8::String>()->WriteOneByte(
               env->isolate(),
               reinterpret_cast<uint8_t*>(header_co...",73,,15,3,,void
197931,BLOCK,-1,,"{
    CHECK_EQ(header_string_len, 0);
    return;
  }",20,,25,2,,void
198016,BLOCK,-1,,<empty>,3,,49,1,,void
198027,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }

    nva[n].name = reinterpret_cast<uint8_t*>(p);
    nva[n].namelen = strlen(p);
    p += nva[n].namelen + 1;
    nva[n].value = reinterpret_cast<uint8_t*>(p);
    nva[n].valuelen = strlen(p);
    p += nva[n].valuelen + 1;
    nva[n].flags = *p;
    p++;
  }",75,,49,4,,void
198032,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }",22,,50,2,,void
198134,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 1;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,69,2,,void
198150,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 4;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,74,2,,void
198165,BLOCK,-1,,"{
  std::string ret = name();
  ret += "" = "";
  ret += value();
  return ret;
}",57,,80,1,,void
198183,BLOCK,-1,,"{
  return IsZeroLength(-1, name, value);
}",34,,90,3,,void
198196,BLOCK,-1,,"{

  if (NgHeader<T>::rcbufferpointer_t::IsZeroLength(value))
    return true;

  const char* header_name = T::ToHttpHeaderName(token);
  return header_name != nullptr ||
      NgHeader<T>::rcbufferpointer_t::IsZeroLength(name);
}",34,,98,4,,void
198207,BLOCK,-1,,<empty>,5,,101,2,,void
198239,BLOCK,-1,,<empty>,48,,114,5,,void
198248,BLOCK,-1,,"{
  if (token == -1) {
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }
  CHECK_NOT_NULL(value);
  name_.reset(name, true);  // Internalizable
  value_.reset(value);
}",62,,122,6,,void
198254,BLOCK,-1,,"{
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }",20,,123,2,,void
198280,BLOCK,-1,,"{
  other.token_ = -1;
  other.flags_ = 0;
  other.env_ = nullptr;
}",28,,138,2,,void
198301,BLOCK,-1,,"{
  tracker->TrackField(""name"", name_);
  tracker->TrackField(""value"", value_);
}",60,,145,2,,void
198318,BLOCK,-1,,"{

  // Not all instances will support using token id's for header names.
  // HTTP/2 specifically does not support it.
  const char* header_name = T::ToHttpHeaderName(token_);

  // If header_name is not nullptr, then it is a known header with
  // a statically defined name. We can safely internalize it here.
  if (header_name != nullptr) {
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }
  return rcbufferpointer_t::External::New(allocator, name_);
}",48,,152,2,,void
198331,BLOCK,-1,,"{
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }",31,,160,2,,void
198359,BLOCK,-1,,"{
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }",28,,163,2,,void
198409,BLOCK,-1,,"{
  return rcbufferpointer_t::External::New(allocator, value_);
}",48,,175,2,,void
198422,BLOCK,-1,,"{
  return name_.str();
}",39,,180,1,,void
198431,BLOCK,-1,,"{
  return value_.str();
}",40,,185,1,,void
198440,BLOCK,-1,,"{
  return name_.len() + value_.len();
}",36,,190,1,,void
198454,BLOCK,-1,,"{
  return flags_;
}",36,,195,1,,void
198469,BLOCK,-1,,<empty>,1,,1,1,,ANY
198472,BLOCK,-1,,"{
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",46,,761,1,,void
198484,BLOCK,-1,,<empty>,9,,763,2,,void
198491,BLOCK,-1,,<empty>,9,,765,1,,void
198526,BLOCK,-1,,<empty>,1,,1,1,,ANY
198593,BLOCK,-1,,"{
  return c == ' ' || c == '\t';
}",27,,90,2,,void
198608,BLOCK,-1,,<empty>,73,,96,3,,void
198617,BLOCK,-1,,"{
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",58,,103,2,,void
198631,BLOCK,-1,,<empty>,,,,1,,<empty>
198639,BLOCK,-1,,"{
    on_heap_ = false;
    Reset();
  }",15,,112,1,,void
198647,BLOCK,-1,,"{
    Reset();
  }",16,,118,1,,void
198652,BLOCK,-1,,"{
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",15,,126,1,,void
198660,BLOCK,-1,,"{
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }",33,,127,2,,void
198679,BLOCK,-1,,"{
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",16,,136,1,,void
198682,BLOCK,-1,,"{
      delete[] str_;
      on_heap_ = false;
    }",19,,137,2,,void
198699,BLOCK,-1,,"{
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",45,,147,3,,void
198704,BLOCK,-1,,"{
      str_ = str;
    }",26,,148,2,,void
198709,BLOCK,-1,,<empty>,12,,150,1,,void
198718,BLOCK,-1,,"{
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }",49,,150,2,,void
198736,BLOCK,-1,,<empty>,9,,158,2,,void
198740,BLOCK,-1,,<empty>,9,,160,1,,void
198754,BLOCK,-1,,"{
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",50,,168,2,,void
198759,BLOCK,-1,,<empty>,7,,170,2,,void
198769,BLOCK,-1,,<empty>,7,,172,1,,void
198783,BLOCK,-1,,"{
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",51,,177,2,,void
198795,BLOCK,-1,,"{
      size_--;
    }",49,,178,2,,void
198811,BLOCK,-1,,<empty>,,,,3,,<empty>
198817,BLOCK,-1,,<empty>,,,,2,,<empty>
198822,BLOCK,-1,,<empty>,,,,2,,<empty>
198827,BLOCK,-1,,<empty>,,,,2,,<empty>
198832,BLOCK,-1,,<empty>,,,,2,,<empty>
198837,BLOCK,-1,,<empty>,,,,2,,<empty>
198842,BLOCK,-1,,"{
      all_connections_.insert(parser);
    }",31,,208,2,,void
198852,BLOCK,-1,,"{
      all_connections_.erase(parser);
    }",30,,212,2,,void
198862,BLOCK,-1,,"{
      active_connections_.insert(parser);
    }",37,,216,2,,void
198872,BLOCK,-1,,"{
      active_connections_.erase(parser);
    }",36,,220,2,,void
198888,BLOCK,-1,,"{
  }",37,,247,3,,void
198895,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",45,,289,3,,void
198905,BLOCK,-1,,"{
      return rv;
    }",18,,291,2,,void
198921,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",48,,300,3,,void
198931,BLOCK,-1,,"{
      return rv;
    }",18,,302,2,,void
198947,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",54,,311,3,,void
198957,BLOCK,-1,,"{
      return rv;
    }",18,,313,2,,void
198964,BLOCK,-1,,"{
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }",37,,317,2,,void
198971,BLOCK,-1,,"{
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }",49,,320,2,,void
199012,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",54,,338,3,,void
199022,BLOCK,-1,,"{
      return rv;
    }",18,,340,2,,void
199029,BLOCK,-1,,"{
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }",37,,344,2,,void
199062,BLOCK,-1,,"{
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // Fast case, pass headers an...",29,,359,1,,void
199107,BLOCK,-1,,<empty>,7,,385,2,,void
199122,BLOCK,-1,,<empty>,5,,388,1,,void
199140,BLOCK,-1,,"{
      // Slow case, flush remaining headers.
      Flush();
    }",24,,391,2,,void
199143,BLOCK,-1,,"{
      // Fast case, pass headers and URL to JS land.
      argv[A_HEADERS] = CreateHeaders();
      if (parser_.type == HTTP_REQUEST)
        argv[A_URL] = url_.ToString(env());
    }",12,,394,1,,void
199155,BLOCK,-1,,<empty>,9,,398,2,,void
199177,BLOCK,-1,,"{
      argv[A_METHOD] =
          Uint32::NewFromUnsigned(env()->isolate(), parser_.method);
    }",39,,405,2,,void
199199,BLOCK,-1,,"{
      argv[A_STATUS_CODE] =
          Integer::New(env()->isolate(), parser_.status_code);
      argv[A_STATUS_MESSAGE] = status_message_.ToString(env());
    }",40,,411,2,,void
199293,BLOCK,21,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      head_response = cb.As<Function>()->Call(
          env()->context(), object(), arraysize(argv), argv);
      if (head_response.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,430,21,,void
199322,BLOCK,-1,,<empty>,36,,435,2,,void
199351,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",52,,442,2,,void
199367,BLOCK,-1,,"{
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",46,,451,3,,void
199372,BLOCK,-1,,<empty>,7,,453,2,,void
199412,BLOCK,-1,,<empty>,7,,461,2,,void
199450,BLOCK,-1,,"{
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }",22,,467,2,,void
199465,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exception_ = true;
      retur...",29,,477,1,,void
199476,BLOCK,-1,,"{
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }",38,,482,2,,void
199494,BLOCK,-1,,"{
      connectionsList_->Push(this);
    }",38,,489,2,,void
199502,BLOCK,-1,,<empty>,7,,494,2,,void
199535,BLOCK,-1,,<empty>,7,,501,2,,void
199543,BLOCK,11,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,504,11,,void
199571,BLOCK,-1,,<empty>,24,,508,2,,void
199581,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",22,,511,2,,void
199593,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",25,,520,1,,void
199602,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",27,,527,1,,void
199612,BLOCK,-1,,"{
    BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
    new Parser(binding_data, args.This());
  }",60,,532,2,,void
199634,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    delete parser;
  }",62,,538,2,,void
199649,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Since the Parser destructor isn't going to run the destroy() callbacks
    // it needs to be triggered manually.
    parser->EmitTraceEventDestroy();
    parser->EmitDestroy();
  }",61,,546,2,,void
199670,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",63,,556,2,,void
199685,BLOCK,-1,,"{
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }",46,,560,2,,void
199703,BLOCK,-1,,"{
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",15,,566,1,,void
199713,BLOCK,-1,,<empty>,5,,570,1,,void
199723,BLOCK,4,,"{
      fields_[i].Save();
    }",46,,570,4,,void
199731,BLOCK,-1,,<empty>,5,,574,1,,void
199741,BLOCK,4,,"{
      values_[i].Save();
    }",46,,574,4,,void
199752,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    ArrayBufferViewContents<char> buffer(args[0]);

    Local<Value> ret = parser->Execute(buffer.data(), buffer.length());

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",64,,580,2,,void
199790,BLOCK,-1,,<empty>,7,,589,2,,void
199803,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Value> ret = parser->Execute(nullptr, 0);

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",63,,593,2,,void
199830,BLOCK,-1,,<empty>,7,,600,2,,void
199843,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);
    Parser* parser;
    ASSIGN_OR_RETURN...",67,,604,2,,void
199885,BLOCK,-1,,"{
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }",28,,614,2,,void
199910,BLOCK,-1,,"{
      max_http_header_size = env->options()->max_http_header_size;
    }",36,,619,2,,void
199926,BLOCK,-1,,"{
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }",28,,623,2,,void
199960,BLOCK,-1,,"{
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }",61,,628,2,,void
200049,BLOCK,-1,,"{
      parser->connectionsList_ = connectionsList;

      // This protects from a DoS attack where an attacker establishes
      // the connection without sending any data on applications where
      // server.timeout is left to the default value of zero.
      parser->last_message_start_ = uv_hrtime();

      // Important: Push into the lists AFTER setting the last_message_start_
      // otherwise std::set.erase will fail later.
      parser->connectionsList_->Push(parser);
      parser->connectionsList_->PushActive(parser);
    }",37,,651,2,,void
200075,BLOCK,-1,,"{
      parser->connectionsList_ = nullptr;
    }",12,,663,1,,void
200085,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",62,,669,2,,void
200110,BLOCK,-1,,"{
      llhttp_pause(&parser->parser_);
    }",33,,676,2,,void
200117,BLOCK,-1,,"{
      llhttp_resume(&parser->parser_);
    }",12,,678,1,,void
200127,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    CHECK(args[0]->IsObject());
    StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
    CHECK_NOT_NULL(stream);
    stream->PushStreamListener(parser);
  }",64,,684,2,,void
200167,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Already unconsumed
    if (parser->stream_ == nullptr)
      return;

    parser->stream_->RemoveStreamListener(parser);
  }",66,,694,2,,void
200182,BLOCK,-1,,<empty>,7,,700,2,,void
200195,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",73,,706,2,,void
200239,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",65,,718,2,,void
200254,BLOCK,-1,,"{
      args.GetReturnValue().Set(0);
      return;
    }",43,,722,2,,void
200286,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",73,,731,2,,void
200310,BLOCK,-1,,"{
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",58,,741,2,,void
200315,BLOCK,-1,,<empty>,7,,746,2,,void
200333,BLOCK,-1,,<empty>,7,,750,2,,void
200354,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    // Once we’re done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didn’t come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_data_ = buf.base;

    MakeCallback(cb.As<Function>(), 1, &ret);...",66,,756,3,,void
200370,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
      return;
    }",20,,768,2,,void
200378,BLOCK,-1,,<empty>,7,,775,2,,void
200396,BLOCK,-1,,<empty>,7,,781,2,,void
200422,BLOCK,-1,,<empty>,7,,787,2,,void
200451,BLOCK,-1,,"{
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
      return scope.Escape(Local<Value>());

    Loc...",54,,800,3,,void
200472,BLOCK,-1,,"{
      err = llhttp_finish(&parser_);
    }",26,,809,2,,void
200479,BLOCK,-1,,"{
      err = llhttp_execute(&parser_, data, len);
      Save();
    }",12,,811,1,,void
200496,BLOCK,-1,,"{
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }",24,,818,2,,void
200508,BLOCK,-1,,"{
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }",38,,822,2,,void
200517,BLOCK,-1,,"{
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }",25,,829,2,,void
200532,BLOCK,-1,,<empty>,7,,839,2,,void
200563,BLOCK,-1,,"{
      Local<Value> e = Exception::Error(env()->parse_error_string());
      Local<Object> obj = e->ToObject(env()->isolate()->GetCurrentContext())
        .ToLocalChecked();
      obj->Set(env()->context(),
               env()->bytes_parsed_string(),
               nread_obj).Check();
      const char* errno_reason = llhttp_get_error_reason(&parser_);

      Local<String> code;
      Local<String> reason;
      if (err == HPE_USER) {
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      } else {
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }

      obj->Set(env()->context(), env()->code_string(), code).Check();
      obj->Set(env(...",44,,845,2,,void
200634,BLOCK,-1,,"{
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      }",28,,856,2,,void
200667,BLOCK,-1,,"{
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }",14,,863,1,,void
200727,BLOCK,-1,,"{
      return scope.Escape(Local<Value>());
    }",26,,874,2,,void
200743,BLOCK,-1,,"{
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",32,,880,1,,void
200754,BLOCK,-1,,<empty>,5,,884,1,,void
200764,BLOCK,4,,"{
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }",46,,884,4,,void
200809,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",16,,894,1,,void
200847,BLOCK,-1,,<empty>,7,,901,2,,void
200876,BLOCK,-1,,<empty>,7,,913,2,,void
200893,BLOCK,-1,,"{
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",37,,921,4,,void
200904,BLOCK,-1,,"{
      llhttp_set_lenient_headers(&parser_, 1);
    }",42,,924,2,,void
200913,BLOCK,-1,,"{
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }",48,,927,2,,void
200922,BLOCK,-1,,"{
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }",44,,930,2,,void
200960,BLOCK,-1,,"{
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",31,,946,2,,void
200968,BLOCK,-1,,"{
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }",49,,948,2,,void
200980,BLOCK,-1,,"{
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",20,,956,1,,void
200984,BLOCK,-1,,"{
      return 0;
    }",26,,957,2,,void
200999,BLOCK,-1,,"{
    // HTTP parsers are able to emit events without any GC root referring
    // to them, because they receive events directly from the underlying
    // libuv resource.
    return true;
  }",59,,967,1,,void
201027,BLOCK,-1,,"{
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",48,,1000,3,,void
201055,BLOCK,-1,,"{
        rv = parser->MaybePause();
      }",20,,1003,2,,void
201067,BLOCK,-1,,<empty>,,,,1,,<empty>
201073,BLOCK,-1,,<empty>,,,,3,,<empty>
201078,BLOCK,-1,,<empty>,,,,1,,<empty>
201102,BLOCK,-1,,"{
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",79,,1016,3,,void
201115,BLOCK,-1,,"{
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  }",71,,1017,2,,void
201121,BLOCK,-1,,<empty>,10,,1021,1,,void
201128,BLOCK,-1,,"{
    return true;
  }",45,,1021,2,,void
201132,BLOCK,-1,,<empty>,10,,1023,1,,void
201139,BLOCK,-1,,"{
    return false;
  }",45,,1023,2,,void
201154,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);

  new ConnectionsList(env, args.This());
}",68,,1030,2,,void
201187,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",68,,1037,2,,void
201227,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",46,,1046,3,,void
201261,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",69,,1054,2,,void
201301,BLOCK,-1,,"{
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }",46,,1063,3,,void
201308,BLOCK,-1,,"{
      result.emplace_back(parser->object());
    }",43,,1064,2,,void
201342,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",71,,1073,2,,void
201382,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",49,,1082,3,,void
201416,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  // On IoT or embedded devices the uv_hrtime() may return the timestamp
  // that is smaller than configured timeout for headers or request
  // to prevent subtracting two unsigned integers
  // that can yield incorrect results we should check
  // if the 'now' is bigger than the timeout for headers or request
  const uint64_t now = uv_hrtime();
  const uint64_t headers_deadlin...",72,,1090,2,,void
201486,BLOCK,-1,,"{
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  }",53,,1103,2,,void
201502,BLOCK,-1,,<empty>,10,,1105,1,,void
201511,BLOCK,-1,,"{
    std::swap(headers_timeout, request_timeout);
  }",72,,1105,2,,void
201560,BLOCK,-1,,"{
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  }",55,,1122,2,,void
201616,BLOCK,-1,,"{
    Parser* parser = *iter;
    iter++;

    // Check for expiration.
    if (
      (!parser->headers_completed_ && headers_deadline > 0 &&
        parser->last_message_start_ < headers_deadline) ||
      (
        request_deadline > 0 &&
        parser->last_message_start_ < request_deadline)
    ) {
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }
  }",23,,1131,2,,void
201649,BLOCK,-1,,"{
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }",7,,1142,2,,void
201740,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, Parser::New);
  t->InstanceTemplate()->SetInternalFieldCount(Parser::kInternalFieldCount);

  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""REQUEST""),
         Integer::New(env->isolate(), HTTP_REQUEST));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""RESPONSE""),
         Integer::New(env->isolate(), HTTP_RESPONSE));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnMessageBegin""),
         Integer::NewFromUnsigned(env->isolate(), kOnMessageBegin));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeaders""),
         Integer::NewFromUnsigned(env->isolate(), kOnHeaders));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeadersComplete""),
         Integer::NewFromUnsigne...",39,,1202,5,,void
201780,BLOCK,-1,,<empty>,32,,1208,2,,void
202317,BLOCK,-1,,<empty>,1,,1,1,,ANY
202334,BLOCK,-1,,<empty>,1,,1,1,,ANY
202363,BLOCK,-1,,<empty>,1,,1,1,,ANY
202378,BLOCK,-1,,<empty>,1,,1,1,,ANY
202382,BLOCK,-1,,"{
  return node::Start(argc, argv);
}",34,,96,3,,void
202428,BLOCK,-1,,<empty>,1,,1,1,,ANY
202436,BLOCK,-1,,"{
  isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();

  isolate_ =
      NewIsolate(isolate_params_.get(), event_loop, platform, snapshot_data);
  CHECK_NOT_NULL(isolate_);

  // If the indexes are not nullptr, we are not deserializing
  isolate_data_.reset(
      CreateIsolateData(isolate_,
                        event_loop,
                        platform,
                        array_buffer_allocator_.get(),
                        snapshot_data->AsEmbedderWrapper().get()));
  isolate_data_->set_is_building_snapshot(
      per_process::cli_options->per_isolate->build_snapshot);

  isolate_data_->max_young_gen_size =
      isolate_params_->constraints.max_young_generation_size_in_bytes();
}",37,,45,6,,void
202499,BLOCK,-1,,"{
  if (isolate_params_ == nullptr) {
    return;
  }
  // This should only be done on a main instance that owns its isolate.
  platform_->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}",39,,66,1,,void
202504,BLOCK,-1,,"{
    return;
  }",35,,67,2,,void
202518,BLOCK,-1,,"{
  Locker locker(isolate_);
  Isolate::Scope isolate_scope(isolate_);
  HandleScope handle_scope(isolate_);

  ExitCode exit_code = ExitCode::kNoFailure;
  DeleteFnPtr<Environment, FreeEnvironment> env =
      CreateMainEnvironment(&exit_code);
  CHECK_NOT_NULL(env);

  Context::Scope context_scope(env->context());
  Run(&exit_code, env.get());
  return exit_code;
}",34,,75,1,,void
202566,BLOCK,-1,,"{
  if (*exit_code == ExitCode::kNoFailure) {
    bool runs_sea_code = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }
#endif
    if (!runs_sea_code) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }

#if defined(LEAK_SANITIZER)
  __lsan_do_leak_check();
#endif
}",67,,90,3,,void
202574,BLOCK,-1,,"{
    bool runs_sea_code = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }
#endif
    if (!runs_sea_code) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }",43,,91,2,,void
202584,BLOCK,-1,,"{
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }",36,,94,2,,void
202607,BLOCK,-1,,"{
      LoadEnvironment(env, StartExecutionCallback{});
    }",25,,101,2,,void
202627,BLOCK,-1,,"{
  *exit_code = ExitCode::kNoFailure;  // Reset the exit code to 0

  HandleScope handle_scope(isolate_);

  // TODO(addaleax): This should load a real per-Isolate option, currently
  // this is still effectively per-process.
  if (isolate_data_->options()->track_heap_objects) {
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }

  Local<Context> context;
  DeleteFnPtr<Environment, FreeEnvironment> env;

  if (snapshot_data_ != nullptr) {
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  } else {
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }

  return env;
}",62,,115,2,,void
202644,BLOCK,-1,,"{
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }",53,,122,2,,void
202669,BLOCK,-1,,"{
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  }",34,,129,2,,void
202683,BLOCK,-1,,"{
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }",10,,137,1,,void
202731,BLOCK,-1,,<empty>,1,,1,1,,ANY
202740,BLOCK,-1,,<empty>,1,,1,1,,ANY
202747,BLOCK,-1,,<empty>,1,,1,1,,ANY
202750,BLOCK,-1,,"{
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  }",37,,166,1,,void
202754,BLOCK,-1,,"{
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }",59,,167,3,,void
202758,BLOCK,-1,,<empty>,20,,168,2,,void
202770,BLOCK,-1,,"{
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  }",43,,641,2,,void
202791,BLOCK,-1,,{ if (!succeeded) Close(); },37,,652,1,,void
202795,BLOCK,-1,,<empty>,55,,652,2,,void
202823,BLOCK,-1,,<empty>,1,,1,1,,ANY
202834,BLOCK,-1,,"{
  return BaseObject::TransferMode::kUntransferable;
}",62,,50,1,,void
202844,BLOCK,-1,,"{
  return CloneForMessaging();
}",74,,54,1,,void
202850,BLOCK,-1,,"{
  return {};
}",77,,58,1,,void
202855,BLOCK,-1,,"{
  return Just(BaseObjectList {});
}",63,,62,1,,void
202865,BLOCK,-1,,"{
  return Just(true);
}",62,,67,3,,void
202875,BLOCK,-1,,"{
  return Just(true);
}",58,,74,3,,void
202883,BLOCK,-1,,<empty>,44,,79,2,,void
202887,BLOCK,-1,,"{
  return main_message_buf_.data == nullptr;
}",38,,81,1,,void
202905,BLOCK,-1,,<empty>,55,,101,7,,void
202910,BLOCK,-1,,"{
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",64,,103,2,,void
202920,BLOCK,-1,,<empty>,7,,107,2,,void
202927,BLOCK,-1,,"{
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }",30,,108,2,,void
202972,BLOCK,-1,,<empty>,7,,116,2,,void
202994,BLOCK,-1,,"{
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",53,,122,3,,void
203010,BLOCK,-1,,"{
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",56,,128,3,,void
203030,BLOCK,-1,,"{
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",80,,134,2,,void
203050,BLOCK,-1,,<empty>,,,,1,,<empty>
203060,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  });

  for (uint32_t i = 0; i < transferables_.size(); ++i) {
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    h...",65,,152,4,,void
203077,BLOCK,-1,,"{
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }",56,,156,2,,void
203114,BLOCK,-1,,<empty>,3,,177,1,,void
203127,BLOCK,4,,"{
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    host_objects[i] = data->Deserialize(
        env, context, std::move(transferables_[i]));
    if (!host_objects[i]) return {};
    if (port_list != nullptr) {
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }
  }",56,,177,4,,void
203165,BLOCK,-1,,<empty>,27,,182,2,,void
203171,BLOCK,-1,,"{
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }",31,,183,2,,void
203209,BLOCK,-1,,"{
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }",71,,191,2,,void
203224,BLOCK,-1,,"{
          return {};
        }",52,,194,2,,void
203240,BLOCK,-1,,<empty>,3,,204,1,,void
203253,BLOCK,4,,"{
    Local<SharedArrayBuffer> sab =
        SharedArrayBuffer::New(env->isolate(), shared_array_buffers_[i]);
    shared_array_buffers.push_back(sab);
  }",63,,204,4,,void
203307,BLOCK,-1,,<empty>,3,,224,1,,void
203320,BLOCK,4,,"{
    Local<ArrayBuffer> ab =
        ArrayBuffer::New(env->isolate(), std::move(array_buffers_[i]));
    deserializer.TransferArrayBuffer(i, ab);
  }",56,,224,4,,void
203357,BLOCK,-1,,<empty>,5,,231,2,,void
203376,BLOCK,-1,,<empty>,5,,234,2,,void
203381,BLOCK,-1,,"{
    if (base_object->FinalizeTransferRead(context, &deserializer).IsNothing())
      return {};
  }",62,,236,3,,void
203393,BLOCK,-1,,<empty>,7,,238,2,,void
203409,BLOCK,-1,,"{
  shared_array_buffers_.emplace_back(std::move(backing_store));
}",50,,246,2,,void
203423,BLOCK,-1,,"{
  transferables_.emplace_back(std::move(data));
}",69,,250,2,,void
203437,BLOCK,-1,,"{
  wasm_modules_.emplace_back(std::move(mod));
  return wasm_modules_.size() - 1;
}",59,,254,2,,void
203458,BLOCK,-1,,"{
  shared_value_conveyor_.emplace(std::move(conveyor));
}",72,,259,2,,void
203473,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> emit_message_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""emitMessage""))
          .ToLocal(&emit_message_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(emit_message_val->IsFunction());
  return emit_message_val.As<Function>();
}",69,,265,2,,void
203515,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",40,,272,2,,void
203532,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> domexception_ctor_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""DOMException""))
          .ToLocal(&domexception_ctor_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(domexception_ctor_val->IsFunction());
  Local<Function> domexception_ctor = domexception_ctor_val.As<Function>();
  return domexception_ctor;
}",62,,279,2,,void
203574,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",45,,286,2,,void
203599,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Value> argv[] = {message,
                         FIXED_ONE_BYTE_STRING(isolate, ""DataCloneError"")};
  Local<Value> exception;
  Local<Function> domexception_ctor;
  if (!GetDOMException(context).ToLocal(&domexception_ctor) ||
      !domexception_ctor->NewInstance(context, arraysize(argv), argv)
           .ToLocal(&exception)) {
    return;
  }
  isolate->ThrowException(exception);
}",77,,294,3,,void
203649,BLOCK,-1,,"{
    return;
  }",34,,302,2,,void
203663,BLOCK,-1,,<empty>,47,,314,4,,void
203668,BLOCK,-1,,"{
    ThrowDataCloneException(context_, message);
  }",60,,316,2,,void
203677,BLOCK,-1,,"{
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }

    ThrowDataCloneError(env_->clone_unsupported_typ...",80,,320,3,,void
203684,BLOCK,-1,,"{
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }",43,,321,2,,void
203713,BLOCK,-1,,"{
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }",55,,329,2,,void
203768,BLOCK,-1,,"{
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",62,,347,3,,void
203771,BLOCK,-1,,<empty>,5,,349,1,,void
203783,BLOCK,4,,"{
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }",61,,349,4,,void
203794,BLOCK,-1,,"{
        return Just(i);
      }",32,,351,2,,void
203822,BLOCK,-1,,"{
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",66,,363,3,,void
203838,BLOCK,-1,,"{
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",74,,368,3,,void
203854,BLOCK,-1,,"{
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",46,,373,2,,void
203856,BLOCK,-1,,<empty>,5,,374,1,,void
203869,BLOCK,4,,"{
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }",57,,374,4,,void
203894,BLOCK,-1,,<empty>,9,,378,2,,void
203904,BLOCK,-1,,<empty>,9,,380,2,,void
203914,BLOCK,-1,,<empty>,18,,381,2,,void
203927,BLOCK,-1,,<empty>,9,,383,2,,void
203946,BLOCK,-1,,"{
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",68,,389,2,,void
203962,BLOCK,-1,,"{
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",45,,398,1,,void
203964,BLOCK,-1,,<empty>,5,,399,1,,void
203977,BLOCK,4,,"{
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }",55,,399,4,,void
204000,BLOCK,-1,,<empty>,9,,402,2,,void
204006,BLOCK,-1,,"{
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }",62,,403,3,,void
204026,BLOCK,-1,,"{
          AddHostObject(nested_transferable);
        }",68,,406,2,,void
204037,BLOCK,-1,,"{
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",70,,417,2,,void
204053,BLOCK,-1,,"{
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }",60,,419,2,,void
204062,BLOCK,-1,,<empty>,5,,424,1,,void
204075,BLOCK,4,,"{
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }",57,,424,4,,void
204082,BLOCK,-1,,"{
        serializer->WriteUint32(i);
        return Just(true);
      }",44,,425,2,,void
204099,BLOCK,-1,,"{
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }",58,,431,2,,void
204122,BLOCK,-1,,<empty>,7,,439,2,,void
204149,BLOCK,-1,,<empty>,,,,1,,<empty>
204164,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does ...",59,,461,6,,void
204208,BLOCK,-1,,<empty>,3,,473,1,,void
204221,BLOCK,4,,"{
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does not return kUntransferable.
    if (entry->IsArrayBuffer()) {
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Node’s ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rat...",59,,473,4,,void
204236,BLOCK,-1,,"{
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }",28,,475,2,,void
204257,BLOCK,-1,,"{
        return Nothing<bool>();
      }",37,,482,2,,void
204262,BLOCK,-1,,<empty>,27,,485,2,,void
204269,BLOCK,-1,,"{
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Node’s ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rather than
      // raw data *and* an Isolate with a non-default ArrayBuffer allocator
      // is always going to outlive any Workers it creates, and so will its
      // allocator along with it.
      if (!ab->IsDetachable()) continue;
      if (std::find(array_buffers.begin(), array_buffers.end(), ab) !=
          array_buffers.end()) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }
      // We simply use the array index i...",33,,490,2,,void
204286,BLOCK,-1,,<empty>,32,,500,2,,void
204307,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }",32,,502,2,,void
204338,BLOCK,-1,,<empty>,12,,516,1,,void
204353,BLOCK,-1,,"{
      // Check if the source MessagePort is being transferred.
      if (!source_port.IsEmpty() && entry == source_port) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }
      BaseObjectPtr<BaseObject> host_object {
          Unwrap<BaseObject>(entry.As<Object>()) };
      if (env->message_port_constructor_template()->HasInstance(entry) &&
          (!host_object ||
           static_cast<MessagePort*>(host_object.get())->IsDetached())) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }
      if (std::find(delegate.host_objects_.begin(),
                    delegate.host_objects_.end(),
                    host_object) != delegate.hos...",62,,517,2,,void
204364,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }",59,,519,2,,void
204411,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }",73,,530,2,,void
204447,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            String::Concat(env->isolate(),
                FIXED_ONE_BYTE_STRING(
                  env->isolate(),
                  ""Transfer list contains duplicate ""),
                entry.As<Object>()->GetConstructorName()));
        return Nothing<bool>();
      }",67,,540,2,,void
204486,BLOCK,-1,,"{
        delegate.AddHostObject(host_object);
        continue;
      }",58,,551,2,,void
204505,BLOCK,-1,,<empty>,5,,561,2,,void
204522,BLOCK,-1,,"{
    return Nothing<bool>();
  }",58,,564,2,,void
204528,BLOCK,-1,,"{
    // If serialization succeeded, we render it inaccessible in this Isolate.
    std::shared_ptr<BackingStore> backing_store = ab->GetBackingStore();
    ab->Detach(Local<Value>()).Check();

    array_buffers_.emplace_back(std::move(backing_store));
  }",47,,568,3,,void
204567,BLOCK,-1,,<empty>,5,,577,2,,void
204599,BLOCK,-1,,"{
  tracker->TrackField(""array_buffers_"", array_buffers_);
  tracker->TrackField(""shared_array_buffers"", shared_array_buffers_);
  tracker->TrackField(""transferables"", transferables_);
}",56,,587,2,,void
204622,BLOCK,-1,,"{
}",21,,594,2,,void
204626,BLOCK,-1,,"{
  CHECK_NULL(owner_);
  Disentangle();
}",37,,597,1,,void
204633,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  tracker->TrackField(""incoming_messages"", incoming_messages_);
}",64,,602,2,,void
204647,BLOCK,-1,,"{
  // This function will be called by other threads.
  Mutex::ScopedLock lock(mutex_);
  incoming_messages_.emplace_back(std::move(message));

  if (owner_ != nullptr) {
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }
}",76,,607,2,,void
204664,BLOCK,-1,,"{
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }",26,,612,2,,void
204677,BLOCK,-1,,"{
  auto group = std::make_shared<SiblingGroup>();
  group->Entangle({a, b});
}",72,,618,3,,void
204695,BLOCK,-1,,"{
  if (group_) {
    group_->Disentangle(this);
  }
}",37,,623,1,,void
204698,BLOCK,-1,,"{
    group_->Disentangle(this);
  }",15,,624,2,,void
204707,BLOCK,-1,,"{
  if (data_) Detach();
}",29,,629,1,,void
204710,BLOCK,-1,,<empty>,14,,630,2,,void
204718,BLOCK,-1,,"{
  auto onmessage = [](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  };

  CHECK_EQ(uv_async_init(env->event_loop(),
                         &async_,
                         onmessage), 0);
  // Reset later to indicate success of the constructor.
  bool succeeded = false;
  auto cleanup = OnScopeLeave([&]() { if (!succeeded) Close(); });

  Local<Value> fn;
  if (!wrap->Get(context, env->oninit_symbol()).ToLocal(&fn))
    return;

  if (fn->IsFunction()) {
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }

  Local<Function> emit_message_fn;
  if (!GetEmitMessageFunction(context).ToLocal(&emit_message_fn))
    return;
  emit_message_fn_.Reset(env->isolate(), emit_message_fn);

  succeeded = true;
  Debug(this, ""Created message port"");
}",38,,640,4,,void
204762,BLOCK,-1,,<empty>,5,,656,2,,void
204769,BLOCK,-1,,"{
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }",25,,658,2,,void
204792,BLOCK,-1,,<empty>,7,,661,2,,void
204808,BLOCK,-1,,<empty>,5,,666,2,,void
204828,BLOCK,-1,,"{
  return data_ == nullptr || IsHandleClosing();
}",38,,673,1,,void
204838,BLOCK,-1,,"{
  if (IsHandleClosing()) return;
  CHECK_EQ(uv_async_send(&async_), 0);
}",34,,677,1,,void
204841,BLOCK,-1,,<empty>,26,,678,2,,void
204852,BLOCK,-1,,"{
  Debug(this, ""Closing message port, data set = %d"", static_cast<int>(!!data_));

  if (data_) {
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  } else {
    HandleWrap::Close(close_callback);
  }
}",62,,682,2,,void
204863,BLOCK,-1,,"{
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  }",14,,685,2,,void
204875,BLOCK,-1,,"{
    HandleWrap::Close(close_callback);
  }",10,,690,1,,void
204885,BLOCK,-1,,"{
  // This constructor just throws an error. Unfortunately, we can’t use V8’s
  // ConstructorBehavior::kThrow, as that also removes the prototype from the
  // class (i.e. makes it behave like an arrow function).
  Environment* env = Environment::GetCurrent(args);
  THROW_ERR_CONSTRUCT_CALL_INVALID(env);
}",64,,695,2,,void
204903,BLOCK,-1,,"{
  Context::Scope context_scope(context);
  Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env);

  // Construct a new instance, then assign the listener instance and possibly
  // the MessagePortData to it.
  Local<Object> instance;
  if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance))
    return nullptr;
  MessagePort* port = new MessagePort(env, context, instance);
  CHECK_NOT_NULL(port);
  if (port->IsHandleClosing()) {
    // Construction failed with an exception.
    return nullptr;
  }

  if (data) {
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, t...",50,,707,5,,void
204935,BLOCK,-1,,<empty>,5,,715,2,,void
204953,BLOCK,-1,,"{
    // Construction failed with an exception.
    return nullptr;
  }",32,,718,2,,void
204958,BLOCK,-1,,"{
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, this is
    // the easiest way to run that queue.
    port->TriggerAsync();
  }",13,,723,2,,void
204994,BLOCK,-1,,<empty>,10,,736,1,,void
204997,BLOCK,-1,,"{
    sibling_group->Entangle(port->data_.get());
  }",29,,736,2,,void
205016,BLOCK,-1,,"{
  std::shared_ptr<Message> received;
  {
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }

  if (received->IsCloseMessage()) {
    Close();
    return env()->no_message_symbol();
  }

  if (!env()->can_call_into_js()) return MaybeLocal<Value>();

  return received->Deserialize(env(), context, port_list);
}",72,,744,4,,void
205024,BLOCK,2,,"{
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }",3,,746,2,,void
205064,BLOCK,-1,,"{
      return env()->no_message_symbol();
    }",65,,761,2,,void
205089,BLOCK,-1,,"{
    Close();
    return env()->no_message_symbol();
  }",35,,769,2,,void
205102,BLOCK,-1,,<empty>,35,,774,2,,void
205117,BLOCK,-1,,"{
  Debug(this, ""Running MessagePort::OnMessage()"");
  HandleScope handle_scope(env()->isolate());
  Local<Context> context =
      object(env()->isolate())->GetCreationContext().ToLocalChecked();

  size_t processing_limit;
  if (mode == MessageProcessingMode::kNormalOperation) {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  } else {
    processing_limit = std::numeric_limits<size_t>::max();
  }

  // data_ can only ever be modified by the owner thread, so no need to lock.
  // However, the message port may be transferred while it is processing
  // messages, so we need to check that this handle still owns its `data_` field
  // on every iteration.
  while (data_) {
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      /...",57,,779,2,,void
205151,BLOCK,-1,,"{
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  }",56,,786,2,,void
205175,BLOCK,-1,,"{
    processing_limit = std::numeric_limits<size_t>::max();
  }",10,,790,1,,void
205190,BLOCK,-1,,"{
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }

    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(context);
    Local<Function> emit_message = PersistentToLocal::Strong(emit_message_fn_);

    Local<Value> payload;
    Local<Value> port_list = Undefined(env()->isolate());
    Local<Value> message_error;
    Local<Value> argv[3];

    {
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catc...",17,,798,2,,void
205196,BLOCK,-1,,"{
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }",34,,799,2,,void
205247,BLOCK,11,,"{
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catch(env());
      if (!ReceiveMessage(context, mode, &port_list).ToLocal(&payload)) {
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }
    }",5,,820,11,,void
205263,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }",73,,824,2,,void
205275,BLOCK,-1,,<empty>,11,,826,2,,void
205290,BLOCK,-1,,<empty>,48,,830,2,,void
205298,BLOCK,-1,,"{
      Debug(this, ""MessagePort drains queue because !can_call_into_js()"");
      // In this case there is nothing to do but to drain the current queue.
      continue;
    }",37,,832,2,,void
205330,BLOCK,-1,,"{
    reschedule:
      if (!message_error.IsEmpty()) {
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }

      // Re-schedule OnMessage() execution in case of failure.
      if (data_)
        TriggerAsync();
      return;
    }",70,,842,2,,void
205338,BLOCK,-1,,"{
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }",37,,844,2,,void
205364,BLOCK,-1,,<empty>,9,,853,2,,void
205370,BLOCK,-1,,"{
  Debug(this, ""MessagePort::OnClose()"");
  if (data_) {
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }
}",29,,859,1,,void
205376,BLOCK,-1,,"{
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }",14,,861,2,,void
205384,BLOCK,-1,,"{
  CHECK(data_);
  Mutex::ScopedLock lock(data_->mutex_);
  data_->owner_ = nullptr;
  return std::move(data_);
}",56,,867,1,,void
205405,BLOCK,-1,,"{
  if (IsDetached())
    return BaseObject::TransferMode::kUntransferable;
  return BaseObject::TransferMode::kTransferable;
}",63,,874,1,,void
205408,BLOCK,-1,,<empty>,5,,876,2,,void
205424,BLOCK,-1,,"{
  Close();
  return Detach();
}",67,,880,1,,void
205434,BLOCK,-1,,"{
  return BaseObjectPtr<MessagePort> { MessagePort::New(
      env, context,
      static_unique_pointer_cast<MessagePortData>(std::move(self))) };
}",41,,888,4,,void
205460,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Object> obj = object(isolate);

  std::shared_ptr<Message> msg = std::make_shared<Message>();

  // Per spec, we need to both check if transfer list has the source port, and
  // serialize the input message, even if the MessagePort is closed or detached.

  Maybe<bool> serialization_maybe =
      msg->Serialize(env, context, message_v, transfer_v, obj);
  if (data_ == nullptr) {
    return serialization_maybe;
  }
  if (serialization_maybe.IsNothing()) {
    return Nothing<bool>();
  }

  std::string error;
  Maybe<bool> res = data_->Dispatch(msg, &error);
  if (res.IsNothing())
    return res;

  if (!error.empty())
    ProcessEmitWarning(env, error.c_str());

  return res;
}",70,,897,5,,void
205504,BLOCK,-1,,"{
    return serialization_maybe;
  }",25,,908,2,,void
205512,BLOCK,-1,,"{
    return Nothing<bool>();
  }",40,,911,2,,void
205531,BLOCK,-1,,<empty>,5,,918,2,,void
205540,BLOCK,-1,,<empty>,5,,921,2,,void
205554,BLOCK,-1,,"{
  if (!group_) {
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }
  return group_->Dispatch(this, message, error);
}",25,,928,3,,void
205558,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }",16,,929,2,,void
205563,BLOCK,-1,,<empty>,7,,931,2,,void
205585,BLOCK,-1,,"{
  if (!object->IsObject()) return Just(false);

  if (object->IsArray()) {
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }

  Isolate* isolate = env->isolate();
  Local<Value> iterator_method;
  if (!object.As<Object>()->Get(context, Symbol::GetIterator(isolate))
      .ToLocal(&iterator_method)) return Nothing<bool>();
  if (!iterator_method->IsFunction()) return Just(false);

  Local<Value> iterator;
  if (!iterator_method.As<Function>()->Call(context, object, 0, nullptr)
      .ToLocal(&iterator)) return Nothing<bool>();
  if (!iterator->IsObject()) return Just(false);

  Local<Value> next;
  if (!iterator.As<Object>()->Get(context, env->next_string()).ToLocal(&next))
    return Nothing<bool>();
  if (!next->IsFunction()) return Jus...",54,,941,5,,void
205592,BLOCK,-1,,<empty>,28,,942,2,,void
205601,BLOCK,-1,,"{
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }",26,,944,2,,void
205625,BLOCK,-1,,<empty>,5,,948,1,,void
205635,BLOCK,4,,"{
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }",41,,948,4,,void
205651,BLOCK,-1,,<empty>,9,,950,2,,void
205689,BLOCK,-1,,<empty>,35,,958,2,,void
205698,BLOCK,-1,,<empty>,39,,959,2,,void
205725,BLOCK,-1,,<empty>,28,,963,2,,void
205734,BLOCK,-1,,<empty>,30,,964,2,,void
205762,BLOCK,-1,,<empty>,5,,968,2,,void
205771,BLOCK,-1,,<empty>,28,,969,2,,void
205789,BLOCK,-1,,"{
    Local<Value> result;
    if (!next.As<Function>()->Call(context, iterator, 0, nullptr)
        .ToLocal(&result)) return Nothing<bool>();
    if (!result->IsObject()) return Just(false);

    Local<Value> done;
    if (!result.As<Object>()->Get(context, env->done_string()).ToLocal(&done))
      return Nothing<bool>();
    if (done->BooleanValue(isolate)) break;

    Local<Value> val;
    if (!result.As<Object>()->Get(context, env->value_string()).ToLocal(&val))
      return Nothing<bool>();
    entries.push_back(val);
  }",35,,972,2,,void
205813,BLOCK,-1,,<empty>,28,,975,2,,void
205822,BLOCK,-1,,<empty>,30,,976,2,,void
205850,BLOCK,-1,,<empty>,7,,980,2,,void
205859,BLOCK,-1,,<empty>,38,,981,2,,void
205885,BLOCK,-1,,<empty>,7,,985,2,,void
205924,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> obj = args.This();
  Local<Context> context = obj->GetCreationContext().ToLocalChecked();

  if (args.Length() == 0) {
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }

  if (!args[1]->IsNullOrUndefined() && !args[1]->IsObject()) {
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }

  TransferList transfer_list;
  if (args[1]->IsObject()) {
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) ...",72,,994,2,,void
205963,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }",27,,999,2,,void
205984,BLOCK,-1,,"{
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }",62,,1004,2,,void
205997,BLOCK,-1,,"{
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }
  }",28,,1012,2,,void
206013,BLOCK,-1,,<empty>,7,,1015,2,,void
206018,BLOCK,-1,,"{
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }",24,,1016,2,,void
206045,BLOCK,-1,,<empty>,39,,1019,2,,void
206053,BLOCK,-1,,"{
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }",44,,1020,2,,void
206066,BLOCK,-1,,<empty>,33,,1022,2,,void
206071,BLOCK,-1,,"{
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }",28,,1023,2,,void
206096,BLOCK,-1,,"{
    Message msg;
    USE(msg.Serialize(env, context, args[0], transfer_list, obj));
    return;
  }",51,,1035,2,,void
206129,BLOCK,-1,,<empty>,5,,1043,2,,void
206144,BLOCK,-1,,"{
  Debug(this, ""Start receiving messages"");
  receiving_messages_ = true;
  Mutex::ScopedLock lock(data_->mutex_);
  if (!data_->incoming_messages_.empty())
    TriggerAsync();
}",27,,1046,1,,void
206164,BLOCK,-1,,<empty>,5,,1051,2,,void
206169,BLOCK,-1,,"{
  Debug(this, ""Stop receiving messages"");
  receiving_messages_ = false;
}",26,,1054,1,,void
206180,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());
  if (!port->data_) {
    return;
  }
  port->Start();
}",66,,1059,2,,void
206194,BLOCK,-1,,"{
    return;
  }",21,,1062,2,,void
206204,BLOCK,-1,,"{
  MessagePort* port;
  CHECK(args[0]->IsObject());
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  if (!port->data_) {
    return;
  }
  port->Stop();
}",65,,1068,2,,void
206227,BLOCK,-1,,"{
    return;
  }",21,,1072,2,,void
206237,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      GetMessagePortConstructorTemplate(env)->HasInstance(args[0]));
}",70,,1078,2,,void
206265,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  port->OnMessage(MessageProcessingMode::kForceReadMessages);
}",66,,1084,2,,void
206287,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr) {
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }

  MaybeLocal<Value> payload = port->ReceiveMessage(
      port->object()->GetCreationContext().ToLocalChecked(),
      MessageProcessingMode::kForceReadMessages);
  if (!payload.IsEmpty())
    args.GetReturnValue().Set(payload.ToLocalChecked());
}",75,,1090,2,,void
206316,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1093,2,,void
206338,BLOCK,-1,,"{
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }",24,,1098,2,,void
206384,BLOCK,-1,,<empty>,5,,1109,2,,void
206400,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr || port->IsHandleClosing()) {
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }

  Local<Value> context_arg = args[1];
  ContextifyContext* context_wrapper;
  if (!context_arg->IsObject() ||
      (context_wrapper = ContextifyContext::ContextFromContextifiedSandbox(
          env, context_arg.As<Object>())) == nullptr) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }

  std::unique_ptr<MessagePortData> data;
  if (!port->IsDetached())
    data = port->Detach();

  Context::Scope context_scope(context_wrapper->context());
  MessagePort* target =
      Messag...",74,,1112,2,,void
206429,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1115,2,,void
206456,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }",51,,1120,2,,void
206497,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }",55,,1130,2,,void
206515,BLOCK,-1,,<empty>,5,,1136,2,,void
206549,BLOCK,-1,,<empty>,5,,1142,2,,void
206566,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b->data_.get());
}",60,,1145,3,,void
206588,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b);
}",64,,1149,3,,void
206604,BLOCK,-1,,"{
  tracker->TrackField(""data"", data_);
  tracker->TrackField(""emit_message_fn"", emit_message_fn_);
}",60,,1153,2,,void
206621,BLOCK,-1,,"{
  // Factor generating the MessagePort JS constructor into its own piece
  // of code, because it is needed early on in the child environment setup.
  Local<FunctionTemplate> templ = env->message_port_constructor_template();
  if (!templ.IsEmpty())
    return templ;

  {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }

  return GetMessagePortConstructorTemplate(env);
}",77,,1158,2,,void
206638,BLOCK,-1,,<empty>,5,,1163,2,,void
206641,BLOCK,3,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }",3,,1165,3,,void
206714,BLOCK,-1,,"{
  MakeWeak();
}",28,,1183,3,,void
206720,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new JSTransferable(Environment::GetCurrent(args), args.This());
}",67,,1187,2,,void
206740,BLOCK,-1,,"{
  // Implement `kClone in this ? kCloneable : kTransferable`.
  HandleScope handle_scope(env()->isolate());
  errors::TryCatchScope ignore_exceptions(env());

  bool has_clone;
  if (!object()->Has(env()->context(),
                     env()->messaging_clone_symbol()).To(&has_clone)) {
    return TransferMode::kUntransferable;
  }

  return has_clone ? TransferMode::kCloneable : TransferMode::kTransferable;
}",70,,1192,1,,void
206770,BLOCK,-1,,"{
    return TransferMode::kUntransferable;
  }",71,,1199,2,,void
206787,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kTransferable);
}",70,,1206,1,,void
206796,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kCloneable);
}",73,,1210,1,,void
206806,BLOCK,-1,,"{
  // Call `this[symbol]()` where `symbol` is `kClone` or `kTransfer`,
  // which should return an object with `data` and `deserializeInfo` properties;
  // `data` is written to the serializer later, and `deserializeInfo` is stored
  // on the `TransferData` instance as a string.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = mode == TransferMode::kCloneable ?
      env()->messaging_clone_symbol() : env()->messaging_transfer_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return {};
  }
  if (method->IsFunction()) {
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(con...",30,,1215,2,,void
206864,BLOCK,-1,,"{
    return {};
  }",62,,1226,2,,void
206871,BLOCK,-1,,"{
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }
  }",29,,1229,2,,void
206895,BLOCK,-1,,"{
      return {};
    }",64,,1232,2,,void
206902,BLOCK,-1,,"{
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }",31,,1236,2,,void
206955,BLOCK,-1,,"{
        return {};
      }",44,,1242,2,,void
206969,BLOCK,-1,,<empty>,45,,1246,2,,void
206999,BLOCK,-1,,<empty>,5,,1253,2,,void
207006,BLOCK,-1,,<empty>,5,,1255,1,,void
207011,BLOCK,-1,,"{
  // Call `this[kTransferList]()` and return the resulting list of BaseObjects.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = env()->messaging_transfer_list_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<BaseObjectList>();
  }
  if (!method->IsFunction()) return Just(BaseObjectList {});

  Local<Value> list_v;
  if (!method.As<Function>()->Call(
          context, object(), 0, nullptr).ToLocal(&list_v)) {
    return Nothing<BaseObjectList>();
  }
  if (!list_v->IsArray()) return Just(BaseObjectList {});
  Local<Array> list = list_v.As<Array>();

  BaseObjectList ret;
  for (size_t i = 0; i < list->Length(); i++) {
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_bac...",45,,1259,1,,void
207059,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",62,,1266,2,,void
207068,BLOCK,-1,,<empty>,30,,1269,2,,void
207096,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",60,,1273,2,,void
207105,BLOCK,-1,,<empty>,27,,1276,2,,void
207122,BLOCK,-1,,<empty>,3,,1280,1,,void
207135,BLOCK,4,,"{
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_back(Unwrap<BaseObject>(value));
  }",47,,1280,4,,void
207154,BLOCK,-1,,<empty>,7,,1283,2,,void
207171,BLOCK,-1,,<empty>,7,,1285,2,,void
207189,BLOCK,-1,,"{
  // Call `this[kDeserialize](data)` where `data` comes from the return value
  // of `this[kTransfer]()` or `this[kClone]()`.
  HandleScope handle_scope(env()->isolate());
  Local<Value> data;
  if (!deserializer->ReadValue(context).ToLocal(&data)) return Nothing<bool>();

  Local<Symbol> method_name = env()->messaging_deserialize_symbol();
  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<bool>();
  }
  if (!method->IsFunction()) return Just(true);

  if (method.As<Function>()->Call(context, object(), 1, &data).IsEmpty()) {
    return Nothing<bool>();
  }
  return Just(true);
}",62,,1291,3,,void
207213,BLOCK,-1,,<empty>,57,,1296,2,,void
207244,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,1300,2,,void
207253,BLOCK,-1,,<empty>,30,,1303,2,,void
207273,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,1305,2,,void
207284,BLOCK,-1,,<empty>,30,,1314,3,,void
207291,BLOCK,-1,,"{
  // Create the JS wrapper object that will later be filled with data passed to
  // the `[kDeserialize]()` method on it. This split is necessary, because here
  // we need to create an object with the right prototype and internal fields,
  // but the actual JS data stored in the serialized data can only be read at
  // the end of the stream, after the main message has been read.

  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  HandleScope handle_scope(env->isolate());
  Local<Value> info;
  if (!ToV8Value(context, deserialize_info_).ToLocal(&info)) return {};

  Local<Value> ret;
  CHECK(!env->messaging_deserialize_create_object().IsEmpty());
  if (!env->messaging_deserialize_create_object()
           ->Call(context, Null(env->isolate()), 1, &info)
           .ToLocal(&ret) ||
      !ret->IsObject() || !BaseObject::IsBaseObject(ret.As<Object>())) {
    return {};
  }

  return BaseObjectPtr<BaseObject> { Unwrap<BaseO...",41,,1319,4,,void
207299,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1326,2,,void
207324,BLOCK,-1,,<empty>,62,,1332,2,,void
207379,BLOCK,-1,,"{
    return {};
  }",72,,1339,2,,void
207394,BLOCK,-1,,"{
  HandleScope handle_scope(context->GetIsolate());
  auto ret = serializer->WriteValue(context, PersistentToLocal::Strong(data_));
  data_.Reset();
  return ret;
}",58,,1347,3,,void
207424,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  std::shared_ptr<SiblingGroup> group;
  auto i = groups_.find(name);
  if (i == groups_.end() || i->second.expired()) {
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  } else {
    group = i->second.lock();
  }
  return group;
}",74,,1354,2,,void
207459,BLOCK,-1,,"{
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  }",50,,1358,2,,void
207475,BLOCK,-1,,"{
    group = i->second.lock();
  }",10,,1361,1,,void
207490,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  auto i = groups_.find(name);
  if (i != groups_.end() && i->second.expired())
    groups_.erase(name);
}",63,,1367,2,,void
207518,BLOCK,-1,,<empty>,5,,1371,2,,void
207528,BLOCK,-1,,{ },19,,1375,2,,void
207532,BLOCK,-1,,"{
  // If this is a named group, check to see if we can remove the group
  if (!name_.empty())
    CheckSiblingGroup(name_);
}",31,,1377,1,,void
207539,BLOCK,-1,,<empty>,5,,1380,2,,void
207547,BLOCK,-1,,"{

  RwLock::ScopedReadLock lock(group_mutex_);

  // The source MessagePortData is not part of this group.
  if (ports_.find(source) == ports_.end()) {
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }

  // There are no destination ports.
  if (size() <= 1)
    return Just(false);

  // Transferables cannot be used when there is more
  // than a single destination.
  if (size() > 2 && message->has_transferables()) {
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }

  for (MessagePortData* port : ports_) {
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
...",25,,1386,4,,void
207562,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }",44,,1391,2,,void
207567,BLOCK,-1,,<empty>,7,,1393,2,,void
207578,BLOCK,-1,,<empty>,5,,1399,2,,void
207591,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }",51,,1403,2,,void
207596,BLOCK,-1,,<empty>,7,,1405,2,,void
207606,BLOCK,-1,,"{
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }
    port->AddToIncomingQueue(message);
  }",40,,1409,3,,void
207611,BLOCK,-1,,<empty>,7,,1411,2,,void
207619,BLOCK,-1,,"{
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }",63,,1413,3,,void
207627,BLOCK,-1,,"{
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }",39,,1414,2,,void
207632,BLOCK,-1,,"{
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }",31,,1415,2,,void
207652,BLOCK,-1,,"{
  Entangle({ port });
}",52,,1428,2,,void
207660,BLOCK,-1,,"{
  RwLock::ScopedWriteLock lock(group_mutex_);
  for (MessagePortData* data : ports) {
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }
}",76,,1432,2,,void
207667,BLOCK,-1,,"{
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }",39,,1434,3,,void
207687,BLOCK,-1,,"{
  auto self = shared_from_this();  // Keep alive until end of function.
  RwLock::ScopedWriteLock lock(group_mutex_);
  ports_.erase(data);
  data->group_.reset();

  data->AddToIncomingQueue(std::make_shared<Message>());
  // If this is an anonymous group and there's another port, close it.
  if (size() == 1 && name_.empty())
    (*(ports_.begin()))->AddToIncomingQueue(std::make_shared<Message>());
}",55,,1441,2,,void
207723,BLOCK,-1,,<empty>,5,,1450,2,,void
207743,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_messaging_deserialize_create_object(args[0].As<Function>());
}",46,,1459,2,,void
207773,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }

  Local<Context> context = args.This()->GetCreationContext().ToLocalChecked();
  Context::Scope context_scope(context);

  MessagePort* port1 = MessagePort::New(env, context);
  if (port1 == nullptr) return;
  MessagePort* port2 = MessagePort::New(env, context);
  if (port2 == nullptr) {
    port1->Close();
    return;
  }

  MessagePort::Entangle(port1, port2);

  args.This()->Set(context, env->port1_string(), port1->object())
      .Check();
  args.This()->Set(context, env->port2_string(), port2->object())
      .Check();
}",69,,1465,2,,void
207788,BLOCK,-1,,"{
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }",32,,1467,2,,void
207824,BLOCK,-1,,<empty>,25,,1476,2,,void
207839,BLOCK,-1,,"{
    port1->Close();
    return;
  }",25,,1478,2,,void
207893,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Context::Scope context_scope(env->context());
  Utf8Value name(env->isolate(), args[0]);
  MessagePort* port =
      MessagePort::New(env, env->context(), {}, SiblingGroup::Get(*name));
  if (port != nullptr) {
    args.GetReturnValue().Set(port->object());
  }
}",71,,1491,2,,void
207947,BLOCK,-1,,"{
    args.GetReturnValue().Set(port->object());
  }",24,,1498,2,,void
207966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }

  {
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }

  SetConstructorFunction(context,
                         target,
                         env->message_port_constructor_string(),
                         GetMessagePortConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  // These are not methods on the MessagePort prototype, because
  // the bro...",39,,1506,5,,void
207982,BLOCK,5,,"{
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }",3,,1510,5,,void
207990,BLOCK,6,,"{
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }",3,,1517,6,,void
208084,BLOCK,15,,"{
    Local<Function> domexception = GetDOMException(context).ToLocalChecked();
    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(env->isolate(), ""DOMException""),
              domexception)
        .Check();
  }",3,,1548,15,,void
208115,BLOCK,-1,,"{
  registry->Register(MessageChannel);
  registry->Register(BroadcastChannel);
  registry->Register(JSTransferable::New);
  registry->Register(MessagePort::New);
  registry->Register(MessagePort::PostMessage);
  registry->Register(MessagePort::Start);
  registry->Register(MessagePort::Stop);
  registry->Register(MessagePort::CheckType);
  registry->Register(MessagePort::Drain);
  registry->Register(MessagePort::ReceiveMessage);
  registry->Register(MessagePort::MoveToContext);
  registry->Register(SetDeserializerCreateObjectFunction);
}",77,,1558,2,,void
208215,BLOCK,-1,,<empty>,1,,1,1,,ANY
208270,BLOCK,-1,,<empty>,1,,1,1,,ANY
208275,BLOCK,-1,,"{
  node = NODE_VERSION_STRING;
  v8 = v8::V8::GetVersion();
  uv = uv_version_string();
  zlib = ZLIB_VERSION;
  ares = ARES_VERSION_STR;
  modules = NODE_STRINGIFY(NODE_MODULE_VERSION);
  nghttp2 = NGHTTP2_VERSION;
  napi = NODE_STRINGIFY(NAPI_VERSION);
  llhttp =
      NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_MINOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_PATCH);

  brotli =
    std::to_string(BrotliEncoderVersion() >> 24) +
    ""."" +
    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +
    ""."" +
    std::to_string(BrotliEncoderVersion() & 0xFFF);
#ifndef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  undici = UNDICI_VERSION;
#endif

  acorn = ACORN_VERSION;
  cjs_module_lexer = CJS_MODULE_LEXER_VERSION;
  base64 = BASE64_VERSION;
  uvwasi = UVWASI_VERSION_STRING;

#if HAVE_OPENSSL
  openssl = GetOpenSSLVersion();
#endif

#ifdef NODE_HAVE_I18N_SUPPORT
  icu = U_ICU_VERSION;
  unicode = U_UNICODE_VERSION;
#endif  // NODE_HAVE_I1...",32,,77,1,,void
208279,BLOCK,1,,<empty>,,,,1,,void
208301,BLOCK,1,,<empty>,,,,1,,void
208309,BLOCK,1,,<empty>,,,,1,,void
208314,BLOCK,1,,<empty>,,,,1,,void
208350,BLOCK,1,,<empty>,,,,1,,void
208355,BLOCK,1,,<empty>,,,,1,,void
208360,BLOCK,1,,<empty>,,,,1,,void
208365,BLOCK,1,,<empty>,,,,1,,void
208379,BLOCK,-1,,"{
#if NODE_VERSION_IS_LTS
  lts = NODE_VERSION_LTS_CODENAME;
#endif  // NODE_VERSION_IS_LTS

#ifdef NODE_HAS_RELEASE_URLS
#define NODE_RELEASE_URLPFX NODE_RELEASE_URLBASE ""v"" NODE_VERSION_STRING ""/""
#define NODE_RELEASE_URLFPFX NODE_RELEASE_URLPFX ""node-v"" NODE_VERSION_STRING

  source_url = NODE_RELEASE_URLFPFX "".tar.gz"";
  headers_url = NODE_RELEASE_URLFPFX ""-headers.tar.gz"";
#ifdef _WIN32
  lib_url = strcmp(NODE_ARCH, ""ia32"") ? NODE_RELEASE_URLPFX ""win-"" NODE_ARCH
                                                           ""/node.lib""
                                     : NODE_RELEASE_URLPFX ""win-x86/node.lib"";
#endif  // _WIN32

#endif  // NODE_HAS_RELEASE_URLS
}",51,,126,1,,void
208383,BLOCK,-1,,<empty>,65,,146,1,,void
208398,BLOCK,-1,,<empty>,1,,1,1,,ANY
208411,BLOCK,-1,,<empty>,1,,1,1,,ANY
208420,BLOCK,-1,,<empty>,1,,1,1,,ANY
208424,BLOCK,-1,,"{
    refs_ = 0;
  }",16,,33,1,,void
208431,BLOCK,-1,,"{
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }",25,,38,1,,void
208437,BLOCK,-1,,<empty>,7,,40,2,,void
208451,BLOCK,-1,,"{
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }",57,,47,2,,void
208486,BLOCK,-1,,"{
    return handle(v8::Isolate::GetCurrent());
  }",41,,58,1,,void
208499,BLOCK,-1,,"{
    return v8::Local<v8::Object>::New(isolate, persistent());
  }",61,,63,2,,void
208518,BLOCK,-1,,"{
    return handle_;
  }",51,,69,1,,void
208525,BLOCK,-1,,"{
    assert(persistent().IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    handle->SetAlignedPointerInInternalField(0, this);
    persistent().Reset(v8::Isolate::GetCurrent(), handle);
    MakeWeak();
  }",50,,75,2,,void
208559,BLOCK,-1,,"{
    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",26,,84,1,,void
208574,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",22,,92,1,,void
208590,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",24,,107,1,,void
208612,BLOCK,-1,,<empty>,7,,112,2,,void
208619,BLOCK,-1,,"{
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",53,,119,2,,void
208654,BLOCK,-1,,<empty>,1,,1,1,,ANY
208657,BLOCK,-1,,"{
    per_process::cli_options->per_isolate->per_env = original_per_env;
    per_process::cli_options->per_isolate = original_per_isolate;
  }",44,,1100,1,,void
208682,BLOCK,-1,,"{
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  }",54,,1283,2,,void
208728,BLOCK,-1,,<empty>,1,,1,1,,ANY
208741,BLOCK,-1,,"{
#if !NODE_USE_V8_PLATFORM && !HAVE_INSPECTOR
  if (inspector_enabled) {
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }
#endif

  if (deprecated_debug) {
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }

  using std::string_view_literals::operator""""sv;
  const std::vector<std::string_view> destinations =
      SplitString(inspect_publish_uid_string, "",""sv);
  inspect_publish_uid.console = false;
  inspect_publish_uid.http = false;
  for (const std::string_view destination : destinations) {
    if (destination == ""stderr""sv) {
      inspect_publish_uid.console = true;
    } else if (destination == ""http""sv) {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
 ...",65,,40,3,,void
208744,BLOCK,-1,,"{
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }",26,,42,2,,void
208752,BLOCK,-1,,"{
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }",25,,48,2,,void
208777,BLOCK,-1,,"{
    if (destination == ""stderr""sv) {
      inspect_publish_uid.console = true;
    } else if (destination == ""http""sv) {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }
  }",59,,59,3,,void
208782,BLOCK,-1,,"{
      inspect_publish_uid.console = true;
    }",36,,60,2,,void
208789,BLOCK,-1,,<empty>,12,,62,1,,void
208794,BLOCK,-1,,"{
      inspect_publish_uid.http = true;
    }",41,,62,2,,void
208801,BLOCK,-1,,"{
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }",12,,64,1,,void
208812,BLOCK,-1,,"{
#if HAVE_OPENSSL
  if (use_openssl_ca && use_bundled_ca) {
    errors->push_back(""either --use-openssl-ca or --use-bundled-ca can be ""
                      ""used, not both"");
  }

  // Any value less than 2 disables use of the secure heap.
  if (secure_heap >= 2) {
    if ((secure_heap & (secure_heap - 1)) != 0)
      errors->push_back(""--secure-heap must be a power of 2"");
    secure_heap_min =
        std::min({
            secure_heap,
            secure_heap_min,
            static_cast<int64_t>(std::numeric_limits<int>::max())});
    secure_heap_min = std::max(static_cast<int64_t>(2), secure_heap_min);
    if ((secure_heap_min & (secure_heap_min - 1)) != 0)
      errors->push_back(""--secure-heap-min must be a power of 2"");
  }
#endif  // HAVE_OPENSSL

  if (use_largepages != ""off"" &&
      use_largepages != ""on"" &&
      use_largepages != ""silent"") {
    errors->push_back(""invalid value for --use-largepages"");
  }
  per_isolate->CheckOptions(errors, argv);
}",70,,72,3,,void
208825,BLOCK,-1,,"{
    errors->push_back(""invalid value for --use-largepages"");
  }",35,,96,2,,void
208842,BLOCK,-1,,"{
  per_env->CheckOptions(errors, argv);
}",70,,103,3,,void
208854,BLOCK,-1,,"{
  if (has_policy_integrity_string && experimental_policy.empty()) {
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }
  if (has_policy_integrity_string && experimental_policy_integrity.empty()) {
    errors->push_back(""--policy-integrity cannot be empty"");
  }

  if (!module_type.empty()) {
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }

  if (syntax_check_only && has_eval_string) {
    errors->push_back(""either --check or --eval can be used, not both"");
  }

  if (!unhandled_rejections.empty() &&
      unhandled_rejections != ""warn-with-error-code"" &&
      unhandled_rejections != ""throw"" &&
      unhandled_rejections != ""strict"" &&
      unhandled_rejections != ""warn"" &&
      unhandled_rejections != ""none"") {
    errors->push_back(""invalid value for --unhandled-rejections"");
  }

  if (tls_min_v1_3 && tls_max_v1...",71,,108,3,,void
208862,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }",67,,109,2,,void
208875,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity cannot be empty"");
  }",77,,113,2,,void
208887,BLOCK,-1,,"{
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }",29,,117,2,,void
208896,BLOCK,-1,,"{
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }",63,,118,2,,void
208903,BLOCK,-1,,<empty>,7,,123,1,,void
208905,BLOCK,-1,,"{
    errors->push_back(""either --check or --eval can be used, not both"");
  }",45,,123,2,,void
208937,BLOCK,-1,,"{
    errors->push_back(""invalid value for --unhandled-rejections"");
  }",39,,132,2,,void
208944,BLOCK,-1,,<empty>,7,,136,1,,void
208946,BLOCK,-1,,"{
    errors->push_back(""either --tls-min-v1.3 or --tls-max-v1.2 can be ""
                      ""used, not both"");
  }",37,,136,2,,void
208956,BLOCK,-1,,"{
    errors->push_back(""--heapsnapshot-near-heap-limit must not be negative"");
  }",42,,141,2,,void
208964,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --test or --check can be used, not both"");
    }

    if (has_eval_string) {
      errors->push_back(""either --test or --eval can be used, not both"");
    }

    if (force_repl) {
      errors->push_back(""either --test or --interactive can be used, not both"");
    }

    if (watch_mode_paths.size() > 0) {
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_TEST_RUNNER
    debug_options_.allow_attaching_debugger = false;
#endif
  }",20,,145,2,,void
208967,BLOCK,-1,,"{
      errors->push_back(""either --test or --check can be used, not both"");
    }",28,,146,2,,void
208975,BLOCK,-1,,"{
      errors->push_back(""either --test or --eval can be used, not both"");
    }",26,,150,2,,void
208983,BLOCK,-1,,"{
      errors->push_back(""either --test or --interactive can be used, not both"");
    }",21,,154,2,,void
208996,BLOCK,-1,,"{
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }",38,,158,2,,void
209009,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --watch or --check can be used, not both"");
    } else if (has_eval_string) {
      errors->push_back(""either --watch or --eval can be used, not both"");
    } else if (force_repl) {
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    } else if (argv->size() < 1 || (*argv)[1].empty()) {
      errors->push_back(""--watch requires specifying a file"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_WATCH_MODE
    debug_options_.allow_attaching_debugger = false;
#endif
  }",19,,168,2,,void
209012,BLOCK,-1,,"{
      errors->push_back(""either --watch or --check can be used, not both"");
    }",28,,169,2,,void
209019,BLOCK,-1,,<empty>,12,,171,1,,void
209022,BLOCK,-1,,"{
      errors->push_back(""either --watch or --eval can be used, not both"");
    }",33,,171,2,,void
209029,BLOCK,-1,,<empty>,12,,173,1,,void
209032,BLOCK,-1,,"{
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    }",28,,173,2,,void
209039,BLOCK,-1,,<empty>,12,,176,1,,void
209055,BLOCK,-1,,"{
      errors->push_back(""--watch requires specifying a file"");
    }",56,,176,2,,void
209071,BLOCK,-1,,<empty>,,,,1,,<empty>
209076,BLOCK,-1,,<empty>,,,,1,,<empty>
209081,BLOCK,-1,,"{
    Insert(dop, &EnvironmentOptions::get_debug_options);
  }",34,,237,2,,void
209092,BLOCK,-1,,<empty>,,,,1,,<empty>
209097,BLOCK,-1,,<empty>,,,,2,,<empty>
209102,BLOCK,-1,,<empty>,,,,1,,<empty>
209107,BLOCK,-1,,<empty>,,,,2,,<empty>
209131,BLOCK,-1,,"{
  _piop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,279,7,,void
209151,BLOCK,-1,,"{
  _ppop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,289,7,,void
209165,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  if (sea::IsSingleExecutable()) return;
#endif

  AddOption(""--inspect-port"",
            ""set host:port for inspector"",
            &DebugOptions::host_port,
            kAllowedInEnvvar);
  AddAlias(""--debug-port"", ""--inspect-port"");

  AddOption(""--inspect"",
            ""activate inspector on host:port (default: 127.0.0.1:9229)"",
            &DebugOptions::inspector_enabled,
            kAllowedInEnvvar);
  AddAlias(""--inspect="", { ""--inspect-port"", ""--inspect"" });

  AddOption(""--debug"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug="", ""--debug"");
  AddOption(""--debug-brk"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug-brk="", ""--debug-brk"");

  AddOption(""--inspect-brk"",
            ""activate inspector on host:port and break at start of user script"",
            &DebugOptions::break_first_line,
            kAllowedInEnvvar);
  Implies(""--inspect-brk"", ""--inspect"");
  AddAlias(""--inspect-brk="", { ""--inspect-...",42,,298,1,,void
209171,BLOCK,-1,,<empty>,34,,300,2,,void
209259,BLOCK,-1,,"{
  AddOption(""--conditions"",
            ""additional user conditions for conditional exports and imports"",
            &EnvironmentOptions::conditions,
            kAllowedInEnvvar);
  AddAlias(""-C"", ""--conditions"");
  AddOption(""--diagnostic-dir"",
            ""set dir for all output files""
            "" (default: current working directory)"",
            &EnvironmentOptions::diagnostic_dir,
            kAllowedInEnvvar);
  AddOption(""--dns-result-order"",
            ""set default value of verbatim in dns.lookup. Options are ""
            ""'ipv4first' (IPv4 addresses are placed before IPv6 addresses) ""
            ""'verbatim' (addresses are in the order the DNS resolver ""
            ""returned)"",
            &EnvironmentOptions::dns_result_order,
            kAllowedInEnvvar);
  AddOption(""--network-family-autoselection"",
            ""Disable network address family autodetection algorithm"",
            &EnvironmentOptions::network_family_autoselection,
            kAllowedInEnvvar,
 ...",54,,338,1,,void
209981,BLOCK,-1,,"{
  AddOption(""--track-heap-objects"",
            ""track heap object allocations for heap snapshots"",
            &PerIsolateOptions::track_heap_objects,
            kAllowedInEnvvar);

  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.
  AddOption(""--abort-on-uncaught-exception"",
            ""aborting instead of exiting causes a core file to be generated ""
            ""for analysis"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--interpreted-frames-native-stack"",
            ""help system profilers to translate JavaScript interpreted frames"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--max-old-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--max-semi-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-basic-prof"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(
      ""--perf-basic-prof-only-functions"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-prof"", """", V8Option{}, kA...",40,,738,2,,void
210141,BLOCK,-1,,"{
  AddOption(""--title"",
            ""the process title to use on startup"",
            &PerProcessOptions::title,
            kAllowedInEnvvar);
  AddOption(""--trace-event-categories"",
            ""comma separated list of trace event categories to record"",
            &PerProcessOptions::trace_event_categories,
            kAllowedInEnvvar);
  AddOption(""--trace-event-file-pattern"",
            ""Template string specifying the filepath for the trace-events ""
            ""data, it supports ${rotation} and ${pid}."",
            &PerProcessOptions::trace_event_file_pattern,
            kAllowedInEnvvar);
  AddAlias(""--trace-events-enabled"", {
    ""--trace-event-categories"", ""v8,node,node.async_hooks"" });
  AddOption(""--v8-pool-size"",
            ""set V8's thread pool size"",
            &PerProcessOptions::v8_thread_pool_size,
            kAllowedInEnvvar);
  AddOption(""--zero-fill-buffers"",
            ""automatically zero-fill all newly allocated Buffer and ""
            ""SlowBuffer in...",39,,813,2,,void
210343,BLOCK,-1,,"{
  if (!host.empty() && host.front() == '[' && host.back() == ']')
    return host.substr(1, host.size() - 2);
  else
    return host;
}",60,,996,2,,void
210364,BLOCK,-1,,<empty>,5,,998,2,,void
210378,BLOCK,-1,,<empty>,5,,1000,1,,void
210386,BLOCK,-1,,"{
  char* endptr;
  errno = 0;
  const unsigned long result =                 // NOLINT(runtime/int)
    strtoul(port.c_str(), &endptr, 10);
  if (errno != 0 || *endptr != '\0'||
      (result != 0 && result < 1024) || result > 65535) {
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }
  return static_cast<int>(result);
}",67,,1004,3,,void
210423,BLOCK,-1,,"{
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }",57,,1010,2,,void
210438,BLOCK,-1,,"{
  // remove_brackets only works if no port is specified
  // so if it has an effect only an IPv6 address was specified.
  std::string host = RemoveBrackets(arg);
  if (host.length() < arg.length())
    return HostPort{host, DebugOptions::kDefaultInspectorPort};

  size_t colon = arg.rfind(':');
  if (colon == std::string::npos) {
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }
  // Host and port found:
  return HostPort { RemoveBrackets(arg.substr(0, colon)),
                    ParseAndValidatePort(arg.substr(colon + 1), errors) };
}",57,,1017,3,,void
210454,BLOCK,-1,,<empty>,5,,1022,2,,void
210478,BLOCK,-1,,"{
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }",35,,1025,2,,void
210482,BLOCK,-1,,"{
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }",24,,1028,3,,void
210491,BLOCK,-1,,"{
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }",31,,1029,2,,void
210528,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  const auto& parser = _ppop_instance;

  std::ostringstream out;

  out << ""_node_complete() {\n""
         ""  local cur_word options\n""
         ""  cur_word=\""${COMP_WORDS[COMP_CWORD]}\""\n""
         ""  if [[ \""${cur_word}\"" == -* ]] ; then\n""
         ""    COMPREPLY=( $(compgen -W '"";

  for (const auto& item : parser.options_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  for (const auto& item : parser.aliases_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  if (parser.aliases_.size() > 0) {
    out.seekp(-1, out.cur);  // Strip the trailing space
  }

  out << ""' -- \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  else\n""
         ""    COMPREPLY=( $(compgen -f \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  fi\n""
         ""}\n""
         ""complete -o filenames -o nospace -o bashdefault ""
         ""-F _node_complete node node_g"";
  return...",33,,1040,1,,void
210547,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1052,3,,void
210556,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1053,2,,void
210569,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1057,3,,void
210578,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1058,2,,void
210595,BLOCK,-1,,"{
    out.seekp(-1, out.cur);  // Strip the trailing space
  }",35,,1062,2,,void
210617,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  env->set_has_serialized_options(true);

  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Temporarily act as if the current Environment's/IsolateData's options were
  // the default options, i.e. like they are the ones we'd access for global
  // options parsing, so that all options are available from the main parser.
  auto original_per_isolate = per_process::cli_options->per_isolate;
  per_process::cli_options->per_isolate = env->isolate_data()->options();
  auto original_per_env = per_process::cli_options->per_isolate->per_env;
  per_process::cli_options->per_isolate->per_env = env->options();
  auto on_scope_leave = OnScopeLeave([&]() {
    per_pro...",61,,1080,2,,void
210637,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1083,2,,void
210736,BLOCK,-1,,"{
    return;
  }",25,,1108,2,,void
210743,BLOCK,-1,,"{
    Local<Value> value;
    const auto& option_info = item.second;
    auto field = option_info.field;
    PerProcessOptions* opts = per_process::cli_options.get();
    switch (option_info.type) {
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            stati...",52,,1112,3,,void
210774,BLOCK,-1,,"{
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<uint64_t>(field, opts)));
        break;
      case kString:
        if (!ToV8Value(context,
                       *_ppop_instance.Lookup<std::string>(field, ...",31,,1117,2,,void
210785,BLOCK,-1,,"{
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        }",60,,1122,2,,void
210797,BLOCK,-1,,"{
          value = Undefined(isolate);
        }",16,,1125,1,,void
210890,BLOCK,-1,,"{
          return;
        }",36,,1146,2,,void
210915,BLOCK,-1,,"{
          return;
        }",36,,1153,2,,void
210920,BLOCK,29,,"{
        const HostPort& host_port =
          *_ppop_instance.Lookup<HostPort>(field, opts);
        Local<Object> obj = Object::New(isolate);
        Local<Value> host;
        if (!ToV8Value(context, host_port.host()).ToLocal(&host) ||
            obj->Set(context, env->host_string(), host).IsNothing() ||
            obj->Set(context,
                     env->port_string(),
                     Integer::New(isolate, host_port.port()))
                .IsNothing()) {
          return;
        }
        value = obj;
        break;
      }",23,,1157,29,,void
211000,BLOCK,-1,,"{
          return;
        }",31,,1167,2,,void
211170,BLOCK,-1,,"{
      return;
    }",54,,1198,2,,void
211189,BLOCK,-1,,<empty>,71,,1204,2,,void
211207,BLOCK,-1,,"{
    return;
  }",25,,1208,2,,void
211248,BLOCK,-1,,"{
    return;
  }",70,,1214,2,,void
211262,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = env->context();
  Local<Object> ret = Object::New(isolate);

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""shouldNotRegisterESMLoader""),
           Boolean::New(isolate, env->should_not_register_esm_loader()))
      .IsNothing()) return;

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""noGlobalSearchPaths""),
           Boolean::New(isolate, env->no_global_search_paths()))
      .IsNothing()) return;

  args.GetReturnValue().Set(ret);
}",66,,1221,2,,void
211277,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1223,2,,void
211336,BLOCK,-1,,<empty>,21,,1235,2,,void
211362,BLOCK,-1,,<empty>,21,,1240,2,,void
211379,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetMethodNoSideEffect(context, target, ""getCLIOptions"", GetCLIOptions);
  SetMethodNoSideEffect(
      context, target, ""getEmbedderOptions"", GetEmbedderOptions);

  Local<Object> env_settings = Object::New(isolate);
  NODE_DEFINE_CONSTANT(env_settings, kAllowedInEnvvar);
  NODE_DEFINE_CONSTANT(env_settings, kDisallowedInEnvvar);
  target
      ->Set(
          context, FIXED_ONE_BYTE_STRING(isolate, ""envSettings""), env_settings)
      .Check();

  Local<Object> types = Object::New(isolate);
  NODE_DEFINE_CONSTANT(types, kNoOp);
  NODE_DEFINE_CONSTANT(types, kV8Option);
  NODE_DEFINE_CONSTANT(types, kBoolean);
  NODE_DEFINE_CONSTANT(types, kInteger);
  NODE_DEFINE_CONSTANT(types, kUInteger);
  NODE_DEFINE_CONSTANT(types, kString);
  NODE_DEFINE_CONSTANT(types, kHostPort);
  NODE_DEFINE_CONSTANT(types, kStringList);
  target->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""types""), types)
   ...",29,,1248,5,,void
211485,BLOCK,-1,,"{
  registry->Register(GetCLIOptions);
  registry->Register(GetEmbedderOptions);
}",70,,1276,2,,void
211500,BLOCK,-1,,"{
  HandleEnvOptions(env_options, [](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  });
}",72,,1282,2,,void
211509,BLOCK,-1,,"{
  env_options->pending_deprecation =
      opt_getter(""NODE_PENDING_DEPRECATION"") == ""1"";

  env_options->preserve_symlinks = opt_getter(""NODE_PRESERVE_SYMLINKS"") == ""1"";

  env_options->preserve_symlinks_main =
      opt_getter(""NODE_PRESERVE_SYMLINKS_MAIN"") == ""1"";

  if (env_options->redirect_warnings.empty())
    env_options->redirect_warnings = opt_getter(""NODE_REDIRECT_WARNINGS"");
}",75,,1290,3,,void
211541,BLOCK,-1,,<empty>,5,,1300,2,,void
211553,BLOCK,-1,,"{
  std::vector<std::string> env_argv;

  bool is_in_string = false;
  bool will_start_new_arg = true;
  for (std::string::size_type index = 0; index < node_options.size(); ++index) {
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }

  if (is_in_string) {
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(un...",72,,1304,3,,void
211572,BLOCK,-1,,<empty>,3,,1309,1,,void
211585,BLOCK,4,,"{
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }",80,,1309,4,,void
211600,BLOCK,-1,,"{
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    }",36,,1313,2,,void
211610,BLOCK,-1,,"{
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      }",45,,1314,2,,void
211619,BLOCK,-1,,"{
        c = node_options.at(++index);
      }",14,,1318,1,,void
211629,BLOCK,-1,,<empty>,12,,1321,1,,void
211637,BLOCK,-1,,"{
      will_start_new_arg = true;
      continue;
    }",43,,1321,2,,void
211643,BLOCK,-1,,<empty>,12,,1324,1,,void
211648,BLOCK,-1,,"{
      is_in_string = !is_in_string;
      continue;
    }",26,,1324,2,,void
211656,BLOCK,-1,,"{
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    }",29,,1329,2,,void
211671,BLOCK,-1,,"{
      env_argv.back() += c;
    }",12,,1332,1,,void
211680,BLOCK,-1,,"{
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(unterminated string)\n"");
  }",21,,1337,2,,void
211711,BLOCK,-1,,<empty>,1,,1,1,,ANY
211714,BLOCK,-1,,{ uv_os_free_passwd(&pwd); },41,,299,1,,void
211741,BLOCK,-1,,<empty>,1,,1,1,,ANY
211746,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[UV_MAXHOSTNAMESIZE];
  size_t size = sizeof(buf);
  int r = uv_os_gethostname(buf, &size);

  if (r != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), buf).ToLocalChecked());
}",66,,60,2,,void
211772,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }",15,,66,2,,void
211824,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_utsname_t info;
  int err = uv_os_uname(&info);

  if (err != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }

  // [sysname, version, release, machine]
  Local<Value> osInformation[] = {
      String::NewFromUtf8(env->isolate(), info.sysname).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.version).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.release).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.machine).ToLocalChecked()};

  args.GetReturnValue().Set(Array::New(env->isolate(),
                                       osInformation,
                                       arraysize(osInformation)));
}",71,,77,2,,void
211844,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }",17,,82,2,,void
211955,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  uv_cpu_info_t* cpu_infos;
  int count;

  int err = uv_cpu_info(&cpu_infos, &count);
  if (err)
    return;

  // It's faster to create an array packed with all the data and
  // assemble them into objects in JS than to call Object::Set() repeatedly
  // The array is in the format
  // [model, speed, (5 entries of cpu_times), model2, speed2, ...]
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (int i = 0; i < count; i++) {
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    re...",65,,100,2,,void
211983,BLOCK,-1,,<empty>,5,,109,2,,void
212002,BLOCK,-1,,<empty>,3,,117,1,,void
212012,BLOCK,4,,"{
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.idle)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.irq)));
  }",35,,117,4,,void
212147,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_free_memory());
  args.GetReturnValue().Set(amount);
}",68,,138,2,,void
212166,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_total_memory());
  args.GetReturnValue().Set(amount);
}",69,,144,2,,void
212185,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double uptime;
  int err = uv_uptime(&uptime);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(uptime);
}",64,,150,2,,void
212205,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }",17,,154,2,,void
212240,BLOCK,-1,,"{
  CHECK(args[0]->IsFloat64Array());
  Local<Float64Array> array = args[0].As<Float64Array>();
  CHECK_EQ(array->Length(), 3);
  Local<ArrayBuffer> ab = array->Buffer();
  double* loadavg = static_cast<double*>(ab->Data());
  uv_loadavg(loadavg);
}",65,,163,2,,void
212291,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_interface_address_t* interfaces;
  int count, i;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  std::array<char, 18> mac;
  Local<String> name, family;

  int err = uv_interface_addresses(&interfaces, &count);

  if (err == UV_ENOSYS)
    return args.GetReturnValue().SetUndefined();

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<Value> no_scope_id = Integer::New(isolate, -1);
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (i = 0; i < count; i++) {
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, it’s more than reasonable
    // to assum...",76,,173,2,,void
212327,BLOCK,-1,,<empty>,5,,186,2,,void
212338,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }",12,,188,2,,void
212397,BLOCK,-1,,<empty>,3,,198,1,,void
212406,BLOCK,4,,"{
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, it’s more than reasonable
    // to assume UTF8 as the default as well. It’s what people will expect if
    // they name the interface from any input that uses UTF-8, which should be
    // the most frequent case by far these days.)
    name = String::NewFromUtf8(isolate, raw_name).ToLocalChecked();

    snprintf(mac.data(),
             mac.size(),
             ""%02x:%02x:%02x:%02x:%02x:%02x"",
             static_cast<unsigned char>(interfaces[i].phys_addr[0]),
             static_cast<unsigned char>(interfaces[i].phys_addr[1]),
             static_cast<unsigned char>(interfaces[i].phys_addr[2]),
             static_cast<unsigned char>(interfaces[i].phys_addr[3]),
             static_cast<unsigned char>(interfaces[i].phys_addr[4]),
             static_cast<unsigned char>(interfaces[i].phys_addr[5]));
...",31,,198,4,,void
212502,BLOCK,-1,,"{
      uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
      uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
      family = env->ipv4_string();
    }",63,,218,2,,void
212534,BLOCK,-1,,<empty>,12,,222,1,,void
212547,BLOCK,-1,,"{
      uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
      uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
      family = env->ipv6_string();
    }",71,,222,2,,void
212579,BLOCK,-1,,"{
      strncpy(ip, ""<unknown sa family>"", INET6_ADDRSTRLEN);
      family = env->unknown_string();
    }",12,,226,1,,void
212650,BLOCK,-1,,"{
      uint32_t scopeid = interfaces[i].address.address6.sin6_scope_id;
      result.emplace_back(Integer::NewFromUnsigned(isolate, scopeid));
    }",64,,238,2,,void
212674,BLOCK,-1,,"{
      result.emplace_back(no_scope_id);
    }",12,,241,1,,void
212707,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[PATH_MAX];

  size_t len = sizeof(buf);
  const int err = uv_os_homedir(buf, &len);

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<String> home = String::NewFromUtf8(env->isolate(),
                                           buf,
                                           NewStringType::kNormal,
                                           len).ToLocalChecked();
  args.GetReturnValue().Set(home);
}",71,,251,2,,void
212731,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }",12,,258,2,,void
212794,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_passwd_t pwd;
  enum encoding encoding;

  if (args[0]->IsObject()) {
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  } else {
    encoding = UTF8;
  }

  const int err = uv_os_get_passwd(&pwd);

  if (err) {
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }

  auto free_passwd = OnScopeLeave([&]() { uv_os_free_passwd(&pwd); });

  Local<Value> error;

  Local<Value> uid = Number::New(env->isolate(), pwd.uid);
  Local<Value> gid = Number::New(env->isolate(), pwd.gid);
  Ma...",66,,272,2,,void
212811,BLOCK,-1,,"{
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  }",28,,277,2,,void
212855,BLOCK,-1,,<empty>,9,,283,2,,void
212867,BLOCK,-1,,"{
    encoding = UTF8;
  }",10,,286,1,,void
212879,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }",12,,292,2,,void
213003,BLOCK,-1,,<empty>,5,,316,2,,void
213012,BLOCK,-1,,<empty>,5,,318,1,,void
213044,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",67,,320,2,,void
213175,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  const int priority = args[1].As<Int32>()->Value();
  const int err = uv_os_setpriority(pid, priority);

  if (err) {
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }

  args.GetReturnValue().Set(err);
}",66,,344,2,,void
213236,BLOCK,-1,,"{
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }",12,,355,2,,void
213265,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  int priority;
  const int err = uv_os_getpriority(pid, &priority);

  if (err) {
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }

  args.GetReturnValue().Set(priority);
}",66,,364,2,,void
213309,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }",12,,374,2,,void
213339,BLOCK,-1,,"{
  unsigned int parallelism = uv_available_parallelism();
  args.GetReturnValue().Set(parallelism);
}",78,,383,2,,void
213359,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  SetMethod(context, target, ""getHostname"", GetHostname);
  SetMethod(context, target, ""getLoadAvg"", GetLoadAvg);
  SetMethod(context, target, ""getUptime"", GetUptime);
  SetMethod(context, target, ""getTotalMem"", GetTotalMemory);
  SetMethod(context, target, ""getFreeMem"", GetFreeMemory);
  SetMethod(context, target, ""getCPUs"", GetCPUInfo);
  SetMethod(context, target, ""getInterfaceAddresses"", GetInterfaceAddresses);
  SetMethod(context, target, ""getHomeDirectory"", GetHomeDirectory);
  SetMethod(context, target, ""getUserInfo"", GetUserInfo);
  SetMethod(context, target, ""setPriority"", SetPriority);
  SetMethod(context, target, ""getPriority"", GetPriority);
  SetMethod(
      context, target, ""getAvailableParallelism"", GetAvailableParallelism);
  SetMethod(context, target, ""getOSInformation"", GetOSInformation);
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(env->isolate(), ""isBigEndian""),
            Boolean::New(e...",29,,391,5,,void
213460,BLOCK,-1,,"{
  registry->Register(GetHostname);
  registry->Register(GetLoadAvg);
  registry->Register(GetUptime);
  registry->Register(GetTotalMemory);
  registry->Register(GetFreeMemory);
  registry->Register(GetCPUInfo);
  registry->Register(GetInterfaceAddresses);
  registry->Register(GetHomeDirectory);
  registry->Register(GetUserInfo);
  registry->Register(SetPriority);
  registry->Register(GetPriority);
  registry->Register(GetAvailableParallelism);
  registry->Register(GetOSInformation);
}",70,,414,2,,void
213532,BLOCK,-1,,"{
    entry->Notify(env);
  }",66,,191,2,,void
213545,BLOCK,-1,,"{
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }",73,,262,2,,void
213622,BLOCK,-1,,<empty>,1,,1,1,,ANY
213637,BLOCK,-1,,"{
  if (info == nullptr) {
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }
}",51,,59,3,,void
213642,BLOCK,-1,,"{
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }",24,,60,2,,void
213644,BLOCK,-1,,<empty>,5,,61,1,,void
213668,BLOCK,-1,,"{
  SerializeInfo info{root.Serialize(context, creator),
                     milestones.Serialize(context, creator),
                     observers.Serialize(context, creator)};
  return info;
}",67,,66,3,,void
213697,BLOCK,-1,,"{
  root.Deserialize(context);
  // This is just done to set up the pointers, we will actually reset
  // all the milestones after deserialization.
  milestones.Deserialize(context);
  observers.Deserialize(context);
}",68,,73,2,,void
213718,BLOCK,-1,,"{
  o << ""{\n""
    << ""  "" << i.root << "",  // root\n""
    << ""  "" << i.milestones << "",  // milestones\n""
    << ""  "" << i.observers << "",  // observers\n""
    << ""}"";
  return o;
}",68,,82,3,,void
213755,BLOCK,-1,,"{
  this->milestones[milestone] = static_cast<double>(ts);
  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
      TRACING_CATEGORY_NODE1(bootstrap),
      GetPerformanceMilestoneName(milestone),
      TRACE_EVENT_SCOPE_THREAD, ts / 1000);
}",74,,91,3,,void
213778,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  Environment* env = realm->env();
  PerformanceMilestone milestone =
      static_cast<PerformanceMilestone>(args[0].As<Int32>()->Value());
  if (milestone != NODE_PERFORMANCE_MILESTONE_INVALID)
    env->performance_state()->Mark(milestone);
}",61,,100,2,,void
213822,BLOCK,-1,,<empty>,5,,108,2,,void
213835,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  CHECK(args[0]->IsFunction());
  realm->set_performance_entry_callback(args[0].As<Function>());
}",73,,111,2,,void
213878,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Prevent gc callback from reentering with different type
  // See https://github.com/nodejs/node/issues/44046
  if (env->performance_state()->current_gc_type != 0) {
    return;
  }
  env->performance_state()->performance_last_gc_start_mark = PERFORMANCE_NOW();
  env->performance_state()->current_gc_type = type;
}",17,,124,5,,void
213894,BLOCK,-1,,"{
    return;
  }",55,,128,2,,void
213917,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

  if (!obj->Set(
          env->context(),
          env->kind_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.kind)).IsJust()) {
    return MaybeLocal<Object>();
  }

  if (!obj->Set(
          env->context(),
          env->flags_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.flags)).IsJust()) {
    return MaybeLocal<Object>();
  }

  return obj;
}",38,,137,3,,void
213962,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",46,,145,2,,void
213995,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",47,,154,2,,void
214007,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  PerformanceState* state = env->performance_state();
  if (type != state->current_gc_type) {
    return;
  }
  env->performance_state()->current_gc_type = 0;
  // If no one is listening to gc performance entries, do not create them.
  if (LIKELY(!state->observers[NODE_PERFORMANCE_ENTRY_TYPE_GC]))
    return;

  double start_time =
      (state->performance_last_gc_start_mark - env->time_origin()) /
      NANOS_PER_MILLIS;
  double duration = (PERFORMANCE_NOW() / NANOS_PER_MILLIS) -
                    (state->performance_last_gc_start_mark / NANOS_PER_MILLIS);

  std::unique_ptr<GCPerformanceEntry> entry =
      std::make_unique<GCPerformanceEntry>(
          ""gc"",
          start_time,
          duration,
          GCPerformanceEntry::Details(static_cast<PerformanceGCKind>(type),
                                      static_cast<PerformanceGCFlags>(flags)));

  env->SetImmediate([entry = std::move(entry)](Environment* env) {
...",17,,166,5,,void
214026,BLOCK,-1,,"{
    return;
  }",39,,169,2,,void
214044,BLOCK,-1,,<empty>,5,,175,2,,void
214059,BLOCK,1,,<empty>,,,,1,,void
214068,BLOCK,1,,<empty>,,,,1,,void
214075,BLOCK,1,,<empty>,,,,1,,void
214118,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->RemoveGCPrologueCallback(MarkGarbageCollectionStart, data);
  env->isolate()->RemoveGCEpilogueCallback(MarkGarbageCollectionEnd, data);
}",47,,196,2,,void
214155,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->AddGCPrologueCallback(MarkGarbageCollectionStart,
                                        static_cast<void*>(env));
  env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                        static_cast<void*>(env));
  env->AddCleanupHook(GarbageCollectionCleanupHook, env);
}",46,,205,2,,void
214204,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->RemoveCleanupHook(GarbageCollectionCleanupHook, env);
  GarbageCollectionCleanupHook(env);
}",44,,217,2,,void
214225,BLOCK,-1,,"{
  Local<Value> val = fn->GetDebugName();
  if (val.IsEmpty() || val->IsUndefined()) {
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }
  return val;
}",49,,225,2,,void
214246,BLOCK,-1,,"{
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }",44,,227,2,,void
214269,BLOCK,-1,,"{
      val = GetName(boundFunction.As<Function>());
    }",68,,229,2,,void
214283,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Utf8Value type(env->isolate(), args[0]);
  Local<Value> entry = args[1];
  PerformanceEntryType entry_type = ToPerformanceEntryTypeEnum(*type);
  AliasedUint32Array& observers = env->performance_state()->observers;
  if (entry_type != NODE_PERFORMANCE_ENTRY_TYPE_INVALID &&
      observers[entry_type]) {
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }
}",54,,237,2,,void
214333,BLOCK,-1,,"{
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }",30,,244,2,,void
214358,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",60,,251,2,,void
214391,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int64_t interval = args[0].As<Integer>()->Value();
  CHECK_GT(interval, 0);
  BaseObjectPtr<IntervalHistogram> histogram =
      IntervalHistogram::Create(env, interval, [](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }, Histogram::Options { 1000 });
  args.GetReturnValue().Set(histogram->object());
}",66,,257,2,,void
214446,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      Number::New(args.GetIsolate(), env->time_origin() / NANOS_PER_MILLIS));
}",61,,278,2,,void
214476,BLOCK,1,,<empty>,,,,1,,void
214482,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(Number::New(
      args.GetIsolate(), env->time_origin_timestamp() / MICROS_PER_MILLIS));
}",70,,284,2,,void
214512,BLOCK,1,,<empty>,,,,1,,void
214518,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  realm->env()->performance_state()->Mark(
      performance::NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
}",69,,290,2,,void
214555,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  HistogramBase::Initialize(isolate_data, target);

  SetMethod(isolate, target, ""markMilestone"", MarkMilestone);
  SetMethod(isolate, target, ""setupObservers"", SetupPerformanceObservers);
  SetMethod(isolate,
            target,
            ""installGarbageCollectionTracking"",
            InstallGarbageCollectionTracking);
  SetMethod(isolate,
            target,
            ""removeGarbageCollectionTracking"",
            RemoveGarbageCollectionTracking);
  SetMethod(isolate, target, ""notify"", Notify);
  SetMethod(isolate, target, ""loopIdleTime"", LoopIdleTime);
  SetMethod(isolate, target, ""getTimeOrigin"", GetTimeOrigin);
  SetMethod(isolate, target, ""getTimeOriginTimestamp"", GetTimeOriginTimeStamp);
  SetMethod(isolate, target, ""createELDHistogram"", CreateELDHistogram);
  SetMethod(isolate, target, ""markBootstrapComplete"", MarkBootstrapComplete);
}",70,,298,3,,void
214626,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  PerformanceState* state = env->performance_state();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""observerCounts""),
              state->observers.GetJSArray()).Check();
  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""milestones""),
              state->milestones.GetJSArray()).Check();

  Local<Object> constants = Object::New(isolate);

  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB);

  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED);
  NODE_DEFINE_CONSTANT(
    con...",45,,324,5,,void
214699,BLOCK,1,,<empty>,,,,7,,void
214701,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR)",3,,338,1,,void
214798,BLOCK,1,,<empty>,,,,7,,void
214800,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR)",3,,339,1,,void
214897,BLOCK,1,,<empty>,,,,7,,void
214899,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL)",3,,340,1,,void
214996,BLOCK,1,,<empty>,,,,7,,void
214998,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB)",3,,341,1,,void
215095,BLOCK,1,,<empty>,,,,7,,void
215097,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO)",3,,343,1,,void
215194,BLOCK,1,,<empty>,,,,7,,void
215196,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED)",3,,345,1,,void
215293,BLOCK,1,,<empty>,,,,7,,void
215295,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED)",3,,347,1,,void
215392,BLOCK,1,,<empty>,,,,7,,void
215394,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING)",3,,349,1,,void
215491,BLOCK,1,,<empty>,,,,7,,void
215493,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE)",3,,351,1,,void
215590,BLOCK,1,,<empty>,,,,7,,void
215592,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY)",3,,353,1,,void
215689,BLOCK,1,,<empty>,,,,7,,void
215691,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE)",3,,355,1,,void
215813,BLOCK,-1,,"{
  registry->Register(MarkMilestone);
  registry->Register(SetupPerformanceObservers);
  registry->Register(InstallGarbageCollectionTracking);
  registry->Register(RemoveGarbageCollectionTracking);
  registry->Register(Notify);
  registry->Register(LoopIdleTime);
  registry->Register(GetTimeOrigin);
  registry->Register(GetTimeOriginTimeStamp);
  registry->Register(CreateELDHistogram);
  registry->Register(MarkBootstrapComplete);
  HistogramBase::RegisterExternalReferences(registry);
  IntervalHistogram::RegisterExternalReferences(registry);
}",70,,375,2,,void
215897,BLOCK,-1,,<empty>,1,,1,1,,ANY
215918,BLOCK,-1,,<empty>,1,,1,1,,ANY
215922,BLOCK,-1,,"{
      static_cast<DelayedTaskScheduler*>(data)->Run();
    }",40,,63,2,,void
215935,BLOCK,-1,,<empty>,40,,117,2,,void
215942,BLOCK,-1,,"{
      delete reinterpret_cast<uv_timer_t*>(handle);
    }",77,,157,2,,void
215952,BLOCK,-1,,"{
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_data =
        static_cast<PerIsolatePlatformData*>(flush_tasks->data);
    platform_data->DecreaseHandleCount();
    platform_data->self_reference_.reset();
  }",36,,314,2,,void
215988,BLOCK,-1,,"{
          return delayed.get() == task;
      }",76,,437,2,,void
216002,BLOCK,-1,,"{
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      }",40,,479,2,,void
216027,BLOCK,-1,,"{
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    }",68,,477,2,,void
216040,BLOCK,-1,,"{
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  }",15,,561,1,,void
216066,BLOCK,-1,,<empty>,1,,1,1,,ANY
216077,BLOCK,-1,,"{
  std::unique_ptr<PlatformWorkerData>
      worker_data(static_cast<PlatformWorkerData*>(data));

  TaskQueue<Task>* pending_worker_tasks = worker_data->task_queue;
  TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                        ""PlatformWorkerThread"");

  // Notify the main thread that the platform worker is ready.
  {
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }

  while (std::unique_ptr<Task> task = pending_worker_tasks->BlockingPop()) {
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }
}",46,,27,2,,void
216098,BLOCK,5,,"{
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }",3,,36,5,,void
216130,BLOCK,-1,,"{
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }",76,,42,2,,void
216143,BLOCK,-1,,"{
  if (thread_pool_size < 1) {
    thread_pool_size = uv_available_parallelism() - 1;
  }
  return std::max(thread_pool_size, 1);
}",58,,48,2,,void
216148,BLOCK,-1,,"{
    thread_pool_size = uv_available_parallelism() - 1;
  }",29,,49,2,,void
216165,BLOCK,-1,,<empty>,36,,60,2,,void
216169,BLOCK,-1,,"{
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",40,,62,1,,void
216210,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",77,,74,3,,void
216236,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",15,,80,1,,void
216254,BLOCK,-1,,"{
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",14,,86,1,,void
216297,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",51,,99,2,,void
216332,BLOCK,-1,,<empty>,79,,108,2,,void
216336,BLOCK,-1,,"{
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",25,,110,1,,void
216372,BLOCK,-1,,<empty>,45,,131,4,,void
216376,BLOCK,-1,,"{
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",25,,133,1,,void
216439,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",42,,148,2,,void
216466,BLOCK,-1,,"{
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",58,,154,2,,void
216503,BLOCK,-1,,"{
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  Mutex::ScopedLock lock(platform_workers_mutex);
  int pending_platform_workers = thread_pool_size;

  delayed_task_scheduler_ = std::make_unique<DelayedTaskScheduler>(
      &pending_worker_tasks_);
  threads_.push_back(delayed_task_scheduler_->Start());

  for (int i = 0; i < thread_pool_size; i++) {
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }

  // Wait for platform workers to initialize before continuing with the
  // bootstrap.
  while (pending_platform_workers > 0) {
    platform_workers_ready.Wait(lock);
  }
}",72,,173,2,,void
216532,BLOCK,-1,,<empty>,3,,184,1,,void
216542,BLOCK,4,,"{
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }",46,,184,4,,void
216568,BLOCK,-1,,"{
      break;
    }",45,,191,2,,void
216583,BLOCK,-1,,"{
    platform_workers_ready.Wait(lock);
  }",40,,199,2,,void
216593,BLOCK,-1,,"{
  pending_worker_tasks_.Push(std::move(task));
}",68,,204,2,,void
216608,BLOCK,-1,,"{
  delayed_task_scheduler_->PostDelayedTask(std::move(task), delay_in_seconds);
}",72,,209,3,,void
216622,BLOCK,-1,,"{
  pending_worker_tasks_.BlockingDrain();
}",47,,213,1,,void
216630,BLOCK,-1,,"{
  pending_worker_tasks_.Stop();
  delayed_task_scheduler_->Stop();
  for (size_t i = 0; i < threads_.size(); i++) {
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }
}",42,,217,1,,void
216640,BLOCK,-1,,<empty>,3,,220,1,,void
216653,BLOCK,4,,"{
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }",48,,220,4,,void
216666,BLOCK,-1,,"{
  return threads_.size();
}",60,,225,1,,void
216677,BLOCK,-1,,"{
  flush_tasks_ = new uv_async_t();
  CHECK_EQ(0, uv_async_init(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = static_cast<void*>(this);
  uv_unref(reinterpret_cast<uv_handle_t*>(flush_tasks_));
}",36,,231,3,,void
216702,BLOCK,-1,,"{
  return shared_from_this();
}",51,,239,1,,void
216709,BLOCK,-1,,"{
  auto platform_data = static_cast<PerIsolatePlatformData*>(handle->data);
  platform_data->FlushForegroundTasksInternal();
}",61,,243,2,,void
216726,BLOCK,-1,,"{
  UNREACHABLE();
}",79,,248,2,,void
216732,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  foreground_tasks_.Push(std::move(task));
  uv_async_send(flush_tasks_);
}",67,,252,2,,void
216737,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,253,2,,void
216754,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  std::unique_ptr<DelayedTask> delayed(new DelayedTask());
  delayed->task = std::move(task);
  delayed->platform_data = shared_from_this();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.Push(std::move(delayed));
  uv_async_send(flush_tasks_);
}",58,,263,3,,void
216759,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,264,2,,void
216803,BLOCK,-1,,"{
  PostTask(std::move(task));
}",78,,277,2,,void
216815,BLOCK,-1,,"{
  PostDelayedTask(std::move(task), delay_in_seconds);
}",30,,283,3,,void
216826,BLOCK,-1,,"{
  CHECK(!flush_tasks_);
}",51,,287,1,,void
216835,BLOCK,-1,,"{
  shutdown_callbacks_.emplace_back(ShutdownCallback { callback, data });
}",62,,292,3,,void
216847,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr)
    return;

  // While there should be no V8 tasks in the queues at this point, it is
  // possible that Node.js-internal tasks from e.g. the inspector are still
  // lying around. We clear these queues and ignore the return value,
  // effectively deleting the tasks instead of running them.
  foreground_delayed_tasks_.PopAll();
  foreground_tasks_.PopAll();
  scheduled_delayed_tasks_.clear();

  // Both destroying the scheduled_delayed_tasks_ lists and closing
  // flush_tasks_ handle add tasks to the event loop. We keep a count of all
  // non-closed handles, and when that reaches zero, we inform any shutdown
  // callbacks that the platform is done as far as this Isolate is concerned.
  self_reference_ = shared_from_this();
  uv_close(reinterpret_cast<uv_handle_t*>(flush_tasks_),
           [](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_...",41,,296,1,,void
216852,BLOCK,-1,,<empty>,5,,298,2,,void
216880,BLOCK,-1,,"{
  CHECK_GE(uv_handle_count_, 1);
  if (--uv_handle_count_ == 0) {
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }
}",52,,325,1,,void
216889,BLOCK,-1,,"{
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }",32,,327,2,,void
216906,BLOCK,-1,,"{
  if (tracing_controller != nullptr) {
    tracing_controller_ = tracing_controller;
  } else {
    tracing_controller_ = new v8::TracingController();
  }

  // V8 will default to its built in allocator if none is provided.
  page_allocator_ = page_allocator;

  // TODO(addaleax): It's a bit icky that we use global state here, but we can't
  // really do anything about it unless V8 starts exposing a way to access the
  // current v8::Platform instance.
  SetTracingController(tracing_controller_);
  DCHECK_EQ(GetTracingController(), tracing_controller_);

  thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
  worker_thread_task_runner_ =
      std::make_shared<WorkerThreadsTaskRunner>(thread_pool_size);
}",63,,335,4,,void
216911,BLOCK,-1,,"{
    tracing_controller_ = tracing_controller;
  }",38,,336,2,,void
216916,BLOCK,-1,,"{
    tracing_controller_ = new v8::TracingController();
  }",10,,338,1,,void
216944,BLOCK,-1,,"{
  Shutdown();
}",31,,356,1,,void
216951,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto delegate = std::make_shared<PerIsolatePlatformData>(isolate, loop);
  IsolatePlatformDelegate* ptr = delegate.get();
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(ptr, std::move(delegate)));
  CHECK(insertion.second);
}",71,,360,3,,void
217002,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(delegate, std::shared_ptr<PerIsolatePlatformData>{}));
  CHECK(insertion.second);
}",71,,371,3,,void
217029,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto existing_it = per_isolate_.find(isolate);
  CHECK_NE(existing_it, per_isolate_.end());
  auto& existing = existing_it->second;
  if (existing.second) {
    existing.second->Shutdown();
  }
  per_isolate_.erase(existing_it);
}",56,,379,2,,void
217057,BLOCK,-1,,"{
    existing.second->Shutdown();
  }",24,,384,2,,void
217075,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto it = per_isolate_.find(isolate);
  if (it == per_isolate_.end()) {
    cb(data);
    return;
  }
  CHECK(it->second.second);
  it->second.second->AddShutdownCallback(cb, data);
}",78,,391,4,,void
217094,BLOCK,-1,,"{
    cb(data);
    return;
  }",33,,394,2,,void
217117,BLOCK,-1,,"{
  if (has_shut_down_) return;
  has_shut_down_ = true;
  worker_thread_task_runner_->Shutdown();

  {
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }
}",31,,402,1,,void
217120,BLOCK,-1,,<empty>,23,,403,2,,void
217129,BLOCK,4,,"{
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }",3,,407,4,,void
217140,BLOCK,-1,,"{
  return worker_thread_task_runner_->NumberOfWorkerThreads();
}",43,,413,1,,void
217150,BLOCK,-1,,"{
  if (isolate_->IsExecutionTerminating()) return;
  DebugSealHandleScope scope(isolate_);
  Environment* env = Environment::GetCurrent(isolate_);
  if (env != nullptr) {
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  } else {
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }
}",76,,417,2,,void
217156,BLOCK,-1,,<empty>,43,,418,2,,void
217173,BLOCK,-1,,"{
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  }",23,,421,2,,void
217196,BLOCK,-1,,"{
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }",10,,426,1,,void
217204,BLOCK,-1,,"{
  auto it = std::find_if(scheduled_delayed_tasks_.begin(),
                         scheduled_delayed_tasks_.end(),
                         [task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      });
  CHECK_NE(it, scheduled_delayed_tasks_.end());
  scheduled_delayed_tasks_.erase(it);
}",74,,434,2,,void
217236,BLOCK,-1,,"{
  DelayedTask* delayed = ContainerOf(&DelayedTask::timer, handle);
  delayed->platform_data->RunForegroundTask(std::move(delayed->task));
  delayed->platform_data->DeleteFromScheduledTasks(delayed);
}",68,,444,2,,void
217270,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return;

  do {
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  } while (per_isolate->FlushForegroundTasksInternal());
}",49,,450,2,,void
217284,BLOCK,-1,,<empty>,21,,452,2,,void
217287,BLOCK,-1,,"{
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  }",6,,454,1,,void
217299,BLOCK,-1,,"{
  bool did_work = false;

  while (std::unique_ptr<DelayedTask> delayed =
      foreground_delayed_tasks_.Pop()) {
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCo...",61,,460,1,,void
217317,BLOCK,-1,,"{
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    });
  }",40,,464,2,,void
217396,BLOCK,-1,,"{
    std::unique_ptr<Task> task = std::move(tasks.front());
    tasks.pop();
    did_work = true;
    RunForegroundTask(std::move(task));
  }",26,,490,2,,void
217432,BLOCK,-1,,"{
  worker_thread_task_runner_->PostTask(std::move(task));
}",67,,499,2,,void
217447,BLOCK,-1,,"{
  worker_thread_task_runner_->PostDelayedTask(std::move(task),
                                              delay_in_seconds);
}",71,,504,3,,void
217462,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.first;
}",69,,510,2,,void
217484,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.second;
}",48,,518,2,,void
217506,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return false;
  return per_isolate->FlushForegroundTasksInternal();
}",59,,525,2,,void
217520,BLOCK,-1,,<empty>,21,,527,2,,void
217533,BLOCK,-1,,"{
  return v8::platform::NewDefaultJobHandle(
      this, priority, std::move(job_task), NumberOfWorkerThreads());
}",71,,532,3,,void
217553,BLOCK,-1,,"{
  return ForIsolate(isolate)->IdleTasksEnabled();
}",55,,537,2,,void
217564,BLOCK,-1,,"{
  return ForIsolate(isolate)->GetForegroundTaskRunner();
}",57,,542,2,,void
217574,BLOCK,-1,,"{
  // Convert nanos to seconds.
  return uv_hrtime() / 1e9;
}",52,,546,1,,void
217582,BLOCK,-1,,"{
  return SystemClockTimeMillis();
}",47,,551,1,,void
217588,BLOCK,-1,,"{
  CHECK_NOT_NULL(tracing_controller_);
  return tracing_controller_;
}",61,,555,1,,void
217595,BLOCK,-1,,"{
  return []() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  };
}",66,,560,1,,void
217601,BLOCK,-1,,"{
  return page_allocator_;
}",53,,568,1,,void
217607,BLOCK,-1,,{ },61,,575,1,,void
217612,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  outstanding_tasks_++;
  task_queue_.push(std::move(task));
  tasks_available_.Signal(scoped_lock);
}",50,,578,2,,void
217635,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (task_queue_.empty()) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",40,,586,1,,void
217644,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",28,,588,2,,void
217678,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (task_queue_.empty() && !stopped_) {
    tasks_available_.Wait(scoped_lock);
  }
  if (stopped_) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",48,,597,1,,void
217690,BLOCK,-1,,"{
    tasks_available_.Wait(scoped_lock);
  }",44,,599,2,,void
217698,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",17,,602,2,,void
217732,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (--outstanding_tasks_ == 0) {
    tasks_drained_.Broadcast(scoped_lock);
  }
}",41,,611,1,,void
217741,BLOCK,-1,,"{
    tasks_drained_.Broadcast(scoped_lock);
  }",34,,613,2,,void
217750,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (outstanding_tasks_ > 0) {
    tasks_drained_.Wait(scoped_lock);
  }
}",36,,619,1,,void
217758,BLOCK,-1,,"{
    tasks_drained_.Wait(scoped_lock);
  }",34,,621,2,,void
217767,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  stopped_ = true;
  tasks_available_.Broadcast(scoped_lock);
}",27,,627,1,,void
217782,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  std::queue<std::unique_ptr<T>> result;
  result.swap(task_queue_);
  return result;
}",55,,634,1,,void
217826,BLOCK,-1,,<empty>,1,,1,1,,ANY
217843,BLOCK,-1,,<empty>,1,,1,1,,ANY
217870,BLOCK,-1,,"{
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",23,,52,1,,void
217884,BLOCK,1,,<empty>,,,,1,,void
217899,BLOCK,1,,<empty>,,,,2,,void
218008,BLOCK,-1,,<empty>,1,,1,1,,ANY
218019,BLOCK,-1,,<empty>,1,,1,1,,ANY
218032,BLOCK,-1,,<empty>,1,,1,1,,ANY
218038,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();

  Local<String> event_string;
  if (!String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(event))
      .ToLocal(&event_string)) return MaybeLocal<Value>();

  Local<Object> process = env->process_object();
  Local<Value> argv[] = {event_string, message};
  return MakeCallback(isolate, process, ""emit"", arraysize(argv), argv, {0, 0});
}",53,,23,4,,void
218066,BLOCK,-1,,<empty>,32,,28,2,,void
218103,BLOCK,-1,,"{
  if (!env->can_call_into_js()) return Just(false);

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  Local<Value> emit_warning;
  if (!process->Get(env->context(), env->emit_warning_string())
           .ToLocal(&emit_warning)) {
    return Nothing<bool>();
  }

  if (!emit_warning->IsFunction()) return Just(false);

  int argc = 0;
  Local<Value> args[3];  // warning, type, code

  // The caller has to be able to handle a failure anyway, so we might as well
  // do proper error checking for string creation.
  if (!String::NewFromUtf8(env->isolate(), warning).ToLocal(&args[argc++]))
    return Nothing<bool>();

  if (type != nullptr) {
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(...",57,,38,5,,void
218110,BLOCK,-1,,<empty>,33,,39,2,,void
218160,BLOCK,-1,,"{
    return Nothing<bool>();
  }",37,,47,2,,void
218169,BLOCK,-1,,<empty>,36,,51,2,,void
218203,BLOCK,-1,,<empty>,5,,59,2,,void
218210,BLOCK,-1,,"{
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(code))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
  }",24,,61,2,,void
218232,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,64,2,,void
218260,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,70,2,,void
218281,BLOCK,-1,,"{
    return Nothing<bool>();
  }",23,,79,2,,void
218293,BLOCK,-1,,"{
  if (experimental_warnings.find(warning) != experimental_warnings.end())
    return Nothing<bool>();

  experimental_warnings.insert(warning);
  std::string message(warning);
  message.append("" is an experimental feature and might change at any time"");
  return ProcessEmitWarningGeneric(env, message.c_str(), ""ExperimentalWarning"");
}",64,,89,3,,void
218305,BLOCK,-1,,<empty>,5,,91,2,,void
218335,BLOCK,-1,,"{
  return ProcessEmitWarningGeneric(
      env, warning, ""DeprecationWarning"", deprecation_code);
}",73,,101,4,,void
218394,BLOCK,-1,,<empty>,1,,1,1,,ANY
218400,BLOCK,-1,,"{
  Abort();
}",60,,66,2,,void
218406,BLOCK,-1,,"{
  // This should crash hard all platforms.
  volatile void** d = static_cast<volatile void**>(nullptr);
  *d = nullptr;
}",68,,71,2,,void
218421,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value path(env->isolate(), args[0]);
  int err = uv_chdir(*path);
  if (err) {
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }
}",60,,77,2,,void
218465,BLOCK,-1,,"{
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }",12,,85,2,,void
218493,BLOCK,-1,,"{
  CHECK(args[index]->IsFloat64Array());
  Local<Float64Array> arr = args[index].As<Float64Array>();
  CHECK_EQ(arr->Length(), array_length);
  return arr->Buffer();
}",26,,98,4,,void
218528,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_rusage_t rusage;

  // Call libuv to get the values we'll return.
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 2);
  double* fields = static_cast<double*>(ab->Data());

  // Set the Float64Array elements to be user / system values in microseconds.
  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
}",63,,110,2,,void
218546,BLOCK,-1,,<empty>,5,,117,2,,void
218580,BLOCK,1,,<empty>,,,,1,,void
218599,BLOCK,1,,<empty>,,,,1,,void
218615,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  char buf[PATH_MAX_BYTES];
  size_t cwd_len = sizeof(buf);
  int err = uv_cwd(buf, &cwd_len);
  if (err)
    return env->ThrowUVException(err, ""uv_cwd"");

  Local<String> cwd = String::NewFromUtf8(env->isolate(),
                                          buf,
                                          NewStringType::kNormal,
                                          cwd_len).ToLocalChecked();
  args.GetReturnValue().Set(cwd);
}",58,,128,2,,void
218644,BLOCK,-1,,<empty>,5,,135,2,,void
218686,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  if (args.Length() < 2) {
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }

  int pid;
  if (!args[0]->Int32Value(context).To(&pid)) return;
  int sig;
  if (!args[1]->Int32Value(context).To(&sig)) return;

  uv_pid_t own_pid = uv_os_getpid();
  if (sig > 0 &&
      (pid == 0 || pid == -1 || pid == own_pid || pid == -own_pid) &&
      !HasSignalJSHandler(sig)) {
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }

  int err = uv_kill(pid, sig);
  args.GetReturnValue().Set(err);
}",59,,144,2,,void
218712,BLOCK,-1,,"{
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }",26,,148,2,,void
218731,BLOCK,-1,,<empty>,47,,153,2,,void
218748,BLOCK,-1,,<empty>,47,,155,2,,void
218780,BLOCK,-1,,"{
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }",33,,160,2,,void
218801,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  args.GetReturnValue().Set(static_cast<double>(rss));
}",58,,170,2,,void
218819,BLOCK,-1,,<empty>,5,,176,2,,void
218841,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  // V8 memory usage
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);

  NodeArrayBufferAllocator* array_buffer_allocator =
      env->isolate_data()->node_allocator();

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 5);
  double* fields = static_cast<double*>(ab->Data());

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  fields[0] = static_cast<double>(rss);
  fields[1] = static_cast<double>(v8_heap_stats.total_heap_size());
  fields[2] = static_cast<double>(v8_heap_stats.used_heap_size());
  fields[3] = static_cast<double>(v8_heap_stats.external_memory());
  fields[4] =
      array_buffer_allocator == nullptr
          ? 0
          : static_cast<double>(array_buffer_allocator->total_mem_usage());
}",66,,181,2,,void
218902,BLOCK,-1,,<empty>,5,,199,2,,void
218966,BLOCK,-1,,"{
  uint64_t value = uv_get_constrained_memory();
  if (value != 0) {
    args.GetReturnValue().Set(static_cast<double>(value));
  }
}",75,,211,2,,void
218975,BLOCK,-1,,"{
    args.GetReturnValue().Set(static_cast<double>(value));
  }",19,,213,2,,void
218990,BLOCK,-1,,"{
  CHECK(args.Length() == 1 && args[0]->IsString() &&
        ""must be called with a single string"");
  Utf8Value message(args.GetIsolate(), args[0]);
  FPrintF(stderr, ""%s\n"", message);
  fflush(stderr);
}",56,,218,2,,void
219025,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());
  Mutex::ScopedLock scoped_lock(per_process::umask_mutex);

  uint32_t old;
  if (args[0]->IsUndefined()) {
    old = umask(0);
    umask(static_cast<mode_t>(old));
  } else {
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }

  args.GetReturnValue().Set(old);
}",60,,226,2,,void
219072,BLOCK,-1,,"{
    old = umask(0);
    umask(static_cast<mode_t>(old));
  }",31,,234,2,,void
219082,BLOCK,-1,,"{
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }",10,,237,1,,void
219113,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_update_time(env->event_loop());
  double uptime =
      static_cast<double>(uv_hrtime() - per_process::node_start_time);
  Local<Number> result = Number::New(env->isolate(), uptime / NANOS_PER_SEC);
  args.GetReturnValue().Set(result);
}",61,,245,2,,void
219154,BLOCK,1,,<empty>,,,,1,,void
219168,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> request_v;
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), request_v.data(), request_v.size()));
}",72,,255,2,,void
219193,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }",56,,259,3,,void
219209,BLOCK,-1,,<empty>,7,,262,2,,void
219246,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> handle_v;
  for (auto w : *env->handle_wrap_queue()) {
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }
  args.GetReturnValue().Set(
      Array::New(env->isolate(), handle_v.data(), handle_v.size()));
}",64,,272,2,,void
219271,BLOCK,-1,,"{
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }",44,,276,3,,void
219279,BLOCK,-1,,<empty>,7,,278,2,,void
219316,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::vector<Local<Value>> resources_info;

  // Active requests
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active handles
  for (HandleWrap* w : *env->handle_wrap_queue()) {
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active timeouts
  resources_info.insert(resources_info.end(),
                        env->timeout_info()[0],
                        OneByteString(env->isolate(), ""Timeout""));

  // Active immediates
  resources_info.insert(resources_info.end(),
                        env->immediate_info()->ref_count(),
                        OneByteString(env->isolate(), ""Immediate""));

  args....",77,,285,2,,void
219341,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",56,,290,3,,void
219357,BLOCK,-1,,<empty>,36,,292,2,,void
219379,BLOCK,-1,,"{
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",51,,298,3,,void
219395,BLOCK,-1,,<empty>,62,,299,2,,void
219478,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_rusage_t rusage;
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 16);
  double* fields = static_cast<double*>(ab->Data());

  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
  fields[2] = static_cast<double>(rusage.ru_maxrss);
  fields[3] = static_cast<double>(rusage.ru_ixrss);
  fields[4] = static_cast<double>(rusage.ru_idrss);
  fields[5] = static_cast<double>(rusage.ru_isrss);
  fields[6] = static_cast<double>(rusage.ru_minflt);
  fields[7] = static_cast<double>(rusage.ru_majflt);
  fields[8] = static_cast<double>(rusage.ru_nswap);
  fields[9] = static_cast<double>(rusage.ru_inblock);
  fields[10] = static_cast<double>(rusage.ru_oublock);
  fields[11] = static_cast<double>(rusage.ru_msgsnd);
  fields...",68,,318,2,,void
219496,BLOCK,-1,,<empty>,5,,324,2,,void
219530,BLOCK,1,,<empty>,,,,1,,void
219549,BLOCK,1,,<empty>,,,,1,,void
219691,BLOCK,-1,,"{
#if HAVE_INSPECTOR
  Environment* env = Environment::GetCurrent(args);
  if (env->inspector_agent()->IsListening()) {
    env->inspector_agent()->Stop();
  }
#endif
}",63,,446,2,,void
219696,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  RunAtExit(env);
  ExitCode code = ExitCode::kNoFailure;
  Maybe<int32_t> code_int = args[0]->Int32Value(env->context());
  if (!code_int.IsNothing()) {
    code = static_cast<ExitCode>(code_int.FromJust());
  }
  env->Exit(code);
}",65,,455,2,,void
219735,BLOCK,-1,,"{
    code = static_cast<ExitCode>(code_int.FromJust());
  }",30,,460,2,,void
219755,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, kBufferSize);
  array_buffer_.Reset(isolate, ab);
  object->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""hrtimeBuffer""), ab)
      .ToChecked();
  backing_store_ = ab->GetBackingStore();
}",51,,469,3,,void
219813,BLOCK,-1,,<empty>,,,,2,,<empty>
219818,BLOCK,-1,,<empty>,,,,2,,<empty>
219824,BLOCK,-1,,"{
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtime"", SlowNumber, &fast_number_);
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtimeBigInt"", SlowBigInt, &fast_bigint_);
}",78,,482,3,,void
219843,BLOCK,-1,,"{
  registry->Register(SlowNumber);
  registry->Register(SlowBigInt);
  registry->Register(FastNumber);
  registry->Register(FastBigInt);
  registry->Register(fast_number_.GetTypeInfo());
  registry->Register(fast_bigint_.GetTypeInfo());
}",42,,490,2,,void
219884,BLOCK,-1,,"{
  Local<Object> v8_object = value.As<Object>();
  return static_cast<BindingData*>(
      v8_object->GetAlignedPointerFromInternalField(BaseObject::kSlot));
}",59,,499,2,,void
219909,BLOCK,-1,,"{
  tracker->TrackField(""array_buffer"", array_buffer_);
}",60,,505,2,,void
219920,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint32_t* fields = static_cast<uint32_t*>(receiver->backing_store_->Data());
  fields[0] = (t / NANOS_PER_SEC) >> 32;
  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;
  fields[2] = t % NANOS_PER_SEC;
}",53,,518,2,,void
219952,BLOCK,1,,<empty>,,,,1,,void
219963,BLOCK,1,,<empty>,,,,1,,void
219973,BLOCK,1,,<empty>,,,,1,,void
219979,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint64_t* fields = static_cast<uint64_t*>(receiver->backing_store_->Data());
  fields[0] = t;
}",53,,528,2,,void
220012,BLOCK,-1,,"{
  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
}",71,,536,2,,void
220026,BLOCK,-1,,"{
  NumberImpl(FromJSObject<BindingData>(args.Holder()));
}",79,,540,2,,void
220041,BLOCK,-1,,"{
  // It's not worth keeping.
  // Release it, we will recreate it when the instance is dehydrated.
  array_buffer_.Reset();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,545,3,,void
220052,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,554,2,,void
220077,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,564,5,,void
220117,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  BindingData::AddMethods(isolate, target);
  // define various internal methods
  SetMethod(isolate, target, ""_debugProcess"", DebugProcess);
  SetMethod(isolate, target, ""abort"", Abort);
  SetMethod(isolate, target, ""causeSegfault"", CauseSegfault);
  SetMethod(isolate, target, ""chdir"", Chdir);

  SetMethod(isolate, target, ""umask"", Umask);
  SetMethod(isolate, target, ""memoryUsage"", MemoryUsage);
  SetMethod(isolate, target, ""constrainedMemory"", GetConstrainedMemory);
  SetMethod(isolate, target, ""rss"", Rss);
  SetMethod(isolate, target, ""cpuUsage"", CPUUsage);
  SetMethod(isolate, target, ""resourceUsage"", ResourceUsage);

  SetMethod(isolate, target, ""_debugEnd"", DebugEnd);
  SetMethod(isolate, target, ""_getActiveRequests"", GetActiveRequests);
  SetMethod(isolate, target, ""_getActiveHandles"", GetActiveHandles);
  SetMethod(isolate, target, ""getActiveResourcesInfo"", GetActiveResourcesInfo);
  SetMethod(isolate, target, ""_kill"", Kill);...",70,,574,3,,void
220245,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,608,5,,void
220268,BLOCK,-1,,"{
  BindingData::RegisterExternalReferences(registry);

  registry->Register(DebugProcess);
  registry->Register(DebugEnd);
  registry->Register(Abort);
  registry->Register(CauseSegfault);
  registry->Register(Chdir);

  registry->Register(Umask);
  registry->Register(RawDebug);
  registry->Register(MemoryUsage);
  registry->Register(GetConstrainedMemory);
  registry->Register(Rss);
  registry->Register(CPUUsage);
  registry->Register(ResourceUsage);

  registry->Register(GetActiveRequests);
  registry->Register(GetActiveHandles);
  registry->Register(GetActiveResourcesInfo);
  registry->Register(Kill);

  registry->Register(Cwd);
  registry->Register(binding::DLOpen);
  registry->Register(ReallyExit);
  registry->Register(Uptime);
  registry->Register(PatchProcessObject);
}",70,,613,2,,void
220388,BLOCK,-1,,{ return a.first < b.first; },34,,129,3,,void
220425,BLOCK,-1,,<empty>,1,,1,1,,ANY
220430,BLOCK,-1,,"{
  std::string title = GetProcessTitle(""node"");
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), title.data(),
                          NewStringType::kNormal, title.size())
      .ToLocalChecked());
}",73,,35,3,,void
220471,BLOCK,-1,,"{
  node::Utf8Value title(info.GetIsolate(), value);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""process_name"", ""name"", TRACE_STR_COPY(*title));
  uv_set_process_title(*title);
}",72,,45,4,,void
220494,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  int port = host_port->port();
  info.GetReturnValue().Set(port);
}",70,,53,3,,void
220530,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  int32_t port = value->Int32Value(env->context()).FromMaybe(0);

  if ((port != 0 && port < 1024) || port > 65535) {
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }

  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  host_port->set_port(static_cast<int>(port));
}",69,,62,4,,void
220566,BLOCK,-1,,"{
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }",51,,66,2,,void
220589,BLOCK,-1,,"{
  info.GetReturnValue().Set(uv_os_getppid());
}",73,,77,3,,void
220602,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version is always on the top
  READONLY_STRING_PROPERTY(
    ...",54,,81,2,,void
220679,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,91,2,,void
220708,BLOCK,-1,,"{
    return {};
  }",25,,100,2,,void
220779,BLOCK,-1,,"{
    versions
        ->DefineOwnProperty(
            context,
            OneByteString(isolate, version.first.data(), version.first.size()),
            OneByteString(
                isolate, version.second.data(), version.second.size()),
            v8::ReadOnly)
        .Check();
  }",46,,131,3,,void
220879,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  CHECK(args[0]->IsObject());
  Local<Object> process = args[0].As<Object>();

  // process.title
  CHECK(process
            ->SetAccessor(
                context,
                FIXED_ONE_BYTE_STRING(isolate, ""title""),
                ProcessTitleGetter,
                env->owns_process_state() ? ProcessTitleSetter : nullptr,
                Local<Value>(),
                DEFAULT,
                None,
                SideEffectType::kHasNoSideEffect)
            .FromJust());

  // process.argv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""argv""),
               ToV8Value(context, env->argv()).ToLocalChecked()).Check();

  // process.execArgv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""execArgv""),
               ToV8Value(context, env->exec_argv())
                   .ToLoc...",66,,177,2,,void
221075,BLOCK,-1,,"{
  registry->Register(RawDebug);
  registry->Register(GetParentProcessId);
  registry->Register(DebugPortSetter);
  registry->Register(DebugPortGetter);
  registry->Register(ProcessTitleSetter);
  registry->Register(ProcessTitleGetter);
}",77,,246,2,,void
221117,BLOCK,-1,,<empty>,1,,1,1,,ANY
221121,BLOCK,-1,,"{
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  }",42,,225,2,,void
221150,BLOCK,-1,,"{
    if (obj->IsNotIndicativeOfMemoryLeakAtExit()) return;
    fprintf(stderr,
            ""Found bad BaseObject during clean exit: %s\n"",
            obj->MemoryInfoName());
    fflush(stderr);
    ABORT();
  }",41,,268,2,,void
221156,BLOCK,-1,,<empty>,51,,269,2,,void
221184,BLOCK,-1,,<empty>,1,,1,1,,ANY
221190,BLOCK,-1,,"{
  context_.Reset(isolate_, context);
  env->AssignToContext(context, this, ContextInfo(""""));
}",63,,22,4,,void
221208,BLOCK,-1,,"{
  CHECK_EQ(base_object_count_, 0);
}",17,,27,1,,void
221216,BLOCK,-1,,"{
#define V(PropertyName, TypeName)                                              \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_REALM_STRONG_PERSISTENT_VALUES(V)
#undef V

  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""builtins_with_cache"", builtins_with_cache);
  tracker->TrackField(""builtins_without_cache"", builtins_without_cache);
}",54,,31,2,,void
221240,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BYTE_STRING(isolate(), Primordial...",32,,42,1,,void
221301,BLOCK,1,,"V(primordials_safe_map_prototype_object, ""SafeMap"")",3,,72,9,,void
221357,BLOCK,1,,"V(primordials_safe_set_prototype_object, ""SafeSet"")",3,,73,10,,void
221413,BLOCK,1,,"V(primordials_safe_weak_map_prototype_object, ""SafeWeakMap"")",3,,74,11,,void
221469,BLOCK,1,,"V(primordials_safe_weak_set_prototype_object, ""SafeWeakSet"")",3,,75,12,,void
221543,BLOCK,-1,,"{
  RealmSerializeInfo info;
  Local<Context> ctx = context();

  // Currently all modules are compiled without cache in builtin snapshot
  // builder.
  info.builtins = std::vector<std::string>(builtins_without_cache.begin(),
                                           builtins_without_cache.end());

  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    Local<TypeName> field = PropertyName();                                    \
    if (!field.IsEmpty()) {                                                    \
      size_t index = creator->AddData(ctx, field);                             \
      info.persistent_values.push_back({#PropertyName, id, index});            \
    }                                                                          \
    id++;                                                                      \
  } while (0);
  PER_REALM_S...",63,,86,2,,void
221601,BLOCK,-1,,"{
  Local<Context> ctx = context();

  builtins_in_snapshot = info->builtins;

  const std::vector<PropInfo>& values = info->persistent_values;
  size_t i = 0;  // index to the array
  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    if (values.size() > i && id == values[i].id) {                             \
      const PropInfo& d = values[i];                                           \
      DCHECK_EQ(d.name, #PropertyName);                                        \
      MaybeLocal<TypeName> maybe_field =                                       \
          ctx->GetDataFromSnapshotOnce<TypeName>(d.index);                     \
      Local<TypeName> field;                                                   \
      if (!maybe_field.ToLocal(&field)) {                                      \
        fprintf(stderr,                                           ...",67,,116,2,,void
221657,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to deserialize context back reference from the snapshot\n"");
  }",61,,148,2,,void
221669,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate());
  Local<Context> ctx = context();
  MaybeLocal<Value> result =
      env()->builtin_loader()->CompileAndCall(ctx, id, this);

  // If there was an error during bootstrap, it must be unrecoverable
  // (e.g. max call stack exceeded). Clear the stack so that the
  // AsyncCallbackScope destructor doesn't fail on the id check.
  // There are only two ways to have a stack size > 1: 1) the user manually
  // called MakeCallback or 2) user awaited during bootstrap, which triggered
  // _tickCallback().
  if (result.IsEmpty()) {
    env()->async_hooks()->clear_async_id_stack();
  }

  return scope.EscapeMaybe(result);
}",62,,157,2,,void
221701,BLOCK,-1,,"{
    env()->async_hooks()->clear_async_id_stack();
  }",25,,169,2,,void
221718,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate_);

  CHECK(!has_run_bootstrapping_code());

  Local<Value> result;
  if (!ExecuteBootstrapper(""internal/bootstrap/realm"").ToLocal(&result) ||
      !BootstrapRealm().ToLocal(&result)) {
    return MaybeLocal<Value>();
  }

  DoneBootstrapping();

  return scope.Escape(result);
}",45,,176,1,,void
221747,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",43,,183,2,,void
221760,BLOCK,-1,,"{
  // Make sure that no request or handle is created during bootstrap -
  // if necessary those should be done in pre-execution.
  // Usually, doing so would trigger the checks present in the ReqWrap and
  // HandleWrap classes, so this is only a consistency check.

  // TODO(legendecas): track req_wrap and handle_wrap by realms instead of
  // environments.
  if (kind_ == kPrincipal) {
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }

  has_run_bootstrapping_code_ = true;

  // This adjusts the return value of base_object_created_after_bootstrap() so
  // that tests that check the count do not have to account for internally
  // created BaseObjects.
  base_object_created_by_bootstrap_ = base_object_count_;
}",33,,192,1,,void
221765,BLOCK,-1,,"{
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }",28,,200,2,,void
221791,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(realm), ""RunCleanup"");
  for (size_t i = 0; i < binding_data_store_.size(); ++i) {
    binding_data_store_[i].reset();
  }
  cleanup_queue_.Drain();
}",26,,213,1,,void
221797,BLOCK,-1,,<empty>,3,,215,1,,void
221810,BLOCK,4,,"{
    binding_data_store_[i].reset();
  }",59,,215,4,,void
221824,BLOCK,-1,,"{
  fprintf(stderr, ""Realm = %p\n"", this);
  fprintf(stderr, ""BaseObjects of the Realm:\n"");
  size_t i = 0;
  ForEachBaseObject([&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  });

  fprintf(stderr, ""\nBuiltins without cache:\n"");
  for (const auto& s : builtins_without_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nBuiltins with cache:\n"");
  for (const auto& s : builtins_with_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nStatic bindings (need to be registered):\n"");
  for (const auto mod : internal_bindings) {
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }

  fprintf(stderr, ""End of the Realm.\n"");
}",36,,221,1,,void
221843,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",48,,231,3,,void
221857,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",45,,235,3,,void
221871,BLOCK,-1,,"{
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }",44,,239,3,,void
221887,BLOCK,-1,,"{
  // When a process exits cleanly, i.e. because the event loop ends up without
  // things to wait for, the Node.js objects that are left on the heap should
  // be:
  //
  //   1. weak, i.e. ready for garbage collection once no longer referenced, or
  //   2. detached, i.e. scheduled for destruction once no longer referenced, or
  //   3. an unrefed libuv handle, i.e. does not keep the event loop alive, or
  //   4. an inactive libuv handle (essentially the same here)
  //
  // There are a few exceptions to this rule, but generally, if there are
  // C++-backed Node.js objects on the heap that do not fall into the above
  // categories, we may be looking at a potential memory leak. Most likely,
  // the cause is a missing MakeWeak() call on the corresponding object.
  //
  // In order to avoid this kind of problem, we check the list of BaseObjects
  // for these criteria. Currently, we only do so when explicitly instructed to
  // or when in debug mode (where --verify-base-object...",41,,246,1,,void
221896,BLOCK,-1,,<empty>,47,,266,2,,void
221903,BLOCK,-1,,"{
  return PersistentToLocal::Strong(context_);
}",47,,278,1,,void
221918,BLOCK,-1,,"{
  // Create properties if not deserializing from snapshot.
  // Or the properties are deserialized with DeserializeProperties() when the
  // env drained the deserialize requests.
  if (realm_info == nullptr) {
    CreateProperties();
  }
}",39,,299,4,,void
221923,BLOCK,-1,,"{
    CreateProperties();
  }",30,,303,2,,void
221928,BLOCK,-1,,"{
  DCHECK(!context_.IsEmpty());

  HandleScope handle_scope(isolate());
  env_->UnassignFromContext(context());
}",35,,308,1,,void
221946,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  if (ExecuteBootstrapper(""internal/bootstrap/node"").IsEmpty()) {
    return MaybeLocal<Value>();
  }

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  // TODO(joyeecheung): skip these in the snapshot building for workers.
  auto thread_switch_id =
      env_->is_main_thread() ? ""internal/bootstrap/switches/is_main_thread""
                             : ""internal/bootstrap/switches/is_not_main_thread"";
  if (ExecuteBootstrapper(thread_switch_id).IsEmpty()) {
    return MaybeLocal<Value>();
  }

  auto process_state_switch_id =
      env_->owns_process_state()
          ? ""internal/bootstrap/switches/does_own_process_state""
          : ""internal/bootstrap/switches/does_not_own_process_state"";
  if (ExecuteBootstrapper...",52,,315,1,,void
221956,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",65,,318,2,,void
221965,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,322,2,,void
221978,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,326,2,,void
221997,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",56,,335,2,,void
222016,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",63,,343,2,,void
222065,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",76,,351,2,,void
222092,BLOCK,-1,,<empty>,1,,1,1,,ANY
222096,BLOCK,-1,,"{
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      }",69,,227,2,,void
222130,BLOCK,-1,,"{
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    }",39,,226,2,,void
222144,BLOCK,-1,,"{
                return !std::iswspace(ch);
              }",70,,538,2,,void
222158,BLOCK,-1,,{ return a.first < b.first; },34,,817,3,,void
222210,BLOCK,-1,,<empty>,1,,1,1,,ANY
222242,BLOCK,-1,,<empty>,,,,9,,<empty>
222247,BLOCK,-1,,<empty>,,,,2,,<empty>
222255,BLOCK,-1,,<empty>,,,,5,,<empty>
222260,BLOCK,-1,,<empty>,,,,2,,<empty>
222267,BLOCK,-1,,<empty>,,,,4,,<empty>
222274,BLOCK,-1,,<empty>,,,,4,,<empty>
222279,BLOCK,-1,,<empty>,,,,2,,<empty>
222284,BLOCK,-1,,<empty>,,,,2,,<empty>
222290,BLOCK,-1,,<empty>,,,,3,,<empty>
222295,BLOCK,-1,,<empty>,,,,2,,<empty>
222300,BLOCK,-1,,<empty>,,,,2,,<empty>
222305,BLOCK,-1,,<empty>,,,,2,,<empty>
222310,BLOCK,-1,,<empty>,,,,2,,<empty>
222315,BLOCK,-1,,<empty>,,,,2,,<empty>
222320,BLOCK,-1,,<empty>,,,,2,,<empty>
222330,BLOCK,-1,,"{
  // Obtain the current time and the pid.
  TIME_TYPE tm_struct;
  DiagnosticFilename::LocalTime(&tm_struct);
  uv_pid_t pid = uv_os_getpid();

  // Save formatting for output stream.
  std::ios old_state(nullptr);
  old_state.copyfmt(out);

  // File stream opened OK, now start printing the report content:
  // the title and header information (event, filename, timestamp and pid)

  JSONWriter writer(out, compact);
  writer.json_start();
  writer.json_objectstart(""header"");
  writer.json_keyvalue(""reportVersion"", NODE_REPORT_VERSION);
  writer.json_keyvalue(""event"", message);
  writer.json_keyvalue(""trigger"", trigger);
  if (!filename.empty())
    writer.json_keyvalue(""filename"", filename);
  else
    writer.json_keyvalue(""filename"", JSONWriter::Null{});

  // Report dump event and module load date/time stamps
  char timebuf[64];
#ifdef _WIN32
  snprintf(timebuf,
           sizeof(timebuf),
           ""%4d-%02d-%02dT%02d:%02d:%02dZ"",
           tm_struct.wYear,
           tm_stru...",43,,95,9,,void
222387,BLOCK,-1,,<empty>,5,,115,2,,void
222395,BLOCK,-1,,<empty>,5,,117,1,,void
222444,BLOCK,-1,,"{
    writer.json_keyvalue(""dumpEventTimeStamp"",
                         std::to_string(ts.tv_sec * 1000 + ts.tv_usec / 1000));
  }",34,,146,2,,void
222475,BLOCK,-1,,<empty>,5,,154,2,,void
222486,BLOCK,-1,,<empty>,5,,156,1,,void
222494,BLOCK,23,,"{
    // Report the process cwd.
    char buf[PATH_MAX_BYTES];
    size_t cwd_size = sizeof(buf);
    if (uv_cwd(buf, &cwd_size) == 0)
      writer.json_keyvalue(""cwd"", buf);
  }",3,,158,23,,void
222508,BLOCK,-1,,<empty>,7,,163,2,,void
222525,BLOCK,-1,,"{
    writer.json_arraystart(""commandLine"");
    for (const std::string& arg : per_process::cli_options->cmdline) {
      writer.json_element(arg);
    }
    writer.json_arrayend();
  }",51,,167,2,,void
222538,BLOCK,-1,,"{
      writer.json_element(arg);
    }",70,,169,3,,void
222559,BLOCK,-1,,"{
    writer.json_objectstart(""javascriptStack"");
    // Report summary JavaScript error stack backtrace
    PrintJavaScriptErrorStack(&writer, isolate, error, trigger);

    writer.json_objectend();  // the end of 'javascriptStack'

    // Report V8 Heap and Garbage Collector information
    PrintGCStatistics(&writer, isolate);
  }",27,,179,2,,void
222580,BLOCK,-1,,"{
    writer.json_objectstart(""javascriptStack"");
    PrintEmptyJavaScriptStack(&writer);
    writer.json_objectend();  // the end of 'javascriptStack'
  }",10,,188,1,,void
222608,BLOCK,-1,,"{
    uv_walk(env->event_loop(), WalkHandle, static_cast<void*>(&writer));

    writer.json_start();
    writer.json_keyvalue(""type"", ""loop"");
    writer.json_keyvalue(""is_active"",
        static_cast<bool>(uv_loop_alive(env->event_loop())));
    writer.json_keyvalue(""address"",
        ValueToHexString(reinterpret_cast<int64_t>(env->event_loop())));

    // Report Event loop idle time
    uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
    writer.json_keyvalue(""loopIdleTimeSeconds"", 1.0 * idle_time / 1e9);
    writer.json_end();
  }",23,,201,2,,void
222688,BLOCK,-1,,"{
    Mutex workers_mutex;
    ConditionVariable notify;
    std::vector<std::string> worker_infos;
    size_t expected_results = 0;

    env->ForEachWorker([&](Worker* w) {
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    });

    Mutex::ScopedLock lock(workers_mutex);
    worker_infos.reserve(expected_results);
    while (worker_infos.size() < expected_results)
      notify.Wait(lock);
    for (const std::string& worker_info : worker_infos)
      writer.json_element(JSONWriter::ForeignJSON { worker_info });
  }",23,,220,2,,void
222756,BLOCK,-1,,"{
  std::ostringstream buf;
  // Report Node version
  buf << ""v"" << NODE_VERSION_STRING;
  writer->json_keyvalue(""nodejsVersion"", buf.str());
  buf.str("""");

#ifndef _WIN32
  // Report compiler and runtime glibc versions where possible.
  const char* (*libc_version)();
  *(reinterpret_cast<void**>(&libc_version)) =
      dlsym(RTLD_DEFAULT, ""gnu_get_libc_version"");
  if (libc_version != nullptr)
    writer->json_keyvalue(""glibcVersionRuntime"", (*libc_version)());
#endif /* _WIN32 */

#ifdef __GLIBC__
  buf << __GLIBC__ << ""."" << __GLIBC_MINOR__;
  writer->json_keyvalue(""glibcVersionCompiler"", buf.str());
  buf.str("""");
#endif

  // Report Process word size
  writer->json_keyvalue(""wordSize"", sizeof(void*) * 8);
  writer->json_keyvalue(""arch"", per_process::metadata.arch);
  writer->json_keyvalue(""platform"", per_process::metadata.platform);

  // Report deps component versions
  PrintComponentVersions(writer);

  // Report release metadata.
  PrintRelease(writer);

  // Report operat...",57,,258,2,,void
222778,BLOCK,-1,,<empty>,,,,1,,<empty>
222794,BLOCK,-1,,<empty>,5,,271,2,,void
222843,BLOCK,-1,,"{
    writer->json_keyvalue(""osName"", os_info.sysname);
    writer->json_keyvalue(""osRelease"", os_info.release);
    writer->json_keyvalue(""osVersion"", os_info.version);
    writer->json_keyvalue(""osMachine"", os_info.machine);
  }",35,,294,2,,void
222893,BLOCK,-1,,<empty>,5,,308,2,,void
222904,BLOCK,-1,,"{
  uv_cpu_info_t* cpu_info;
  int count;
  if (uv_cpu_info(&cpu_info, &count) == 0) {
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }
}",46,,312,2,,void
222915,BLOCK,-1,,"{
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }",44,,315,2,,void
222922,BLOCK,-1,,<empty>,5,,317,1,,void
222932,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }",37,,317,4,,void
223032,BLOCK,-1,,"{
  uv_interface_address_t* interfaces;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  char mac[18];
  int count;

  if (uv_interface_addresses(&interfaces, &count) == 0) {
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac)...",59,,333,2,,void
223046,BLOCK,-1,,"{
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask...",57,,340,2,,void
223053,BLOCK,-1,,<empty>,5,,343,1,,void
223063,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        write...",37,,343,4,,void
223167,BLOCK,-1,,"{
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv4"");
      }",65,,358,2,,void
223211,BLOCK,-1,,<empty>,14,,364,1,,void
223224,BLOCK,-1,,"{
        uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
        uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv6"");
        writer->json_keyvalue(""scopeid"",
                              interfaces[i].address.address6.sin6_scope_id);
      }",73,,364,2,,void
223282,BLOCK,-1,,"{
        writer->json_keyvalue(""family"", ""unknown"");
      }",14,,372,1,,void
223306,BLOCK,-1,,"{
  writer->json_objectstart(""errorProperties"");
  if (!error.IsEmpty() && error->IsObject()) {
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->jso...",64,,386,4,,void
223323,BLOCK,-1,,"{
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }
  }",46,,388,2,,void
223367,BLOCK,-1,,"{
      return writer->json_objectend();  // the end of 'errorProperties'
    }",66,,393,2,,void
223381,BLOCK,-1,,<empty>,5,,397,1,,void
223391,BLOCK,4,,"{
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }",48,,397,4,,void
223416,BLOCK,-1,,"{
        continue;
      }",69,,399,2,,void
223453,BLOCK,-1,,"{
        continue;
      }",61,,405,2,,void
223467,BLOCK,-1,,<empty>,43,,409,2,,void
223495,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return Nothing<std::string>();
  }

  MaybeLocal<String> maybe_str;
  // `ToString` is not available to Symbols.
  if (error->IsSymbol()) {
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  } else if (!error->IsObject()) {
    maybe_str = error->ToString(context);
  } else if (error->IsObject()) {
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }

  Local<String> js_str;
  if (!maybe_str.ToLocal(&js_str)) {
    return Nothing<std::string>();
  }
  String::Utf8Value sv(isolate, js_str);
  return Just<>(std::string(*sv, sv.length()));
}",61,,419,4,,void
223501,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",24,,420,2,,void
223515,BLOCK,-1,,"{
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  }",26,,426,2,,void
223527,BLOCK,-1,,<empty>,10,,428,1,,void
223534,BLOCK,-1,,"{
    maybe_str = error->ToString(context);
  }",34,,428,2,,void
223543,BLOCK,-1,,<empty>,10,,430,1,,void
223549,BLOCK,-1,,"{
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }",33,,430,2,,void
223581,BLOCK,-1,,"{
      maybe_str = stack.ToLocalChecked().As<String>();
    }",65,,433,2,,void
223604,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",36,,439,2,,void
223628,BLOCK,-1,,"{
  writer->json_keyvalue(""message"", ""No stack."");
  writer->json_arraystart(""stack"");
  writer->json_element(""Unavailable."");
  writer->json_arrayend();

  writer->json_objectstart(""errorProperties"");
  writer->json_objectend();
}",59,,446,2,,void
223664,BLOCK,-1,,"{
  // Can not capture the stacktrace when the isolate is in a OOM state or no
  // context is entered.
  if (!strcmp(trigger, ""OOMError"") || !isolate->InContext()) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  HandleScope scope(isolate);
  RegisterState state;
  state.pc = nullptr;
  state.fp = &state;
  state.sp = &state;

  // in-out params
  SampleInfo info;
  void* samples[MAX_FRAME_COUNT];
  isolate->GetStackSample(state, samples, MAX_FRAME_COUNT, &info);

  constexpr StackTrace::StackTraceOptions stack_trace_options =
      static_cast<StackTrace::StackTraceOptions>(
          StackTrace::kDetailed |
          StackTrace::kExposeFramesAcrossSecurityOrigins);
  Local<StackTrace> stack = StackTrace::CurrentStackTrace(
      isolate, MAX_FRAME_COUNT, stack_trace_options);

  if (stack->GetFrameCount() == 0) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  writer->json_keyvalue(""message"", trigger);
  writer->json_arraystart(""stack"");
  for (int i = 0; i <...",55,,459,4,,void
223676,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",62,,462,2,,void
223744,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",36,,485,2,,void
223760,BLOCK,-1,,<empty>,3,,492,1,,void
223773,BLOCK,4,,"{
    Local<StackFrame> frame = stack->GetFrame(isolate, i);

    Utf8Value function_name(isolate, frame->GetFunctionName());
    Utf8Value script_name(isolate, frame->GetScriptName());
    const int line_number = frame->GetLineNumber();
    const int column = frame->GetColumn();

    std::string stack_line = SPrintF(
        ""at %s (%s:%d:%d)"", *function_name, *script_name, line_number, column);
    writer->json_element(stack_line);
  }",52,,492,4,,void
223850,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return PrintJavaScriptStack(writer, isolate, trigger);
  }

  TryCatch try_catch(isolate);
  HandleScope scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  std::string ss = """";
  if (!ErrorToString(isolate, context, error).To(&ss)) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  int line = ss.find('\n');
  if (line == -1) {
    writer->json_keyvalue(""message"", ss);
  } else {
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }

  // Report summary JavaScript error properties backtrace...",60,,513,5,,void
223856,BLOCK,-1,,"{
    return PrintJavaScriptStack(writer, isolate, trigger);
  }",24,,514,2,,void
223893,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",56,,522,2,,void
223910,BLOCK,-1,,"{
    writer->json_keyvalue(""message"", ss);
  }",19,,528,2,,void
223918,BLOCK,-1,,"{
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }",10,,530,1,,void
223960,BLOCK,-1,,"{
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }",24,,536,2,,void
224023,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  writer->json_arraystart(""nativeStack"");
  int i;
  for (i = 1; i < size; i++) {
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }
  writer->json_arrayend();
}",50,,553,2,,void
224049,BLOCK,-1,,<empty>,3,,559,1,,void
224058,BLOCK,4,,"{
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }",30,,559,4,,void
224104,BLOCK,-1,,"{
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);
  HeapSpaceStatistics v8_heap_space_stats;

  writer->json_objectstart(""javascriptHeap"");
  writer->json_keyvalue(""totalMemory"", v8_heap_stats.total_heap_size());
  writer->json_keyvalue(""executableMemory"",
                        v8_heap_stats.total_heap_size_executable());
  writer->json_keyvalue(""totalCommittedMemory"",
                        v8_heap_stats.total_physical_size());
  writer->json_keyvalue(""availableMemory"",
                        v8_heap_stats.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesMemory"",
                        v8_heap_stats.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesMemory"",
                        v8_heap_stats.used_global_handles_size());
  writer->json_keyvalue(""usedMemory"", v8_heap_stats.used_heap_size());
  writer->json_keyvalue(""memoryLimit"", v8_heap_stats.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", v...",69,,574,3,,void
224250,BLOCK,-1,,<empty>,3,,605,1,,void
224263,BLOCK,4,,"{
    isolate->GetHeapSpaceStatistics(&v8_heap_space_stats, i);
    writer->json_objectstart(v8_heap_space_stats.space_name());
    writer->json_keyvalue(""memorySize"", v8_heap_space_stats.space_size());
    writer->json_keyvalue(
        ""committedMemory"",
        v8_heap_space_stats.physical_space_size());
    writer->json_keyvalue(
        ""capacity"",
        v8_heap_space_stats.space_used_size() +
            v8_heap_space_stats.space_available_size());
    writer->json_keyvalue(""used"", v8_heap_space_stats.space_used_size());
    writer->json_keyvalue(
        ""available"", v8_heap_space_stats.space_available_size());
    writer->json_objectend();
  }",62,,605,4,,void
224345,BLOCK,-1,,"{
  // Get process uptime in seconds
  uint64_t uptime =
      (uv_hrtime() - per_process::node_start_time) / (NANOS_PER_SEC);
  if (uptime == 0) uptime = 1;  // avoid division by zero.

  // Process and current thread usage statistics
  uv_rusage_t rusage;
  writer->json_objectstart(""resourceUsage"");

  uint64_t free_memory = uv_get_free_memory();
  uint64_t total_memory = uv_get_total_memory();

  writer->json_keyvalue(""free_memory"", free_memory);
  writer->json_keyvalue(""total_memory"", total_memory);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (!err) {
    writer->json_keyvalue(""rss"", rss);
  }

  uint64_t constrained_memory = uv_get_constrained_memory();
  if (constrained_memory) {
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }

  // See GuessMemoryAvailableToTheProcess
  if (!err && constrained_memory && constrained_memory >= rss) {
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"",...",52,,626,2,,void
224360,BLOCK,-1,,<empty>,20,,630,2,,void
224400,BLOCK,-1,,"{
    writer->json_keyvalue(""rss"", rss);
  }",13,,644,2,,void
224413,BLOCK,-1,,"{
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }",27,,649,2,,void
224429,BLOCK,-1,,"{
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"", available_memory);
  }",64,,654,2,,void
224443,BLOCK,-1,,"{
    writer->json_keyvalue(""available_memory"", free_memory);
  }",10,,657,1,,void
224456,BLOCK,-1,,"{
    double user_cpu =
        rusage.ru_utime.tv_sec + SEC_PER_MICROS * rusage.ru_utime.tv_usec;
    double kernel_cpu =
        rusage.ru_stime.tv_sec + SEC_PER_MICROS * rusage.ru_stime.tv_usec;
    writer->json_keyvalue(""userCpuSeconds"", user_cpu);
    writer->json_keyvalue(""kernelCpuSeconds"", kernel_cpu);
    double cpu_abs = user_cpu + kernel_cpu;
    double cpu_percentage = (cpu_abs / uptime) * 100.0;
    double user_cpu_percentage = (user_cpu / uptime) * 100.0;
    double kernel_cpu_percentage = (kernel_cpu / uptime) * 100.0;
    writer->json_keyvalue(""cpuConsumptionPercent"", cpu_percentage);
    writer->json_keyvalue(""userCpuConsumptionPercent"", user_cpu_percentage);
    writer->json_keyvalue(""kernelCpuConsumptionPercent"", kernel_cpu_percentage);
    writer->json_keyvalue(""maxRss"", rusage.ru_maxrss * 1024);
    writer->json_objectstart(""pageFaults"");
    writer->json_keyvalue(""IORequired"", rusage.ru_majflt);
    writer->json_keyvalue(""IONotRequired"", rusage.ru_minflt);
    ...",35,,661,2,,void
224617,BLOCK,-1,,"{
  uv_env_item_t* envitems;
  int envcount;
  int r;

  writer->json_objectstart(""environmentVariables"");

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }

  if (r == 0) {
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }

  writer->json_objectend();

#ifndef _WIN32
  static struct {
    const char* description;
    int id;
  } rlimit_strings[] = {
    {""core_file_size_blocks"", RLIMIT_CORE},
    {""data_seg_size_kbytes"", RLIMIT_DATA},
    {""file_size_blocks"", RLIMIT_FSIZE},
#if !(defined(_AIX) || defined(__sun))
    {""max_locked_memory_bytes"", RLIMIT_MEMLOCK},
#endif
#ifndef __sun
    {""max_memory_size_kbytes"", RLIMIT_RSS},
#endif
    {""open_files"", RLIMIT_NOFILE},
    {""stack_size_bytes"", RLIMIT_STACK},
    {""cpu_time_seconds"", RLIMIT_CPU},
#ifndef __sun
    {""max_user_processes"", RLIMIT_NPROC},
#endif
#ifndef __OpenBSD...",56,,713,2,,void
224626,BLOCK,5,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }",3,,720,5,,void
224643,BLOCK,-1,,"{
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }",15,,725,2,,void
224645,BLOCK,-1,,<empty>,5,,726,1,,void
224719,BLOCK,-1,,<empty>,3,,763,1,,void
224730,BLOCK,4,,"{
    if (getrlimit(rlimit_strings[i].id, &limit) == 0) {
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }
  }",58,,763,4,,void
224742,BLOCK,-1,,"{
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }",55,,764,2,,void
224758,BLOCK,-1,,<empty>,9,,768,2,,void
224766,BLOCK,-1,,<empty>,9,,770,1,,void
224781,BLOCK,-1,,<empty>,9,,773,2,,void
224789,BLOCK,-1,,<empty>,9,,775,1,,void
224812,BLOCK,-1,,"{
  writer->json_arraystart(""sharedObjects"");
  std::vector<std::string> modules =
      NativeSymbolDebuggingContext::GetLoadedLibraries();
  for (auto const& module_name : modules) writer->json_element(module_name);
  writer->json_arrayend();
}",54,,787,2,,void
224848,BLOCK,-1,,"{
  std::stringstream buf;

  writer->json_objectstart(""componentVersions"");

#define V(key) +1
  std::pair<std::string_view, std::string_view>
      versions_array[NODE_VERSIONS_KEYS(V)];
#undef V
  auto* slot = &versions_array[0];

#define V(key)                                                                 \
  do {                                                                         \
    *slot++ = std::pair<std::string_view, std::string_view>(                   \
        #key, per_process::metadata.versions.key);                             \
  } while (0);
  NODE_VERSIONS_KEYS(V)
#undef V

  std::sort(&versions_array[0],
            &versions_array[arraysize(versions_array)],
            [](auto& a, auto& b) { return a.first < b.first; });

  for (const auto& version : versions_array) {
    writer->json_keyvalue(version.first, version.second);
  }

  writer->json_objectend();
}",56,,796,2,,void
224897,BLOCK,-1,,"{
    writer->json_keyvalue(version.first, version.second);
  }",46,,819,3,,void
224916,BLOCK,-1,,"{
  writer->json_objectstart(""release"");
  writer->json_keyvalue(""name"", per_process::metadata.release.name);
#if NODE_VERSION_IS_LTS
  writer->json_keyvalue(""lts"", per_process::metadata.release.lts);
#endif

#ifdef NODE_HAS_RELEASE_URLS
  writer->json_keyvalue(""headersUrl"",
                        per_process::metadata.release.headers_url);
  writer->json_keyvalue(""sourceUrl"", per_process::metadata.release.source_url);
#ifdef _WIN32
  writer->json_keyvalue(""libUrl"", per_process::metadata.release.lib_url);
#endif  // _WIN32
#endif  // NODE_HAS_RELEASE_URLS

  writer->json_objectend();
}",46,,827,2,,void
224947,BLOCK,-1,,"{
  std::string filename;

  // Determine the required report filename. In order of priority:
  //   1) supplied on API 2) configured on startup 3) default generated
  if (!name.empty()) {
    // Filename was specified as API parameter.
    filename = name;
  } else {
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
  }

  // Open the report file stream for writing. Supports stdout/err,
  // user-specified or (default) generated name
  std::ofstream outfile;
  std::ostream* outstream;
  if (filename == ""stdout"") {
    outstream = &std::cout;
  } else if (filename == ""stderr"") {
    outstream = &std::cerr;
  } els...",51,,853,7,,void
224955,BLOCK,-1,,"{
    // Filename was specified as API parameter.
    filename = name;
  }",22,,858,2,,void
224960,BLOCK,-1,,"{
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
  }",10,,861,1,,void
224962,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }",5,,863,2,,void
224982,BLOCK,-1,,"{
      // File name was supplied via start-up option.
      filename = report_filename;
    }",39,,867,2,,void
224987,BLOCK,-1,,"{
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }",12,,870,1,,void
225009,BLOCK,-1,,"{
    outstream = &std::cout;
  }",29,,880,2,,void
225017,BLOCK,-1,,<empty>,10,,882,1,,void
225022,BLOCK,-1,,"{
    outstream = &std::cerr;
  }",36,,882,2,,void
225030,BLOCK,-1,,"{
    std::string report_directory;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }
    // Regular file. Append filename to directory path if one was specified
    if (report_directory.length() > 0) {
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    } else {
      outfile.open(filename, std::ios::out | std::ios::binary);
    }
    // Check for errors on the file open
    if (!outfile.is_open()) {
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }
    outstream = &outfile;
    std::cerr << ""\nWriting Node.js report to file: "" << filename;
  }",10,,884,1,,void
225032,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }",5,,886,2,,void
225052,BLOCK,-1,,"{
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    }",40,,891,2,,void
225080,BLOCK,-1,,"{
      outfile.open(filename, std::ios::out | std::ios::binary);
    }",12,,896,1,,void
225103,BLOCK,-1,,"{
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }",29,,900,2,,void
225118,BLOCK,-1,,<empty>,9,,904,2,,void
225153,BLOCK,7,,"{
    Mutex::ScopedLock lock(per_process::cli_options_mutex);
    compact = per_process::cli_options->report_compact;
  }",3,,914,7,,void
225184,BLOCK,-1,,"{
    outfile.close();
  }",26,,923,2,,void
225193,BLOCK,-1,,"{
    std::cerr << ""\nNode.js report completed"" << std::endl;
  }",29,,928,2,,void
225213,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  return TriggerNodeReport(isolate, env, message, trigger, name, error);
}",51,,939,6,,void
225222,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,941,2,,void
225246,BLOCK,-1,,"{
  return TriggerNodeReport(env != nullptr ? env->isolate() : nullptr,
                           env,
                           message,
                           trigger,
                           name,
                           error);
}",51,,952,6,,void
225271,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,966,6,,void
225280,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,968,2,,void
225308,BLOCK,-1,,"{
  Isolate* isolate = nullptr;
  if (env != nullptr) {
    isolate = env->isolate();
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,980,6,,void
225317,BLOCK,-1,,"{
    isolate = env->isolate();
  }",23,,982,2,,void
225358,BLOCK,-1,,<empty>,1,,1,1,,ANY
225391,BLOCK,-1,,<empty>,1,,1,1,,ANY
225396,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  std::string filename;
  Local<Value> error;

  CHECK_EQ(info.Length(), 4);
  String::Utf8Value message(isolate, info[0].As<String>());
  String::Utf8Value trigger(isolate, info[1].As<String>());

  if (info[2]->IsString())
    filename = *String::Utf8Value(isolate, info[2]);
  if (!info[3].IsEmpty())
    error = info[3];
  else
    error = Local<Value>();

  filename = TriggerNodeReport(env, *message, *trigger, filename, error);
  // Return value is the report filename
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, filename.c_str()).ToLocalChecked());
}",59,,29,2,,void
225452,BLOCK,-1,,<empty>,5,,41,2,,void
225472,BLOCK,-1,,<empty>,5,,43,2,,void
225479,BLOCK,-1,,<empty>,5,,45,1,,void
225516,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Object> error;
  std::ostringstream out;

  CHECK_EQ(info.Length(), 1);
  if (!info[0].IsEmpty() && info[0]->IsObject())
    error = info[0].As<Object>();
  else
    error = Local<Object>();

  GetNodeReport(env, ""JavaScript API"", __func__, error, out);

  // Return value is the contents of a report as a string.
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, out.str().c_str()).ToLocalChecked());
}",57,,54,2,,void
225562,BLOCK,-1,,<empty>,5,,63,2,,void
225572,BLOCK,-1,,<empty>,5,,65,1,,void
225608,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_compact);
}",65,,74,2,,void
225630,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  bool compact = info[0]->ToBoolean(isolate)->Value();
  per_process::cli_options->report_compact = compact;
}",65,,79,2,,void
225675,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string directory = per_process::cli_options->report_directory;
  auto result = String::NewFromUtf8(env->isolate(), directory.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",67,,87,2,,void
225727,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value dir(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_directory = *dir;
}",67,,95,2,,void
225772,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string filename = per_process::cli_options->report_filename;
  auto result = String::NewFromUtf8(env->isolate(), filename.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",66,,103,2,,void
225824,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value name(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_filename = *name;
}",66,,111,2,,void
225869,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  std::string signal = env->isolate_data()->options()->report_signal;
  auto result = String::NewFromUtf8(env->isolate(), signal.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",64,,119,2,,void
225920,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value signal(env->isolate(), info[0].As<String>());
  env->isolate_data()->options()->report_signal = *signal;
}",64,,126,2,,void
225964,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_on_fatalerror);
}",79,,133,2,,void
225986,BLOCK,-1,,"{
  CHECK(info[0]->IsBoolean());
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  per_process::cli_options->report_on_fatalerror = info[0]->IsTrue();
}",76,,138,2,,void
226015,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(env->isolate_data()->options()->report_on_signal);
}",75,,144,2,,void
226044,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_on_signal = info[0]->IsTrue();
}",72,,149,2,,void
226080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->isolate_data()->options()->report_uncaught_exception);
}",46,,156,2,,void
226109,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_uncaught_exception = info[0]->IsTrue();
}",46,,163,2,,void
226148,BLOCK,-1,,"{
  SetMethod(context, exports, ""writeReport"", WriteReport);
  SetMethod(context, exports, ""getReport"", GetReport);
  SetMethod(context, exports, ""getCompact"", GetCompact);
  SetMethod(context, exports, ""setCompact"", SetCompact);
  SetMethod(context, exports, ""getDirectory"", GetDirectory);
  SetMethod(context, exports, ""setDirectory"", SetDirectory);
  SetMethod(context, exports, ""getFilename"", GetFilename);
  SetMethod(context, exports, ""setFilename"", SetFilename);
  SetMethod(context, exports, ""getSignal"", GetSignal);
  SetMethod(context, exports, ""setSignal"", SetSignal);
  SetMethod(
      context, exports, ""shouldReportOnFatalError"", ShouldReportOnFatalError);
  SetMethod(context, exports, ""setReportOnFatalError"", SetReportOnFatalError);
  SetMethod(context, exports, ""shouldReportOnSignal"", ShouldReportOnSignal);
  SetMethod(context, exports, ""setReportOnSignal"", SetReportOnSignal);
  SetMethod(context,
            exports,
            ""shouldReportOnUncaughtException"",
         ...",36,,172,5,,void
226233,BLOCK,-1,,"{
  registry->Register(WriteReport);
  registry->Register(GetReport);
  registry->Register(GetCompact);
  registry->Register(SetCompact);
  registry->Register(GetDirectory);
  registry->Register(SetDirectory);
  registry->Register(GetFilename);
  registry->Register(SetFilename);
  registry->Register(GetSignal);
  registry->Register(SetSignal);
  registry->Register(ShouldReportOnFatalError);
  registry->Register(SetReportOnFatalError);
  registry->Register(ShouldReportOnSignal);
  registry->Register(SetReportOnSignal);
  registry->Register(ShouldReportOnUncaughtException);
  registry->Register(SetReportOnUncaughtException);
}",70,,198,2,,void
226329,BLOCK,-1,,<empty>,1,,1,1,,ANY
226342,BLOCK,-1,,"{
  if (addr == nullptr) {
    writer->json_keyvalue(name, null);
    return;
  }

  uv_getnameinfo_t endpoint;
  char* host = nullptr;
  char hostbuf[INET6_ADDRSTRLEN];
  const int family = addr->sa_family;
  const int port = ntohs(family == AF_INET ?
                         reinterpret_cast<sockaddr_in*>(addr)->sin_port :
                         reinterpret_cast<sockaddr_in6*>(addr)->sin6_port);

  if (uv_getnameinfo(h->loop, &endpoint, nullptr, addr, NI_NUMERICSERV) == 0) {
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  } else {
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }
  writer->json_objectstart(name);
  if (host ...",48,,15,5,,void
226347,BLOCK,-1,,"{
    writer->json_keyvalue(name, null);
    return;
  }",24,,16,2,,void
226397,BLOCK,-1,,"{
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  }",79,,29,2,,void
226413,BLOCK,-1,,"{
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }",10,,32,1,,void
226446,BLOCK,-1,,"{
      host = hostbuf;
    }",67,,38,2,,void
226459,BLOCK,-1,,"{
    writer->json_keyvalue(""host"", host);
  }",24,,43,2,,void
226481,BLOCK,-1,,"{
  struct sockaddr_storage addr_storage;
  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  int addr_size = sizeof(addr_storage);
  int rc = -1;

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr,  ""localEndpoint"", writer);

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr, ""remoteEndpoint"", writer);
}",65,,51,3,,void
226510,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,58,2,,void
226553,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,70,2,,void
226597,BLOCK,-1,,"{
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  MaybeStackBuffer<char> buffer;
  size_t buffer_size = buffer.capacity();
  int rc = -1;

  // First call to get required buffer size.
  rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""localEndpoint"", null);
  }

  // First call to get required buffer size.
  buffer_size = buffer.capacity();
  rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buf...",69,,84,3,,void
226634,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,92,2,,void
226661,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  }",36,,96,2,,void
226677,BLOCK,-1,,"{
    writer->json_keyvalue(""localEndpoint"", null);
  }",10,,99,1,,void
226707,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,106,2,,void
226734,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""remoteEndpoint"", buffer.ToStringView());
  }",36,,110,2,,void
226750,BLOCK,-1,,"{
    writer->json_keyvalue(""remoteEndpoint"", null);
  }",10,,113,1,,void
226762,BLOCK,-1,,"{
  MaybeStackBuffer<char> buffer;
  int rc = -1;
  size_t size = buffer.capacity();
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  // First call to get required buffer size.
  switch (h->type) {
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }

  if (rc == 0 && size > 0) {
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""filename"", null);
  }
}",60,,119,3,,void
226786,BLOCK,-1,,"{
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }",20,,125,2,,void
226825,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }",25,,135,2,,void
226835,BLOCK,-1,,"{
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }",22,,137,2,,void
226878,BLOCK,-1,,"{
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  }",28,,149,2,,void
226894,BLOCK,-1,,"{
    writer->json_keyvalue(""filename"", null);
  }",10,,152,1,,void
226906,BLOCK,-1,,"{
  const char* type = uv_handle_type_name(h->type);
  JSONWriter* writer = static_cast<JSONWriter*>(arg);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);

  writer->json_start();
  writer->json_keyvalue(""type"", type);
  writer->json_keyvalue(""is_active"", static_cast<bool>(uv_is_active(h)));
  writer->json_keyvalue(""is_referenced"", static_cast<bool>(uv_has_ref(h)));
  writer->json_keyvalue(""address"",
                        ValueToHexString(reinterpret_cast<uint64_t>(h)));

  switch (h->type) {
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat""...",44,,158,3,,void
226967,BLOCK,-1,,"{
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }
    case UV_TTY: {
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }
    case UV_SIGNAL:
      // SIGWINC...",20,,170,2,,void
227005,BLOCK,23,,"{
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }",20,,185,23,,void
227054,BLOCK,26,,"{
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }",18,,194,26,,void
227073,BLOCK,-1,,"{
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }",20,,197,2,,void
227131,BLOCK,-1,,"{
    // These *must* be 0 or libuv will set the buffer sizes to the non-zero
    // values they contain.
    int send_size = 0;
    int recv_size = 0;
    uv_send_buffer_size(h, &send_size);
    uv_recv_buffer_size(h, &recv_size);
    writer->json_keyvalue(""sendBufferSize"", send_size);
    writer->json_keyvalue(""recvBufferSize"", recv_size);
  }",5,,217,2,,void
227190,BLOCK,-1,,"{
    uv_os_fd_t fd_v;
    int rc = uv_fileno(h, &fd_v);

    if (rc == 0) {
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }
  }",48,,230,2,,void
227203,BLOCK,-1,,"{
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }",18,,234,2,,void
227214,BLOCK,-1,,"{
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }",21,,236,2,,void
227262,BLOCK,-1,,"{
    writer->json_keyvalue(""writeQueueSize"", handle->stream.write_queue_size);
    writer->json_keyvalue(""readable"",
                          static_cast<bool>(uv_is_readable(&handle->stream)));
    writer->json_keyvalue(""writable"",
                          static_cast<bool>(uv_is_writable(&handle->stream)));
  }",75,,253,2,,void
227303,BLOCK,-1,,"{
    writer->json_keyvalue(
        ""writeQueueSize"",
        uv_udp_get_send_queue_size(reinterpret_cast<uv_udp_t*>(h)));
    writer->json_keyvalue(
        ""writeQueueCount"",
        uv_udp_get_send_queue_count(reinterpret_cast<uv_udp_t*>(h)));
  }",26,,260,2,,void
227334,BLOCK,-1,,<empty>,1,,1,1,,ANY
227339,BLOCK,-1,,<empty>,1,,1,1,,ANY
227342,BLOCK,-1,,"{
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }",67,,113,1,,void
227360,BLOCK,-1,,"{
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }",63,,137,1,,void
227420,BLOCK,-1,,<empty>,1,,1,1,,ANY
227427,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) |
                               static_cast<uint32_t>(y));
}",44,,39,3,,void
227443,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) &
                               static_cast<uint32_t>(y));
}",44,,44,3,,void
227459,BLOCK,-1,,"{
  return x = x | y;
}",80,,49,3,,void
227470,BLOCK,-1,,<empty>,74,,57,1,,void
227475,BLOCK,-1,,<empty>,,,,2,,<empty>
227480,BLOCK,-1,,"{
  sink.reserve(SeaResource::kHeaderSize + sea.code.size());

  Debug(""Write SEA magic %x\n"", kMagic);
  size_t written_total = WriteArithmetic<uint32_t>(kMagic);

  uint32_t flags = static_cast<uint32_t>(sea.flags);
  Debug(""Write SEA flags %x\n"", flags);
  written_total += WriteArithmetic<uint32_t>(flags);
  DCHECK_EQ(written_total, SeaResource::kHeaderSize);

  Debug(""Write SEA resource code %p, size=%zu\n"",
        sea.code.data(),
        sea.code.size());
  written_total += WriteStringView(sea.code, StringLogMode::kAddressAndContent);
  return written_total;
}",53,,66,2,,void
227559,BLOCK,-1,,<empty>,77,,88,2,,void
227563,BLOCK,-1,,<empty>,,,,1,,<empty>
227567,BLOCK,-1,,"{
  uint32_t magic = ReadArithmetic<uint32_t>();
  Debug(""Read SEA magic %x\n"", magic);

  CHECK_EQ(magic, kMagic);
  SeaFlags flags(static_cast<SeaFlags>(ReadArithmetic<uint32_t>()));
  Debug(""Read SEA flags %x\n"", static_cast<uint32_t>(flags));
  CHECK_EQ(read_total, SeaResource::kHeaderSize);

  std::string_view code = ReadStringView(StringLogMode::kAddressAndContent);
  Debug(""Read SEA resource code %p, size=%zu\n"", code.data(), code.size());
  return {flags, code};
}",37,,97,1,,void
227614,BLOCK,-1,,"{
  CHECK(IsSingleExecutable());
  static const std::string_view result = []() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }();
  per_process::Debug(DebugCategory::SEA,
                     ""Found SEA blob %p, size=%zu\n"",
                     result.data(),
                     result.size());
  return result;
}",45,,111,1,,void
227642,BLOCK,-1,,"{
  static const SeaResource sea_resource = []() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }();
  return sea_resource;
}",44,,136,1,,void
227653,BLOCK,-1,,"{
  return postject_has_resource();
}",27,,149,1,,void
227660,BLOCK,-1,,"{
  if (!IsSingleExecutable()) {
    args.GetReturnValue().Set(false);
    return;
  }

  SeaResource sea_resource = FindSingleExecutableResource();
  args.GetReturnValue().Set(!static_cast<bool>(
      sea_resource.flags & SeaFlags::kDisableExperimentalSeaWarning));
}",78,,153,2,,void
227664,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
    return;
  }",30,,154,2,,void
227700,BLOCK,-1,,"{
  // Repeats argv[0] at position 1 on argv as a replacement for the missing
  // entry point file path.
  if (IsSingleExecutable()) {
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }

  return {argc, argv};
}",64,,164,3,,void
227703,BLOCK,-1,,"{
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }",29,,167,2,,void
227759,BLOCK,-1,,<empty>,,,,1,,<empty>
227769,BLOCK,-1,,"{
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
 ...",37,,189,2,,void
227785,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }",15,,192,2,,void
227809,BLOCK,-1,,"{
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }",30,,203,2,,void
227841,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",33,,210,2,,void
227873,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",35,,219,2,,void
227896,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""disableExperimentalSEAWarning\"" field of %s is not a Boolean\n"",
            config_path);
    return std::nullopt;
  }",54,,228,2,,void
227910,BLOCK,-1,,"{
    result.flags |= SeaFlags::kDisableExperimentalSeaWarning;
  }",49,,234,2,,void
227924,BLOCK,-1,,"{
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }

  SeaResource sea{config.flags, main_script};

  SeaSerializer serializer;
  serializer.Write(sea);

  uv_buf_t buf = uv_buf_init(serializer.sink.data(), serializer.sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }

  FPrintF(stderr,
          ""Wrote single executable preparation blob to %s\n"",
          config.output_path);
  return ExitCode::kNoFailure;
}",64,,241,2,,void
227942,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }",15,,245,2,,void
228003,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }",15,,258,2,,void
228034,BLOCK,-1,,"{
  std::optional<SeaConfig> config_opt =
      ParseSingleExecutableConfig(config_path);
  if (config_opt.has_value()) {
    ExitCode code = GenerateSingleExecutableBlob(config_opt.value());
    return code;
  }

  return ExitCode::kGenericUserError;
}",68,,272,2,,void
228045,BLOCK,-1,,"{
    ExitCode code = GenerateSingleExecutableBlob(config_opt.value());
    return code;
  }",31,,275,2,,void
228067,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""isExperimentalSeaWarningNeeded"",
            IsExperimentalSeaWarningNeeded);
}",29,,286,5,,void
228077,BLOCK,-1,,"{
  registry->Register(IsExperimentalSeaWarningNeeded);
}",70,,293,2,,void
228098,BLOCK,-1,,<empty>,1,,1,1,,ANY
228115,BLOCK,-1,,<empty>,1,,1,1,,ANY
228122,BLOCK,-1,,<empty>,,,,3,,<empty>
228126,BLOCK,-1,,<empty>,,,,1,,<empty>
228131,BLOCK,-1,,<empty>,,,,2,,<empty>
228137,BLOCK,-1,,<empty>,,,,3,,<empty>
228143,BLOCK,-1,,<empty>,,,,3,,<empty>
228148,BLOCK,-1,,<empty>,,,,2,,<empty>
228153,BLOCK,-1,,<empty>,,,,2,,<empty>
228158,BLOCK,-1,,<empty>,,,,2,,<empty>
228163,BLOCK,-1,,<empty>,,,,2,,<empty>
228168,BLOCK,-1,,<empty>,,,,2,,<empty>
228173,BLOCK,-1,,<empty>,,,,2,,<empty>
228178,BLOCK,-1,,<empty>,,,,2,,<empty>
228183,BLOCK,-1,,<empty>,,,,2,,<empty>
228188,BLOCK,-1,,<empty>,,,,2,,<empty>
228193,BLOCK,-1,,<empty>,,,,2,,<empty>
228202,BLOCK,-1,,<empty>,,,,4,,<empty>
228206,BLOCK,-1,,<empty>,,,,1,,<empty>
228211,BLOCK,-1,,<empty>,,,,2,,<empty>
228216,BLOCK,-1,,<empty>,,,,2,,<empty>
228221,BLOCK,-1,,<empty>,,,,2,,<empty>
228226,BLOCK,-1,,<empty>,,,,2,,<empty>
228231,BLOCK,-1,,<empty>,,,,2,,<empty>
228236,BLOCK,-1,,<empty>,,,,2,,<empty>
228241,BLOCK,-1,,<empty>,,,,2,,<empty>
228246,BLOCK,-1,,<empty>,,,,2,,<empty>
228251,BLOCK,-1,,<empty>,,,,2,,<empty>
228256,BLOCK,-1,,<empty>,,,,2,,<empty>
228265,BLOCK,-1,,"{
  MakeWeak();
}",39,,100,3,,void
228271,BLOCK,-1,,"{
  Local<Value> args[1] = { message };
  Local<Value> get_data_clone_error =
      object()->Get(env()->context(),
                    env()->get_data_clone_error_string())
                      .ToLocalChecked();

  CHECK(get_data_clone_error->IsFunction());
  MaybeLocal<Value> error =
      get_data_clone_error.As<Function>()->Call(env()->context(),
                                                object(),
                                                arraysize(args),
                                                args);

  if (error.IsEmpty()) return;

  env()->isolate()->ThrowException(error.ToLocalChecked());
}",68,,104,2,,void
228332,BLOCK,-1,,<empty>,24,,118,2,,void
228350,BLOCK,-1,,"{
  Local<Value> args[1] = { shared_array_buffer };
  Local<Value> get_shared_array_buffer_id =
      object()->Get(env()->context(),
                    env()->get_shared_array_buffer_id_string())
                      .ToLocalChecked();

  if (!get_shared_array_buffer_id->IsFunction()) {
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }

  MaybeLocal<Value> id =
      get_shared_array_buffer_id.As<Function>()->Call(env()->context(),
                                                      object(),
                                                      arraysize(args),
                                                      args);

  if (id.IsEmpty()) return Nothing<uint32_t>();

  return id.ToLocalChecked()->Uint32Value(env()->context());
}",69,,124,3,,void
228386,BLOCK,-1,,"{
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }",50,,131,2,,void
228422,BLOCK,-1,,<empty>,21,,142,2,,void
228442,BLOCK,-1,,"{
  MaybeLocal<Value> ret;
  Local<Value> args[1] = { input };

  Local<Value> write_host_object =
      object()->Get(env()->context(),
                    env()->write_host_object_string()).ToLocalChecked();

  if (!write_host_object->IsFunction()) {
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }

  ret = write_host_object.As<Function>()->Call(env()->context(),
                                               object(),
                                               arraysize(args),
                                               args);

  if (ret.IsEmpty())
    return Nothing<bool>();

  return Just(true);
}",69,,148,3,,void
228483,BLOCK,-1,,"{
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }",41,,156,2,,void
228515,BLOCK,-1,,<empty>,5,,166,2,,void
228525,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }

  new SerializerContext(env, args.This());
}",70,,171,2,,void
228540,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }",32,,173,2,,void
228556,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  ctx->serializer_.WriteHeader();
}",78,,181,2,,void
228575,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  Maybe<bool> ret =
      ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",77,,187,2,,void
228608,BLOCK,-1,,<empty>,21,,193,2,,void
228624,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  bool value = args[0]->BooleanValue(ctx->env()->isolate());
  ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
}",46,,197,2,,void
228660,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
  // as the underlying allocator.
  std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
  auto buf = Buffer::New(ctx->env(),
                         reinterpret_cast<char*>(ret.first),
                         ret.second);

  if (!buf.IsEmpty()) {
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",80,,205,2,,void
228703,BLOCK,-1,,"{
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",23,,216,2,,void
228719,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (!args[1]->IsArrayBuffer())
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""arrayBuffer must be an ArrayBuffer"");

  Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
  ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);
  return;
}",46,,222,2,,void
228752,BLOCK,-1,,<empty>,23,,227,2,,void
228762,BLOCK,-1,,<empty>,5,,230,2,,void
228801,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteUint32(value.FromJust());
}",78,,238,2,,void
228834,BLOCK,-1,,<empty>,26,,243,2,,void
228850,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
  Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
  if (arg0.IsNothing() || arg1.IsNothing())
    return;

  uint64_t hi = arg0.FromJust();
  uint64_t lo = arg1.FromJust();
  ctx->serializer_.WriteUint64((hi << 32) | lo);
}",78,,248,2,,void
228907,BLOCK,-1,,<empty>,5,,255,2,,void
228938,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteDouble(value.FromJust());
}",78,,262,2,,void
228968,BLOCK,-1,,<empty>,26,,267,2,,void
228984,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }

  ArrayBufferViewContents<char> bytes(args[0]);
  ctx->serializer_.WriteRawBytes(bytes.data(), bytes.length());
}",80,,272,2,,void
229001,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }",38,,276,2,,void
229037,BLOCK,-1,,"{
  object()->Set(env->context(), env->buffer_string(), buffer).Check();

  MakeWeak();
}",57,,291,4,,void
229059,BLOCK,-1,,"{
  Local<Value> read_host_object =
      object()->Get(env()->context(),
                    env()->read_host_object_string()).ToLocalChecked();

  if (!read_host_object->IsFunction()) {
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }

  Isolate::AllowJavascriptExecutionScope allow_js(isolate);
  MaybeLocal<Value> ret =
      read_host_object.As<Function>()->Call(env()->context(),
                                            object(),
                                            0,
                                            nullptr);

  if (ret.IsEmpty())
    return MaybeLocal<Object>();

  Local<Value> return_value = ret.ToLocalChecked();
  if (!return_value->IsObject()) {
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }

  return return_value.As<Object>();
}",74,,297,2,,void
229087,BLOCK,-1,,"{
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }",40,,302,2,,void
229124,BLOCK,-1,,<empty>,5,,314,2,,void
229143,BLOCK,-1,,"{
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }",34,,317,2,,void
229160,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }

  new DeserializerContext(env, args.This(), args[0]);
}",72,,325,2,,void
229175,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }",32,,327,2,,void
229188,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }",38,,332,2,,void
229210,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",79,,340,2,,void
229240,BLOCK,-1,,<empty>,21,,346,2,,void
229256,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());

  if (!ret.IsEmpty()) args.GetReturnValue().Set(ret.ToLocalChecked());
}",78,,349,2,,void
229290,BLOCK,-1,,<empty>,23,,355,2,,void
229306,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (args[1]->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }

  if (args[1]->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }

  return node::THROW_ERR_INVALID_ARG_TYPE(
      ctx->env(), ""arrayBuffer must be an ArrayBuffer or SharedArrayBuffer"");
}",46,,359,2,,void
229339,BLOCK,-1,,<empty>,23,,364,2,,void
229348,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }",33,,366,2,,void
229380,BLOCK,-1,,"{
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }",39,,372,2,,void
229419,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
}",46,,383,2,,void
229445,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint32_t value;
  bool ok = ctx->deserializer_.ReadUint32(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint32() failed"");
  return args.GetReturnValue().Set(value);
}",79,,390,2,,void
229469,BLOCK,-1,,<empty>,12,,396,2,,void
229492,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint64_t value;
  bool ok = ctx->deserializer_.ReadUint64(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint64() failed"");

  uint32_t hi = static_cast<uint32_t>(value >> 32);
  uint32_t lo = static_cast<uint32_t>(value);

  Isolate* isolate = ctx->env()->isolate();

  Local<Value> ret[] = {
    Integer::NewFromUnsigned(isolate, hi),
    Integer::NewFromUnsigned(isolate, lo)
  };
  return args.GetReturnValue().Set(Array::New(isolate, ret, arraysize(ret)));
}",79,,400,2,,void
229516,BLOCK,-1,,<empty>,12,,406,2,,void
229586,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  double value;
  bool ok = ctx->deserializer_.ReadDouble(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadDouble() failed"");
  return args.GetReturnValue().Set(value);
}",79,,420,2,,void
229610,BLOCK,-1,,<empty>,12,,426,2,,void
229633,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
  if (length_arg.IsNothing()) return;
  size_t length = length_arg.FromJust();

  const void* data;
  bool ok = ctx->deserializer_.ReadRawBytes(length, &data);
  if (!ok) return ctx->env()->ThrowError(""ReadRawBytes() failed"");

  const uint8_t* position = reinterpret_cast<const uint8_t*>(data);
  CHECK_GE(position, ctx->data_);
  CHECK_LE(position + length, ctx->data_ + ctx->length_);

  const uint32_t offset = static_cast<uint32_t>(position - ctx->data_);
  CHECK_EQ(ctx->data_ + offset, position);

  args.GetReturnValue().Set(offset);
}",46,,431,2,,void
229666,BLOCK,-1,,<empty>,31,,436,2,,void
229691,BLOCK,-1,,<empty>,12,,441,2,,void
229755,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> ser =
      NewFunctionTemplate(isolate, SerializerContext::New);

  ser->InstanceTemplate()->SetInternalFieldCount(
      SerializerContext::kInternalFieldCount);

  SetProtoMethod(isolate, ser, ""writeHeader"", SerializerContext::WriteHeader);
  SetProtoMethod(isolate, ser, ""writeValue"", SerializerContext::WriteValue);
  SetProtoMethod(
      isolate, ser, ""releaseBuffer"", SerializerContext::ReleaseBuffer);
  SetProtoMethod(isolate,
                 ser,
                 ""transferArrayBuffer"",
                 SerializerContext::TransferArrayBuffer);
  SetProtoMethod(isolate, ser, ""writeUint32"", SerializerContext::WriteUint32);
  SetProtoMethod(isolate, ser, ""writeUint64"", SerializerContext::WriteUint64);
  SetProtoMethod(isolate, ser, ""writeDouble"", SerializerContext::WriteDouble);
  SetProtoMethod(
      isolate, ser, ""writeRawBytes"", SerializerContext::WriteRaw...",29,,456,5,,void
229959,BLOCK,-1,,"{
  registry->Register(SerializerContext::New);

  registry->Register(SerializerContext::WriteHeader);
  registry->Register(SerializerContext::WriteValue);
  registry->Register(SerializerContext::ReleaseBuffer);
  registry->Register(SerializerContext::TransferArrayBuffer);
  registry->Register(SerializerContext::WriteUint32);
  registry->Register(SerializerContext::WriteUint64);
  registry->Register(SerializerContext::WriteDouble);
  registry->Register(SerializerContext::WriteRawBytes);
  registry->Register(SerializerContext::SetTreatArrayBufferViewsAsHostObjects);

  registry->Register(DeserializerContext::New);
  registry->Register(DeserializerContext::ReadHeader);
  registry->Register(DeserializerContext::ReadValue);
  registry->Register(DeserializerContext::GetWireFormatVersion);
  registry->Register(DeserializerContext::TransferArrayBuffer);
  registry->Register(DeserializerContext::ReadUint32);
  registry->Register(DeserializerContext::ReadUint64);
  registry->Register(Deseria...",70,,514,2,,void
230099,BLOCK,-1,,{ delete realm; },56,,51,2,,void
230115,BLOCK,-1,,<empty>,1,,1,1,,ANY
230121,BLOCK,-1,,"{
  ShadowRealm* realm = new ShadowRealm(env);

  // We do not expect the realm bootstrapping to throw any
  // exceptions. If it does, exit the current Node.js instance.
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  if (realm->RunBootstrapping().IsEmpty()) {
    delete realm;
    return nullptr;
  }
  return realm;
}",49,,17,2,,void
230144,BLOCK,-1,,"{
    delete realm;
    return nullptr;
  }",44,,23,2,,void
230155,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(initiator_context);
  EscapableHandleScope scope(env->isolate());
  ShadowRealm* realm = ShadowRealm::New(env);
  if (realm != nullptr) {
    return scope.Escape(realm->context());
  }
  return MaybeLocal<Context>();
}",39,,32,2,,void
230182,BLOCK,-1,,"{
    return scope.Escape(realm->context());
  }",25,,36,2,,void
230198,BLOCK,-1,,"{
  ShadowRealm* realm = data.GetParameter();
  realm->context_.Reset();

  // Yield to pending weak callbacks before deleting the realm.
  // This is necessary to avoid cleaning up base objects before their scheduled
  // weak callbacks are invoked, which can lead to accessing to v8 apis during
  // the first pass of the weak callback.
  realm->env()->SetImmediate([realm](Environment* env) { delete realm; });
  // Remove the cleanup hook to avoid deleting the realm again.
  realm->env()->RemoveCleanupHook(DeleteMe, realm);
}",79,,43,2,,void
230232,BLOCK,-1,,"{
  ShadowRealm* realm = static_cast<ShadowRealm*>(data);
  // Clear the context handle to avoid invoking the weak callback again.
  // Also, the context internal slots are cleared and the context is no longer
  // reference to the realm.
  delete realm;
}",40,,57,2,,void
230245,BLOCK,-1,,"{
  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  CreateProperties();

  env->TrackShadowRealm(this);
  env->AddCleanupHook(DeleteMe, this);
}",60,,66,2,,void
230272,BLOCK,-1,,"{
  while (HasCleanupHooks()) {
    RunCleanup();
  }

  env_->UntrackShadowRealm(this);

  if (context_.IsEmpty()) {
    // This most likely happened because the weak callback cleared it.
    return;
  }

  {
    HandleScope handle_scope(isolate());
    env_->UnassignFromContext(context());
  }
}",29,,74,1,,void
230275,BLOCK,-1,,"{
    RunCleanup();
  }",29,,75,2,,void
230287,BLOCK,-1,,"{
    // This most likely happened because the weak callback cleared it.
    return;
  }",27,,81,2,,void
230289,BLOCK,4,,"{
    HandleScope handle_scope(isolate());
    env_->UnassignFromContext(context());
  }",3,,86,4,,void
230301,BLOCK,-1,,"{
  Local<Context> ctx = PersistentToLocal::Default(isolate_, context_);
  DCHECK(!ctx.IsEmpty());
  return ctx;
}",53,,92,1,,void
230327,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  // Skip ""internal/bootstrap/node"" as it installs node globals and per-isolate
  // callbacks.

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  return v8::True(isolate_);
}",57,,127,1,,void
230337,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,133,2,,void
230344,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,135,2,,void
230363,BLOCK,-1,,<empty>,1,,1,1,,ANY
230380,BLOCK,-1,,<empty>,1,,1,1,,ANY
230387,BLOCK,-1,,<empty>,1,,1,1,,ANY
230390,BLOCK,-1,,"{
  return nullptr;
}",64,,9,1,,void
230397,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    }",47,,928,1,,void
230403,BLOCK,-1,,"{
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }",39,,929,2,,void
230419,BLOCK,-1,,{ realm->PrintInfoForSnapshot(); },44,,1002,2,,void
230429,BLOCK,-1,,"{
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_ob...",49,,1203,2,,void
230436,BLOCK,-1,,"{
      return;
    }",34,,1207,2,,void
230476,BLOCK,-1,,"{
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_objects.push_back({type_name, i, index});
    }",57,,1221,2,,void
230574,BLOCK,-1,,<empty>,1,,1,1,,ANY
230580,BLOCK,-1,,"{
  output << ""<builtins::CodeCacheInfo id="" << info.id
         << "", length="" << info.data.length << "">\n"";
  return output;
}",63,,55,3,,void
230605,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << info;
  }
  output << ""}\n"";
  return output;
}",75,,62,3,,void
230612,BLOCK,-1,,"{
    output << info;
  }",32,,64,3,,void
230626,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& i : vec) {
    output << i << "","";
  }
  output << ""}"";
  return output;
}",59,,72,3,,void
230633,BLOCK,-1,,"{
    output << i << "","";
  }",29,,74,3,,void
230649,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  "" << info << "",\n"";
  }
  output << ""}"";
  return output;
}",60,,82,3,,void
230656,BLOCK,-1,,"{
    output << ""  "" << info << "",\n"";
  }",32,,84,3,,void
230674,BLOCK,-1,,"{
  output << ""{ \"""" << info.name << ""\"", "" << std::to_string(info.id) << "", ""
         << std::to_string(info.index) << "" }"";
  return output;
}",70,,91,3,,void
230711,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  \"""" << info << ""\"",\n"";
  }
  output << ""}"";
  return output;
}",63,,98,3,,void
230718,BLOCK,-1,,"{
    output << ""  \"""" << info << ""\"",\n"";
  }",32,,100,3,,void
230736,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- builtins begins --\n""
         << i.builtins << "",\n""
         << ""// -- builtins ends --\n""
         << ""// -- persistent_values begins --\n""
         << i.persistent_values << "",\n""
         << ""// -- persistent_values ends --\n""
         << ""// -- native_objects begins --\n""
         << i.native_objects << "",\n""
         << ""// -- native_objects ends --\n""
         << i.context << "",  // context\n""
         << ""}"";
  return output;
}",77,,107,3,,void
230785,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- async_hooks begins --\n""
         << i.async_hooks << "",\n""
         << ""// -- async_hooks ends --\n""
         << i.tick_info << "",  // tick_info\n""
         << i.immediate_info << "",  // immediate_info\n""
         << i.timeout_info << "",  // timeout_info\n""
         << ""// -- performance_state begins --\n""
         << i.performance_state << "",\n""
         << ""// -- performance_state ends --\n""
         << i.exit_info << "",  // exit_info\n""
         << i.stream_base_state << "",  // stream_base_state\n""
         << i.should_abort_on_uncaught_toggle
         << "",  // should_abort_on_uncaught_toggle\n""
         << ""// -- principal_realm begins --\n""
         << i.principal_realm << "",\n""
         << ""// -- principal_realm ends --\n""
         << ""}"";
  return output;
}",75,,123,3,,void
230864,BLOCK,-1,,<empty>,16,,150,2,,void
230868,BLOCK,-1,,<empty>,,,,1,,<empty>
230873,BLOCK,-1,,"{
    // Currently the snapshot blob built with an empty script is around 4MB.
    // So use that as the default sink size.
    sink.reserve(4 * 1024 * 1024);
  }",45,,163,1,,void
230887,BLOCK,-1,,<empty>,,,,2,,<empty>
230891,BLOCK,-1,,"{
  Debug(""Read<v8::StartupData>()\n"");

  int raw_size = ReadArithmetic<int>();
  Debug(""size=%d\n"", raw_size);

  CHECK_GT(raw_size, 0);  // There should be no startup data of size 0.
  // The data pointer of v8::StartupData would be deleted so it must be new'ed.
  std::unique_ptr<char> buf = std::unique_ptr<char>(new char[raw_size]);
  ReadArithmetic<char>(buf.get(), raw_size);

  return v8::StartupData{buf.release(), raw_size};
}",46,,179,1,,void
230931,BLOCK,-1,,"{
  Debug(""\nWrite<v8::StartupData>() size=%d\n"", data.raw_size);

  CHECK_GT(data.raw_size, 0);  // There should be no startup data of size 0.
  size_t written_total = WriteArithmetic<int>(data.raw_size);
  written_total +=
      WriteArithmetic<char>(data.data, static_cast<size_t>(data.raw_size));

  Debug(""Write<v8::StartupData>() wrote %d bytes\n\n"", written_total);
  return written_total;
}",63,,194,2,,void
230968,BLOCK,-1,,"{
  Debug(""Read<builtins::CodeCacheInfo>()\n"");

  std::string id = ReadString();
  auto owning_ptr =
      std::make_shared<std::vector<uint8_t>>(ReadVector<uint8_t>());
  builtins::BuiltinCodeCacheData code_cache_data{std::move(owning_ptr)};
  builtins::CodeCacheInfo result{id, code_cache_data};

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }
  return result;
}",54,,212,1,,void
231006,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }",17,,221,2,,void
231024,BLOCK,-1,,"{
  Debug(""\nWrite<builtins::CodeCacheInfo>() id = %s""
        "", length=%d\n"",
        info.id.c_str(),
        info.data.length);

  size_t written_total = WriteString(info.id);

  written_total += WriteArithmetic<size_t>(info.data.length);
  written_total += WriteArithmetic(info.data.data, info.data.length);

  Debug(""Write<builtins::CodeCacheInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,229,2,,void
231077,BLOCK,-1,,"{
  Debug(""Read<PropInfo>()\n"");

  PropInfo result;
  result.name = ReadString();
  result.id = ReadArithmetic<uint32_t>();
  result.index = ReadArithmetic<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }

  return result;
}",39,,251,1,,void
231098,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }",17,,259,2,,void
231116,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteString(data.name);
  written_total += WriteArithmetic<uint32_t>(data.id);
  written_total += WriteArithmetic<SnapshotIndex>(data.index);

  Debug(""Write<PropInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",56,,268,2,,void
231119,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }",17,,269,2,,void
231164,BLOCK,-1,,"{
  Debug(""Read<AsyncHooks::SerializeInfo>()\n"");

  AsyncHooks::SerializeInfo result;
  result.async_ids_stack = ReadArithmetic<AliasedBufferIndex>();
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  result.async_id_fields = ReadArithmetic<AliasedBufferIndex>();
  result.js_execution_async_resources = ReadArithmetic<SnapshotIndex>();
  result.native_execution_async_resources = ReadVector<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",56,,291,1,,void
231195,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,301,2,,void
231213,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total =
      WriteArithmetic<AliasedBufferIndex>(data.async_ids_stack);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.fields);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.async_id_fields);
  written_total +=
      WriteArithmetic<SnapshotIndex>(data.js_execution_async_resources);
  written_total +=
      WriteVector<SnapshotIndex>(data.native_execution_async_resources);

  Debug(""Write<AsyncHooks::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",73,,309,2,,void
231216,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,310,2,,void
231282,BLOCK,-1,,"{
  Debug(""Read<TickInfo::SerializeInfo>()\n"");

  TickInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",54,,331,1,,void
231293,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,337,2,,void
231311,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<TickInfo::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,346,2,,void
231314,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,347,2,,void
231344,BLOCK,-1,,"{
  Debug(""Read<ImmediateInfo::SerializeInfo>()\n"");

  ImmediateInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",59,,361,1,,void
231355,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,366,2,,void
231373,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<ImmediateInfo::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",76,,374,2,,void
231376,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,375,2,,void
231406,BLOCK,-1,,"{
  Debug(""Read<PerformanceState::SerializeInfo>()\n"");

  performance::PerformanceState::SerializeInfo result;
  result.root = ReadArithmetic<AliasedBufferIndex>();
  result.milestones = ReadArithmetic<AliasedBufferIndex>();
  result.observers = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",75,,392,1,,void
231427,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,399,2,,void
231445,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.root);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.milestones);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.observers);

  Debug(""Write<PerformanceState::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",63,,408,2,,void
231448,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,409,2,,void
231496,BLOCK,-1,,"{
  Debug(""Read<IsolateDataSerializeInfo>()\n"");

  IsolateDataSerializeInfo result;
  result.primitive_values = ReadVector<SnapshotIndex>();
  result.template_values = ReadVector<PropInfo>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",55,,429,1,,void
231512,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,435,2,,void
231530,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteVector<SnapshotIndex>(data.primitive_values);
  written_total += WriteVector<PropInfo>(data.template_values);

  Debug(""Write<IsolateDataSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",72,,443,2,,void
231533,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,444,2,,void
231572,BLOCK,-1,,"{
  Debug(""Read<RealmSerializeInfo>()\n"");
  RealmSerializeInfo result;
  result.builtins = ReadVector<std::string>();
  result.persistent_values = ReadVector<PropInfo>();
  result.native_objects = ReadVector<PropInfo>();
  result.context = ReadArithmetic<SnapshotIndex>();
  return result;
}",49,,457,1,,void
231603,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = WriteVector<std::string>(data.builtins);
  written_total += WriteVector<PropInfo>(data.persistent_values);
  written_total += WriteVector<PropInfo>(data.native_objects);
  written_total += WriteArithmetic<SnapshotIndex>(data.context);

  Debug(""Write<RealmSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",66,,468,2,,void
231606,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }",17,,469,2,,void
231665,BLOCK,-1,,"{
  Debug(""Read<EnvSerializeInfo>()\n"");
  EnvSerializeInfo result;
  result.async_hooks = Read<AsyncHooks::SerializeInfo>();
  result.tick_info = Read<TickInfo::SerializeInfo>();
  result.immediate_info = Read<ImmediateInfo::SerializeInfo>();
  result.timeout_info = ReadArithmetic<AliasedBufferIndex>();
  result.performance_state =
      Read<performance::PerformanceState::SerializeInfo>();
  result.exit_info = ReadArithmetic<AliasedBufferIndex>();
  result.stream_base_state = ReadArithmetic<AliasedBufferIndex>();
  result.should_abort_on_uncaught_toggle = ReadArithmetic<AliasedBufferIndex>();
  result.principal_realm = Read<RealmSerializeInfo>();
  return result;
}",47,,485,1,,void
231724,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = Write<AsyncHooks::SerializeInfo>(data.async_hooks);
  written_total += Write<TickInfo::SerializeInfo>(data.tick_info);
  written_total += Write<ImmediateInfo::SerializeInfo>(data.immediate_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.timeout_info);
  written_total += Write<performance::PerformanceState::SerializeInfo>(
      data.performance_state);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.exit_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.stream_base_state);
  written_total +=
      WriteArithmetic<AliasedBufferIndex>(data.should_abort_on_uncaught_toggle);
  written_total += Write<RealmSerializeInfo>(data.principal_realm);

  Debug(""Write<EnvSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",64,,502,2,,void
231727,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }",17,,503,2,,void
231818,BLOCK,-1,,"{
  Debug(""Read<SnapshotMetadata>()\n"");

  SnapshotMetadata result;
  result.type = static_cast<SnapshotMetadata::Type>(ReadArithmetic<uint8_t>());
  result.node_version = ReadString();
  result.node_arch = ReadString();
  result.node_platform = ReadString();
  result.v8_cache_version_tag = ReadArithmetic<uint32_t>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }
  return result;
}",47,,535,1,,void
231851,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,545,2,,void
231869,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }
  size_t written_total = 0;
  // We need the Node.js version, platform and arch to match because
  // Node.js may perform synchronizations that are platform-specific and they
  // can be changed in semver-patches.
  Debug(""Write snapshot type %d\n"", static_cast<uint8_t>(data.type));
  written_total += WriteArithmetic<uint8_t>(static_cast<uint8_t>(data.type));
  Debug(""Write Node.js version %s\n"", data.node_version.c_str());
  written_total += WriteString(data.node_version);
  Debug(""Write Node.js arch %s\n"", data.node_arch);
  written_total += WriteString(data.node_arch);
  Debug(""Write Node.js platform %s\n"", data.node_platform);
  written_total += WriteString(data.node_platform);
  Debug(""Write V8 cached data version tag %"" PRIx32 ""\n"",
        data.v8_cache_version_tag);
  written_total += WriteArithmetic<uint32_t>(data.v8_cache_version_tag);
  return written_tot...",64,,553,2,,void
231872,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,554,2,,void
231957,BLOCK,-1,,"{
  SnapshotSerializer w;
  w.Debug(""SnapshotData::ToBlob()\n"");

  size_t written_total = 0;

  // Metadata
  w.Debug(""Write magic %"" PRIx32 ""\n"", kMagic);
  written_total += w.WriteArithmetic<uint32_t>(kMagic);
  w.Debug(""Write metadata\n"");
  written_total += w.Write<SnapshotMetadata>(metadata);

  written_total += w.Write<v8::StartupData>(v8_snapshot_blob_data);
  w.Debug(""Write isolate_data_indices\n"");
  written_total += w.Write<IsolateDataSerializeInfo>(isolate_data_info);
  written_total += w.Write<EnvSerializeInfo>(env_info);
  w.Debug(""Write code_cache\n"");
  written_total += w.WriteVector<builtins::CodeCacheInfo>(code_cache);
  w.Debug(""SnapshotData::ToBlob() Wrote %d bytes\n"", written_total);
  return w.sink;
}",48,,587,1,,void
232056,BLOCK,-1,,"{
  const std::vector<char> sink = ToBlob();
  size_t num_written = fwrite(sink.data(), sink.size(), 1, out);
  CHECK_EQ(num_written, 1);
  CHECK_EQ(fflush(out), 0);
}",44,,609,2,,void
232086,BLOCK,-1,,"{
  return data != nullptr ? data->impl_ : nullptr;
}",39,,617,2,,void
232099,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(this, false)};
}",71,,621,1,,void
232112,BLOCK,-1,,"{
  return FromBlob(out, ReadFileSync(in));
}",58,,625,3,,void
232123,BLOCK,-1,,"{
  return FromBlob(out, std::string_view(in.data(), in.size()));
}",77,,629,3,,void
232144,BLOCK,-1,,"{
  SnapshotDeserializer r(in);
  r.Debug(""SnapshotData::FromBlob()\n"");

  DCHECK_EQ(out->data_ownership, SnapshotData::DataOwnership::kOwned);

  // Metadata
  uint32_t magic = r.ReadArithmetic<uint32_t>();
  r.Debug(""Read magic %"" PRIx32 ""\n"", magic);
  CHECK_EQ(magic, kMagic);
  out->metadata = r.Read<SnapshotMetadata>();
  r.Debug(""Read metadata\n"");
  if (!out->Check()) {
    return false;
  }

  out->v8_snapshot_blob_data = r.Read<v8::StartupData>();
  r.Debug(""Read isolate_data_info\n"");
  out->isolate_data_info = r.Read<IsolateDataSerializeInfo>();
  out->env_info = r.Read<EnvSerializeInfo>();
  r.Debug(""Read code_cache\n"");
  out->code_cache = r.ReadVector<builtins::CodeCacheInfo>();

  r.Debug(""SnapshotData::FromBlob() read %d bytes\n"", r.read_total);
  return true;
}",69,,633,3,,void
232192,BLOCK,-1,,"{
    return false;
  }",22,,645,2,,void
232250,BLOCK,-1,,"{
  if (metadata.node_version != per_process::metadata.versions.node) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }

  if (metadata.node_arch != per_process::metadata.arch) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }

  if (metadata.node_platform != per_process::metadata.platform) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }

  uint32_t current_cache_version = v8::Sc...",34,,660,1,,void
232263,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }",69,,661,2,,void
232286,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }",57,,670,2,,void
232309,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }",65,,679,2,,void
232347,BLOCK,-1,,"{
    // For now we only do this check for the customized snapshots - we know
    // that the flags we use in the default snapshot are limited and safe
    // enough so we can relax the constraints for it.
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with ""
            ""a different version of V8 or with different V8 configurations.\n""
            ""Expected tag %"" PRIx32 "", read %"" PRIx32 ""\n"",
            current_cache_version,
            metadata.v8_cache_version_tag);
    return false;
  }",66,,690,2,,void
232356,BLOCK,-1,,"{
  if (data_ownership == DataOwnership::kOwned &&
      v8_snapshot_blob_data.data != nullptr) {
    delete[] v8_snapshot_blob_data.data;
  }
}",31,,707,1,,void
232369,BLOCK,-1,,"{
    delete[] v8_snapshot_blob_data.data;
  }",46,,709,2,,void
232380,BLOCK,-1,,"{
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}",63,,715,4,,void
232382,BLOCK,-1,,<empty>,3,,716,1,,void
232392,BLOCK,4,,"{
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }",37,,716,4,,void
232416,BLOCK,-1,,"{
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }
  return std::string(buf) + std::string(""_cache_data"");
}",63,,721,2,,void
232434,BLOCK,-1,,<empty>,3,,725,1,,void
232444,BLOCK,4,,"{
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }",37,,725,4,,void
232481,BLOCK,-1,,"{
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}",44,,732,2,,void
232491,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  }",20,,734,2,,void
232501,BLOCK,-1,,<empty>,10,,736,1,,void
232508,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  }",34,,736,2,,void
232520,BLOCK,-1,,"{
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }",10,,738,1,,void
232540,BLOCK,-1,,"{
  *ss << ""static const uint8_t "" << GetCodeCacheDefName(info.id) << ""[] = {\n"";
  WriteVector(ss, info.data.data, info.data.length);
  *ss << ""};\n"";
}",60,,781,3,,void
232574,BLOCK,-1,,"{
  std::string def_name = GetCodeCacheDefName(id);
  *ss << ""    { \"""" << id << ""\"",\n"";
  *ss << ""      {"" << def_name << "",\n"";
  *ss << ""       "" << size << "",\n"";
  *ss << ""      }\n"";
  *ss << ""    },\n"";
}",52,,790,4,,void
232617,BLOCK,-1,,"{
  ss << R""(#include <cstddef>
#include ""env.hpp""
#include ""node_snapshot_builder.hpp""
#include ""v8.hpp""

// This file is generated by tools/snapshot. Do not edit.

namespace node {
)"";

#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
  ss << R""(static const char *v8_snapshot_blob_data = "")"";
  WriteDataAsCharString(
      &ss,
      reinterpret_cast<const uint8_t*>(data->v8_snapshot_blob_data.data),
      data->v8_snapshot_blob_data.raw_size);
  ss << R""("";)"";
#else
  ss << R""(static const char v8_snapshot_blob_data[] = {)"";
  WriteVector(&ss,
              data->v8_snapshot_blob_data.data,
              data->v8_snapshot_blob_data.raw_size);
  ss << R""(};)"";
#endif

  ss << R""(static const int v8_snapshot_blob_size = )""
     << data->v8_snapshot_blob_data.raw_size << "";"";

  for (const auto& item : data->code_cache) {
#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
    WriteStaticCodeCacheDataAsStringLiteral(&ss, item);
#else
    // Windows can't deal with too many large vector initializer...",61,,799,3,,void
232656,BLOCK,-1,,"{
#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
    WriteStaticCodeCacheDataAsStringLiteral(&ss, item);
#else
    // Windows can't deal with too many large vector initializers.
    // Store the data into static arrays first.
    WriteStaticCodeCacheDataAsArray(&ss, item);
#endif
  }",45,,828,3,,void
232687,BLOCK,-1,,"{
    WriteCodeCacheInitializer(&ss, item.id, item.data.length);
  }",45,,861,3,,void
232706,BLOCK,-1,,"{
  // Reset the AllowCodeGenerationFromStrings flag to true (default value) so
  // that it can be re-initialized with v8 flag
  // --disallow-code-generation-from-strings and recognized in
  // node::InitializeContextRuntime.
  context->AllowCodeGenerationFromStrings(true);
}",72,,878,2,,void
232715,BLOCK,-1,,"{
  static auto registry = std::make_unique<ExternalReferenceRegistry>();
  return registry->external_references();
}",75,,886,1,,void
232733,BLOCK,-1,,"{
  CHECK_NULL(params->external_references);
  CHECK_NULL(params->snapshot_blob);
  params->external_references = CollectExternalReferences().data();
  params->snapshot_blob =
      const_cast<v8::StartupData*>(&(data->v8_snapshot_blob_data));
}",78,,892,3,,void
232767,BLOCK,-1,,"{
  // The default snapshot is meant to be runtime-independent and has more
  // restrictions. We do not enable the inspector and do not run the event
  // loop when building the default snapshot to avoid inconsistencies, but
  // we do for the fully customized one, and they are expected to fixup the
  // inconsistencies using v8.startupSnapshot callbacks.
  SnapshotMetadata::Type snapshot_type =
      main_script.has_value() ? SnapshotMetadata::Type::kFullyCustomized
                              : SnapshotMetadata::Type::kDefault;

  std::vector<std::string> errors;
  auto setup = CommonEnvironmentSetup::CreateForSnapshotting(
      per_process::v8_platform.Platform(), &errors, args, exec_args);
  if (!setup) {
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }
  Isolate* isolate = setup->isolate();

  {
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto...",50,,904,5,,void
232815,BLOCK,-1,,"{
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }",15,,917,2,,void
232842,BLOCK,9,,"{
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    });

    // Run the custom main script for fully customized snapshots.
    if (snapshot_type == SnapshotMetadata::Type::kFullyCustomized) {
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, main_script.value()).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }

        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder might introduce inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGeneri...",3,,924,9,,void
232861,BLOCK,-1,,"{
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, main_script.value()).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }

        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder might introduce inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
        if (exit_code != ExitCode::kNoFailure) {
          return exit_code;
        }
    }",68,,936,2,,void
232885,BLOCK,-1,,"{
          return ExitCode::kGenericUserError;
        }",66,,942,2,,void
232907,BLOCK,-1,,"{
          return exit_code;
        }",48,,951,2,,void
232926,BLOCK,-1,,"{
  SnapshotMetadata::Type snapshot_type =
      static_cast<SnapshotMetadata::Type>(snapshot_type_u8);
  Isolate* isolate = setup->isolate();
  Environment* env = setup->env();
  SnapshotCreator* creator = setup->snapshot_creator();

  {
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung):...",68,,962,4,,void
232954,BLOCK,9,,"{
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung): investigate if this can be used by vm contexts
    // without breaking compatibility.
    Local<Context> base_context = NewContext(isolate);
    if (base_context.IsEmpty()) {
      return ExitCode::kBootstrapFailure;
    }
    ResetCont...",3,,969,9,,void
232984,BLOCK,6,,"{
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }",5,,978,6,,void
233021,BLOCK,-1,,"{
        return ExitCode::kStartupSnapshotFailure;
      }",39,,984,2,,void
233039,BLOCK,-1,,"{
      return ExitCode::kBootstrapFailure;
    }",33,,993,2,,void
233045,BLOCK,10,,"{
      Context::Scope context_scope(main_context);

      if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }

      // Serialize the native states
      out->isolate_data_info = setup->isolate_data()->Serialize(creator);
      out->env_info = env->Serialize(creator);

#ifdef NODE_USE_NODE_CODE_CACHE
      // Regenerate all the code cache.
      if (!env->builtin_loader()->CompileAllBuiltins(main_context)) {
        return ExitCode::kGenericUserError;
      }
      env->builtin_loader()->CopyCodeCache(&(out->code_cache));
      for (const auto& item : out->code_cache) {
        std::string size_str = FormatSize(item.data.length);
        per_process::Debug(DebugCategory::MKSNAPSHOT,
                           ""Generated code cache for %d: %s\n"",
                           item.id.c_str(),
                           size_str.c_str()...",5,,998,10,,void
233059,BLOCK,-1,,"{
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }",79,,1001,2,,void
233156,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",52,,1047,2,,void
233222,BLOCK,-1,,"{
    PrintLibuvHandleInformation(env->event_loop(), stderr);
  }",75,,1063,2,,void
233232,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",26,,1066,2,,void
233248,BLOCK,-1,,"{
  SnapshotData data;
  ExitCode exit_code = Generate(&data, args, exec_args, main_script);
  if (exit_code != ExitCode::kNoFailure) {
    return exit_code;
  }
  FormatBlob(out, &data);
  return exit_code;
}",50,,1076,5,,void
233265,BLOCK,-1,,"{
    return exit_code;
  }",42,,1079,2,,void
233280,BLOCK,-1,,<empty>,44,,1089,4,,void
233284,BLOCK,-1,,"{
  switch (type_) {
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }
}",53,,1091,1,,void
233287,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }",18,,1092,2,,void
233291,BLOCK,4,,{ UNREACHABLE(); },14,,1099,4,,void
233300,BLOCK,-1,,"{
  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }
  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Deserialize internal field %d of %p, size=%d\n"",
                     static_cast<int>(index),
                     (*holder),
                     static_cast<int>(payload.raw_size));

  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }

  DCHECK_EQ(index, BaseObject::kEmbedderType);

  Environment* env_ptr = static_cast<Environment*>(env);
  const InternalFieldInfoBase* info =
      reinterpret_cast<const InternalFieldInfoBase*>(payload.data);
  // TODO(joyeecheung): we can add a constant kNodeEmbedderId to the
  // beginning of every InternalFieldInfoBase to ensure that we don't
  // step on payloads that were not serialized by Node.js.
  switch (info->type) {
#define V(PropertyName, NativeTypeName)                                        \
  case...",47,,1106,5,,void
233307,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1107,2,,void
233339,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1117,2,,void
233370,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    per_process::Debug(DebugCategory::MKSNAPSHOT,                              \
                       ""Object %p is %s\n"",                                    \
                       (*holder),                                              \
                       #NativeTypeName);                                       \
    env_ptr->EnqueueDeserializeRequest(                                        \
        NativeTypeName::Deserialize,                                           \
        holder,                                                                \
        index,                                                                 \
        info->Copy<NativeTypeName::InternalFieldInfo>());                      \
    break;                                                                     \
  }
    SERIALIZABLE_OB...",23,,1130,2,,void
233374,BLOCK,4,,"{
      // This should only be reachable during development when trying to
      // deserialize a snapshot blob built by a version of Node.js that
      // has more recognizable EmbedderObjectTypes than the deserializing
      // Node.js binary.
      fprintf(stderr,
              ""Unknown embedder object type %"" PRIu8 "", possibly caused by ""
              ""mismatched Node.js versions\n"",
              static_cast<uint8_t>(info->type));
      ABORT();
    }",14,,1146,4,,void
233383,BLOCK,-1,,"{
  // We only do one serialization for the kEmbedderType slot, the result
  // contains everything necessary for deserializing the entire object,
  // including the fields whose index is bigger than kEmbedderType
  // (most importantly, BaseObject::kSlot).
  // For Node.js this design is enough for all the native binding that are
  // serializable.
  if (index != BaseObject::kEmbedderType || !BaseObject::IsBaseObject(holder)) {
    return StartupData{nullptr, 0};
  }

  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Serialize internal field, index=%d, holder=%p\n"",
                     static_cast<int>(index),
                     *holder);

  void* native_ptr =
      holder->GetAlignedPointerFromInternalField(BaseObject::kSlot);
  per_process::Debug(DebugCategory::MKSNAPSHOT, ""native = %p\n"", native_ptr);
  DCHECK(static_cast<BaseObject*>(native_ptr)->is_snapshotable());
  SnapshotableObject* obj = static_cast<SnapshotableObject*>(native_ptr);

  per_process::...",59,,1162,4,,void
233397,BLOCK,-1,,"{
    return StartupData{nullptr, 0};
  }",80,,1169,2,,void
233498,BLOCK,-1,,"{
  HandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  uint32_t i = 0;
  realm->ForEachBaseObject([&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(De...",61,,1199,4,,void
233527,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Value> process_obj = args[0];
  Local<Value> require_fn = args[1];
  Local<Value> runcjs_fn = args[2];
  CHECK(process_obj->IsObject());
  CHECK(require_fn->IsFunction());
  CHECK(runcjs_fn->IsFunction());

  const node::StartExecutionCallback& callback = env->embedder_entry_point();
  node::StartExecutionCallbackInfo info{process_obj.As<Object>(),
                                        require_fn.As<Function>(),
                                        runcjs_fn.As<Function>()};
  MaybeLocal<Value> retval = callback(info);
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",76,,1232,2,,void
233615,BLOCK,-1,,"{
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }",26,,1246,2,,void
233631,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Local<String> filename = args[0].As<String>();
  Local<String> source = args[1].As<String>();
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  ScriptOrigin origin(isolate, filename, 0, 0, true);
  // TODO(joyeecheung): do we need all of these? Maybe we would want a less
  // internal version of them.
  std::vector<Local<String>> parameters = {
      FIXED_ONE_BYTE_STRING(isolate, ""require""),
      FIXED_ONE_BYTE_STRING(isolate, ""__filename""),
      FIXED_ONE_BYTE_STRING(isolate, ""__dirname""),
  };
  ScriptCompiler::Source script_source(source, origin);
  Local<Function> fn;
  if (ScriptCompiler::CompileFunction(context,
                                      &script_source,
                                      parameters.size(),
                                      parameters.data(),
                                      0,
                                      nullptr,
                             ...",68,,1251,2,,void
233732,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",26,,1274,2,,void
233745,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_serialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_serialize_callback(args[0].As<Function>());
}",68,,1279,2,,void
233783,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_callback(args[0].As<Function>());
}",70,,1286,2,,void
233821,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_main().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_main(args[0].As<Function>());
}",74,,1293,2,,void
233862,BLOCK,-1,,"{
  return kAnonymousMainPath;
}",36,,1302,1,,void
233872,BLOCK,-1,,"{
  if (info == nullptr) {
    object
        ->Set(
            realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""isBuildingSnapshotBuffer""),
            is_building_snapshot_buffer_.GetJSArray())
        .Check();
  } else {
    is_building_snapshot_buffer_.Deserialize(realm->context());
  }
  // Reset the status according to the current state of the realm.
  bool is_building_snapshot = realm->isolate_data()->is_building_snapshot();
  DCHECK_IMPLIES(is_building_snapshot,
                 realm->isolate_data()->snapshot_data() == nullptr);
  is_building_snapshot_buffer_[0] = is_building_snapshot ? 1 : 0;
  is_building_snapshot_buffer_.MakeWeak();
}",63,,1315,4,,void
233877,BLOCK,-1,,"{
    object
        ->Set(
            realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""isBuildingSnapshotBuffer""),
            is_building_snapshot_buffer_.GetJSArray())
        .Check();
  }",24,,1316,2,,void
233900,BLOCK,-1,,"{
    is_building_snapshot_buffer_.Deserialize(realm->context());
  }",10,,1323,1,,void
233947,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->is_building_snapshot_buffer =
      is_building_snapshot_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,1335,3,,void
233974,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,1345,2,,void
233996,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,1355,5,,void
234042,BLOCK,-1,,"{
  tracker->TrackField(""is_building_snapshot_buffer"",
                      is_building_snapshot_buffer_);
}",60,,1366,2,,void
234056,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",45,,1374,5,,void
234080,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""runEmbedderEntryPoint"", RunEmbedderEntryPoint);
  SetMethod(isolate, target, ""compileSerializeMain"", CompileSerializeMain);
  SetMethod(isolate, target, ""setSerializeCallback"", SetSerializeCallback);
  SetMethod(isolate, target, ""setDeserializeCallback"", SetDeserializeCallback);
  SetMethod(isolate,
            target,
            ""setDeserializeMainFunction"",
            SetDeserializeMainFunction);
  target->Set(FIXED_ONE_BYTE_STRING(isolate, ""anonymousMainPath""),
              OneByteString(isolate, kAnonymousMainPath));
}",63,,1380,3,,void
234127,BLOCK,-1,,"{
  registry->Register(RunEmbedderEntryPoint);
  registry->Register(CompileSerializeMain);
  registry->Register(SetSerializeCallback);
  registry->Register(SetDeserializeCallback);
  registry->Register(SetDeserializeMainFunction);
}",70,,1394,2,,void
234166,BLOCK,-1,,<empty>,1,,1,1,,ANY
234185,BLOCK,-1,,<empty>,1,,1,1,,ANY
234210,BLOCK,-1,,<empty>,1,,1,1,,ANY
234216,BLOCK,-1,,"{
  SocketAddress addr;
  int len = sizeof(sockaddr_storage);
  if (fn(&handle, addr.storage(), &len) == 0)
    CHECK_EQ(static_cast<size_t>(len), addr.length());
  else
    addr.storage()->sa_family = 0;
  return addr;
}",51,,29,3,,void
234235,BLOCK,-1,,<empty>,5,,33,2,,void
234245,BLOCK,-1,,<empty>,5,,35,1,,void
234263,BLOCK,-1,,"{
  switch (family) {
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }
}",29,,44,5,,void
234266,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }",19,,45,2,,void
234297,BLOCK,-1,,"{
  return New(AF_INET, host, port, addr) || New(AF_INET6, host, port, addr);
}",26,,64,4,,void
234317,BLOCK,-1,,"{
  return ToSockAddr(family, host, port,
                    reinterpret_cast<sockaddr_storage*>(addr->storage()));
}",26,,72,5,,void
234333,BLOCK,-1,,"{
  size_t hash = 0;
  switch (addr.family()) {
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }
  return hash;
}",73,,77,2,,void
234343,BLOCK,-1,,"{
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }",26,,79,2,,void
234346,BLOCK,3,,"{
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }",19,,80,3,,void
234370,BLOCK,6,,"{
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }",20,,86,6,,void
234410,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getsockname, handle);
}",67,,100,2,,void
234419,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getsockname, handle);
}",67,,104,2,,void
234428,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getpeername, handle);
}",67,,108,2,,void
234437,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getpeername, handle);
}",67,,112,2,,void
234464,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  return memcmp(&one_in->sin_addr, &two_in->sin_addr, sizeof(uint32_t)) == 0;
}",31,,121,3,,void
234502,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  return memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16) == 0;
}",31,,131,3,,void
234539,BLOCK,-1,,"{
  const sockaddr_in* check_ipv4 =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6* check_ipv6 =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&check_ipv6->sin6_addr);

  return memcmp(ptr, mask, sizeof(mask)) == 0 &&
         memcmp(ptr + sizeof(mask),
                &check_ipv4->sin_addr,
                sizeof(uint32_t)) == 0;
}",32,,141,3,,void
234594,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  const uint32_t s_addr_one = ntohl(one_in->sin_addr.s_addr);
  const uint32_t s_addr_two = ntohl(two_in->sin_addr.s_addr);

  if (s_addr_one < s_addr_two)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (s_addr_one == s_addr_two)
    return SocketAddress::CompareResult::SAME;
  else
    return SocketAddress::CompareResult::GREATER_THAN;
}",31,,158,3,,void
234635,BLOCK,-1,,<empty>,5,,167,2,,void
234643,BLOCK,-1,,<empty>,8,,168,1,,void
234648,BLOCK,-1,,<empty>,5,,169,2,,void
234656,BLOCK,-1,,<empty>,5,,171,1,,void
234668,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  int ret = memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16);
  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",31,,176,3,,void
234704,BLOCK,-1,,<empty>,5,,183,2,,void
234712,BLOCK,-1,,<empty>,8,,184,1,,void
234717,BLOCK,-1,,<empty>,5,,185,2,,void
234735,BLOCK,-1,,"{
  const sockaddr_in* ipv4_in =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6 * ipv6_in =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ipv6_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return SocketAddress::CompareResult::NOT_COMPARABLE;

  int ret = memcmp(
      &ipv4_in->sin_addr,
      ptr + sizeof(mask),
      sizeof(uint32_t));

  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",32,,191,3,,void
234771,BLOCK,-1,,<empty>,5,,201,2,,void
234796,BLOCK,-1,,<empty>,5,,209,2,,void
234804,BLOCK,-1,,<empty>,8,,210,1,,void
234809,BLOCK,-1,,<empty>,5,,211,2,,void
234828,BLOCK,-1,,"{
  uint32_t mask = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  return (htonl(ip_in->sin_addr.s_addr) & mask) ==
         (htonl(net_in->sin_addr.s_addr) & mask);
}",17,,218,4,,void
234883,BLOCK,-1,,"{
  // Special case, if prefix == 128, then just do a
  // straight comparison.
  if (prefix == 128)
    return compare_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  if (memcmp(&ip_in->sin6_addr, &net_in->sin6_addr, len) != 0)
    return false;

  const uint8_t* p1 = reinterpret_cast<const uint8_t*>(
      ip_in->sin6_addr.s6_addr);
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (p1[len] & mask) == (p2[len] & mask);
}",17,,233,4,,void
234888,BLOCK,-1,,<empty>,5,,237,2,,void
234956,BLOCK,-1,,<empty>,5,,249,2,,void
234997,BLOCK,-1,,"{

  if (prefix == 128)
    return compare_ipv4_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  uint8_t ip_mask[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 0, 0, 0};
  uint8_t* ptr = ip_mask;
  memcpy(ptr + 12, &ip_in->sin_addr, 4);

  if (memcmp(ptr, &net_in->sin6_addr, len) != 0)
    return false;

  ptr += len;
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (ptr[0] & mask) == (p2[len] & mask);
}",17,,262,4,,void
235002,BLOCK,-1,,<empty>,5,,265,2,,void
235100,BLOCK,-1,,<empty>,5,,281,2,,void
235134,BLOCK,-1,,"{
  if (prefix == 32)
    return compare_ipv4_ipv6(net, ip) == SocketAddress::CompareResult::SAME;

  uint32_t m = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ip_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return false;

  ptr += sizeof(mask);
  uint32_t check = ReadUint32BE(ptr);

  return (check & m) == (htonl(net_in->sin_addr.s_addr) & m);
}",17,,293,4,,void
235139,BLOCK,-1,,<empty>,5,,295,2,,void
235197,BLOCK,-1,,<empty>,5,,308,2,,void
235226,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }
  return false;
}",64,,321,2,,void
235229,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }",21,,322,2,,void
235237,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }",31,,324,2,,void
235260,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }",31,,330,2,,void
235282,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }
  return SocketAddress::CompareResult::NOT_COMPARABLE;
}",39,,340,2,,void
235285,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }",21,,341,2,,void
235293,BLOCK,-1,,"{
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }",31,,343,2,,void
235316,BLOCK,-1,,"{
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }",31,,349,2,,void
235319,BLOCK,3,,"{
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }",23,,350,3,,void
235329,BLOCK,-1,,"{
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }",22,,352,2,,void
235388,BLOCK,-1,,"{

  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }

  return false;
}",23,,373,3,,void
235391,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }",21,,375,2,,void
235399,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }",31,,377,2,,void
235424,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }",31,,383,2,,void
235448,BLOCK,-1,,<empty>,23,,395,2,,void
235453,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRule>(address);
  rules_.emplace_front(std::move(rule));
  address_rules_[*address.get()] = rules_.begin();
}",52,,398,2,,void
235497,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = address_rules_.find(*address.get());
  if (it != std::end(address_rules_)) {
    rules_.erase(it->second);
    address_rules_.erase(it);
  }
}",52,,407,2,,void
235521,BLOCK,-1,,"{
    rules_.erase(it->second);
    address_rules_.erase(it);
  }",39,,410,2,,void
235539,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRangeRule>(start, end);
  rules_.emplace_front(std::move(rule));
}",48,,418,3,,void
235575,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressMaskRule>(network, prefix);
  rules_.emplace_front(std::move(rule));
}",17,,427,3,,void
235610,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  for (const auto& rule : rules_) {
    if (rule->Apply(address))
      return true;
  }
  return parent_ ? parent_->Apply(address) : false;
}",52,,435,2,,void
235617,BLOCK,-1,,"{
    if (rule->Apply(address))
      return true;
  }",35,,437,3,,void
235624,BLOCK,-1,,<empty>,7,,439,2,,void
235640,BLOCK,-1,,<empty>,25,,446,2,,void
235646,BLOCK,-1,,<empty>,17,,452,3,,void
235652,BLOCK,-1,,<empty>,23,,458,3,,void
235657,BLOCK,-1,,"{
  return this->address->is_match(*address.get());
}",52,,461,2,,void
235673,BLOCK,-1,,"{
  std::string ret = ""Address: "";
  ret += address->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += address->address();
  return ret;
}",67,,465,1,,void
235704,BLOCK,-1,,"{
  return *address.get() >= *start.get() &&
         *address.get() <= *end.get();
}",52,,474,2,,void
235732,BLOCK,-1,,"{
  std::string ret = ""Range: "";
  ret += start->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += start->address();
  ret += ""-"";
  ret += end->address();
  return ret;
}",72,,479,1,,void
235772,BLOCK,-1,,"{
  return address->is_in_network(*network.get(), prefix);
}",52,,490,2,,void
235787,BLOCK,-1,,"{
  std::string ret = ""Subnet: "";
  ret += network->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += network->address();
  ret += ""/"" + std::to_string(prefix);
  return ret;
}",71,,494,1,,void
235827,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> rules;
  if (!ListRules(env, &rules))
    return MaybeLocal<Array>();
  return Array::New(env->isolate(), rules.data(), rules.size());
}",71,,503,2,,void
235846,BLOCK,-1,,<empty>,5,,507,2,,void
235871,BLOCK,-1,,"{
  if (parent_ && !parent_->ListRules(env, rules))
    return false;
  for (const auto& rule : rules_) {
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }
  return true;
}",47,,513,3,,void
235882,BLOCK,-1,,<empty>,5,,515,2,,void
235888,BLOCK,-1,,"{
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }",35,,516,3,,void
235906,BLOCK,-1,,<empty>,7,,519,2,,void
235920,BLOCK,-1,,"{
  tracker->TrackField(""rules"", rules_);
}",77,,525,2,,void
235931,BLOCK,-1,,"{
  tracker->TrackField(""address"", address);
}",41,,530,2,,void
235942,BLOCK,-1,,"{
  tracker->TrackField(""start"", start);
  tracker->TrackField(""end"", end);
}",41,,535,2,,void
235959,BLOCK,-1,,"{
  tracker->TrackField(""network"", network);
}",41,,541,2,,void
235972,BLOCK,-1,,"{
  MakeWeak();
}",40,,550,4,,void
235978,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(env, obj);
  CHECK(wrap);
  return wrap;
}",23,,555,2,,void
236005,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,559,2,,void
236030,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(
          env,
          obj,
          std::move(blocklist));
  CHECK(wrap);
  return wrap;
}",56,,570,3,,void
236057,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,574,2,,void
236086,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new SocketAddressBlockListWrap(env, args.This());
}",46,,587,2,,void
236111,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  wrap->blocklist_->AddSocketAddress(addr->address());

  args.GetReturnValue().Set(true);
}",46,,594,2,,void
236166,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(SocketAddressBase::HasInstance(env, args[1]));

  SocketAddressBase* start_addr;
  SocketAddressBase* end_addr;
  ASSIGN_OR_RETURN_UNWRAP(&start_addr, args[0]);
  ASSIGN_OR_RETURN_UNWRAP(&end_addr, args[1]);

  // Starting address must come before the end address
  if (*start_addr->address().get() > *end_addr->address().get())
    return args.GetReturnValue().Set(false);

  wrap->blocklist_->AddSocketAddressRange(
      start_addr->address(),
      end_addr->address());

  args.GetReturnValue().Set(true);
}",46,,609,2,,void
236233,BLOCK,-1,,<empty>,5,,624,2,,void
236269,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(args[1]->IsInt32());

  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  int32_t prefix;
  if (!args[1]->Int32Value(env->context()).To(&prefix)) {
    return;
  }

  CHECK_IMPLIES(addr->address()->family() == AF_INET, prefix <= 32);
  CHECK_IMPLIES(addr->address()->family() == AF_INET6, prefix <= 128);
  CHECK_GE(prefix, 0);

  wrap->blocklist_->AddSocketAddressMask(addr->address(), prefix);

  args.GetReturnValue().Set(true);
}",46,,634,2,,void
236327,BLOCK,-1,,"{
    return;
  }",57,,646,2,,void
236381,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  args.GetReturnValue().Set(wrap->blocklist_->Apply(addr->address()));
}",46,,660,2,,void
236435,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Local<Array> rules;
  if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
    args.GetReturnValue().Set(rules);
}",46,,673,2,,void
236470,BLOCK,-1,,<empty>,5,,679,2,,void
236483,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",75,,682,2,,void
236492,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",55,,687,1,,void
236506,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",25,,693,3,,void
236518,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blocklist_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }
  return tmpl;
}",23,,698,2,,void
236534,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }",23,,700,2,,void
236606,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  SetConstructorFunction(context,
                         target,
                         ""BlockList"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SocketAddressBase::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, AF_INET);
  NODE_DEFINE_CONSTANT(target, AF_INET6);
}",17,,719,5,,void
236642,BLOCK,-1,,"{
  return New(env, std::move(blocklist_));
}",49,,737,4,,void
236655,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",35,,742,2,,void
236666,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",75,,746,3,,void
236678,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->socketaddress_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }
  return tmpl;
}",23,,751,2,,void
236694,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }",23,,753,2,,void
236754,BLOCK,-1,,"{
  SetConstructorFunction(env->context(),
                         target,
                         ""SocketAddress"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);
}",76,,767,3,,void
236772,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBase>();
  }

  return MakeBaseObject<SocketAddressBase>(env, obj, std::move(address));
}",45,,777,3,,void
236797,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBase>();
  }",56,,781,2,,void
236818,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsString());  // address
  CHECK(args[1]->IsInt32());  // port
  CHECK(args[2]->IsInt32());  // family
  CHECK(args[3]->IsUint32());  // flow label

  Utf8Value address(env->isolate(), args[0]);
  int32_t port = args[1].As<Int32>()->Value();
  int32_t family = args[2].As<Int32>()->Value();
  uint32_t flow_label = args[3].As<Uint32>()->Value();

  std::shared_ptr<SocketAddress> addr = std::make_shared<SocketAddress>();

  if (!SocketAddress::New(family, *address, port, addr.get()))
    return THROW_ERR_INVALID_ADDRESS(env);

  addr->set_flow_label(flow_label);

  new SocketAddressBase(env, args.This(), std::move(addr));
}",70,,788,2,,void
236931,BLOCK,-1,,<empty>,5,,804,2,,void
236956,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> detail = args[0].As<Object>();

  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());

  Local<Value> address;
  if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
    return;

  if (detail->Set(env->context(), env->address_string(), address).IsJust() &&
      detail->Set(
          env->context(),
          env->port_string(),
          Int32::New(env->isolate(), base->address_->port())).IsJust() &&
      detail->Set(
          env->context(),
          env->family_string(),
          Int32::New(env->isolate(), base->address_->family())).IsJust() &&
      detail->Set(
          env->context(),
          env->flowlabel_string(),
          Uint32::New(env->isolate(), base->address_->flow_label()))
              .IsJust()) {
    args.GetReturnValue().Set(detail);
  }
}",73,,811,2,,void
237015,BLOCK,-1,,<empty>,5,,821,2,,void
237124,BLOCK,-1,,"{
    args.GetReturnValue().Set(detail);
  }",26,,836,2,,void
237137,BLOCK,-1,,"{
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  args.GetReturnValue().Set(base->address_->flow_label());
}",79,,841,2,,void
237163,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  Local<Object> address;
  if (!base->address_->ToJS(env).ToLocal(&address)) return;
  args.GetReturnValue().Set(address);
}",79,,847,2,,void
237199,BLOCK,-1,,<empty>,53,,852,2,,void
237215,BLOCK,-1,,"{
  MakeWeak();
}",36,,861,4,,void
237221,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",66,,865,2,,void
237231,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",46,,870,1,,void
237244,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",80,,874,2,,void
237257,BLOCK,-1,,"{
  return SocketAddressBase::Create(env, std::move(address_));
}",49,,881,4,,void
237298,BLOCK,-1,,<empty>,1,,1,1,,ANY
237323,BLOCK,-1,,<empty>,1,,1,1,,ANY
237328,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, StatWatcher::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      StatWatcher::kInternalFieldCount);
  t->Inherit(HandleWrap::GetConstructorTemplate(isolate_data));
  SetProtoMethod(isolate, t, ""start"", StatWatcher::Start);

  SetConstructorFunction(isolate, target, ""StatWatcher"", t);
}",76,,49,3,,void
237382,BLOCK,-1,,"{
  registry->Register(StatWatcher::New);
  registry->Register(StatWatcher::Start);
}",42,,62,2,,void
237403,BLOCK,-1,,"{
  CHECK_EQ(0, uv_fs_poll_init(env()->event_loop(), &watcher_));
}",35,,75,4,,void
237420,BLOCK,-1,,"{
  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);
  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> arr = fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, curr);
  USE(fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, prev, true));

  Local<Value> argv[2] = { Integer::New(env->isolate(), status), arr };
  wrap->MakeCallback(env->onchange_string(), arraysize(argv), argv);
}",51,,83,5,,void
237508,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  fs::BindingData* binding_data = Realm::GetBindingData<fs::BindingData>(args);
  new StatWatcher(binding_data, args.This(), args[0]->IsTrue());
}",64,,99,2,,void
237543,BLOCK,-1,,"{
  CHECK_EQ(args.Length(), 2);

  StatWatcher* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(!uv_is_active(wrap->GetHandle()));

  node::Utf8Value path(args.GetIsolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      wrap->env(),
      permission::PermissionScope::kFileSystemRead,
      path.ToStringView());

  CHECK(args[1]->IsUint32());
  const uint32_t interval = args[1].As<Uint32>()->Value();

  // Note that uv_fs_poll_start does not return ENOENT, we are handling
  // mostly memory errors here.
  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);
  if (err != 0) {
    args.GetReturnValue().Set(err);
  }
}",66,,106,2,,void
237626,BLOCK,-1,,"{
    args.GetReturnValue().Set(err);
  }",17,,126,2,,void
237649,BLOCK,-1,,<empty>,1,,1,1,,ANY
237660,BLOCK,-1,,<empty>,1,,1,1,,ANY
237668,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
#define V(PropertyName, StringValue)                                           \
  target                                                                       \
      ->Set(env->context(),                                                    \
            env->PropertyName()->Description(env->isolate()),                  \
            env->PropertyName())                                               \
      .Check();
  PER_ISOLATE_SYMBOL_PROPERTIES(V)
#undef V
}",36,,17,5,,void
237706,BLOCK,-1,,<empty>,1,,1,1,,ANY
237712,BLOCK,-1,,"{
  Local<Value> maybe_async_id;
  if (!promise->Get(env->context(), id_symbol).ToLocal(&maybe_async_id)) {
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
  return maybe_async_id->IsNumber()
      ? maybe_async_id->NumberValue(env->context())
      : v8::Just(AsyncWrap::kInvalidAsyncId);
}",72,,36,4,,void
237734,BLOCK,-1,,"{
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",74,,38,2,,void
237770,BLOCK,-1,,"{
  // This check is imperfect. If the internal field is set, it should
  // be an object. If it's not, we just ignore it. Ideally v8 would
  // have had GetInternalField returning a MaybeLocal but this works
  // for now.
  Local<Value> promiseWrap = promise->GetInternalField(0);
  if (promiseWrap->IsObject()) {
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  } else {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
}",76,,48,4,,void
237787,BLOCK,-1,,"{
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  }",32,,54,2,,void
237812,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }",36,,57,2,,void
237843,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",10,,63,1,,void
237856,BLOCK,-1,,"{
  static std::atomic<uint64_t> unhandledRejections{0};
  static std::atomic<uint64_t> rejectionsHandledAfter{0};

  Local<Promise> promise = message.GetPromise();
  Isolate* isolate = promise->GetIsolate();
  PromiseRejectEvent event = message.GetEvent();

  Environment* env = Environment::GetCurrent(isolate);

  if (env == nullptr || !env->can_call_into_js()) return;

  Local<Function> callback = env->promise_reject_callback();
  // The promise is rejected before JS land calls SetPromiseRejectCallback
  // to initializes the promise reject callback during bootstrap.
  CHECK(!callback.IsEmpty());

  Local<Value> value;
  Local<Value> type = Number::New(env->isolate(), event);

  if (event == kPromiseRejectWithNoHandler) {
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfte...",58,,68,2,,void
237909,BLOCK,-1,,<empty>,51,,78,2,,void
237951,BLOCK,-1,,"{
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",45,,88,2,,void
237970,BLOCK,-1,,<empty>,10,,95,1,,void
237975,BLOCK,-1,,"{
    value = Undefined(isolate);
    rejectionsHandledAfter++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",56,,95,2,,void
237992,BLOCK,-1,,<empty>,10,,102,1,,void
237997,BLOCK,-1,,"{
    value = message.GetValue();
  }",53,,102,2,,void
238005,BLOCK,-1,,<empty>,10,,104,1,,void
238010,BLOCK,-1,,"{
    value = message.GetValue();
  }",52,,104,2,,void
238018,BLOCK,-1,,"{
    return;
  }",10,,106,1,,void
238025,BLOCK,-1,,"{
    value = Undefined(isolate);
  }",24,,110,2,,void
238066,BLOCK,-1,,<empty>,27,,121,2,,void
238082,BLOCK,-1,,<empty>,35,,123,2,,void
238096,BLOCK,-1,,"{
    // That means that promise might be a PromiseWrap, so we'll
    // check there as well.
    if (!GetAssignedPromiseWrapAsyncId(env, promise, env->async_id_symbol())
              .To(&async_id)) return;
    if (!GetAssignedPromiseWrapAsyncId(
          env, promise, env->trigger_async_id_symbol())
              .To(&trigger_async_id)) return;
  }",55,,126,2,,void
238111,BLOCK,-1,,<empty>,31,,130,2,,void
238127,BLOCK,-1,,<empty>,39,,133,2,,void
238141,BLOCK,-1,,"{
    env->async_hooks()->push_async_context(
        async_id, trigger_async_id, promise);
  }",55,,137,2,,void
238185,BLOCK,-1,,"{
    // This condition might not be true if async_hooks was enabled during
    // the promise callback execution.
    env->async_hooks()->pop_async_context(async_id);
  }",46,,147,2,,void
238205,BLOCK,-1,,"{
    fprintf(stderr, ""Exception in PromiseRejectCallback:\n"");
    PrintCaughtException(isolate, env->context(), try_catch);
  }",60,,156,2,,void
238221,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsFunction());

  isolate->GetCurrentContext()->GetMicrotaskQueue()
      ->EnqueueMicrotask(isolate, args[0].As<Function>());
}",71,,163,2,,void
238265,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());
}",68,,173,2,,void
238292,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_tick_callback_function(args[0].As<Function>());
}",70,,178,2,,void
238322,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  env->set_promise_reject_callback(args[0].As<Function>());
}",46,,185,2,,void
238355,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""enqueueMicrotask"", EnqueueMicrotask);
  SetMethod(context, target, ""setTickCallback"", SetTickCallback);
  SetMethod(context, target, ""runMicrotasks"", RunMicrotasks);
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""tickInfo""),
              env->tick_info()->fields().GetJSArray()).Check();

  Local<Object> events = Object::New(isolate);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler);
  NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject);
  NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved);

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""promiseRejectEvents""),
              events).Check();
  SetMethod(
      context, target, ""setPromiseRejectCallback"", SetPromiseRejectCallback);
}",36,,195,5,,void
238426,BLOCK,1,,<empty>,,,,7,,void
238428,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler)",3,,207,1,,void
238525,BLOCK,1,,<empty>,,,,7,,void
238527,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject)",3,,208,1,,void
238624,BLOCK,1,,<empty>,,,,7,,void
238626,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved)",3,,209,1,,void
238723,BLOCK,1,,<empty>,,,,7,,void
238725,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved)",3,,210,1,,void
238841,BLOCK,-1,,"{
  registry->Register(EnqueueMicrotask);
  registry->Register(SetTickCallback);
  registry->Register(RunMicrotasks);
  registry->Register(SetPromiseRejectCallback);
}",70,,219,2,,void
238869,BLOCK,-1,,<empty>,1,,1,1,,ANY
238882,BLOCK,-1,,<empty>,1,,1,1,,ANY
238909,BLOCK,-1,,<empty>,1,,1,1,,ANY
238918,BLOCK,-1,,<empty>,,,,5,,<empty>
238923,BLOCK,-1,,<empty>,,,,2,,<empty>
238928,BLOCK,-1,,<empty>,,,,2,,<empty>
238933,BLOCK,-1,,<empty>,,,,2,,<empty>
238938,BLOCK,-1,,<empty>,,,,2,,<empty>
238942,BLOCK,-1,,{ return categories_; },54,,41,1,,void
238949,BLOCK,-1,,"{
    tracker->TrackField(""categories"", categories_);
  }",58,,43,2,,void
238966,BLOCK,-1,,"{
    MakeWeak();
  }",67,,54,4,,void
238973,BLOCK,-1,,<empty>,,,,1,,<empty>
238981,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::set<std::string> categories;
  CHECK(args[0]->IsArray());
  Local<Array> cats = args[0].As<Array>();
  for (size_t n = 0; n < cats->Length(); n++) {
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }
  CHECK_NOT_NULL(GetTracingAgentWriter());
  new NodeCategorySet(env, args.This(), std::move(categories));
}",68,,62,2,,void
239019,BLOCK,-1,,<empty>,3,,67,1,,void
239032,BLOCK,4,,"{
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }",47,,67,4,,void
239054,BLOCK,-1,,<empty>,59,,69,2,,void
239067,BLOCK,-1,,<empty>,16,,71,2,,void
239092,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (!category_set->enabled_ && !categories.empty()) {
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }
}",71,,78,2,,void
239121,BLOCK,-1,,"{
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }",55,,83,2,,void
239137,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (category_set->enabled_ && !categories.empty()) {
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }
}",72,,92,2,,void
239165,BLOCK,-1,,"{
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }",54,,97,2,,void
239180,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string categories =
      GetTracingAgentWriter()->agent()->GetEnabledCategories();
  if (!categories.empty()) {
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }
}",68,,103,2,,void
239205,BLOCK,-1,,"{
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }",28,,107,2,,void
239239,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_trace_category_state_function(args[0].As<Function>());
}",46,,117,2,,void
239272,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getEnabledCategories"", GetEnabledCategories);
  SetMethod(context,
            target,
            ""setTraceCategoryStateUpdateHandler"",
            SetTraceCategoryStateUpdateHandler);

  Local<FunctionTemplate> category_set =
      NewFunctionTemplate(isolate, NodeCategorySet::New);
  category_set->InstanceTemplate()->SetInternalFieldCount(
      NodeCategorySet::kInternalFieldCount);
  SetProtoMethod(isolate, category_set, ""enable"", NodeCategorySet::Enable);
  SetProtoMethod(isolate, category_set, ""disable"", NodeCategorySet::Disable);

  SetConstructorFunction(context, target, ""CategorySet"", category_set);

  Local<String> isTraceCategoryEnabled =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""isTraceCategoryEnabled"");
  Local<String> trace = FIXED_ONE_BYTE_STRING(env->isolate(), ""trace"");

  // Grab the trace and isTraceCategoryEnabled intrinsics from the bi...",29,,126,5,,void
239412,BLOCK,-1,,"{
  registry->Register(GetEnabledCategories);
  registry->Register(SetTraceCategoryStateUpdateHandler);
  registry->Register(NodeCategorySet::New);
  registry->Register(NodeCategorySet::Enable);
  registry->Register(NodeCategorySet::Disable);
}",42,,160,2,,void
239457,BLOCK,-1,,<empty>,1,,1,1,,ANY
239462,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239480,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239498,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239516,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239534,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239552,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239570,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239588,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239606,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239624,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239642,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239660,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239678,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239696,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239714,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239732,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239750,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239768,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239786,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239804,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239822,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239840,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239858,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239876,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239894,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
239912,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
}",71,,50,2,,void
239937,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsNumberObject() ||
    args[0]->IsStringObject() ||
    args[0]->IsBooleanObject() ||
    args[0]->IsBigIntObject() ||
    args[0]->IsSymbolObject());
}",71,,55,2,,void
239986,BLOCK,-1,,"{
#define V(type) SetMethodNoSideEffect(context, target, ""is"" #type, Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  SetMethodNoSideEffect(context, target, ""isAnyArrayBuffer"", IsAnyArrayBuffer);
  SetMethodNoSideEffect(context, target, ""isBoxedPrimitive"", IsBoxedPrimitive);
}",34,,67,5,,void
239988,BLOCK,1,,<empty>,,,,1,,void
239995,BLOCK,1,,<empty>,,,,1,,void
240130,BLOCK,-1,,"{
#define V(type) registry->Register(Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  registry->Register(IsAnyArrayBuffer);
  registry->Register(IsBoxedPrimitive);
}",75,,78,2,,void
240132,BLOCK,1,,<empty>,,,,1,,void
240277,BLOCK,-1,,<empty>,1,,1,1,,ANY
240306,BLOCK,-1,,<empty>,1,,1,1,,ANY
240311,BLOCK,-1,,"{
  tracker->TrackField(""url_components_buffer"", url_components_buffer_);
}",60,,31,2,,void
240323,BLOCK,-1,,"{
  object
      ->Set(realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""urlComponents""),
            url_components_buffer_.GetJSArray())
      .Check();
  url_components_buffer_.MakeWeak();
}",70,,37,3,,void
240354,BLOCK,-1,,"{
  // We'll just re-initialize the buffers in the constructor since their
  // contents can be thrown away once consumed in the previous call.
  url_components_buffer_.Release();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,47,3,,void
240365,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,56,2,,void
240390,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,66,5,,void
240429,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  if (input.empty()) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }

  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }
  std::string host = out->get_hostname();
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), host.c_str()).ToLocalChecked());
}",74,,74,2,,void
240470,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",22,,80,2,,void
240506,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",34,,89,2,,void
240554,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }
  std::string result = ada::unicode::to_unicode(out->get_hostname());

  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                result.c_str(),
                                                NewStringType::kNormal,
                                                result.length())
                                .ToLocalChecked());
}",76,,97,2,,void
240611,BLOCK,-1,,"{
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }",34,,108,2,,void
240678,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input_view);

  if (!out) {
    THROW_ERR_INVALID_URL(env, ""Invalid URL"");
    return;
  }

  std::string origin = out->get_origin();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                origin.data(),
                                                NewStringType::kNormal,
                                                origin.length())
                                .ToLocalChecked());
}",74,,121,2,,void
240737,BLOCK,-1,,"{
    THROW_ERR_INVALID_URL(env, ""Invalid URL"");
    return;
  }",13,,132,2,,void
240782,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();

  bool can_parse{};
  if (args[1]->IsString()) {
    Utf8Value base(env->isolate(), args[1]);
    std::string_view base_view = base.ToStringView();
    can_parse = ada::can_parse(input_view, &base_view);
  } else {
    can_parse = ada::can_parse(input_view);
  }

  args.GetReturnValue().Set(can_parse);
}",69,,145,2,,void
240837,BLOCK,-1,,"{
    Utf8Value base(env->isolate(), args[1]);
    std::string_view base_view = base.ToStringView();
    can_parse = ada::can_parse(input_view, &base_view);
  }",28,,157,2,,void
240864,BLOCK,-1,,"{
    can_parse = ada::can_parse(input_view);
  }",10,,161,1,,void
240885,BLOCK,-1,,"{
  return ada::can_parse(std::string_view(input.data, input.length));
}",64,,169,3,,void
240905,BLOCK,-1,,<empty>,,,,2,,<empty>
240910,BLOCK,-1,,"{
  CHECK_GT(args.Length(), 4);
  CHECK(args[0]->IsString());  // url href

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Utf8Value href(isolate, args[0].As<String>());
  const bool hash = args[1]->IsTrue();
  const bool unicode = args[2]->IsTrue();
  const bool search = args[3]->IsTrue();
  const bool auth = args[4]->IsTrue();

  // ada::url provides a faster alternative to ada::url_aggregator if we
  // directly want to manipulate the url components without using the respective
  // setters. therefore we are using ada::url here.
  auto out = ada::parse<ada::url>(href.ToStringView());
  CHECK(out);

  if (!hash) {
    out->hash = std::nullopt;
  }

  if (unicode) {
    out->host = ada::idna::to_unicode(out->get_hostname());
  }

  if (!search) {
    out->query = std::nullopt;
  }

  if (!auth) {
    out->username = """";
    out->password = """";
  }

  std::string result = out->get_href();
  args.GetReturnValue().Set(String::NewFromUtf8(en...",67,,175,2,,void
241004,BLOCK,-1,,"{
    out->hash = std::nullopt;
  }",14,,194,2,,void
241014,BLOCK,-1,,"{
    out->host = ada::idna::to_unicode(out->get_hostname());
  }",16,,198,2,,void
241032,BLOCK,-1,,"{
    out->query = std::nullopt;
  }",16,,202,2,,void
241043,BLOCK,-1,,"{
    out->username = """";
    out->password = """";
  }",14,,206,2,,void
241094,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  if (!out) {
    return args.GetReturnValue().Set(false);
  }

  binding_data->UpdateComponents(out->get_components(), out->type);

  args.GetReturnValue().Set(
      ToV8Value(env->context(), out->get_href(), env->isolate(...",66,,219,2,,void
241167,BLOCK,-1,,"{
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }",28,,232,2,,void
241192,BLOCK,-1,,"{
      return args.GetReturnValue().Set(false);
    }",16,,235,2,,void
241230,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",13,,243,2,,void
241278,BLOCK,-1,,"{
  CHECK(args[0]->IsString());    // href
  CHECK(args[1]->IsNumber());    // action type
  CHECK(args[2]->IsString());    // new value

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  enum url_update_action action = static_cast<enum url_update_action>(
      args[1]->Uint32Value(env->context()).FromJust());
  Utf8Value input(isolate, args[0].As<String>());
  Utf8Value new_value(isolate, args[2].As<String>());

  std::string_view new_value_view = new_value.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());
  CHECK(out);

  bool result{true};

  switch (action) {
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      re...",67,,254,2,,void
241392,BLOCK,-1,,"{
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      result = out->set_hostname(new_value_view);
      break;
    }
    case kHref: {
      result = out->set_href(new_value_view);
      break;
    }
    case kPassword: {
      result = out->set_password(new_value_view);
      break;
    }
    case kPort: {
      result = out->set_port(new_value_view);
      break;
    }
    case kProtocol: {
      result = out->set_protocol(new_value_view);
      break;
    }
    case kSearch: {
      out->set_search(new_value_view);
      break;
    }
    case kUsername: {
      result = out->set_username(new_value_view);
      break;
    }
    default:
      UNREACHABLE(""Unsupported URL update action"");
  }",19,,274,2,,void
241395,BLOCK,3,,"{
      result = out->set_pathname(new_value_view);
      break;
    }",21,,275,3,,void
241406,BLOCK,6,,"{
      out->set_hash(new_value_view);
      break;
    }",17,,279,6,,void
241415,BLOCK,9,,"{
      result = out->set_host(new_value_view);
      break;
    }",17,,283,9,,void
241426,BLOCK,12,,"{
      result = out->set_hostname(new_value_view);
      break;
    }",21,,287,12,,void
241437,BLOCK,15,,"{
      result = out->set_href(new_value_view);
      break;
    }",17,,291,15,,void
241448,BLOCK,18,,"{
      result = out->set_password(new_value_view);
      break;
    }",21,,295,18,,void
241459,BLOCK,21,,"{
      result = out->set_port(new_value_view);
      break;
    }",17,,299,21,,void
241470,BLOCK,24,,"{
      result = out->set_protocol(new_value_view);
      break;
    }",21,,303,24,,void
241481,BLOCK,27,,"{
      out->set_search(new_value_view);
      break;
    }",19,,307,27,,void
241490,BLOCK,30,,"{
      result = out->set_username(new_value_view);
      break;
    }",21,,311,30,,void
241505,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",16,,319,2,,void
241554,BLOCK,-1,,"{
  url_components_buffer_[0] = components.protocol_end;
  url_components_buffer_[1] = components.username_end;
  url_components_buffer_[2] = components.host_start;
  url_components_buffer_[3] = components.host_end;
  url_components_buffer_[4] = components.port;
  url_components_buffer_[5] = components.pathname_start;
  url_components_buffer_[6] = components.search_start;
  url_components_buffer_[7] = components.hash_start;
  url_components_buffer_[8] = type;
  static_assert(kURLComponentsLength == 9,
                ""kURLComponentsLength should be up-to-date"");
}",66,,330,3,,void
241626,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethodNoSideEffect(isolate, target, ""domainToASCII"", DomainToASCII);
  SetMethodNoSideEffect(isolate, target, ""domainToUnicode"", DomainToUnicode);
  SetMethodNoSideEffect(isolate, target, ""format"", Format);
  SetMethodNoSideEffect(isolate, target, ""getOrigin"", GetOrigin);
  SetMethod(isolate, target, ""parse"", Parse);
  SetMethod(isolate, target, ""update"", Update);
  SetFastMethodNoSideEffect(
      isolate, target, ""canParse"", CanParse, &fast_can_parse_);
}",76,,345,3,,void
241678,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,360,5,,void
241701,BLOCK,-1,,"{
  registry->Register(DomainToASCII);
  registry->Register(DomainToUnicode);
  registry->Register(Format);
  registry->Register(GetOrigin);
  registry->Register(Parse);
  registry->Register(Update);
  registry->Register(CanParse);
  registry->Register(FastCanParse);
  registry->Register(fast_can_parse_.GetTypeInfo());
}",42,,366,2,,void
241754,BLOCK,-1,,"{
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",60,,378,2,,void
241757,BLOCK,-1,,<empty>,3,,380,1,,void
241770,BLOCK,4,,"{
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }",51,,380,4,,void
241782,BLOCK,-1,,<empty>,30,,382,2,,void
241817,BLOCK,-1,,<empty>,1,,1,1,,ANY
241834,BLOCK,-1,,<empty>,1,,1,1,,ANY
241844,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Local<Object> object = args[0].As<Object>();
  Local<String> name = object->GetConstructorName();

  args.GetReturnValue().Set(name);
}",46,,79,2,,void
241886,BLOCK,-1,,"{
  CHECK(args[0]->IsExternal());
  Isolate* isolate = args.GetIsolate();
  Local<External> external = args[0].As<External>();

  void* ptr = external->Value();
  uint64_t value = reinterpret_cast<uint64_t>(ptr);
  Local<BigInt> ret = BigInt::NewFromUnsigned(isolate, value);
  args.GetReturnValue().Set(ret);
}",46,,89,2,,void
241950,BLOCK,-1,,"{
  // Return undefined if it's not a Promise.
  if (!args[0]->IsPromise())
    return;

  auto isolate = args.GetIsolate();

  Local<Promise> promise = args[0].As<Promise>();

  int state = promise->State();
  Local<Value> values[2] = { Integer::New(isolate, state) };
  size_t number_of_values = 1;
  if (state != Promise::PromiseState::kPending)
    values[number_of_values++] = promise->Result();
  Local<Array> ret = Array::New(isolate, values, number_of_values);
  args.GetReturnValue().Set(ret);
}",72,,100,2,,void
241959,BLOCK,-1,,<empty>,5,,103,2,,void
242007,BLOCK,-1,,<empty>,5,,113,2,,void
242042,BLOCK,-1,,"{
  // Return undefined if it's not a proxy.
  if (!args[0]->IsProxy())
    return;

  Local<Proxy> proxy = args[0].As<Proxy>();

  // TODO(BridgeAR): Remove the length check as soon as we prohibit access to
  // the util binding layer. It's accessed in the wild and `esm` would break in
  // case the check is removed.
  if (args.Length() == 1 || args[1]->IsTrue()) {
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  } else {
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }
}",70,,118,2,,void
242051,BLOCK,-1,,<empty>,5,,121,2,,void
242079,BLOCK,-1,,"{
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  }",48,,128,2,,void
242111,BLOCK,-1,,"{
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }",10,,136,1,,void
242134,BLOCK,-1,,"{
  if (args[0]->IsArrayBuffer()) {
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }
  args.GetReturnValue().Set(false);
}",76,,143,2,,void
242142,BLOCK,-1,,"{
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }",33,,144,2,,void
242176,BLOCK,-1,,"{
  if (!args[0]->IsObject())
    return;

  Environment* env = Environment::GetCurrent(args);
  bool is_key_value;
  Local<Array> entries;
  if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))
    return;
  // Fast path for WeakMap and WeakSet.
  if (args.Length() == 1)
    return args.GetReturnValue().Set(entries);

  Local<Value> ret[] = {
    entries,
    Boolean::New(env->isolate(), is_key_value)
  };
  return args.GetReturnValue().Set(
      Array::New(env->isolate(), ret, arraysize(ret)));
}",69,,152,2,,void
242185,BLOCK,-1,,<empty>,5,,154,2,,void
242219,BLOCK,-1,,<empty>,5,,160,2,,void
242228,BLOCK,-1,,<empty>,5,,163,2,,void
242275,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  uint32_t msec = args[0].As<Uint32>()->Value();
  uv_sleep(msec);
}",60,,173,2,,void
242301,BLOCK,-1,,"{
  CHECK(args[0]->IsArrayBufferView());
  args.GetReturnValue().Set(args[0].As<ArrayBufferView>()->HasBuffer());
}",72,,179,2,,void
242331,BLOCK,-1,,<empty>,47,,187,4,,void
242339,BLOCK,-1,,"{
  MakeWeak();
  if (!target.IsEmpty()) {
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }
}",41,,194,5,,void
242347,BLOCK,-1,,"{
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }",26,,196,2,,void
242361,BLOCK,-1,,"{
      target_.SetWeak();
    }",32,,198,2,,void
242371,BLOCK,-1,,"{
  if (target_.IsEmpty()) {
    target_index_ = 0;
    return true;
  }

  // Users can still hold strong references to target in addition to the
  // reference that we manage here, and they could expect that the referenced
  // object remains the same as long as that external strong reference
  // is alive. Since we have no way to know if there is any other reference
  // keeping the target alive, the best we can do to maintain consistency is to
  // simply save a reference to the target in the snapshot (effectively making
  // it strong) during serialization, and restore it during deserialization.
  // If there's no known counted reference from our side, we'll make the
  // reference here weak upon deserialization so that it can be GC'ed if users
  // do not hold additional references to it.
  Local<Object> target = target_.Get(context->GetIsolate());
  target_index_ = creator->AddData(context, target);
  DCHECK_NE(target_index_, 0);
  target_.Reset();
  return true;
}",75,,205,3,,void
242377,BLOCK,-1,,"{
    target_index_ = 0;
    return true;
  }",26,,206,2,,void
242418,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  info->target = target_index_;
  info->reference_count = reference_count_;
  return info;
}",60,,228,2,,void
242453,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());

  InternalFieldInfo* weak_info = reinterpret_cast<InternalFieldInfo*>(info);
  Local<Object> target;
  if (weak_info->target != 0) {
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }
  new WeakReference(
      Realm::GetCurrent(context), holder, target, weak_info->reference_count);
}",62,,240,5,,void
242482,BLOCK,-1,,"{
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }",31,,246,2,,void
242513,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  new WeakReference(realm, args.This(), args[0].As<Object>());
}",66,,254,2,,void
242551,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  Isolate* isolate = args.GetIsolate();
  if (!weak_ref->target_.IsEmpty())
    args.GetReturnValue().Set(weak_ref->target_.Get(isolate));
}",66,,261,2,,void
242578,BLOCK,-1,,<empty>,5,,265,2,,void
242597,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  weak_ref->reference_count_++;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 1) weak_ref->target_.ClearWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,268,2,,void
242620,BLOCK,-1,,<empty>,36,,271,2,,void
242628,BLOCK,-1,,<empty>,40,,272,2,,void
242659,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  CHECK_GE(weak_ref->reference_count_, 1);
  weak_ref->reference_count_--;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 0) weak_ref->target_.SetWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,277,2,,void
242687,BLOCK,-1,,<empty>,36,,281,2,,void
242695,BLOCK,-1,,<empty>,40,,282,2,,void
242726,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  uv_handle_type t = uv_guess_handle(fd);
  // TODO(anonrig): We can use an enum here and then create the array in the
  // binding, which will remove the hard-coding in C++ and JS land.
  uint32_t type{0};

  // Currently, the return type of this function corresponds to the index of the
  // array defined in the JS land. This is done as an optimization to reduce the
  // string serialization overhead.
  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  args.GetReturnValue().Set(type);
}",70,,287,2,,void
242753,BLOCK,-1,,<empty>,53,,290,2,,void
242770,BLOCK,-1,,"{
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }",14,,301,2,,void
242822,BLOCK,-1,,"{
  uv_handle_type t = uv_guess_handle(fd);
  uint32_t type{0};

  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  return type;
}",79,,327,3,,void
242835,BLOCK,-1,,"{
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }",14,,331,2,,void
242880,BLOCK,-1,,<empty>,,,,2,,<empty>
242885,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsNumber());

  TwoByteValue value(env->isolate(), args[0]);

  int64_t start = args[1]->IntegerValue(env->context()).FromJust();
  CHECK_GE(start, 0);

  for (size_t i = start; i < value.length(); i++) {
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }

  args.GetReturnValue().Set(
      String::NewFromTwoByte(env->isolate(),
                             *value,
                             v8::NewStringType::kNormal,
                             value.length()).ToLocalChecked());
}",66,,359,2,,void
242943,BLOCK,-1,,<empty>,3,,370,1,,void
242956,BLOCK,4,,"{
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }",51,,370,4,,void
242967,BLOCK,-1,,"{
      continue;
    }",33,,372,2,,void
242970,BLOCK,-1,,<empty>,12,,374,1,,void
242983,BLOCK,-1,,"{
      value[i] = kUnicodeReplacementCharacter;
    }",71,,374,2,,void
242990,BLOCK,-1,,"{
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }",12,,376,1,,void
243002,BLOCK,-1,,"{
        i++;
      }",30,,378,2,,void
243006,BLOCK,-1,,"{
        value[i] = kUnicodeReplacementCharacter;
      }",14,,380,1,,void
243045,BLOCK,-1,,"{
  registry->Register(GetPromiseDetails);
  registry->Register(GetProxyDetails);
  registry->Register(IsArrayBufferDetached);
  registry->Register(PreviewEntries);
  registry->Register(GetOwnNonIndexProperties);
  registry->Register(GetConstructorName);
  registry->Register(GetExternalValue);
  registry->Register(Sleep);
  registry->Register(ArrayBufferViewHasBuffer);
  registry->Register(WeakReference::New);
  registry->Register(WeakReference::Get);
  registry->Register(WeakReference::IncRef);
  registry->Register(WeakReference::DecRef);
  registry->Register(GuessHandleType);
  registry->Register(FastGuessHandleType);
  registry->Register(fast_guess_handle_type_.GetTypeInfo());
  registry->Register(ToUSVString);
}",70,,393,2,,void
243149,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }

  {
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::Ne...",29,,416,5,,void
243165,BLOCK,5,,"{
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }",3,,420,5,,void
243198,BLOCK,6,,"{
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Promise::PromiseState::name))                \
      .Check();

    V(kPending);
    V(kFulfilled);
    V(kRejected);
#undef V

#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Environment::ExitInfoField::name))           \
      .Check();

    V(kExiting);
    V(kExitCode);
...",3,,436,6,,void
243211,BLOCK,1,,<empty>,,,,3,,void
243234,BLOCK,1,,<empty>,,,,3,,void
243257,BLOCK,1,,<empty>,,,,3,,void
243280,BLOCK,1,,<empty>,,,,3,,void
243303,BLOCK,1,,<empty>,,,,3,,void
243326,BLOCK,1,,<empty>,,,,3,,void
243349,BLOCK,1,,<empty>,,,,3,,void
243370,BLOCK,1,,<empty>,,,,3,,void
243391,BLOCK,1,,<empty>,,,,3,,void
243412,BLOCK,1,,<empty>,,,,3,,void
243433,BLOCK,1,,<empty>,,,,3,,void
243454,BLOCK,1,,<empty>,,,,3,,void
243633,BLOCK,-1,,<empty>,1,,1,1,,ANY
243656,BLOCK,-1,,<empty>,1,,1,1,,ANY
243663,BLOCK,1,,<empty>,,,,1,,void
243696,BLOCK,1,,<empty>,,,,1,,void
243709,BLOCK,1,,<empty>,,,,1,,void
243722,BLOCK,-1,,"{
  Local<Context> context = realm->context();
  if (info == nullptr) {
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  } else {
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }
  heap_statistics_buffer.MakeWeak();
  heap_space_statistics_buffer.MakeWeak();
  heap_code_statistics_buffer.MakeWeak();
}",63,,109,4,,void
243737,BLOCK,-1,,"{
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  }",24,,111,2,,void
243793,BLOCK,-1,,"{
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }",10,,126,1,,void
243835,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->heap_statistics_buffer =
      heap_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_space_statistics_buffer =
      heap_space_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_code_statistics_buffer =
      heap_code_statistics_buffer.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,137,3,,void
243885,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,154,5,,void
243931,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,165,2,,void
243950,BLOCK,-1,,"{
  tracker->TrackField(""heap_statistics_buffer"", heap_statistics_buffer);
  tracker->TrackField(""heap_space_statistics_buffer"",
                      heap_space_statistics_buffer);
  tracker->TrackField(""heap_code_statistics_buffer"",
                      heap_code_statistics_buffer);
}",60,,172,2,,void
243973,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Integer> result =
      Integer::NewFromUnsigned(env->isolate(),
                               ScriptCompiler::CachedDataVersionTag());
  args.GetReturnValue().Set(result);
}",68,,180,2,,void
244012,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t limit = args[0].As<v8::Uint32>()->Value();
  CHECK_GT(limit, 0);
  env->AddHeapSnapshotNearHeapLimitCallback();
  env->set_heap_snapshot_near_heap_limit(limit);
}",76,,188,2,,void
244056,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapStatistics s;
  args.GetIsolate()->GetHeapStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_statistics_buffer;
#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_STATISTICS_PROPERTIES(V)
#undef V
}",74,,197,2,,void
244084,BLOCK,1,,<empty>,,,,3,,void
244229,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapSpaceStatistics s;
  Isolate* const isolate = args.GetIsolate();
  CHECK(args[0]->IsUint32());
  size_t space_index = static_cast<size_t>(args[0].As<v8::Uint32>()->Value());
  isolate->GetHeapSpaceStatistics(&s, space_index);

  AliasedFloat64Array& buffer = data->heap_space_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_SPACE_STATISTICS_PROPERTIES(V)
#undef V
}",79,,208,2,,void
244283,BLOCK,1,,<empty>,,,,3,,void
244328,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapCodeStatistics s;
  args.GetIsolate()->GetHeapCodeAndMetadataStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_code_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_CODE_STATISTICS_PROPERTIES(V)
#undef V
}",78,,223,2,,void
244356,BLOCK,1,,<empty>,,,,3,,void
244401,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  String::Utf8Value flags(args.GetIsolate(), args[0]);
  V8::SetFlagsFromString(*flags, static_cast<size_t>(flags.length()));
}",66,,235,2,,void
244434,BLOCK,-1,,"{
  switch (gc_type) {
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }
}",54,,241,2,,void
244437,BLOCK,-1,,"{
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }",20,,242,2,,void
244478,BLOCK,-1,,"{
  HeapStatistics heap_statistics;
  isolate->GetHeapStatistics(&heap_statistics);
  writer->json_objectstart(""heapStatistics"");
  writer->json_keyvalue(""totalHeapSize"", heap_statistics.total_heap_size());
  writer->json_keyvalue(""totalHeapSizeExecutable"",
                        heap_statistics.total_heap_size_executable());
  writer->json_keyvalue(""totalPhysicalSize"",
                        heap_statistics.total_physical_size());
  writer->json_keyvalue(""totalAvailableSize"",
                        heap_statistics.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesSize"",
                        heap_statistics.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesSize"",
                        heap_statistics.used_global_handles_size());
  writer->json_keyvalue(""usedHeapSize"", heap_statistics.used_heap_size());
  writer->json_keyvalue(""heapSizeLimit"", heap_statistics.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", heap_statistics....",69,,256,3,,void
244607,BLOCK,-1,,<empty>,3,,281,1,,void
244617,BLOCK,4,,"{
    HeapSpaceStatistics heap_space_statistics;
    isolate->GetHeapSpaceStatistics(&heap_space_statistics, i);
    writer->json_start();
    writer->json_keyvalue(""spaceName"", heap_space_statistics.space_name());
    writer->json_keyvalue(""spaceSize"", heap_space_statistics.space_size());
    writer->json_keyvalue(""spaceUsedSize"",
                          heap_space_statistics.space_used_size());
    writer->json_keyvalue(""spaceAvailableSize"",
                          heap_space_statistics.space_available_size());
    writer->json_keyvalue(""physicalSpaceSize"",
                          heap_space_statistics.physical_space_size());
    writer->json_end();
  }",41,,281,4,,void
244690,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != 0) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  writer->json_start();
  writer->json_keyvalue(""gcType"", GetGCTypeName(gc_type));
  writer->json_objectstart(""beforeGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  profiler->current_gc_type = gc_type;
  profiler->start_time = uv_hrtime();
}",42,,301,5,,void
244703,BLOCK,-1,,"{
    return;
  }",39,,303,2,,void
244752,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != gc_type) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  profiler->current_gc_type = 0;
  writer->json_keyvalue(""cost"", (uv_hrtime() - profiler->start_time) / 1e3);
  profiler->start_time = 0;
  writer->json_objectstart(""afterGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  writer->json_end();
}",41,,319,5,,void
244765,BLOCK,-1,,"{
    return;
  }",45,,321,2,,void
244817,BLOCK,-1,,"{
  MakeWeak();
}",35,,339,3,,void
244822,BLOCK,-1,,"{
  if (state != GCProfiler::GCProfilerState::kInitialized) {
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }
}",27,,348,1,,void
244831,BLOCK,-1,,"{
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }",59,,349,2,,void
244853,BLOCK,-1,,"{
  return &writer_;
}",34,,355,1,,void
244860,BLOCK,-1,,"{
  return &out_stream_;
}",46,,359,1,,void
244868,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new GCProfiler(env, args.This());
}",63,,363,2,,void
244893,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
    return;
  }
  profiler->writer()->json_start();
  profiler->writer()->json_keyvalue(""version"", 1);

  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }
  profiler->writer()->json_arraystart(""statistics"");
  env->isolate()->AddGCPrologueCallback(BeforeGCCallback,
                                        static_cast<void*>(profiler));
  env->isolate()->AddGCEpilogueCallback(AfterGCCallback,
                                        static_cast<void*>(profiler));
  profiler->state = GCProfiler::GCProfilerState::kStarted;
}",65,,369,2,,void
244920,BLOCK,-1,,"{
    return;
  }",69,,373,2,,void
244945,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,380,2,,void
244966,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }",10,,383,1,,void
245019,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
    return;
  }
  profiler->writer()->json_arrayend();
  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }
  profiler->writer()->json_end();
  profiler->state = GCProfiler::GCProfilerState::kStopped;
  auto string = profiler->out_stream()->str();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                string.data(),
                                                v8::NewStringType::kNormal,
                                                string.size())
                                .ToLocalChecked());
}",68,,394,2,,void
245046,BLOCK,-1,,"{
    return;
  }",65,,398,2,,void
245062,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,403,2,,void
245083,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }",10,,406,1,,void
245157,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  SetMethodNoSideEffect(
      context, target, ""cachedDataVersionTag"", CachedDataVersionTag);
  SetMethodNoSideEffect(context,
                        target,
                        ""setHeapSnapshotNearHeapLimit"",
                        SetHeapSnapshotNearHeapLimit);
  SetMethod(context,
            target,
            ""updateHeapStatisticsBuffer"",
            UpdateHeapStatisticsBuffer);

  SetMethod(context,
            target,
            ""updateHeapCodeStatisticsBuffer"",
            UpdateHeapCodeStatisticsBuffer);

  size_t number_of_heap_spaces = env->isolate()->NumberOfHeapSpaces();

  // Heap space names are extracted once and exposed to JavaScript to
  // avoid excessive creation of heap space name Strings.
  HeapSpaceStatistics s;
  MaybeStackBuffer<Local<V...",29,,422,5,,void
245190,BLOCK,-1,,<empty>,32,,427,2,,void
245227,BLOCK,-1,,<empty>,3,,451,1,,void
245237,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&s, i);
    heap_spaces[i] = String::NewFromUtf8(env->isolate(), s.space_name())
                                             .ToLocalChecked();
  }",54,,451,4,,void
245300,BLOCK,1,,<empty>,,,,3,,void
245624,BLOCK,1,,<empty>,,,,3,,void
245718,BLOCK,1,,<empty>,,,,3,,void
245869,BLOCK,-1,,"{
  registry->Register(CachedDataVersionTag);
  registry->Register(UpdateHeapStatisticsBuffer);
  registry->Register(UpdateHeapCodeStatisticsBuffer);
  registry->Register(UpdateHeapSpaceStatisticsBuffer);
  registry->Register(SetFlagsFromString);
  registry->Register(SetHeapSnapshotNearHeapLimit);
  registry->Register(GCProfiler::New);
  registry->Register(GCProfiler::Start);
  registry->Register(GCProfiler::Stop);
}",70,,492,2,,void
245942,BLOCK,-1,,<empty>,1,,1,1,,ANY
245969,BLOCK,-1,,<empty>,1,,1,1,,ANY
245974,BLOCK,-1,,<empty>,1,,1,1,,ANY
246001,BLOCK,-1,,<empty>,1,,1,1,,ANY
246007,BLOCK,-1,,"{
  Debug(wasi.env(), DebugCategory::WASI, std::forward<Args>(args)...);
}",53,,17,3,,void
246029,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  CHECK_NOT_NULL(env);
  const char* err_name = uvwasi_embedder_err_code_to_string(errorno);
  Local<String> js_code = OneByteString(isolate, err_name);
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);
  Local<Object> e;
  if (!Exception::Error(js_msg)->ToObject(context).ToLocal(&e))
    return MaybeLocal<Value>();

  if (e->Set(context,
             env->errno_string(),
             Integer::New(isolate, errorno)).IsNothing() ||
      e->Set(context, env->code_string(), js_code).IsNothing() ||
      e->Set(context, env->syscall_string(), js_syscall).IsNothing()) {
    return MaybeLocal<Value>();
  }

  return e;
}",61,,50,4,,void
246118,BLOCK,-1,,<empty>,5,,63,2,,void
246168,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",71,,69,2,,void
246179,BLOCK,-1,,"{
  MakeWeak();
  alloc_info_ = MakeAllocator();
  options->allocator = &alloc_info_;
  int err = uvwasi_init(&uvw_, options);
  if (err != UVWASI_ESUCCESS) {
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }
}",65,,79,4,,void
246201,BLOCK,-1,,"{
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }",31,,84,2,,void
246221,BLOCK,-1,,<empty>,7,,87,2,,void
246234,BLOCK,-1,,"{
  uvwasi_destroy(&uvw_);
  CHECK_EQ(current_uvwasi_memory_, 0);
}",15,,94,1,,void
246243,BLOCK,-1,,"{
  tracker->TrackField(""memory"", memory_);
  tracker->TrackFieldWithSize(""uvwasi_memory"", current_uvwasi_memory_);
}",53,,99,2,,void
246260,BLOCK,-1,,"{
  CHECK_GE(current_uvwasi_memory_, previous_size);
}",59,,104,2,,void
246268,BLOCK,-1,,"{
  current_uvwasi_memory_ += size;
}",47,,108,2,,void
246276,BLOCK,-1,,"{
  current_uvwasi_memory_ -= size;
}",47,,112,2,,void
246284,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 4);
  CHECK(args[0]->IsArray());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsArray());
  CHECK(args[3]->IsArray());

  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Local<Array> argv = args[0].As<Array>();
  const uint32_t argc = argv->Length();
  uvwasi_options_t options;

  uvwasi_options_init(&options);

  Local<Array> stdio = args[3].As<Array>();
  CHECK_EQ(stdio->Length(), 3);
  options.in = stdio->Get(context, 0).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.out = stdio->Get(context, 1).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.err = stdio->Get(context, 2).ToLocalChecked()->
    Int32Value(context).FromJust();

  options.fd_table_size = 3;
  options.argc = argc;
  options.argv =
    const_cast<const char**>(argc == 0 ? nullptr : new char*[argc]);

  for (uint32_t i = 0; i < argc; i++) {
    auto arg = argv->Get(context, i)....",57,,116,2,,void
246467,BLOCK,-1,,<empty>,3,,146,1,,void
246477,BLOCK,4,,"{
    auto arg = argv->Get(context, i).ToLocalChecked();
    CHECK(arg->IsString());
    node::Utf8Value str(env->isolate(), arg);
    options.argv[i] = strdup(*str);
    CHECK_NOT_NULL(options.argv[i]);
  }",39,,146,4,,void
246545,BLOCK,-1,,<empty>,3,,157,1,,void
246555,BLOCK,4,,"{
    auto pair = env_pairs->Get(context, i).ToLocalChecked();
    CHECK(pair->IsString());
    node::Utf8Value str(env->isolate(), pair);
    options.envp[i] = strdup(*str);
    CHECK_NOT_NULL(options.envp[i]);
  }",39,,157,4,,void
246648,BLOCK,-1,,<empty>,3,,171,1,,void
246662,BLOCK,4,,"{
    auto mapped = preopens->Get(context, i).ToLocalChecked();
    auto real = preopens->Get(context, i + 1).ToLocalChecked();
    CHECK(mapped->IsString());
    CHECK(real->IsString());
    node::Utf8Value mapped_path(env->isolate(), mapped);
    node::Utf8Value real_path(env->isolate(), real);
    options.preopens[index].mapped_path = strdup(*mapped_path);
    CHECK_NOT_NULL(options.preopens[index].mapped_path);
    options.preopens[index].real_path = strdup(*real_path);
    CHECK_NOT_NULL(options.preopens[index].real_path);
    index++;
  }",56,,171,4,,void
246768,BLOCK,-1,,"{
    for (uint32_t i = 0; i < argc; i++)
      free(const_cast<char*>(options.argv[i]));
    delete[] options.argv;
  }",32,,187,2,,void
246770,BLOCK,-1,,<empty>,5,,188,1,,void
246793,BLOCK,-1,,<empty>,3,,193,1,,void
246823,BLOCK,-1,,"{
    for (uint32_t i = 0; i < options.preopenc; i++) {
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }

    free(options.preopens);
  }",36,,197,2,,void
246825,BLOCK,-1,,<empty>,5,,198,1,,void
246837,BLOCK,4,,"{
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }",53,,198,4,,void
246868,BLOCK,-1,,"{
  auto c_function = CFunction::Make(FastCallback);
  Local<FunctionTemplate> t =
      FunctionTemplate::New(env->isolate(),
                            SlowCallback,
                            Local<Value>(),
                            Local<Signature>(),
                            sizeof...(Args),
                            v8::ConstructorBehavior::kThrow,
                            v8::SideEffectType::kHasSideEffect,
                            &c_function);
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<String> name_string =
      String::NewFromUtf8(env->isolate(), name, type).ToLocalChecked();
  tmpl->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",71,,209,4,,void
246953,BLOCK,-1,,<empty>,,,,1,,<empty>
246957,BLOCK,-1,,"{
  return UVWASI_EINVAL;
}",31,,232,1,,void
246963,BLOCK,-1,,<empty>,27,,237,1,,void
246970,BLOCK,-1,,"{
  WASI* wasi = reinterpret_cast<WASI*>(BaseObject::FromJSObject(receiver));
  if (UNLIKELY(wasi == nullptr)) return EinvalError<R>();

  if (UNLIKELY(options.wasm_memory == nullptr || wasi->memory_.IsEmpty())) {
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }
  uint8_t* memory = nullptr;
  CHECK(LIKELY(options.wasm_memory->getStorageIfAligned(&memory)));

  return F(*wasi,
           {reinterpret_cast<char*>(memory), options.wasm_memory->length()},
           args...);
}",38,,245,4,,void
246986,BLOCK,-1,,<empty>,34,,247,2,,void
247003,BLOCK,-1,,"{
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }",76,,249,2,,void
247045,BLOCK,-1,,<empty>,,,,2,,<empty>
247050,BLOCK,-1,,<empty>,,,,2,,<empty>
247055,BLOCK,-1,,"{
  return value->IsUint32();
}",46,,270,2,,void
247065,BLOCK,-1,,"{
  return value.As<Uint32>()->Value();
}",42,,275,2,,void
247078,BLOCK,-1,,"{
  return value->IsBigInt();
}",46,,280,2,,void
247088,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Uint64Value(&lossless);
}",42,,285,2,,void
247111,BLOCK,-1,,"{
  return value->IsBigInt();
}",45,,292,2,,void
247121,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Int64Value(&lossless);
}",41,,297,2,,void
247146,BLOCK,-1,,"{
  return CheckType<T>(info[i]);
}",68,,304,4,,void
247159,BLOCK,-1,,"{
  if (!CheckTypes<T>(info, i, arg)) return false;
  return CheckTypes<Ts...>(info, i + 1, args...);
}",29,,312,5,,void
247166,BLOCK,-1,,<empty>,37,,313,2,,void
247180,BLOCK,-1,,"{
  return CheckTypes<Args...>(info, 0, Args()...);
}",58,,318,2,,void
247190,BLOCK,-1,,"{
  return true;
}",58,,323,2,,void
247200,BLOCK,-1,,"{
  args.GetReturnValue().Set(
      F(*wasi, memory, ConvertType<Args>(args[Indices])...));
}",49,,336,5,,void
247223,BLOCK,-1,,"{
  F(*wasi, memory, ConvertType<Args>(args[Indices])...);
}",49,,350,5,,void
247236,BLOCK,-1,,"{
  if (args.Length() != sizeof...(Args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }
  if (!CheckTypes<Args...>(args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }

  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  if (wasi->memory_.IsEmpty()) {
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }

  Local<WasmMemoryObject> memory = PersistentToLocal::Strong(wasi->memory_);
  Local<ArrayBuffer> ab = memory->Buffer();
  size_t mem_size = ab->ByteLength();
  char* mem_data = static_cast<char*>(ab->Data());
  CHECK_NOT_NULL(mem_data);

  CallAndSetReturn<FT, F, R, Args...>(
      std::make_index_sequence<sizeof...(Args)>{},
      args,
      wasi,
      {mem_data, mem_size});
}",46,,358,2,,void
247245,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",41,,359,2,,void
247259,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",35,,363,2,,void
247284,BLOCK,-1,,"{
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }",32,,370,2,,void
247348,BLOCK,-1,,"{
  WASI::WasiFunction<FT, F, R, Args...>::SetFunction(env, name, tmpl);
}",55,,392,5,,void
247365,BLOCK,-1,,"{
  Debug(wasi, ""args_get(%d, %d)\n"", argv_offset, argv_buf_offset);

  CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> argv(wasi.uvw_.argc);
  char* argv_buf = &memory.data[argv_buf_offset];
  uvwasi_errno_t err = uvwasi_args_get(&wasi.uvw_, argv.data(), argv_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }

  return err;
}",50,,399,5,,void
247381,BLOCK,1,,<empty>,,,,4,,void
247383,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,1,,void
247396,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,2,,void
247405,BLOCK,1,,<empty>,,,,3,,void
247407,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,1,,void
247422,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,2,,void
247459,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }",31,,409,2,,void
247461,BLOCK,-1,,<empty>,5,,410,1,,void
247475,BLOCK,4,,"{
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }",49,,410,4,,void
247509,BLOCK,-1,,"{
  Debug(wasi, ""args_sizes_get(%d, %d)\n"", argc_offset, argv_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t argc;
  uvwasi_size_t argv_buf_size;
  uvwasi_errno_t err = uvwasi_args_sizes_get(&wasi.uvw_, &argc, &argv_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }

  return err;
}",55,,424,5,,void
247521,BLOCK,1,,<empty>,,,,4,,void
247523,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,1,,void
247532,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,2,,void
247542,BLOCK,1,,<empty>,,,,4,,void
247544,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,1,,void
247553,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,2,,void
247575,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }",31,,432,2,,void
247597,BLOCK,-1,,"{
  Debug(wasi, ""clock_res_get(%d, %d)\n"", clock_id, resolution_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t resolution;
  uvwasi_errno_t err = uvwasi_clock_res_get(&wasi.uvw_, clock_id, &resolution);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, resolution_ptr, resolution);

  return err;
}",53,,443,5,,void
247609,BLOCK,1,,<empty>,,,,4,,void
247611,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,1,,void
247620,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,2,,void
247640,BLOCK,-1,,<empty>,5,,450,2,,void
247657,BLOCK,-1,,"{
  Debug(wasi, ""clock_time_get(%d, %d, %d)\n"", clock_id, precision, time_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t time;
  uvwasi_errno_t err =
      uvwasi_clock_time_get(&wasi.uvw_, clock_id, precision, &time);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, time_ptr, time);

  return err;
}",48,,459,6,,void
247670,BLOCK,1,,<empty>,,,,4,,void
247672,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,1,,void
247681,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,2,,void
247702,BLOCK,-1,,<empty>,5,,466,2,,void
247718,BLOCK,-1,,"{
  Debug(wasi, ""environ_get(%d, %d)\n"", environ_offset, environ_buf_offset);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size);
  CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> environment(wasi.uvw_.envc);
  char* environ_buf = &memory.data[environ_buf_offset];
  uvwasi_errno_t err =
      uvwasi_environ_get(&wasi.uvw_, environment.data(), environ_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }

  return err;
}",56,,474,5,,void
247734,BLOCK,1,,<empty>,,,,4,,void
247736,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,1,,void
247749,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,2,,void
247758,BLOCK,1,,<empty>,,,,3,,void
247760,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,1,,void
247775,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,2,,void
247812,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }",31,,486,2,,void
247814,BLOCK,-1,,<empty>,5,,487,1,,void
247828,BLOCK,4,,"{
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }",49,,487,4,,void
247862,BLOCK,-1,,"{
  Debug(wasi, ""environ_sizes_get(%d, %d)\n"", envc_offset, env_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t envc;
  uvwasi_size_t env_buf_size;
  uvwasi_errno_t err =
      uvwasi_environ_sizes_get(&wasi.uvw_, &envc, &env_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }

  return err;
}",57,,504,5,,void
247874,BLOCK,1,,<empty>,,,,4,,void
247876,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,1,,void
247885,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,2,,void
247895,BLOCK,1,,<empty>,,,,4,,void
247897,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,1,,void
247906,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,2,,void
247928,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }",31,,513,2,,void
247952,BLOCK,-1,,"{
  Debug(wasi, ""fd_advise(%d, %d, %d, %d)\n"", fd, offset, len, advice);
  return uvwasi_fd_advise(&wasi.uvw_, fd, offset, len, advice);
}",42,,526,7,,void
247978,BLOCK,-1,,"{
  Debug(wasi, ""fd_allocate(%d, %d, %d)\n"", fd, offset, len);
  return uvwasi_fd_allocate(&wasi.uvw_, fd, offset, len);
}",73,,532,6,,void
248000,BLOCK,-1,,"{
  Debug(wasi, ""fd_close(%d)\n"", fd);
  return uvwasi_fd_close(&wasi.uvw_, fd);
}",61,,537,4,,void
248018,BLOCK,-1,,"{
  Debug(wasi, ""fd_datasync(%d)\n"", fd);
  return uvwasi_fd_datasync(&wasi.uvw_, fd);
}",64,,542,4,,void
248037,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t);
  uvwasi_fdstat_t stats;
  uvwasi_errno_t err = uvwasi_fd_fdstat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_fdstat_t(memory.data, buf, &stats);

  return err;
}",42,,550,5,,void
248049,BLOCK,1,,<empty>,,,,4,,void
248051,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,1,,void
248060,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,2,,void
248080,BLOCK,-1,,<empty>,5,,557,2,,void
248097,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_set_flags(%d, %d)\n"", fd, flags);
  return uvwasi_fd_fdstat_set_flags(&wasi.uvw_, fd, flags);
}",49,,565,5,,void
248119,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_fdstat_set_rights(%d, %d, %d)\n"",
        fd,
        fs_rights_base,
        fs_rights_inheriting);
  return uvwasi_fd_fdstat_set_rights(
      &wasi.uvw_, fd, fs_rights_base, fs_rights_inheriting);
}",65,,574,6,,void
248142,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_fd_filestat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf, &stats);

  return err;
}",44,,587,5,,void
248154,BLOCK,1,,<empty>,,,,4,,void
248156,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,1,,void
248165,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,2,,void
248185,BLOCK,-1,,<empty>,5,,594,2,,void
248202,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_set_size(%d, %d)\n"", fd, st_size);
  return uvwasi_fd_filestat_set_size(&wasi.uvw_, fd, st_size);
}",52,,602,5,,void
248225,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_filestat_set_times(%d, %d, %d, %d)\n"",
        fd,
        st_atim,
        st_mtim,
        fst_flags);
  return uvwasi_fd_filestat_set_times(
      &wasi.uvw_, fd, st_atim, st_mtim, fst_flags);
}",55,,612,7,,void
248253,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pread(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_pread(&wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",44,,629,8,,void
248267,BLOCK,1,,<empty>,,,,3,,void
248269,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,1,,void
248280,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,2,,void
248290,BLOCK,1,,<empty>,,,,4,,void
248292,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,1,,void
248301,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,2,,void
248333,BLOCK,-1,,"{
    return err;
  }",31,,645,2,,void
248357,BLOCK,-1,,<empty>,5,,652,2,,void
248373,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t);
  uvwasi_prestat_t prestat;
  uvwasi_errno_t err = uvwasi_fd_prestat_get(&wasi.uvw_, fd, &prestat);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_prestat_t(memory.data, buf, &prestat);

  return err;
}",43,,660,5,,void
248385,BLOCK,1,,<empty>,,,,4,,void
248387,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,1,,void
248396,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,2,,void
248416,BLOCK,-1,,<empty>,5,,667,2,,void
248434,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_dir_name(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_fd_prestat_dir_name(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",52,,676,6,,void
248447,BLOCK,1,,<empty>,,,,4,,void
248449,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,1,,void
248458,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,2,,void
248486,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pwrite(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_pwrite(
      &wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",48,,689,8,,void
248500,BLOCK,1,,<empty>,,,,3,,void
248502,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,1,,void
248513,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,2,,void
248523,BLOCK,1,,<empty>,,,,4,,void
248525,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,1,,void
248534,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,2,,void
248566,BLOCK,-1,,"{
    return err;
  }",31,,705,2,,void
248590,BLOCK,-1,,<empty>,5,,713,2,,void
248608,BLOCK,-1,,"{
  Debug(wasi, ""fd_read(%d, %d, %d, %d)\n"", fd, iovs_ptr, iovs_len, nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_read(&wasi.uvw_, fd, iovs.data(), iovs_len, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",43,,723,7,,void
248621,BLOCK,1,,<empty>,,,,3,,void
248623,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,1,,void
248634,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,2,,void
248644,BLOCK,1,,<empty>,,,,4,,void
248646,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,1,,void
248655,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,2,,void
248687,BLOCK,-1,,"{
    return err;
  }",31,,733,2,,void
248710,BLOCK,-1,,<empty>,5,,740,2,,void
248729,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_readdir(%d, %d, %d, %d, %d)\n"",
        fd,
        buf_ptr,
        buf_len,
        cookie,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_fd_readdir(
      &wasi.uvw_, fd, &memory.data[buf_ptr], buf_len, cookie, &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",48,,751,8,,void
248744,BLOCK,1,,<empty>,,,,4,,void
248746,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,1,,void
248755,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,2,,void
248765,BLOCK,1,,<empty>,,,,4,,void
248767,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,1,,void
248776,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,2,,void
248804,BLOCK,-1,,<empty>,5,,765,2,,void
248820,BLOCK,-1,,"{
  Debug(wasi, ""fd_renumber(%d, %d)\n"", from, to);
  return uvwasi_fd_renumber(&wasi.uvw_, from, to);
}",79,,770,5,,void
248843,BLOCK,-1,,"{
  Debug(wasi, ""fd_seek(%d, %d, %d, %d)\n"", fd, offset, whence, newoffset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t newoffset;
  uvwasi_errno_t err =
      uvwasi_fd_seek(&wasi.uvw_, fd, offset, whence, &newoffset);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, newoffset_ptr, newoffset);

  return err;
}",47,,780,7,,void
248857,BLOCK,1,,<empty>,,,,4,,void
248859,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,1,,void
248868,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,2,,void
248890,BLOCK,-1,,<empty>,5,,788,2,,void
248905,BLOCK,-1,,"{
  Debug(wasi, ""fd_sync(%d)\n"", fd);
  return uvwasi_fd_sync(&wasi.uvw_, fd);
}",60,,793,4,,void
248924,BLOCK,-1,,"{
  Debug(wasi, ""fd_tell(%d, %d)\n"", fd, offset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t offset;
  uvwasi_errno_t err = uvwasi_fd_tell(&wasi.uvw_, fd, &offset);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, offset_ptr, offset);

  return err;
}",44,,801,5,,void
248936,BLOCK,1,,<empty>,,,,4,,void
248938,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,1,,void
248947,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,2,,void
248967,BLOCK,-1,,<empty>,5,,809,2,,void
248985,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_write(%d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_write(&wasi.uvw_, fd, iovs.data(), iovs_len, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",47,,819,7,,void
248998,BLOCK,1,,<empty>,,,,3,,void
249000,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,1,,void
249011,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,2,,void
249021,BLOCK,1,,<empty>,,,,4,,void
249023,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,1,,void
249032,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,2,,void
249064,BLOCK,-1,,"{
    return err;
  }",31,,834,2,,void
249087,BLOCK,-1,,<empty>,5,,841,2,,void
249104,BLOCK,-1,,"{
  Debug(wasi, ""path_create_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  uvwasi_errno_t err = uvwasi_path_create_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
  return err;
}",55,,850,6,,void
249117,BLOCK,1,,<empty>,,,,4,,void
249119,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,1,,void
249128,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,2,,void
249160,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_get(%d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_path_filestat_get(
      &wasi.uvw_, fd, flags, &memory.data[path_ptr], path_len, &stats);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf_ptr, &stats);

  return err;
}",50,,864,8,,void
249173,BLOCK,1,,<empty>,,,,4,,void
249175,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,1,,void
249184,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,2,,void
249194,BLOCK,1,,<empty>,,,,4,,void
249196,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,1,,void
249205,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,2,,void
249233,BLOCK,-1,,<empty>,5,,876,2,,void
249255,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_set_times(%d, %d, %d, %d, %d, %d, %d)\n"",
        fd,
        flags,
        path_ptr,
        path_len,
        st_atim,
        st_mtim,
        fst_flags);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_filestat_set_times(&wasi.uvw_,
                                        fd,
                                        flags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        st_atim,
                                        st_mtim,
                                        fst_flags);
}",57,,889,10,,void
249272,BLOCK,1,,<empty>,,,,4,,void
249274,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,1,,void
249283,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,2,,void
249317,BLOCK,-1,,"{
  Debug(wasi,
        ""path_link(%d, %d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_flags,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_link(&wasi.uvw_,
                          old_fd,
                          old_flags,
                          &memory.data[old_path_ptr],
                          old_path_len,
                          new_fd,
                          &memory.data[new_path_ptr],
                          new_path_len);
}",48,,918,10,,void
249334,BLOCK,1,,<empty>,,,,4,,void
249336,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,1,,void
249345,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,2,,void
249355,BLOCK,1,,<empty>,,,,4,,void
249357,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,1,,void
249366,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,2,,void
249407,BLOCK,-1,,"{
  Debug(wasi,
        ""path_open(%d, %d, %d, %d, %d, %d, %d, %d, %d)\n"",
        dirfd,
        dirflags,
        path_ptr,
        path_len,
        o_flags,
        fs_rights_base,
        fs_rights_inheriting,
        fs_flags,
        fd_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_path_open(&wasi.uvw_,
                                        dirfd,
                                        dirflags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        static_cast<uvwasi_oflags_t>(o_flags),
                                        fs_rights_base,
                                        fs_rights_inheriting,
                                        static_cast<uvwasi_fdflags_t>(fs_flags),
                                        &fd);
  if (err =...",42,,950,12,,void
249426,BLOCK,1,,<empty>,,,,4,,void
249428,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,1,,void
249437,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,2,,void
249447,BLOCK,1,,<empty>,,,,4,,void
249449,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,1,,void
249458,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,2,,void
249494,BLOCK,-1,,<empty>,5,,976,2,,void
249514,BLOCK,-1,,"{
  Debug(wasi,
        ""path_readlink(%d, %d, %d, %d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len,
        buf_ptr,
        buf_len,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_path_readlink(&wasi.uvw_,
                                            fd,
                                            &memory.data[path_ptr],
                                            path_len,
                                            &memory.data[buf_ptr],
                                            buf_len,
                                            &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",51,,988,9,,void
249530,BLOCK,1,,<empty>,,,,4,,void
249532,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,1,,void
249541,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,2,,void
249551,BLOCK,1,,<empty>,,,,4,,void
249553,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,1,,void
249562,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,2,,void
249572,BLOCK,1,,<empty>,,,,4,,void
249574,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,1,,void
249583,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,2,,void
249617,BLOCK,-1,,<empty>,5,,1009,2,,void
249634,BLOCK,-1,,"{
  Debug(wasi, ""path_remove_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_remove_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",55,,1018,6,,void
249647,BLOCK,1,,<empty>,,,,4,,void
249649,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,1,,void
249658,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,2,,void
249687,BLOCK,-1,,"{
  Debug(wasi,
        ""path_rename(%d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_rename(&wasi.uvw_,
                            old_fd,
                            &memory.data[old_path_ptr],
                            old_path_len,
                            new_fd,
                            &memory.data[new_path_ptr],
                            new_path_len);
}",50,,1032,9,,void
249703,BLOCK,1,,<empty>,,,,4,,void
249705,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,1,,void
249714,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,2,,void
249724,BLOCK,1,,<empty>,,,,4,,void
249726,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,1,,void
249735,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,2,,void
249771,BLOCK,-1,,"{
  Debug(wasi,
        ""path_symlink(%d, %d, %d, %d, %d)\n"",
        old_path_ptr,
        old_path_len,
        fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_symlink(&wasi.uvw_,
                             &memory.data[old_path_ptr],
                             old_path_len,
                             fd,
                             &memory.data[new_path_ptr],
                             new_path_len);
}",51,,1058,8,,void
249786,BLOCK,1,,<empty>,,,,4,,void
249788,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,1,,void
249797,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,2,,void
249807,BLOCK,1,,<empty>,,,,4,,void
249809,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,1,,void
249818,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,2,,void
249851,BLOCK,-1,,"{
  Debug(wasi, ""path_unlink_file(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_unlink_file(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",50,,1080,6,,void
249864,BLOCK,1,,<empty>,,,,4,,void
249866,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,1,,void
249875,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,2,,void
249902,BLOCK,-1,,"{
  Debug(wasi,
        ""poll_oneoff(%d, %d, %d, %d)\n"",
        in_ptr,
        out_ptr,
        nsubscriptions,
        nevents_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_subscription_t> in(nsubscriptions);
  std::vector<uvwasi_event_t> out(nsubscriptions);

  for (uint32_t i = 0; i < nsubscriptions; ++i) {
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }

  uvwasi_size_t nevents;
  uvwasi_errno_t err = uvwasi_poll_oneoff(
      &wasi.uvw_, in.data(), out.data(), nsubscriptions, &nevents);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      u...",49,,1092,7,,void
249915,BLOCK,1,,<empty>,,,,3,,void
249917,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,1,,void
249928,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,2,,void
249937,BLOCK,1,,<empty>,,,,3,,void
249939,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,1,,void
249950,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,2,,void
249960,BLOCK,1,,<empty>,,,,4,,void
249962,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,1,,void
249971,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,2,,void
249992,BLOCK,-1,,<empty>,3,,1107,1,,void
250002,BLOCK,4,,"{
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }",49,,1107,4,,void
250039,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }
  }",31,,1115,2,,void
250047,BLOCK,-1,,<empty>,5,,1118,1,,void
250057,BLOCK,4,,"{
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }",51,,1118,4,,void
250078,BLOCK,-1,,"{
  Debug(wasi, ""proc_exit(%d)\n"", code);
  uvwasi_proc_exit(&wasi.uvw_, code);
}",60,,1127,4,,void
250095,BLOCK,-1,,"{
  Debug(wasi, ""proc_raise(%d)\n"", sig);
  return uvwasi_proc_raise(&wasi.uvw_, sig);
}",64,,1132,4,,void
250114,BLOCK,-1,,"{
  Debug(wasi, ""random_get(%d, %d)\n"", buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  return uvwasi_random_get(&wasi.uvw_, &memory.data[buf_ptr], buf_len);
}",44,,1140,5,,void
250126,BLOCK,1,,<empty>,,,,4,,void
250128,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,1,,void
250137,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,2,,void
250159,BLOCK,-1,,"{
  Debug(wasi, ""sched_yield()\n"");
  return uvwasi_sched_yield(&wasi.uvw_);
}",51,,1146,3,,void
250177,BLOCK,-1,,"{
  Debug(wasi, ""sock_accept(%d, %d, %d)\n"", sock, flags, fd_ptr);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_sock_accept(&wasi.uvw_, sock, flags, &fd);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, fd_ptr, fd);

  return err;
}",44,,1155,6,,void
250201,BLOCK,-1,,<empty>,5,,1161,2,,void
250221,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_recv(%d, %d, %d, %d, %d, %d)\n"",
        sock,
        ri_data_ptr,
        ri_data_len,
        ri_flags,
        ro_datalen_ptr,
        ro_flags_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4);
  std::vector<uvwasi_iovec_t> ri_data(ri_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, ri_data_ptr, ri_data.data(), ri_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t ro_datalen;
  uvwasi_roflags_t ro_flags;
  err = uvwasi_sock_recv(&wasi.uvw_,
                         sock,
                         ri_data.data(),
                         ri_data_len,
                         ri_flags,
                         &ro_datalen,
                         &ro_flags);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_wr...",48,,1173,9,,void
250236,BLOCK,1,,<empty>,,,,3,,void
250238,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,1,,void
250249,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,2,,void
250259,BLOCK,1,,<empty>,,,,4,,void
250261,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,1,,void
250270,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,2,,void
250280,BLOCK,1,,<empty>,,,,4,,void
250282,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,1,,void
250291,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,2,,void
250323,BLOCK,-1,,"{
    return err;
  }",31,,1189,2,,void
250350,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, ro_datalen_ptr, ro_datalen);
    uvwasi_serdes_write_roflags_t(memory.data, ro_flags_ptr, ro_flags);
  }",31,,1202,2,,void
250375,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_send(%d, %d, %d, %d, %d)\n"",
        sock,
        si_data_ptr,
        si_data_len,
        si_flags,
        so_datalen_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> si_data(si_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, si_data_ptr, si_data.data(), si_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t so_datalen;
  err = uvwasi_sock_send(
      &wasi.uvw_, sock, si_data.data(), si_data_len, si_flags, &so_datalen);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, so_datalen_ptr, so_datalen);

  return err;
}",50,,1216,8,,void
250389,BLOCK,1,,<empty>,,,,3,,void
250391,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,1,,void
250402,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,2,,void
250412,BLOCK,1,,<empty>,,,,4,,void
250414,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,1,,void
250423,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,2,,void
250455,BLOCK,-1,,"{
    return err;
  }",31,,1231,2,,void
250479,BLOCK,-1,,<empty>,5,,1239,2,,void
250495,BLOCK,-1,,"{
  Debug(wasi, ""sock_shutdown(%d, %d)\n"", sock, how);
  return uvwasi_sock_shutdown(&wasi.uvw_, sock, how);
}",43,,1247,5,,void
250513,BLOCK,-1,,"{
  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  CHECK_EQ(args.Length(), 1);
  if (!args[0]->IsWasmMemoryObject()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }
  wasi->memory_.Reset(wasi->env()->isolate(), args[0].As<WasmMemoryObject>());
}",64,,1252,2,,void
250536,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }",39,,1256,2,,void
250573,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, WASI::New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(WASI::kInternalFieldCount);

#define V(F, name)                                                             \
  SetFunction<decltype(&WASI::F), WASI::F>(WASI::F, env, name, tmpl);

  V(ArgsGet, ""args_get"")
  V(ArgsSizesGet, ""args_sizes_get"")
  V(ClockResGet, ""clock_res_get"")
  V(ClockTimeGet, ""clock_time_get"")
  V(EnvironGet, ""environ_get"")
  V(EnvironSizesGet, ""environ_sizes_get"")
  V(FdAdvise, ""fd_advise"")
  V(FdAllocate, ""fd_allocate"")
  V(FdClose, ""fd_close"")
  V(FdDatasync, ""fd_datasync"")
  V(FdFdstatGet, ""fd_fdstat_get"")
  V(FdFdstatSetFlags, ""fd_fdstat_set_flags"")
  V(FdFdstatSetRights, ""fd_fdstat_set_rights"")
  V(FdFilestatGet, ""fd_filestat_get"")
  V(FdFilestatSetSize, ""fd_filestat_set_size"")
  V(FdFilestatSetTimes, ""fd_filestat_set_times"")
  V(FdPread, ""fd_pr...",44,,1268,5,,void
250612,BLOCK,1,,<empty>,,,,3,,void
250623,BLOCK,1,,<empty>,,,,3,,void
250634,BLOCK,1,,<empty>,,,,3,,void
250645,BLOCK,1,,<empty>,,,,3,,void
250656,BLOCK,1,,<empty>,,,,3,,void
250667,BLOCK,1,,<empty>,,,,3,,void
250678,BLOCK,1,,<empty>,,,,3,,void
250689,BLOCK,1,,<empty>,,,,3,,void
250700,BLOCK,1,,<empty>,,,,3,,void
250711,BLOCK,1,,<empty>,,,,3,,void
250722,BLOCK,1,,<empty>,,,,3,,void
250733,BLOCK,1,,<empty>,,,,3,,void
250744,BLOCK,1,,<empty>,,,,3,,void
250755,BLOCK,1,,<empty>,,,,3,,void
250766,BLOCK,1,,<empty>,,,,3,,void
250777,BLOCK,1,,<empty>,,,,3,,void
250788,BLOCK,1,,<empty>,,,,3,,void
250799,BLOCK,1,,<empty>,,,,3,,void
250810,BLOCK,1,,<empty>,,,,3,,void
250821,BLOCK,1,,<empty>,,,,3,,void
250832,BLOCK,1,,<empty>,,,,3,,void
250843,BLOCK,1,,<empty>,,,,3,,void
250854,BLOCK,1,,<empty>,,,,3,,void
250865,BLOCK,1,,<empty>,,,,3,,void
250876,BLOCK,1,,<empty>,,,,3,,void
250887,BLOCK,1,,<empty>,,,,3,,void
250898,BLOCK,1,,<empty>,,,,3,,void
250909,BLOCK,1,,<empty>,,,,3,,void
250920,BLOCK,1,,<empty>,,,,3,,void
250931,BLOCK,1,,<empty>,,,,3,,void
250942,BLOCK,1,,<empty>,,,,3,,void
250953,BLOCK,1,,<empty>,,,,3,,void
250964,BLOCK,1,,<empty>,,,,3,,void
250975,BLOCK,1,,<empty>,,,,3,,void
250986,BLOCK,1,,<empty>,,,,3,,void
250997,BLOCK,1,,<empty>,,,,3,,void
251008,BLOCK,1,,<empty>,,,,3,,void
251019,BLOCK,1,,<empty>,,,,3,,void
251030,BLOCK,1,,<empty>,,,,3,,void
251041,BLOCK,1,,<empty>,,,,3,,void
251052,BLOCK,1,,<empty>,,,,3,,void
251063,BLOCK,1,,<empty>,,,,3,,void
251074,BLOCK,1,,<empty>,,,,3,,void
251085,BLOCK,1,,<empty>,,,,3,,void
251096,BLOCK,1,,<empty>,,,,3,,void
251107,BLOCK,1,,<empty>,,,,3,,void
251143,BLOCK,-1,,<empty>,1,,1,1,,ANY
251156,BLOCK,-1,,<empty>,1,,1,1,,ANY
251161,BLOCK,-1,,"{
  Local<Function> templ = env->wasm_streaming_object_constructor();
  if (!templ.IsEmpty()) {
    return templ;
  }

  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      WasmStreamingObject::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""setURL"", SetURL);
  SetProtoMethod(isolate, t, ""push"", Push);
  SetProtoMethod(isolate, t, ""finish"", Finish);
  SetProtoMethod(isolate, t, ""abort"", Abort);

  auto function = t->GetFunction(env->context()).ToLocalChecked();
  env->set_wasm_streaming_object_constructor(function);
  return function;
}",67,,23,2,,void
251178,BLOCK,-1,,"{
    return templ;
  }",25,,25,2,,void
251252,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Push);
  registry->Register(Finish);
  registry->Register(Abort);
}",42,,45,2,,void
251277,BLOCK,-1,,"{
  // v8::WasmStreaming is opaque. We assume that the size of the WebAssembly
  // module that is being compiled is roughly what V8 allocates (as in, off by
  // only a small factor).
  tracker->TrackFieldWithSize(""streaming"", wasm_size_);
}",68,,52,2,,void
251289,BLOCK,-1,,"{
  Local<Function> ctor = Initialize(env);
  Local<Object> obj;
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj)) {
    return MaybeLocal<Object>();
  }

  CHECK(streaming);

  WasmStreamingObject* ptr = Unwrap<WasmStreamingObject>(obj);
  CHECK_NOT_NULL(ptr);
  ptr->streaming_ = streaming;
  ptr->wasm_size_ = 0;
  return obj;
}",65,,60,3,,void
251320,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",69,,63,2,,void
251351,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new WasmStreamingObject(env, args.This());
}",72,,76,2,,void
251376,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value url(Environment::GetCurrent(args)->isolate(), args[0]);
  obj->streaming_->SetUrl(url.out(), url.length());
}",75,,82,2,,void
251433,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  Local<Value> chunk = args[0];

  // The start of the memory section backing the ArrayBuffer(View), the offset
  // of the ArrayBuffer(View) within the memory section, and its size in bytes.
  const void* bytes;
  size_t offset;
  size_t size;

  if (LIKELY(chunk->IsArrayBufferView())) {
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  } else if (LIKELY(chunk->IsArrayBuffer())) {
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  } else {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }

  // Forward the data to V8. Internally, V8 will make a copy.
  o...",73,,93,2,,void
251470,BLOCK,-1,,"{
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  }",43,,107,2,,void
251503,BLOCK,-1,,<empty>,10,,112,1,,void
251510,BLOCK,-1,,"{
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  }",46,,112,2,,void
251537,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }",10,,117,1,,void
251570,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 0);
  obj->streaming_->Finish();
}",75,,129,2,,void
251599,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  obj->streaming_->Abort(args[0]);
}",74,,138,2,,void
251631,BLOCK,-1,,"{
  // V8 passes an instance of v8::WasmStreaming to this callback, which we can
  // use to pass the WebAssembly module bytes to V8 as we receive them.
  // Unfortunately, our fetch() implementation is a JavaScript dependency, so it
  // is difficult to implement the required logic here. Instead, we create a
  // a WasmStreamingObject that encapsulates v8::WasmStreaming and that we can
  // pass to the JavaScript implementation. The JavaScript implementation can
  // then push() bytes from the Response and eventually either finish() or
  // abort() the operation.

  // Create the wrapper object.
  std::shared_ptr<WasmStreaming> streaming =
      WasmStreaming::Unpack(info.GetIsolate(), info.Data());
  Environment* env = Environment::GetCurrent(info);
  Local<Object> obj;
  if (!WasmStreamingObject::Create(env, streaming).ToLocal(&obj)) {
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }

  // V8 always passes one argument to this callback.
  CHECK_EQ(in...",73,,147,2,,void
251678,BLOCK,-1,,"{
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }",67,,162,2,,void
251750,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  env->set_wasm_streaming_compilation_impl(info[0].As<Function>());
}",65,,189,2,,void
251776,BLOCK,-1,,"{
  SetMethod(context, target, ""setImplementation"", SetImplementation);
}",24,,197,5,,void
251786,BLOCK,-1,,"{
  registry->Register(SetImplementation);
  registry->Register(StartStreamingCompilation);
  WasmStreamingObject::RegisterExternalReferences(registry);
}",70,,201,2,,void
251813,BLOCK,-1,,<empty>,1,,1,1,,ANY
251817,BLOCK,-1,,"{
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  }",62,,51,2,,void
251838,BLOCK,-1,,"{
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  }",77,,172,2,,void
251865,BLOCK,-1,,"{
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      }",44,,189,3,,void
251880,BLOCK,-1,,"{
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }",54,,191,2,,void
251913,BLOCK,-1,,<empty>,1,,1,1,,ANY
251919,BLOCK,-1,,"{

  int rc;
  rc = uv_loop_init(&loop_);
  if (rc != 0) {
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }

  rc = uv_async_init(&loop_, &async_, [](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  });

  CHECK_EQ(0, rc);

  rc = uv_timer_init(&loop_, &timer_);
  CHECK_EQ(0, rc);

  rc = uv_timer_start(&timer_, &Watchdog::Timer, ms, 0);
  CHECK_EQ(0, rc);

  rc = uv_thread_create(&thread_, &Watchdog::Run, this);
  CHECK_EQ(0, rc);
}",48,,43,4,,void
251930,BLOCK,-1,,"{
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }",16,,47,2,,void
251985,BLOCK,-1,,"{
  uv_async_send(&async_);
  uv_thread_join(&thread_);

  uv_close(reinterpret_cast<uv_handle_t*>(&async_), nullptr);

  // UV_RUN_DEFAULT so that libuv has a chance to clean up.
  uv_run(&loop_, UV_RUN_DEFAULT);

  CheckedUvLoopClose(&loop_);
}",23,,69,1,,void
252003,BLOCK,-1,,"{
  Watchdog* wd = static_cast<Watchdog*>(arg);

  // UV_RUN_DEFAULT the loop will be stopped either by the async or the
  // timer handle.
  uv_run(&wd->loop_, UV_RUN_DEFAULT);

  // Loop ref count reaches zero when both handles are closed.
  // Close the timer handle on this side and let ~Watchdog() close async_
  uv_close(reinterpret_cast<uv_handle_t*>(&wd->timer_), nullptr);
}",31,,82,2,,void
252028,BLOCK,-1,,"{
  Watchdog* w = ContainerOf(&Watchdog::timer_, timer);
  *w->timed_out_ = true;
  w->isolate()->TerminateExecution();
  uv_stop(&w->loop_);
}",41,,94,2,,void
252061,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(this);
  // Start the helper thread, if that has not already happened.
  SigintWatchdogHelper::GetInstance()->Start();
}",60,,104,3,,void
252086,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
}",35,,113,1,,void
252111,BLOCK,-1,,"{
  *received_signal_ = true;
  isolate_->TerminateExecution();
  return SignalPropagation::kStopPropagation;
}",50,,119,1,,void
252129,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
  constructor->InstanceTemplate()->SetInternalFieldCount(
      TraceSigintWatchdog::kInternalFieldCount);
  constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, constructor, ""start"", Start);
  SetProtoMethod(isolate, constructor, ""stop"", Stop);

  SetConstructorFunction(
      env->context(), target, ""TraceSigintWatchdog"", constructor);
}",72,,125,3,,void
252187,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new TraceSigintWatchdog(env, args.This());
}",72,,139,2,,void
252212,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(watchdog);
  // Start the helper thread, if that has not already happened.
  int r = SigintWatchdogHelper::GetInstance()->Start();
  CHECK_EQ(r, 0);
}",74,,148,2,,void
252252,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
  SigintWatchdogHelper::GetInstance()->Stop();
}",73,,159,2,,void
252287,BLOCK,-1,,"{
  int r = uv_async_init(env->event_loop(), &handle_, [](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  });
  CHECK_EQ(r, 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&handle_));
}",54,,171,3,,void
252310,BLOCK,-1,,"{
  /**
   * In case of uv loop polling, i.e. no JS currently running, activate the
   * loop to run a piece of JS code to trigger interruption.
   */
  CHECK_EQ(uv_async_send(&handle_), 0);
  env()->isolate()->RequestInterrupt(
      [](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      },
      this);
  return SignalPropagation::kContinuePropagation;
}",55,,182,1,,void
252332,BLOCK,-1,,"{
  // Do not nest interrupts.
  if (interrupting) {
    return;
  }
  interrupting = true;
  if (signal_flag_ == SignalFlags::None) {
    return;
  }
  Environment* env_ = env();
  // FIXME: Before
  // https://github.com/nodejs/node/pull/29207#issuecomment-527667993 get
  // fixed, additional JavaScript code evaluation shall be prevented from
  // running during interruption.
  FPrintF(stderr,
      ""KEYBOARD_INTERRUPT: Script execution was interrupted by `SIGINT`\n"");
  if (signal_flag_ == SignalFlags::FromInterrupt) {
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }
  signal_flag_ = SignalFlags::None;
  interrupting = false;

  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
  raise(SIGINT);
}",45,,200,1,,void
252335,BLOCK,-1,,"{
    return;
  }",21,,202,2,,void
252346,BLOCK,-1,,"{
    return;
  }",42,,206,2,,void
252361,BLOCK,-1,,"{
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }",51,,216,2,,void
252418,BLOCK,-1,,"{
  if (!instance.watchdog_disabled_ &&
      (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT)) {
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  } else {
    return FALSE;
  }
}",76,,253,2,,void
252432,BLOCK,-1,,"{
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  }",71,,255,2,,void
252437,BLOCK,-1,,"{
    return FALSE;
  }",10,,260,1,,void
252443,BLOCK,-1,,"{
  Mutex::ScopedLock list_lock(instance.list_mutex_);

  bool is_stopping = false;
#ifdef __POSIX__
  is_stopping = instance.stopping_;
#endif

  // If there are no listeners and the helper thread has been awoken by a signal
  // (= not when stopping it), indicate that by setting has_pending_signal_.
  if (instance.watchdogs_.empty() && !is_stopping) {
    instance.has_pending_signal_ = true;
  }

  for (auto it = instance.watchdogs_.rbegin(); it != instance.watchdogs_.rend();
       it++) {
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }

  return is_stopping;
}",57,,267,1,,void
252463,BLOCK,-1,,"{
    instance.has_pending_signal_ = true;
  }",52,,277,2,,void
252470,BLOCK,-1,,<empty>,3,,281,1,,void
252490,BLOCK,4,,"{
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }",14,,282,4,,void
252505,BLOCK,-1,,"{
      break;
    }",52,,284,2,,void
252512,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  if (start_stop_count_++ > 0) {
    return 0;
  }

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  has_pending_signal_ = false;
  stopping_ = false;

  sigset_t sigmask;
  sigfillset(&sigmask);
  sigset_t savemask;
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, &savemask));
  sigmask = savemask;
  int ret = pthread_create(&thread_, nullptr, RunSigintWatchdog, nullptr);
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, nullptr));
  if (ret != 0) {
    return ret;
  }
  has_running_thread_ = true;

  RegisterSignalHandler(SIGINT, HandleSignal);
#else
  if (watchdog_disabled_) {
    watchdog_disabled_ = false;
  } else {
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }
#endif

  return 0;
}",35,,293,1,,void
252521,BLOCK,-1,,"{
    return 0;
  }",32,,296,2,,void
252526,BLOCK,-1,,"{
    watchdog_disabled_ = false;
  }",27,,319,2,,void
252531,BLOCK,-1,,"{
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }",10,,321,1,,void
252540,BLOCK,-1,,"{
  bool had_pending_signal;
  Mutex::ScopedLock lock(mutex_);

  {
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }

#ifdef __POSIX__
  if (!has_running_thread_) {
    has_pending_signal_ = false;
    return had_pending_signal;
  }

  // Wake up the helper thread.
  uv_sem_post(&sem_);

  // Wait for the helper thread to finish.
  CHECK_EQ(0, pthread_join(thread_, nullptr));
  has_running_thread_ = false;

  RegisterSignalHandler(SIGINT, SignalExit, true);
#else
  watchdog_disabled_ = true;
#endif

  had_pending_signal = has_pending_signal_;
  has_pending_signal_ = false;

  return had_pending_signal;
}",35,,330,1,,void
252545,BLOCK,4,,"{
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }",3,,334,4,,void
252557,BLOCK,-1,,"{
      has_pending_signal_ = false;
      return had_pending_signal;
    }",34,,339,2,,void
252581,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  return has_pending_signal_;
}",47,,377,1,,void
252591,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  watchdogs_.push_back(wd);
}",61,,383,2,,void
252604,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  auto it = std::find(watchdogs_.begin(), watchdogs_.end(), wd);

  CHECK_NE(it, watchdogs_.end());
  watchdogs_.erase(it);
}",63,,389,2,,void
252638,BLOCK,-1,,"{
#ifdef __POSIX__
  has_running_thread_ = false;
  stopping_ = false;
  CHECK_EQ(0, uv_sem_init(&sem_, 0));
#else
  watchdog_disabled_ = false;
#endif
}",34,,401,1,,void
252645,BLOCK,-1,,"{
  start_stop_count_ = 0;
  Stop();

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  uv_sem_destroy(&sem_);
#endif
}",47,,412,1,,void
252660,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  TraceSigintWatchdog::Init(env, target);
}",36,,429,5,,void
252696,BLOCK,-1,,<empty>,1,,1,1,,ANY
252700,BLOCK,-1,,"{
        *static_cast<bool*>(data) = true;
      }",73,,221,2,,void
252712,BLOCK,-1,,"{
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    }",43,,297,1,,void
252720,BLOCK,-1,,<empty>,18,,303,2,,void
252727,BLOCK,4,,"{
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }",7,,306,4,,void
252750,BLOCK,-1,,"{
          Exit(static_cast<ExitCode>(exit_code));
        }",79,,366,3,,void
252760,BLOCK,-1,,"{
      return env_vars->Get(name).FromMaybe("""");
    }",79,,528,2,,void
252777,BLOCK,-1,,"{
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        }",60,,686,2,,void
252782,BLOCK,-1,,<empty>,13,,688,2,,void
252799,BLOCK,-1,,"{
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    Worker* w = static_cast<Worker*>(arg);
    const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg);

    // Leave a few kilobytes just to make sure we're within limits and have
    // some space to do work in C++ land.
    w->stack_base_ = stack_top - (w->stack_size_ - kStackBufferSize);

    w->Run();

    Mutex::ScopedLock lock(w->mutex_);
    w->env()->SetImmediateThreadsafe(
        [w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        });
  }",69,,671,2,,void
252845,BLOCK,-1,,"{
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        }",68,,837,2,,void
252909,BLOCK,-1,,"{
    heap::HeapSnapshotPointer snapshot{
        worker_env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
    CHECK(snapshot);

    // Here, the worker thread temporarily owns the WorkerHeapSnapshotTaker
    // object.

    env->SetImmediateThreadsafe(
        [taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        },
        CallbackFlags::kUnrefed);

    // Now, the lambda is delivered to the main thread, as a result, the
    // Worke...",77,,827,2,,void
252972,BLOCK,-1,,<empty>,1,,1,1,,ANY
252990,BLOCK,-1,,"{
  Debug(this, ""Creating new worker instance with thread id %llu"",
        thread_id_.id);

  // Set up everything that needs to be set up in the parent environment.
  MessagePort* parent_port = MessagePort::New(env, env->context());
  if (parent_port == nullptr) {
    // This can happen e.g. because execution is terminating.
    return;
  }

  child_port_data_ = std::make_unique<MessagePortData>(nullptr);
  MessagePort::Entangle(parent_port, child_port_data_.get());

  object()
      ->Set(env->context(), env->message_port_string(), parent_port->object())
      .Check();

  object()->Set(env->context(),
                env->thread_id_string(),
                Number::New(env->isolate(), static_cast<double>(thread_id_.id)))
      .Check();

  // Without this check, to use the permission model with
  // workers (--allow-worker) one would need to pass --allow-inspector as well
  if (env->permission()->is_granted(
          node::permission::PermissionScope::kInspector)) {
    inspect...",37,,65,9,,void
253013,BLOCK,-1,,"{
    // This can happen e.g. because execution is terminating.
    return;
  }",31,,71,2,,void
253095,BLOCK,-1,,"{
    inspector_parent_handle_ =
        GetInspectorParentHandle(env, thread_id_, url.c_str(), name.c_str());
  }",59,,91,2,,void
253129,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (env_ != nullptr)
    return env_->is_stopping();
  return stopped_;
}",33,,103,1,,void
253137,BLOCK,-1,,<empty>,5,,106,2,,void
253149,BLOCK,-1,,"{
  constraints->set_stack_limit(reinterpret_cast<uint32_t*>(stack_base_));

  if (resource_limits_[kMaxYoungGenerationSizeMb] > 0) {
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kMaxOldGenerationSizeMb] > 0) {
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kCodeRangeSizeMb] > 0) {
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  } else {
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }
}",74,,110,2,,void
253163,BLOCK,-1,,"{
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  }",56,,113,2,,void
253176,BLOCK,-1,,"{
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }",10,,116,1,,void
253193,BLOCK,-1,,"{
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  }",54,,121,2,,void
253206,BLOCK,-1,,"{
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }",10,,124,1,,void
253223,BLOCK,-1,,"{
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  }",47,,129,2,,void
253236,BLOCK,-1,,"{
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }",10,,132,1,,void
253251,BLOCK,-1,,"{
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Is...",13,,144,2,,void
253262,BLOCK,-1,,"{
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }",19,,146,2,,void
253329,BLOCK,-1,,"{
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Isolate"");
      return;
    }",29,,164,2,,void
253350,BLOCK,17,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);
      // V8 computes its stack limit the first time a `Locker` is used based on
      // --stack-size. Reset it to the correct value.
      isolate->SetStackLimit(w->stack_base_);

      HandleScope handle_scope(isolate);
      isolate_data_.reset(
          CreateIsolateData(isolate,
                            &loop_,
                            w_->platform_,
                            allocator.get(),
                            w->snapshot_data()->AsEmbedderWrapper().get()));
      CHECK(isolate_data_);
      CHECK(!isolate_data_->is_building_snapshot());
      if (w_->per_isolate_opts_)
        isolate_data_->set_options(std::move(w_->per_isolate_opts_));
      isolate_data_->set_worker_context(w_);
      isolate_data_->max_young_gen_size =
          params.constraints.max_young_generation_size_in_bytes();
    }",5,,179,17,,void
253404,BLOCK,-1,,<empty>,9,,196,2,,void
253444,BLOCK,-1,,"{
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_r...",23,,206,1,,void
253454,BLOCK,3,,"{
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }",5,,209,3,,void
253474,BLOCK,-1,,"{
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_run(&loop_, UV_RUN_ONCE);
      }
    }",29,,215,2,,void
253510,BLOCK,-1,,"{
        uv_run(&loop_, UV_RUN_ONCE);
      }",34,,234,2,,void
253518,BLOCK,-1,,"{
      CheckedUvLoopClose(&loop_);
    }",29,,238,2,,void
253525,BLOCK,-1,,{ return !loop_init_failed_; },31,,243,1,,void
253538,BLOCK,-1,,<empty>,,,,1,,<empty>
253551,BLOCK,-1,,"{
  Worker* worker = static_cast<Worker*>(data);
  // Give the current GC some extra leeway to let it finish rather than
  // crash hard. We are not going to perform further allocations anyway.
  constexpr size_t kExtraHeapAllowance = 16 * 1024 * 1024;
  size_t new_limit = current_heap_limit + kExtraHeapAllowance;
  Environment* env = worker->env();
  if (env != nullptr) {
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }
  // TODO(joyeecheung): maybe this should be kV8FatalError instead?
  worker->Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_OUT_OF_MEMORY"",
               ""JS heap out of memory"");
  return new_limit;
}",57,,255,4,,void
253583,BLOCK,-1,,"{
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }",23,,262,2,,void
253605,BLOCK,-1,,"{
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      i...",20,,277,1,,void
253652,BLOCK,-1,,<empty>,28,,287,2,,void
253665,BLOCK,11,,"{
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    });

    if (is_stopped()) return;
    {
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need so...",3,,291,11,,void
253689,BLOCK,-1,,<empty>,23,,315,2,,void
253691,BLOCK,11,,"{
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds cont...",5,,316,11,,void
253700,BLOCK,4,,"{
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
 ...",7,,319,4,,void
253708,BLOCK,-1,,"{
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        }",40,,325,2,,void
253746,BLOCK,-1,,"{
            context = Local<Context>();
          }",60,,334,2,,void
253751,BLOCK,-1,,"{
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
        }",16,,337,1,,void
253767,BLOCK,-1,,"{
          // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
          Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_INIT_FAILED"",
               ""Failed to create new Context"");
          return;
        }",32,,342,2,,void
253777,BLOCK,-1,,<empty>,25,,351,2,,void
253788,BLOCK,9,,"{
        env_.reset(CreateEnvironment(
            data.isolate_data_.get(),
            context,
            std::move(argv_),
            std::move(exec_argv_),
            static_cast<EnvironmentFlags::Flags>(environment_flags_),
            thread_id_,
            std::move(inspector_parent_handle_)));
        if (is_stopped()) return;
        CHECK_NOT_NULL(env_);
        env_->set_env_vars(std::move(env_vars_));
        SetProcessExitHandler(env_.get(), [this](Environment*, int exit_code) {
          Exit(static_cast<ExitCode>(exit_code));
        });
      }",7,,354,9,,void
253822,BLOCK,-1,,<empty>,27,,363,2,,void
253840,BLOCK,10,,"{
        Mutex::ScopedLock lock(mutex_);
        if (stopped_) return;
        this->env_ = env_.get();
      }",7,,370,10,,void
253846,BLOCK,-1,,<empty>,23,,372,2,,void
253864,BLOCK,-1,,<empty>,25,,376,2,,void
253866,BLOCK,13,,"{
        if (!CreateEnvMessagePort(env_.get())) {
          return;
        }

        Debug(this, ""Created message port for worker %llu"", thread_id_.id);
        if (LoadEnvironment(env_.get(), StartExecutionCallback{}).IsEmpty())
          return;

        Debug(this, ""Loaded environment for worker %llu"", thread_id_.id);
      }",7,,377,13,,void
253874,BLOCK,-1,,"{
          return;
        }",48,,378,2,,void
253893,BLOCK,-1,,<empty>,11,,384,2,,void
253901,BLOCK,12,,"{
      Maybe<ExitCode> exit_code = SpinEventLoopInternal(env_.get());
      Mutex::ScopedLock lock(mutex_);
      if (exit_code_ == ExitCode::kNoFailure && exit_code.IsJust()) {
        exit_code_ = exit_code.FromJust();
      }

      Debug(this,
            ""Exiting thread for worker %llu with exit code %d"",
            thread_id_.id,
            static_cast<int>(exit_code_));
    }",5,,390,12,,void
253927,BLOCK,-1,,"{
        exit_code_ = exit_code.FromJust();
      }",69,,393,2,,void
253953,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  std::unique_ptr<MessagePortData> data;
  {
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }

  // Set up the message channel for receiving messages in the child.
  MessagePort* child_port = MessagePort::New(env,
                                             env->context(),
                                             std::move(data));
  // MessagePort::New() may return nullptr if execution is terminated
  // within it.
  if (child_port != nullptr)
    env->set_message_port(child_port->object(isolate_));

  return child_port;
}",53,,407,2,,void
253964,BLOCK,4,,"{
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }",3,,410,4,,void
253996,BLOCK,-1,,<empty>,5,,422,2,,void
254011,BLOCK,-1,,"{
  if (!tid_.has_value())
    return;
  CHECK_EQ(uv_thread_join(&tid_.value()), 0);
  tid_.reset();

  env()->remove_sub_worker_context(this);

  {
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }

  // If we get here, the...",27,,427,1,,void
254018,BLOCK,-1,,<empty>,5,,429,2,,void
254037,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }",3,,435,5,,void
254143,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  CHECK(stopped_);
  CHECK_NULL(env_);
  CHECK(!tid_.has_value());

  Debug(this, ""Worker %llu destroyed"", thread_id_.id);
}",19,,464,1,,void
254165,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  auto is_internal = args[5];
  CHECK(is_internal->IsBoolean());
  if (is_internal->IsFalse()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }
  Isolate* isolate = args.GetIsolate();

  CHECK(args.IsConstructCall());

  if (env->isolate_data()->platform() == nullptr) {
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }
  CHECK(!env->isolate_data()->is_building_snapshot());

  std::string url;
  std::string name;
  std::shared_ptr<PerIsolateOptions> per_isolate_opts = nullptr;
  std::shared_ptr<KVStore> env_vars = nullptr;

  std::vector<std::string> exec_argv_out;

  // Argument might be a string or URL
  if (!args[0]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }

  if (!args[6]->IsNullOrUndefined()) {
    Utf8Value value(
        i...",59,,474,2,,void
254190,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }",31,,478,2,,void
254221,BLOCK,-1,,"{
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }",51,,486,2,,void
254270,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }",38,,500,2,,void
254308,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[6]->ToString(env->context()).FromMaybe(Local<String>()));
    name.append(value.out(), value.length());
  }",38,,506,2,,void
254345,BLOCK,-1,,"{
    // Means worker.env = { ...process.env }.
    env_vars = env->env_vars()->Clone(isolate);
  }",26,,512,2,,void
254357,BLOCK,-1,,<empty>,10,,515,1,,void
254365,BLOCK,-1,,"{
    // User provided env.
    env_vars = KVStore::CreateMapKVStore();
    env_vars->AssignFromObject(isolate->GetCurrentContext(),
                               args[1].As<Object>());
  }",35,,515,2,,void
254387,BLOCK,-1,,"{
    // Env is shared.
    env_vars = env->env_vars();
  }",10,,520,1,,void
254408,BLOCK,-1,,"{
    per_isolate_opts.reset(new PerIsolateOptions());

    HandleEnvOptions(per_isolate_opts->per_env, [&env_vars](const char* name) {
      return env_vars->Get(name).FromMaybe("""");
    });

#ifndef NODE_WITHOUT_NODE_OPTIONS
    MaybeLocal<String> maybe_node_opts =
        env_vars->Get(isolate, OneByteString(isolate, ""NODE_OPTIONS""));
    Local<String> node_opts;
    if (maybe_node_opts.ToLocal(&node_opts)) {
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInE...",50,,525,2,,void
254446,BLOCK,-1,,"{
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInEnvvar,
                            &errors);
      if (!errors.empty() && args[1]->IsObject()) {
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRIN...",46,,536,2,,void
254528,BLOCK,-1,,"{
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidNodeOptions"");
        // Ignore the return value of Set() because exceptions bubble up to JS
        // when we return anyway.
        USE(args.This()->Set(env->context(), key, error));
        return;
      }",51,,550,2,,void
254547,BLOCK,-1,,<empty>,65,,554,2,,void
254583,BLOCK,-1,,"{
    Local<Array> array = args[2].As<Array>();
    // The first argument is reserved for program name, but we don't need it
    // in workers.
    std::vector<std::string> exec_argv = {""""};
    uint32_t length = array->Length();
    for (uint32_t i = 0; i < length; i++) {
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }

    std::vector<std::string> invalid_args{};
    std::vector<std::string> errors{};
    // Using invalid_args as the v8_args argument as it stores unknown
    // options for the per isolate parser.
    options_parser::Parse(&exec_argv,
                          &exec_argv_out,
                          &invalid_args,
   ...",27,,566,2,,void
254614,BLOCK,-1,,<empty>,5,,572,1,,void
254624,BLOCK,4,,"{
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }",43,,572,4,,void
254646,BLOCK,-1,,"{
        return;
      }",57,,574,2,,void
254668,BLOCK,-1,,"{
        return;
      }",60,,578,2,,void
254751,BLOCK,-1,,"{
      Local<Value> error;
      if (!ToV8Value(env->context(),
                     errors.size() > 0 ? errors : invalid_args)
                         .ToLocal(&error)) {
        return;
      }
      Local<String> key =
          FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidExecArgv"");
      // Ignore the return value of Set() because exceptions bubble up to JS
      // when we return anyway.
      USE(args.This()->Set(env->context(), key, error));
      return;
    }",55,,599,2,,void
254778,BLOCK,-1,,"{
        return;
      }",44,,603,2,,void
254808,BLOCK,-1,,"{
    exec_argv_out = env->exec_argv();
  }",10,,613,1,,void
254900,BLOCK,-1,,<empty>,5,,636,2,,void
254913,BLOCK,-1,,<empty>,5,,638,2,,void
254926,BLOCK,-1,,<empty>,5,,640,2,,void
254939,BLOCK,-1,,<empty>,5,,642,2,,void
254952,BLOCK,-1,,<empty>,5,,644,2,,void
254964,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  Mutex::ScopedLock lock(w->mutex_);

  w->stopped_ = false;

  if (w->resource_limits_[kStackSizeMb] > 0) {
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  } else {
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }

  uv_thread_options_t thread_options;
  thread_options.flags = UV_THREAD_HAS_STACK_SIZE;
  thread_options.stack_size = w->stack_size_;

  uv_thread_t* tid = &w->tid_.emplace();  // Create uv_thread_t instance
  int ret = uv_thread_create_ex(tid, &thread_options, [](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    ...",67,,647,2,,void
254991,BLOCK,-1,,"{
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  }",46,,654,2,,void
255002,BLOCK,-1,,"{
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    }",69,,655,2,,void
255018,BLOCK,-1,,"{
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }",12,,658,1,,void
255033,BLOCK,-1,,"{
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }",10,,662,1,,void
255083,BLOCK,-1,,"{
    // The object now owns the created thread and should not be garbage
    // collected until that finishes.
    w->ClearWeak();

    if (w->has_ref_)
      w->env()->add_refs(1);

    w->env()->add_sub_worker_context(w);
  }",17,,694,2,,void
255092,BLOCK,-1,,<empty>,7,,700,2,,void
255110,BLOCK,-1,,"{
    w->stopped_ = true;
    w->tid_.reset();

    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    {
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }
  }",10,,703,1,,void
255128,BLOCK,5,,"{
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }",5,,709,5,,void
255149,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Debug(w, ""Worker %llu is getting stopped by parent"", w->thread_id_.id);
  w->Exit(ExitCode::kGenericUserError);
}",66,,717,2,,void
255177,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (!w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }
}",59,,725,2,,void
255198,BLOCK,-1,,"{
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }",44,,728,2,,void
255216,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->has_ref_);
}",62,,734,2,,void
255239,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }
}",61,,740,2,,void
255259,BLOCK,-1,,"{
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }",43,,743,2,,void
255278,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->GetResourceLimits(args.GetIsolate()));
}",73,,749,2,,void
255306,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, sizeof(resource_limits_));

  memcpy(ab->Data(), resource_limits_, sizeof(resource_limits_));
  return Float64Array::New(ab, 0, kTotalResourceLimitCount);
}",71,,755,2,,void
255342,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Debug(this,
        ""Worker %llu called Exit(%d, %s, %s)"",
        thread_id_.id,
        static_cast<int>(code),
        error_code,
        error_message);

  if (error_code != nullptr) {
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }

  if (env_ != nullptr) {
    exit_code_ = code;
    Stop(env_);
  } else {
    stopped_ = true;
  }
}",46,,764,4,,void
255361,BLOCK,-1,,"{
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }",30,,773,2,,void
255372,BLOCK,-1,,"{
    exit_code_ = code;
    Stop(env_);
  }",24,,778,2,,void
255378,BLOCK,-1,,"{
    stopped_ = true;
  }",10,,781,1,,void
255385,BLOCK,-1,,"{
  // Worker objects always stay alive as long as the child thread, regardless
  // of whether they are being referenced in the parent thread.
  return true;
}",56,,786,1,,void
255394,BLOCK,-1,,<empty>,67,,795,3,,void
255400,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  CHECK_EQ(args.Length(), 1);
  auto options = heap::GetHeapSnapshotOptions(args[0]);

  Debug(w, ""Worker %llu taking heap snapshot"", w->thread_id_.id);

  Environment* env = w->env();
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(w);
  Local<Object> wrap;
  if (!env->worker_heap_snapshot_taker_template()
      ->NewInstance(env->context()).ToLocal(&wrap)) {
    return;
  }

  // The created WorkerHeapSnapshotTaker is an object owned by main
  // thread's Isolate, it can not be accessed by worker thread
  std::unique_ptr<BaseObjectPtr<WorkerHeapSnapshotTaker>> taker =
      std::make_unique<BaseObjectPtr<WorkerHeapSnapshotTaker>>(
          MakeDetachedBaseObject<WorkerHeapSnapshotTaker>(env, wrap));

  // Interrupt the worker thread and take a snapshot, then schedule a call
  // on the parent thread that turns that snapshot into a readable stream.
  bool scheduled = w->RequestInterrupt([taker = std::move(taker),...",72,,802,2,,void
255464,BLOCK,-1,,"{
    return;
  }",53,,814,2,,void
255502,BLOCK,-1,,"{
    args.GetReturnValue().Set(wrap);
  }",18,,855,2,,void
255512,BLOCK,-1,,"{
    args.GetReturnValue().Set(Local<Object>());
  }",10,,857,1,,void
255525,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  uint64_t idle_time = uv_metrics_idle_time(w->env_->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",68,,862,2,,void
255549,BLOCK,-1,,<empty>,5,,871,2,,void
255586,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  double loop_start_time = w->env_->performance_state()->milestones[
      node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START];
  CHECK_GE(loop_start_time, 0);
  args.GetReturnValue().Set(loop_start_time / 1e6);
}",69,,877,2,,void
255610,BLOCK,-1,,<empty>,5,,886,2,,void
255656,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> port = env->message_port();
  CHECK_IMPLIES(!env->is_main_thread(), !port.IsEmpty());
  if (!port.IsEmpty()) {
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }
}",65,,898,2,,void
255692,BLOCK,-1,,"{
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }",24,,902,2,,void
255721,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  {
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, target, ""Worker"", w);
  }

  {
    Local<FunctionTemplate> wst = NewFunctionT...",69,,910,3,,void
255729,BLOCK,3,,"{
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, target, ""Worker"", w);
  }",3,,913,3,,void
255828,BLOCK,4,,"{
    Local<FunctionTemplate> wst = NewFunctionTemplate(isolate, nullptr);

    wst->InstanceTemplate()->SetInternalFieldCount(
        WorkerHeapSnapshotTaker::kInternalFieldCount);
    wst->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    Local<String> wst_string =
        FIXED_ONE_BYTE_STRING(isolate, ""WorkerHeapSnapshotTaker"");
    wst->SetClassName(wst_string);
    isolate_data->set_worker_heap_snapshot_taker_template(
        wst->InstanceTemplate());
  }",3,,933,4,,void
255891,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  target
      ->Set(env->context(),
            env->thread_id_string(),
            Number::New(isolate, static_cast<double>(env->thread_id())))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""isMainThread""),
            Boolean::New(isolate, env->is_main_thread()))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""ownsProcessState""),
            Boolean::New(isolate, env->owns_process_state()))
      .Check();

  if (!env->is_main_thread()) {
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }

  NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kCodeRangeSize...",51,,953,5,,void
255985,BLOCK,-1,,"{
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }",31,,975,2,,void
256013,BLOCK,1,,<empty>,,,,7,,void
256015,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb)",3,,983,1,,void
256112,BLOCK,1,,<empty>,,,,7,,void
256114,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb)",3,,984,1,,void
256211,BLOCK,1,,<empty>,,,,7,,void
256213,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb)",3,,985,1,,void
256310,BLOCK,1,,<empty>,,,,7,,void
256312,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kStackSizeMb)",3,,986,1,,void
256409,BLOCK,1,,<empty>,,,,7,,void
256411,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount)",3,,987,1,,void
256507,BLOCK,-1,,"{
  registry->Register(GetEnvMessagePort);
  registry->Register(Worker::New);
  registry->Register(Worker::StartThread);
  registry->Register(Worker::StopThread);
  registry->Register(Worker::HasRef);
  registry->Register(Worker::Ref);
  registry->Register(Worker::Unref);
  registry->Register(Worker::GetResourceLimits);
  registry->Register(Worker::TakeHeapSnapshot);
  registry->Register(Worker::LoopIdleTime);
  registry->Register(Worker::LoopStartTime);
}",70,,990,2,,void
256600,BLOCK,-1,,<empty>,1,,1,1,,ANY
256603,BLOCK,-1,,{ Unref(); },46,,405,1,,void
256646,BLOCK,-1,,<empty>,1,,1,1,,ANY
256651,BLOCK,-1,,"{
#define V(code) if (err == code) return #code;
  ZLIB_ERROR_CODES(V)
#undef V
  return ""Z_UNKNOWN_ERROR"";
}",42,,90,2,,void
256653,BLOCK,1,,<empty>,,,,1,,void
256658,BLOCK,-1,,<empty>,3,,92,2,,void
256665,BLOCK,-1,,<empty>,3,,92,2,,void
256672,BLOCK,-1,,<empty>,3,,92,2,,void
256679,BLOCK,-1,,<empty>,3,,92,2,,void
256686,BLOCK,-1,,<empty>,3,,92,2,,void
256693,BLOCK,-1,,<empty>,3,,92,2,,void
256700,BLOCK,-1,,<empty>,3,,92,2,,void
256707,BLOCK,-1,,<empty>,3,,92,2,,void
256714,BLOCK,-1,,<empty>,3,,92,2,,void
256745,BLOCK,-1,,"{
    CHECK_NOT_NULL(message);
  }",18,,117,4,,void
256751,BLOCK,-1,,<empty>,,,,1,,<empty>
256758,BLOCK,-1,,{ return code != nullptr; },31,,127,1,,void
256766,BLOCK,-1,,<empty>,,,,1,,<empty>
256780,BLOCK,-1,,<empty>,,,,1,,<empty>
256784,BLOCK,-1,,<empty>,,,,1,,<empty>
256788,BLOCK,-1,,<empty>,,,,1,,<empty>
256796,BLOCK,-1,,<empty>,,,,5,,<empty>
256801,BLOCK,-1,,<empty>,,,,2,,<empty>
256807,BLOCK,-1,,<empty>,,,,3,,<empty>
256811,BLOCK,-1,,<empty>,,,,1,,<empty>
256816,BLOCK,-1,,{ mode_ = mode; },44,,141,2,,void
256823,BLOCK,-1,,<empty>,,,,1,,<empty>
256832,BLOCK,-1,,<empty>,,,,6,,<empty>
256839,BLOCK,-1,,<empty>,,,,4,,<empty>
256845,BLOCK,-1,,<empty>,,,,3,,<empty>
256854,BLOCK,-1,,"{
    tracker->TrackField(""dictionary"", dictionary_);
  }",58,,153,2,,void
256865,BLOCK,-1,,<empty>,,,,2,,<empty>
256870,BLOCK,-1,,<empty>,,,,2,,<empty>
256875,BLOCK,-1,,<empty>,,,,2,,<empty>
256879,BLOCK,-1,,<empty>,,,,1,,<empty>
256883,BLOCK,-1,,<empty>,,,,1,,<empty>
256899,BLOCK,-1,,<empty>,,,,1,,<empty>
256931,BLOCK,-1,,<empty>,,,,1,,<empty>
256939,BLOCK,-1,,<empty>,,,,5,,<empty>
256944,BLOCK,-1,,<empty>,,,,2,,<empty>
256950,BLOCK,-1,,<empty>,,,,3,,<empty>
256955,BLOCK,-1,,{ mode_ = mode; },44,,189,2,,void
256963,BLOCK,-1,,<empty>,,,,2,,<empty>
256968,BLOCK,-1,,<empty>,,,,2,,<empty>
256981,BLOCK,-1,,<empty>,,,,1,,<empty>
257013,BLOCK,-1,,<empty>,,,,1,,<empty>
257017,BLOCK,-1,,<empty>,,,,1,,<empty>
257024,BLOCK,-1,,<empty>,,,,4,,<empty>
257028,BLOCK,-1,,<empty>,,,,1,,<empty>
257034,BLOCK,-1,,<empty>,,,,3,,<empty>
257038,BLOCK,-1,,<empty>,,,,1,,<empty>
257049,BLOCK,-1,,<empty>,,,,1,,<empty>
257053,BLOCK,-1,,<empty>,,,,1,,<empty>
257060,BLOCK,-1,,<empty>,,,,4,,<empty>
257064,BLOCK,-1,,<empty>,,,,1,,<empty>
257070,BLOCK,-1,,<empty>,,,,3,,<empty>
257074,BLOCK,-1,,<empty>,,,,1,,<empty>
257086,BLOCK,-1,,<empty>,,,,1,,<empty>
257097,BLOCK,-1,,<empty>,,,,1,,<empty>
257108,BLOCK,-1,,"{
    MakeWeak();
  }",32,,263,3,,void
257113,BLOCK,-1,,"{
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",33,,267,1,,void
257127,BLOCK,-1,,"{
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",16,,274,1,,void
257130,BLOCK,-1,,"{
      pending_close_ = true;
      return;
    }",29,,275,2,,void
257156,BLOCK,-1,,"{
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }",62,,289,2,,void
257173,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    CHECK_EQ(args.Length(), 7);

    uint32_t in_off, in_len, out_off, out_len, flush;
    const char* in;
    char* out;

    CHECK_EQ(false, args[0]->IsUndefined() && ""must provide flush value"");
    if (!args[0]->Uint32Value(context).To(&flush)) return;

    if (flush != Z_NO_FLUSH &&
        flush != Z_PARTIAL_FLUSH &&
        flush != Z_SYNC_FLUSH &&
        flush != Z_FULL_FLUSH &&
        flush != Z_FINISH &&
        flush != Z_BLOCK) {
      UNREACHABLE(""Invalid flush value"");
    }

    if (args[1]->IsNull()) {
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    } else {
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::L...",62,,298,2,,void
257229,BLOCK,-1,,<empty>,52,,308,2,,void
257255,BLOCK,-1,,"{
      UNREACHABLE(""Invalid flush value"");
    }",27,,315,2,,void
257265,BLOCK,-1,,"{
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    }",28,,319,2,,void
257276,BLOCK,-1,,"{
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::Length(in_buf)));
      in = Buffer::Data(in_buf) + in_off;
    }",12,,324,1,,void
257311,BLOCK,-1,,<empty>,55,,327,2,,void
257327,BLOCK,-1,,<empty>,55,,328,2,,void
257384,BLOCK,-1,,<empty>,54,,336,2,,void
257400,BLOCK,-1,,<empty>,54,,337,2,,void
257448,BLOCK,-1,,"{
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",43,,350,6,,void
257487,BLOCK,-1,,"{
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }",27,,364,2,,void
257498,BLOCK,-1,,"{
        UpdateWriteResult();
        write_in_progress_ = false;
      }",25,,368,2,,void
257509,BLOCK,-1,,"{
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",28,,380,1,,void
257525,BLOCK,-1,,"{
    ctx_.DoThreadPoolWork();
  }",36,,388,1,,void
257533,BLOCK,-1,,"{
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",21,,393,1,,void
257547,BLOCK,-1,,<empty>,25,,395,2,,void
257558,BLOCK,-1,,"{
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",49,,402,2,,void
257576,BLOCK,-1,,"{
      Close();
      return;
    }",33,,409,2,,void
257604,BLOCK,-1,,<empty>,7,,421,2,,void
257627,BLOCK,-1,,<empty>,7,,430,2,,void
257633,BLOCK,-1,,"{
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",47,,434,2,,void
257703,BLOCK,-1,,<empty>,7,,450,2,,void
257709,BLOCK,-1,,"{
    CompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->ResetStream();
    if (err.IsError())
      wrap->EmitError(err);
  }",62,,453,2,,void
257736,BLOCK,-1,,<empty>,7,,460,2,,void
257746,BLOCK,-1,,"{
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",58,,463,2,,void
257764,BLOCK,-1,,{ return &ctx_; },33,,470,1,,void
257773,BLOCK,-1,,"{
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",78,,472,3,,void
257792,BLOCK,-1,,"{
    size_t real_size =
        MultiplyWithOverflowCheck(static_cast<size_t>(items),
                                  static_cast<size_t>(size));
    return AllocForBrotli(data, real_size);
  }",64,,484,4,,void
257812,BLOCK,-1,,"{
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",56,,491,3,,void
257833,BLOCK,-1,,<empty>,38,,495,2,,void
257862,BLOCK,-1,,"{
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",54,,502,3,,void
257868,BLOCK,-1,,<empty>,39,,503,2,,void
257907,BLOCK,-1,,"{
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",48,,514,1,,void
257923,BLOCK,-1,,<empty>,22,,517,2,,void
257954,BLOCK,-1,,<empty>,69,,524,2,,void
257958,BLOCK,-1,,{ stream->AdjustAmountOfExternalAllocatedMemory(); },19,,525,1,,void
257967,BLOCK,-1,,"{
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",14,,530,1,,void
257973,BLOCK,-1,,"{
      ClearWeak();
    }",23,,531,2,,void
257978,BLOCK,-1,,"{
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",16,,536,1,,void
257987,BLOCK,-1,,"{
      MakeWeak();
    }",23,,538,2,,void
258001,BLOCK,-1,,<empty>,,,,1,,<empty>
258034,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",36,,558,4,,void
258044,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }",60,,562,2,,void
258086,BLOCK,-1,,"{
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }
    CHECK(args.Length() == 7 &&
      ""init(windowBits, level, memLevel, strategy, writeResult, writeCallback,""
      "" dictionary)"");

    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    Local<Context> context = args.GetIsolate()->GetCurrentContext();

    // windowBits is special. On the compression side, 0 is an invalid value.
    // But on the decompression side, a value of 0 for windowBits tells zlib
    // to use the window size in t...",61,,571,2,,void
258094,BLOCK,-1,,"{
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }",29,,574,2,,void
258143,BLOCK,-1,,<empty>,58,,595,2,,void
258160,BLOCK,-1,,<empty>,51,,598,2,,void
258177,BLOCK,-1,,<empty>,56,,601,2,,void
258194,BLOCK,-1,,<empty>,55,,604,2,,void
258262,BLOCK,-1,,"{
      unsigned char* data =
          reinterpret_cast<unsigned char*>(Buffer::Data(args[6]));
      dictionary = std::vector<unsigned char>(
          data,
          data + Buffer::Length(args[6]));
    }",39,,615,2,,void
258332,BLOCK,-1,,"{
    CHECK(args.Length() == 2 && ""params(level, strategy)"");
    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Local<Context> context = args.GetIsolate()->GetCurrentContext();
    int level;
    if (!args[0]->Int32Value(context).To(&level)) return;
    int strategy;
    if (!args[1]->Int32Value(context).To(&strategy)) return;

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->SetParams(level, strategy);
    if (err.IsError())
      wrap->EmitError(err);
  }",63,,632,2,,void
258378,BLOCK,-1,,<empty>,51,,638,2,,void
258395,BLOCK,-1,,<empty>,54,,640,2,,void
258417,BLOCK,-1,,<empty>,7,,645,2,,void
258434,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",56,,659,4,,void
258443,BLOCK,-1,,"{
    return this->CompressionStream<CompressionContext>::context();
  }",40,,663,1,,void
258454,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }",60,,668,2,,void
258496,BLOCK,-1,,"{
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 && ""init(params, writeResult, writeCallback)"");

    CHECK(args[1]->IsUint32Array());
    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));

    CHECK(args[2]->IsFunction());
    Local<Function> write_js_callback = args[2].As<Function>();
    wrap->InitStream(write_result, write_js_callback);

    AllocScope alloc_scope(wrap);
    CompressionError err =
        wrap->context()->Init(
          CompressionStream<CompressionContext>::AllocForBrotli,
          CompressionStream<CompressionContext>::FreeForZlib,
          static_cast<CompressionStream<CompressionContext>*>(wrap));
    if (err.IsError()) {
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }

    CHECK(args[0]->IsUint32Array());
    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffer::Data(args[0]));
    size_t len = args[0].As<Uint32Array...",61,,676,2,,void
258587,BLOCK,-1,,"{
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }",24,,694,2,,void
258634,BLOCK,-1,,<empty>,5,,704,1,,void
258646,BLOCK,4,,"{
      if (data[i] == static_cast<uint32_t>(-1))
        continue;
      err = wrap->context()->SetParams(i, data[i]);
      if (err.IsError()) {
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }
    }",56,,704,4,,void
258656,BLOCK,-1,,<empty>,9,,706,2,,void
258676,BLOCK,-1,,"{
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }",26,,708,2,,void
258703,BLOCK,-1,,"{
    // Currently a no-op, and not accessed from JS land.
    // At some point Brotli may support changing parameters on the fly,
    // in which case we can implement this and a JS equivalent similar to
    // the zlib Params() function.
  }",63,,718,2,,void
258713,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }

  CHECK_LE(mode_, UNZIP);

  int status = Z_OK;
  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {
    status = deflateEnd(&strm_);
  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||
             mode_ == UNZIP) {
    status = inflateEnd(&strm_);
  }

  CHECK(status == Z_OK || status == Z_DATA_ERROR);
  mode_ = NONE;

  dictionary_.clear();
}",27,,732,1,,void
258714,BLOCK,1,,"{
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }",3,,733,1,,void
258721,BLOCK,-1,,"{
      dictionary_.clear();
      mode_ = NONE;
      return;
    }",27,,735,2,,void
258749,BLOCK,-1,,"{
    status = deflateEnd(&strm_);
  }",65,,745,2,,void
258756,BLOCK,-1,,<empty>,10,,747,1,,void
258773,BLOCK,-1,,"{
    status = inflateEnd(&strm_);
  }",30,,748,2,,void
258797,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return;
  }

  const Bytef* next_expected_header_byte = nullptr;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            ...",38,,759,1,,void
258808,BLOCK,-1,,"{
    return;
  }",40,,761,2,,void
258816,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            ...",18,,770,2,,void
258838,BLOCK,-1,,"{
        next_expected_header_byte = strm_.next_in;
      }",31,,777,2,,void
258846,BLOCK,-1,,"{
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }

          break;
        default:
          UNREACHABLE(""invalid number of gzip magic number bytes read"")...",36,,781,2,,void
258853,BLOCK,-1,,"{
            break;
          }",53,,783,2,,void
258860,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          }",62,,787,2,,void
258872,BLOCK,-1,,"{
              // The only available byte was already read.
              break;
            }",38,,791,2,,void
258875,BLOCK,-1,,"{
            mode_ = INFLATE;
            break;
          }",18,,795,1,,void
258886,BLOCK,-1,,"{
            break;
          }",53,,802,2,,void
258893,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          }",62,,806,2,,void
258901,BLOCK,-1,,"{
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }",18,,809,1,,void
258935,BLOCK,-1,,"{
        // Load it
        err_ = inflateSetDictionary(&strm_,
                                    dictionary_.data(),
                                    dictionary_.size());
        if (err_ == Z_OK) {
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        } else if (err_ == Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }
      }",33,,830,2,,void
258953,BLOCK,-1,,"{
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        }",27,,835,2,,void
258961,BLOCK,-1,,<empty>,16,,838,1,,void
258966,BLOCK,-1,,"{
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }",42,,838,2,,void
258992,BLOCK,-1,,"{
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.

        ResetStream();
        err_ = inflate(&strm_, flush_);
      }",40,,849,2,,void
259010,BLOCK,-1,,"{
  strm_.avail_in = in_len;
  strm_.next_in = const_cast<Bytef*>(reinterpret_cast<const Bytef*>(in));
  strm_.avail_out = out_len;
  strm_.next_out = reinterpret_cast<Bytef*>(out);
}",59,,866,5,,void
259041,BLOCK,-1,,"{
  flush_ = flush;
}",39,,874,2,,void
259050,BLOCK,-1,,"{
  *avail_in = strm_.avail_in;
  *avail_out = strm_.avail_out;
}",67,,880,3,,void
259067,BLOCK,-1,,"{
  if (strm_.msg != nullptr)
    message = strm_.msg;

  return CompressionError { message, ZlibStrerror(err_), err_ };
}",74,,886,2,,void
259074,BLOCK,-1,,<empty>,5,,888,2,,void
259090,BLOCK,-1,,"{
  // Acceptable error states depend on the type of zlib stream.
  switch (err_) {
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }

  return CompressionError {};
}",52,,894,1,,void
259093,BLOCK,-1,,"{
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }",17,,896,2,,void
259108,BLOCK,-1,,"{
      return ErrorForMessage(""unexpected end of file"");
    }",53,,899,2,,void
259122,BLOCK,-1,,<empty>,7,,907,2,,void
259127,BLOCK,-1,,<empty>,7,,909,1,,void
259141,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before reset"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }

  if (err_ != Z_OK)
    return ErrorForMessage(""Failed to reset stream"");

  return SetDictionary();
}",45,,919,1,,void
259152,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before reset"");
  }",40,,921,2,,void
259161,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }",18,,927,2,,void
259192,BLOCK,-1,,<empty>,5,,943,2,,void
259204,BLOCK,-1,,"{
  strm_.zalloc = alloc;
  strm_.zfree = free;
  strm_.opaque = opaque;
}",56,,951,4,,void
259228,BLOCK,-1,,"{
  if (!((window_bits == 0) &&
        (mode_ == INFLATE ||
         mode_ == GUNZIP ||
         mode_ == UNZIP))) {
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }

  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&
    ""invalid compression level"");

  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&
        ""invalid memlevel"");

  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||
         strategy == Z_RLE || strategy == Z_FIXED ||
         strategy == Z_DEFAULT_STRATEGY) &&
        ""invalid strategy"");

  level_ = level;
  window_bits_ = window_bits;
  mem_level_ = mem_level;
  strategy_ = strategy;

  flush_ = Z_NO_FLUSH;

  err_ = Z_OK;

  if (mode_ == GZIP || mode_ == GUNZIP) {
    window_bits_ += 16;
  }

  if (mode_ == UNZIP) {
    window_bits_ += 32;
  }

  if (mode_ == DEFLATERAW || mode_ == INFLATERAW) {
    window_bits_ *= -1;
  }

  dictionary_ = std::...",46,,960,6,,void
259246,BLOCK,-1,,"{
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }",28,,964,2,,void
259253,BLOCK,1,,<empty>,,,,1,,void
259258,BLOCK,1,,<empty>,,,,1,,void
259267,BLOCK,1,,<empty>,,,,1,,void
259273,BLOCK,1,,<empty>,,,,1,,void
259282,BLOCK,1,,<empty>,,,,1,,void
259287,BLOCK,1,,<empty>,,,,1,,void
259338,BLOCK,-1,,"{
    window_bits_ += 16;
  }",41,,990,2,,void
259346,BLOCK,-1,,"{
    window_bits_ += 32;
  }",23,,994,2,,void
259358,BLOCK,-1,,"{
    window_bits_ *= -1;
  }",51,,998,2,,void
259373,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (zlib_init_done_) {
    return false;
  }

  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }

  if (err_ != Z_OK) {
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }

  SetDictionary();
  zlib_init_done_ = true;
  return true;
}",30,,1005,1,,void
259379,BLOCK,-1,,"{
    return false;
  }",24,,1007,2,,void
259384,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }",18,,1011,2,,void
259423,BLOCK,-1,,"{
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }",21,,1032,2,,void
259442,BLOCK,-1,,"{
  if (dictionary_.empty())
    return CompressionError {};

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }

  if (err_ != Z_OK) {
    return ErrorForMessage(""Failed to set dictionary"");
  }

  return CompressionError {};
}",47,,1044,1,,void
259448,BLOCK,-1,,<empty>,5,,1046,2,,void
259457,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }",18,,1050,2,,void
259498,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set dictionary"");
  }",21,,1068,2,,void
259510,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }

  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {
    return ErrorForMessage(""Failed to set parameters"");
  }

  return CompressionError {};
}",66,,1076,3,,void
259521,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }",40,,1078,2,,void
259530,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }",18,,1084,2,,void
259553,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set parameters"");
  }",44,,1093,2,,void
259567,BLOCK,-1,,"{
  next_in_ = reinterpret_cast<const uint8_t*>(in);
  next_out_ = reinterpret_cast<uint8_t*>(out);
  avail_in_ = in_len;
  avail_out_ = out_len;
}",61,,1102,5,,void
259588,BLOCK,-1,,"{
  flush_ = static_cast<BrotliEncoderOperation>(flush);
}",41,,1110,2,,void
259599,BLOCK,-1,,"{
  *avail_in = avail_in_;
  *avail_out = avail_out_;
}",69,,1116,3,,void
259611,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_ENCODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliEncoderCompressStream(state_.get(),
                                             flush_,
                                             &avail_in_,
                                             &next_in,
                                             &avail_out_,
                                             &next_out_,
                                             nullptr);
  next_in_ += next_in - next_in_;
}",47,,1122,1,,void
259646,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1137,1,,void
259660,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1144,4,,void
259681,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1149,2,,void
259689,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1153,1,,void
259696,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1158,1,,void
259707,BLOCK,-1,,"{
  if (!BrotliEncoderSetParameter(state_.get(),
                                 static_cast<BrotliEncoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1162,3,,void
259719,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1165,2,,void
259727,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1169,1,,void
259734,BLOCK,-1,,"{
  if (!last_result_) {
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",61,,1174,1,,void
259738,BLOCK,-1,,"{
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  }",22,,1175,2,,void
259746,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1179,1,,void
259753,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1185,1,,void
259764,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_DECODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliDecoderDecompressStream(state_.get(),
                                               &avail_in_,
                                               &next_in,
                                               &avail_out_,
                                               &next_out_,
                                               nullptr);
  next_in_ += next_in - next_in_;
  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }
}",47,,1190,1,,void
259799,BLOCK,-1,,"{
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }",52,,1201,2,,void
259823,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1209,4,,void
259844,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1214,2,,void
259852,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1218,1,,void
259859,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1223,1,,void
259870,BLOCK,-1,,"{
  if (!BrotliDecoderSetParameter(state_.get(),
                                 static_cast<BrotliDecoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1227,3,,void
259882,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1230,2,,void
259890,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1234,1,,void
259897,BLOCK,-1,,"{
  if (error_ != BROTLI_DECODER_NO_ERROR) {
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  } else if (flush_ == BROTLI_OPERATION_FINISH &&
             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  } else {
    return CompressionError {};
  }
}",61,,1239,1,,void
259902,BLOCK,-1,,"{
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  }",42,,1240,2,,void
259914,BLOCK,-1,,<empty>,10,,1244,1,,void
259923,BLOCK,-1,,"{
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  }",70,,1245,2,,void
259930,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1250,1,,void
259941,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }",78,,1258,4,,void
260033,BLOCK,-1,,"{
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false>);
    registry->Register(Stream::Close);
    registry->Register(Stream::Init);
    registry->Register(Stream::Params);
    registry->Register(Stream::Reset);
  }",57,,1277,2,,void
260090,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  MakeClass<ZlibStream>::Make(env, target, ""Zlib"");
  MakeClass<BrotliEncoderStream>::Make(env, target, ""BrotliEncoder"");
  MakeClass<BrotliDecoderStream>::Make(env, target, ""BrotliDecoder"");

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""ZLIB_VERSION""),
              FIXED_ONE_BYTE_STRING(env->isolate(), ZLIB_VERSION)).Check();
}",29,,1291,5,,void
260147,BLOCK,-1,,"{
  MakeClass<ZlibStream>::Make(registry);
  MakeClass<BrotliEncoderStream>::Make(registry);
  MakeClass<BrotliDecoderStream>::Make(registry);
}",70,,1303,2,,void
260167,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FINISH);
  NODE_DEFINE_CONSTANT(target, Z_BLOCK);

  // return/error codes
  NODE_DEFINE_CONSTANT(target, Z_OK);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_END);
  NODE_DEFINE_CONSTANT(target, Z_NEED_DICT);
  NODE_DEFINE_CONSTANT(target, Z_ERRNO);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR);

  NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED);
  NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_FILTERED);
  NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY);
  N...",48,,1311,2,,void
260173,BLOCK,1,,<empty>,,,,7,,void
260175,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH)",3,,1312,1,,void
260272,BLOCK,1,,<empty>,,,,7,,void
260274,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH)",3,,1313,1,,void
260371,BLOCK,1,,<empty>,,,,7,,void
260373,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH)",3,,1314,1,,void
260470,BLOCK,1,,<empty>,,,,7,,void
260472,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH)",3,,1315,1,,void
260569,BLOCK,1,,<empty>,,,,7,,void
260571,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FINISH)",3,,1316,1,,void
260668,BLOCK,1,,<empty>,,,,7,,void
260670,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BLOCK)",3,,1317,1,,void
260767,BLOCK,1,,<empty>,,,,7,,void
260769,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_OK)",3,,1320,1,,void
260866,BLOCK,1,,<empty>,,,,7,,void
260868,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_END)",3,,1321,1,,void
260965,BLOCK,1,,<empty>,,,,7,,void
260967,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NEED_DICT)",3,,1322,1,,void
261064,BLOCK,1,,<empty>,,,,7,,void
261066,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_ERRNO)",3,,1323,1,,void
261163,BLOCK,1,,<empty>,,,,7,,void
261165,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR)",3,,1324,1,,void
261262,BLOCK,1,,<empty>,,,,7,,void
261264,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR)",3,,1325,1,,void
261361,BLOCK,1,,<empty>,,,,7,,void
261363,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR)",3,,1326,1,,void
261460,BLOCK,1,,<empty>,,,,7,,void
261462,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR)",3,,1327,1,,void
261559,BLOCK,1,,<empty>,,,,7,,void
261561,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR)",3,,1328,1,,void
261658,BLOCK,1,,<empty>,,,,7,,void
261660,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION)",3,,1330,1,,void
261757,BLOCK,1,,<empty>,,,,7,,void
261759,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED)",3,,1331,1,,void
261856,BLOCK,1,,<empty>,,,,7,,void
261858,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION)",3,,1332,1,,void
261955,BLOCK,1,,<empty>,,,,7,,void
261957,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION)",3,,1333,1,,void
262054,BLOCK,1,,<empty>,,,,7,,void
262056,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FILTERED)",3,,1334,1,,void
262153,BLOCK,1,,<empty>,,,,7,,void
262155,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY)",3,,1335,1,,void
262252,BLOCK,1,,<empty>,,,,7,,void
262254,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_RLE)",3,,1336,1,,void
262351,BLOCK,1,,<empty>,,,,7,,void
262353,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FIXED)",3,,1337,1,,void
262450,BLOCK,1,,<empty>,,,,7,,void
262452,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_STRATEGY)",3,,1338,1,,void
262549,BLOCK,1,,<empty>,,,,7,,void
262551,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, ZLIB_VERNUM)",3,,1339,1,,void
262648,BLOCK,1,,<empty>,,,,7,,void
262650,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATE)",3,,1341,1,,void
262747,BLOCK,1,,<empty>,,,,7,,void
262749,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATE)",3,,1342,1,,void
262846,BLOCK,1,,<empty>,,,,7,,void
262848,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GZIP)",3,,1343,1,,void
262945,BLOCK,1,,<empty>,,,,7,,void
262947,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GUNZIP)",3,,1344,1,,void
263044,BLOCK,1,,<empty>,,,,7,,void
263046,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATERAW)",3,,1345,1,,void
263143,BLOCK,1,,<empty>,,,,7,,void
263145,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATERAW)",3,,1346,1,,void
263242,BLOCK,1,,<empty>,,,,7,,void
263244,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, UNZIP)",3,,1347,1,,void
263341,BLOCK,1,,<empty>,,,,7,,void
263343,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODE)",3,,1348,1,,void
263440,BLOCK,1,,<empty>,,,,7,,void
263442,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE)",3,,1349,1,,void
263538,BLOCK,1,,<empty>,,,,6,,void
263540,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS)",3,,1351,1,,void
263636,BLOCK,1,,<empty>,,,,6,,void
263638,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS)",3,,1352,1,,void
263734,BLOCK,1,,<empty>,,,,6,,void
263736,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_WINDOWBITS)",3,,1353,1,,void
263832,BLOCK,1,,<empty>,,,,6,,void
263834,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_CHUNK)",3,,1354,1,,void
263930,BLOCK,1,,<empty>,,,,6,,void
263932,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_CHUNK)",3,,1355,1,,void
264033,BLOCK,1,,<empty>,,,,6,,void
264035,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_CHUNK)",3,,1356,1,,void
264133,BLOCK,1,,<empty>,,,,6,,void
264135,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_MEMLEVEL)",3,,1357,1,,void
264231,BLOCK,1,,<empty>,,,,6,,void
264233,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_MEMLEVEL)",3,,1358,1,,void
264329,BLOCK,1,,<empty>,,,,6,,void
264331,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_MEMLEVEL)",3,,1359,1,,void
264427,BLOCK,1,,<empty>,,,,6,,void
264429,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL)",3,,1360,1,,void
264526,BLOCK,1,,<empty>,,,,6,,void
264528,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL)",3,,1361,1,,void
264624,BLOCK,1,,<empty>,,,,6,,void
264626,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL)",3,,1362,1,,void
264723,BLOCK,1,,<empty>,,,,7,,void
264725,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS)",3,,1365,1,,void
264822,BLOCK,1,,<empty>,,,,7,,void
264824,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH)",3,,1366,1,,void
264921,BLOCK,1,,<empty>,,,,7,,void
264923,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH)",3,,1367,1,,void
265020,BLOCK,1,,<empty>,,,,7,,void
265022,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA)",3,,1368,1,,void
265119,BLOCK,1,,<empty>,,,,7,,void
265121,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE)",3,,1369,1,,void
265218,BLOCK,1,,<empty>,,,,7,,void
265220,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC)",3,,1370,1,,void
265317,BLOCK,1,,<empty>,,,,7,,void
265319,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT)",3,,1371,1,,void
265416,BLOCK,1,,<empty>,,,,7,,void
265418,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT)",3,,1372,1,,void
265515,BLOCK,1,,<empty>,,,,7,,void
265517,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE)",3,,1373,1,,void
265614,BLOCK,1,,<empty>,,,,7,,void
265616,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY)",3,,1374,1,,void
265713,BLOCK,1,,<empty>,,,,7,,void
265715,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY)",3,,1375,1,,void
265812,BLOCK,1,,<empty>,,,,7,,void
265814,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY)",3,,1376,1,,void
265911,BLOCK,1,,<empty>,,,,7,,void
265913,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY)",3,,1377,1,,void
266010,BLOCK,1,,<empty>,,,,7,,void
266012,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN)",3,,1378,1,,void
266109,BLOCK,1,,<empty>,,,,7,,void
266111,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS)",3,,1379,1,,void
266208,BLOCK,1,,<empty>,,,,7,,void
266210,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS)",3,,1380,1,,void
266307,BLOCK,1,,<empty>,,,,7,,void
266309,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS)",3,,1381,1,,void
266406,BLOCK,1,,<empty>,,,,7,,void
266408,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW)",3,,1382,1,,void
266505,BLOCK,1,,<empty>,,,,7,,void
266507,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK)",3,,1383,1,,void
266604,BLOCK,1,,<empty>,,,,7,,void
266606,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS)",3,,1384,1,,void
266703,BLOCK,1,,<empty>,,,,7,,void
266705,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS)",3,,1385,1,,void
266802,BLOCK,1,,<empty>,,,,7,,void
266804,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING)",3,,1386,1,,void
266901,BLOCK,1,,<empty>,,,,7,,void
266903,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT)",3,,1387,1,,void
267000,BLOCK,1,,<empty>,,,,7,,void
267002,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW)",3,,1388,1,,void
267099,BLOCK,1,,<empty>,,,,7,,void
267101,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX)",3,,1389,1,,void
267198,BLOCK,1,,<empty>,,,,7,,void
267200,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT)",3,,1390,1,,void
267297,BLOCK,1,,<empty>,,,,7,,void
267299,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR)",3,,1391,1,,void
267396,BLOCK,1,,<empty>,,,,7,,void
267398,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS)",3,,1392,1,,void
267495,BLOCK,1,,<empty>,,,,7,,void
267497,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT)",3,,1393,1,,void
267594,BLOCK,1,,<empty>,,,,7,,void
267596,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)",3,,1394,1,,void
267693,BLOCK,1,,<empty>,,,,7,,void
267695,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION)",3,,1395,1,,void
267792,BLOCK,1,,<empty>,,,,7,,void
267794,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW)",3,,1397,1,,void
267891,BLOCK,1,,<empty>,,,,7,,void
267893,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR)",3,,1398,1,,void
267990,BLOCK,1,,<empty>,,,,7,,void
267992,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS)",3,,1399,1,,void
268089,BLOCK,1,,<empty>,,,,7,,void
268091,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT)",3,,1400,1,,void
268188,BLOCK,1,,<empty>,,,,7,,void
268190,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT)",3,,1401,1,,void
268287,BLOCK,1,,<empty>,,,,7,,void
268289,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE)",3,,1402,1,,void
268386,BLOCK,1,,<empty>,,,,7,,void
268388,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED)",3,,1403,1,,void
268485,BLOCK,1,,<empty>,,,,7,,void
268487,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE)",3,,1404,1,,void
268584,BLOCK,1,,<empty>,,,,7,,void
268586,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET)",3,,1406,1,,void
268683,BLOCK,1,,<empty>,,,,7,,void
268685,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME)",3,,1408,1,,void
268782,BLOCK,1,,<empty>,,,,7,,void
268784,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE)",3,,1409,1,,void
268881,BLOCK,1,,<empty>,,,,7,,void
268883,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE)",3,,1410,1,,void
268980,BLOCK,1,,<empty>,,,,7,,void
268982,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT)",3,,1411,1,,void
269079,BLOCK,1,,<empty>,,,,7,,void
269081,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1)",3,,1412,1,,void
269178,BLOCK,1,,<empty>,,,,7,,void
269180,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2)",3,,1413,1,,void
269277,BLOCK,1,,<empty>,,,,7,,void
269279,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM)",3,,1414,1,,void
269376,BLOCK,1,,<empty>,,,,7,,void
269378,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY)",3,,1415,1,,void
269475,BLOCK,1,,<empty>,,,,7,,void
269477,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS)",3,,1416,1,,void
269574,BLOCK,1,,<empty>,,,,7,,void
269576,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1)",3,,1417,1,,void
269673,BLOCK,1,,<empty>,,,,7,,void
269675,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2)",3,,1418,1,,void
269772,BLOCK,1,,<empty>,,,,7,,void
269774,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE)",3,,1419,1,,void
269871,BLOCK,1,,<empty>,,,,7,,void
269873,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET)",3,,1420,1,,void
269970,BLOCK,1,,<empty>,,,,7,,void
269972,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS)",3,,1421,1,,void
270069,BLOCK,1,,<empty>,,,,7,,void
270071,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES)",3,,1422,1,,void
270168,BLOCK,1,,<empty>,,,,7,,void
270170,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS)",3,,1423,1,,void
270267,BLOCK,1,,<empty>,,,,7,,void
270269,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP)",3,,1424,1,,void
270366,BLOCK,1,,<empty>,,,,7,,void
270368,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1)",3,,1425,1,,void
270465,BLOCK,1,,<empty>,,,,7,,void
270467,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2)",3,,1426,1,,void
270564,BLOCK,1,,<empty>,,,,7,,void
270566,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES)",3,,1427,1,,void
270663,BLOCK,1,,<empty>,,,,7,,void
270665,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE)",3,,1428,1,,void
270770,BLOCK,-1,,<empty>,1,,1,1,,ANY
270776,BLOCK,-1,,"{
  deny_all_ = true;
}",59,,13,3,,void
270785,BLOCK,-1,,"{
  return deny_all_ == false;
}",72,,18,3,,void
270800,BLOCK,-1,,<empty>,1,,1,1,,ANY
270829,BLOCK,-1,,<empty>,1,,1,1,,ANY
270833,BLOCK,-1,,"{
  uv_fs_t req;
  int rc = uv_fs_stat(nullptr, &req, res.c_str(), nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }
  uv_fs_req_cleanup(&req);
  return res;
}",60,,17,2,,void
270851,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }",16,,20,2,,void
270866,BLOCK,-1,,"{
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }",31,,22,2,,void
270876,BLOCK,-1,,"{
        return res + ""*"";
      }",47,,24,2,,void
270898,BLOCK,-1,,"{
  if (node == nullptr) {
    return;
  }

  if (node->children.size()) {
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }

  if (node->wildcard_child != nullptr) {
    delete node->wildcard_child;
  }
  delete node;
}",60,,35,2,,void
270903,BLOCK,-1,,"{
    return;
  }",24,,36,2,,void
270912,BLOCK,-1,,"{
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }",30,,40,2,,void
270918,BLOCK,-1,,"{
      FreeRecursivelyNode(c.second);
    }",36,,41,3,,void
270929,BLOCK,-1,,"{
    delete node->wildcard_child;
  }",40,,46,2,,void
270941,BLOCK,-1,,"{
#ifdef _WIN32
  // is UNC file path
  if (param.rfind(""\\\\"", 0) == 0) {
    // return lookup with normalized param
    int starting_pos = 4;  // ""\\?\""
    if (param.rfind(""\\\\?\\UNC\\"") == 0) {
      starting_pos += 4;  // ""UNC\""
    }
    auto normalized = param.substr(starting_pos);
    return granted_tree->Lookup(normalized, true);
  }
#endif
  return granted_tree->Lookup(param, true);
}",53,,53,3,,void
270956,BLOCK,-1,,"{
  using std::string_view_literals::operator""""sv;
  for (const std::string_view res : SplitString(allow, "",""sv)) {
    if (res == ""*""sv) {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, std::string(res.data(), res.size()));
  }
}",75,,77,3,,void
270962,BLOCK,-1,,"{
    if (res == ""*""sv) {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, std::string(res.data(), res.size()));
  }",64,,79,3,,void
270967,BLOCK,-1,,"{
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }",23,,80,2,,void
270974,BLOCK,-1,,"{
        deny_all_in_ = false;
        allow_all_in_ = true;
      }",54,,81,2,,void
270982,BLOCK,-1,,"{
        deny_all_out_ = false;
        allow_all_out_ = true;
      }",14,,84,1,,void
271009,BLOCK,-1,,"{
  const std::string path = WildcardIfDir(res);
  if (perm == PermissionScope::kFileSystemRead) {
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  } else if (perm == PermissionScope::kFileSystemWrite) {
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }
}",78,,94,3,,void
271021,BLOCK,-1,,"{
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  }",49,,96,2,,void
271031,BLOCK,-1,,<empty>,10,,99,1,,void
271038,BLOCK,-1,,"{
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }",57,,99,2,,void
271052,BLOCK,-1,,"{
  switch (perm) {
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }
}",67,,106,3,,void
271055,BLOCK,-1,,"{
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }",17,,107,2,,void
271112,BLOCK,-1,,<empty>,65,,123,1,,void
271116,BLOCK,-1,,"{
  FreeRecursivelyNode(root_node_);
}",39,,125,1,,void
271123,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;
  if (current_node->children.size() == 0) {
    return when_empty_return;
  }
  unsigned int parent_node_prefix_len = current_node->prefix.length();
  const std::string path(s);
  auto path_len = path.length();

  while (true) {
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }
}",70,,130,3,,void
271137,BLOCK,-1,,"{
    return when_empty_return;
  }",43,,132,2,,void
271161,BLOCK,-1,,"{
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }",16,,139,2,,void
271171,BLOCK,-1,,"{
      return true;
    }",74,,140,2,,void
271187,BLOCK,-1,,"{
      return false;
    }",26,,145,2,,void
271213,BLOCK,-1,,"{
      return true;
    }",64,,152,2,,void
271220,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  int path_len = path.length();

  for (int i = 1; i <= path_len; ++i) {
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }
}",63,,158,2,,void
271242,BLOCK,-1,,<empty>,3,,164,1,,void
271252,BLOCK,4,,"{
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }",39,,164,4,,void
271273,BLOCK,-1,,"{
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }",43,,168,2,,void
271292,BLOCK,-1,,"{
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }",27,,173,2,,void
271316,BLOCK,-1,,<empty>,1,,1,1,,ANY
271325,BLOCK,-1,,<empty>,1,,1,1,,ANY
271331,BLOCK,-1,,"{
  deny_all_ = true;
}",56,,12,3,,void
271340,BLOCK,-1,,"{
  return deny_all_ == false;
}",69,,17,3,,void
271355,BLOCK,-1,,<empty>,1,,1,1,,ANY
271382,BLOCK,-1,,<empty>,1,,1,1,,ANY
271388,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  v8::Isolate* isolate = env->isolate();
  CHECK(args[0]->IsString());

  String::Utf8Value utf8_deny_scope(isolate, args[0]);
  if (*utf8_deny_scope == nullptr) {
    return;
  }

  const std::string deny_scope = *utf8_deny_scope;
  PermissionScope scope = Permission::StringToPermission(deny_scope);
  if (scope == PermissionScope::kPermissionsRoot) {
    return args.GetReturnValue().Set(false);
  }

  if (args.Length() > 1 && !args[1]->IsUndefined()) {
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }

  return args.GetReturnValue().Set(env->permission()->is_granted(scope));
}",58,,30,2,,void
271422,BLOCK,-1,,"{
    return;
  }",36,,36,2,,void
271443,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,42,2,,void
271468,BLOCK,-1,,"{
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }",53,,46,2,,void
271480,BLOCK,-1,,"{
      return;
    }",31,,48,2,,void
271520,BLOCK,-1,,"{
  PERMISSIONS(V)
  return nullptr;
}",72,,62,2,,void
271529,BLOCK,-1,,"{
  PERMISSIONS(V)
  return PermissionScope::kPermissionsRoot;
}",73,,70,2,,void
271539,BLOCK,-1,,"{
  std::shared_ptr<PermissionBase> fs = std::make_shared<FSPermission>();
  std::shared_ptr<PermissionBase> child_p =
      std::make_shared<ChildProcessPermission>();
  std::shared_ptr<PermissionBase> worker_t =
      std::make_shared<WorkerPermission>();
  std::shared_ptr<PermissionBase> inspector =
      std::make_shared<InspectorPermission>();
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, fs));
  FILESYSTEM_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, child_p));
  CHILD_PROCESS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, worker_t));
  WORKER_THREADS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  no...",44,,76,1,,void
271602,BLOCK,-1,,"{
  Local<Value> err = ERR_ACCESS_DENIED(env->isolate());
  CHECK(err->IsObject());
  if (err.As<Object>()
          ->Set(env->context(),
                env->permission_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        PermissionToString(perm),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing() ||
      err.As<Object>()
          ->Set(env->context(),
                env->resource_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        std::string(res).c_str(),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing())
    return;
  env->isolate()->ThrowException(err);
}",65,,104,4,,void
271703,BLOCK,-1,,<empty>,5,,123,2,,void
271716,BLOCK,-1,,"{
  if (!enabled_) {
    enabled_ = true;
  }
}",38,,127,1,,void
271720,BLOCK,-1,,"{
    enabled_ = true;
  }",18,,128,2,,void
271729,BLOCK,-1,,"{
  auto permission = nodes_.find(scope);
  if (permission != nodes_.end()) {
    permission->second->Apply(allow, scope);
  }
}",73,,133,3,,void
271745,BLOCK,-1,,"{
    permission->second->Apply(allow, scope);
  }",35,,135,2,,void
271761,BLOCK,-1,,"{
  SetMethodNoSideEffect(context, target, ""has"", Has);

  target->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen).FromJust();
}",29,,143,5,,void
271784,BLOCK,-1,,"{
  registry->Register(Has);
}",70,,149,2,,void
271817,BLOCK,-1,,<empty>,1,,1,1,,ANY
271830,BLOCK,-1,,<empty>,1,,1,1,,ANY
271841,BLOCK,-1,,<empty>,1,,1,1,,ANY
271847,BLOCK,-1,,"{
  deny_all_ = true;
}",79,,12,3,,void
271856,BLOCK,-1,,"{
  return deny_all_ == false;
}",66,,17,3,,void
271871,BLOCK,-1,,<empty>,1,,1,1,,ANY
271900,BLOCK,-1,,<empty>,1,,1,1,,ANY
271906,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(false, env->pipe_constructor_template().IsEmpty());
  Local<Function> constructor = env->pipe_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(false, constructor.IsEmpty());
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",69,,52,4,,void
271989,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""open"", Open);

#ifdef _WIN32
  SetProtoMethod(isolate, t, ""setPendingInstances"", SetPendingInstances);
#endif

  SetProtoMethod(isolate, t, ""fchmod"", Fchmod);

  SetConstructorFunction(context, target, ""Pipe"", t);
  env->set_pipe_constructor_template(t);

  // Create FunctionTemplate for PipeConnectWrap.
  auto cwt = BaseObject::MakeLazilyInitializedJSTemplate(env);
  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, ""PipeConnectWrap"", cwt);

  // Define constants
  ...",39,,69,5,,void
272109,BLOCK,1,,<empty>,,,,7,,void
272111,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,100,1,,void
272208,BLOCK,1,,<empty>,,,,7,,void
272210,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,101,1,,void
272307,BLOCK,1,,<empty>,,,,7,,void
272309,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, IPC)",3,,102,1,,void
272406,BLOCK,1,,<empty>,,,,7,,void
272408,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_READABLE)",3,,103,1,,void
272505,BLOCK,1,,<empty>,,,,7,,void
272507,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_WRITABLE)",3,,104,1,,void
272616,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Open);
#ifdef _WIN32
  registry->Register(SetPendingInstances);
#endif
  registry->Register(Fchmod);
}",80,,110,2,,void
272651,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value);

  bool ipc;
  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }

  new PipeWrap(env, args.This(), provider, ipc);
}",61,,122,2,,void
272694,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }",17,,135,2,,void
272740,BLOCK,-1,,"{
  int r = uv_pipe_init(env->event_loop(), &handle_, ipc);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_pipe_init() returns void.
}",45,,160,5,,void
272759,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  node::Utf8Value name(args.GetIsolate(), args[0]);
  int err = uv_pipe_bind(&wrap->handle_, *name);
  args.GetReturnValue().Set(err);
}",62,,167,2,,void
272799,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(args[0]->IsInt32());
  int mode = args[0].As<Int32>()->Value();
  int err = uv_pipe_chmod(&wrap->handle_, mode);
  args.GetReturnValue().Set(err);
}",72,,187,2,,void
272848,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",64,,197,2,,void
272882,BLOCK,-1,,<empty>,58,,202,2,,void
272908,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;

  int err = uv_pipe_open(&wrap->handle_, fd);
  if (err == 0) wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",62,,210,2,,void
272943,BLOCK,-1,,<empty>,53,,217,2,,void
272958,BLOCK,-1,,<empty>,17,,220,2,,void
272976,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value name(env->isolate(), args[1]);

  ConnectWrap* req_wrap =
      new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);
  req_wrap->Dispatch(uv_pipe_connect,
                     &wrap->handle_,
                     *name,
                     AfterConnect);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE2(net, native),
                                    ""connect"",
                                    req_wrap,
                                    ""pipe_path"",
                                    TRACE_STR_COPY(*name));

  args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.
}",65,,226,2,,void
273079,BLOCK,-1,,<empty>,1,,1,1,,ANY
273100,BLOCK,-1,,<empty>,1,,1,1,,ANY
273109,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }",38,,55,5,,void
273174,BLOCK,-1,,"{
    MarkAsUninitialized();
  }",53,,88,3,,void
273181,BLOCK,-1,,"{
    Local<String> handle_key = env->handle_string();
    // This property has always been set by JS land if we are in this code path.
    Local<Object> handle =
        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();

    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();
    CHECK_NOT_NULL(stream);
    return stream;
  }",76,,92,3,,void
273235,BLOCK,-1,,"{
    Local<Context> context = env->context();
    Local<String> stdio_key = env->stdio_string();
    Local<Array> stdios =
        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();

    uint32_t len = stdios->Length();
    options->stdio = new uv_stdio_container_t[len];
    options->stdio_count = len;

    for (uint32_t i = 0; i < len; i++) {
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].f...",64,,105,4,,void
273293,BLOCK,-1,,<empty>,5,,115,1,,void
273303,BLOCK,4,,"{
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->wrap_string())) {
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = Strea...",40,,115,4,,void
273349,BLOCK,-1,,"{
        options->stdio[i].flags = UV_IGNORE;
      }",53,,121,2,,void
273360,BLOCK,-1,,<empty>,14,,123,1,,void
273370,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,123,2,,void
273400,BLOCK,-1,,<empty>,14,,127,1,,void
273410,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",64,,127,2,,void
273442,BLOCK,-1,,<empty>,14,,132,1,,void
273452,BLOCK,-1,,"{
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,132,2,,void
273476,BLOCK,-1,,"{
        Local<String> fd_key = env->fd_string();
        Local<Value> fd_value = stdio->Get(context, fd_key).ToLocalChecked();
        CHECK(fd_value->IsNumber());
        int fd = static_cast<int>(fd_value.As<Integer>()->Value());
        options->stdio[i].flags = UV_INHERIT_FD;
        options->stdio[i].data.fd = fd;
      }",14,,135,1,,void
273543,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToLocalChecked();
    if (!gid_v->IsUndefined() && !gid_v->IsN...",62,,146,2,,void
273639,BLOCK,-1,,"{
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }",52,,165,2,,void
273697,BLOCK,-1,,"{
      CHECK(gid_v->IsInt32());
      const int32_t gid = gid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETGID;
      options.gid = static_cast<uv_gid_t>(gid);
    }",52,,175,2,,void
273790,BLOCK,-1,,"{
      Local<Array> js_argv = argv_v.As<Array>();
      int argc = js_argv->Length();
      CHECK_LT(argc, INT_MAX);  // Check for overflow.

      // Heap allocate to detect errors. +1 is for nullptr.
      options.args = new char*[argc + 1];
      for (int i = 0; i < argc; i++) {
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }
      options.args[argc] = nullptr;
    }",49,,194,2,,void
273818,BLOCK,-1,,<empty>,7,,201,1,,void
273828,BLOCK,4,,"{
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }",38,,201,4,,void
273904,BLOCK,-1,,"{
      options.cwd = *cwd;
    }",27,,215,2,,void
273940,BLOCK,-1,,"{
      Local<Array> env_opt = env_v.As<Array>();
      int envc = env_opt->Length();
      CHECK_LT(envc, INT_MAX);            // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i < envc; i++) {
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }",47,,222,2,,void
273968,BLOCK,-1,,<empty>,7,,227,1,,void
273978,BLOCK,4,,"{
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }",38,,227,4,,void
274044,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE;
    }",27,,243,2,,void
274055,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE_CONSOLE;
    }",38,,247,2,,void
274084,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS;
    }",26,,256,2,,void
274113,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_DETACHED;
    }",31,,264,2,,void
274141,BLOCK,-1,,"{
      CHECK_EQ(wrap->process_.data, wrap);
      wrap->object()->Set(context, env->pid_string(),
                          Integer::New(env->isolate(),
                                       wrap->process_.pid)).Check();
    }",19,,271,2,,void
274181,BLOCK,-1,,"{
      for (int i = 0; options.args[i]; i++) free(options.args[i]);
      delete [] options.args;
    }",23,,278,2,,void
274183,BLOCK,-1,,<empty>,7,,279,1,,void
274209,BLOCK,-1,,"{
      for (int i = 0; options.env[i]; i++) free(options.env[i]);
      delete [] options.env;
    }",22,,283,2,,void
274211,BLOCK,-1,,<empty>,7,,284,1,,void
274249,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",61,,293,2,,void
274305,BLOCK,-1,,"{
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",39,,304,4,,void
274405,BLOCK,-1,,<empty>,1,,1,1,,ANY
274430,BLOCK,-1,,<empty>,1,,1,1,,ANY
274445,BLOCK,-1,,<empty>,1,,1,1,,ANY
274456,BLOCK,-1,,<empty>,1,,1,1,,ANY
274475,BLOCK,-1,,<empty>,1,,1,1,,ANY
274494,BLOCK,-1,,<empty>,1,,1,1,,ANY
274509,BLOCK,-1,,<empty>,1,,1,1,,ANY
274517,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }
  return true;
}",51,,16,5,,void
274543,BLOCK,-1,,<empty>,59,,18,2,,void
274552,BLOCK,-1,,"{
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }",30,,19,2,,void
274575,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }
  return true;
}",51,,30,5,,void
274601,BLOCK,-1,,<empty>,59,,32,2,,void
274610,BLOCK,-1,,"{
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }",30,,33,2,,void
274633,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;

  if (!value->IsUndefined()) {
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }
  return true;
}",51,,44,5,,void
274659,BLOCK,-1,,<empty>,59,,46,2,,void
274668,BLOCK,-1,,"{
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }",30,,48,2,,void
274688,BLOCK,-1,,"{
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    }",28,,52,2,,void
274707,BLOCK,-1,,"{
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }",22,,55,2,,void
274731,BLOCK,-1,,"{
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }",12,,61,1,,void
274755,BLOCK,-1,,"{
  stats->*member += amt;
}",52,,74,3,,void
274765,BLOCK,-1,,"{
  stats->*member = uv_hrtime();
}",40,,79,2,,void
274776,BLOCK,-1,,"{
  stats->*member = val;
}",42,,84,3,,void
274786,BLOCK,-1,,"{
  return stats->*member;
}",32,,89,2,,void
274817,BLOCK,-1,,<empty>,1,,1,1,,ANY
274832,BLOCK,-1,,<empty>,1,,1,1,,ANY
274865,BLOCK,-1,,<empty>,1,,1,1,,ANY
274896,BLOCK,-1,,<empty>,1,,1,1,,ANY
274917,BLOCK,-1,,<empty>,1,,1,1,,ANY
274932,BLOCK,-1,,<empty>,1,,1,1,,ANY
274949,BLOCK,-1,,<empty>,1,,1,1,,ANY
274966,BLOCK,-1,,<empty>,1,,1,1,,ANY
274995,BLOCK,-1,,<empty>,1,,1,1,,ANY
275016,BLOCK,-1,,<empty>,1,,1,1,,ANY
275035,BLOCK,-1,,<empty>,1,,1,1,,ANY
275050,BLOCK,-1,,<empty>,1,,1,1,,ANY
275073,BLOCK,-1,,<empty>,1,,1,1,,ANY
275094,BLOCK,-1,,<empty>,1,,1,1,,ANY
275105,BLOCK,-1,,<empty>,1,,1,1,,ANY
275116,BLOCK,-1,,<empty>,1,,1,1,,ANY
275121,BLOCK,-1,,"{
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",45,,123,3,,void
275198,BLOCK,-1,,<empty>,1,,1,1,,ANY
275202,BLOCK,-1,,<empty>,,,,2,,<empty>
275213,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }",38,,54,5,,void
275276,BLOCK,-1,,"{
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }",79,,68,2,,void
275298,BLOCK,-1,,"{
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",52,,92,3,,void
275316,BLOCK,-1,,"{
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",60,,97,2,,void
275319,BLOCK,-1,,"{
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }",18,,98,2,,void
275336,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        },
        signum)...",62,,105,2,,void
275369,BLOCK,-1,,<empty>,59,,110,2,,void
275385,BLOCK,-1,,"{
      CHECK(!wrap->active_);
      wrap->active_ = true;
      Mutex::ScopedLock lock(handled_signals_mutex);
      handled_signals[signum]++;
    }",19,,133,2,,void
275415,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",61,,143,2,,void
275428,BLOCK,-1,,"{
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }",25,,147,2,,void
275461,BLOCK,-1,,<empty>,,,,1,,<empty>
275469,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  int64_t new_handler_count = --handled_signals[signum];
  CHECK_GE(new_handler_count, 0);
  if (new_handler_count == 0)
    handled_signals.erase(signum);
}",45,,163,2,,void
275487,BLOCK,-1,,<empty>,5,,168,2,,void
275497,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  return handled_signals.find(signum) != handled_signals.end();
}",37,,171,2,,void
275533,BLOCK,-1,,<empty>,1,,1,1,,ANY
275538,BLOCK,-1,,"{
  if (used() == kBufferSize)
    *buf = uv_buf_init(nullptr, 0);
  else
    *buf = uv_buf_init(data_ + used(), available());
}",60,,54,3,,void
275543,BLOCK,-1,,<empty>,5,,56,2,,void
275551,BLOCK,-1,,<empty>,5,,58,1,,void
275565,BLOCK,-1,,"{
  // If we hand out the same chunk twice, this should catch it.
  CHECK_EQ(buf->base, data_ + used());
  used_ += static_cast<unsigned int>(nread);
}",73,,62,3,,void
275582,BLOCK,-1,,"{
  memcpy(dest, data_, used());
  return used();
}",56,,69,2,,void
275592,BLOCK,-1,,"{
  return sizeof data_ - used();
}",57,,75,1,,void
275601,BLOCK,-1,,"{
  return used_;
}",52,,80,1,,void
275607,BLOCK,-1,,"{
  return next_;
}",64,,85,1,,void
275614,BLOCK,-1,,"{
  next_ = next;
}",71,,90,2,,void
275625,BLOCK,-1,,"{
  CHECK(readable || writable);
}",34,,111,5,,void
275633,BLOCK,-1,,"{
  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);

  SyncProcessOutputBuffer* buf;
  SyncProcessOutputBuffer* next;

  for (buf = first_output_buffer_; buf != nullptr; buf = next) {
    next = buf->next();
    delete buf;
  }
}",47,,116,1,,void
275645,BLOCK,-1,,<empty>,3,,122,1,,void
275655,BLOCK,4,,"{
    next = buf->next();
    delete buf;
  }",64,,122,4,,void
275668,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kUninitialized);

  int r = uv_pipe_init(loop, uv_pipe(), 0);
  if (r < 0)
    return r;

  uv_pipe()->data = this;

  lifecycle_ = kInitialized;
  return 0;
}",55,,129,2,,void
275683,BLOCK,-1,,<empty>,5,,134,2,,void
275699,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kInitialized);

  // Set the busy flag already. If this function fails no recovery is
  // possible.
  lifecycle_ = kStarted;

  if (readable()) {
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }

  if (writable()) {
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }

  return 0;
}",35,,143,1,,void
275708,BLOCK,-1,,"{
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }",19,,150,2,,void
275715,BLOCK,-1,,"{
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }",32,,151,2,,void
275735,BLOCK,-1,,<empty>,9,,160,2,,void
275750,BLOCK,-1,,<empty>,7,,165,2,,void
275755,BLOCK,-1,,"{
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }",19,,168,2,,void
275767,BLOCK,-1,,<empty>,7,,171,2,,void
275775,BLOCK,-1,,"{
  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);

  uv_close(uv_handle(), CloseCallback);

  lifecycle_ = kClosing;
}",36,,178,1,,void
275794,BLOCK,-1,,"{
  size_t length = OutputLength();
  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();
  CopyOutput(Buffer::Data(js_buffer));
  return js_buffer;
}",79,,187,2,,void
275825,BLOCK,-1,,"{
  return readable_;
}",45,,195,1,,void
275831,BLOCK,-1,,"{
  return writable_;
}",45,,200,1,,void
275837,BLOCK,-1,,"{
  unsigned int flags;

  flags = UV_CREATE_PIPE;
  if (readable())
    flags |= UV_READABLE_PIPE;
  if (writable())
    flags |= UV_WRITABLE_PIPE;

  return static_cast<uv_stdio_flags>(flags);
}",55,,205,1,,void
275844,BLOCK,-1,,<empty>,5,,210,2,,void
275850,BLOCK,-1,,<empty>,5,,212,2,,void
275861,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kClosing);
  return &uv_pipe_;
}",50,,218,1,,void
275871,BLOCK,-1,,"{
  return reinterpret_cast<uv_stream_t*>(uv_pipe());
}",54,,224,1,,void
275879,BLOCK,-1,,"{
  return reinterpret_cast<uv_handle_t*>(uv_pipe());
}",54,,229,1,,void
275887,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t size = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    size += buf->used();

  return size;
}",51,,234,1,,void
275894,BLOCK,-1,,<empty>,3,,238,1,,void
275919,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t offset = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    offset += buf->Copy(dest + offset);
}",57,,245,2,,void
275926,BLOCK,-1,,<empty>,3,,249,1,,void
275953,BLOCK,-1,,"{
  // This function assumes that libuv will never allocate two buffers for the
  // same stream at the same time. There's an assert in
  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was
  // ever violated.

  if (last_output_buffer_ == nullptr) {
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  } else if (last_output_buffer_->available() == 0) {
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }

  last_output_buffer_->OnAlloc(suggested_size, buf);
}",74,,254,3,,void
275958,BLOCK,-1,,"{
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  }",39,,260,2,,void
275967,BLOCK,-1,,<empty>,10,,265,1,,void
275975,BLOCK,-1,,"{
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }",53,,265,2,,void
276000,BLOCK,-1,,"{
  if (nread == UV_EOF) {
    // Libuv implicitly stops reading on EOF.

  } else if (nread < 0) {
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  } else {
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }
}",71,,276,3,,void
276005,BLOCK,-1,,"{
    // Libuv implicitly stops reading on EOF.

  }",24,,277,2,,void
276007,BLOCK,-1,,<empty>,10,,280,1,,void
276012,BLOCK,-1,,"{
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  }",25,,280,2,,void
276019,BLOCK,-1,,"{
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }",10,,285,1,,void
276035,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",52,,292,2,,void
276040,BLOCK,-1,,<empty>,5,,294,2,,void
276047,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",55,,298,2,,void
276052,BLOCK,-1,,<empty>,5,,300,2,,void
276058,BLOCK,-1,,"{
  lifecycle_ = kClosed;
}",38,,304,1,,void
276066,BLOCK,-1,,"{
  CHECK_NE(error, 0);
  process_handler_->SetPipeError(error);
}",48,,309,2,,void
276081,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnAlloc(suggested_size, buf);
}",57,,317,4,,void
276102,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);
  self->OnRead(buf, nread);
}",62,,326,4,,void
276122,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);
  self->OnWriteDone(result);
}",71,,333,3,,void
276143,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);

  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe
  // when the other end has closed the connection fails with ENOTCONN.
  // Libuv is not the right place to handle that because it can't tell
  // if the error is genuine but we here can.
  if (result == UV_ENOTCONN)
    result = 0;

  self->OnShutdownDone(result);
}",77,,340,3,,void
276158,BLOCK,-1,,<empty>,5,,349,2,,void
276171,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnClose();
}",63,,355,2,,void
276191,BLOCK,-1,,"{
  SetMethod(context, target, ""spawn"", Spawn);
}",48,,365,5,,void
276201,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kChildProcess, """");
  env->PrintSyncTrace();
  SyncProcessRunner p(env);
  Local<Value> result;
  if (!p.Run(args[0]).ToLocal(&result)) return;
  args.GetReturnValue().Set(result);
}",72,,370,2,,void
276244,BLOCK,-1,,<empty>,41,,377,2,,void
276258,BLOCK,-1,,"{
}",17,,414,2,,void
276262,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kHandlesClosed);

  stdio_pipes_.clear();
  delete[] file_buffer_;
  delete[] args_buffer_;
  delete[] cwd_buffer_;
  delete[] env_buffer_;
  delete[] uv_stdio_containers_;
}",41,,418,1,,void
276283,BLOCK,-1,,"{
  return env_;
}",45,,430,1,,void
276290,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());

  CHECK_EQ(lifecycle_, kUninitialized);

  Maybe<bool> r = TryInitializeAndRunLoop(options);
  CloseHandlesAndDeleteLoop();
  if (r.IsNothing()) return MaybeLocal<Object>();

  Local<Object> result = BuildResultObject();

  return scope.Escape(result);
}",65,,434,2,,void
276311,BLOCK,-1,,<empty>,22,,441,2,,void
276331,BLOCK,-1,,"{
  int r;

  // There is no recovery from failure inside TryInitializeAndRunLoop - the
  // only option we'd have is to close all handles and destroy the loop.
  CHECK_EQ(lifecycle_, kUninitialized);
  lifecycle_ = kInitialized;

  uv_loop_ = new uv_loop_t;
  if (uv_loop_ == nullptr) {
    SetError(UV_ENOMEM);
    return Just(false);
  }

  r = uv_loop_init(uv_loop_);
  if (r < 0) {
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }

  if (!ParseOptions(options).To(&r)) return Nothing<bool>();

  if (r < 0) {
    SetError(r);
    return Just(false);
  }

  if (timeout_ > 0) {
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
   ...",78,,448,2,,void
276347,BLOCK,-1,,"{
    SetError(UV_ENOMEM);
    return Just(false);
  }",28,,457,2,,void
276360,BLOCK,-1,,"{
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }",14,,463,2,,void
276380,BLOCK,-1,,<empty>,38,,470,2,,void
276387,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,472,2,,void
276397,BLOCK,-1,,"{
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
    // which implicitly stops it, so there is no risk that the timeout callback
    // runs when the process didn't start.
    r = uv_timer_start(&uv_timer_, KillTimerCallback, timeout_, 0);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }
  }",21,,477,2,,void
276408,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,479,2,,void
276439,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,494,2,,void
276462,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,502,2,,void
276476,BLOCK,-1,,"{
    if (pipe != nullptr) {
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }
  }",41,,508,3,,void
276481,BLOCK,-1,,"{
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }",26,,509,2,,void
276492,BLOCK,-1,,"{
        SetPipeError(r);
        return Just(false);
      }",18,,511,2,,void
276507,BLOCK,-1,,<empty>,5,,521,2,,void
276518,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (uv_loop_ != nullptr) {
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  } else {
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHEC...",53,,529,1,,void
276526,BLOCK,-1,,"{
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  }",28,,532,2,,void
276546,BLOCK,-1,,<empty>,7,,544,2,,void
276560,BLOCK,-1,,<empty>,7,,550,2,,void
276569,BLOCK,-1,,"{
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHECK_EQ(false, kill_timer_initialized_);
  }",10,,556,1,,void
276582,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (stdio_pipes_initialized_) {
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }
}",43,,566,1,,void
276588,BLOCK,-1,,"{
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }",33,,569,2,,void
276599,BLOCK,-1,,"{
      if (pipe)
        pipe->Close();
    }",43,,573,3,,void
276602,BLOCK,-1,,<empty>,9,,575,2,,void
276613,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (kill_timer_initialized_) {
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }
}",42,,583,1,,void
276619,BLOCK,-1,,"{
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }",32,,586,2,,void
276642,BLOCK,-1,,"{
  // Only attempt to kill once.
  if (killed_)
    return;
  killed_ = true;

  // We might get here even if the process we spawned has already exited. This
  // could happen when our child process spawned another process which
  // inherited (one of) the stdio pipes. In this case we won't attempt to send
  // a signal to the process, however we will still close our end of the stdio
  // pipes so this situation won't make us hang.
  if (exit_status_ < 0) {
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }

  // Close all stdio p...",32,,599,1,,void
276645,BLOCK,-1,,<empty>,5,,602,2,,void
276654,BLOCK,-1,,"{
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }",25,,610,2,,void
276670,BLOCK,-1,,"{
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }",33,,616,2,,void
276684,BLOCK,-1,,"{
  buffered_output_size_ += length;

  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {
    SetError(UV_ENOBUFS);
    Kill();
  }
}",77,,633,2,,void
276696,BLOCK,-1,,"{
    SetError(UV_ENOBUFS);
    Kill();
  }",63,,636,2,,void
276704,BLOCK,-1,,"{
  if (exit_status < 0)
    return SetError(static_cast<int>(exit_status));

  exit_status_ = exit_status;
  term_signal_ = term_signal;
}",70,,643,3,,void
276709,BLOCK,-1,,<empty>,5,,645,2,,void
276724,BLOCK,-1,,"{
  SetError(UV_ETIMEDOUT);
  Kill();
}",46,,652,1,,void
276730,BLOCK,-1,,"{
  if (error_ != 0)
    return error_;
  else
    return pipe_error_;
}",35,,658,1,,void
276735,BLOCK,-1,,<empty>,5,,660,2,,void
276739,BLOCK,-1,,<empty>,5,,662,1,,void
276746,BLOCK,-1,,"{
  if (error_ == 0)
    error_ = error;
}",45,,666,2,,void
276751,BLOCK,-1,,<empty>,5,,668,2,,void
276759,BLOCK,-1,,"{
  if (pipe_error_ == 0)
    pipe_error_ = pipe_error;
}",54,,672,2,,void
276764,BLOCK,-1,,<empty>,5,,674,2,,void
276771,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());
  Local<Context> context = env()->context();

  Local<Object> js_result = Object::New(env()->isolate());

  if (GetError() != 0) {
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }

  if (exit_status_ >= 0) {
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  } else {
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }

  if (term_signal_ > 0)
    js_result->Set(context, env()->signal_string(),
                   String::NewFromUtf8(env()->i...",54,,678,1,,void
276806,BLOCK,-1,,"{
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }",24,,684,2,,void
276832,BLOCK,-1,,"{
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  }",26,,689,2,,void
276837,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    }",27,,690,2,,void
276856,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }",12,,693,1,,void
276881,BLOCK,-1,,"{
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }",10,,698,1,,void
276903,BLOCK,-1,,<empty>,5,,705,2,,void
276930,BLOCK,-1,,<empty>,5,,711,1,,void
276952,BLOCK,-1,,<empty>,5,,715,2,,void
276967,BLOCK,-1,,<empty>,5,,718,1,,void
277017,BLOCK,-1,,"{
  CHECK_GE(lifecycle_, kInitialized);
  CHECK(!stdio_pipes_.empty());

  EscapableHandleScope scope(env()->isolate());
  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());

  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }

  return scope.Escape(
      Array::New(env()->isolate(), js_output.out(), js_output.length()));
}",52,,728,1,,void
277040,BLOCK,-1,,<empty>,3,,735,1,,void
277053,BLOCK,4,,"{
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }",54,,735,4,,void
277072,BLOCK,-1,,<empty>,7,,738,2,,void
277083,BLOCK,-1,,<empty>,7,,740,1,,void
277118,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  int r;

  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  Local<Object> js_options = js_value.As<Object>();

  Local<Value> js_file =
      js_options->Get(context, env()->file_string()).ToLocalChecked();
  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.file = file_buffer_;

  Local<Value> js_args =
      js_options->Get(context, env()->args_string()).ToLocalChecked();
  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);

  Local<Value> js_cwd =
      js_options->Get(context, env()->cwd_string()).ToLocalChecked();
  if (IsSet(js_cwd)) {
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_op...",67,,747,2,,void
277136,BLOCK,-1,,<empty>,30,,752,2,,void
277189,BLOCK,-1,,<empty>,53,,759,2,,void
277196,BLOCK,-1,,<empty>,14,,760,2,,void
277234,BLOCK,-1,,<empty>,58,,765,2,,void
277241,BLOCK,-1,,<empty>,14,,766,2,,void
277271,BLOCK,-1,,<empty>,7,,771,1,,void
277273,BLOCK,-1,,"{
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_options_.cwd = cwd_buffer_;
  }",22,,771,2,,void
277285,BLOCK,-1,,<empty>,53,,772,2,,void
277292,BLOCK,-1,,<empty>,16,,773,2,,void
277320,BLOCK,-1,,<empty>,7,,779,1,,void
277322,BLOCK,-1,,"{
    if (!CopyJsStringArray(js_env_pairs, &env_buffer_).To(&r))
      return Nothing<int>();
    if (r < 0) return Just(r);

    uv_process_options_.env = reinterpret_cast<char**>(env_buffer_);
  }",28,,779,2,,void
277334,BLOCK,-1,,<empty>,7,,781,2,,void
277341,BLOCK,-1,,<empty>,16,,782,2,,void
277371,BLOCK,-1,,<empty>,7,,788,1,,void
277373,BLOCK,-1,,"{
    CHECK(js_uid->IsInt32());
    const int32_t uid = js_uid.As<Int32>()->Value();
    uv_process_options_.uid = static_cast<uv_uid_t>(uid);
    uv_process_options_.flags |= UV_PROCESS_SETUID;
  }",22,,788,2,,void
277420,BLOCK,-1,,<empty>,7,,797,1,,void
277422,BLOCK,-1,,"{
    CHECK(js_gid->IsInt32());
    const int32_t gid = js_gid.As<Int32>()->Value();
    uv_process_options_.gid = static_cast<uv_gid_t>(gid);
    uv_process_options_.flags |= UV_PROCESS_SETGID;
  }",22,,797,2,,void
277474,BLOCK,-1,,<empty>,5,,807,2,,void
277504,BLOCK,-1,,<empty>,5,,812,2,,void
277515,BLOCK,-1,,<empty>,5,,815,2,,void
277545,BLOCK,-1,,<empty>,5,,822,2,,void
277570,BLOCK,-1,,<empty>,7,,826,1,,void
277572,BLOCK,-1,,"{
    CHECK(js_timeout->IsNumber());
    int64_t timeout = js_timeout->IntegerValue(context).FromJust();
    timeout_ = static_cast<uint64_t>(timeout);
  }",26,,826,2,,void
277613,BLOCK,-1,,<empty>,7,,834,1,,void
277615,BLOCK,-1,,"{
    CHECK(js_max_buffer->IsNumber());
    max_buffer_ = js_max_buffer->NumberValue(context).FromJust();
  }",29,,834,2,,void
277650,BLOCK,-1,,<empty>,7,,841,1,,void
277652,BLOCK,-1,,"{
    CHECK(js_kill_signal->IsInt32());
    kill_signal_ = js_kill_signal.As<Int32>()->Value();
  }",30,,841,2,,void
277693,BLOCK,-1,,<empty>,14,,849,2,,void
277704,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Array> js_stdio_options;

  if (!js_value->IsArray())
    return UV_EINVAL;

  Local<Context> context = env()->context();
  js_stdio_options = js_value.As<Array>();

  stdio_count_ = js_stdio_options->Length();
  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];

  stdio_pipes_.clear();
  stdio_pipes_.resize(stdio_count_);
  stdio_pipes_initialized_ = true;

  for (uint32_t i = 0; i < stdio_count_; i++) {
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }

  uv_process_options_.stdio = uv_stdio_containers_;
  uv_process_options_.stdio_count = stdio_count_;

  return 0;
}",65,,855,2,,void
277722,BLOCK,-1,,<empty>,5,,860,2,,void
277764,BLOCK,-1,,<empty>,3,,872,1,,void
277774,BLOCK,4,,"{
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }",47,,872,4,,void
277796,BLOCK,-1,,<empty>,7,,877,2,,void
277812,BLOCK,-1,,<empty>,7,,881,2,,void
277832,BLOCK,-1,,"{
  Local<Context> context = env()->context();
  Local<Value> js_type =
      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();

  if (js_type->StrictEquals(env()->ignore_string())) {
    return AddStdioIgnore(child_fd);

  } else if (js_type->StrictEquals(env()->pipe_string())) {
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
 ...",72,,892,3,,void
277870,BLOCK,-1,,"{
    return AddStdioIgnore(child_fd);

  }",54,,897,2,,void
277875,BLOCK,-1,,<empty>,10,,900,1,,void
277885,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }

    return AddSt...",59,,900,2,,void
277953,BLOCK,-1,,"{
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }",19,,913,2,,void
277973,BLOCK,-1,,<empty>,11,,916,1,,void
277975,BLOCK,-1,,"{
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      }",39,,916,2,,void
277992,BLOCK,-1,,<empty>,14,,919,1,,void
278005,BLOCK,-1,,"{
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }",61,,919,2,,void
278015,BLOCK,-1,,<empty>,10,,929,1,,void
278034,BLOCK,-1,,"{
    int inherit_fd = js_stdio_option->Get(context, env()->fd_string())
        .ToLocalChecked()->Int32Value(context).FromJust();
    return AddStdioInheritFD(child_fd, inherit_fd);

  }",57,,930,2,,void
278062,BLOCK,-1,,"{
    UNREACHABLE(""invalid child stdio type"");
  }",10,,935,1,,void
278069,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_IGNORE;

  return 0;
}",58,,941,2,,void
278094,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  std::unique_ptr<SyncProcessStdioPipe> h(
      new SyncProcessStdioPipe(this, readable, writable, input_buffer));

  int r = h->Initialize(uv_loop_);
  if (r < 0) {
    h.reset();
    return r;
  }

  uv_stdio_containers_[child_fd].flags = h->uv_flags();
  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();

  stdio_pipes_[child_fd] = std::move(h);

  return 0;
}",60,,954,5,,void
278128,BLOCK,-1,,"{
    h.reset();
    return r;
  }",14,,962,2,,void
278173,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;
  uv_stdio_containers_[child_fd].data.fd = inherit_fd;

  return 0;
}",77,,976,3,,void
278204,BLOCK,-1,,"{
  return !value->IsUndefined() && !value->IsNull();
}",51,,987,2,,void
278222,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<String> js_string;
  size_t size, written;
  char* buffer;

  if (js_value->IsString())
    js_string = js_value.As<String>();
  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())
                .ToLocal(&js_string))
    return Nothing<int>();

  // Include space for null terminator byte.
  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))
    return Nothing<int>();
  size += 1;

  buffer = new char[size];

  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);
  buffer[written] = '\0';

  *target = buffer;
  return Just(0);
}",65,,992,3,,void
278243,BLOCK,-1,,<empty>,5,,999,2,,void
278251,BLOCK,-1,,<empty>,8,,1000,1,,void
278270,BLOCK,-1,,<empty>,5,,1002,2,,void
278287,BLOCK,-1,,<empty>,5,,1006,2,,void
278326,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<Array> js_array;
  uint32_t length;
  size_t list_size, data_size, data_offset;
  char** list;
  char* buffer;

  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  js_array = js_value.As<Array>()->Clone().As<Array>();
  length = js_array->Length();
  data_size = 0;

  // Index has a pointer to every string element, plus one more for a final
  // null pointer.
  list_size = (length + 1) * sizeof *list;

  // Convert all array elements to string. Modify the js object itself if
  // needed - it's okay since we cloned the original object. Also compute the
  // length of all strings, including room for a null terminator after every
  // string. Align strings to cache lines.
  for (uint32_t i = 0; i < length; i++) {
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrent...",64,,1019,3,,void
278351,BLOCK,-1,,<empty>,29,,1027,2,,void
278396,BLOCK,-1,,<empty>,3,,1042,1,,void
278406,BLOCK,4,,"{
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }

    Maybe<size_t> maybe_size = StringBytes::StorageSize(isolate, value, UTF8);
    if (maybe_size.IsNothing()) return Nothing<int>();
    data_size += maybe_size.FromJust() + 1;
    data_size = RoundUp(data_size, sizeof(void*));
  }",41,,1042,4,,void
278425,BLOCK,-1,,"{
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }",29,,1045,2,,void
278449,BLOCK,-1,,<empty>,9,,1049,2,,void
278480,BLOCK,-1,,<empty>,33,,1058,2,,void
278510,BLOCK,-1,,<empty>,3,,1068,1,,void
278520,BLOCK,4,,"{
    list[i] = buffer + data_offset;
    auto value = js_array->Get(context, i).ToLocalChecked();
    data_offset += StringBytes::Write(isolate,
                                      buffer + data_offset,
                                      -1,
                                      value,
                                      UTF8);
    buffer[data_offset++] = '\0';
    data_offset = RoundUp(data_offset, sizeof(void*));
  }",41,,1068,4,,void
278584,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);
  self->OnExit(exit_status, term_signal);
}",55,,1089,4,,void
278608,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  self->OnKillTimerTimeout();
}",63,,1096,2,,void
278625,BLOCK,-1,,"{
  // No-op.
}",69,,1102,2,,void
278639,BLOCK,-1,,<empty>,1,,1,1,,ANY
278654,BLOCK,-1,,<empty>,1,,1,1,,ANY
278685,BLOCK,-1,,<empty>,1,,1,1,,ANY
278689,BLOCK,-1,,"{
  Environment* env = stream_env();

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  BaseObjectPtr<AsyncWrap> req_wrap_ptr;
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj);
  if (req_wrap != nullptr) req_wrap_ptr.reset(req_wrap->GetAsyncWrap());
  int err = DoShutdown(req_wrap);

  if (err != 0 && req_wrap != nullptr) {
    req_wrap->Dispose();
  }

  const char* msg = Error();
  if (msg != nullptr) {
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }

  return err;
}",62,,43,2,,void
278705,BLOCK,-1,,"{
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,48,2,,void
278724,BLOCK,-1,,"{
      return UV_EBUSY;
    }",39,,51,2,,void
278749,BLOCK,-1,,<empty>,28,,60,2,,void
278771,BLOCK,-1,,"{
    req_wrap->Dispose();
  }",40,,63,2,,void
278784,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }",23,,68,2,,void
278807,BLOCK,-1,,"{
      return UV_EBUSY;
    }",27,,73,2,,void
278821,BLOCK,-1,,"{
  Environment* env = stream_env();
  int err;

  size_t total_bytes = 0;
  for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len;
  bytes_written_ += total_bytes;

  if (send_handle == nullptr && !skip_try_write) {
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);
  BaseObjectPtr<AsyncWrap> req_wrap_ptr(req_wrap->GetAsyncWrap());

  err = DoWrite(req_wrap, bufs, count, send_handle);
  bool async = err == 0;

  if (!async) {
    req_wrap...",58,,86,6,,void
278832,BLOCK,-1,,<empty>,3,,91,1,,void
278859,BLOCK,-1,,"{
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }",50,,94,2,,void
278875,BLOCK,-1,,"{
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }",33,,96,2,,void
278895,BLOCK,-1,,"{
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,103,2,,void
278914,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",39,,106,2,,void
278961,BLOCK,-1,,"{
    req_wrap->Dispose();
    req_wrap = nullptr;
  }",15,,119,2,,void
278977,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    ClearError();
  }",23,,125,2,,void
279000,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",27,,130,2,,void
279026,BLOCK,-1,,"{
  return ReadStart();
}",70,,150,2,,void
279033,BLOCK,-1,,"{
  return ReadStop();
}",69,,155,2,,void
279040,BLOCK,-1,,"{
  CHECK(Buffer::HasInstance(args[0]));

  uv_buf_t buf = uv_buf_init(Buffer::Data(args[0]), Buffer::Length(args[0]));
  PushStreamListener(new CustomBufferJSListener(buf));
  return 0;
}",72,,159,2,,void
279077,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Local<Object> req_wrap_obj = args[0].As<Object>();

  return Shutdown(req_wrap_obj);
}",67,,167,2,,void
279104,BLOCK,-1,,"{
  env_->stream_base_state()[kBytesWritten] = res.bytes;
  env_->stream_base_state()[kLastWriteWasAsync] = res.async;
}",63,,174,2,,void
279129,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<Array> chunks = args[1].As<Array>();
  bool all_buffers = args[2]->IsTrue();

  size_t count;
  if (all_buffers)
    count = chunks->Length();
  else
    count = chunks->Length() >> 1;

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  size_t storage_size = 0;
  size_t offset;

  if (!all_buffers) {
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_ch...",65,,179,2,,void
279205,BLOCK,-1,,<empty>,5,,193,2,,void
279213,BLOCK,-1,,<empty>,5,,195,1,,void
279238,BLOCK,-1,,"{
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }

    if (storage_size > INT_MAX)
      return UV_E...",21,,202,2,,void
279240,BLOCK,-1,,<empty>,5,,204,1,,void
279250,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }",40,,204,4,,void
279271,BLOCK,-1,,<empty>,9,,207,2,,void
279276,BLOCK,-1,,<empty>,11,,209,1,,void
279278,BLOCK,-1,,<empty>,9,,210,2,,void
279297,BLOCK,-1,,<empty>,9,,216,2,,void
279323,BLOCK,-1,,<empty>,9,,219,2,,void
279373,BLOCK,-1,,"{
        return -1;
      }",37,,226,2,,void
279384,BLOCK,-1,,<empty>,7,,233,2,,void
279388,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }
  }",10,,234,1,,void
279390,BLOCK,-1,,<empty>,5,,235,1,,void
279400,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }",40,,235,4,,void
279419,BLOCK,-1,,<empty>,9,,238,2,,void
279456,BLOCK,-1,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
  }",25,,245,2,,void
279477,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    ...",21,,251,2,,void
279479,BLOCK,-1,,<empty>,5,,252,1,,void
279489,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    string,
                                 ...",40,,252,4,,void
279510,BLOCK,-1,,<empty>,9,,255,2,,void
279515,BLOCK,-1,,<empty>,11,,258,1,,void
279517,BLOCK,-1,,"{
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }",39,,258,2,,void
279587,BLOCK,-1,,<empty>,9,,272,2,,void
279613,BLOCK,-1,,<empty>,9,,275,2,,void
279672,BLOCK,-1,,<empty>,5,,291,2,,void
279692,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }

  StreamWriteResult res = Write(&buf, 1,...",70,,296,2,,void
279716,BLOCK,-1,,"{
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }",33,,301,2,,void
279773,BLOCK,-1,,"{
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",43,,313,2,,void
279817,BLOCK,-1,,"{
      return -1;
    }",57,,323,2,,void
279840,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  Local<Object> send_handle_obj;
  if (args[2]->IsObject())
    send_handle_obj = args[2].As<Object>();

  // Compute the size of the storage that the string will be flattened into.
  // For UTF8 strings that are very long, go ahead and take the hit for
  // computing their actual size, rather than tripling the storage.
  size_t storage_size;
  if ((enc == UTF8 &&
         string->Length() > 65535 &&
         !StringBytes::Size(isolate, string, enc).To(&storage_size)) ||
          !StringBytes::StorageSize(isolate, string, enc).To(&storage_size)) {
    return -1;
  }

  if (storage_size > INT_MAX)
    return UV_ENOBUFS;

  // Try writing immediately if write size isn't too big
  char stack_storage[16384];  // 16kb
  size_t data_size;
 ...",70,,336,2,,void
279906,BLOCK,-1,,<empty>,5,,346,2,,void
279955,BLOCK,-1,,"{
    return -1;
  }",78,,355,2,,void
279963,BLOCK,-1,,<empty>,5,,360,2,,void
279990,BLOCK,-1,,"{
    data_size = StringBytes::Write(isolate,
                                   stack_storage,
                                   storage_size,
                                   string,
                                   enc);
    buf = uv_buf_init(stack_storage, data_size);

    uv_buf_t* bufs = &buf;
    size_t count = 1;
    const int err = DoTryWrite(&bufs, &count);
    // Keep track of the bytes written here, because we're taking a shortcut
    // by using `DoTryWrite()` directly instead of using the utilities
    // provided by `Write()`.
    synchronously_written = count == 0 ? data_size : data_size - buf.len;
    bytes_written_ += synchronously_written;

    // Immediate failure or success
    if (err != 0 || count == 0) {
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }

    // Partial write
    CHECK_EQ(count, 1);
  }",18,,370,2,,void
280047,BLOCK,-1,,"{
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }",33,,388,2,,void
280070,BLOCK,-1,,"{
    // Copy partial data
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, buf.len);
    memcpy(static_cast<char*>(bs->Data()), buf.base, buf.len);
    data_size = buf.len;
  }",18,,399,2,,void
280106,BLOCK,-1,,"{
    // Write it
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
    data_size = StringBytes::Write(isolate,
                                   static_cast<char*>(bs->Data()),
                                   storage_size,
                                   string,
                                   enc);
  }",10,,405,1,,void
280162,BLOCK,-1,,"{
    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",50,,422,2,,void
280194,BLOCK,-1,,"{
      return -1;
    }",57,,430,2,,void
280221,BLOCK,-1,,<empty>,5,,440,2,,void
280244,BLOCK,-1,,"{
  Environment* env = env_;

  DCHECK_EQ(static_cast<int32_t>(nread), nread);
  DCHECK_LE(offset, INT32_MAX);

  if (checks == DONT_SKIP_NREAD_CHECKS) {
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }

  env->stream_base_state()[kReadBytesOrError] = static_cast<int32_t>(nread);
  env->stream_base_state()[kArrayBufferOffset] = offset;

  Local<Value> argv[] = {
    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()
  };

  AsyncWrap* wrap = GetAsyncWrap();
  CHECK_NOT_NULL(wrap);
  Local<Value> onread = wrap->object()->GetInternalField(
      StreamBase::kOnReadFunctionField);
  CHECK(onread->IsFunction());
  return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv);
}",77,,449,5,,void
280261,BLOCK,-1,,"{
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }",41,,455,2,,void
280267,BLOCK,-1,,"{
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    }",23,,456,2,,void
280275,BLOCK,-1,,"{
      DCHECK_GE(nread, 0);
    }",12,,459,1,,void
280360,BLOCK,-1,,"{
  return false;
}",30,,480,1,,void
280366,BLOCK,-1,,"{
  return -1;
}",25,,485,1,,void
280373,BLOCK,-1,,"{
  return GetAsyncWrap()->object();
}",39,,490,1,,void
280388,BLOCK,-1,,"{
  Local<FunctionTemplate> templ =
      NewFunctionTemplate(isolate,
                          stream_method,
                          signature,
                          ConstructorBehavior::kThrow,
                          SideEffectType::kHasNoSideEffect);
  t->PrototypeTemplate()->SetAccessorProperty(
      string, templ, Local<FunctionTemplate>(), attributes);
}",50,,499,7,,void
280421,BLOCK,-1,,"{
  AddMethods(env->isolate_data(), t);
}",74,,510,3,,void
280433,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum);
  Local<Signature> sig = Signature::New(isolate, t);

  AddMethod(isolate, sig, attributes, t, GetFD, isolate_data->fd_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetExternal,
            isolate_data->external_stream_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesRead,
            isolate_data->bytes_read_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesWritten,
            isolate_data->bytes_written_string());
  SetProtoMethod(isolate, t, ""readStart"", JSMethod<&StreamBase::ReadStartJS>);
  SetProtoMethod(isolate, t, ""readStop"", JSMethod<&StreamBase::ReadStopJS>);
  SetProtoMethod(isolate, t, ""shutdown"", JSMethod<&StreamBa...",56,,515,3,,void
280588,BLOCK,-1,,"{
  // This function is called by a single thread during start up, so it is safe
  // to use a local static variable here.
  static bool is_registered = false;
  if (is_registered) return;
  registry->Register(GetFD);
  registry->Register(GetExternal);
  registry->Register(GetBytesRead);
  registry->Register(GetBytesWritten);
  registry->Register(JSMethod<&StreamBase::ReadStartJS>);
  registry->Register(JSMethod<&StreamBase::ReadStopJS>);
  registry->Register(JSMethod<&StreamBase::Shutdown>);
  registry->Register(JSMethod<&StreamBase::UseUserBuffer>);
  registry->Register(JSMethod<&StreamBase::Writev>);
  registry->Register(JSMethod<&StreamBase::WriteBuffer>);
  registry->Register(JSMethod<&StreamBase::WriteString<ASCII>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UTF8>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UCS2>>);
  registry->Register(JSMethod<&StreamBase::WriteString<LATIN1>>);
  registry->Register(
      BaseObject::InternalFieldGet<StreamBase::...",42,,571,2,,void
280595,BLOCK,-1,,<empty>,22,,575,2,,void
280688,BLOCK,-1,,"{
  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL);

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  args.GetReturnValue().Set(wrap->GetFD());
}",65,,598,2,,void
280707,BLOCK,-1,,<empty>,24,,601,2,,void
280723,BLOCK,-1,,<empty>,25,,603,2,,void
280748,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
}",72,,608,2,,void
280767,BLOCK,-1,,<empty>,24,,610,2,,void
280793,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_written_));
}",75,,616,2,,void
280812,BLOCK,-1,,<empty>,24,,618,2,,void
280838,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return;

  Local<External> ext = External::New(args.GetIsolate(), wrap);
  args.GetReturnValue().Set(ext);
}",71,,624,2,,void
280857,BLOCK,-1,,<empty>,24,,626,2,,void
280886,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
  if (wrap == nullptr) return;

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap->GetAsyncWrap());
  args.GetReturnValue().Set((wrap->*Method)(args));
}",68,,633,2,,void
280905,BLOCK,-1,,<empty>,24,,635,2,,void
280913,BLOCK,-1,,<empty>,25,,637,2,,void
280946,BLOCK,-1,,"{
  // No TryWrite by default
  return 0;
}",64,,643,3,,void
280952,BLOCK,-1,,"{
  return nullptr;
}",43,,649,1,,void
280958,BLOCK,-1,,"{
  // No-op
}",35,,654,1,,void
280963,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();
  return env->allocate_managed_buffer(suggested_size);
}",71,,659,2,,void
280985,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);

  if (nread <= 0)  {
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
  bs = BackingStore::Reallocate(isolate, std::move(bs), nread);

  stream->CallJSOnreadMethod(nread, ArrayBuffer::New(isolate, std::move(bs)));
}",80,,665,3,,void
281033,BLOCK,-1,,"{
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",20,,674,2,,void
281038,BLOCK,-1,,<empty>,7,,676,2,,void
281086,BLOCK,-1,,"{
  return buffer_;
}",71,,687,2,,void
281094,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);

  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // In the case that there's an error and buf is null, return immediately.
  // This can happen on unices when POLLHUP is received and UV_EOF is returned
  // or when getting an error while performing a UV_HANDLE_ZERO_READ on Windows.
  if (buf.base == nullptr && nread < 0) {
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_EQ(buf.base, buffer_.base);

  MaybeLocal<Value> ret = stream->CallJSOnreadMethod(nread,
                             Local<ArrayBuffer>(),
                             0,
                             StreamBase::SKIP_NREAD_CHECKS);
  Local<Value> next_buf_v;
  if (ret.ToLocal(&next_buf_v) && !next_buf_v->IsUndefined()) {
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_bu...",79,,692,3,,void
281131,BLOCK,-1,,"{
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",41,,703,2,,void
281180,BLOCK,-1,,"{
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_buf_v);
  }",63,,715,2,,void
281204,BLOCK,-1,,"{
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  if (!env->can_call_into_js()) return;
  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  CHECK(!async_wrap->persistent().IsEmpty());
  Local<Object> req_wrap_obj = async_wrap->object();

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    stream->GetObject(),
    Undefined(env->isolate())
  };

  const char* msg = stream->Error();
  if (msg != nullptr) {
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }

  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())
    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",38,,723,3,,void
281224,BLOCK,-1,,<empty>,33,,726,2,,void
281297,BLOCK,-1,,"{
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }",23,,740,2,,void
281328,BLOCK,-1,,<empty>,5,,746,2,,void
281345,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",38,,750,3,,void
281354,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",41,,755,3,,void
281362,BLOCK,-1,,"{
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",39,,759,2,,void
281374,BLOCK,-1,,"{
  stream()->EmitAfterWrite(this, status);
  Dispose();
}",36,,764,2,,void
281385,BLOCK,-1,,"{
  if (stream_ != nullptr)
    stream_->RemoveStreamListener(this);
}",35,,769,1,,void
281390,BLOCK,-1,,<empty>,5,,771,2,,void
281401,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterShutdown(w, status);
}",73,,774,3,,void
281414,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterWrite(w, status);
}",67,,779,3,,void
281425,BLOCK,-1,,"{
  while (listener_ != nullptr) {
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didn’t remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }
}",35,,784,1,,void
281430,BLOCK,-1,,"{
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didn’t remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }",32,,785,2,,void
281443,BLOCK,-1,,<empty>,7,,793,2,,void
281449,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener);

  StreamListener* previous;
  StreamListener* current;

  // Remove from the linked list.
  // No loop condition because we want a crash if listener is not found.
  for (current = listener_, previous = nullptr;;
       previous = current, current = current->previous_listener_) {
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }

  listener->stream_ = nullptr;
  listener->previous_listener_ = nullptr;
}",69,,797,2,,void
281455,BLOCK,-1,,<empty>,3,,805,1,,void
281472,BLOCK,4,,"{
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }",67,,806,4,,void
281479,BLOCK,-1,,"{
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }",30,,808,2,,void
281484,BLOCK,-1,,<empty>,9,,810,2,,void
281493,BLOCK,-1,,<empty>,9,,812,1,,void
281514,BLOCK,-1,,"{
  auto* wrap = new SimpleShutdownWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,822,2,,void
281532,BLOCK,-1,,"{
  auto* wrap = new SimpleWriteWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,829,2,,void
281551,BLOCK,-1,,"{
  AsyncWrap* async_wrap = GetAsyncWrap();
  Environment* env = async_wrap->env();
  if (error_str != nullptr) {
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }

  OnDone(status);
}",57,,835,3,,void
281567,BLOCK,-1,,"{
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }",29,,838,2,,void
281599,BLOCK,-1,,"{
      return;
    }",27,,844,2,,void
281619,BLOCK,-1,,<empty>,1,,1,1,,ANY
281623,BLOCK,-1,,"{
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        source_v.As<Object>()
            ->Set(en...",60,,71,2,,void
281670,BLOCK,-1,,<empty>,7,,78,2,,void
281688,BLOCK,-1,,"{
      return;
    }",70,,80,2,,void
281761,BLOCK,-1,,"{
      return;
    }",55,,91,2,,void
281837,BLOCK,-1,,"{
      return;
    }",27,,102,2,,void
281853,BLOCK,-1,,<empty>,1,,1,1,,ANY
281859,BLOCK,-1,,"{
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}",76,,25,4,,void
281886,BLOCK,-1,,"{
  Unpipe(true);
}",27,,37,1,,void
281892,BLOCK,-1,,"{
  return static_cast<StreamBase*>(readable_listener_.stream());
}",34,,41,1,,void
281903,BLOCK,-1,,"{
  return static_cast<StreamBase*>(writable_listener_.stream());
}",32,,45,1,,void
281915,BLOCK,-1,,"{
  if (is_closed_)
    return;

  // Note that we possibly cannot use virtual methods on `source` and `sink`
  // here, because this function can be called from their destructors via
  // `OnStreamDestroy()`.
  if (!source_destroyed_)
    source()->ReadStop();

  is_closed_ = true;
  is_reading_ = false;
  source()->RemoveStreamListener(&readable_listener_);
  if (pending_writes_ == 0)
    sink()->RemoveStreamListener(&writable_listener_);

  if (is_in_deletion) return;

  // Delay the JS-facing part with SetImmediate, because this might be from
  // inside the garbage collector, so we can’t run JS here.
  HandleScope handle_scope(env()->isolate());
  BaseObjectPtr<StreamPipe> strong_ref{this};
  env()->SetImmediate([this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToL...",46,,49,2,,void
281918,BLOCK,-1,,<empty>,5,,51,2,,void
281923,BLOCK,-1,,<empty>,5,,57,2,,void
281944,BLOCK,-1,,<empty>,5,,63,2,,void
281953,BLOCK,-1,,<empty>,23,,65,2,,void
281977,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}",77,,108,2,,void
282015,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If we’re not writing, close now. Otherwise, we’ll do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}",71,,116,3,,void
282045,BLOCK,-1,,"{
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If we’re not writing, close now. Otherwise, we’ll do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }",18,,119,2,,void
282077,BLOCK,-1,,"{
      sink->Shutdown();
      pipe->Unpipe();
    }",37,,131,2,,void
282102,BLOCK,-1,,"{
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}",64,,142,3,,void
282137,BLOCK,-1,,"{
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  }",19,,147,2,,void
282147,BLOCK,-1,,"{
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }",10,,149,1,,void
282166,BLOCK,-1,,<empty>,7,,153,2,,void
282176,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }

  if (!pipe->uses_wants_write_) {
    OnStreamWantsWrite(65536);
  }
}",67,,158,3,,void
282194,BLOCK,-1,,"{
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }",25,,161,2,,void
282201,BLOCK,-1,,"{
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }",37,,162,2,,void
282235,BLOCK,-1,,<empty>,9,,167,2,,void
282247,BLOCK,-1,,"{
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }",22,,173,2,,void
282279,BLOCK,-1,,"{
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }",20,,182,2,,void
282301,BLOCK,-1,,"{
    OnStreamWantsWrite(65536);
  }",33,,190,2,,void
282309,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}",70,,196,3,,void
282337,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}",54,,204,1,,void
282357,BLOCK,-1,,"{
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }",23,,207,2,,void
282366,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}",54,,212,1,,void
282399,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}",78,,220,2,,void
282422,BLOCK,-1,,<empty>,5,,224,2,,void
282455,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}",77,,232,2,,void
282468,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}",70,,238,3,,void
282483,BLOCK,-1,,"{
  std::unique_ptr<StreamPipe> stream_pipe(new StreamPipe(source, sink, obj));

  // Set up links between this object and the source/sink objects.
  // In particular, this makes sure that they are garbage collected as a group,
  // if that applies to the given streams (for example, Http2Streams use
  // weak references).
  Environment* env = source->stream_env();
  if (obj->Set(env->context(), env->source_string(), source->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (source->GetObject()
          ->Set(env->context(), env->pipe_target_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (obj->Set(env->context(), env->sink_string(), sink->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (sink->GetObject()
          ->Set(env->context(), env->pipe_source_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }

  return Just(stream_pipe.release());
}",55,,245,4,,void
282523,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,254,2,,void
282546,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,259,2,,void
282569,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,263,2,,void
282592,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,268,2,,void
282605,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}",63,,275,2,,void
282665,BLOCK,-1,,<empty>,63,,282,2,,void
282671,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}",65,,285,2,,void
282696,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->Unpipe();
}",66,,292,2,,void
282713,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->is_closed_);
}",68,,298,2,,void
282736,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->pending_writes_);
}",73,,304,2,,void
282763,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, ""unpipe"", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, ""start"", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, ""isClosed"", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, ""pendingWrites"", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, ""StreamPipe"", pipe);
}",39,,315,5,,void
282851,BLOCK,-1,,<empty>,1,,1,1,,ANY
282857,BLOCK,-1,,"{
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      }",69,,205,4,,void
282876,BLOCK,-1,,"{
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      }",67,,209,4,,void
282935,BLOCK,-1,,<empty>,1,,1,1,,ANY
282939,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}",71,,61,2,,void
282960,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""callback""),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""handle""),
                              v8::Null(isolate));

  sw->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetConstructorFunction(context, target, ""ShutdownWrap"", sw);
  env->set_shutdown_wrap_template(sw->InstanceTemplate());

  Local<FunctionTemplate> ww =
  ...",46,,69,5,,void
283112,BLOCK,1,,<empty>,,,,7,,void
283114,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kReadBytesOrError)",3,,103,1,,void
283211,BLOCK,1,,<empty>,,,,7,,void
283213,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kArrayBufferOffset)",3,,104,1,,void
283310,BLOCK,1,,<empty>,,,,7,,void
283312,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBytesWritten)",3,,105,1,,void
283409,BLOCK,1,,<empty>,,,,7,,void
283411,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync)",3,,106,1,,void
283525,BLOCK,-1,,"{
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}",42,,115,2,,void
283553,BLOCK,-1,,"{
  StreamBase::AttachToObject(object);
}",23,,131,5,,void
283563,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->...",23,,137,2,,void
283579,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->set_libuv_stream_wrap_ctor_template(tmpl);
  }",23,,139,2,,void
283678,BLOCK,-1,,"{
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}",80,,164,3,,void
283710,BLOCK,-1,,"{
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}",30,,171,1,,void
283720,BLOCK,-1,,<empty>,5,,177,2,,void
283732,BLOCK,-1,,"{
  return HandleWrap::IsAlive(this);
}",33,,183,1,,void
283742,BLOCK,-1,,"{
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}",35,,188,1,,void
283751,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",44,,193,1,,void
283759,BLOCK,-1,,"{
  return is_named_pipe_ipc();
}",35,,198,1,,void
283765,BLOCK,-1,,"{
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}",34,,202,1,,void
283774,BLOCK,-1,,"{
  return uv_read_stop(stream());
}",33,,218,1,,void
283783,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}",71,,223,3,,void
283806,BLOCK,-1,,"{
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                ""Can only accept stream handles"");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}",65,,232,3,,void
283847,BLOCK,-1,,<empty>,5,,241,2,,void
283878,BLOCK,-1,,<empty>,5,,249,2,,void
283891,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
 ...",75,,254,3,,void
283917,BLOCK,-1,,"{
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }",74,,260,2,,void
283934,BLOCK,-1,,"{
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
             ->Set(env()->context(),
                   env()->pending_handle_string(),
                   local_pending_obj)
             .IsNothing())) {
      return Nothing<void>();
    }
  }",18,,268,2,,void
283944,BLOCK,-1,,"{
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    }",25,,271,2,,void
283956,BLOCK,-1,,<empty>,12,,273,1,,void
283961,BLOCK,-1,,"{
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    }",39,,273,2,,void
283973,BLOCK,-1,,<empty>,12,,275,1,,void
283978,BLOCK,-1,,"{
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    }",32,,275,2,,void
283990,BLOCK,-1,,"{
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }",12,,277,1,,void
284028,BLOCK,-1,,"{
      return Nothing<void>();
    }",29,,288,2,,void
284041,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}",46,,298,2,,void
284057,BLOCK,-1,,"{
    info.GetReturnValue().Set(0);
    return;
  }",34,,302,2,,void
284088,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}",76,,312,2,,void
284109,BLOCK,-1,,<empty>,5,,318,2,,void
284147,BLOCK,-1,,"{
  return new LibuvShutdownWrap(this, object);
}",73,,327,2,,void
284157,BLOCK,-1,,"{
  return new LibuvWriteWrap(this, object);
}",67,,331,2,,void
284167,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}",58,,336,2,,void
284187,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",71,,342,3,,void
284228,BLOCK,-1,,"{
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}",65,,356,3,,void
284255,BLOCK,-1,,<empty>,5,,364,2,,void
284262,BLOCK,-1,,<empty>,5,,366,2,,void
284269,BLOCK,-1,,<empty>,3,,371,1,,void
284278,BLOCK,4,,"{
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }",41,,371,4,,void
284287,BLOCK,-1,,"{
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    }",33,,373,2,,void
284307,BLOCK,-1,,"{
      written -= vbufs[0].len;
    }",12,,380,1,,void
284332,BLOCK,-1,,"{
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}",56,,395,5,,void
284355,BLOCK,-1,,"{
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",65,,407,3,,void
284404,BLOCK,-1,,<empty>,1,,1,1,,ANY
284429,BLOCK,-1,,<empty>,1,,1,1,,ANY
284434,BLOCK,-1,,"{
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",28,,58,1,,void
284448,BLOCK,-1,,"{
    return data_;
  }",41,,63,1,,void
284454,BLOCK,-1,,"{
    return length_;
  }",34,,67,1,,void
284460,BLOCK,-1,,"{
    return length() * sizeof(*data());
  }",31,,71,1,,void
284474,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }",61,,78,5,,void
284479,BLOCK,-1,,<empty>,7,,80,2,,void
284490,BLOCK,1,,<empty>,,,,1,,void
284492,BLOCK,-1,,<empty>,7,,83,2,,void
284513,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",30,,86,2,,void
284548,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }",53,,102,5,,void
284553,BLOCK,-1,,<empty>,7,,104,2,,void
284564,BLOCK,1,,<empty>,,,,1,,void
284566,BLOCK,-1,,"{
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }",31,,106,2,,void
284612,BLOCK,-1,,"{
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }",24,,118,2,,void
284633,BLOCK,-1,,{ return isolate_; },35,,127,1,,void
284642,BLOCK,-1,,{ },55,,131,4,,void
284648,BLOCK,-1,,<empty>,,,,3,,<empty>
284656,BLOCK,-1,,<empty>,,,,5,,<empty>
284667,BLOCK,-1,,"{
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,155,3,,void
284684,BLOCK,-1,,"{
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,162,3,,void
284703,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,170,5,,void
284729,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,176,2,,void
284752,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,188,5,,void
284776,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,194,2,,void
285740,BLOCK,-1,,"{
  return unhex_table[x];
}",41,,243,2,,void
285752,BLOCK,-1,,"{
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }

  return i;
}",47,,251,5,,void
285755,BLOCK,-1,,<empty>,3,,253,1,,void
285772,BLOCK,4,,"{
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }",51,,253,4,,void
285807,BLOCK,-1,,<empty>,7,,257,2,,void
285829,BLOCK,-1,,"{
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcpy(buf + nchars * sizeof(*dst), &last, sizeof(last));
  nchars++;

  return nchars * sizeof(*dst);
}",79,,265,6,,void
285848,BLOCK,-1,,"{
    return 0;
  }",23,,269,2,,void
285864,BLOCK,-1,,"{
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }",27,,275,2,,void
285908,BLOCK,-1,,"{
    return 0;
  }",23,,284,2,,void
285978,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  S...",51,,306,6,,void
286016,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }

    case BASE64URL:
      // Fall through
    case BASE64:
      if (str->IsExternalOneByte()) {
    ...",21,,317,2,,void
286026,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      }",37,,320,2,,void
286053,BLOCK,-1,,"{
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }",14,,324,1,,void
286090,BLOCK,15,,"{
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }",16,,335,15,,void
286101,BLOCK,-1,,<empty>,9,,343,2,,void
286115,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = base64_decode(buf, buflen, ext->data(), ext->length());
      }",37,,351,2,,void
286137,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = base64_decode(buf, buflen, *value, value.length());
      }",14,,354,1,,void
286161,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = hex_decode(buf, buflen, ext->data(), ext->length());
      }",37,,361,2,,void
286183,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = hex_decode(buf, buflen, *value, value.length());
      }",14,,364,1,,void
286211,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t data_size = 0;
  bool is_buffer = Buffer::HasInstance(val);

  if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""inval...",64,,382,4,,void
286237,BLOCK,-1,,"{
    return Just(Buffer::Length(val));
  }",64,,387,2,,void
286265,BLOCK,-1,,<empty>,5,,393,2,,void
286270,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""invalid hex string length"");
      data_size = str->Length() / 2;
      break;

    default:
      UNREACHABLE(""unknown encoding"");
  }",21,,395,2,,void
286353,BLOCK,-1,,"{
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }

  UNREACHABLE();
}",57,,433,4,,void
286371,BLOCK,-1,,<empty>,5,,437,2,,void
286399,BLOCK,-1,,<empty>,5,,441,2,,void
286404,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }",21,,443,2,,void
286447,BLOCK,18,,"{
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }",18,,457,18,,void
286481,BLOCK,-1,,"{
  for (size_t i = 0; i < len; ++i) {
    dst[i] = src[i] & 0x7f;
  }
}",70,,469,4,,void
286483,BLOCK,-1,,<empty>,3,,470,1,,void
286493,BLOCK,4,,"{
    dst[i] = src[i] & 0x7f;
  }",36,,470,4,,void
286509,BLOCK,-1,,"{
  if (len < 16) {
    force_ascii_slow(src, dst, len);
    return;
  }

  const unsigned bytes_per_word = sizeof(uintptr_t);
  const unsigned align_mask = bytes_per_word - 1;
  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;
  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;

  if (src_unalign > 0) {
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }

#if defined(_WIN64) || defined(_LP64)
  const uintptr_t mask = ~0x8080808080808080ll;
#else
  const uintptr_t mask = ~0x80808080l;
#endif

  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);
  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);

  for (size_t i = 0, n = len / bytes_per_word; i < n; ++i) {
    dstw[i] = srcw[i] & ma...",65,,476,4,,void
286514,BLOCK,-1,,"{
    force_ascii_slow(src, dst, len);
    return;
  }",17,,477,2,,void
286551,BLOCK,-1,,"{
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }",24,,487,2,,void
286556,BLOCK,-1,,"{
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    }",37,,488,2,,void
286577,BLOCK,-1,,"{
      force_ascii_slow(src, dst, len);
      return;
    }",12,,494,1,,void
286601,BLOCK,-1,,<empty>,3,,509,1,,void
286617,BLOCK,4,,"{
    dstw[i] = srcw[i] & mask;
  }",60,,509,4,,void
286637,BLOCK,-1,,"{
    const size_t offset = len - remainder;
    force_ascii_slow(src + offset, dst + offset, remainder);
  }",22,,514,2,,void
286659,BLOCK,-1,,"{
  // We know how much we'll write, just make sure that there's space.
  CHECK(dlen >= slen * 2 &&
      ""not enough space provided for hex encode"");

  dlen = slen * 2;
  for (uint32_t i = 0, k = 0; k < dlen; i += 1, k += 2) {
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }

  return dlen;
}",18,,525,5,,void
286674,BLOCK,-1,,<empty>,3,,531,1,,void
286693,BLOCK,4,,"{
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }",57,,531,4,,void
286735,BLOCK,-1,,"{
  size_t dlen = slen * 2;
  std::string dst(dlen, '\0');
  hex_encode(src, slen, dst.data(), dlen);
  return dst;
}",67,,541,3,,void
286764,BLOCK,-1,,"{
  CHECK_BUFLEN_IN_RANGE(buflen);

  if (!buflen && encoding != BUFFER) {
    return String::Empty(isolate);
  }

  MaybeLocal<String> val;

  switch (encoding) {
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = S...",60,,561,6,,void
286767,BLOCK,1,,<empty>,,,,2,,void
286769,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,1,,void
286776,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,2,,void
286795,BLOCK,-1,,"{
    return String::Empty(isolate);
  }",38,,564,2,,void
286809,BLOCK,-1,,"{
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                 ...",21,,570,2,,void
286812,BLOCK,3,,"{
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }",7,,572,3,,void
286838,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }",39,,575,2,,void
286860,BLOCK,-1,,"{
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      }",67,,582,2,,void
286873,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,585,2,,void
286898,BLOCK,-1,,"{
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }",14,,591,1,,void
286910,BLOCK,9,,"{
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                  buflen);
        Local<String> str;
        if (!val.ToLocal(&str)) {
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }
        return str;
      }",7,,596,9,,void
286938,BLOCK,-1,,"{
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }",33,,602,2,,void
286962,BLOCK,15,,"{
      size_t dlen = base64_encoded_size(buflen);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",18,,611,15,,void
286980,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,614,2,,void
287013,BLOCK,18,,"{
      size_t dlen = base64_encoded_size(buflen, Base64Mode::URL);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen, Base64Mode::URL);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",21,,625,18,,void
287034,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,628,2,,void
287070,BLOCK,21,,"{
      size_t dlen = buflen * 2;
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }
      size_t written = hex_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",15,,639,21,,void
287089,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,642,2,,void
287122,BLOCK,24,,"{
      size_t str_len = buflen / 2;
      if (IsBigEndian()) {
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }
      if (reinterpret_cast<uintptr_t>(buf) % 2 != 0) {
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ER...",16,,652,24,,void
287131,BLOCK,-1,,"{
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }",26,,654,2,,void
287150,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",45,,656,2,,void
287162,BLOCK,-1,,<empty>,9,,660,1,,void
287181,BLOCK,4,,"{
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }",64,,660,4,,void
287230,BLOCK,-1,,"{
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        memcpy(dst, buf, buflen);
        return ExternTwoByteString::New(
            isolate, reinterpret_cast<uint16_t*>(dst), str_len, error);
      }",54,,669,2,,void
287243,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,672,2,,void
287290,BLOCK,-1,,"{
  if (buflen == 0) return String::Empty(isolate);
  CHECK_BUFLEN_IN_RANGE(buflen);

  // Node's ""ucs2"" encoding expects LE character data inside a
  // Buffer, so we need to reorder on BE platforms.  See
  // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
  // encoding specification
  if (IsBigEndian()) {
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  } else {
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }
}",60,,693,5,,void
287295,BLOCK,-1,,<empty>,20,,694,2,,void
287304,BLOCK,1,,<empty>,,,,2,,void
287306,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,1,,void
287313,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,2,,void
287327,BLOCK,-1,,"{
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  }",22,,701,2,,void
287342,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",25,,703,2,,void
287379,BLOCK,-1,,"{
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }",10,,711,1,,void
287396,BLOCK,-1,,"{
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}",60,,719,5,,void
287421,BLOCK,-1,,<empty>,1,,1,1,,ANY
287428,BLOCK,-1,,<empty>,1,,1,1,,ANY
287449,BLOCK,-1,,<empty>,1,,1,1,,ANY
287457,BLOCK,-1,,"{
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}",55,,30,5,,void
287472,BLOCK,-1,,"{
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  }",25,,33,2,,void
287496,BLOCK,-1,,"{
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    }",32,,39,2,,void
287509,BLOCK,-1,,"{
      return utf8_string;
    }",12,,42,1,,void
287513,BLOCK,-1,,"{
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }",10,,45,1,,void
287531,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }",22,,54,2,,void
287571,BLOCK,-1,,"{
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation...",65,,68,4,,void
287595,BLOCK,-1,,"{
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes f...",32,,76,2,,void
287600,BLOCK,-1,,"{
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
          ...",29,,81,2,,void
287610,BLOCK,-1,,"{
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }
      }",31,,85,2,,void
287612,BLOCK,-1,,<empty>,9,,89,1,,void
287626,BLOCK,4,,"{
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }",66,,89,4,,void
287635,BLOCK,-1,,"{
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }",41,,90,2,,void
287697,BLOCK,-1,,"{
        // If no more bytes are missing, create a small string that we
        // will later prepend.
        if (!MakeString(isolate,
                        IncompleteCharacterBuffer(),
                        BufferedBytes(),
                        Encoding()).ToLocal(&prepend)) {
          return MaybeLocal<String>();
        }

        *nread_ptr += BufferedBytes();
        // No more buffered bytes.
        state_[kBufferedBytes] = 0;
      }",40,,117,2,,void
287710,BLOCK,-1,,"{
          return MaybeLocal<String>();
        }",56,,123,2,,void
287727,BLOCK,-1,,"{
      body = !prepend.IsEmpty() ? prepend : String::Empty(isolate);
      prepend = Local<String>();
    }",31,,135,2,,void
287746,BLOCK,-1,,"{
      // If not, that means is no character left to finish at this point.
      DCHECK_EQ(MissingBytes(), 0);
      DCHECK_EQ(BufferedBytes(), 0);

      // See whether there is a character that we may have to cut off and
      // finish when receiving the next chunk.
      if (Encoding() == UTF8 && data[nread - 1] & 0x80) {
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular ...",12,,138,1,,void
287765,BLOCK,-1,,"{
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              sta...",57,,145,2,,void
287767,BLOCK,-1,,<empty>,9,,149,1,,void
287776,BLOCK,4,,"{
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          } else {
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
     ...",43,,149,4,,void
287792,BLOCK,-1,,"{
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          }",41,,152,2,,void
287803,BLOCK,-1,,"{
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }",56,,154,2,,void
287811,BLOCK,-1,,"{
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
            if ((data[i] & 0xE0) == 0xC0) {
              state_[kMissingBytes] = 2;
            } else if ((data[i] & 0xF0) == 0xE0) {
              state_[kMissingBytes] = 3;
            } else if ((data[i] & 0xF8) == 0xF0) {
              state_[kMissingBytes] = 4;
            } else {
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }

            if (BufferedBytes() >= MissingBytes()) {
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes...",18,,165,1,,void
287820,BLOCK,-1,,"{
              state_[kMissingBytes] = 2;
            }",43,,168,2,,void
287827,BLOCK,-1,,<empty>,20,,170,1,,void
287836,BLOCK,-1,,"{
              state_[kMissingBytes] = 3;
            }",50,,170,2,,void
287843,BLOCK,-1,,<empty>,20,,172,1,,void
287852,BLOCK,-1,,"{
              state_[kMissingBytes] = 4;
            }",50,,172,2,,void
287859,BLOCK,-1,,"{
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }",20,,174,1,,void
287870,BLOCK,-1,,"{
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes] = 0;
              state_[kBufferedBytes] = 0;
            }",52,,181,2,,void
287890,BLOCK,-1,,<empty>,14,,194,1,,void
287895,BLOCK,-1,,"{
        if ((nread % 2) == 1) {
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        } else if ((data[nread - 1] & 0xFC) == 0xD8) {
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }
      }",38,,194,2,,void
287902,BLOCK,-1,,"{
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        }",31,,195,2,,void
287914,BLOCK,-1,,<empty>,16,,199,1,,void
287925,BLOCK,-1,,"{
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }",54,,199,2,,void
287937,BLOCK,-1,,<empty>,14,,204,1,,void
287946,BLOCK,-1,,"{
        state_[kBufferedBytes] = nread % 3;
        if (state_[kBufferedBytes] > 0)
          state_[kMissingBytes] = 3 - BufferedBytes();
      }",67,,204,2,,void
287960,BLOCK,-1,,<empty>,11,,207,2,,void
287972,BLOCK,-1,,"{
        // Copy the requested number of buffered bytes from the end of the
        // input into the incomplete character buffer.
        nread -= BufferedBytes();
        *nread_ptr -= BufferedBytes();
        memcpy(IncompleteCharacterBuffer(), data + nread, BufferedBytes());
      }",32,,210,2,,void
287990,BLOCK,-1,,"{
        if (!MakeString(isolate, data, nread, Encoding()).ToLocal(&body))
          return MaybeLocal<String>();
      }",22,,218,2,,void
288003,BLOCK,-1,,<empty>,11,,220,2,,void
288007,BLOCK,-1,,"{
        body = String::Empty(isolate);
      }",14,,221,1,,void
288020,BLOCK,-1,,"{
      return body;
    }",28,,226,2,,void
288024,BLOCK,-1,,"{
      return String::Concat(isolate, prepend, body);
    }",12,,228,1,,void
288034,BLOCK,-1,,"{
    CHECK(Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1);
    return MakeString(isolate, data, nread, Encoding());
  }",10,,231,1,,void
288057,BLOCK,-1,,"{
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}",63,,237,2,,void
288070,BLOCK,-1,,"{
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }",73,,238,2,,void
288087,BLOCK,-1,,"{
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }",55,,243,2,,void
288100,BLOCK,-1,,<empty>,5,,250,2,,void
288135,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",58,,266,2,,void
288198,BLOCK,-1,,<empty>,5,,278,2,,void
288214,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",57,,281,2,,void
288249,BLOCK,-1,,<empty>,5,,287,2,,void
288268,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings->Set(context,                                                     \
                 static_cast<int32_t>(cname),                                 \
                 FIXED_ONE_BYTE_STRING(isolate...",42,,293,5,,void
288285,BLOCK,1,,<empty>,,,,3,,void
288306,BLOCK,1,,<empty>,,,,3,,void
288327,BLOCK,1,,<empty>,,,,3,,void
288348,BLOCK,1,,<empty>,,,,3,,void
288369,BLOCK,1,,<empty>,,,,3,,void
288390,BLOCK,1,,<empty>,,,,3,,void
288424,BLOCK,1,,<empty>,,,,4,,void
288442,BLOCK,1,,<empty>,,,,4,,void
288460,BLOCK,1,,<empty>,,,,4,,void
288478,BLOCK,1,,<empty>,,,,4,,void
288496,BLOCK,1,,<empty>,,,,4,,void
288514,BLOCK,1,,<empty>,,,,4,,void
288532,BLOCK,1,,<empty>,,,,4,,void
288550,BLOCK,1,,<empty>,,,,4,,void
288609,BLOCK,-1,,"{
  registry->Register(DecodeData);
  registry->Register(FlushData);
}",42,,338,2,,void
288629,BLOCK,-1,,<empty>,1,,1,1,,ANY
288640,BLOCK,-1,,<empty>,1,,1,1,,ANY
288645,BLOCK,-1,,"{
      return uv_ip4_addr(ip_address, port, addr);
  }",74,,300,3,,void
288659,BLOCK,-1,,"{
      return uv_ip6_addr(ip_address, port, addr);
  }",76,,312,3,,void
288695,BLOCK,-1,,<empty>,1,,1,1,,ANY
288701,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",67,,58,4,,void
288784,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""reading""),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""bind6"", Bind6);
  SetProtoMethod(isolate, t, ""connect6"", Connect6);
  SetProtoMethod(isolate,
                 t,
                 ""getsockname"",
           ...",38,,75,5,,void
288991,BLOCK,1,,<empty>,,,,7,,void
288993,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,123,1,,void
289090,BLOCK,1,,<empty>,,,,7,,void
289092,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,124,1,,void
289189,BLOCK,1,,<empty>,,,,7,,void
289191,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY)",3,,125,1,,void
289300,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}",79,,131,2,,void
289365,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}",60,,150,2,,void
289407,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }",17,,162,2,,void
289436,BLOCK,-1,,"{
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}",45,,178,4,,void
289454,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}",67,,185,2,,void
289503,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}",69,,196,2,,void
289545,BLOCK,-1,,<empty>,57,,203,2,,void
289583,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",61,,223,2,,void
289621,BLOCK,-1,,<empty>,5,,230,2,,void
289642,BLOCK,-1,,<empty>,5,,235,2,,void
289662,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  node::Utf8Value ip_address(env->isolate(), args[0]);
  int port;
  unsigned int flags = 0;
  if (!args[1]->Int32Value(env->context()).To(&port)) return;
  if (family == AF_INET6 &&
      !args[2]->Uint32Value(env->context()).To(&flags)) {
    return;
  }

  T addr;
  int err = uv_ip_addr(*ip_address, port, &addr);

  if (err == 0) {
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }
  args.GetReturnValue().Set(err);
}",79,,244,4,,void
289717,BLOCK,-1,,<empty>,55,,253,2,,void
289740,BLOCK,-1,,"{
    return;
  }",57,,255,2,,void
289756,BLOCK,-1,,"{
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }",17,,262,2,,void
289781,BLOCK,-1,,"{
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}",61,,270,2,,void
289795,BLOCK,-1,,"{
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}",62,,275,2,,void
289809,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",63,,280,2,,void
289851,BLOCK,-1,,<empty>,58,,287,2,,void
289877,BLOCK,-1,,"{
  CHECK(args[2]->IsUint32());
  // explicit cast to fit to libuv's type expectation
  int port = static_cast<int>(args[2].As<Uint32>()->Value());
  Connect<sockaddr_in>(args,
                       [port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  });
}",64,,295,2,,void
289910,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}",65,,306,2,,void
289943,BLOCK,-1,,<empty>,55,,310,2,,void
289958,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).F...",69,,319,3,,void
290031,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }
  }",17,,336,2,,void
290063,BLOCK,-1,,"{
      delete req_wrap;
    }",14,,344,2,,void
290067,BLOCK,-1,,"{
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }",12,,346,1,,void
290122,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  int err = wrap->Reset(args[0]);

  args.GetReturnValue().Set(err);
}",62,,361,2,,void
290161,BLOCK,-1,,"{
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}",49,,371,2,,void
290166,BLOCK,-1,,<empty>,31,,372,2,,void
290199,BLOCK,-1,,"{
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }",32,,377,2,,void
290224,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6...",52,,388,4,,void
290240,BLOCK,-1,,<empty>,5,,397,2,,void
290255,BLOCK,-1,,"{
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6->sin6_port);
    info->Set(env->context(),
              env->address_string(),
              OneByteString(env->isolate(), ip)).Check();
    info->Set(env->context(), env->family_string(), env->ipv6_string()).Check();
    info->Set(env->context(),...",28,,399,2,,void
290284,BLOCK,-1,,"{
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }",73,,404,2,,void
290327,BLOCK,-1,,"{
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }",14,,413,2,,void
290534,BLOCK,-1,,<empty>,1,,1,1,,ANY
290545,BLOCK,-1,,<empty>,1,,1,1,,ANY
290558,BLOCK,-1,,<empty>,1,,1,1,,ANY
290573,BLOCK,-1,,<empty>,1,,1,1,,ANY
290576,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}",24,,10,1,,void
290583,BLOCK,-1,,<empty>,31,,11,2,,void
290589,BLOCK,-1,,"{
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}",25,,15,1,,void
290608,BLOCK,-1,,"{
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}",52,,20,2,,void
290629,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}",60,,26,3,,void
290636,BLOCK,-1,,<empty>,31,,27,2,,void
290647,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}",23,,31,1,,void
290654,BLOCK,-1,,<empty>,31,,32,2,,void
290664,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",25,,36,1,,void
290671,BLOCK,-1,,<empty>,31,,37,2,,void
290682,BLOCK,-1,,"{
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}",46,,41,2,,void
290699,BLOCK,-1,,"{
  if (timer_ != nullptr)
    return timer_->Stop();
}",30,,46,1,,void
290704,BLOCK,-1,,<empty>,5,,48,2,,void
290713,BLOCK,-1,,"{
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}",31,,51,1,,void
290718,BLOCK,-1,,"{
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }",26,,52,2,,void
290738,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Ref();
}",29,,59,1,,void
290743,BLOCK,-1,,<empty>,5,,61,2,,void
290751,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Unref();
}",31,,64,1,,void
290756,BLOCK,-1,,<empty>,5,,66,2,,void
290766,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}",66,,69,3,,void
290771,BLOCK,-1,,<empty>,5,,71,2,,void
290782,BLOCK,-1,,"{
  if (timer_ != nullptr)
    tracker->TrackField(""timer"", *timer_);
}",64,,74,2,,void
290787,BLOCK,-1,,<empty>,5,,76,2,,void
290799,BLOCK,-1,,"{
  static_cast<TimerWrapHandle*>(data)->Close();
}",47,,79,2,,void
290820,BLOCK,-1,,<empty>,1,,1,1,,ANY
290837,BLOCK,-1,,<empty>,1,,1,1,,ANY
290842,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}",72,,22,2,,void
290889,BLOCK,-1,,"{
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}",76,,31,2,,void
290921,BLOCK,-1,,"{
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}",61,,36,2,,void
290933,BLOCK,-1,,"{
  return static_cast<double>(data->env()->GetNowUint64());
}",56,,40,2,,void
290948,BLOCK,-1,,"{
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}",78,,44,2,,void
290982,BLOCK,-1,,"{
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}",79,,50,3,,void
290995,BLOCK,-1,,"{
  data->env()->ScheduleTimer(duration);
}",74,,54,3,,void
291008,BLOCK,-1,,"{
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}",54,,59,2,,void
291028,BLOCK,-1,,"{
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}",72,,64,3,,void
291041,BLOCK,-1,,"{
  data->env()->ToggleTimerRef(ref);
}",67,,68,3,,void
291054,BLOCK,-1,,"{
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}",54,,73,2,,void
291074,BLOCK,-1,,"{
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}",76,,78,3,,void
291087,BLOCK,-1,,"{
  data->env()->ToggleImmediateRef(ref);
}",71,,82,3,,void
291101,BLOCK,-1,,<empty>,51,,87,3,,void
291107,BLOCK,-1,,"{
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,90,3,,void
291114,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,96,2,,void
291139,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,106,5,,void
291178,BLOCK,-1,,<empty>,,,,2,,<empty>
291183,BLOCK,-1,,<empty>,,,,2,,<empty>
291188,BLOCK,-1,,<empty>,,,,2,,<empty>
291193,BLOCK,-1,,<empty>,,,,2,,<empty>
291199,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupTimers"", SetupTimers);
  SetFastMethod(
      isolate, target, ""getLibuvNow"", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                ""scheduleTimer"",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                ""toggleTimerRef"",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                ""toggleImmediateRef"",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}",76,,125,3,,void
291247,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""immediateInfo""),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""timeoutInfo""),
            env->timeout_info().GetJSArray())
      .Check();
}",58,,151,5,,void
291280,BLOCK,-1,,<empty>,32,,156,2,,void
291331,BLOCK,-1,,"{
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}",42,,173,2,,void
291420,BLOCK,-1,,<empty>,1,,1,1,,ANY
291424,BLOCK,-1,,"{
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",48,,58,2,,void
291444,BLOCK,-1,,"{
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",56,,97,2,,void
291474,BLOCK,-1,,<empty>,1,,1,1,,ANY
291482,BLOCK,-1,,"{
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",69,,16,4,,void
291485,BLOCK,-1,,"{
      CHECK(agent_->started_);
      controller->StopTracing();
    }",21,,17,2,,void
291497,BLOCK,-1,,"{
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",27,,23,1,,void
291502,BLOCK,-1,,<empty>,28,,24,2,,void
291515,BLOCK,-1,,"{
      controller_->StartTracing(config);
    }",28,,26,2,,void
291528,BLOCK,-1,,"{
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}",69,,39,2,,void
291562,BLOCK,-1,,"{
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",63,,52,1,,void
291589,BLOCK,-1,,"{
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",41,,65,1,,void
291599,BLOCK,-1,,"{
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }",39,,67,2,,void
291627,BLOCK,-1,,"{
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",17,,75,1,,void
291653,BLOCK,-1,,"{
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",21,,86,1,,void
291656,BLOCK,-1,,<empty>,5,,88,2,,void
291690,BLOCK,-1,,"{
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }

  return AgentWriterHandle(this, id);
}",39,,107,4,,void
291710,BLOCK,-1,,"{
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }",38,,113,2,,void
291775,BLOCK,14,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }",3,,126,14,,void
291807,BLOCK,-1,,"{
  return AgentWriterHandle(this, kDefaultHandleId);
}",42,,137,1,,void
291815,BLOCK,-1,,"{
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",27,,141,1,,void
291819,BLOCK,-1,,<empty>,5,,143,2,,void
291840,BLOCK,-1,,"{
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",36,,154,2,,void
291845,BLOCK,-1,,<empty>,35,,155,2,,void
291847,BLOCK,2,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }",3,,156,2,,void
291883,BLOCK,-1,,"{
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",69,,165,3,,void
291889,BLOCK,-1,,<empty>,5,,167,2,,void
291920,BLOCK,-1,,"{
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",70,,174,3,,void
291948,BLOCK,-1,,"{
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }",50,,178,3,,void
291964,BLOCK,-1,,<empty>,7,,181,2,,void
291973,BLOCK,-1,,"{
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",47,,185,1,,void
291979,BLOCK,-1,,<empty>,5,,187,2,,void
291991,BLOCK,-1,,"{
    trace_config->AddIncludedCategory(category.c_str());
  }",53,,189,3,,void
292005,BLOCK,-1,,"{
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",49,,195,1,,void
292011,BLOCK,-1,,"{
    if (!categories.empty())
      categories += ',';
    categories += category;
  }",60,,197,3,,void
292018,BLOCK,-1,,<empty>,7,,199,2,,void
292031,BLOCK,-1,,"{
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",56,,205,2,,void
292046,BLOCK,-1,,"{
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",66,,210,2,,void
292063,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",34,,215,2,,void
292064,BLOCK,1,,"{
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }",3,,216,1,,void
292097,BLOCK,-1,,"{
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",25,,234,9,,void
292112,BLOCK,1,,<empty>,,,,1,,void
292137,BLOCK,1,,<empty>,,,,1,,void
292158,BLOCK,-1,,<empty>,5,,247,2,,void
292190,BLOCK,-1,,<empty>,1,,1,1,,ANY
292199,BLOCK,-1,,<empty>,,,,1,,<empty>
292204,BLOCK,-1,,<empty>,,,,2,,<empty>
292209,BLOCK,-1,,<empty>,,,,2,,<empty>
292214,BLOCK,-1,,<empty>,52,,32,2,,void
292219,BLOCK,-1,,<empty>,68,,37,1,,void
292223,BLOCK,-1,,"{
    return uv_hrtime() / 1000;
  }",51,,39,1,,void
292239,BLOCK,-1,,<empty>,,,,9,,<empty>
292244,BLOCK,-1,,<empty>,,,,1,,<empty>
292248,BLOCK,-1,,{ reset(); },31,,56,1,,void
292254,BLOCK,-1,,<empty>,,,,2,,<empty>
292259,BLOCK,-1,,<empty>,,,,2,,<empty>
292263,BLOCK,-1,,{ return agent_ == nullptr; },29,,60,1,,void
292271,BLOCK,-1,,<empty>,,,,1,,<empty>
292276,BLOCK,-1,,<empty>,,,,2,,<empty>
292281,BLOCK,-1,,<empty>,,,,2,,<empty>
292285,BLOCK,-1,,<empty>,,,,1,,<empty>
292289,BLOCK,-1,,{ return agent_; },25,,68,1,,void
292295,BLOCK,-1,,<empty>,,,,1,,<empty>
292300,BLOCK,-1,,<empty>,,,,2,,<empty>
292305,BLOCK,-1,,<empty>,,,,2,,<empty>
292311,BLOCK,-1,,<empty>,75,,76,3,,void
292318,BLOCK,-1,,<empty>,,,,1,,<empty>
292329,BLOCK,-1,,<empty>,,,,1,,<empty>
292333,BLOCK,-1,,<empty>,,,,1,,<empty>
292337,BLOCK,-1,,"{
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",45,,89,1,,void
292358,BLOCK,-1,,<empty>,,,,4,,<empty>
292362,BLOCK,-1,,<empty>,,,,1,,<empty>
292366,BLOCK,-1,,<empty>,,,,1,,<empty>
292371,BLOCK,-1,,<empty>,,,,2,,<empty>
292376,BLOCK,-1,,<empty>,,,,2,,<empty>
292381,BLOCK,-1,,<empty>,,,,2,,<empty>
292385,BLOCK,-1,,<empty>,,,,1,,<empty>
292390,BLOCK,-1,,<empty>,,,,1,,<empty>
292394,BLOCK,-1,,<empty>,,,,1,,<empty>
292398,BLOCK,-1,,<empty>,,,,1,,<empty>
292403,BLOCK,-1,,<empty>,,,,2,,<empty>
292409,BLOCK,-1,,<empty>,,,,3,,<empty>
292415,BLOCK,-1,,<empty>,,,,3,,<empty>
292426,BLOCK,-1,,<empty>,,,,1,,<empty>
292443,BLOCK,-1,,<empty>,,,,1,,<empty>
292453,BLOCK,-1,,"{
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}",33,,158,1,,void
292458,BLOCK,-1,,<empty>,5,,160,2,,void
292471,BLOCK,-1,,"{
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}",76,,164,2,,void
292495,BLOCK,-1,,"{
  *this = std::move(other);
}",65,,172,2,,void
292508,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}",73,,176,2,,void
292513,BLOCK,-1,,<empty>,26,,177,2,,void
292524,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}",74,,180,2,,void
292529,BLOCK,-1,,<empty>,26,,181,2,,void
292539,BLOCK,-1,,"{
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}",43,,184,1,,void
292553,BLOCK,-1,,"{
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}",73,,188,1,,void
292569,BLOCK,-1,,"{
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",38,,187,2,,void
292605,BLOCK,-1,,"{
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",36,,181,2,,void
292636,BLOCK,-1,,<empty>,1,,1,1,,ANY
292643,BLOCK,-1,,"{
  chunks_.resize(max_chunks);
}",30,,12,4,,void
292653,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",67,,16,2,,void
292670,BLOCK,-1,,"{
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }",67,,19,2,,void
292680,BLOCK,-1,,"{
      chunk->Reset(current_chunk_seq_++);
    }",16,,21,2,,void
292688,BLOCK,-1,,"{
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }",12,,23,1,,void
292735,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",69,,34,2,,void
292743,BLOCK,-1,,"{
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }",20,,36,2,,void
292768,BLOCK,-1,,"{
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }",57,,43,2,,void
292784,BLOCK,-1,,"{
    // Chunk is no longer in memory.
    return nullptr;
  }",34,,50,2,,void
292797,BLOCK,-1,,"{
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",48,,57,2,,void
292798,BLOCK,1,,"{
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }",3,,58,1,,void
292806,BLOCK,-1,,"{
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }",28,,60,2,,void
292811,BLOCK,-1,,<empty>,7,,62,1,,void
292821,BLOCK,4,,"{
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }",50,,62,4,,void
292829,BLOCK,-1,,<empty>,9,,64,1,,void
292842,BLOCK,4,,"{
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }",52,,64,4,,void
292856,BLOCK,-1,,"{
            agent_->AppendTraceEvent(trace_event);
          }",36,,69,2,,void
292879,BLOCK,-1,,"{
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",71,,82,4,,void
292906,BLOCK,-1,,"{
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}",53,,89,6,,void
292954,BLOCK,-1,,"{
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",38,,102,4,,void
292995,BLOCK,-1,,"{
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,115,1,,void
293005,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,118,2,,void
293015,BLOCK,-1,,"{
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",63,,123,2,,void
293019,BLOCK,-1,,"{
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }",34,,125,2,,void
293039,BLOCK,-1,,"{
  return current_buf_.load()->GetEventByHandle(handle);
}",65,,135,2,,void
293052,BLOCK,-1,,"{
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",31,,139,1,,void
293068,BLOCK,-1,,"{
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",48,,148,1,,void
293081,BLOCK,-1,,"{
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }",27,,150,2,,void
293103,BLOCK,-1,,"{
      current_buf_.store(other_buf);
    }",31,,154,2,,void
293110,BLOCK,-1,,"{
      return false;
    }",12,,156,1,,void
293119,BLOCK,-1,,"{
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",68,,164,2,,void
293143,BLOCK,-1,,"{
    buffer->buffer1_.Flush(false);
  }",68,,166,2,,void
293166,BLOCK,-1,,"{
    buffer->buffer2_.Flush(false);
  }",68,,169,2,,void
293177,BLOCK,-1,,"{
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",56,,175,2,,void
293209,BLOCK,-1,,<empty>,1,,1,1,,ANY
293218,BLOCK,-1,,<empty>,,,,4,,<empty>
293223,BLOCK,-1,,<empty>,,,,2,,<empty>
293228,BLOCK,-1,,<empty>,,,,2,,<empty>
293233,BLOCK,-1,,<empty>,,,,2,,<empty>
293237,BLOCK,-1,,"{
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",23,,27,1,,void
293254,BLOCK,-1,,"{
    return flushing_;
  }",27,,30,1,,void
293263,BLOCK,-1,,<empty>,,,,4,,<empty>
293272,BLOCK,-1,,<empty>,,,,6,,<empty>
293276,BLOCK,-1,,{ return max_chunks_ * TraceBufferChunk::kChunkSize; },27,,39,1,,void
293294,BLOCK,-1,,<empty>,,,,1,,<empty>
293308,BLOCK,-1,,<empty>,,,,4,,<empty>
293312,BLOCK,-1,,<empty>,,,,1,,<empty>
293317,BLOCK,-1,,<empty>,,,,2,,<empty>
293322,BLOCK,-1,,<empty>,,,,2,,<empty>
293326,BLOCK,-1,,<empty>,,,,1,,<empty>
293331,BLOCK,-1,,<empty>,,,,1,,<empty>
293336,BLOCK,-1,,<empty>,,,,2,,<empty>
293341,BLOCK,-1,,<empty>,,,,2,,<empty>
293354,BLOCK,-1,,<empty>,,,,1,,<empty>
293366,BLOCK,-1,,"{
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",50,,20,2,,void
293386,BLOCK,-1,,"{
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",24,,187,2,,void
293405,BLOCK,-1,,"{
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",42,,229,2,,void
293440,BLOCK,-1,,"{
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",36,,223,2,,void
293473,BLOCK,-1,,<empty>,1,,1,1,,ANY
293478,BLOCK,-1,,<empty>,43,,12,2,,void
293483,BLOCK,-1,,"{
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",59,,14,2,,void
293523,BLOCK,-1,,"{
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",37,,32,1,,void
293528,BLOCK,3,,"{
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }",3,,37,3,,void
293536,BLOCK,-1,,"{
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }",28,,39,2,,void
293545,BLOCK,-1,,"{
    Flush(true);
  }",21,,44,2,,void
293551,BLOCK,-1,,"{
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,49,1,,void
293559,BLOCK,-1,,"{
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }",18,,52,2,,void
293580,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,58,2,,void
293592,BLOCK,-1,,"{
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}",51,,65,4,,void
293602,BLOCK,-1,,<empty>,3,,67,1,,void
293618,BLOCK,4,,"{
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }",69,,67,4,,void
293638,BLOCK,-1,,"{
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",49,,73,1,,void
293668,BLOCK,-1,,"{
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }",18,,83,2,,void
293704,BLOCK,-1,,"{
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }",16,,91,2,,void
293722,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",66,,99,2,,void
293730,BLOCK,-1,,"{
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }",27,,102,2,,void
293751,BLOCK,-1,,"{
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",38,,116,1,,void
293754,BLOCK,3,,"{
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }",3,,119,3,,void
293762,BLOCK,-1,,"{
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }",42,,121,2,,void
293785,BLOCK,4,,"{
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }",3,,132,4,,void
293803,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",44,,139,2,,void
293807,BLOCK,3,,"{
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }",3,,141,3,,void
293814,BLOCK,-1,,<empty>,7,,147,2,,void
293832,BLOCK,-1,,"{
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }",17,,152,2,,void
293837,BLOCK,-1,,"{
      request_cond_.Wait(scoped_lock);
    }",56,,156,2,,void
293848,BLOCK,-1,,"{
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",78,,162,3,,void
293854,BLOCK,-1,,<empty>,18,,163,2,,void
293862,BLOCK,4,,"{
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,166,4,,void
293885,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",39,,171,2,,void
293920,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,179,2,,void
293927,BLOCK,-1,,"{
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",48,,184,2,,void
293948,BLOCK,-1,,"{
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",36,,195,1,,void
293963,BLOCK,5,,"{
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,200,5,,void
293994,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",36,,206,2,,void
294029,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,212,2,,void
294035,BLOCK,-1,,"{
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           });
}",56,,218,2,,void
294069,BLOCK,-1,,<empty>,1,,1,1,,ANY
294075,BLOCK,-1,,<empty>,,,,2,,<empty>
294079,BLOCK,-1,,<empty>,,,,1,,<empty>
294084,BLOCK,-1,,<empty>,,,,2,,<empty>
294089,BLOCK,-1,,<empty>,,,,2,,<empty>
294094,BLOCK,-1,,<empty>,,,,2,,<empty>
294102,BLOCK,-1,,<empty>,,,,1,,<empty>
294107,BLOCK,-1,,<empty>,,,,2,,<empty>
294111,BLOCK,-1,,<empty>,,,,1,,<empty>
294117,BLOCK,-1,,<empty>,,,,3,,<empty>
294121,BLOCK,-1,,<empty>,,,,1,,<empty>
294125,BLOCK,-1,,<empty>,,,,1,,<empty>
294130,BLOCK,-1,,<empty>,,,,2,,<empty>
294152,BLOCK,-1,,<empty>,,,,1,,<empty>
294190,BLOCK,-1,,<empty>,1,,1,1,,ANY
294203,BLOCK,-1,,"{
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}",47,,10,2,,void
294206,BLOCK,-1,,"{
    g_agent = agent;
    g_controller = agent->GetTracingController();
  }",14,,11,2,,void
294217,BLOCK,-1,,"{
    g_agent = nullptr;
    g_controller = nullptr;
  }",10,,14,1,,void
294227,BLOCK,-1,,"{
  return g_agent;
}",37,,20,1,,void
294233,BLOCK,-1,,"{
  return g_controller;
}",65,,24,1,,void
294240,BLOCK,-1,,"{
  g_controller = controller;
}",80,,28,2,,void
294247,BLOCK,-1,,"{
  return tracing::TraceEventHelper::GetTracingController();
}",47,,34,1,,void
294259,BLOCK,-1,,"{
  tracing::TraceEventHelper::SetTracingController(controller);
}",62,,38,2,,void
294281,BLOCK,-1,,<empty>,1,,1,1,,ANY
294287,BLOCK,-1,,<empty>,,,,1,,<empty>
294321,BLOCK,-1,,<empty>,,,,1,,<empty>
294326,BLOCK,-1,,<empty>,,,,2,,<empty>
294330,BLOCK,-1,,<empty>,,,,1,,<empty>
294335,BLOCK,-1,,<empty>,,,,2,,<empty>
294340,BLOCK,-1,,"{
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }",75,,321,2,,void
294354,BLOCK,-1,,<empty>,42,,324,2,,void
294371,BLOCK,-1,,<empty>,42,,337,3,,void
294375,BLOCK,-1,,{ return raw_id_; },29,,338,1,,void
294381,BLOCK,-1,,{ return scope_; },31,,339,1,,void
294389,BLOCK,-1,,<empty>,,,,1,,<empty>
294398,BLOCK,-1,,<empty>,79,,349,2,,void
294403,BLOCK,-1,,<empty>,60,,350,2,,void
294408,BLOCK,-1,,<empty>,64,,351,2,,void
294413,BLOCK,-1,,<empty>,60,,352,2,,void
294418,BLOCK,-1,,<empty>,65,,353,2,,void
294423,BLOCK,-1,,<empty>,50,,355,2,,void
294428,BLOCK,-1,,<empty>,78,,356,2,,void
294433,BLOCK,-1,,<empty>,50,,358,2,,void
294438,BLOCK,-1,,<empty>,50,,360,2,,void
294443,BLOCK,-1,,<empty>,66,,362,2,,void
294447,BLOCK,-1,,{ return scope_; },31,,363,1,,void
294453,BLOCK,-1,,{ return raw_id_; },29,,364,1,,void
294461,BLOCK,-1,,<empty>,,,,1,,<empty>
294470,BLOCK,-1,,<empty>,61,,373,2,,void
294475,BLOCK,-1,,<empty>,65,,374,2,,void
294480,BLOCK,-1,,<empty>,61,,375,2,,void
294485,BLOCK,-1,,<empty>,66,,376,2,,void
294490,BLOCK,-1,,<empty>,50,,378,2,,void
294495,BLOCK,-1,,<empty>,79,,379,2,,void
294500,BLOCK,-1,,<empty>,50,,381,2,,void
294505,BLOCK,-1,,<empty>,50,,383,2,,void
294509,BLOCK,-1,,{ return raw_id_; },29,,384,1,,void
294518,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",77,,391,3,,void
294523,BLOCK,1,,<empty>,,,,1,,void
294534,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",79,,394,3,,void
294539,BLOCK,1,,<empty>,,,,1,,void
294550,BLOCK,-1,,<empty>,76,,398,3,,void
294556,BLOCK,-1,,"{
    (void)flags;
  }",67,,399,3,,void
294565,BLOCK,-1,,"{
    (void)flags;
  }",71,,402,3,,void
294574,BLOCK,-1,,"{
    (void)flags;
  }",67,,405,3,,void
294583,BLOCK,-1,,"{
    (void)flags;
  }",72,,408,3,,void
294592,BLOCK,-1,,"{
    (void)flags;
  }",48,,412,3,,void
294601,BLOCK,-1,,"{
    (void)flags;
  }",48,,416,3,,void
294610,BLOCK,-1,,"{
    (void)flags;
  }",48,,420,3,,void
294619,BLOCK,-1,,"{
    (void)flags;
  }",48,,424,3,,void
294628,BLOCK,-1,,<empty>,64,,428,3,,void
294632,BLOCK,-1,,{ return raw_id_; },27,,430,1,,void
294638,BLOCK,-1,,{ return scope_; },29,,431,1,,void
294646,BLOCK,-1,,<empty>,,,,1,,<empty>
294662,BLOCK,-1,,<empty>,61,,451,2,,void
294666,BLOCK,-1,,{ return str_; },32,,452,1,,void
294684,BLOCK,-1,,"{
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled, name, scope, id,
                                   bind_id, num_args, arg_names, arg_types,
                                   arg_values, arg_convertibles, flags);
}",53,,462,12,,void
294696,BLOCK,1,,<empty>,,,,1,,void
294700,BLOCK,-1,,"{
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }",69,,464,2,,void
294724,BLOCK,1,,<empty>,,,,1,,void
294728,BLOCK,-1,,"{
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }",69,,468,2,,void
294757,BLOCK,-1,,<empty>,30,,475,2,,void
294785,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)",1,,545,4,,void
294804,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)",1,,546,4,,void
294823,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)",1,,547,4,,void
294842,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)",1,,548,4,,void
294861,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)",1,,549,4,,void
294880,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)",1,,550,4,,void
294899,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)",1,,551,4,,void
294918,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)",1,,552,4,,void
294937,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)",1,,553,4,,void
294962,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)",1,,554,4,,void
294987,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
                                 TRACE_VALUE_TYPE_POINTER)",1,,555,4,,void
295012,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
                                 TRACE_VALUE_TYPE_STRING)",1,,557,4,,void
295037,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
                                 TRACE_VALUE_TYPE_COPY_STRING)",1,,559,4,,void
295062,BLOCK,-1,,"{
  *type = TRACE_VALUE_TYPE_CONVERTABLE;
  *value = static_cast<uint64_t>(reinterpret_cast<intptr_t>(convertable_value));
}",75,,566,4,,void
295067,BLOCK,1,,<empty>,,,,1,,void
295085,BLOCK,-1,,"{
  SetTraceValue(ptr.release(), type, value);
}",77,,574,4,,void
295103,BLOCK,-1,,"{
  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
                                         scope, id, bind_id, kZeroNumArgs,
                                         nullptr, nullptr, nullptr, flags);
}",61,,588,8,,void
295106,BLOCK,1,,<empty>,,,,2,,void
295136,BLOCK,-1,,"{
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags);
}",50,,598,10,,void
295157,BLOCK,1,,<empty>,,,,4,,void
295192,BLOCK,-1,,"{
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}",27,,613,12,,void
295239,BLOCK,1,,<empty>,,,,5,,void
295265,BLOCK,-1,,<empty>,37,,686,1,,void
295269,BLOCK,-1,,"{
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",19,,688,1,,void
295277,BLOCK,-1,,<empty>,7,,690,2,,void
295279,BLOCK,1,,<empty>,,,,1,,void
295281,BLOCK,-1,,<empty>,7,,690,1,,void
295293,BLOCK,-1,,<empty>,7,,690,2,,void
295313,BLOCK,-1,,"{
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",42,,695,4,,void
295345,BLOCK,-1,,<empty>,1,,1,1,,ANY
295364,BLOCK,-1,,<empty>,1,,1,1,,ANY
295370,BLOCK,-1,,"{
  std::string result;
  result += '""';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // code from V8's own TracedValue implementation....",45,,29,2,,void
295379,BLOCK,-1,,"{
    char c = *value++;
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }
  }",18,,63,2,,void
295388,BLOCK,-1,,"{
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }",16,,65,2,,void
295436,BLOCK,-1,,"{
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        }",25,,74,2,,void
295451,BLOCK,-1,,"{
          result += c;
        }",16,,79,1,,void
295464,BLOCK,-1,,"{
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}",39,,89,2,,void
295467,BLOCK,1,,<empty>,,,,1,,void
295473,BLOCK,-1,,"{
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }",48,,90,2,,void
295514,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}",52,,105,1,,void
295528,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}",57,,109,1,,void
295543,BLOCK,-1,,<empty>,54,,114,2,,void
295549,BLOCK,-1,,"{
  WriteName(name);
  data_ += std::to_string(value);
}",59,,116,3,,void
295564,BLOCK,-1,,"{
  WriteName(name);
  data_ += DoubleToCString(value);
}",61,,121,3,,void
295576,BLOCK,-1,,"{
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",60,,126,3,,void
295589,BLOCK,-1,,"{
  WriteName(name);
  data_ += ""null"";
}",45,,131,2,,void
295600,BLOCK,-1,,"{
  WriteName(name);
  data_ += EscapeString(value);
}",66,,136,3,,void
295611,BLOCK,-1,,"{
  WriteName(name);
  data_ += '{';
  first_item_ = true;
}",53,,141,2,,void
295624,BLOCK,-1,,"{
  WriteName(name);
  data_ += '[';
  first_item_ = true;
}",48,,147,2,,void
295637,BLOCK,-1,,"{
  WriteComma();
  data_ += std::to_string(value);
}",44,,153,2,,void
295650,BLOCK,-1,,"{
  WriteComma();
  data_ += DoubleToCString(value);
}",46,,158,2,,void
295660,BLOCK,-1,,"{
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",45,,163,2,,void
295671,BLOCK,-1,,"{
  WriteComma();
  data_ += ""null"";
}",32,,168,1,,void
295680,BLOCK,-1,,"{
  WriteComma();
  data_ += EscapeString(value);
}",51,,173,2,,void
295689,BLOCK,-1,,"{
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",37,,178,1,,void
295700,BLOCK,-1,,"{
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",32,,184,1,,void
295711,BLOCK,-1,,"{
  data_ += '}';
  first_item_ = false;
}",35,,190,1,,void
295721,BLOCK,-1,,"{
  data_ += ']';
  first_item_ = false;
}",30,,195,1,,void
295731,BLOCK,-1,,"{
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",32,,200,1,,void
295734,BLOCK,-1,,"{
    first_item_ = false;
  }",20,,201,2,,void
295739,BLOCK,-1,,"{
    data_ += ',';
  }",10,,203,1,,void
295747,BLOCK,-1,,"{
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",47,,208,2,,void
295762,BLOCK,-1,,"{
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",63,,215,2,,void
295799,BLOCK,-1,,<empty>,1,,1,1,,ANY
295804,BLOCK,-1,,<empty>,,,,1,,<empty>
295808,BLOCK,-1,,<empty>,,,,1,,<empty>
295812,BLOCK,-1,,<empty>,,,,1,,<empty>
295816,BLOCK,-1,,<empty>,,,,1,,<empty>
295820,BLOCK,-1,,<empty>,,,,1,,<empty>
295826,BLOCK,-1,,<empty>,,,,3,,<empty>
295832,BLOCK,-1,,<empty>,,,,3,,<empty>
295838,BLOCK,-1,,<empty>,,,,3,,<empty>
295843,BLOCK,-1,,<empty>,,,,2,,<empty>
295849,BLOCK,-1,,<empty>,,,,3,,<empty>
295855,BLOCK,-1,,"{
    SetString(name, value.c_str());
  }",62,,35,3,,void
295866,BLOCK,-1,,<empty>,,,,2,,<empty>
295871,BLOCK,-1,,<empty>,,,,2,,<empty>
295876,BLOCK,-1,,<empty>,,,,2,,<empty>
295881,BLOCK,-1,,<empty>,,,,2,,<empty>
295886,BLOCK,-1,,<empty>,,,,2,,<empty>
295890,BLOCK,-1,,<empty>,,,,1,,<empty>
295895,BLOCK,-1,,<empty>,,,,2,,<empty>
295900,BLOCK,-1,,{ AppendString(value.c_str()); },47,,46,2,,void
295909,BLOCK,-1,,<empty>,,,,1,,<empty>
295913,BLOCK,-1,,<empty>,,,,1,,<empty>
295918,BLOCK,-1,,<empty>,,,,2,,<empty>
295923,BLOCK,-1,,<empty>,,,,2,,<empty>
295928,BLOCK,-1,,<empty>,,,,2,,<empty>
295933,BLOCK,-1,,<empty>,,,,2,,<empty>
295937,BLOCK,-1,,<empty>,,,,1,,<empty>
295942,BLOCK,-1,,<empty>,,,,2,,<empty>
295968,BLOCK,-1,,<empty>,1,,1,1,,ANY
295972,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}",79,,45,2,,void
296000,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), ""TTY"");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, ""getWindowSize"", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, ""setRawMode"", SetRawMode);

  SetMethodNoSideEffect(context, target, ""isTTY"", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}",38,,55,5,,void
296105,BLOCK,-1,,"{
    env->set_tty_constructor_template(t);
  }",55,,74,2,,void
296115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}",62,,80,2,,void
296142,BLOCK,-1,,<empty>,53,,83,2,,void
296166,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}",70,,90,2,,void
296216,BLOCK,-1,,"{
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }",17,,102,2,,void
296283,BLOCK,-1,,"{
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}",67,,112,2,,void
296326,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }
}",60,,122,2,,void
296358,BLOCK,-1,,<empty>,53,,131,2,,void
296381,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }",17,,136,2,,void
296405,BLOCK,-1,,"{
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}",52,,150,5,,void
296425,BLOCK,-1,,<empty>,5,,154,2,,void
296438,BLOCK,-1,,<empty>,1,,1,1,,ANY
296443,BLOCK,-1,,"{
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }",59,,601,3,,void
296494,BLOCK,-1,,<empty>,1,,1,1,,ANY
296499,BLOCK,-1,,"{
  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}",61,,57,2,,void
296515,BLOCK,-1,,"{
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }",24,,59,2,,void
296556,BLOCK,-1,,"{
    return;
  }",55,,66,2,,void
296582,BLOCK,-1,,<empty>,,,,4,,<empty>
296586,BLOCK,-1,,<empty>,,,,1,,<empty>
296595,BLOCK,-1,,"{
}",37,,93,4,,void
296599,BLOCK,-1,,"{
  return have_callback_;
}",38,,97,1,,void
296605,BLOCK,-1,,"{
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}",29,,101,1,,void
296610,BLOCK,-1,,<empty>,5,,103,2,,void
296619,BLOCK,-1,,"{
  set_listener(nullptr);
}",29,,106,1,,void
296625,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener_);
  return listener_;
}",44,,110,1,,void
296633,BLOCK,-1,,"{
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}",55,,115,2,,void
296638,BLOCK,-1,,<empty>,5,,117,2,,void
296651,BLOCK,-1,,"{
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }",29,,119,2,,void
296665,BLOCK,-1,,"{
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}",57,,125,2,,void
296689,BLOCK,-1,,"{
  SetProtoMethod(env->isolate(), t, ""recvStart"", RecvStart);
  SetProtoMethod(env->isolate(), t, ""recvStop"", RecvStop);
}",75,,131,3,,void
296711,BLOCK,-1,,"{
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}",47,,140,3,,void
296744,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""send...",38,,154,5,,void
297012,BLOCK,1,,<empty>,,,,7,,void
297014,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY)",3,,225,1,,void
297111,BLOCK,1,,<empty>,,,,7,,void
297113,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR)",3,,226,1,,void
297222,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}",60,,233,2,,void
297247,BLOCK,-1,,"{
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}",62,,240,2,,void
297267,BLOCK,-1,,<empty>,5,,245,2,,void
297292,BLOCK,-1,,"{
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }
}",56,,253,5,,void
297295,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }",27,,254,2,,void
297322,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}",75,,264,3,,void
297397,BLOCK,-1,,<empty>,5,,278,2,,void
297416,BLOCK,-1,,"{
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }",17,,281,2,,void
297433,BLOCK,-1,,<empty>,5,,288,2,,void
297454,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}",78,,294,3,,void
297514,BLOCK,-1,,<empty>,5,,306,2,,void
297533,BLOCK,-1,,"{
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }",17,,309,2,,void
297557,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}",61,,318,2,,void
297616,BLOCK,-1,,"{
  DoBind(args, AF_INET);
}",61,,331,2,,void
297624,BLOCK,-1,,"{
  DoBind(args, AF_INET6);
}",62,,336,2,,void
297632,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? ""uv_recv_buffer_size"" :
                                       ""uv_send_buffer_size"";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  args....",67,,341,2,,void
297698,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",28,,354,2,,void
297742,BLOCK,-1,,<empty>,5,,364,2,,void
297750,BLOCK,-1,,<empty>,5,,366,1,,void
297761,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",17,,368,2,,void
297791,BLOCK,-1,,"{
  DoConnect(args, AF_INET);
}",64,,377,2,,void
297799,BLOCK,-1,,"{
  DoConnect(args, AF_INET6);
}",65,,382,2,,void
297807,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}",67,,387,2,,void
297851,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}",78,,400,2,,void
297917,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}",55,,418,3,,void
297977,BLOCK,-1,,"{
      iface_cstr = nullptr;
  }",52,,430,2,,void
298005,BLOCK,-1,,"{
  SetMembership(args, UV_JOIN_GROUP);
}",70,,442,2,,void
298013,BLOCK,-1,,"{
  SetMembership(args, UV_LEAVE_GROUP);
}",71,,447,2,,void
298022,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}",61,,452,3,,void
298077,BLOCK,-1,,<empty>,26,,464,2,,void
298098,BLOCK,-1,,"{
    iface_cstr = nullptr;
  }",52,,466,2,,void
298128,BLOCK,-1,,"{
  SetSourceMembership(args, UV_JOIN_GROUP);
}",44,,479,2,,void
298136,BLOCK,-1,,"{
  SetSourceMembership(args, UV_LEAVE_GROUP);
}",44,,485,2,,void
298145,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i < count; i++) {
    Local<Value> chunk;
    if (!chunks->Get(env->context...",75,,490,3,,void
298216,BLOCK,-1,,"{
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  }",15,,504,2,,void
298239,BLOCK,-1,,"{
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }",10,,509,1,,void
298280,BLOCK,-1,,<empty>,3,,522,1,,void
298290,BLOCK,4,,"{
    Local<Value> chunk;
    if (!chunks->Get(env->context(), i).ToLocal(&chunk)) return;

    size_t length = Buffer::Length(chunk);

    bufs[i] = uv_buf_init(Buffer::Data(chunk), length);
  }",38,,522,4,,void
298312,BLOCK,-1,,<empty>,58,,524,2,,void
298344,BLOCK,-1,,"{
    const unsigned short port = args[3].As<Uint32>()->Value();
    node::Utf8Value address(env->isolate(), args[4]);
    err = sockaddr_for_family(family, address.out(), port, &addr_storage);
    if (err == 0)
      addr = reinterpret_cast<sockaddr*>(&addr_storage);
  }",15,,534,2,,void
298381,BLOCK,-1,,<empty>,7,,539,2,,void
298392,BLOCK,-1,,"{
    wrap->current_send_req_wrap_ = args[0].As<Object>();
    wrap->current_send_has_callback_ =
        sendto ? args[5]->IsTrue() : args[3]->IsTrue();

    err = static_cast<int>(wrap->Send(*bufs, count, addr));

    wrap->current_send_req_wrap_.Clear();
    wrap->current_send_has_callback_ = false;
  }",17,,542,2,,void
298458,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;

  size_t msg_size = 0;
  for (size_t i = 0; i < count; i++)
    msg_size += bufs_ptr[i].len;

  int err = 0;
  if (!UNLIKELY(env()->options()->test_udp_no_try_send)) {
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()...",45,,558,4,,void
298461,BLOCK,-1,,<empty>,26,,559,2,,void
298469,BLOCK,-1,,<empty>,3,,562,1,,void
298499,BLOCK,-1,,"{
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }",58,,566,2,,void
298516,BLOCK,-1,,"{
      err = 0;
    }",47,,568,2,,void
298521,BLOCK,-1,,<empty>,12,,570,1,,void
298526,BLOCK,-1,,"{
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }",26,,570,2,,void
298541,BLOCK,-1,,"{
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }",50,,572,2,,void
298555,BLOCK,-1,,"{
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      }",22,,577,2,,void
298572,BLOCK,-1,,"{
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }",14,,581,1,,void
298586,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()->CreateSendWrap(msg_size);
    if (req_wrap == nullptr) return UV_ENOSYS;

    err = req_wrap->Dispatch(
        uv_udp_send,
        &handle_,
        bufs_ptr,
        count,
        addr,
        uv_udp_send_cb{[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }});
    if (err)
      delete req_wrap;
  }",17,,590,2,,void
298606,BLOCK,-1,,<empty>,30,,593,2,,void
298626,BLOCK,-1,,<empty>,7,,607,2,,void
298635,BLOCK,-1,,"{
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",66,,614,2,,void
298655,BLOCK,-1,,"{
  DoSend(args, AF_INET);
}",61,,623,2,,void
298663,BLOCK,-1,,"{
  DoSend(args, AF_INET6);
}",62,,628,2,,void
298670,BLOCK,-1,,"{
  return this;
}",36,,633,1,,void
298676,BLOCK,-1,,"{
  return SocketAddress::FromPeerName(handle_);
}",38,,637,1,,void
298686,BLOCK,-1,,"{
  return SocketAddress::FromSockName(handle_);
}",38,,641,1,,void
298697,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}",70,,645,2,,void
298728,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}",26,,650,1,,void
298731,BLOCK,-1,,<empty>,26,,651,2,,void
298746,BLOCK,-1,,<empty>,5,,655,2,,void
298756,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}",69,,660,2,,void
298787,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}",25,,665,1,,void
298790,BLOCK,-1,,<empty>,26,,666,2,,void
298802,BLOCK,-1,,"{
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}",67,,671,3,,void
298817,BLOCK,-1,,"{
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }",34,,673,2,,void
298877,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_,
                              reinterpret_cast<uv_udp_t*>(handle));
  *buf = wrap->listener()->OnAlloc(suggested_size);
}",38,,688,4,,void
298904,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",50,,694,2,,void
298919,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_, handle);
  wrap->listener()->OnRecv(nread, *buf, addr, flags);
}",42,,702,6,,void
298948,BLOCK,-1,,"{
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2]...",42,,710,5,,void
298984,BLOCK,-1,,"{
    return;
  }",38,,714,2,,void
299016,BLOCK,-1,,"{
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  }",18,,727,2,,void
299027,BLOCK,-1,,<empty>,10,,730,1,,void
299032,BLOCK,-1,,"{
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  }",26,,730,2,,void
299042,BLOCK,-1,,"{
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }",10,,732,1,,void
299069,BLOCK,15,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,738,15,,void
299074,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,740,3,,void
299088,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",54,,742,2,,void
299121,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,749,2,,void
299155,BLOCK,17,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,757,17,,void
299160,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,759,3,,void
299184,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",73,,761,2,,void
299217,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,768,2,,void
299254,BLOCK,-1,,"{
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}",67,,781,4,,void
299283,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}",73,,789,2,,void
299322,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}",74,,798,2,,void
299374,BLOCK,-1,,<empty>,1,,1,1,,ANY
299379,BLOCK,-1,,<empty>,1,,1,1,,ANY
299394,BLOCK,-1,,<empty>,1,,1,1,,ANY
299397,BLOCK,-1,,"{
    uv_fs_req_cleanup(&req);
  }",50,,235,1,,void
299407,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",44,,246,1,,void
299464,BLOCK,-1,,<empty>,1,,1,1,,ANY
299475,BLOCK,-1,,"{
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  size_t storage;
  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;
  storage += 1;
  target->AllocateSufficientStorage(storage);
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}",57,,71,4,,void
299496,BLOCK,-1,,<empty>,72,,73,2,,void
299513,BLOCK,-1,,<empty>,70,,76,2,,void
299558,BLOCK,-1,,"{
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}",60,,86,3,,void
299564,BLOCK,-1,,<empty>,5,,88,2,,void
299575,BLOCK,-1,,"{
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}",66,,94,3,,void
299581,BLOCK,-1,,"{
    return;
  }",24,,95,2,,void
299603,BLOCK,-1,,<empty>,72,,100,2,,void
299641,BLOCK,-1,,"{
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}",64,,111,3,,void
299647,BLOCK,-1,,"{
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }",24,,115,2,,void
299655,BLOCK,-1,,"{
    MakeUtf8String(isolate, value, this);
  }",26,,121,2,,void
299661,BLOCK,-1,,<empty>,10,,123,1,,void
299667,BLOCK,-1,,"{
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  }",42,,123,2,,void
299694,BLOCK,-1,,"{
    Invalidate();
  }",10,,129,1,,void
299699,BLOCK,-1,,"{
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}",30,,134,1,,void
299704,BLOCK,-1,,"{
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }",36,,135,2,,void
299716,BLOCK,-1,,"{
      isolate->LowMemoryNotification();
    }",29,,137,2,,void
299725,BLOCK,-1,,"{
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}",56,,143,2,,void
299731,BLOCK,-1,,<empty>,3,,146,1,,void
299732,BLOCK,4,,"{
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }",12,,146,4,,void
299749,BLOCK,-1,,<empty>,7,,150,2,,void
299764,BLOCK,-1,,<empty>,7,,156,2,,void
299791,BLOCK,-1,,"{
  return SPrintF(""%s[%d]"", GetProcessTitle(""Node.js""), uv_os_getpid());
}",43,,168,1,,void
299803,BLOCK,-1,,"{
  std::vector<std::string_view> out;

  for (auto first = in.data(), second = in.data(), last = first + in.size();
       second != last && first != last;
       first = second + 1) {
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }

  return out;
}",73,,173,3,,void
299814,BLOCK,-1,,<empty>,3,,176,1,,void
299850,BLOCK,4,,"{
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }",28,,178,4,,void
299873,BLOCK,-1,,"{
      out.emplace_back(first, second - first);
    }",26,,182,2,,void
299888,BLOCK,-1,,"{
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}",46,,190,2,,void
299898,BLOCK,-1,,"{
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}",39,,194,1,,void
299924,BLOCK,-1,,"{
  uv_fs_t req;
  int fd = uv_fs_open(nullptr,
                      &req,
                      path,
                      O_WRONLY | O_CREAT | O_TRUNC,
                      S_IWUSR | S_IRUSR,
                      nullptr);
  uv_fs_req_cleanup(&req);
  if (fd < 0) {
    return fd;
  }

  int err = uv_fs_write(nullptr, &req, fd, &buf, 1, 0, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    return err;
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  return err;
}",51,,201,3,,void
299950,BLOCK,-1,,"{
    return fd;
  }",15,,210,2,,void
299973,BLOCK,-1,,"{
    return err;
  }",16,,216,2,,void
299995,BLOCK,-1,,"{
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}",49,,227,4,,void
300021,BLOCK,-1,,"{
  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() {
    uv_fs_req_cleanup(&req);
  });

  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    return req.result;
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  *result = std::string("""");
  char buffer[4096];
  uv_buf_t buf = uv_buf_init(buffer, sizeof(buffer));

  while (true) {
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }
  return 0;
}",57,,233,3,,void
300043,BLOCK,-1,,"{
    // req will be cleaned up by scope leave.
    return req.result;
  }",23,,240,2,,void
300074,BLOCK,-1,,"{
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }",16,,256,2,,void
300097,BLOCK,-1,,"{
      // req will be cleaned up by scope leave.
      return req.result;
    }",25,,259,2,,void
300109,BLOCK,-1,,"{
      break;
    }",17,,264,2,,void
300125,BLOCK,-1,,"{
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}",42,,272,2,,void
300183,BLOCK,-1,,"{
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, OSX
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}",58,,287,2,,void
300201,BLOCK,-1,,"{
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_hour;
  oss << std::setfill('0')
            << std::setw(2)
            << ...",22,,301,4,,void
300367,BLOCK,-1,,"{
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}",38,,348,7,,void
300391,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",47,,362,5,,void
300479,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",47,,383,5,,void
300545,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",53,,401,6,,void
300612,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",53,,420,6,,void
300697,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",65,,441,6,,void
300782,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",65,,462,6,,void
300848,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",59,,480,5,,void
300936,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",59,,501,5,,void
301001,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",52,,518,5,,void
301089,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",64,,537,5,,void
301177,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",55,,556,5,,void
301266,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  SetConstructorFunction(
      context, that, OneByteString(isolate, name), tmpl, flag);
}",62,,576,6,,void
301290,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(context, name, tmpl->GetFunction(context).ToLocalChecked()).Check();
}",62,,586,6,,void
301298,BLOCK,-1,,<empty>,5,,588,2,,void
301329,BLOCK,-1,,"{
  SetConstructorFunction(
      isolate, that, OneByteString(isolate, name), tmpl, flag);
}",62,,596,6,,void
301346,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(name, tmpl);
}",62,,605,6,,void
301354,BLOCK,-1,,<empty>,5,,607,2,,void
301370,BLOCK,-1,,"{
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}",67,,611,2,,void
301373,BLOCK,-1,,"{
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  }",22,,612,2,,void
301385,BLOCK,-1,,"{
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }",10,,615,1,,void
301438,BLOCK,-1,,<empty>,1,,1,1,,ANY
301453,BLOCK,-1,,<empty>,1,,1,1,,ANY
301470,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }
  int err;
  if (!args[0]->Int32Value(env->context()).To(&err)) return;
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}",55,,62,2,,void
301491,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }",73,,64,2,,void
301500,BLOCK,-1,,<empty>,5,,71,2,,void
301520,BLOCK,-1,,<empty>,54,,74,2,,void
301548,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}",57,,81,2,,void
301593,BLOCK,-1,,<empty>,3,,91,1,,void
301603,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }",43,,91,4,,void
301651,BLOCK,-1,,"{
      return;
    }",25,,99,2,,void
301668,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, ""errname"", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = ""UV_"";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }

  SetMethod(context, target, ""getErrorMap"", GetErrMap);
}",29,,110,5,,void
301711,BLOCK,-1,,<empty>,3,,122,1,,void
301721,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }",43,,122,4,,void
301784,BLOCK,-1,,"{
  registry->Register(ErrName);
  registry->Register(GetErrMap);
}",70,,133,2,,void
305579,BLOCK,-1,,<empty>,,,,1,,ANY
305994,BLOCK,1,,<empty>,,,,1,,ANY
305999,BLOCK,1,,<empty>,,,,1,,ANY
306007,BLOCK,1,,<empty>,,,,1,,ANY
306012,BLOCK,1,,<empty>,,,,1,,ANY
306017,BLOCK,1,,<empty>,,,,1,,ANY
306021,BLOCK,1,,<empty>,,,,1,,ANY
306026,BLOCK,1,,<empty>,,,,1,,ANY
306029,BLOCK,1,,<empty>,,,,1,,ANY
306035,BLOCK,1,,<empty>,,,,1,,ANY
306039,BLOCK,1,,<empty>,,,,1,,ANY
306043,BLOCK,1,,<empty>,,,,1,,ANY
306047,BLOCK,1,,<empty>,,,,1,,ANY
306051,BLOCK,1,,<empty>,,,,1,,ANY
306056,BLOCK,1,,<empty>,,,,1,,ANY
306060,BLOCK,1,,<empty>,,,,1,,ANY
306065,BLOCK,1,,<empty>,,,,1,,ANY
306069,BLOCK,1,,<empty>,,,,1,,ANY
306073,BLOCK,1,,<empty>,,,,1,,ANY
306077,BLOCK,1,,<empty>,,,,1,,ANY
306081,BLOCK,1,,<empty>,,,,1,,ANY
306085,BLOCK,1,,<empty>,,,,1,,ANY
306089,BLOCK,1,,<empty>,,,,1,,ANY
306094,BLOCK,1,,<empty>,,,,1,,ANY
306099,BLOCK,1,,<empty>,,,,1,,ANY
306103,BLOCK,1,,<empty>,,,,1,,ANY
306107,BLOCK,1,,<empty>,,,,1,,ANY
306112,BLOCK,1,,<empty>,,,,1,,ANY
306116,BLOCK,1,,<empty>,,,,1,,ANY
306121,BLOCK,1,,<empty>,,,,1,,ANY
306126,BLOCK,1,,<empty>,,,,1,,ANY
306133,BLOCK,1,,<empty>,,,,1,,ANY
306138,BLOCK,1,,<empty>,,,,1,,ANY
306144,BLOCK,1,,<empty>,,,,1,,ANY
306148,BLOCK,1,,<empty>,,,,1,,ANY
306152,BLOCK,1,,<empty>,,,,1,,ANY
306155,BLOCK,1,,<empty>,,,,1,,ANY
306159,BLOCK,1,,<empty>,,,,1,,ANY
306165,BLOCK,1,,<empty>,,,,1,,ANY
306170,BLOCK,1,,<empty>,,,,1,,ANY
306175,BLOCK,1,,<empty>,,,,1,,ANY
306179,BLOCK,1,,<empty>,,,,1,,ANY
306183,BLOCK,1,,<empty>,,,,1,,ANY
306187,BLOCK,1,,<empty>,,,,1,,ANY
306192,BLOCK,1,,<empty>,,,,1,,ANY
306196,BLOCK,1,,<empty>,,,,1,,ANY
306201,BLOCK,1,,<empty>,,,,1,,ANY
306205,BLOCK,1,,<empty>,,,,1,,ANY
306209,BLOCK,1,,<empty>,,,,1,,ANY
306213,BLOCK,1,,<empty>,,,,1,,ANY
306217,BLOCK,1,,<empty>,,,,1,,ANY
306220,BLOCK,1,,<empty>,,,,1,,ANY
306224,BLOCK,1,,<empty>,,,,1,,ANY
306228,BLOCK,1,,<empty>,,,,1,,ANY
306232,BLOCK,1,,<empty>,,,,1,,ANY
306240,BLOCK,1,,<empty>,,,,1,,ANY
306244,BLOCK,1,,<empty>,,,,1,,ANY
306249,BLOCK,1,,<empty>,,,,1,,ANY
306253,BLOCK,1,,<empty>,,,,1,,ANY
306257,BLOCK,1,,<empty>,,,,1,,ANY
306260,BLOCK,1,,<empty>,,,,1,,ANY
306264,BLOCK,1,,<empty>,,,,1,,ANY
306270,BLOCK,1,,<empty>,,,,1,,ANY
306274,BLOCK,1,,<empty>,,,,1,,ANY
306278,BLOCK,1,,<empty>,,,,1,,ANY
306282,BLOCK,1,,<empty>,,,,1,,ANY
306286,BLOCK,1,,<empty>,,,,1,,ANY
306290,BLOCK,1,,<empty>,,,,1,,ANY
306294,BLOCK,1,,<empty>,,,,1,,ANY
306302,BLOCK,1,,<empty>,,,,1,,ANY
306308,BLOCK,1,,<empty>,,,,1,,ANY
306312,BLOCK,1,,<empty>,,,,1,,ANY
306315,BLOCK,1,,<empty>,,,,1,,ANY
306320,BLOCK,1,,<empty>,,,,1,,ANY
306324,BLOCK,1,,<empty>,,,,1,,ANY
306328,BLOCK,1,,<empty>,,,,1,,ANY
306332,BLOCK,1,,<empty>,,,,1,,ANY
306336,BLOCK,1,,<empty>,,,,1,,ANY
306346,BLOCK,1,,<empty>,,,,1,,ANY
306351,BLOCK,1,,<empty>,,,,1,,ANY
306355,BLOCK,1,,<empty>,,,,1,,ANY
306360,BLOCK,1,,<empty>,,,,1,,ANY
306365,BLOCK,1,,<empty>,,,,1,,ANY
306370,BLOCK,1,,<empty>,,,,1,,ANY
306374,BLOCK,1,,<empty>,,,,1,,ANY
306379,BLOCK,1,,<empty>,,,,1,,ANY
306387,BLOCK,1,,<empty>,,,,1,,ANY
306397,BLOCK,1,,<empty>,,,,1,,ANY
306401,BLOCK,1,,<empty>,,,,1,,ANY
306406,BLOCK,1,,<empty>,,,,1,,ANY
306410,BLOCK,1,,<empty>,,,,1,,ANY
306414,BLOCK,1,,<empty>,,,,1,,ANY
306418,BLOCK,1,,<empty>,,,,1,,ANY
306421,BLOCK,1,,<empty>,,,,1,,ANY
306426,BLOCK,1,,<empty>,,,,1,,ANY
306430,BLOCK,1,,<empty>,,,,1,,ANY
306435,BLOCK,1,,<empty>,,,,1,,ANY
306439,BLOCK,1,,<empty>,,,,1,,ANY
306444,BLOCK,1,,<empty>,,,,1,,ANY
306448,BLOCK,1,,<empty>,,,,1,,ANY
306453,BLOCK,1,,<empty>,,,,1,,ANY
306457,BLOCK,1,,<empty>,,,,1,,ANY
306461,BLOCK,1,,<empty>,,,,1,,ANY
306465,BLOCK,1,,<empty>,,,,1,,ANY
306469,BLOCK,1,,<empty>,,,,1,,ANY
306474,BLOCK,1,,<empty>,,,,1,,ANY
306477,BLOCK,1,,<empty>,,,,1,,ANY
306481,BLOCK,1,,<empty>,,,,1,,ANY
306486,BLOCK,1,,<empty>,,,,1,,ANY
306490,BLOCK,1,,<empty>,,,,1,,ANY
306494,BLOCK,1,,<empty>,,,,1,,ANY
306500,BLOCK,1,,<empty>,,,,1,,ANY
306504,BLOCK,1,,<empty>,,,,1,,ANY
306509,BLOCK,1,,<empty>,,,,1,,ANY
306514,BLOCK,1,,<empty>,,,,1,,ANY
306518,BLOCK,1,,<empty>,,,,1,,ANY
306522,BLOCK,1,,<empty>,,,,1,,ANY
306528,BLOCK,1,,<empty>,,,,1,,ANY
306533,BLOCK,1,,<empty>,,,,1,,ANY
306537,BLOCK,1,,<empty>,,,,1,,ANY
306542,BLOCK,1,,<empty>,,,,1,,ANY
306547,BLOCK,1,,<empty>,,,,1,,ANY
306551,BLOCK,1,,<empty>,,,,1,,ANY
306558,BLOCK,1,,<empty>,,,,1,,ANY
306562,BLOCK,1,,<empty>,,,,1,,ANY
306566,BLOCK,1,,<empty>,,,,1,,ANY
306570,BLOCK,1,,<empty>,,,,1,,ANY
306575,BLOCK,1,,<empty>,,,,1,,ANY
306583,BLOCK,1,,<empty>,,,,1,,ANY
306587,BLOCK,1,,<empty>,,,,1,,ANY
306592,BLOCK,1,,<empty>,,,,1,,ANY
306596,BLOCK,1,,<empty>,,,,1,,ANY
306600,BLOCK,1,,<empty>,,,,1,,ANY
306605,BLOCK,1,,<empty>,,,,1,,ANY
306609,BLOCK,1,,<empty>,,,,1,,ANY
306614,BLOCK,1,,<empty>,,,,1,,ANY
306621,BLOCK,1,,<empty>,,,,1,,ANY
306625,BLOCK,1,,<empty>,,,,1,,ANY
306632,BLOCK,1,,<empty>,,,,1,,ANY
306637,BLOCK,1,,<empty>,,,,1,,ANY
306640,BLOCK,1,,<empty>,,,,1,,ANY
306644,BLOCK,1,,<empty>,,,,1,,ANY
306647,BLOCK,1,,<empty>,,,,1,,ANY
306654,BLOCK,1,,<empty>,,,,1,,ANY
306658,BLOCK,1,,<empty>,,,,1,,ANY
306661,BLOCK,1,,<empty>,,,,1,,ANY
306665,BLOCK,1,,<empty>,,,,1,,ANY
306669,BLOCK,1,,<empty>,,,,1,,ANY
306675,BLOCK,1,,<empty>,,,,1,,ANY
306680,BLOCK,1,,<empty>,,,,1,,ANY
306685,BLOCK,1,,<empty>,,,,1,,ANY
306689,BLOCK,1,,<empty>,,,,1,,ANY
306693,BLOCK,1,,<empty>,,,,1,,ANY
306699,BLOCK,1,,<empty>,,,,1,,ANY
306704,BLOCK,1,,<empty>,,,,1,,ANY
306708,BLOCK,1,,<empty>,,,,1,,ANY
306711,BLOCK,1,,<empty>,,,,1,,ANY
306716,BLOCK,1,,<empty>,,,,1,,ANY
306722,BLOCK,1,,<empty>,,,,1,,ANY
306727,BLOCK,1,,<empty>,,,,1,,ANY
306731,BLOCK,1,,<empty>,,,,1,,ANY
306735,BLOCK,1,,<empty>,,,,1,,ANY
306740,BLOCK,1,,<empty>,,,,1,,ANY
306745,BLOCK,1,,<empty>,,,,1,,ANY
306754,BLOCK,1,,<empty>,,,,1,,ANY
306761,BLOCK,1,,<empty>,,,,1,,ANY
306765,BLOCK,1,,<empty>,,,,1,,ANY
306774,BLOCK,1,,<empty>,,,,1,,ANY
306779,BLOCK,1,,<empty>,,,,1,,ANY
306783,BLOCK,1,,<empty>,,,,1,,ANY
306788,BLOCK,1,,<empty>,,,,1,,ANY
306793,BLOCK,1,,<empty>,,,,1,,ANY
306797,BLOCK,1,,<empty>,,,,1,,ANY
306801,BLOCK,1,,<empty>,,,,1,,ANY
306805,BLOCK,1,,<empty>,,,,1,,ANY
306809,BLOCK,1,,<empty>,,,,1,,ANY
306813,BLOCK,1,,<empty>,,,,1,,ANY
306817,BLOCK,1,,<empty>,,,,1,,ANY
306822,BLOCK,1,,<empty>,,,,1,,ANY
306827,BLOCK,1,,<empty>,,,,1,,ANY
306831,BLOCK,1,,<empty>,,,,1,,ANY
306835,BLOCK,1,,<empty>,,,,1,,ANY
306839,BLOCK,1,,<empty>,,,,1,,ANY
306843,BLOCK,1,,<empty>,,,,1,,ANY
306847,BLOCK,1,,<empty>,,,,1,,ANY
306851,BLOCK,1,,<empty>,,,,1,,ANY
306855,BLOCK,1,,<empty>,,,,1,,ANY
306860,BLOCK,1,,<empty>,,,,1,,ANY
306865,BLOCK,1,,<empty>,,,,1,,ANY
306869,BLOCK,1,,<empty>,,,,1,,ANY
306875,BLOCK,1,,<empty>,,,,1,,ANY
306882,BLOCK,1,,<empty>,,,,1,,ANY
306887,BLOCK,1,,<empty>,,,,1,,ANY
306893,BLOCK,1,,<empty>,,,,1,,ANY
306899,BLOCK,1,,<empty>,,,,1,,ANY
306903,BLOCK,1,,<empty>,,,,1,,ANY
306908,BLOCK,1,,<empty>,,,,1,,ANY
306913,BLOCK,1,,<empty>,,,,1,,ANY
306918,BLOCK,1,,<empty>,,,,1,,ANY
306923,BLOCK,1,,<empty>,,,,1,,ANY
306929,BLOCK,1,,<empty>,,,,1,,ANY
306936,BLOCK,1,,<empty>,,,,1,,ANY
306942,BLOCK,1,,<empty>,,,,1,,ANY
306946,BLOCK,1,,<empty>,,,,1,,ANY
306951,BLOCK,1,,<empty>,,,,1,,ANY
306957,BLOCK,1,,<empty>,,,,1,,ANY
306963,BLOCK,1,,<empty>,,,,1,,ANY
306968,BLOCK,1,,<empty>,,,,1,,ANY
306972,BLOCK,1,,<empty>,,,,1,,ANY
306976,BLOCK,1,,<empty>,,,,1,,ANY
306980,BLOCK,1,,<empty>,,,,1,,ANY
306983,BLOCK,1,,<empty>,,,,1,,ANY
306989,BLOCK,1,,<empty>,,,,1,,ANY
306992,BLOCK,1,,<empty>,,,,1,,ANY
306996,BLOCK,1,,<empty>,,,,1,,ANY
307002,BLOCK,1,,<empty>,,,,1,,ANY
307006,BLOCK,1,,<empty>,,,,1,,ANY
307012,BLOCK,1,,<empty>,,,,1,,ANY
307017,BLOCK,1,,<empty>,,,,1,,ANY
307022,BLOCK,1,,<empty>,,,,1,,ANY
307027,BLOCK,1,,<empty>,,,,1,,ANY
307032,BLOCK,1,,<empty>,,,,1,,ANY
307037,BLOCK,1,,<empty>,,,,1,,ANY
307042,BLOCK,1,,<empty>,,,,1,,ANY
307047,BLOCK,1,,<empty>,,,,1,,ANY
307051,BLOCK,1,,<empty>,,,,1,,ANY
307055,BLOCK,1,,<empty>,,,,1,,ANY
307060,BLOCK,1,,<empty>,,,,1,,ANY
307065,BLOCK,1,,<empty>,,,,1,,ANY
307070,BLOCK,1,,<empty>,,,,1,,ANY
307075,BLOCK,1,,<empty>,,,,1,,ANY
307080,BLOCK,1,,<empty>,,,,1,,ANY
307084,BLOCK,1,,<empty>,,,,1,,ANY
307090,BLOCK,1,,<empty>,,,,1,,ANY
307094,BLOCK,1,,<empty>,,,,1,,ANY
307100,BLOCK,1,,<empty>,,,,1,,ANY
307105,BLOCK,1,,<empty>,,,,1,,ANY
307109,BLOCK,1,,<empty>,,,,1,,ANY
307115,BLOCK,1,,<empty>,,,,1,,ANY
307119,BLOCK,1,,<empty>,,,,1,,ANY
307123,BLOCK,1,,<empty>,,,,1,,ANY
307129,BLOCK,1,,<empty>,,,,1,,ANY
307133,BLOCK,1,,<empty>,,,,1,,ANY
307138,BLOCK,1,,<empty>,,,,1,,ANY
307142,BLOCK,1,,<empty>,,,,1,,ANY
307147,BLOCK,1,,<empty>,,,,1,,ANY
307151,BLOCK,1,,<empty>,,,,1,,ANY
307155,BLOCK,1,,<empty>,,,,1,,ANY
307158,BLOCK,1,,<empty>,,,,1,,ANY
307162,BLOCK,1,,<empty>,,,,1,,ANY
307166,BLOCK,1,,<empty>,,,,1,,ANY
307173,BLOCK,1,,<empty>,,,,1,,ANY
307177,BLOCK,1,,<empty>,,,,1,,ANY
307181,BLOCK,1,,<empty>,,,,1,,ANY
307185,BLOCK,1,,<empty>,,,,1,,ANY
307190,BLOCK,1,,<empty>,,,,1,,ANY
307195,BLOCK,1,,<empty>,,,,1,,ANY
307199,BLOCK,1,,<empty>,,,,1,,ANY
307204,BLOCK,1,,<empty>,,,,1,,ANY
307208,BLOCK,1,,<empty>,,,,1,,ANY
307213,BLOCK,1,,<empty>,,,,1,,ANY
307217,BLOCK,1,,<empty>,,,,1,,ANY
307223,BLOCK,1,,<empty>,,,,1,,ANY
307228,BLOCK,1,,<empty>,,,,1,,ANY
307234,BLOCK,1,,<empty>,,,,1,,ANY
307237,BLOCK,1,,<empty>,,,,1,,ANY
307241,BLOCK,1,,<empty>,,,,1,,ANY
307245,BLOCK,1,,<empty>,,,,1,,ANY
307250,BLOCK,1,,<empty>,,,,1,,ANY
307257,BLOCK,1,,<empty>,,,,1,,ANY
307261,BLOCK,1,,<empty>,,,,1,,ANY
307266,BLOCK,1,,<empty>,,,,1,,ANY
307270,BLOCK,1,,<empty>,,,,1,,ANY
307273,BLOCK,1,,<empty>,,,,1,,ANY
307277,BLOCK,1,,<empty>,,,,1,,ANY
307281,BLOCK,1,,<empty>,,,,1,,ANY
307286,BLOCK,1,,<empty>,,,,1,,ANY
307292,BLOCK,1,,<empty>,,,,1,,ANY
307298,BLOCK,1,,<empty>,,,,1,,ANY
307301,BLOCK,1,,<empty>,,,,1,,ANY
307307,BLOCK,1,,<empty>,,,,1,,ANY
307313,BLOCK,1,,<empty>,,,,1,,ANY
307318,BLOCK,1,,<empty>,,,,1,,ANY
307323,BLOCK,1,,<empty>,,,,1,,ANY
307328,BLOCK,1,,<empty>,,,,1,,ANY
307335,BLOCK,1,,<empty>,,,,1,,ANY
307340,BLOCK,1,,<empty>,,,,1,,ANY
307344,BLOCK,1,,<empty>,,,,1,,ANY
307348,BLOCK,1,,<empty>,,,,1,,ANY
307354,BLOCK,1,,<empty>,,,,1,,ANY
307358,BLOCK,1,,<empty>,,,,1,,ANY
307363,BLOCK,1,,<empty>,,,,1,,ANY
307370,BLOCK,1,,<empty>,,,,1,,ANY
307374,BLOCK,1,,<empty>,,,,1,,ANY
307378,BLOCK,1,,<empty>,,,,1,,ANY
307382,BLOCK,1,,<empty>,,,,1,,ANY
307386,BLOCK,1,,<empty>,,,,1,,ANY
307390,BLOCK,1,,<empty>,,,,1,,ANY
307394,BLOCK,1,,<empty>,,,,1,,ANY
307399,BLOCK,1,,<empty>,,,,1,,ANY
307402,BLOCK,1,,<empty>,,,,1,,ANY
307406,BLOCK,1,,<empty>,,,,1,,ANY
307410,BLOCK,1,,<empty>,,,,1,,ANY
307414,BLOCK,1,,<empty>,,,,1,,ANY
307418,BLOCK,1,,<empty>,,,,1,,ANY
307421,BLOCK,1,,<empty>,,,,1,,ANY
307424,BLOCK,1,,<empty>,,,,1,,ANY
307429,BLOCK,1,,<empty>,,,,1,,ANY
307434,BLOCK,1,,<empty>,,,,1,,ANY
307439,BLOCK,1,,<empty>,,,,1,,ANY
307444,BLOCK,1,,<empty>,,,,1,,ANY
307449,BLOCK,1,,<empty>,,,,1,,ANY
307454,BLOCK,1,,<empty>,,,,1,,ANY
307458,BLOCK,1,,<empty>,,,,1,,ANY
307465,BLOCK,1,,<empty>,,,,1,,ANY
307470,BLOCK,1,,<empty>,,,,1,,ANY
307474,BLOCK,1,,<empty>,,,,1,,ANY
307478,BLOCK,1,,<empty>,,,,1,,ANY
307484,BLOCK,1,,<empty>,,,,1,,ANY
307488,BLOCK,1,,<empty>,,,,1,,ANY
307492,BLOCK,1,,<empty>,,,,1,,ANY
307496,BLOCK,1,,<empty>,,,,1,,ANY
307500,BLOCK,1,,<empty>,,,,1,,ANY
307505,BLOCK,1,,<empty>,,,,1,,ANY
307510,BLOCK,1,,<empty>,,,,1,,ANY
307514,BLOCK,1,,<empty>,,,,1,,ANY
307522,BLOCK,1,,<empty>,,,,1,,ANY
307529,BLOCK,1,,<empty>,,,,1,,ANY
307533,BLOCK,1,,<empty>,,,,1,,ANY
307539,BLOCK,1,,<empty>,,,,1,,ANY
307543,BLOCK,1,,<empty>,,,,1,,ANY
307548,BLOCK,1,,<empty>,,,,1,,ANY
307552,BLOCK,1,,<empty>,,,,1,,ANY
307556,BLOCK,1,,<empty>,,,,1,,ANY
307561,BLOCK,1,,<empty>,,,,1,,ANY
307566,BLOCK,1,,<empty>,,,,1,,ANY
307572,BLOCK,1,,<empty>,,,,1,,ANY
307576,BLOCK,1,,<empty>,,,,1,,ANY
307580,BLOCK,1,,<empty>,,,,1,,ANY
307586,BLOCK,1,,<empty>,,,,1,,ANY
307592,BLOCK,1,,<empty>,,,,1,,ANY
307596,BLOCK,1,,<empty>,,,,1,,ANY
307600,BLOCK,1,,<empty>,,,,1,,ANY
307604,BLOCK,1,,<empty>,,,,1,,ANY
307609,BLOCK,1,,<empty>,,,,1,,ANY
307613,BLOCK,1,,<empty>,,,,1,,ANY
307617,BLOCK,1,,<empty>,,,,1,,ANY
307626,BLOCK,1,,<empty>,,,,1,,ANY
307632,BLOCK,1,,<empty>,,,,1,,ANY
307635,BLOCK,1,,<empty>,,,,1,,ANY
307639,BLOCK,1,,<empty>,,,,1,,ANY
307645,BLOCK,1,,<empty>,,,,1,,ANY
307649,BLOCK,1,,<empty>,,,,1,,ANY
307653,BLOCK,1,,<empty>,,,,1,,ANY
307658,BLOCK,1,,<empty>,,,,1,,ANY
307664,BLOCK,1,,<empty>,,,,1,,ANY
307671,BLOCK,1,,<empty>,,,,1,,ANY
307675,BLOCK,1,,<empty>,,,,1,,ANY
307678,BLOCK,1,,<empty>,,,,1,,ANY
307682,BLOCK,1,,<empty>,,,,1,,ANY
307686,BLOCK,1,,<empty>,,,,1,,ANY
307690,BLOCK,1,,<empty>,,,,1,,ANY
307694,BLOCK,1,,<empty>,,,,1,,ANY
307697,BLOCK,1,,<empty>,,,,1,,ANY
307701,BLOCK,1,,<empty>,,,,1,,ANY
307705,BLOCK,1,,<empty>,,,,1,,ANY
307709,BLOCK,1,,<empty>,,,,1,,ANY
307713,BLOCK,1,,<empty>,,,,1,,ANY
307717,BLOCK,1,,<empty>,,,,1,,ANY
307725,BLOCK,1,,<empty>,,,,1,,ANY
307729,BLOCK,1,,<empty>,,,,1,,ANY
307733,BLOCK,1,,<empty>,,,,1,,ANY
307739,BLOCK,1,,<empty>,,,,1,,ANY
307743,BLOCK,1,,<empty>,,,,1,,ANY
307747,BLOCK,1,,<empty>,,,,1,,ANY
307751,BLOCK,1,,<empty>,,,,1,,ANY
307755,BLOCK,1,,<empty>,,,,1,,ANY
307759,BLOCK,1,,<empty>,,,,1,,ANY
307763,BLOCK,1,,<empty>,,,,1,,ANY
307767,BLOCK,1,,<empty>,,,,1,,ANY
307771,BLOCK,1,,<empty>,,,,1,,ANY
307777,BLOCK,1,,<empty>,,,,1,,ANY
307781,BLOCK,1,,<empty>,,,,1,,ANY
307784,BLOCK,1,,<empty>,,,,1,,ANY
307789,BLOCK,1,,<empty>,,,,1,,ANY
307794,BLOCK,1,,<empty>,,,,1,,ANY
307799,BLOCK,1,,<empty>,,,,1,,ANY
307804,BLOCK,1,,<empty>,,,,1,,ANY
307809,BLOCK,1,,<empty>,,,,1,,ANY
307813,BLOCK,1,,<empty>,,,,1,,ANY
307816,BLOCK,1,,<empty>,,,,1,,ANY
307821,BLOCK,1,,<empty>,,,,1,,ANY
307825,BLOCK,1,,<empty>,,,,1,,ANY
307830,BLOCK,1,,<empty>,,,,1,,ANY
307835,BLOCK,1,,<empty>,,,,1,,ANY
307842,BLOCK,1,,<empty>,,,,1,,ANY
307847,BLOCK,1,,<empty>,,,,1,,ANY
307854,BLOCK,1,,<empty>,,,,1,,ANY
307859,BLOCK,1,,<empty>,,,,1,,ANY
307863,BLOCK,1,,<empty>,,,,1,,ANY
307867,BLOCK,1,,<empty>,,,,1,,ANY
307871,BLOCK,1,,<empty>,,,,1,,ANY
307875,BLOCK,1,,<empty>,,,,1,,ANY
307879,BLOCK,1,,<empty>,,,,1,,ANY
307883,BLOCK,1,,<empty>,,,,1,,ANY
307887,BLOCK,1,,<empty>,,,,1,,ANY
307890,BLOCK,1,,<empty>,,,,1,,ANY
307896,BLOCK,1,,<empty>,,,,1,,ANY
307902,BLOCK,1,,<empty>,,,,1,,ANY
307908,BLOCK,1,,<empty>,,,,1,,ANY
307914,BLOCK,1,,<empty>,,,,1,,ANY
307920,BLOCK,1,,<empty>,,,,1,,ANY
307926,BLOCK,1,,<empty>,,,,1,,ANY
307932,BLOCK,1,,<empty>,,,,1,,ANY
307938,BLOCK,1,,<empty>,,,,1,,ANY
307944,BLOCK,1,,<empty>,,,,1,,ANY
307950,BLOCK,1,,<empty>,,,,1,,ANY
307956,BLOCK,1,,<empty>,,,,1,,ANY
307962,BLOCK,1,,<empty>,,,,1,,ANY
307968,BLOCK,1,,<empty>,,,,1,,ANY
307976,BLOCK,1,,<empty>,,,,1,,ANY
307984,BLOCK,1,,<empty>,,,,1,,ANY
307989,BLOCK,1,,<empty>,,,,1,,ANY
307994,BLOCK,1,,<empty>,,,,1,,ANY
307999,BLOCK,1,,<empty>,,,,1,,ANY
308004,BLOCK,1,,<empty>,,,,1,,ANY
308009,BLOCK,1,,<empty>,,,,1,,ANY
308014,BLOCK,1,,<empty>,,,,1,,ANY
308019,BLOCK,1,,<empty>,,,,1,,ANY
308024,BLOCK,1,,<empty>,,,,1,,ANY
308028,BLOCK,1,,<empty>,,,,1,,ANY
308032,BLOCK,1,,<empty>,,,,1,,ANY
308037,BLOCK,1,,<empty>,,,,1,,ANY
308041,BLOCK,1,,<empty>,,,,1,,ANY
308044,BLOCK,1,,<empty>,,,,1,,ANY
308048,BLOCK,1,,<empty>,,,,1,,ANY
308053,BLOCK,1,,<empty>,,,,1,,ANY
308056,BLOCK,1,,<empty>,,,,1,,ANY
308059,BLOCK,1,,<empty>,,,,1,,ANY
308064,BLOCK,1,,<empty>,,,,1,,ANY
308068,BLOCK,1,,<empty>,,,,1,,ANY
308072,BLOCK,1,,<empty>,,,,1,,ANY
308076,BLOCK,1,,<empty>,,,,1,,ANY
308080,BLOCK,1,,<empty>,,,,1,,ANY
308084,BLOCK,1,,<empty>,,,,1,,ANY
308087,BLOCK,1,,<empty>,,,,1,,ANY
308092,BLOCK,1,,<empty>,,,,1,,ANY
308096,BLOCK,1,,<empty>,,,,1,,ANY
308101,BLOCK,1,,<empty>,,,,1,,ANY
308106,BLOCK,1,,<empty>,,,,1,,ANY
308109,BLOCK,1,,<empty>,,,,1,,ANY
308115,BLOCK,1,,<empty>,,,,1,,ANY
308119,BLOCK,1,,<empty>,,,,1,,ANY
308123,BLOCK,1,,<empty>,,,,1,,ANY
308127,BLOCK,1,,<empty>,,,,1,,ANY
308131,BLOCK,1,,<empty>,,,,1,,ANY
308136,BLOCK,1,,<empty>,,,,1,,ANY
308140,BLOCK,1,,<empty>,,,,1,,ANY
308144,BLOCK,1,,<empty>,,,,1,,ANY
308149,BLOCK,1,,<empty>,,,,1,,ANY
308153,BLOCK,1,,<empty>,,,,1,,ANY
308156,BLOCK,1,,<empty>,,,,1,,ANY
308159,BLOCK,1,,<empty>,,,,1,,ANY
308163,BLOCK,1,,<empty>,,,,1,,ANY
308166,BLOCK,1,,<empty>,,,,1,,ANY
308170,BLOCK,1,,<empty>,,,,1,,ANY
308177,BLOCK,1,,<empty>,,,,1,,ANY
308181,BLOCK,1,,<empty>,,,,1,,ANY
308185,BLOCK,1,,<empty>,,,,1,,ANY
308190,BLOCK,1,,<empty>,,,,1,,ANY
308195,BLOCK,1,,<empty>,,,,1,,ANY
308199,BLOCK,1,,<empty>,,,,1,,ANY
308202,BLOCK,1,,<empty>,,,,1,,ANY
308208,BLOCK,1,,<empty>,,,,1,,ANY
308212,BLOCK,1,,<empty>,,,,1,,ANY
308216,BLOCK,1,,<empty>,,,,1,,ANY
308220,BLOCK,1,,<empty>,,,,1,,ANY
308224,BLOCK,1,,<empty>,,,,1,,ANY
308230,BLOCK,1,,<empty>,,,,1,,ANY
308236,BLOCK,1,,<empty>,,,,1,,ANY
308242,BLOCK,1,,<empty>,,,,1,,ANY
308248,BLOCK,1,,<empty>,,,,1,,ANY
308251,BLOCK,1,,<empty>,,,,1,,ANY
308256,BLOCK,1,,<empty>,,,,1,,ANY
308260,BLOCK,1,,<empty>,,,,1,,ANY
308266,BLOCK,1,,<empty>,,,,1,,ANY
308273,BLOCK,1,,<empty>,,,,1,,ANY
308277,BLOCK,1,,<empty>,,,,1,,ANY
308283,BLOCK,1,,<empty>,,,,1,,ANY
308287,BLOCK,1,,<empty>,,,,1,,ANY
308295,BLOCK,1,,<empty>,,,,1,,ANY
308303,BLOCK,1,,<empty>,,,,1,,ANY
308309,BLOCK,1,,<empty>,,,,1,,ANY
308318,BLOCK,1,,<empty>,,,,1,,ANY
308322,BLOCK,1,,<empty>,,,,1,,ANY
308327,BLOCK,1,,<empty>,,,,1,,ANY
308333,BLOCK,1,,<empty>,,,,1,,ANY
308337,BLOCK,1,,<empty>,,,,1,,ANY
308341,BLOCK,1,,<empty>,,,,1,,ANY
308345,BLOCK,1,,<empty>,,,,1,,ANY
308349,BLOCK,1,,<empty>,,,,1,,ANY
308355,BLOCK,1,,<empty>,,,,1,,ANY
308359,BLOCK,1,,<empty>,,,,1,,ANY
308363,BLOCK,1,,<empty>,,,,1,,ANY
308369,BLOCK,1,,<empty>,,,,1,,ANY
308373,BLOCK,1,,<empty>,,,,1,,ANY
308377,BLOCK,1,,<empty>,,,,1,,ANY
308383,BLOCK,1,,<empty>,,,,1,,ANY
308388,BLOCK,1,,<empty>,,,,1,,ANY
308392,BLOCK,1,,<empty>,,,,1,,ANY
308396,BLOCK,1,,<empty>,,,,1,,ANY
308400,BLOCK,1,,<empty>,,,,1,,ANY
308406,BLOCK,1,,<empty>,,,,1,,ANY
308410,BLOCK,1,,<empty>,,,,1,,ANY
308414,BLOCK,1,,<empty>,,,,1,,ANY
308418,BLOCK,1,,<empty>,,,,1,,ANY
308422,BLOCK,1,,<empty>,,,,1,,ANY
308426,BLOCK,1,,<empty>,,,,1,,ANY
308430,BLOCK,1,,<empty>,,,,1,,ANY
308434,BLOCK,1,,<empty>,,,,1,,ANY
308438,BLOCK,1,,<empty>,,,,1,,ANY
308446,BLOCK,1,,<empty>,,,,1,,ANY
308450,BLOCK,1,,<empty>,,,,1,,ANY
308455,BLOCK,1,,<empty>,,,,1,,ANY
308459,BLOCK,1,,<empty>,,,,1,,ANY
308463,BLOCK,1,,<empty>,,,,1,,ANY
308467,BLOCK,1,,<empty>,,,,1,,ANY
308471,BLOCK,1,,<empty>,,,,1,,ANY
308475,BLOCK,1,,<empty>,,,,1,,ANY
308479,BLOCK,1,,<empty>,,,,1,,ANY
308483,BLOCK,1,,<empty>,,,,1,,ANY
308487,BLOCK,1,,<empty>,,,,1,,ANY
308491,BLOCK,1,,<empty>,,,,1,,ANY
308495,BLOCK,1,,<empty>,,,,1,,ANY
308499,BLOCK,1,,<empty>,,,,1,,ANY
308503,BLOCK,1,,<empty>,,,,1,,ANY
308506,BLOCK,1,,<empty>,,,,1,,ANY
308512,BLOCK,1,,<empty>,,,,1,,ANY
308516,BLOCK,1,,<empty>,,,,1,,ANY
308520,BLOCK,1,,<empty>,,,,1,,ANY
308526,BLOCK,1,,<empty>,,,,1,,ANY
308532,BLOCK,1,,<empty>,,,,1,,ANY
308536,BLOCK,1,,<empty>,,,,1,,ANY
308541,BLOCK,1,,<empty>,,,,1,,ANY
308545,BLOCK,1,,<empty>,,,,1,,ANY
308551,BLOCK,1,,<empty>,,,,1,,ANY
308554,BLOCK,1,,<empty>,,,,1,,ANY
308559,BLOCK,1,,<empty>,,,,1,,ANY
308563,BLOCK,1,,<empty>,,,,1,,ANY
308570,BLOCK,1,,<empty>,,,,1,,ANY
308575,BLOCK,1,,<empty>,,,,1,,ANY
308579,BLOCK,1,,<empty>,,,,1,,ANY
308586,BLOCK,1,,<empty>,,,,1,,ANY
308589,BLOCK,1,,<empty>,,,,1,,ANY
308597,BLOCK,1,,<empty>,,,,1,,ANY
308601,BLOCK,1,,<empty>,,,,1,,ANY
308605,BLOCK,1,,<empty>,,,,1,,ANY
308609,BLOCK,1,,<empty>,,,,1,,ANY
308613,BLOCK,1,,<empty>,,,,1,,ANY
308617,BLOCK,1,,<empty>,,,,1,,ANY
308621,BLOCK,1,,<empty>,,,,1,,ANY
308628,BLOCK,1,,<empty>,,,,1,,ANY
308632,BLOCK,1,,<empty>,,,,1,,ANY
308639,BLOCK,1,,<empty>,,,,1,,ANY
308646,BLOCK,1,,<empty>,,,,1,,ANY
308650,BLOCK,1,,<empty>,,,,1,,ANY
308657,BLOCK,1,,<empty>,,,,1,,ANY
308660,BLOCK,1,,<empty>,,,,1,,ANY
308667,BLOCK,1,,<empty>,,,,1,,ANY
308674,BLOCK,1,,<empty>,,,,1,,ANY
308679,BLOCK,1,,<empty>,,,,1,,ANY
308685,BLOCK,1,,<empty>,,,,1,,ANY
308691,BLOCK,1,,<empty>,,,,1,,ANY
308701,BLOCK,1,,<empty>,,,,1,,ANY
308706,BLOCK,1,,<empty>,,,,1,,ANY
308710,BLOCK,1,,<empty>,,,,1,,ANY
308719,BLOCK,1,,<empty>,,,,1,,ANY
308723,BLOCK,1,,<empty>,,,,1,,ANY
308727,BLOCK,1,,<empty>,,,,1,,ANY
308731,BLOCK,1,,<empty>,,,,1,,ANY
308736,BLOCK,1,,<empty>,,,,1,,ANY
308740,BLOCK,1,,<empty>,,,,1,,ANY
308745,BLOCK,1,,<empty>,,,,1,,ANY
308750,BLOCK,1,,<empty>,,,,1,,ANY
308757,BLOCK,1,,<empty>,,,,1,,ANY
308761,BLOCK,1,,<empty>,,,,1,,ANY
308765,BLOCK,1,,<empty>,,,,1,,ANY
308769,BLOCK,1,,<empty>,,,,1,,ANY
308773,BLOCK,1,,<empty>,,,,1,,ANY
308783,BLOCK,1,,<empty>,,,,1,,ANY
308787,BLOCK,1,,<empty>,,,,1,,ANY
308792,BLOCK,1,,<empty>,,,,1,,ANY
308796,BLOCK,1,,<empty>,,,,1,,ANY
308801,BLOCK,1,,<empty>,,,,1,,ANY
308811,BLOCK,1,,<empty>,,,,1,,ANY
308815,BLOCK,1,,<empty>,,,,1,,ANY
308821,BLOCK,1,,<empty>,,,,1,,ANY
308827,BLOCK,1,,<empty>,,,,1,,ANY
308831,BLOCK,1,,<empty>,,,,1,,ANY
308835,BLOCK,1,,<empty>,,,,1,,ANY
308839,BLOCK,1,,<empty>,,,,1,,ANY
308844,BLOCK,1,,<empty>,,,,1,,ANY
308848,BLOCK,1,,<empty>,,,,1,,ANY
308853,BLOCK,1,,<empty>,,,,1,,ANY
308858,BLOCK,1,,<empty>,,,,1,,ANY
308863,BLOCK,1,,<empty>,,,,1,,ANY
308868,BLOCK,1,,<empty>,,,,1,,ANY
308873,BLOCK,1,,<empty>,,,,1,,ANY
308878,BLOCK,1,,<empty>,,,,1,,ANY
308883,BLOCK,1,,<empty>,,,,1,,ANY
308888,BLOCK,1,,<empty>,,,,1,,ANY
308894,BLOCK,1,,<empty>,,,,1,,ANY
308898,BLOCK,1,,<empty>,,,,1,,ANY
308902,BLOCK,1,,<empty>,,,,1,,ANY
308906,BLOCK,1,,<empty>,,,,1,,ANY
308913,BLOCK,1,,<empty>,,,,1,,ANY
308916,BLOCK,1,,<empty>,,,,1,,ANY
308919,BLOCK,1,,<empty>,,,,1,,ANY
308924,BLOCK,1,,<empty>,,,,1,,ANY
308929,BLOCK,1,,<empty>,,,,1,,ANY
308936,BLOCK,1,,<empty>,,,,1,,ANY
308943,BLOCK,1,,<empty>,,,,1,,ANY
308948,BLOCK,1,,<empty>,,,,1,,ANY
308952,BLOCK,1,,<empty>,,,,1,,ANY
308959,BLOCK,1,,<empty>,,,,1,,ANY
308963,BLOCK,1,,<empty>,,,,1,,ANY
308968,BLOCK,1,,<empty>,,,,1,,ANY
308972,BLOCK,1,,<empty>,,,,1,,ANY
308979,BLOCK,1,,<empty>,,,,1,,ANY
308984,BLOCK,1,,<empty>,,,,1,,ANY
308988,BLOCK,1,,<empty>,,,,1,,ANY
308992,BLOCK,1,,<empty>,,,,1,,ANY
308996,BLOCK,1,,<empty>,,,,1,,ANY
309004,BLOCK,1,,<empty>,,,,1,,ANY
309008,BLOCK,1,,<empty>,,,,1,,ANY
309012,BLOCK,1,,<empty>,,,,1,,ANY
309016,BLOCK,1,,<empty>,,,,1,,ANY
309019,BLOCK,1,,<empty>,,,,1,,ANY
309023,BLOCK,1,,<empty>,,,,1,,ANY
309028,BLOCK,1,,<empty>,,,,1,,ANY
309037,BLOCK,1,,<empty>,,,,1,,ANY
309044,BLOCK,1,,<empty>,,,,1,,ANY
309049,BLOCK,1,,<empty>,,,,1,,ANY
309053,BLOCK,1,,<empty>,,,,1,,ANY
309057,BLOCK,1,,<empty>,,,,1,,ANY
309061,BLOCK,1,,<empty>,,,,1,,ANY
309065,BLOCK,1,,<empty>,,,,1,,ANY
309069,BLOCK,1,,<empty>,,,,1,,ANY
309077,BLOCK,1,,<empty>,,,,1,,ANY
309082,BLOCK,1,,<empty>,,,,1,,ANY
309087,BLOCK,1,,<empty>,,,,1,,ANY
309093,BLOCK,1,,<empty>,,,,1,,ANY
309098,BLOCK,1,,<empty>,,,,1,,ANY
309103,BLOCK,1,,<empty>,,,,1,,ANY
309107,BLOCK,1,,<empty>,,,,1,,ANY
309113,BLOCK,1,,<empty>,,,,1,,ANY
309118,BLOCK,1,,<empty>,,,,1,,ANY
309123,BLOCK,1,,<empty>,,,,1,,ANY
309128,BLOCK,1,,<empty>,,,,1,,ANY
309132,BLOCK,1,,<empty>,,,,1,,ANY
309137,BLOCK,1,,<empty>,,,,1,,ANY
309141,BLOCK,1,,<empty>,,,,1,,ANY
309145,BLOCK,1,,<empty>,,,,1,,ANY
309148,BLOCK,1,,<empty>,,,,1,,ANY
309154,BLOCK,1,,<empty>,,,,1,,ANY
309157,BLOCK,1,,<empty>,,,,1,,ANY
309161,BLOCK,1,,<empty>,,,,1,,ANY
309165,BLOCK,1,,<empty>,,,,1,,ANY
309170,BLOCK,1,,<empty>,,,,1,,ANY
309175,BLOCK,1,,<empty>,,,,1,,ANY
309179,BLOCK,1,,<empty>,,,,1,,ANY
309185,BLOCK,1,,<empty>,,,,1,,ANY
309190,BLOCK,1,,<empty>,,,,1,,ANY
309199,BLOCK,1,,<empty>,,,,1,,ANY
309203,BLOCK,1,,<empty>,,,,1,,ANY
309209,BLOCK,1,,<empty>,,,,1,,ANY
309213,BLOCK,1,,<empty>,,,,1,,ANY
309217,BLOCK,1,,<empty>,,,,1,,ANY
309221,BLOCK,1,,<empty>,,,,1,,ANY
309226,BLOCK,1,,<empty>,,,,1,,ANY
309230,BLOCK,1,,<empty>,,,,1,,ANY
309234,BLOCK,1,,<empty>,,,,1,,ANY
309238,BLOCK,1,,<empty>,,,,1,,ANY
309242,BLOCK,1,,<empty>,,,,1,,ANY
309246,BLOCK,1,,<empty>,,,,1,,ANY
309250,BLOCK,1,,<empty>,,,,1,,ANY
309254,BLOCK,1,,<empty>,,,,1,,ANY
309258,BLOCK,1,,<empty>,,,,1,,ANY
309262,BLOCK,1,,<empty>,,,,1,,ANY
309266,BLOCK,1,,<empty>,,,,1,,ANY
309272,BLOCK,1,,<empty>,,,,1,,ANY
309279,BLOCK,1,,<empty>,,,,1,,ANY
309285,BLOCK,1,,<empty>,,,,1,,ANY
309289,BLOCK,1,,<empty>,,,,1,,ANY
309297,BLOCK,1,,<empty>,,,,1,,ANY
309304,BLOCK,1,,<empty>,,,,1,,ANY
309308,BLOCK,1,,<empty>,,,,1,,ANY
309312,BLOCK,1,,<empty>,,,,1,,ANY
309316,BLOCK,1,,<empty>,,,,1,,ANY
309320,BLOCK,1,,<empty>,,,,1,,ANY
309326,BLOCK,1,,<empty>,,,,1,,ANY
309331,BLOCK,1,,<empty>,,,,1,,ANY
309336,BLOCK,1,,<empty>,,,,1,,ANY
309341,BLOCK,1,,<empty>,,,,1,,ANY
309346,BLOCK,1,,<empty>,,,,1,,ANY
309351,BLOCK,1,,<empty>,,,,1,,ANY
309356,BLOCK,1,,<empty>,,,,1,,ANY
309361,BLOCK,1,,<empty>,,,,1,,ANY
309366,BLOCK,1,,<empty>,,,,1,,ANY
309371,BLOCK,1,,<empty>,,,,1,,ANY
309376,BLOCK,1,,<empty>,,,,1,,ANY
309381,BLOCK,1,,<empty>,,,,1,,ANY
309387,BLOCK,1,,<empty>,,,,1,,ANY
309392,BLOCK,1,,<empty>,,,,1,,ANY
309395,BLOCK,1,,<empty>,,,,1,,ANY
309400,BLOCK,1,,<empty>,,,,1,,ANY
309405,BLOCK,1,,<empty>,,,,1,,ANY
309409,BLOCK,1,,<empty>,,,,1,,ANY
309413,BLOCK,1,,<empty>,,,,1,,ANY
309417,BLOCK,1,,<empty>,,,,1,,ANY
309421,BLOCK,1,,<empty>,,,,1,,ANY
309425,BLOCK,1,,<empty>,,,,1,,ANY
309430,BLOCK,1,,<empty>,,,,1,,ANY
309434,BLOCK,1,,<empty>,,,,1,,ANY
309438,BLOCK,1,,<empty>,,,,1,,ANY
309447,BLOCK,1,,<empty>,,,,1,,ANY
309453,BLOCK,1,,<empty>,,,,1,,ANY
309457,BLOCK,1,,<empty>,,,,1,,ANY
309462,BLOCK,1,,<empty>,,,,1,,ANY
309467,BLOCK,1,,<empty>,,,,1,,ANY
309473,BLOCK,1,,<empty>,,,,1,,ANY
309478,BLOCK,1,,<empty>,,,,1,,ANY
309481,BLOCK,1,,<empty>,,,,1,,ANY
309484,BLOCK,1,,<empty>,,,,1,,ANY
309488,BLOCK,1,,<empty>,,,,1,,ANY
309493,BLOCK,1,,<empty>,,,,1,,ANY
309499,BLOCK,1,,<empty>,,,,1,,ANY
309504,BLOCK,1,,<empty>,,,,1,,ANY
309507,BLOCK,1,,<empty>,,,,1,,ANY
309513,BLOCK,1,,<empty>,,,,1,,ANY
309521,BLOCK,1,,<empty>,,,,1,,ANY
309525,BLOCK,1,,<empty>,,,,1,,ANY
309529,BLOCK,1,,<empty>,,,,1,,ANY
309533,BLOCK,1,,<empty>,,,,1,,ANY
309537,BLOCK,1,,<empty>,,,,1,,ANY
309541,BLOCK,1,,<empty>,,,,1,,ANY
309545,BLOCK,1,,<empty>,,,,1,,ANY
309549,BLOCK,1,,<empty>,,,,1,,ANY
309553,BLOCK,1,,<empty>,,,,1,,ANY
309559,BLOCK,1,,<empty>,,,,1,,ANY
309563,BLOCK,1,,<empty>,,,,1,,ANY
309567,BLOCK,1,,<empty>,,,,1,,ANY
309571,BLOCK,1,,<empty>,,,,1,,ANY
309575,BLOCK,1,,<empty>,,,,1,,ANY
309579,BLOCK,1,,<empty>,,,,1,,ANY
309583,BLOCK,1,,<empty>,,,,1,,ANY
309588,BLOCK,1,,<empty>,,,,1,,ANY
309592,BLOCK,1,,<empty>,,,,1,,ANY
309597,BLOCK,1,,<empty>,,,,1,,ANY
309601,BLOCK,1,,<empty>,,,,1,,ANY
309606,BLOCK,1,,<empty>,,,,1,,ANY
309614,BLOCK,1,,<empty>,,,,1,,ANY
309622,BLOCK,1,,<empty>,,,,1,,ANY
309628,BLOCK,1,,<empty>,,,,1,,ANY
309632,BLOCK,1,,<empty>,,,,1,,ANY
309635,BLOCK,1,,<empty>,,,,1,,ANY
309639,BLOCK,1,,<empty>,,,,1,,ANY
309650,BLOCK,1,,<empty>,,,,1,,ANY
309653,BLOCK,1,,<empty>,,,,1,,ANY
309658,BLOCK,1,,<empty>,,,,1,,ANY
309668,BLOCK,1,,<empty>,,,,1,,ANY
309673,BLOCK,1,,<empty>,,,,1,,ANY
309677,BLOCK,1,,<empty>,,,,1,,ANY
309684,BLOCK,1,,<empty>,,,,1,,ANY
309690,BLOCK,1,,<empty>,,,,1,,ANY
309694,BLOCK,1,,<empty>,,,,1,,ANY
309698,BLOCK,1,,<empty>,,,,1,,ANY
309706,BLOCK,1,,<empty>,,,,1,,ANY
309710,BLOCK,1,,<empty>,,,,1,,ANY
309714,BLOCK,1,,<empty>,,,,1,,ANY
309720,BLOCK,1,,<empty>,,,,1,,ANY
309724,BLOCK,1,,<empty>,,,,1,,ANY
309731,BLOCK,1,,<empty>,,,,1,,ANY
309735,BLOCK,1,,<empty>,,,,1,,ANY
309739,BLOCK,1,,<empty>,,,,1,,ANY
309745,BLOCK,1,,<empty>,,,,1,,ANY
309750,BLOCK,1,,<empty>,,,,1,,ANY
309754,BLOCK,1,,<empty>,,,,1,,ANY
309757,BLOCK,1,,<empty>,,,,1,,ANY
309763,BLOCK,1,,<empty>,,,,1,,ANY
309767,BLOCK,1,,<empty>,,,,1,,ANY
309773,BLOCK,1,,<empty>,,,,1,,ANY
309777,BLOCK,1,,<empty>,,,,1,,ANY
309784,BLOCK,1,,<empty>,,,,1,,ANY
309789,BLOCK,1,,<empty>,,,,1,,ANY
309794,BLOCK,1,,<empty>,,,,1,,ANY
309799,BLOCK,1,,<empty>,,,,1,,ANY
309804,BLOCK,1,,<empty>,,,,1,,ANY
309809,BLOCK,1,,<empty>,,,,1,,ANY
309813,BLOCK,1,,<empty>,,,,1,,ANY
309818,BLOCK,1,,<empty>,,,,1,,ANY
309823,BLOCK,1,,<empty>,,,,1,,ANY
309828,BLOCK,1,,<empty>,,,,1,,ANY
309836,BLOCK,1,,<empty>,,,,1,,ANY
309842,BLOCK,1,,<empty>,,,,1,,ANY
309847,BLOCK,1,,<empty>,,,,1,,ANY
309851,BLOCK,1,,<empty>,,,,1,,ANY
309855,BLOCK,1,,<empty>,,,,1,,ANY
309859,BLOCK,1,,<empty>,,,,1,,ANY
309869,BLOCK,1,,<empty>,,,,1,,ANY
309874,BLOCK,1,,<empty>,,,,1,,ANY
309879,BLOCK,1,,<empty>,,,,1,,ANY
309883,BLOCK,1,,<empty>,,,,1,,ANY
309888,BLOCK,1,,<empty>,,,,1,,ANY
309893,BLOCK,1,,<empty>,,,,1,,ANY
309899,BLOCK,1,,<empty>,,,,1,,ANY
309903,BLOCK,1,,<empty>,,,,1,,ANY
309907,BLOCK,1,,<empty>,,,,1,,ANY
309911,BLOCK,1,,<empty>,,,,1,,ANY
309914,BLOCK,1,,<empty>,,,,1,,ANY
309921,BLOCK,1,,<empty>,,,,1,,ANY
309927,BLOCK,1,,<empty>,,,,1,,ANY
309931,BLOCK,1,,<empty>,,,,1,,ANY
309935,BLOCK,1,,<empty>,,,,1,,ANY
309941,BLOCK,1,,<empty>,,,,1,,ANY
309947,BLOCK,1,,<empty>,,,,1,,ANY
309952,BLOCK,1,,<empty>,,,,1,,ANY
309957,BLOCK,1,,<empty>,,,,1,,ANY
309962,BLOCK,1,,<empty>,,,,1,,ANY
309966,BLOCK,1,,<empty>,,,,1,,ANY
309972,BLOCK,1,,<empty>,,,,1,,ANY
309976,BLOCK,1,,<empty>,,,,1,,ANY
309980,BLOCK,1,,<empty>,,,,1,,ANY
309984,BLOCK,1,,<empty>,,,,1,,ANY
309988,BLOCK,1,,<empty>,,,,1,,ANY
309992,BLOCK,1,,<empty>,,,,1,,ANY
309996,BLOCK,1,,<empty>,,,,1,,ANY
310000,BLOCK,1,,<empty>,,,,1,,ANY
310004,BLOCK,1,,<empty>,,,,1,,ANY
310008,BLOCK,1,,<empty>,,,,1,,ANY
310012,BLOCK,1,,<empty>,,,,1,,ANY
310017,BLOCK,1,,<empty>,,,,1,,ANY
310022,BLOCK,1,,<empty>,,,,1,,ANY
310027,BLOCK,1,,<empty>,,,,1,,ANY
310032,BLOCK,1,,<empty>,,,,1,,ANY
310039,BLOCK,1,,<empty>,,,,1,,ANY
310044,BLOCK,1,,<empty>,,,,1,,ANY
310049,BLOCK,1,,<empty>,,,,1,,ANY
310052,BLOCK,1,,<empty>,,,,1,,ANY
310056,BLOCK,1,,<empty>,,,,1,,ANY
310060,BLOCK,1,,<empty>,,,,1,,ANY
310064,BLOCK,1,,<empty>,,,,1,,ANY
310069,BLOCK,1,,<empty>,,,,1,,ANY
310074,BLOCK,1,,<empty>,,,,1,,ANY
310078,BLOCK,1,,<empty>,,,,1,,ANY
310082,BLOCK,1,,<empty>,,,,1,,ANY
310087,BLOCK,1,,<empty>,,,,1,,ANY
310091,BLOCK,1,,<empty>,,,,1,,ANY
310096,BLOCK,1,,<empty>,,,,1,,ANY
310101,BLOCK,1,,<empty>,,,,1,,ANY
310108,BLOCK,1,,<empty>,,,,1,,ANY
310112,BLOCK,1,,<empty>,,,,1,,ANY
310117,BLOCK,1,,<empty>,,,,1,,ANY
310122,BLOCK,1,,<empty>,,,,1,,ANY
310126,BLOCK,1,,<empty>,,,,1,,ANY
310130,BLOCK,1,,<empty>,,,,1,,ANY
310138,BLOCK,1,,<empty>,,,,1,,ANY
310142,BLOCK,1,,<empty>,,,,1,,ANY
310146,BLOCK,1,,<empty>,,,,1,,ANY
310151,BLOCK,1,,<empty>,,,,1,,ANY
310155,BLOCK,1,,<empty>,,,,1,,ANY
310160,BLOCK,1,,<empty>,,,,1,,ANY
310165,BLOCK,1,,<empty>,,,,1,,ANY
310169,BLOCK,1,,<empty>,,,,1,,ANY
310173,BLOCK,1,,<empty>,,,,1,,ANY
310178,BLOCK,1,,<empty>,,,,1,,ANY
310182,BLOCK,1,,<empty>,,,,1,,ANY
310188,BLOCK,1,,<empty>,,,,1,,ANY
310192,BLOCK,1,,<empty>,,,,1,,ANY
310196,BLOCK,1,,<empty>,,,,1,,ANY
310203,BLOCK,1,,<empty>,,,,1,,ANY
310208,BLOCK,1,,<empty>,,,,1,,ANY
310213,BLOCK,1,,<empty>,,,,1,,ANY
310218,BLOCK,1,,<empty>,,,,1,,ANY
310225,BLOCK,1,,<empty>,,,,1,,ANY
310231,BLOCK,1,,<empty>,,,,1,,ANY
310236,BLOCK,1,,<empty>,,,,1,,ANY
310240,BLOCK,1,,<empty>,,,,1,,ANY
310244,BLOCK,1,,<empty>,,,,1,,ANY
310250,BLOCK,1,,<empty>,,,,1,,ANY
310256,BLOCK,1,,<empty>,,,,1,,ANY
310264,BLOCK,1,,<empty>,,,,1,,ANY
310270,BLOCK,1,,<empty>,,,,1,,ANY
310277,BLOCK,1,,<empty>,,,,1,,ANY
310282,BLOCK,1,,<empty>,,,,1,,ANY
310288,BLOCK,1,,<empty>,,,,1,,ANY
310292,BLOCK,1,,<empty>,,,,1,,ANY
310296,BLOCK,1,,<empty>,,,,1,,ANY
310300,BLOCK,1,,<empty>,,,,1,,ANY
310304,BLOCK,1,,<empty>,,,,1,,ANY
310309,BLOCK,1,,<empty>,,,,1,,ANY
310314,BLOCK,1,,<empty>,,,,1,,ANY
310319,BLOCK,1,,<empty>,,,,1,,ANY
310323,BLOCK,1,,<empty>,,,,1,,ANY
310328,BLOCK,1,,<empty>,,,,1,,ANY
310334,BLOCK,1,,<empty>,,,,1,,ANY
310339,BLOCK,1,,<empty>,,,,1,,ANY
310345,BLOCK,1,,<empty>,,,,1,,ANY
310350,BLOCK,1,,<empty>,,,,1,,ANY
310355,BLOCK,1,,<empty>,,,,1,,ANY
310360,BLOCK,1,,<empty>,,,,1,,ANY
310365,BLOCK,1,,<empty>,,,,1,,ANY
310369,BLOCK,1,,<empty>,,,,1,,ANY
310373,BLOCK,1,,<empty>,,,,1,,ANY
310377,BLOCK,1,,<empty>,,,,1,,ANY
310381,BLOCK,1,,<empty>,,,,1,,ANY
310386,BLOCK,1,,<empty>,,,,1,,ANY
310390,BLOCK,1,,<empty>,,,,1,,ANY
310394,BLOCK,1,,<empty>,,,,1,,ANY
310398,BLOCK,1,,<empty>,,,,1,,ANY
310403,BLOCK,1,,<empty>,,,,1,,ANY
310409,BLOCK,1,,<empty>,,,,1,,ANY
310414,BLOCK,1,,<empty>,,,,1,,ANY
310419,BLOCK,1,,<empty>,,,,1,,ANY
310424,BLOCK,1,,<empty>,,,,1,,ANY
310428,BLOCK,1,,<empty>,,,,1,,ANY
310433,BLOCK,1,,<empty>,,,,1,,ANY
310437,BLOCK,1,,<empty>,,,,1,,ANY
310440,BLOCK,1,,<empty>,,,,1,,ANY
310447,BLOCK,1,,<empty>,,,,1,,ANY
310452,BLOCK,1,,<empty>,,,,1,,ANY
310457,BLOCK,1,,<empty>,,,,1,,ANY
310462,BLOCK,1,,<empty>,,,,1,,ANY
310466,BLOCK,1,,<empty>,,,,1,,ANY
310471,BLOCK,1,,<empty>,,,,1,,ANY
310476,BLOCK,1,,<empty>,,,,1,,ANY
310480,BLOCK,1,,<empty>,,,,1,,ANY
310484,BLOCK,1,,<empty>,,,,1,,ANY
310491,BLOCK,1,,<empty>,,,,1,,ANY
310495,BLOCK,1,,<empty>,,,,1,,ANY
310502,BLOCK,1,,<empty>,,,,1,,ANY
310506,BLOCK,1,,<empty>,,,,1,,ANY
310510,BLOCK,1,,<empty>,,,,1,,ANY
310514,BLOCK,1,,<empty>,,,,1,,ANY
310518,BLOCK,1,,<empty>,,,,1,,ANY
310522,BLOCK,1,,<empty>,,,,1,,ANY
310526,BLOCK,1,,<empty>,,,,1,,ANY
310535,BLOCK,1,,<empty>,,,,1,,ANY
310539,BLOCK,1,,<empty>,,,,1,,ANY
310543,BLOCK,1,,<empty>,,,,1,,ANY
310548,BLOCK,1,,<empty>,,,,1,,ANY
310552,BLOCK,1,,<empty>,,,,1,,ANY
310559,BLOCK,1,,<empty>,,,,1,,ANY
310566,BLOCK,1,,<empty>,,,,1,,ANY
310570,BLOCK,1,,<empty>,,,,1,,ANY
310574,BLOCK,1,,<empty>,,,,1,,ANY
310578,BLOCK,1,,<empty>,,,,1,,ANY
310583,BLOCK,1,,<empty>,,,,1,,ANY
310587,BLOCK,1,,<empty>,,,,1,,ANY
310592,BLOCK,1,,<empty>,,,,1,,ANY
310596,BLOCK,1,,<empty>,,,,1,,ANY
310602,BLOCK,1,,<empty>,,,,1,,ANY
310606,BLOCK,1,,<empty>,,,,1,,ANY
310612,BLOCK,1,,<empty>,,,,1,,ANY
310619,BLOCK,1,,<empty>,,,,1,,ANY
310623,BLOCK,1,,<empty>,,,,1,,ANY
310627,BLOCK,1,,<empty>,,,,1,,ANY
310631,BLOCK,1,,<empty>,,,,1,,ANY
310635,BLOCK,1,,<empty>,,,,1,,ANY
310642,BLOCK,1,,<empty>,,,,1,,ANY
310646,BLOCK,1,,<empty>,,,,1,,ANY
310652,BLOCK,1,,<empty>,,,,1,,ANY
310656,BLOCK,1,,<empty>,,,,1,,ANY
310661,BLOCK,1,,<empty>,,,,1,,ANY
310665,BLOCK,1,,<empty>,,,,1,,ANY
310671,BLOCK,1,,<empty>,,,,1,,ANY
310675,BLOCK,1,,<empty>,,,,1,,ANY
310680,BLOCK,1,,<empty>,,,,1,,ANY
310686,BLOCK,1,,<empty>,,,,1,,ANY
310692,BLOCK,1,,<empty>,,,,1,,ANY
310696,BLOCK,1,,<empty>,,,,1,,ANY
310701,BLOCK,1,,<empty>,,,,1,,ANY
310705,BLOCK,1,,<empty>,,,,1,,ANY
310710,BLOCK,1,,<empty>,,,,1,,ANY
310714,BLOCK,1,,<empty>,,,,1,,ANY
310720,BLOCK,1,,<empty>,,,,1,,ANY
310724,BLOCK,1,,<empty>,,,,1,,ANY
310730,BLOCK,1,,<empty>,,,,1,,ANY
310734,BLOCK,1,,<empty>,,,,1,,ANY
310740,BLOCK,1,,<empty>,,,,1,,ANY
310743,BLOCK,1,,<empty>,,,,1,,ANY
310747,BLOCK,1,,<empty>,,,,1,,ANY
310750,BLOCK,1,,<empty>,,,,1,,ANY
310754,BLOCK,1,,<empty>,,,,1,,ANY
310757,BLOCK,1,,<empty>,,,,1,,ANY
310761,BLOCK,1,,<empty>,,,,1,,ANY
310766,BLOCK,1,,<empty>,,,,1,,ANY
310770,BLOCK,1,,<empty>,,,,1,,ANY
310775,BLOCK,1,,<empty>,,,,1,,ANY
310779,BLOCK,1,,<empty>,,,,1,,ANY
310784,BLOCK,1,,<empty>,,,,1,,ANY
310787,BLOCK,1,,<empty>,,,,1,,ANY
310791,BLOCK,1,,<empty>,,,,1,,ANY
310797,BLOCK,1,,<empty>,,,,1,,ANY
310800,BLOCK,1,,<empty>,,,,1,,ANY
310804,BLOCK,1,,<empty>,,,,1,,ANY
310811,BLOCK,1,,<empty>,,,,1,,ANY
310815,BLOCK,1,,<empty>,,,,1,,ANY
310818,BLOCK,1,,<empty>,,,,1,,ANY
310823,BLOCK,1,,<empty>,,,,1,,ANY
310826,BLOCK,1,,<empty>,,,,1,,ANY
310830,BLOCK,1,,<empty>,,,,1,,ANY
310834,BLOCK,1,,<empty>,,,,1,,ANY
310842,BLOCK,1,,<empty>,,,,1,,ANY
310849,BLOCK,1,,<empty>,,,,1,,ANY
310855,BLOCK,1,,<empty>,,,,1,,ANY
310858,BLOCK,1,,<empty>,,,,1,,ANY
310861,BLOCK,1,,<empty>,,,,1,,ANY
310867,BLOCK,1,,<empty>,,,,1,,ANY
310870,BLOCK,1,,<empty>,,,,1,,ANY
310874,BLOCK,1,,<empty>,,,,1,,ANY
310878,BLOCK,1,,<empty>,,,,1,,ANY
310882,BLOCK,1,,<empty>,,,,1,,ANY
310887,BLOCK,1,,<empty>,,,,1,,ANY
310895,BLOCK,1,,<empty>,,,,1,,ANY
310900,BLOCK,1,,<empty>,,,,1,,ANY
310904,BLOCK,1,,<empty>,,,,1,,ANY
310908,BLOCK,1,,<empty>,,,,1,,ANY
310913,BLOCK,1,,<empty>,,,,1,,ANY
310919,BLOCK,1,,<empty>,,,,1,,ANY
310925,BLOCK,1,,<empty>,,,,1,,ANY
310931,BLOCK,1,,<empty>,,,,1,,ANY
310937,BLOCK,1,,<empty>,,,,1,,ANY
310943,BLOCK,1,,<empty>,,,,1,,ANY
310951,BLOCK,1,,<empty>,,,,1,,ANY
310957,BLOCK,1,,<empty>,,,,1,,ANY
310965,BLOCK,1,,<empty>,,,,1,,ANY
310969,BLOCK,1,,<empty>,,,,1,,ANY
310972,BLOCK,1,,<empty>,,,,1,,ANY
310977,BLOCK,1,,<empty>,,,,1,,ANY
310982,BLOCK,1,,<empty>,,,,1,,ANY
310987,BLOCK,1,,<empty>,,,,1,,ANY
310990,BLOCK,1,,<empty>,,,,1,,ANY
310995,BLOCK,1,,<empty>,,,,1,,ANY
311001,BLOCK,1,,<empty>,,,,1,,ANY
311004,BLOCK,1,,<empty>,,,,1,,ANY
311007,BLOCK,1,,<empty>,,,,1,,ANY
311011,BLOCK,1,,<empty>,,,,1,,ANY
311016,BLOCK,1,,<empty>,,,,1,,ANY
311021,BLOCK,1,,<empty>,,,,1,,ANY
311026,BLOCK,1,,<empty>,,,,1,,ANY
311031,BLOCK,1,,<empty>,,,,1,,ANY
311036,BLOCK,1,,<empty>,,,,1,,ANY
311041,BLOCK,1,,<empty>,,,,1,,ANY
311045,BLOCK,1,,<empty>,,,,1,,ANY
311050,BLOCK,1,,<empty>,,,,1,,ANY
311054,BLOCK,1,,<empty>,,,,1,,ANY
311059,BLOCK,1,,<empty>,,,,1,,ANY
311063,BLOCK,1,,<empty>,,,,1,,ANY
311068,BLOCK,1,,<empty>,,,,1,,ANY
311073,BLOCK,1,,<empty>,,,,1,,ANY
311078,BLOCK,1,,<empty>,,,,1,,ANY
311083,BLOCK,1,,<empty>,,,,1,,ANY
311087,BLOCK,1,,<empty>,,,,1,,ANY
311092,BLOCK,1,,<empty>,,,,1,,ANY
311096,BLOCK,1,,<empty>,,,,1,,ANY
311100,BLOCK,1,,<empty>,,,,1,,ANY
311105,BLOCK,1,,<empty>,,,,1,,ANY
311111,BLOCK,1,,<empty>,,,,1,,ANY
311118,BLOCK,1,,<empty>,,,,1,,ANY
311123,BLOCK,1,,<empty>,,,,1,,ANY
311128,BLOCK,1,,<empty>,,,,1,,ANY
311133,BLOCK,1,,<empty>,,,,1,,ANY
311137,BLOCK,1,,<empty>,,,,1,,ANY
311142,BLOCK,1,,<empty>,,,,1,,ANY
311147,BLOCK,1,,<empty>,,,,1,,ANY
311152,BLOCK,1,,<empty>,,,,1,,ANY
311158,BLOCK,1,,<empty>,,,,1,,ANY
311163,BLOCK,1,,<empty>,,,,1,,ANY
311167,BLOCK,1,,<empty>,,,,1,,ANY
311172,BLOCK,1,,<empty>,,,,1,,ANY
311179,BLOCK,1,,<empty>,,,,1,,ANY
311185,BLOCK,1,,<empty>,,,,1,,ANY
311188,BLOCK,1,,<empty>,,,,1,,ANY
311193,BLOCK,1,,<empty>,,,,1,,ANY
311198,BLOCK,1,,<empty>,,,,1,,ANY
311203,BLOCK,1,,<empty>,,,,1,,ANY
311207,BLOCK,1,,<empty>,,,,1,,ANY
311214,BLOCK,1,,<empty>,,,,1,,ANY
311219,BLOCK,1,,<empty>,,,,1,,ANY
311224,BLOCK,1,,<empty>,,,,1,,ANY
311230,BLOCK,1,,<empty>,,,,1,,ANY
311234,BLOCK,1,,<empty>,,,,1,,ANY
311238,BLOCK,1,,<empty>,,,,1,,ANY
311243,BLOCK,1,,<empty>,,,,1,,ANY
311248,BLOCK,1,,<empty>,,,,1,,ANY
311253,BLOCK,1,,<empty>,,,,1,,ANY
311258,BLOCK,1,,<empty>,,,,1,,ANY
311263,BLOCK,1,,<empty>,,,,1,,ANY
311270,BLOCK,1,,<empty>,,,,1,,ANY
311277,BLOCK,1,,<empty>,,,,1,,ANY
311282,BLOCK,1,,<empty>,,,,1,,ANY
311286,BLOCK,1,,<empty>,,,,1,,ANY
311290,BLOCK,1,,<empty>,,,,1,,ANY
311295,BLOCK,1,,<empty>,,,,1,,ANY
311300,BLOCK,1,,<empty>,,,,1,,ANY
311306,BLOCK,1,,<empty>,,,,1,,ANY
311310,BLOCK,1,,<empty>,,,,1,,ANY
311315,BLOCK,1,,<empty>,,,,1,,ANY
311320,BLOCK,1,,<empty>,,,,1,,ANY
311324,BLOCK,1,,<empty>,,,,1,,ANY
311330,BLOCK,1,,<empty>,,,,1,,ANY
311334,BLOCK,1,,<empty>,,,,1,,ANY
311339,BLOCK,1,,<empty>,,,,1,,ANY
311345,BLOCK,1,,<empty>,,,,1,,ANY
311350,BLOCK,1,,<empty>,,,,1,,ANY
311358,BLOCK,1,,<empty>,,,,1,,ANY
311362,BLOCK,1,,<empty>,,,,1,,ANY
311367,BLOCK,1,,<empty>,,,,1,,ANY
311372,BLOCK,1,,<empty>,,,,1,,ANY
311376,BLOCK,1,,<empty>,,,,1,,ANY
311380,BLOCK,1,,<empty>,,,,1,,ANY
311385,BLOCK,1,,<empty>,,,,1,,ANY
311389,BLOCK,1,,<empty>,,,,1,,ANY
311397,BLOCK,1,,<empty>,,,,1,,ANY
311401,BLOCK,1,,<empty>,,,,1,,ANY
311409,BLOCK,1,,<empty>,,,,1,,ANY
311412,BLOCK,1,,<empty>,,,,1,,ANY
311420,BLOCK,1,,<empty>,,,,1,,ANY
311426,BLOCK,1,,<empty>,,,,1,,ANY
311432,BLOCK,1,,<empty>,,,,1,,ANY
311436,BLOCK,1,,<empty>,,,,1,,ANY
311441,BLOCK,1,,<empty>,,,,1,,ANY
311444,BLOCK,1,,<empty>,,,,1,,ANY
311449,BLOCK,1,,<empty>,,,,1,,ANY
311455,BLOCK,1,,<empty>,,,,1,,ANY
311462,BLOCK,1,,<empty>,,,,1,,ANY
311466,BLOCK,1,,<empty>,,,,1,,ANY
311472,BLOCK,1,,<empty>,,,,1,,ANY
311478,BLOCK,1,,<empty>,,,,1,,ANY
311483,BLOCK,1,,<empty>,,,,1,,ANY
311489,BLOCK,1,,<empty>,,,,1,,ANY
311494,BLOCK,1,,<empty>,,,,1,,ANY
311500,BLOCK,1,,<empty>,,,,1,,ANY
311506,BLOCK,1,,<empty>,,,,1,,ANY
311512,BLOCK,1,,<empty>,,,,1,,ANY
311517,BLOCK,1,,<empty>,,,,1,,ANY
311522,BLOCK,1,,<empty>,,,,1,,ANY
311527,BLOCK,1,,<empty>,,,,1,,ANY
311530,BLOCK,1,,<empty>,,,,1,,ANY
311537,BLOCK,1,,<empty>,,,,1,,ANY
311540,BLOCK,1,,<empty>,,,,1,,ANY
311544,BLOCK,1,,<empty>,,,,1,,ANY
311551,BLOCK,1,,<empty>,,,,1,,ANY
311559,BLOCK,1,,<empty>,,,,1,,ANY
311562,BLOCK,1,,<empty>,,,,1,,ANY
311565,BLOCK,1,,<empty>,,,,1,,ANY
311569,BLOCK,1,,<empty>,,,,1,,ANY
311573,BLOCK,1,,<empty>,,,,1,,ANY
311577,BLOCK,1,,<empty>,,,,1,,ANY
311581,BLOCK,1,,<empty>,,,,1,,ANY
311587,BLOCK,1,,<empty>,,,,1,,ANY
311592,BLOCK,1,,<empty>,,,,1,,ANY
311596,BLOCK,1,,<empty>,,,,1,,ANY
311600,BLOCK,1,,<empty>,,,,1,,ANY
311604,BLOCK,1,,<empty>,,,,1,,ANY
311608,BLOCK,1,,<empty>,,,,1,,ANY
311612,BLOCK,1,,<empty>,,,,1,,ANY
311616,BLOCK,1,,<empty>,,,,1,,ANY
311620,BLOCK,1,,<empty>,,,,1,,ANY
311624,BLOCK,1,,<empty>,,,,1,,ANY
311630,BLOCK,1,,<empty>,,,,1,,ANY
311634,BLOCK,1,,<empty>,,,,1,,ANY
311640,BLOCK,1,,<empty>,,,,1,,ANY
311644,BLOCK,1,,<empty>,,,,1,,ANY
311650,BLOCK,1,,<empty>,,,,1,,ANY
311656,BLOCK,1,,<empty>,,,,1,,ANY
311662,BLOCK,1,,<empty>,,,,1,,ANY
311667,BLOCK,1,,<empty>,,,,1,,ANY
311673,BLOCK,1,,<empty>,,,,1,,ANY
311678,BLOCK,1,,<empty>,,,,1,,ANY
311683,BLOCK,1,,<empty>,,,,1,,ANY
311687,BLOCK,1,,<empty>,,,,1,,ANY
311690,BLOCK,1,,<empty>,,,,1,,ANY
311694,BLOCK,1,,<empty>,,,,1,,ANY
311697,BLOCK,1,,<empty>,,,,1,,ANY
311702,BLOCK,1,,<empty>,,,,1,,ANY
311707,BLOCK,1,,<empty>,,,,1,,ANY
311711,BLOCK,1,,<empty>,,,,1,,ANY
311716,BLOCK,1,,<empty>,,,,1,,ANY
311720,BLOCK,1,,<empty>,,,,1,,ANY
311725,BLOCK,1,,<empty>,,,,1,,ANY
311730,BLOCK,1,,<empty>,,,,1,,ANY
311735,BLOCK,1,,<empty>,,,,1,,ANY
311739,BLOCK,1,,<empty>,,,,1,,ANY
311744,BLOCK,1,,<empty>,,,,1,,ANY
311749,BLOCK,1,,<empty>,,,,1,,ANY
311753,BLOCK,1,,<empty>,,,,1,,ANY
311758,BLOCK,1,,<empty>,,,,1,,ANY
311764,BLOCK,1,,<empty>,,,,1,,ANY
311770,BLOCK,1,,<empty>,,,,1,,ANY
311775,BLOCK,1,,<empty>,,,,1,,ANY
311780,BLOCK,1,,<empty>,,,,1,,ANY
311784,BLOCK,1,,<empty>,,,,1,,ANY
311789,BLOCK,1,,<empty>,,,,1,,ANY
311794,BLOCK,1,,<empty>,,,,1,,ANY
311798,BLOCK,1,,<empty>,,,,1,,ANY
311807,BLOCK,1,,<empty>,,,,1,,ANY
311811,BLOCK,1,,<empty>,,,,1,,ANY
311815,BLOCK,1,,<empty>,,,,1,,ANY
311819,BLOCK,1,,<empty>,,,,1,,ANY
311823,BLOCK,1,,<empty>,,,,1,,ANY
311830,BLOCK,1,,<empty>,,,,1,,ANY
311834,BLOCK,1,,<empty>,,,,1,,ANY
311838,BLOCK,1,,<empty>,,,,1,,ANY
311844,BLOCK,1,,<empty>,,,,1,,ANY
311850,BLOCK,1,,<empty>,,,,1,,ANY
311855,BLOCK,1,,<empty>,,,,1,,ANY
311860,BLOCK,1,,<empty>,,,,1,,ANY
311864,BLOCK,1,,<empty>,,,,1,,ANY
311868,BLOCK,1,,<empty>,,,,1,,ANY
311873,BLOCK,1,,<empty>,,,,1,,ANY
311879,BLOCK,1,,<empty>,,,,1,,ANY
311885,BLOCK,1,,<empty>,,,,1,,ANY
311891,BLOCK,1,,<empty>,,,,1,,ANY
311899,BLOCK,1,,<empty>,,,,1,,ANY
311907,BLOCK,1,,<empty>,,,,1,,ANY
311912,BLOCK,1,,<empty>,,,,1,,ANY
311917,BLOCK,1,,<empty>,,,,1,,ANY
311922,BLOCK,1,,<empty>,,,,1,,ANY
311927,BLOCK,1,,<empty>,,,,1,,ANY
311931,BLOCK,1,,<empty>,,,,1,,ANY
311939,BLOCK,1,,<empty>,,,,1,,ANY
311943,BLOCK,1,,<empty>,,,,1,,ANY
311947,BLOCK,1,,<empty>,,,,1,,ANY
311951,BLOCK,1,,<empty>,,,,1,,ANY
311955,BLOCK,1,,<empty>,,,,1,,ANY
311959,BLOCK,1,,<empty>,,,,1,,ANY
311962,BLOCK,1,,<empty>,,,,1,,ANY
311970,BLOCK,1,,<empty>,,,,1,,ANY
311974,BLOCK,1,,<empty>,,,,1,,ANY
311978,BLOCK,1,,<empty>,,,,1,,ANY
311985,BLOCK,1,,<empty>,,,,1,,ANY
311989,BLOCK,1,,<empty>,,,,1,,ANY
311997,BLOCK,1,,<empty>,,,,1,,ANY
312001,BLOCK,1,,<empty>,,,,1,,ANY
312005,BLOCK,1,,<empty>,,,,1,,ANY
312009,BLOCK,1,,<empty>,,,,1,,ANY
312014,BLOCK,1,,<empty>,,,,1,,ANY
312018,BLOCK,1,,<empty>,,,,1,,ANY
312022,BLOCK,1,,<empty>,,,,1,,ANY
312027,BLOCK,1,,<empty>,,,,1,,ANY
312036,BLOCK,1,,<empty>,,,,1,,ANY
312041,BLOCK,1,,<empty>,,,,1,,ANY
312045,BLOCK,1,,<empty>,,,,1,,ANY
312051,BLOCK,1,,<empty>,,,,1,,ANY
312055,BLOCK,1,,<empty>,,,,1,,ANY
312059,BLOCK,1,,<empty>,,,,1,,ANY
312063,BLOCK,1,,<empty>,,,,1,,ANY
312067,BLOCK,1,,<empty>,,,,1,,ANY
312071,BLOCK,1,,<empty>,,,,1,,ANY
312075,BLOCK,1,,<empty>,,,,1,,ANY
312079,BLOCK,1,,<empty>,,,,1,,ANY
312083,BLOCK,1,,<empty>,,,,1,,ANY
312088,BLOCK,1,,<empty>,,,,1,,ANY
312093,BLOCK,1,,<empty>,,,,1,,ANY
312098,BLOCK,1,,<empty>,,,,1,,ANY
312102,BLOCK,1,,<empty>,,,,1,,ANY
312107,BLOCK,1,,<empty>,,,,1,,ANY
312113,BLOCK,1,,<empty>,,,,1,,ANY
312116,BLOCK,1,,<empty>,,,,1,,ANY
312121,BLOCK,1,,<empty>,,,,1,,ANY
312125,BLOCK,1,,<empty>,,,,1,,ANY
312130,BLOCK,1,,<empty>,,,,1,,ANY
312135,BLOCK,1,,<empty>,,,,1,,ANY
312140,BLOCK,1,,<empty>,,,,1,,ANY
312144,BLOCK,1,,<empty>,,,,1,,ANY
312152,BLOCK,1,,<empty>,,,,1,,ANY
312155,BLOCK,1,,<empty>,,,,1,,ANY
312159,BLOCK,1,,<empty>,,,,1,,ANY
312163,BLOCK,1,,<empty>,,,,1,,ANY
312170,BLOCK,1,,<empty>,,,,1,,ANY
312174,BLOCK,1,,<empty>,,,,1,,ANY
312178,BLOCK,1,,<empty>,,,,1,,ANY
312184,BLOCK,1,,<empty>,,,,1,,ANY
312188,BLOCK,1,,<empty>,,,,1,,ANY
312192,BLOCK,1,,<empty>,,,,1,,ANY
312196,BLOCK,1,,<empty>,,,,1,,ANY
312199,BLOCK,1,,<empty>,,,,1,,ANY
312205,BLOCK,1,,<empty>,,,,1,,ANY
312211,BLOCK,1,,<empty>,,,,1,,ANY
312215,BLOCK,1,,<empty>,,,,1,,ANY
312219,BLOCK,1,,<empty>,,,,1,,ANY
312223,BLOCK,1,,<empty>,,,,1,,ANY
312228,BLOCK,1,,<empty>,,,,1,,ANY
312234,BLOCK,1,,<empty>,,,,1,,ANY
312240,BLOCK,1,,<empty>,,,,1,,ANY
312244,BLOCK,1,,<empty>,,,,1,,ANY
312250,BLOCK,1,,<empty>,,,,1,,ANY
312254,BLOCK,1,,<empty>,,,,1,,ANY
312258,BLOCK,1,,<empty>,,,,1,,ANY
312264,BLOCK,1,,<empty>,,,,1,,ANY
312269,BLOCK,1,,<empty>,,,,1,,ANY
312275,BLOCK,1,,<empty>,,,,1,,ANY
312280,BLOCK,1,,<empty>,,,,1,,ANY
312284,BLOCK,1,,<empty>,,,,1,,ANY
312289,BLOCK,1,,<empty>,,,,1,,ANY
312292,BLOCK,1,,<empty>,,,,1,,ANY
312296,BLOCK,1,,<empty>,,,,1,,ANY
312302,BLOCK,1,,<empty>,,,,1,,ANY
312307,BLOCK,1,,<empty>,,,,1,,ANY
312310,BLOCK,1,,<empty>,,,,1,,ANY
312316,BLOCK,1,,<empty>,,,,1,,ANY
312320,BLOCK,1,,<empty>,,,,1,,ANY
312324,BLOCK,1,,<empty>,,,,1,,ANY
312329,BLOCK,1,,<empty>,,,,1,,ANY
312335,BLOCK,1,,<empty>,,,,1,,ANY
312340,BLOCK,1,,<empty>,,,,1,,ANY
312344,BLOCK,1,,<empty>,,,,1,,ANY
312350,BLOCK,1,,<empty>,,,,1,,ANY
312356,BLOCK,1,,<empty>,,,,1,,ANY
312360,BLOCK,1,,<empty>,,,,1,,ANY
312366,BLOCK,1,,<empty>,,,,1,,ANY
312370,BLOCK,1,,<empty>,,,,1,,ANY
312375,BLOCK,1,,<empty>,,,,1,,ANY
312379,BLOCK,1,,<empty>,,,,1,,ANY
312383,BLOCK,1,,<empty>,,,,1,,ANY
312388,BLOCK,1,,<empty>,,,,1,,ANY
312394,BLOCK,1,,<empty>,,,,1,,ANY
312404,BLOCK,1,,<empty>,,,,1,,ANY
312409,BLOCK,1,,<empty>,,,,1,,ANY
312415,BLOCK,1,,<empty>,,,,1,,ANY
312421,BLOCK,1,,<empty>,,,,1,,ANY
312427,BLOCK,1,,<empty>,,,,1,,ANY
312432,BLOCK,1,,<empty>,,,,1,,ANY
312435,BLOCK,1,,<empty>,,,,1,,ANY
312442,BLOCK,1,,<empty>,,,,1,,ANY
312448,BLOCK,1,,<empty>,,,,1,,ANY
312454,BLOCK,1,,<empty>,,,,1,,ANY
312458,BLOCK,1,,<empty>,,,,1,,ANY
312462,BLOCK,1,,<empty>,,,,1,,ANY
312466,BLOCK,1,,<empty>,,,,1,,ANY
312471,BLOCK,1,,<empty>,,,,1,,ANY
312477,BLOCK,1,,<empty>,,,,1,,ANY
312483,BLOCK,1,,<empty>,,,,1,,ANY
312489,BLOCK,1,,<empty>,,,,1,,ANY
312494,BLOCK,1,,<empty>,,,,1,,ANY
312499,BLOCK,1,,<empty>,,,,1,,ANY
312505,BLOCK,1,,<empty>,,,,1,,ANY
312512,BLOCK,1,,<empty>,,,,1,,ANY
312516,BLOCK,1,,<empty>,,,,1,,ANY
312522,BLOCK,1,,<empty>,,,,1,,ANY
312526,BLOCK,1,,<empty>,,,,1,,ANY
312529,BLOCK,1,,<empty>,,,,1,,ANY
312539,BLOCK,1,,<empty>,,,,1,,ANY
312544,BLOCK,1,,<empty>,,,,1,,ANY
312549,BLOCK,1,,<empty>,,,,1,,ANY
312553,BLOCK,1,,<empty>,,,,1,,ANY
312558,BLOCK,1,,<empty>,,,,1,,ANY
312565,BLOCK,1,,<empty>,,,,1,,ANY
312571,BLOCK,1,,<empty>,,,,1,,ANY
312575,BLOCK,1,,<empty>,,,,1,,ANY
312582,BLOCK,1,,<empty>,,,,1,,ANY
312589,BLOCK,1,,<empty>,,,,1,,ANY
312594,BLOCK,1,,<empty>,,,,1,,ANY
312601,BLOCK,1,,<empty>,,,,1,,ANY
312605,BLOCK,1,,<empty>,,,,1,,ANY
312610,BLOCK,1,,<empty>,,,,1,,ANY
312614,BLOCK,1,,<empty>,,,,1,,ANY
312618,BLOCK,1,,<empty>,,,,1,,ANY
312628,BLOCK,1,,<empty>,,,,1,,ANY
312632,BLOCK,1,,<empty>,,,,1,,ANY
312637,BLOCK,1,,<empty>,,,,1,,ANY
312647,BLOCK,1,,<empty>,,,,1,,ANY
312657,BLOCK,1,,<empty>,,,,1,,ANY
312661,BLOCK,1,,<empty>,,,,1,,ANY
312671,BLOCK,1,,<empty>,,,,1,,ANY
312676,BLOCK,1,,<empty>,,,,1,,ANY
312682,BLOCK,1,,<empty>,,,,1,,ANY
312687,BLOCK,1,,<empty>,,,,1,,ANY
312692,BLOCK,1,,<empty>,,,,1,,ANY
312697,BLOCK,1,,<empty>,,,,1,,ANY
312703,BLOCK,1,,<empty>,,,,1,,ANY
312707,BLOCK,1,,<empty>,,,,1,,ANY
312711,BLOCK,1,,<empty>,,,,1,,ANY
312716,BLOCK,1,,<empty>,,,,1,,ANY
312722,BLOCK,1,,<empty>,,,,1,,ANY
312728,BLOCK,1,,<empty>,,,,1,,ANY
312734,BLOCK,1,,<empty>,,,,1,,ANY
312738,BLOCK,1,,<empty>,,,,1,,ANY
312745,BLOCK,1,,<empty>,,,,1,,ANY
312752,BLOCK,1,,<empty>,,,,1,,ANY
312756,BLOCK,1,,<empty>,,,,1,,ANY
312762,BLOCK,1,,<empty>,,,,1,,ANY
312768,BLOCK,1,,<empty>,,,,1,,ANY
312774,BLOCK,1,,<empty>,,,,1,,ANY
312780,BLOCK,1,,<empty>,,,,1,,ANY
312784,BLOCK,1,,<empty>,,,,1,,ANY
312787,BLOCK,1,,<empty>,,,,1,,ANY
312790,BLOCK,1,,<empty>,,,,1,,ANY
312796,BLOCK,1,,<empty>,,,,1,,ANY
312803,BLOCK,1,,<empty>,,,,1,,ANY
312807,BLOCK,1,,<empty>,,,,1,,ANY
312814,BLOCK,1,,<empty>,,,,1,,ANY
312820,BLOCK,1,,<empty>,,,,1,,ANY
312826,BLOCK,1,,<empty>,,,,1,,ANY
312833,BLOCK,1,,<empty>,,,,1,,ANY
312838,BLOCK,1,,<empty>,,,,1,,ANY
312841,BLOCK,1,,<empty>,,,,1,,ANY
312845,BLOCK,1,,<empty>,,,,1,,ANY
312849,BLOCK,1,,<empty>,,,,1,,ANY
312855,BLOCK,1,,<empty>,,,,1,,ANY
312862,BLOCK,1,,<empty>,,,,1,,ANY
312866,BLOCK,1,,<empty>,,,,1,,ANY
312873,BLOCK,1,,<empty>,,,,1,,ANY
312878,BLOCK,1,,<empty>,,,,1,,ANY
312885,BLOCK,1,,<empty>,,,,1,,ANY
312893,BLOCK,1,,<empty>,,,,1,,ANY
312898,BLOCK,1,,<empty>,,,,1,,ANY
312902,BLOCK,1,,<empty>,,,,1,,ANY
312907,BLOCK,1,,<empty>,,,,1,,ANY
312912,BLOCK,1,,<empty>,,,,1,,ANY
312917,BLOCK,1,,<empty>,,,,1,,ANY
312924,BLOCK,1,,<empty>,,,,1,,ANY
312929,BLOCK,1,,<empty>,,,,1,,ANY
312934,BLOCK,1,,<empty>,,,,1,,ANY
312942,BLOCK,1,,<empty>,,,,1,,ANY
312946,BLOCK,1,,<empty>,,,,1,,ANY
312950,BLOCK,1,,<empty>,,,,1,,ANY
312955,BLOCK,1,,<empty>,,,,1,,ANY
312959,BLOCK,1,,<empty>,,,,1,,ANY
312965,BLOCK,1,,<empty>,,,,1,,ANY
312970,BLOCK,1,,<empty>,,,,1,,ANY
312976,BLOCK,1,,<empty>,,,,1,,ANY
312982,BLOCK,1,,<empty>,,,,1,,ANY
312986,BLOCK,1,,<empty>,,,,1,,ANY
312990,BLOCK,1,,<empty>,,,,1,,ANY
312994,BLOCK,1,,<empty>,,,,1,,ANY
312998,BLOCK,1,,<empty>,,,,1,,ANY
313002,BLOCK,1,,<empty>,,,,1,,ANY
313006,BLOCK,1,,<empty>,,,,1,,ANY
313010,BLOCK,1,,<empty>,,,,1,,ANY
313014,BLOCK,1,,<empty>,,,,1,,ANY
313018,BLOCK,1,,<empty>,,,,1,,ANY
313022,BLOCK,1,,<empty>,,,,1,,ANY
313026,BLOCK,1,,<empty>,,,,1,,ANY
313033,BLOCK,1,,<empty>,,,,1,,ANY
313038,BLOCK,1,,<empty>,,,,1,,ANY
313045,BLOCK,1,,<empty>,,,,1,,ANY
313050,BLOCK,1,,<empty>,,,,1,,ANY
313055,BLOCK,1,,<empty>,,,,1,,ANY
313060,BLOCK,1,,<empty>,,,,1,,ANY
313065,BLOCK,1,,<empty>,,,,1,,ANY
313069,BLOCK,1,,<empty>,,,,1,,ANY
313073,BLOCK,1,,<empty>,,,,1,,ANY
313077,BLOCK,1,,<empty>,,,,1,,ANY
313081,BLOCK,1,,<empty>,,,,1,,ANY
313085,BLOCK,1,,<empty>,,,,1,,ANY
313089,BLOCK,1,,<empty>,,,,1,,ANY
313094,BLOCK,1,,<empty>,,,,1,,ANY
313102,BLOCK,1,,<empty>,,,,1,,ANY
313110,BLOCK,1,,<empty>,,,,1,,ANY
313118,BLOCK,1,,<empty>,,,,1,,ANY
313126,BLOCK,1,,<empty>,,,,1,,ANY
313134,BLOCK,1,,<empty>,,,,1,,ANY
313142,BLOCK,1,,<empty>,,,,1,,ANY
313150,BLOCK,1,,<empty>,,,,1,,ANY
313158,BLOCK,1,,<empty>,,,,1,,ANY
313166,BLOCK,1,,<empty>,,,,1,,ANY
313174,BLOCK,1,,<empty>,,,,1,,ANY
313182,BLOCK,1,,<empty>,,,,1,,ANY
313190,BLOCK,1,,<empty>,,,,1,,ANY
313198,BLOCK,1,,<empty>,,,,1,,ANY
313206,BLOCK,1,,<empty>,,,,1,,ANY
313214,BLOCK,1,,<empty>,,,,1,,ANY
313222,BLOCK,1,,<empty>,,,,1,,ANY
313230,BLOCK,1,,<empty>,,,,1,,ANY
313238,BLOCK,1,,<empty>,,,,1,,ANY
313246,BLOCK,1,,<empty>,,,,1,,ANY
313254,BLOCK,1,,<empty>,,,,1,,ANY
313259,BLOCK,1,,<empty>,,,,1,,ANY
313263,BLOCK,1,,<empty>,,,,1,,ANY
313267,BLOCK,1,,<empty>,,,,1,,ANY
313278,BLOCK,1,,<empty>,,,,1,,ANY
313283,BLOCK,1,,<empty>,,,,1,,ANY
313287,BLOCK,1,,<empty>,,,,1,,ANY
313291,BLOCK,1,,<empty>,,,,1,,ANY
313294,BLOCK,1,,<empty>,,,,1,,ANY
313303,BLOCK,1,,<empty>,,,,1,,ANY
313307,BLOCK,1,,<empty>,,,,1,,ANY
313310,BLOCK,1,,<empty>,,,,1,,ANY
313317,BLOCK,1,,<empty>,,,,1,,ANY
313323,BLOCK,1,,<empty>,,,,1,,ANY
313329,BLOCK,1,,<empty>,,,,1,,ANY
313335,BLOCK,1,,<empty>,,,,1,,ANY
313340,BLOCK,1,,<empty>,,,,1,,ANY
313345,BLOCK,1,,<empty>,,,,1,,ANY
313350,BLOCK,1,,<empty>,,,,1,,ANY
313355,BLOCK,1,,<empty>,,,,1,,ANY
313360,BLOCK,1,,<empty>,,,,1,,ANY
313365,BLOCK,1,,<empty>,,,,1,,ANY
313370,BLOCK,1,,<empty>,,,,1,,ANY
313375,BLOCK,1,,<empty>,,,,1,,ANY
313380,BLOCK,1,,<empty>,,,,1,,ANY
313385,BLOCK,1,,<empty>,,,,1,,ANY
313393,BLOCK,1,,<empty>,,,,1,,ANY
313399,BLOCK,1,,<empty>,,,,1,,ANY
313404,BLOCK,1,,<empty>,,,,1,,ANY
313412,BLOCK,1,,<empty>,,,,1,,ANY
313420,BLOCK,1,,<empty>,,,,1,,ANY
313423,BLOCK,1,,<empty>,,,,1,,ANY
313427,BLOCK,1,,<empty>,,,,1,,ANY
313431,BLOCK,1,,<empty>,,,,1,,ANY
313435,BLOCK,1,,<empty>,,,,1,,ANY
313439,BLOCK,1,,<empty>,,,,1,,ANY
313443,BLOCK,1,,<empty>,,,,1,,ANY
313449,BLOCK,1,,<empty>,,,,1,,ANY
313456,BLOCK,1,,<empty>,,,,1,,ANY
313460,BLOCK,1,,<empty>,,,,1,,ANY
313464,BLOCK,1,,<empty>,,,,1,,ANY
313468,BLOCK,1,,<empty>,,,,1,,ANY
313472,BLOCK,1,,<empty>,,,,1,,ANY
313476,BLOCK,1,,<empty>,,,,1,,ANY
313479,BLOCK,1,,<empty>,,,,1,,ANY
313486,BLOCK,1,,<empty>,,,,1,,ANY
313492,BLOCK,1,,<empty>,,,,1,,ANY
313499,BLOCK,1,,<empty>,,,,1,,ANY
313504,BLOCK,1,,<empty>,,,,1,,ANY
313508,BLOCK,1,,<empty>,,,,1,,ANY
313512,BLOCK,1,,<empty>,,,,1,,ANY
313516,BLOCK,1,,<empty>,,,,1,,ANY
313520,BLOCK,1,,<empty>,,,,1,,ANY
313524,BLOCK,1,,<empty>,,,,1,,ANY
313529,BLOCK,1,,<empty>,,,,1,,ANY
313533,BLOCK,1,,<empty>,,,,1,,ANY
313537,BLOCK,1,,<empty>,,,,1,,ANY
313543,BLOCK,1,,<empty>,,,,1,,ANY
313549,BLOCK,1,,<empty>,,,,1,,ANY
313555,BLOCK,1,,<empty>,,,,1,,ANY
313560,BLOCK,1,,<empty>,,,,1,,ANY
313565,BLOCK,1,,<empty>,,,,1,,ANY
313570,BLOCK,1,,<empty>,,,,1,,ANY
313575,BLOCK,1,,<empty>,,,,1,,ANY
313579,BLOCK,1,,<empty>,,,,1,,ANY
313592,BLOCK,1,,<empty>,,,,1,,ANY
313596,BLOCK,1,,<empty>,,,,1,,ANY
313602,BLOCK,1,,<empty>,,,,1,,ANY
313606,BLOCK,1,,<empty>,,,,1,,ANY
313611,BLOCK,1,,<empty>,,,,1,,ANY
313615,BLOCK,1,,<empty>,,,,1,,ANY
313619,BLOCK,1,,<empty>,,,,1,,ANY
313623,BLOCK,1,,<empty>,,,,1,,ANY
313630,BLOCK,1,,<empty>,,,,1,,ANY
313635,BLOCK,1,,<empty>,,,,1,,ANY
313643,BLOCK,1,,<empty>,,,,1,,ANY
313647,BLOCK,1,,<empty>,,,,1,,ANY
313651,BLOCK,1,,<empty>,,,,1,,ANY
313657,BLOCK,1,,<empty>,,,,1,,ANY
313661,BLOCK,1,,<empty>,,,,1,,ANY
313665,BLOCK,1,,<empty>,,,,1,,ANY
313669,BLOCK,1,,<empty>,,,,1,,ANY
313676,BLOCK,1,,<empty>,,,,1,,ANY
313680,BLOCK,1,,<empty>,,,,1,,ANY
313683,BLOCK,1,,<empty>,,,,1,,ANY
313689,BLOCK,1,,<empty>,,,,1,,ANY
313694,BLOCK,1,,<empty>,,,,1,,ANY
313697,BLOCK,1,,<empty>,,,,1,,ANY
313703,BLOCK,1,,<empty>,,,,1,,ANY
313708,BLOCK,1,,<empty>,,,,1,,ANY
313713,BLOCK,1,,<empty>,,,,1,,ANY
313718,BLOCK,1,,<empty>,,,,1,,ANY
313722,BLOCK,1,,<empty>,,,,1,,ANY
313730,BLOCK,1,,<empty>,,,,1,,ANY
313736,BLOCK,1,,<empty>,,,,1,,ANY
313740,BLOCK,1,,<empty>,,,,1,,ANY
313744,BLOCK,1,,<empty>,,,,1,,ANY
313752,BLOCK,1,,<empty>,,,,1,,ANY
313757,BLOCK,1,,<empty>,,,,1,,ANY
313761,BLOCK,1,,<empty>,,,,1,,ANY
313769,BLOCK,1,,<empty>,,,,1,,ANY
313773,BLOCK,1,,<empty>,,,,1,,ANY
313778,BLOCK,1,,<empty>,,,,1,,ANY
313787,BLOCK,1,,<empty>,,,,1,,ANY
313791,BLOCK,1,,<empty>,,,,1,,ANY
313796,BLOCK,1,,<empty>,,,,1,,ANY
313801,BLOCK,1,,<empty>,,,,1,,ANY
313809,BLOCK,1,,<empty>,,,,1,,ANY
313817,BLOCK,1,,<empty>,,,,1,,ANY
313821,BLOCK,1,,<empty>,,,,1,,ANY
313829,BLOCK,1,,<empty>,,,,1,,ANY
313835,BLOCK,1,,<empty>,,,,1,,ANY
313841,BLOCK,1,,<empty>,,,,1,,ANY
313849,BLOCK,1,,<empty>,,,,1,,ANY
313853,BLOCK,1,,<empty>,,,,1,,ANY
313858,BLOCK,1,,<empty>,,,,1,,ANY
313862,BLOCK,1,,<empty>,,,,1,,ANY
313867,BLOCK,1,,<empty>,,,,1,,ANY
313871,BLOCK,1,,<empty>,,,,1,,ANY
313875,BLOCK,1,,<empty>,,,,1,,ANY
313879,BLOCK,1,,<empty>,,,,1,,ANY
313883,BLOCK,1,,<empty>,,,,1,,ANY
313891,BLOCK,1,,<empty>,,,,1,,ANY
313896,BLOCK,1,,<empty>,,,,1,,ANY
313900,BLOCK,1,,<empty>,,,,1,,ANY
313904,BLOCK,1,,<empty>,,,,1,,ANY
313908,BLOCK,1,,<empty>,,,,1,,ANY
313914,BLOCK,1,,<empty>,,,,1,,ANY
313919,BLOCK,1,,<empty>,,,,1,,ANY
313925,BLOCK,1,,<empty>,,,,1,,ANY
313929,BLOCK,1,,<empty>,,,,1,,ANY
313934,BLOCK,1,,<empty>,,,,1,,ANY
313944,BLOCK,1,,<empty>,,,,1,,ANY
313948,BLOCK,1,,<empty>,,,,1,,ANY
313952,BLOCK,1,,<empty>,,,,1,,ANY
313957,BLOCK,1,,<empty>,,,,1,,ANY
313962,BLOCK,1,,<empty>,,,,1,,ANY
313966,BLOCK,1,,<empty>,,,,1,,ANY
313970,BLOCK,1,,<empty>,,,,1,,ANY
313974,BLOCK,1,,<empty>,,,,1,,ANY
313978,BLOCK,1,,<empty>,,,,1,,ANY
313982,BLOCK,1,,<empty>,,,,1,,ANY
313986,BLOCK,1,,<empty>,,,,1,,ANY
313990,BLOCK,1,,<empty>,,,,1,,ANY
313994,BLOCK,1,,<empty>,,,,1,,ANY
313998,BLOCK,1,,<empty>,,,,1,,ANY
314002,BLOCK,1,,<empty>,,,,1,,ANY
314007,BLOCK,1,,<empty>,,,,1,,ANY
314012,BLOCK,1,,<empty>,,,,1,,ANY
314016,BLOCK,1,,<empty>,,,,1,,ANY
314021,BLOCK,1,,<empty>,,,,1,,ANY
314025,BLOCK,1,,<empty>,,,,1,,ANY
314029,BLOCK,1,,<empty>,,,,1,,ANY
314033,BLOCK,1,,<empty>,,,,1,,ANY
314037,BLOCK,1,,<empty>,,,,1,,ANY
314041,BLOCK,1,,<empty>,,,,1,,ANY
314045,BLOCK,1,,<empty>,,,,1,,ANY
314049,BLOCK,1,,<empty>,,,,1,,ANY
314053,BLOCK,1,,<empty>,,,,1,,ANY
314057,BLOCK,1,,<empty>,,,,1,,ANY
314061,BLOCK,1,,<empty>,,,,1,,ANY
314070,BLOCK,1,,<empty>,,,,1,,ANY
314074,BLOCK,1,,<empty>,,,,1,,ANY
314080,BLOCK,1,,<empty>,,,,1,,ANY
314084,BLOCK,1,,<empty>,,,,1,,ANY
314088,BLOCK,1,,<empty>,,,,1,,ANY
314091,BLOCK,1,,<empty>,,,,1,,ANY
314095,BLOCK,1,,<empty>,,,,1,,ANY
314101,BLOCK,1,,<empty>,,,,1,,ANY
314105,BLOCK,1,,<empty>,,,,1,,ANY
314110,BLOCK,1,,<empty>,,,,1,,ANY
314115,BLOCK,1,,<empty>,,,,1,,ANY
314120,BLOCK,1,,<empty>,,,,1,,ANY
314124,BLOCK,1,,<empty>,,,,1,,ANY
314129,BLOCK,1,,<empty>,,,,1,,ANY
314134,BLOCK,1,,<empty>,,,,1,,ANY
314139,BLOCK,1,,<empty>,,,,1,,ANY
314142,BLOCK,1,,<empty>,,,,1,,ANY
314148,BLOCK,1,,<empty>,,,,1,,ANY
314152,BLOCK,1,,<empty>,,,,1,,ANY
314155,BLOCK,1,,<empty>,,,,1,,ANY
314160,BLOCK,1,,<empty>,,,,1,,ANY
314164,BLOCK,1,,<empty>,,,,1,,ANY
314169,BLOCK,1,,<empty>,,,,1,,ANY
314175,BLOCK,1,,<empty>,,,,1,,ANY
314181,BLOCK,1,,<empty>,,,,1,,ANY
314186,BLOCK,1,,<empty>,,,,1,,ANY
314191,BLOCK,1,,<empty>,,,,1,,ANY
314196,BLOCK,1,,<empty>,,,,1,,ANY
314201,BLOCK,1,,<empty>,,,,1,,ANY
314205,BLOCK,1,,<empty>,,,,1,,ANY
314211,BLOCK,1,,<empty>,,,,1,,ANY
314215,BLOCK,1,,<empty>,,,,1,,ANY
314220,BLOCK,1,,<empty>,,,,1,,ANY
314224,BLOCK,1,,<empty>,,,,1,,ANY
314229,BLOCK,1,,<empty>,,,,1,,ANY
314233,BLOCK,1,,<empty>,,,,1,,ANY
314237,BLOCK,1,,<empty>,,,,1,,ANY
314241,BLOCK,1,,<empty>,,,,1,,ANY
314244,BLOCK,1,,<empty>,,,,1,,ANY
314249,BLOCK,1,,<empty>,,,,1,,ANY
314255,BLOCK,1,,<empty>,,,,1,,ANY
314258,BLOCK,1,,<empty>,,,,1,,ANY
314261,BLOCK,1,,<empty>,,,,1,,ANY
314265,BLOCK,1,,<empty>,,,,1,,ANY
314269,BLOCK,1,,<empty>,,,,1,,ANY
314273,BLOCK,1,,<empty>,,,,1,,ANY
314277,BLOCK,1,,<empty>,,,,1,,ANY
314281,BLOCK,1,,<empty>,,,,1,,ANY
314284,BLOCK,1,,<empty>,,,,1,,ANY
314288,BLOCK,1,,<empty>,,,,1,,ANY
314292,BLOCK,1,,<empty>,,,,1,,ANY
314299,BLOCK,1,,<empty>,,,,1,,ANY
314304,BLOCK,1,,<empty>,,,,1,,ANY
314307,BLOCK,1,,<empty>,,,,1,,ANY
314310,BLOCK,1,,<empty>,,,,1,,ANY
314316,BLOCK,1,,<empty>,,,,1,,ANY
314320,BLOCK,1,,<empty>,,,,1,,ANY
314325,BLOCK,1,,<empty>,,,,1,,ANY
314330,BLOCK,1,,<empty>,,,,1,,ANY
314333,BLOCK,1,,<empty>,,,,1,,ANY
314337,BLOCK,1,,<empty>,,,,1,,ANY
314341,BLOCK,1,,<empty>,,,,1,,ANY
314345,BLOCK,1,,<empty>,,,,1,,ANY
314349,BLOCK,1,,<empty>,,,,1,,ANY
314353,BLOCK,1,,<empty>,,,,1,,ANY
314357,BLOCK,1,,<empty>,,,,1,,ANY
314361,BLOCK,1,,<empty>,,,,1,,ANY
314366,BLOCK,1,,<empty>,,,,1,,ANY
314372,BLOCK,1,,<empty>,,,,1,,ANY
314377,BLOCK,1,,<empty>,,,,1,,ANY
314380,BLOCK,1,,<empty>,,,,1,,ANY
314384,BLOCK,1,,<empty>,,,,1,,ANY
314388,BLOCK,1,,<empty>,,,,1,,ANY
314392,BLOCK,1,,<empty>,,,,1,,ANY
314396,BLOCK,1,,<empty>,,,,1,,ANY
314400,BLOCK,1,,<empty>,,,,1,,ANY
314403,BLOCK,1,,<empty>,,,,1,,ANY
314408,BLOCK,1,,<empty>,,,,1,,ANY
314413,BLOCK,1,,<empty>,,,,1,,ANY
314418,BLOCK,1,,<empty>,,,,1,,ANY
314423,BLOCK,1,,<empty>,,,,1,,ANY
314427,BLOCK,1,,<empty>,,,,1,,ANY
314431,BLOCK,1,,<empty>,,,,1,,ANY
314435,BLOCK,1,,<empty>,,,,1,,ANY
314439,BLOCK,1,,<empty>,,,,1,,ANY
314443,BLOCK,1,,<empty>,,,,1,,ANY
314448,BLOCK,1,,<empty>,,,,1,,ANY
314453,BLOCK,1,,<empty>,,,,1,,ANY
314458,BLOCK,1,,<empty>,,,,1,,ANY
314463,BLOCK,1,,<empty>,,,,1,,ANY
314468,BLOCK,1,,<empty>,,,,1,,ANY
314474,BLOCK,1,,<empty>,,,,1,,ANY
314480,BLOCK,1,,<empty>,,,,1,,ANY
314485,BLOCK,1,,<empty>,,,,1,,ANY
314489,BLOCK,1,,<empty>,,,,1,,ANY
314493,BLOCK,1,,<empty>,,,,1,,ANY
314498,BLOCK,1,,<empty>,,,,1,,ANY
314503,BLOCK,1,,<empty>,,,,1,,ANY
314508,BLOCK,1,,<empty>,,,,1,,ANY
314512,BLOCK,1,,<empty>,,,,1,,ANY
314516,BLOCK,1,,<empty>,,,,1,,ANY
314521,BLOCK,1,,<empty>,,,,1,,ANY
314526,BLOCK,1,,<empty>,,,,1,,ANY
314531,BLOCK,1,,<empty>,,,,1,,ANY
314536,BLOCK,1,,<empty>,,,,1,,ANY
314541,BLOCK,1,,<empty>,,,,1,,ANY
314546,BLOCK,1,,<empty>,,,,1,,ANY
314549,BLOCK,1,,<empty>,,,,1,,ANY
314554,BLOCK,1,,<empty>,,,,1,,ANY
314558,BLOCK,1,,<empty>,,,,1,,ANY
314562,BLOCK,1,,<empty>,,,,1,,ANY
314566,BLOCK,1,,<empty>,,,,1,,ANY
314570,BLOCK,1,,<empty>,,,,1,,ANY
314575,BLOCK,1,,<empty>,,,,1,,ANY
314580,BLOCK,1,,<empty>,,,,1,,ANY
314584,BLOCK,1,,<empty>,,,,1,,ANY
314589,BLOCK,1,,<empty>,,,,1,,ANY
314594,BLOCK,1,,<empty>,,,,1,,ANY
314598,BLOCK,1,,<empty>,,,,1,,ANY
314604,BLOCK,1,,<empty>,,,,1,,ANY
314610,BLOCK,1,,<empty>,,,,1,,ANY
314617,BLOCK,1,,<empty>,,,,1,,ANY
314624,BLOCK,1,,<empty>,,,,1,,ANY
314629,BLOCK,1,,<empty>,,,,1,,ANY
314635,BLOCK,1,,<empty>,,,,1,,ANY
314641,BLOCK,1,,<empty>,,,,1,,ANY
314647,BLOCK,1,,<empty>,,,,1,,ANY
314651,BLOCK,1,,<empty>,,,,1,,ANY
314656,BLOCK,1,,<empty>,,,,1,,ANY
314661,BLOCK,1,,<empty>,,,,1,,ANY
314666,BLOCK,1,,<empty>,,,,1,,ANY
314671,BLOCK,1,,<empty>,,,,1,,ANY
314681,BLOCK,1,,<empty>,,,,1,,ANY
314685,BLOCK,1,,<empty>,,,,1,,ANY
314690,BLOCK,1,,<empty>,,,,1,,ANY
314695,BLOCK,1,,<empty>,,,,1,,ANY
314706,BLOCK,1,,<empty>,,,,1,,ANY
314710,BLOCK,1,,<empty>,,,,1,,ANY
314716,BLOCK,1,,<empty>,,,,1,,ANY
314720,BLOCK,1,,<empty>,,,,1,,ANY
314725,BLOCK,1,,<empty>,,,,1,,ANY
314730,BLOCK,1,,<empty>,,,,1,,ANY
314734,BLOCK,1,,<empty>,,,,1,,ANY
314740,BLOCK,1,,<empty>,,,,1,,ANY
314744,BLOCK,1,,<empty>,,,,1,,ANY
314748,BLOCK,1,,<empty>,,,,1,,ANY
314752,BLOCK,1,,<empty>,,,,1,,ANY
314760,BLOCK,1,,<empty>,,,,1,,ANY
314764,BLOCK,1,,<empty>,,,,1,,ANY
314770,BLOCK,1,,<empty>,,,,1,,ANY
314775,BLOCK,1,,<empty>,,,,1,,ANY
314780,BLOCK,1,,<empty>,,,,1,,ANY
314783,BLOCK,1,,<empty>,,,,1,,ANY
314788,BLOCK,1,,<empty>,,,,1,,ANY
314791,BLOCK,1,,<empty>,,,,1,,ANY
314795,BLOCK,1,,<empty>,,,,1,,ANY
314800,BLOCK,1,,<empty>,,,,1,,ANY
314804,BLOCK,1,,<empty>,,,,1,,ANY
314807,BLOCK,1,,<empty>,,,,1,,ANY
314812,BLOCK,1,,<empty>,,,,1,,ANY
314817,BLOCK,1,,<empty>,,,,1,,ANY
314821,BLOCK,1,,<empty>,,,,1,,ANY
314826,BLOCK,1,,<empty>,,,,1,,ANY
314829,BLOCK,1,,<empty>,,,,1,,ANY
314832,BLOCK,1,,<empty>,,,,1,,ANY
314836,BLOCK,1,,<empty>,,,,1,,ANY
314841,BLOCK,1,,<empty>,,,,1,,ANY
314847,BLOCK,1,,<empty>,,,,1,,ANY
314852,BLOCK,1,,<empty>,,,,1,,ANY
314857,BLOCK,1,,<empty>,,,,1,,ANY
314861,BLOCK,1,,<empty>,,,,1,,ANY
314865,BLOCK,1,,<empty>,,,,1,,ANY
314870,BLOCK,1,,<empty>,,,,1,,ANY
314874,BLOCK,1,,<empty>,,,,1,,ANY
314878,BLOCK,1,,<empty>,,,,1,,ANY
314881,BLOCK,1,,<empty>,,,,1,,ANY
314886,BLOCK,1,,<empty>,,,,1,,ANY
314892,BLOCK,1,,<empty>,,,,1,,ANY
314897,BLOCK,1,,<empty>,,,,1,,ANY
314906,BLOCK,1,,<empty>,,,,1,,ANY
314911,BLOCK,1,,<empty>,,,,1,,ANY
314916,BLOCK,1,,<empty>,,,,1,,ANY
314921,BLOCK,1,,<empty>,,,,1,,ANY
314924,BLOCK,1,,<empty>,,,,1,,ANY
314931,BLOCK,1,,<empty>,,,,1,,ANY
314935,BLOCK,1,,<empty>,,,,1,,ANY
314942,BLOCK,1,,<empty>,,,,1,,ANY
314946,BLOCK,1,,<empty>,,,,1,,ANY
314950,BLOCK,1,,<empty>,,,,1,,ANY
314954,BLOCK,1,,<empty>,,,,1,,ANY
314961,BLOCK,1,,<empty>,,,,1,,ANY
314966,BLOCK,1,,<empty>,,,,1,,ANY
314971,BLOCK,1,,<empty>,,,,1,,ANY
314978,BLOCK,1,,<empty>,,,,1,,ANY
314983,BLOCK,1,,<empty>,,,,1,,ANY
314989,BLOCK,1,,<empty>,,,,1,,ANY
314993,BLOCK,1,,<empty>,,,,1,,ANY
314997,BLOCK,1,,<empty>,,,,1,,ANY
315004,BLOCK,1,,<empty>,,,,1,,ANY
315007,BLOCK,1,,<empty>,,,,1,,ANY
315013,BLOCK,1,,<empty>,,,,1,,ANY
315016,BLOCK,1,,<empty>,,,,1,,ANY
315024,BLOCK,1,,<empty>,,,,1,,ANY
315032,BLOCK,1,,<empty>,,,,1,,ANY
315035,BLOCK,1,,<empty>,,,,1,,ANY
315039,BLOCK,1,,<empty>,,,,1,,ANY
315044,BLOCK,1,,<empty>,,,,1,,ANY
315048,BLOCK,1,,<empty>,,,,1,,ANY
315052,BLOCK,1,,<empty>,,,,1,,ANY
315056,BLOCK,1,,<empty>,,,,1,,ANY
315062,BLOCK,1,,<empty>,,,,1,,ANY
315068,BLOCK,1,,<empty>,,,,1,,ANY
315074,BLOCK,1,,<empty>,,,,1,,ANY
315078,BLOCK,1,,<empty>,,,,1,,ANY
315083,BLOCK,1,,<empty>,,,,1,,ANY
315091,BLOCK,1,,<empty>,,,,1,,ANY
315098,BLOCK,1,,<empty>,,,,1,,ANY
315104,BLOCK,1,,<empty>,,,,1,,ANY
315110,BLOCK,1,,<empty>,,,,1,,ANY
315115,BLOCK,1,,<empty>,,,,1,,ANY
315120,BLOCK,1,,<empty>,,,,1,,ANY
315128,BLOCK,1,,<empty>,,,,1,,ANY
315132,BLOCK,1,,<empty>,,,,1,,ANY
315136,BLOCK,1,,<empty>,,,,1,,ANY
315140,BLOCK,1,,<empty>,,,,1,,ANY
315144,BLOCK,1,,<empty>,,,,1,,ANY
315148,BLOCK,1,,<empty>,,,,1,,ANY
315152,BLOCK,1,,<empty>,,,,1,,ANY
315156,BLOCK,1,,<empty>,,,,1,,ANY
315162,BLOCK,1,,<empty>,,,,1,,ANY
315167,BLOCK,1,,<empty>,,,,1,,ANY
315172,BLOCK,1,,<empty>,,,,1,,ANY
315178,BLOCK,1,,<empty>,,,,1,,ANY
315181,BLOCK,1,,<empty>,,,,1,,ANY
315185,BLOCK,1,,<empty>,,,,1,,ANY
315188,BLOCK,1,,<empty>,,,,1,,ANY
315191,BLOCK,1,,<empty>,,,,1,,ANY
315199,BLOCK,1,,<empty>,,,,1,,ANY
315203,BLOCK,1,,<empty>,,,,1,,ANY
315207,BLOCK,1,,<empty>,,,,1,,ANY
315210,BLOCK,1,,<empty>,,,,1,,ANY
315214,BLOCK,1,,<empty>,,,,1,,ANY
315218,BLOCK,1,,<empty>,,,,1,,ANY
315223,BLOCK,1,,<empty>,,,,1,,ANY
315226,BLOCK,1,,<empty>,,,,1,,ANY
315233,BLOCK,1,,<empty>,,,,1,,ANY
315238,BLOCK,1,,<empty>,,,,1,,ANY
315245,BLOCK,1,,<empty>,,,,1,,ANY
315250,BLOCK,1,,<empty>,,,,1,,ANY
315259,BLOCK,1,,<empty>,,,,1,,ANY
315265,BLOCK,1,,<empty>,,,,1,,ANY
315272,BLOCK,1,,<empty>,,,,1,,ANY
315281,BLOCK,1,,<empty>,,,,1,,ANY
315284,BLOCK,1,,<empty>,,,,1,,ANY
315289,BLOCK,1,,<empty>,,,,1,,ANY
315294,BLOCK,1,,<empty>,,,,1,,ANY
315297,BLOCK,1,,<empty>,,,,1,,ANY
315302,BLOCK,1,,<empty>,,,,1,,ANY
315310,BLOCK,1,,<empty>,,,,1,,ANY
315316,BLOCK,1,,<empty>,,,,1,,ANY
315320,BLOCK,1,,<empty>,,,,1,,ANY
315327,BLOCK,1,,<empty>,,,,1,,ANY
315331,BLOCK,1,,<empty>,,,,1,,ANY
315335,BLOCK,1,,<empty>,,,,1,,ANY
315339,BLOCK,1,,<empty>,,,,1,,ANY
315343,BLOCK,1,,<empty>,,,,1,,ANY
315349,BLOCK,1,,<empty>,,,,1,,ANY
315355,BLOCK,1,,<empty>,,,,1,,ANY
315359,BLOCK,1,,<empty>,,,,1,,ANY
315363,BLOCK,1,,<empty>,,,,1,,ANY
315368,BLOCK,1,,<empty>,,,,1,,ANY
315373,BLOCK,1,,<empty>,,,,1,,ANY
315380,BLOCK,1,,<empty>,,,,1,,ANY
315386,BLOCK,1,,<empty>,,,,1,,ANY
315390,BLOCK,1,,<empty>,,,,1,,ANY
315396,BLOCK,1,,<empty>,,,,1,,ANY
315399,BLOCK,1,,<empty>,,,,1,,ANY
315405,BLOCK,1,,<empty>,,,,1,,ANY
315409,BLOCK,1,,<empty>,,,,1,,ANY
315416,BLOCK,1,,<empty>,,,,1,,ANY
315419,BLOCK,1,,<empty>,,,,1,,ANY
315422,BLOCK,1,,<empty>,,,,1,,ANY
315429,BLOCK,1,,<empty>,,,,1,,ANY
315436,BLOCK,1,,<empty>,,,,1,,ANY
315440,BLOCK,1,,<empty>,,,,1,,ANY
315446,BLOCK,1,,<empty>,,,,1,,ANY
315450,BLOCK,1,,<empty>,,,,1,,ANY
315454,BLOCK,1,,<empty>,,,,1,,ANY
315460,BLOCK,1,,<empty>,,,,1,,ANY
315467,BLOCK,1,,<empty>,,,,1,,ANY
315471,BLOCK,1,,<empty>,,,,1,,ANY
315475,BLOCK,1,,<empty>,,,,1,,ANY
315481,BLOCK,1,,<empty>,,,,1,,ANY
315485,BLOCK,1,,<empty>,,,,1,,ANY
315490,BLOCK,1,,<empty>,,,,1,,ANY
315496,BLOCK,1,,<empty>,,,,1,,ANY
315499,BLOCK,1,,<empty>,,,,1,,ANY
315504,BLOCK,1,,<empty>,,,,1,,ANY
315507,BLOCK,1,,<empty>,,,,1,,ANY
315513,BLOCK,1,,<empty>,,,,1,,ANY
315518,BLOCK,1,,<empty>,,,,1,,ANY
315522,BLOCK,1,,<empty>,,,,1,,ANY
315526,BLOCK,1,,<empty>,,,,1,,ANY
315530,BLOCK,1,,<empty>,,,,1,,ANY
315534,BLOCK,1,,<empty>,,,,1,,ANY
315540,BLOCK,1,,<empty>,,,,1,,ANY
315546,BLOCK,1,,<empty>,,,,1,,ANY
315552,BLOCK,1,,<empty>,,,,1,,ANY
315557,BLOCK,1,,<empty>,,,,1,,ANY
315561,BLOCK,1,,<empty>,,,,1,,ANY
315565,BLOCK,1,,<empty>,,,,1,,ANY
315569,BLOCK,1,,<empty>,,,,1,,ANY
315575,BLOCK,1,,<empty>,,,,1,,ANY
315580,BLOCK,1,,<empty>,,,,1,,ANY
315585,BLOCK,1,,<empty>,,,,1,,ANY
315589,BLOCK,1,,<empty>,,,,1,,ANY
315597,BLOCK,1,,<empty>,,,,1,,ANY
315603,BLOCK,1,,<empty>,,,,1,,ANY
315606,BLOCK,1,,<empty>,,,,1,,ANY
315610,BLOCK,1,,<empty>,,,,1,,ANY
315614,BLOCK,1,,<empty>,,,,1,,ANY
315618,BLOCK,1,,<empty>,,,,1,,ANY
315621,BLOCK,1,,<empty>,,,,1,,ANY
315626,BLOCK,1,,<empty>,,,,1,,ANY
315633,BLOCK,1,,<empty>,,,,1,,ANY
315637,BLOCK,1,,<empty>,,,,1,,ANY
315643,BLOCK,1,,<empty>,,,,1,,ANY
315647,BLOCK,1,,<empty>,,,,1,,ANY
315652,BLOCK,1,,<empty>,,,,1,,ANY
315657,BLOCK,1,,<empty>,,,,1,,ANY
315662,BLOCK,1,,<empty>,,,,1,,ANY
315665,BLOCK,1,,<empty>,,,,1,,ANY
315670,BLOCK,1,,<empty>,,,,1,,ANY
315674,BLOCK,1,,<empty>,,,,1,,ANY
315678,BLOCK,1,,<empty>,,,,1,,ANY
315684,BLOCK,1,,<empty>,,,,1,,ANY
315688,BLOCK,1,,<empty>,,,,1,,ANY
315693,BLOCK,1,,<empty>,,,,1,,ANY
315698,BLOCK,1,,<empty>,,,,1,,ANY
315702,BLOCK,1,,<empty>,,,,1,,ANY
315706,BLOCK,1,,<empty>,,,,1,,ANY
315710,BLOCK,1,,<empty>,,,,1,,ANY
315715,BLOCK,1,,<empty>,,,,1,,ANY
315720,BLOCK,1,,<empty>,,,,1,,ANY
315724,BLOCK,1,,<empty>,,,,1,,ANY
315728,BLOCK,1,,<empty>,,,,1,,ANY
315736,BLOCK,1,,<empty>,,,,1,,ANY
315741,BLOCK,1,,<empty>,,,,1,,ANY
315745,BLOCK,1,,<empty>,,,,1,,ANY
315750,BLOCK,1,,<empty>,,,,1,,ANY
315754,BLOCK,1,,<empty>,,,,1,,ANY
315759,BLOCK,1,,<empty>,,,,1,,ANY
315764,BLOCK,1,,<empty>,,,,1,,ANY
315768,BLOCK,1,,<empty>,,,,1,,ANY
315772,BLOCK,1,,<empty>,,,,1,,ANY
315776,BLOCK,1,,<empty>,,,,1,,ANY
315779,BLOCK,1,,<empty>,,,,1,,ANY
315782,BLOCK,1,,<empty>,,,,1,,ANY
315787,BLOCK,1,,<empty>,,,,1,,ANY
315792,BLOCK,1,,<empty>,,,,1,,ANY
315797,BLOCK,1,,<empty>,,,,1,,ANY
315801,BLOCK,1,,<empty>,,,,1,,ANY
315806,BLOCK,1,,<empty>,,,,1,,ANY
315810,BLOCK,1,,<empty>,,,,1,,ANY
315814,BLOCK,1,,<empty>,,,,1,,ANY
315822,BLOCK,1,,<empty>,,,,1,,ANY
315826,BLOCK,1,,<empty>,,,,1,,ANY
315832,BLOCK,1,,<empty>,,,,1,,ANY
315836,BLOCK,1,,<empty>,,,,1,,ANY
315840,BLOCK,1,,<empty>,,,,1,,ANY
315844,BLOCK,1,,<empty>,,,,1,,ANY
315850,BLOCK,1,,<empty>,,,,1,,ANY
315855,BLOCK,1,,<empty>,,,,1,,ANY
315860,BLOCK,1,,<empty>,,,,1,,ANY
315866,BLOCK,1,,<empty>,,,,1,,ANY
315870,BLOCK,1,,<empty>,,,,1,,ANY
315875,BLOCK,1,,<empty>,,,,1,,ANY
315881,BLOCK,1,,<empty>,,,,1,,ANY
315886,BLOCK,1,,<empty>,,,,1,,ANY
315889,BLOCK,1,,<empty>,,,,1,,ANY
315894,BLOCK,1,,<empty>,,,,1,,ANY
315897,BLOCK,1,,<empty>,,,,1,,ANY
315902,BLOCK,1,,<empty>,,,,1,,ANY
315907,BLOCK,1,,<empty>,,,,1,,ANY
315913,BLOCK,1,,<empty>,,,,1,,ANY
315916,BLOCK,1,,<empty>,,,,1,,ANY
315919,BLOCK,1,,<empty>,,,,1,,ANY
315923,BLOCK,1,,<empty>,,,,1,,ANY
315929,BLOCK,1,,<empty>,,,,1,,ANY
315933,BLOCK,1,,<empty>,,,,1,,ANY
315937,BLOCK,1,,<empty>,,,,1,,ANY
315942,BLOCK,1,,<empty>,,,,1,,ANY
315947,BLOCK,1,,<empty>,,,,1,,ANY
315950,BLOCK,1,,<empty>,,,,1,,ANY
315955,BLOCK,1,,<empty>,,,,1,,ANY
315962,BLOCK,1,,<empty>,,,,1,,ANY
315965,BLOCK,1,,<empty>,,,,1,,ANY
315969,BLOCK,1,,<empty>,,,,1,,ANY
315974,BLOCK,1,,<empty>,,,,1,,ANY
315978,BLOCK,1,,<empty>,,,,1,,ANY
315981,BLOCK,1,,<empty>,,,,1,,ANY
315984,BLOCK,1,,<empty>,,,,1,,ANY
315988,BLOCK,1,,<empty>,,,,1,,ANY
315993,BLOCK,1,,<empty>,,,,1,,ANY
315997,BLOCK,1,,<empty>,,,,1,,ANY
316002,BLOCK,1,,<empty>,,,,1,,ANY
316009,BLOCK,1,,<empty>,,,,1,,ANY
316013,BLOCK,1,,<empty>,,,,1,,ANY
316018,BLOCK,1,,<empty>,,,,1,,ANY
316022,BLOCK,1,,<empty>,,,,1,,ANY
316026,BLOCK,1,,<empty>,,,,1,,ANY
316031,BLOCK,1,,<empty>,,,,1,,ANY
316037,BLOCK,1,,<empty>,,,,1,,ANY
316042,BLOCK,1,,<empty>,,,,1,,ANY
316046,BLOCK,1,,<empty>,,,,1,,ANY
316050,BLOCK,1,,<empty>,,,,1,,ANY
316054,BLOCK,1,,<empty>,,,,1,,ANY
316057,BLOCK,1,,<empty>,,,,1,,ANY
316062,BLOCK,1,,<empty>,,,,1,,ANY
316067,BLOCK,1,,<empty>,,,,1,,ANY
316071,BLOCK,1,,<empty>,,,,1,,ANY
316075,BLOCK,1,,<empty>,,,,1,,ANY
316080,BLOCK,1,,<empty>,,,,1,,ANY
316084,BLOCK,1,,<empty>,,,,1,,ANY
316088,BLOCK,1,,<empty>,,,,1,,ANY
316092,BLOCK,1,,<empty>,,,,1,,ANY
316096,BLOCK,1,,<empty>,,,,1,,ANY
316100,BLOCK,1,,<empty>,,,,1,,ANY
316103,BLOCK,1,,<empty>,,,,1,,ANY
316108,BLOCK,1,,<empty>,,,,1,,ANY
316112,BLOCK,1,,<empty>,,,,1,,ANY
316117,BLOCK,1,,<empty>,,,,1,,ANY
316121,BLOCK,1,,<empty>,,,,1,,ANY
316125,BLOCK,1,,<empty>,,,,1,,ANY
316128,BLOCK,1,,<empty>,,,,1,,ANY
316132,BLOCK,1,,<empty>,,,,1,,ANY
316136,BLOCK,1,,<empty>,,,,1,,ANY
316139,BLOCK,1,,<empty>,,,,1,,ANY
316142,BLOCK,1,,<empty>,,,,1,,ANY
316146,BLOCK,1,,<empty>,,,,1,,ANY
316151,BLOCK,1,,<empty>,,,,1,,ANY
316156,BLOCK,1,,<empty>,,,,1,,ANY
316160,BLOCK,1,,<empty>,,,,1,,ANY
316166,BLOCK,1,,<empty>,,,,1,,ANY
316170,BLOCK,1,,<empty>,,,,1,,ANY
316174,BLOCK,1,,<empty>,,,,1,,ANY
316177,BLOCK,1,,<empty>,,,,1,,ANY
316181,BLOCK,1,,<empty>,,,,1,,ANY
316188,BLOCK,1,,<empty>,,,,1,,ANY
316193,BLOCK,1,,<empty>,,,,1,,ANY
316198,BLOCK,1,,<empty>,,,,1,,ANY
316202,BLOCK,1,,<empty>,,,,1,,ANY
316205,BLOCK,1,,<empty>,,,,1,,ANY
316208,BLOCK,1,,<empty>,,,,1,,ANY
316213,BLOCK,1,,<empty>,,,,1,,ANY
316217,BLOCK,1,,<empty>,,,,1,,ANY
316223,BLOCK,1,,<empty>,,,,1,,ANY
316228,BLOCK,1,,<empty>,,,,1,,ANY
316235,BLOCK,1,,<empty>,,,,1,,ANY
316239,BLOCK,1,,<empty>,,,,1,,ANY
316244,BLOCK,1,,<empty>,,,,1,,ANY
316248,BLOCK,1,,<empty>,,,,1,,ANY
316252,BLOCK,1,,<empty>,,,,1,,ANY
316256,BLOCK,1,,<empty>,,,,1,,ANY
316260,BLOCK,1,,<empty>,,,,1,,ANY
316264,BLOCK,1,,<empty>,,,,1,,ANY
316269,BLOCK,1,,<empty>,,,,1,,ANY
316273,BLOCK,1,,<empty>,,,,1,,ANY
316277,BLOCK,1,,<empty>,,,,1,,ANY
316282,BLOCK,1,,<empty>,,,,1,,ANY
316287,BLOCK,1,,<empty>,,,,1,,ANY
316291,BLOCK,1,,<empty>,,,,1,,ANY
316295,BLOCK,1,,<empty>,,,,1,,ANY
316298,BLOCK,1,,<empty>,,,,1,,ANY
316302,BLOCK,1,,<empty>,,,,1,,ANY
316306,BLOCK,1,,<empty>,,,,1,,ANY
316312,BLOCK,1,,<empty>,,,,1,,ANY
316316,BLOCK,1,,<empty>,,,,1,,ANY
316321,BLOCK,1,,<empty>,,,,1,,ANY
316324,BLOCK,1,,<empty>,,,,1,,ANY
316328,BLOCK,1,,<empty>,,,,1,,ANY
316332,BLOCK,1,,<empty>,,,,1,,ANY
316336,BLOCK,1,,<empty>,,,,1,,ANY
316340,BLOCK,1,,<empty>,,,,1,,ANY
316344,BLOCK,1,,<empty>,,,,1,,ANY
316349,BLOCK,1,,<empty>,,,,1,,ANY
316353,BLOCK,1,,<empty>,,,,1,,ANY
316357,BLOCK,1,,<empty>,,,,1,,ANY
316363,BLOCK,1,,<empty>,,,,1,,ANY
316367,BLOCK,1,,<empty>,,,,1,,ANY
316371,BLOCK,1,,<empty>,,,,1,,ANY
316375,BLOCK,1,,<empty>,,,,1,,ANY
316379,BLOCK,1,,<empty>,,,,1,,ANY
316383,BLOCK,1,,<empty>,,,,1,,ANY
316387,BLOCK,1,,<empty>,,,,1,,ANY
316391,BLOCK,1,,<empty>,,,,1,,ANY
316398,BLOCK,1,,<empty>,,,,1,,ANY
316402,BLOCK,1,,<empty>,,,,1,,ANY
316412,BLOCK,1,,<empty>,,,,1,,ANY
316417,BLOCK,1,,<empty>,,,,1,,ANY
316423,BLOCK,1,,<empty>,,,,1,,ANY
316426,BLOCK,1,,<empty>,,,,1,,ANY
316432,BLOCK,1,,<empty>,,,,1,,ANY
316436,BLOCK,1,,<empty>,,,,1,,ANY
316440,BLOCK,1,,<empty>,,,,1,,ANY
316445,BLOCK,1,,<empty>,,,,1,,ANY
316449,BLOCK,1,,<empty>,,,,1,,ANY
316454,BLOCK,1,,<empty>,,,,1,,ANY
316460,BLOCK,1,,<empty>,,,,1,,ANY
316467,BLOCK,1,,<empty>,,,,1,,ANY
316470,BLOCK,1,,<empty>,,,,1,,ANY
316473,BLOCK,1,,<empty>,,,,1,,ANY
316477,BLOCK,1,,<empty>,,,,1,,ANY
316483,BLOCK,1,,<empty>,,,,1,,ANY
316487,BLOCK,1,,<empty>,,,,1,,ANY
316491,BLOCK,1,,<empty>,,,,1,,ANY
316495,BLOCK,1,,<empty>,,,,1,,ANY
316499,BLOCK,1,,<empty>,,,,1,,ANY
316503,BLOCK,1,,<empty>,,,,1,,ANY
316508,BLOCK,1,,<empty>,,,,1,,ANY
316512,BLOCK,1,,<empty>,,,,1,,ANY
316516,BLOCK,1,,<empty>,,,,1,,ANY
316521,BLOCK,1,,<empty>,,,,1,,ANY
316525,BLOCK,1,,<empty>,,,,1,,ANY
316529,BLOCK,1,,<empty>,,,,1,,ANY
316534,BLOCK,1,,<empty>,,,,1,,ANY
316538,BLOCK,1,,<empty>,,,,1,,ANY
316543,BLOCK,1,,<empty>,,,,1,,ANY
316548,BLOCK,1,,<empty>,,,,1,,ANY
316551,BLOCK,1,,<empty>,,,,1,,ANY
316555,BLOCK,1,,<empty>,,,,1,,ANY
316559,BLOCK,1,,<empty>,,,,1,,ANY
316563,BLOCK,1,,<empty>,,,,1,,ANY
316567,BLOCK,1,,<empty>,,,,1,,ANY
316572,BLOCK,1,,<empty>,,,,1,,ANY
316577,BLOCK,1,,<empty>,,,,1,,ANY
316581,BLOCK,1,,<empty>,,,,1,,ANY
316586,BLOCK,1,,<empty>,,,,1,,ANY
316589,BLOCK,1,,<empty>,,,,1,,ANY
316594,BLOCK,1,,<empty>,,,,1,,ANY
316599,BLOCK,1,,<empty>,,,,1,,ANY
316603,BLOCK,1,,<empty>,,,,1,,ANY
316608,BLOCK,1,,<empty>,,,,1,,ANY
316612,BLOCK,1,,<empty>,,,,1,,ANY
316616,BLOCK,1,,<empty>,,,,1,,ANY
316620,BLOCK,1,,<empty>,,,,1,,ANY
316626,BLOCK,1,,<empty>,,,,1,,ANY
316630,BLOCK,1,,<empty>,,,,1,,ANY
316634,BLOCK,1,,<empty>,,,,1,,ANY
316639,BLOCK,1,,<empty>,,,,1,,ANY
316645,BLOCK,1,,<empty>,,,,1,,ANY
316652,BLOCK,1,,<empty>,,,,1,,ANY
316657,BLOCK,1,,<empty>,,,,1,,ANY
316665,BLOCK,1,,<empty>,,,,1,,ANY
316670,BLOCK,1,,<empty>,,,,1,,ANY
316674,BLOCK,1,,<empty>,,,,1,,ANY
316680,BLOCK,1,,<empty>,,,,1,,ANY
316685,BLOCK,1,,<empty>,,,,1,,ANY
316689,BLOCK,1,,<empty>,,,,1,,ANY
316694,BLOCK,1,,<empty>,,,,1,,ANY
316699,BLOCK,1,,<empty>,,,,1,,ANY
316705,BLOCK,1,,<empty>,,,,1,,ANY
316709,BLOCK,1,,<empty>,,,,1,,ANY
316715,BLOCK,1,,<empty>,,,,1,,ANY
316722,BLOCK,1,,<empty>,,,,1,,ANY
316727,BLOCK,1,,<empty>,,,,1,,ANY
316730,BLOCK,1,,<empty>,,,,1,,ANY
316735,BLOCK,1,,<empty>,,,,1,,ANY
316741,BLOCK,1,,<empty>,,,,1,,ANY
316746,BLOCK,1,,<empty>,,,,1,,ANY
316750,BLOCK,1,,<empty>,,,,1,,ANY
316754,BLOCK,1,,<empty>,,,,1,,ANY
316758,BLOCK,1,,<empty>,,,,1,,ANY
316764,BLOCK,1,,<empty>,,,,1,,ANY
316771,BLOCK,1,,<empty>,,,,1,,ANY
316776,BLOCK,1,,<empty>,,,,1,,ANY
316781,BLOCK,1,,<empty>,,,,1,,ANY
316785,BLOCK,1,,<empty>,,,,1,,ANY
316789,BLOCK,1,,<empty>,,,,1,,ANY
316795,BLOCK,1,,<empty>,,,,1,,ANY
316799,BLOCK,1,,<empty>,,,,1,,ANY
316805,BLOCK,1,,<empty>,,,,1,,ANY
316811,BLOCK,1,,<empty>,,,,1,,ANY
316817,BLOCK,1,,<empty>,,,,1,,ANY
316822,BLOCK,1,,<empty>,,,,1,,ANY
316828,BLOCK,1,,<empty>,,,,1,,ANY
316832,BLOCK,1,,<empty>,,,,1,,ANY
316836,BLOCK,1,,<empty>,,,,1,,ANY
316841,BLOCK,1,,<empty>,,,,1,,ANY
316846,BLOCK,1,,<empty>,,,,1,,ANY
316851,BLOCK,1,,<empty>,,,,1,,ANY
316856,BLOCK,1,,<empty>,,,,1,,ANY
316861,BLOCK,1,,<empty>,,,,1,,ANY
316865,BLOCK,1,,<empty>,,,,1,,ANY
316871,BLOCK,1,,<empty>,,,,1,,ANY
316876,BLOCK,1,,<empty>,,,,1,,ANY
316880,BLOCK,1,,<empty>,,,,1,,ANY
316887,BLOCK,1,,<empty>,,,,1,,ANY
316891,BLOCK,1,,<empty>,,,,1,,ANY
316895,BLOCK,1,,<empty>,,,,1,,ANY
316899,BLOCK,1,,<empty>,,,,1,,ANY
316904,BLOCK,1,,<empty>,,,,1,,ANY
316912,BLOCK,1,,<empty>,,,,1,,ANY
316917,BLOCK,1,,<empty>,,,,1,,ANY
316922,BLOCK,1,,<empty>,,,,1,,ANY
316926,BLOCK,1,,<empty>,,,,1,,ANY
316931,BLOCK,1,,<empty>,,,,1,,ANY
316936,BLOCK,1,,<empty>,,,,1,,ANY
316941,BLOCK,1,,<empty>,,,,1,,ANY
316946,BLOCK,1,,<empty>,,,,1,,ANY
316950,BLOCK,1,,<empty>,,,,1,,ANY
316956,BLOCK,1,,<empty>,,,,1,,ANY
316960,BLOCK,1,,<empty>,,,,1,,ANY
316966,BLOCK,1,,<empty>,,,,1,,ANY
316972,BLOCK,1,,<empty>,,,,1,,ANY
316977,BLOCK,1,,<empty>,,,,1,,ANY
316982,BLOCK,1,,<empty>,,,,1,,ANY
316987,BLOCK,1,,<empty>,,,,1,,ANY
316994,BLOCK,1,,<empty>,,,,1,,ANY
317000,BLOCK,1,,<empty>,,,,1,,ANY
317006,BLOCK,1,,<empty>,,,,1,,ANY
317010,BLOCK,1,,<empty>,,,,1,,ANY
317015,BLOCK,1,,<empty>,,,,1,,ANY
317019,BLOCK,1,,<empty>,,,,1,,ANY
317025,BLOCK,1,,<empty>,,,,1,,ANY
317030,BLOCK,1,,<empty>,,,,1,,ANY
317034,BLOCK,1,,<empty>,,,,1,,ANY
317040,BLOCK,1,,<empty>,,,,1,,ANY
317046,BLOCK,1,,<empty>,,,,1,,ANY
317051,BLOCK,1,,<empty>,,,,1,,ANY
317055,BLOCK,1,,<empty>,,,,1,,ANY
317061,BLOCK,1,,<empty>,,,,1,,ANY
317065,BLOCK,1,,<empty>,,,,1,,ANY
317068,BLOCK,1,,<empty>,,,,1,,ANY
317072,BLOCK,1,,<empty>,,,,1,,ANY
317077,BLOCK,1,,<empty>,,,,1,,ANY
317081,BLOCK,1,,<empty>,,,,1,,ANY
317089,BLOCK,1,,<empty>,,,,1,,ANY
317094,BLOCK,1,,<empty>,,,,1,,ANY
317098,BLOCK,1,,<empty>,,,,1,,ANY
317102,BLOCK,1,,<empty>,,,,1,,ANY
317109,BLOCK,1,,<empty>,,,,1,,ANY
317114,BLOCK,1,,<empty>,,,,1,,ANY
317120,BLOCK,1,,<empty>,,,,1,,ANY
317127,BLOCK,1,,<empty>,,,,1,,ANY
317132,BLOCK,1,,<empty>,,,,1,,ANY
317137,BLOCK,1,,<empty>,,,,1,,ANY
317145,BLOCK,1,,<empty>,,,,1,,ANY
317150,BLOCK,1,,<empty>,,,,1,,ANY
317154,BLOCK,1,,<empty>,,,,1,,ANY
317158,BLOCK,1,,<empty>,,,,1,,ANY
317162,BLOCK,1,,<empty>,,,,1,,ANY
317169,BLOCK,1,,<empty>,,,,1,,ANY
317175,BLOCK,1,,<empty>,,,,1,,ANY
317178,BLOCK,1,,<empty>,,,,1,,ANY
317182,BLOCK,1,,<empty>,,,,1,,ANY
317188,BLOCK,1,,<empty>,,,,1,,ANY
317191,BLOCK,1,,<empty>,,,,1,,ANY
317194,BLOCK,1,,<empty>,,,,1,,ANY
317197,BLOCK,1,,<empty>,,,,1,,ANY
317203,BLOCK,1,,<empty>,,,,1,,ANY
317208,BLOCK,1,,<empty>,,,,1,,ANY
317211,BLOCK,1,,<empty>,,,,1,,ANY
317214,BLOCK,1,,<empty>,,,,1,,ANY
317218,BLOCK,1,,<empty>,,,,1,,ANY
317222,BLOCK,1,,<empty>,,,,1,,ANY
317226,BLOCK,1,,<empty>,,,,1,,ANY
317230,BLOCK,1,,<empty>,,,,1,,ANY
317234,BLOCK,1,,<empty>,,,,1,,ANY
317238,BLOCK,1,,<empty>,,,,1,,ANY
317244,BLOCK,1,,<empty>,,,,1,,ANY
317257,BLOCK,1,,<empty>,,,,1,,ANY
317262,BLOCK,1,,<empty>,,,,1,,ANY
317266,BLOCK,1,,<empty>,,,,1,,ANY
317270,BLOCK,1,,<empty>,,,,1,,ANY
317275,BLOCK,1,,<empty>,,,,1,,ANY
317280,BLOCK,1,,<empty>,,,,1,,ANY
317286,BLOCK,1,,<empty>,,,,1,,ANY
317293,BLOCK,1,,<empty>,,,,1,,ANY
317298,BLOCK,1,,<empty>,,,,1,,ANY
317303,BLOCK,1,,<empty>,,,,1,,ANY
317308,BLOCK,1,,<empty>,,,,1,,ANY
317312,BLOCK,1,,<empty>,,,,1,,ANY
317316,BLOCK,1,,<empty>,,,,1,,ANY
317319,BLOCK,1,,<empty>,,,,1,,ANY
317322,BLOCK,1,,<empty>,,,,1,,ANY
317326,BLOCK,1,,<empty>,,,,1,,ANY
317330,BLOCK,1,,<empty>,,,,1,,ANY
317334,BLOCK,1,,<empty>,,,,1,,ANY
317338,BLOCK,1,,<empty>,,,,1,,ANY
317341,BLOCK,1,,<empty>,,,,1,,ANY
317345,BLOCK,1,,<empty>,,,,1,,ANY
317349,BLOCK,1,,<empty>,,,,1,,ANY
317353,BLOCK,1,,<empty>,,,,1,,ANY
317357,BLOCK,1,,<empty>,,,,1,,ANY
317361,BLOCK,1,,<empty>,,,,1,,ANY
317365,BLOCK,1,,<empty>,,,,1,,ANY
317369,BLOCK,1,,<empty>,,,,1,,ANY
317377,BLOCK,1,,<empty>,,,,1,,ANY
317381,BLOCK,1,,<empty>,,,,1,,ANY
317387,BLOCK,1,,<empty>,,,,1,,ANY
317391,BLOCK,1,,<empty>,,,,1,,ANY
317395,BLOCK,1,,<empty>,,,,1,,ANY
317399,BLOCK,1,,<empty>,,,,1,,ANY
317403,BLOCK,1,,<empty>,,,,1,,ANY
317409,BLOCK,1,,<empty>,,,,1,,ANY
317414,BLOCK,1,,<empty>,,,,1,,ANY
317419,BLOCK,1,,<empty>,,,,1,,ANY
317423,BLOCK,1,,<empty>,,,,1,,ANY
317428,BLOCK,1,,<empty>,,,,1,,ANY
317434,BLOCK,1,,<empty>,,,,1,,ANY
317441,BLOCK,1,,<empty>,,,,1,,ANY
317446,BLOCK,1,,<empty>,,,,1,,ANY
317451,BLOCK,1,,<empty>,,,,1,,ANY
317456,BLOCK,1,,<empty>,,,,1,,ANY
317460,BLOCK,1,,<empty>,,,,1,,ANY
317464,BLOCK,1,,<empty>,,,,1,,ANY
317468,BLOCK,1,,<empty>,,,,1,,ANY
317475,BLOCK,1,,<empty>,,,,1,,ANY
317479,BLOCK,1,,<empty>,,,,1,,ANY
317486,BLOCK,1,,<empty>,,,,1,,ANY
317490,BLOCK,1,,<empty>,,,,1,,ANY
317494,BLOCK,1,,<empty>,,,,1,,ANY
317499,BLOCK,1,,<empty>,,,,1,,ANY
317505,BLOCK,1,,<empty>,,,,1,,ANY
317511,BLOCK,1,,<empty>,,,,1,,ANY
317515,BLOCK,1,,<empty>,,,,1,,ANY
317522,BLOCK,1,,<empty>,,,,1,,ANY
317528,BLOCK,1,,<empty>,,,,1,,ANY
317532,BLOCK,1,,<empty>,,,,1,,ANY
317536,BLOCK,1,,<empty>,,,,1,,ANY
317539,BLOCK,1,,<empty>,,,,1,,ANY
317544,BLOCK,1,,<empty>,,,,1,,ANY
317550,BLOCK,1,,<empty>,,,,1,,ANY
317554,BLOCK,1,,<empty>,,,,1,,ANY
317558,BLOCK,1,,<empty>,,,,1,,ANY
317563,BLOCK,1,,<empty>,,,,1,,ANY
317568,BLOCK,1,,<empty>,,,,1,,ANY
317572,BLOCK,1,,<empty>,,,,1,,ANY
317576,BLOCK,1,,<empty>,,,,1,,ANY
317580,BLOCK,1,,<empty>,,,,1,,ANY
317588,BLOCK,1,,<empty>,,,,1,,ANY
317592,BLOCK,1,,<empty>,,,,1,,ANY
317597,BLOCK,1,,<empty>,,,,1,,ANY
317601,BLOCK,1,,<empty>,,,,1,,ANY
317608,BLOCK,1,,<empty>,,,,1,,ANY
317614,BLOCK,1,,<empty>,,,,1,,ANY
317622,BLOCK,1,,<empty>,,,,1,,ANY
317627,BLOCK,1,,<empty>,,,,1,,ANY
317633,BLOCK,1,,<empty>,,,,1,,ANY
317637,BLOCK,1,,<empty>,,,,1,,ANY
317642,BLOCK,1,,<empty>,,,,1,,ANY
317647,BLOCK,1,,<empty>,,,,1,,ANY
317652,BLOCK,1,,<empty>,,,,1,,ANY
317657,BLOCK,1,,<empty>,,,,1,,ANY
317662,BLOCK,1,,<empty>,,,,1,,ANY
317666,BLOCK,1,,<empty>,,,,1,,ANY
317670,BLOCK,1,,<empty>,,,,1,,ANY
317674,BLOCK,1,,<empty>,,,,1,,ANY
317679,BLOCK,1,,<empty>,,,,1,,ANY
317684,BLOCK,1,,<empty>,,,,1,,ANY
317688,BLOCK,1,,<empty>,,,,1,,ANY
317693,BLOCK,1,,<empty>,,,,1,,ANY
317698,BLOCK,1,,<empty>,,,,1,,ANY
317705,BLOCK,1,,<empty>,,,,1,,ANY
317710,BLOCK,1,,<empty>,,,,1,,ANY
317714,BLOCK,1,,<empty>,,,,1,,ANY
317719,BLOCK,1,,<empty>,,,,1,,ANY
317723,BLOCK,1,,<empty>,,,,1,,ANY
317729,BLOCK,1,,<empty>,,,,1,,ANY
317735,BLOCK,1,,<empty>,,,,1,,ANY
317739,BLOCK,1,,<empty>,,,,1,,ANY
317742,BLOCK,1,,<empty>,,,,1,,ANY
317747,BLOCK,1,,<empty>,,,,1,,ANY
317753,BLOCK,1,,<empty>,,,,1,,ANY
317759,BLOCK,1,,<empty>,,,,1,,ANY
317764,BLOCK,1,,<empty>,,,,1,,ANY
317769,BLOCK,1,,<empty>,,,,1,,ANY
317774,BLOCK,1,,<empty>,,,,1,,ANY
317783,BLOCK,1,,<empty>,,,,1,,ANY
317786,BLOCK,1,,<empty>,,,,1,,ANY
317790,BLOCK,1,,<empty>,,,,1,,ANY
317796,BLOCK,1,,<empty>,,,,1,,ANY
317799,BLOCK,1,,<empty>,,,,1,,ANY
317804,BLOCK,1,,<empty>,,,,1,,ANY
317807,BLOCK,1,,<empty>,,,,1,,ANY
317813,BLOCK,1,,<empty>,,,,1,,ANY
317817,BLOCK,1,,<empty>,,,,1,,ANY
317821,BLOCK,1,,<empty>,,,,1,,ANY
317827,BLOCK,1,,<empty>,,,,1,,ANY
317831,BLOCK,1,,<empty>,,,,1,,ANY
317835,BLOCK,1,,<empty>,,,,1,,ANY
317839,BLOCK,1,,<empty>,,,,1,,ANY
317843,BLOCK,1,,<empty>,,,,1,,ANY
317847,BLOCK,1,,<empty>,,,,1,,ANY
317851,BLOCK,1,,<empty>,,,,1,,ANY
317855,BLOCK,1,,<empty>,,,,1,,ANY
317859,BLOCK,1,,<empty>,,,,1,,ANY
317863,BLOCK,1,,<empty>,,,,1,,ANY
317867,BLOCK,1,,<empty>,,,,1,,ANY
317872,BLOCK,1,,<empty>,,,,1,,ANY
317877,BLOCK,1,,<empty>,,,,1,,ANY
317882,BLOCK,1,,<empty>,,,,1,,ANY
317887,BLOCK,1,,<empty>,,,,1,,ANY
317892,BLOCK,1,,<empty>,,,,1,,ANY
317897,BLOCK,1,,<empty>,,,,1,,ANY
317902,BLOCK,1,,<empty>,,,,1,,ANY
317907,BLOCK,1,,<empty>,,,,1,,ANY
317912,BLOCK,1,,<empty>,,,,1,,ANY
317917,BLOCK,1,,<empty>,,,,1,,ANY
317922,BLOCK,1,,<empty>,,,,1,,ANY
317927,BLOCK,1,,<empty>,,,,1,,ANY
317932,BLOCK,1,,<empty>,,,,1,,ANY
317936,BLOCK,1,,<empty>,,,,1,,ANY
317941,BLOCK,1,,<empty>,,,,1,,ANY
317947,BLOCK,1,,<empty>,,,,1,,ANY
317955,BLOCK,1,,<empty>,,,,1,,ANY
317960,BLOCK,1,,<empty>,,,,1,,ANY
317967,BLOCK,1,,<empty>,,,,1,,ANY
317974,BLOCK,1,,<empty>,,,,1,,ANY
317979,BLOCK,1,,<empty>,,,,1,,ANY
317984,BLOCK,1,,<empty>,,,,1,,ANY
317989,BLOCK,1,,<empty>,,,,1,,ANY
317993,BLOCK,1,,<empty>,,,,1,,ANY
317998,BLOCK,1,,<empty>,,,,1,,ANY
318002,BLOCK,1,,<empty>,,,,1,,ANY
318008,BLOCK,1,,<empty>,,,,1,,ANY
318011,BLOCK,1,,<empty>,,,,1,,ANY
318016,BLOCK,1,,<empty>,,,,1,,ANY
318020,BLOCK,1,,<empty>,,,,1,,ANY
318026,BLOCK,1,,<empty>,,,,1,,ANY
318034,BLOCK,1,,<empty>,,,,1,,ANY
318037,BLOCK,1,,<empty>,,,,1,,ANY
318041,BLOCK,1,,<empty>,,,,1,,ANY
318046,BLOCK,1,,<empty>,,,,1,,ANY
318049,BLOCK,1,,<empty>,,,,1,,ANY
318055,BLOCK,1,,<empty>,,,,1,,ANY
318059,BLOCK,1,,<empty>,,,,1,,ANY
318064,BLOCK,1,,<empty>,,,,1,,ANY
318069,BLOCK,1,,<empty>,,,,1,,ANY
318074,BLOCK,1,,<empty>,,,,1,,ANY
318080,BLOCK,1,,<empty>,,,,1,,ANY
318084,BLOCK,1,,<empty>,,,,1,,ANY
318087,BLOCK,1,,<empty>,,,,1,,ANY
318091,BLOCK,1,,<empty>,,,,1,,ANY
318097,BLOCK,1,,<empty>,,,,1,,ANY
318100,BLOCK,1,,<empty>,,,,1,,ANY
318107,BLOCK,1,,<empty>,,,,1,,ANY
318112,BLOCK,1,,<empty>,,,,1,,ANY
318118,BLOCK,1,,<empty>,,,,1,,ANY
318122,BLOCK,1,,<empty>,,,,1,,ANY
318126,BLOCK,1,,<empty>,,,,1,,ANY
318132,BLOCK,1,,<empty>,,,,1,,ANY
318136,BLOCK,1,,<empty>,,,,1,,ANY
318140,BLOCK,1,,<empty>,,,,1,,ANY
318144,BLOCK,1,,<empty>,,,,1,,ANY
318149,BLOCK,1,,<empty>,,,,1,,ANY
318156,BLOCK,1,,<empty>,,,,1,,ANY
318160,BLOCK,1,,<empty>,,,,1,,ANY
318164,BLOCK,1,,<empty>,,,,1,,ANY
318170,BLOCK,1,,<empty>,,,,1,,ANY
318175,BLOCK,1,,<empty>,,,,1,,ANY
318181,BLOCK,1,,<empty>,,,,1,,ANY
318185,BLOCK,1,,<empty>,,,,1,,ANY
318191,BLOCK,1,,<empty>,,,,1,,ANY
318197,BLOCK,1,,<empty>,,,,1,,ANY
318202,BLOCK,1,,<empty>,,,,1,,ANY
318208,BLOCK,1,,<empty>,,,,1,,ANY
318213,BLOCK,1,,<empty>,,,,1,,ANY
318221,BLOCK,1,,<empty>,,,,1,,ANY
318227,BLOCK,1,,<empty>,,,,1,,ANY
318231,BLOCK,1,,<empty>,,,,1,,ANY
318236,BLOCK,1,,<empty>,,,,1,,ANY
318240,BLOCK,1,,<empty>,,,,1,,ANY
318246,BLOCK,1,,<empty>,,,,1,,ANY
318251,BLOCK,1,,<empty>,,,,1,,ANY
318256,BLOCK,1,,<empty>,,,,1,,ANY
318260,BLOCK,1,,<empty>,,,,1,,ANY
318264,BLOCK,1,,<empty>,,,,1,,ANY
318268,BLOCK,1,,<empty>,,,,1,,ANY
318274,BLOCK,1,,<empty>,,,,1,,ANY
318280,BLOCK,1,,<empty>,,,,1,,ANY
318284,BLOCK,1,,<empty>,,,,1,,ANY
318289,BLOCK,1,,<empty>,,,,1,,ANY
318293,BLOCK,1,,<empty>,,,,1,,ANY
318299,BLOCK,1,,<empty>,,,,1,,ANY
318304,BLOCK,1,,<empty>,,,,1,,ANY
318309,BLOCK,1,,<empty>,,,,1,,ANY
318313,BLOCK,1,,<empty>,,,,1,,ANY
318317,BLOCK,1,,<empty>,,,,1,,ANY
318322,BLOCK,1,,<empty>,,,,1,,ANY
318326,BLOCK,1,,<empty>,,,,1,,ANY
318330,BLOCK,1,,<empty>,,,,1,,ANY
318336,BLOCK,1,,<empty>,,,,1,,ANY
318342,BLOCK,1,,<empty>,,,,1,,ANY
318347,BLOCK,1,,<empty>,,,,1,,ANY
318356,BLOCK,1,,<empty>,,,,1,,ANY
318360,BLOCK,1,,<empty>,,,,1,,ANY
318364,BLOCK,1,,<empty>,,,,1,,ANY
318368,BLOCK,1,,<empty>,,,,1,,ANY
318373,BLOCK,1,,<empty>,,,,1,,ANY
318379,BLOCK,1,,<empty>,,,,1,,ANY
318383,BLOCK,1,,<empty>,,,,1,,ANY
318387,BLOCK,1,,<empty>,,,,1,,ANY
318391,BLOCK,1,,<empty>,,,,1,,ANY
318396,BLOCK,1,,<empty>,,,,1,,ANY
318401,BLOCK,1,,<empty>,,,,1,,ANY
318405,BLOCK,1,,<empty>,,,,1,,ANY
318410,BLOCK,1,,<empty>,,,,1,,ANY
318414,BLOCK,1,,<empty>,,,,1,,ANY
318423,BLOCK,1,,<empty>,,,,1,,ANY
318427,BLOCK,1,,<empty>,,,,1,,ANY
318433,BLOCK,1,,<empty>,,,,1,,ANY
318436,BLOCK,1,,<empty>,,,,1,,ANY
318443,BLOCK,1,,<empty>,,,,1,,ANY
318447,BLOCK,1,,<empty>,,,,1,,ANY
318452,BLOCK,1,,<empty>,,,,1,,ANY
318456,BLOCK,1,,<empty>,,,,1,,ANY
318462,BLOCK,1,,<empty>,,,,1,,ANY
318467,BLOCK,1,,<empty>,,,,1,,ANY
318474,BLOCK,1,,<empty>,,,,1,,ANY
318477,BLOCK,1,,<empty>,,,,1,,ANY
318484,BLOCK,1,,<empty>,,,,1,,ANY
318490,BLOCK,1,,<empty>,,,,1,,ANY
318494,BLOCK,1,,<empty>,,,,1,,ANY
318500,BLOCK,1,,<empty>,,,,1,,ANY
318506,BLOCK,1,,<empty>,,,,1,,ANY
318509,BLOCK,1,,<empty>,,,,1,,ANY
318514,BLOCK,1,,<empty>,,,,1,,ANY
318518,BLOCK,1,,<empty>,,,,1,,ANY
318526,BLOCK,1,,<empty>,,,,1,,ANY
318534,BLOCK,1,,<empty>,,,,1,,ANY
318537,BLOCK,1,,<empty>,,,,1,,ANY
318543,BLOCK,1,,<empty>,,,,1,,ANY
318549,BLOCK,1,,<empty>,,,,1,,ANY
318554,BLOCK,1,,<empty>,,,,1,,ANY
318560,BLOCK,1,,<empty>,,,,1,,ANY
318564,BLOCK,1,,<empty>,,,,1,,ANY
318569,BLOCK,1,,<empty>,,,,1,,ANY
318574,BLOCK,1,,<empty>,,,,1,,ANY
318578,BLOCK,1,,<empty>,,,,1,,ANY
318584,BLOCK,1,,<empty>,,,,1,,ANY
318588,BLOCK,1,,<empty>,,,,1,,ANY
318596,BLOCK,1,,<empty>,,,,1,,ANY
318600,BLOCK,1,,<empty>,,,,1,,ANY
318603,BLOCK,1,,<empty>,,,,1,,ANY
318609,BLOCK,1,,<empty>,,,,1,,ANY
318615,BLOCK,1,,<empty>,,,,1,,ANY
318619,BLOCK,1,,<empty>,,,,1,,ANY
318623,BLOCK,1,,<empty>,,,,1,,ANY
318627,BLOCK,1,,<empty>,,,,1,,ANY
318631,BLOCK,1,,<empty>,,,,1,,ANY
318635,BLOCK,1,,<empty>,,,,1,,ANY
318639,BLOCK,1,,<empty>,,,,1,,ANY
318643,BLOCK,1,,<empty>,,,,1,,ANY
318647,BLOCK,1,,<empty>,,,,1,,ANY
318652,BLOCK,1,,<empty>,,,,1,,ANY
318657,BLOCK,1,,<empty>,,,,1,,ANY
318662,BLOCK,1,,<empty>,,,,1,,ANY
318666,BLOCK,1,,<empty>,,,,1,,ANY
318670,BLOCK,1,,<empty>,,,,1,,ANY
318674,BLOCK,1,,<empty>,,,,1,,ANY
318678,BLOCK,1,,<empty>,,,,1,,ANY
318682,BLOCK,1,,<empty>,,,,1,,ANY
318687,BLOCK,1,,<empty>,,,,1,,ANY
318691,BLOCK,1,,<empty>,,,,1,,ANY
318695,BLOCK,1,,<empty>,,,,1,,ANY
318701,BLOCK,1,,<empty>,,,,1,,ANY
318705,BLOCK,1,,<empty>,,,,1,,ANY
318709,BLOCK,1,,<empty>,,,,1,,ANY
318715,BLOCK,1,,<empty>,,,,1,,ANY
318726,BLOCK,1,,<empty>,,,,1,,ANY
318731,BLOCK,1,,<empty>,,,,1,,ANY
318736,BLOCK,1,,<empty>,,,,1,,ANY
318740,BLOCK,1,,<empty>,,,,1,,ANY
318744,BLOCK,1,,<empty>,,,,1,,ANY
318751,BLOCK,1,,<empty>,,,,1,,ANY
318755,BLOCK,1,,<empty>,,,,1,,ANY
318762,BLOCK,1,,<empty>,,,,1,,ANY
318766,BLOCK,1,,<empty>,,,,1,,ANY
318773,BLOCK,1,,<empty>,,,,1,,ANY
318785,BLOCK,1,,<empty>,,,,1,,ANY
318789,BLOCK,1,,<empty>,,,,1,,ANY
318794,BLOCK,1,,<empty>,,,,1,,ANY
318798,BLOCK,1,,<empty>,,,,1,,ANY
318802,BLOCK,1,,<empty>,,,,1,,ANY
318805,BLOCK,1,,<empty>,,,,1,,ANY
318808,BLOCK,1,,<empty>,,,,1,,ANY
318811,BLOCK,1,,<empty>,,,,1,,ANY
318814,BLOCK,1,,<empty>,,,,1,,ANY
318818,BLOCK,1,,<empty>,,,,1,,ANY
318822,BLOCK,1,,<empty>,,,,1,,ANY
318826,BLOCK,1,,<empty>,,,,1,,ANY
318830,BLOCK,1,,<empty>,,,,1,,ANY
318834,BLOCK,1,,<empty>,,,,1,,ANY
318839,BLOCK,1,,<empty>,,,,1,,ANY
318842,BLOCK,1,,<empty>,,,,1,,ANY
318850,BLOCK,1,,<empty>,,,,1,,ANY
318857,BLOCK,1,,<empty>,,,,1,,ANY
318861,BLOCK,1,,<empty>,,,,1,,ANY
318869,BLOCK,1,,<empty>,,,,1,,ANY
318876,BLOCK,1,,<empty>,,,,1,,ANY
318881,BLOCK,1,,<empty>,,,,1,,ANY
318889,BLOCK,1,,<empty>,,,,1,,ANY
318897,BLOCK,1,,<empty>,,,,1,,ANY
318903,BLOCK,1,,<empty>,,,,1,,ANY
318907,BLOCK,1,,<empty>,,,,1,,ANY
318914,BLOCK,1,,<empty>,,,,1,,ANY
318918,BLOCK,1,,<empty>,,,,1,,ANY
318923,BLOCK,1,,<empty>,,,,1,,ANY
318929,BLOCK,1,,<empty>,,,,1,,ANY
318933,BLOCK,1,,<empty>,,,,1,,ANY
318937,BLOCK,1,,<empty>,,,,1,,ANY
318942,BLOCK,1,,<empty>,,,,1,,ANY
318948,BLOCK,1,,<empty>,,,,1,,ANY
318952,BLOCK,1,,<empty>,,,,1,,ANY
318956,BLOCK,1,,<empty>,,,,1,,ANY
318960,BLOCK,1,,<empty>,,,,1,,ANY
318964,BLOCK,1,,<empty>,,,,1,,ANY
318968,BLOCK,1,,<empty>,,,,1,,ANY
318976,BLOCK,1,,<empty>,,,,1,,ANY
318984,BLOCK,1,,<empty>,,,,1,,ANY
318992,BLOCK,1,,<empty>,,,,1,,ANY
318999,BLOCK,1,,<empty>,,,,1,,ANY
319005,BLOCK,1,,<empty>,,,,1,,ANY
319011,BLOCK,1,,<empty>,,,,1,,ANY
319016,BLOCK,1,,<empty>,,,,1,,ANY
319020,BLOCK,1,,<empty>,,,,1,,ANY
319025,BLOCK,1,,<empty>,,,,1,,ANY
319029,BLOCK,1,,<empty>,,,,1,,ANY
319033,BLOCK,1,,<empty>,,,,1,,ANY
319037,BLOCK,1,,<empty>,,,,1,,ANY
319042,BLOCK,1,,<empty>,,,,1,,ANY
319046,BLOCK,1,,<empty>,,,,1,,ANY
319051,BLOCK,1,,<empty>,,,,1,,ANY
319057,BLOCK,1,,<empty>,,,,1,,ANY
319066,BLOCK,1,,<empty>,,,,1,,ANY
319079,BLOCK,1,,<empty>,,,,1,,ANY
319085,BLOCK,1,,<empty>,,,,1,,ANY
319091,BLOCK,1,,<empty>,,,,1,,ANY
319097,BLOCK,1,,<empty>,,,,1,,ANY
319103,BLOCK,1,,<empty>,,,,1,,ANY
319111,BLOCK,1,,<empty>,,,,1,,ANY
319115,BLOCK,1,,<empty>,,,,1,,ANY
319119,BLOCK,1,,<empty>,,,,1,,ANY
319124,BLOCK,1,,<empty>,,,,1,,ANY
319129,BLOCK,1,,<empty>,,,,1,,ANY
319135,BLOCK,1,,<empty>,,,,1,,ANY
319139,BLOCK,1,,<empty>,,,,1,,ANY
319143,BLOCK,1,,<empty>,,,,1,,ANY
319149,BLOCK,1,,<empty>,,,,1,,ANY
319153,BLOCK,1,,<empty>,,,,1,,ANY
319157,BLOCK,1,,<empty>,,,,1,,ANY
319161,BLOCK,1,,<empty>,,,,1,,ANY
319166,BLOCK,1,,<empty>,,,,1,,ANY
319170,BLOCK,1,,<empty>,,,,1,,ANY
319175,BLOCK,1,,<empty>,,,,1,,ANY
319180,BLOCK,1,,<empty>,,,,1,,ANY
319185,BLOCK,1,,<empty>,,,,1,,ANY
319190,BLOCK,1,,<empty>,,,,1,,ANY
319194,BLOCK,1,,<empty>,,,,1,,ANY
319197,BLOCK,1,,<empty>,,,,1,,ANY
319201,BLOCK,1,,<empty>,,,,1,,ANY
319205,BLOCK,1,,<empty>,,,,1,,ANY
319211,BLOCK,1,,<empty>,,,,1,,ANY
319215,BLOCK,1,,<empty>,,,,1,,ANY
319219,BLOCK,1,,<empty>,,,,1,,ANY
319223,BLOCK,1,,<empty>,,,,1,,ANY
319227,BLOCK,1,,<empty>,,,,1,,ANY
319231,BLOCK,1,,<empty>,,,,1,,ANY
319235,BLOCK,1,,<empty>,,,,1,,ANY
319240,BLOCK,1,,<empty>,,,,1,,ANY
319244,BLOCK,1,,<empty>,,,,1,,ANY
319248,BLOCK,1,,<empty>,,,,1,,ANY
319253,BLOCK,1,,<empty>,,,,1,,ANY
319257,BLOCK,1,,<empty>,,,,1,,ANY
319264,BLOCK,1,,<empty>,,,,1,,ANY
319268,BLOCK,1,,<empty>,,,,1,,ANY
319272,BLOCK,1,,<empty>,,,,1,,ANY
319276,BLOCK,1,,<empty>,,,,1,,ANY
319285,BLOCK,1,,<empty>,,,,1,,ANY
319290,BLOCK,1,,<empty>,,,,1,,ANY
319295,BLOCK,1,,<empty>,,,,1,,ANY
319299,BLOCK,1,,<empty>,,,,1,,ANY
319303,BLOCK,1,,<empty>,,,,1,,ANY
319307,BLOCK,1,,<empty>,,,,1,,ANY
319312,BLOCK,1,,<empty>,,,,1,,ANY
319316,BLOCK,1,,<empty>,,,,1,,ANY
319320,BLOCK,1,,<empty>,,,,1,,ANY
319324,BLOCK,1,,<empty>,,,,1,,ANY
319329,BLOCK,1,,<empty>,,,,1,,ANY
319333,BLOCK,1,,<empty>,,,,1,,ANY
319337,BLOCK,1,,<empty>,,,,1,,ANY
319341,BLOCK,1,,<empty>,,,,1,,ANY
319351,BLOCK,1,,<empty>,,,,1,,ANY
319359,BLOCK,1,,<empty>,,,,1,,ANY
319366,BLOCK,1,,<empty>,,,,1,,ANY
319370,BLOCK,1,,<empty>,,,,1,,ANY
319374,BLOCK,1,,<empty>,,,,1,,ANY
319379,BLOCK,1,,<empty>,,,,1,,ANY
319383,BLOCK,1,,<empty>,,,,1,,ANY
319388,BLOCK,1,,<empty>,,,,1,,ANY
319394,BLOCK,1,,<empty>,,,,1,,ANY
319400,BLOCK,1,,<empty>,,,,1,,ANY
319404,BLOCK,1,,<empty>,,,,1,,ANY
319408,BLOCK,1,,<empty>,,,,1,,ANY
319412,BLOCK,1,,<empty>,,,,1,,ANY
319416,BLOCK,1,,<empty>,,,,1,,ANY
319420,BLOCK,1,,<empty>,,,,1,,ANY
319424,BLOCK,1,,<empty>,,,,1,,ANY
319428,BLOCK,1,,<empty>,,,,1,,ANY
319432,BLOCK,1,,<empty>,,,,1,,ANY
319436,BLOCK,1,,<empty>,,,,1,,ANY
319440,BLOCK,1,,<empty>,,,,1,,ANY
319444,BLOCK,1,,<empty>,,,,1,,ANY
319448,BLOCK,1,,<empty>,,,,1,,ANY
319452,BLOCK,1,,<empty>,,,,1,,ANY
319455,BLOCK,1,,<empty>,,,,1,,ANY
319459,BLOCK,1,,<empty>,,,,1,,ANY
319463,BLOCK,1,,<empty>,,,,1,,ANY
319467,BLOCK,1,,<empty>,,,,1,,ANY
319472,BLOCK,1,,<empty>,,,,1,,ANY
319477,BLOCK,1,,<empty>,,,,1,,ANY
319482,BLOCK,1,,<empty>,,,,1,,ANY
319487,BLOCK,1,,<empty>,,,,1,,ANY
319491,BLOCK,1,,<empty>,,,,1,,ANY
319495,BLOCK,1,,<empty>,,,,1,,ANY
319499,BLOCK,1,,<empty>,,,,1,,ANY
319503,BLOCK,1,,<empty>,,,,1,,ANY
319509,BLOCK,1,,<empty>,,,,1,,ANY
319513,BLOCK,1,,<empty>,,,,1,,ANY
319519,BLOCK,1,,<empty>,,,,1,,ANY
319523,BLOCK,1,,<empty>,,,,1,,ANY
319527,BLOCK,1,,<empty>,,,,1,,ANY
319531,BLOCK,1,,<empty>,,,,1,,ANY
319540,BLOCK,1,,<empty>,,,,1,,ANY
319547,BLOCK,1,,<empty>,,,,1,,ANY
319554,BLOCK,1,,<empty>,,,,1,,ANY
319561,BLOCK,1,,<empty>,,,,1,,ANY
319568,BLOCK,1,,<empty>,,,,1,,ANY
319575,BLOCK,1,,<empty>,,,,1,,ANY
319582,BLOCK,1,,<empty>,,,,1,,ANY
319589,BLOCK,1,,<empty>,,,,1,,ANY
319596,BLOCK,1,,<empty>,,,,1,,ANY
319603,BLOCK,1,,<empty>,,,,1,,ANY
319610,BLOCK,1,,<empty>,,,,1,,ANY
319617,BLOCK,1,,<empty>,,,,1,,ANY
319621,BLOCK,1,,<empty>,,,,1,,ANY
319625,BLOCK,1,,<empty>,,,,1,,ANY
319629,BLOCK,1,,<empty>,,,,1,,ANY
319633,BLOCK,1,,<empty>,,,,1,,ANY
319637,BLOCK,1,,<empty>,,,,1,,ANY
319641,BLOCK,1,,<empty>,,,,1,,ANY
319645,BLOCK,1,,<empty>,,,,1,,ANY
319649,BLOCK,1,,<empty>,,,,1,,ANY
319653,BLOCK,1,,<empty>,,,,1,,ANY
319657,BLOCK,1,,<empty>,,,,1,,ANY
319661,BLOCK,1,,<empty>,,,,1,,ANY
319665,BLOCK,1,,<empty>,,,,1,,ANY
319672,BLOCK,1,,<empty>,,,,1,,ANY
319676,BLOCK,1,,<empty>,,,,1,,ANY
319680,BLOCK,1,,<empty>,,,,1,,ANY
319684,BLOCK,1,,<empty>,,,,1,,ANY
319687,BLOCK,1,,<empty>,,,,1,,ANY
319692,BLOCK,1,,<empty>,,,,1,,ANY
319697,BLOCK,1,,<empty>,,,,1,,ANY
319701,BLOCK,1,,<empty>,,,,1,,ANY
319709,BLOCK,1,,<empty>,,,,1,,ANY
319713,BLOCK,1,,<empty>,,,,1,,ANY
319719,BLOCK,1,,<empty>,,,,1,,ANY
319723,BLOCK,1,,<empty>,,,,1,,ANY
319727,BLOCK,1,,<empty>,,,,1,,ANY
319731,BLOCK,1,,<empty>,,,,1,,ANY
319735,BLOCK,1,,<empty>,,,,1,,ANY
319739,BLOCK,1,,<empty>,,,,1,,ANY
319745,BLOCK,1,,<empty>,,,,1,,ANY
319749,BLOCK,1,,<empty>,,,,1,,ANY
319753,BLOCK,1,,<empty>,,,,1,,ANY
319757,BLOCK,1,,<empty>,,,,1,,ANY
319761,BLOCK,1,,<empty>,,,,1,,ANY
319765,BLOCK,1,,<empty>,,,,1,,ANY
319769,BLOCK,1,,<empty>,,,,1,,ANY
319773,BLOCK,1,,<empty>,,,,1,,ANY
319778,BLOCK,1,,<empty>,,,,1,,ANY
319782,BLOCK,1,,<empty>,,,,1,,ANY
319786,BLOCK,1,,<empty>,,,,1,,ANY
319791,BLOCK,1,,<empty>,,,,1,,ANY
319796,BLOCK,1,,<empty>,,,,1,,ANY
319799,BLOCK,1,,<empty>,,,,1,,ANY
319803,BLOCK,1,,<empty>,,,,1,,ANY
319808,BLOCK,1,,<empty>,,,,1,,ANY
319812,BLOCK,1,,<empty>,,,,1,,ANY
319816,BLOCK,1,,<empty>,,,,1,,ANY
319820,BLOCK,1,,<empty>,,,,1,,ANY
319824,BLOCK,1,,<empty>,,,,1,,ANY
319828,BLOCK,1,,<empty>,,,,1,,ANY
319832,BLOCK,1,,<empty>,,,,1,,ANY
319837,BLOCK,1,,<empty>,,,,1,,ANY
319840,BLOCK,1,,<empty>,,,,1,,ANY
319844,BLOCK,1,,<empty>,,,,1,,ANY
319849,BLOCK,1,,<empty>,,,,1,,ANY
319854,BLOCK,1,,<empty>,,,,1,,ANY
319858,BLOCK,1,,<empty>,,,,1,,ANY
319866,BLOCK,1,,<empty>,,,,1,,ANY
319871,BLOCK,1,,<empty>,,,,1,,ANY
319878,BLOCK,1,,<empty>,,,,1,,ANY
319883,BLOCK,1,,<empty>,,,,1,,ANY
319891,BLOCK,1,,<empty>,,,,1,,ANY
319897,BLOCK,1,,<empty>,,,,1,,ANY
319901,BLOCK,1,,<empty>,,,,1,,ANY
319907,BLOCK,1,,<empty>,,,,1,,ANY
319911,BLOCK,1,,<empty>,,,,1,,ANY
319914,BLOCK,1,,<empty>,,,,1,,ANY
319919,BLOCK,1,,<empty>,,,,1,,ANY
319924,BLOCK,1,,<empty>,,,,1,,ANY
319929,BLOCK,1,,<empty>,,,,1,,ANY
319935,BLOCK,1,,<empty>,,,,1,,ANY
319940,BLOCK,1,,<empty>,,,,1,,ANY
319945,BLOCK,1,,<empty>,,,,1,,ANY
319951,BLOCK,1,,<empty>,,,,1,,ANY
319957,BLOCK,1,,<empty>,,,,1,,ANY
319961,BLOCK,1,,<empty>,,,,1,,ANY
319965,BLOCK,1,,<empty>,,,,1,,ANY
319973,BLOCK,1,,<empty>,,,,1,,ANY
319981,BLOCK,1,,<empty>,,,,1,,ANY
319985,BLOCK,1,,<empty>,,,,1,,ANY
319989,BLOCK,1,,<empty>,,,,1,,ANY
319996,BLOCK,1,,<empty>,,,,1,,ANY
319999,BLOCK,1,,<empty>,,,,1,,ANY
320006,BLOCK,1,,<empty>,,,,1,,ANY
320011,BLOCK,1,,<empty>,,,,1,,ANY
320015,BLOCK,1,,<empty>,,,,1,,ANY
320019,BLOCK,1,,<empty>,,,,1,,ANY
320023,BLOCK,1,,<empty>,,,,1,,ANY
320027,BLOCK,1,,<empty>,,,,1,,ANY
320031,BLOCK,1,,<empty>,,,,1,,ANY
320035,BLOCK,1,,<empty>,,,,1,,ANY
320040,BLOCK,1,,<empty>,,,,1,,ANY
320045,BLOCK,1,,<empty>,,,,1,,ANY
320049,BLOCK,1,,<empty>,,,,1,,ANY
320055,BLOCK,1,,<empty>,,,,1,,ANY
320061,BLOCK,1,,<empty>,,,,1,,ANY
320065,BLOCK,1,,<empty>,,,,1,,ANY
320071,BLOCK,1,,<empty>,,,,1,,ANY
320075,BLOCK,1,,<empty>,,,,1,,ANY
320079,BLOCK,1,,<empty>,,,,1,,ANY
320085,BLOCK,1,,<empty>,,,,1,,ANY
320090,BLOCK,1,,<empty>,,,,1,,ANY
320093,BLOCK,1,,<empty>,,,,1,,ANY
320097,BLOCK,1,,<empty>,,,,1,,ANY
320102,BLOCK,1,,<empty>,,,,1,,ANY
320106,BLOCK,1,,<empty>,,,,1,,ANY
320110,BLOCK,1,,<empty>,,,,1,,ANY
320114,BLOCK,1,,<empty>,,,,1,,ANY
320118,BLOCK,1,,<empty>,,,,1,,ANY
320122,BLOCK,1,,<empty>,,,,1,,ANY
320126,BLOCK,1,,<empty>,,,,1,,ANY
320129,BLOCK,1,,<empty>,,,,1,,ANY
320134,BLOCK,1,,<empty>,,,,1,,ANY
320138,BLOCK,1,,<empty>,,,,1,,ANY
320142,BLOCK,1,,<empty>,,,,1,,ANY
320145,BLOCK,1,,<empty>,,,,1,,ANY
320149,BLOCK,1,,<empty>,,,,1,,ANY
320153,BLOCK,1,,<empty>,,,,1,,ANY
320158,BLOCK,1,,<empty>,,,,1,,ANY
320164,BLOCK,1,,<empty>,,,,1,,ANY
320169,BLOCK,1,,<empty>,,,,1,,ANY
320174,BLOCK,1,,<empty>,,,,1,,ANY
320178,BLOCK,1,,<empty>,,,,1,,ANY
320183,BLOCK,1,,<empty>,,,,1,,ANY
320188,BLOCK,1,,<empty>,,,,1,,ANY
320195,BLOCK,1,,<empty>,,,,1,,ANY
320199,BLOCK,1,,<empty>,,,,1,,ANY
320202,BLOCK,1,,<empty>,,,,1,,ANY
320206,BLOCK,1,,<empty>,,,,1,,ANY
320210,BLOCK,1,,<empty>,,,,1,,ANY
320214,BLOCK,1,,<empty>,,,,1,,ANY
320218,BLOCK,1,,<empty>,,,,1,,ANY
320222,BLOCK,1,,<empty>,,,,1,,ANY
320226,BLOCK,1,,<empty>,,,,1,,ANY
320232,BLOCK,1,,<empty>,,,,1,,ANY
320237,BLOCK,1,,<empty>,,,,1,,ANY
320240,BLOCK,1,,<empty>,,,,1,,ANY
320244,BLOCK,1,,<empty>,,,,1,,ANY
320247,BLOCK,1,,<empty>,,,,1,,ANY
320253,BLOCK,1,,<empty>,,,,1,,ANY
320257,BLOCK,1,,<empty>,,,,1,,ANY
320261,BLOCK,1,,<empty>,,,,1,,ANY
320266,BLOCK,1,,<empty>,,,,1,,ANY
320270,BLOCK,1,,<empty>,,,,1,,ANY
320274,BLOCK,1,,<empty>,,,,1,,ANY
320278,BLOCK,1,,<empty>,,,,1,,ANY
320282,BLOCK,1,,<empty>,,,,1,,ANY
320286,BLOCK,1,,<empty>,,,,1,,ANY
320289,BLOCK,1,,<empty>,,,,1,,ANY
320299,BLOCK,1,,<empty>,,,,1,,ANY
320304,BLOCK,1,,<empty>,,,,1,,ANY
320308,BLOCK,1,,<empty>,,,,1,,ANY
320315,BLOCK,1,,<empty>,,,,1,,ANY
320322,BLOCK,1,,<empty>,,,,1,,ANY
320325,BLOCK,1,,<empty>,,,,1,,ANY
320329,BLOCK,1,,<empty>,,,,1,,ANY
320332,BLOCK,1,,<empty>,,,,1,,ANY
320338,BLOCK,1,,<empty>,,,,1,,ANY
320343,BLOCK,1,,<empty>,,,,1,,ANY
320348,BLOCK,1,,<empty>,,,,1,,ANY
320353,BLOCK,1,,<empty>,,,,1,,ANY
320357,BLOCK,1,,<empty>,,,,1,,ANY
320364,BLOCK,1,,<empty>,,,,1,,ANY
320368,BLOCK,1,,<empty>,,,,1,,ANY
320372,BLOCK,1,,<empty>,,,,1,,ANY
320376,BLOCK,1,,<empty>,,,,1,,ANY
320381,BLOCK,1,,<empty>,,,,1,,ANY
320384,BLOCK,1,,<empty>,,,,1,,ANY
320388,BLOCK,1,,<empty>,,,,1,,ANY
320393,BLOCK,1,,<empty>,,,,1,,ANY
320397,BLOCK,1,,<empty>,,,,1,,ANY
320401,BLOCK,1,,<empty>,,,,1,,ANY
320404,BLOCK,1,,<empty>,,,,1,,ANY
320408,BLOCK,1,,<empty>,,,,1,,ANY
320411,BLOCK,1,,<empty>,,,,1,,ANY
320414,BLOCK,1,,<empty>,,,,1,,ANY
320418,BLOCK,1,,<empty>,,,,1,,ANY
320422,BLOCK,1,,<empty>,,,,1,,ANY
320426,BLOCK,1,,<empty>,,,,1,,ANY
320430,BLOCK,1,,<empty>,,,,1,,ANY
320434,BLOCK,1,,<empty>,,,,1,,ANY
320438,BLOCK,1,,<empty>,,,,1,,ANY
320443,BLOCK,1,,<empty>,,,,1,,ANY
320447,BLOCK,1,,<empty>,,,,1,,ANY
320453,BLOCK,1,,<empty>,,,,1,,ANY
320461,BLOCK,1,,<empty>,,,,1,,ANY
320466,BLOCK,1,,<empty>,,,,1,,ANY
320470,BLOCK,1,,<empty>,,,,1,,ANY
320474,BLOCK,1,,<empty>,,,,1,,ANY
320479,BLOCK,1,,<empty>,,,,1,,ANY
320484,BLOCK,1,,<empty>,,,,1,,ANY
320489,BLOCK,1,,<empty>,,,,1,,ANY
320494,BLOCK,1,,<empty>,,,,1,,ANY
320500,BLOCK,1,,<empty>,,,,1,,ANY
320505,BLOCK,1,,<empty>,,,,1,,ANY
320510,BLOCK,1,,<empty>,,,,1,,ANY
320518,BLOCK,1,,<empty>,,,,1,,ANY
320522,BLOCK,1,,<empty>,,,,1,,ANY
320530,BLOCK,1,,<empty>,,,,1,,ANY
320534,BLOCK,1,,<empty>,,,,1,,ANY
320539,BLOCK,1,,<empty>,,,,1,,ANY
320543,BLOCK,1,,<empty>,,,,1,,ANY
320547,BLOCK,1,,<empty>,,,,1,,ANY
320551,BLOCK,1,,<empty>,,,,1,,ANY
320555,BLOCK,1,,<empty>,,,,1,,ANY
320559,BLOCK,1,,<empty>,,,,1,,ANY
320565,BLOCK,1,,<empty>,,,,1,,ANY
320569,BLOCK,1,,<empty>,,,,1,,ANY
320575,BLOCK,1,,<empty>,,,,1,,ANY
320579,BLOCK,1,,<empty>,,,,1,,ANY
320583,BLOCK,1,,<empty>,,,,1,,ANY
320587,BLOCK,1,,<empty>,,,,1,,ANY
320591,BLOCK,1,,<empty>,,,,1,,ANY
320597,BLOCK,1,,<empty>,,,,1,,ANY
320604,BLOCK,1,,<empty>,,,,1,,ANY
320610,BLOCK,1,,<empty>,,,,1,,ANY
320614,BLOCK,1,,<empty>,,,,1,,ANY
320618,BLOCK,1,,<empty>,,,,1,,ANY
320624,BLOCK,1,,<empty>,,,,1,,ANY
320627,BLOCK,1,,<empty>,,,,1,,ANY
320631,BLOCK,1,,<empty>,,,,1,,ANY
320636,BLOCK,1,,<empty>,,,,1,,ANY
320640,BLOCK,1,,<empty>,,,,1,,ANY
320646,BLOCK,1,,<empty>,,,,1,,ANY
320653,BLOCK,1,,<empty>,,,,1,,ANY
320656,BLOCK,1,,<empty>,,,,1,,ANY
320661,BLOCK,1,,<empty>,,,,1,,ANY
320667,BLOCK,1,,<empty>,,,,1,,ANY
320671,BLOCK,1,,<empty>,,,,1,,ANY
320676,BLOCK,1,,<empty>,,,,1,,ANY
320679,BLOCK,1,,<empty>,,,,1,,ANY
320684,BLOCK,1,,<empty>,,,,1,,ANY
320688,BLOCK,1,,<empty>,,,,1,,ANY
320692,BLOCK,1,,<empty>,,,,1,,ANY
320695,BLOCK,1,,<empty>,,,,1,,ANY
320698,BLOCK,1,,<empty>,,,,1,,ANY
320703,BLOCK,1,,<empty>,,,,1,,ANY
320710,BLOCK,1,,<empty>,,,,1,,ANY
320713,BLOCK,1,,<empty>,,,,1,,ANY
320718,BLOCK,1,,<empty>,,,,1,,ANY
320723,BLOCK,1,,<empty>,,,,1,,ANY
320726,BLOCK,1,,<empty>,,,,1,,ANY
320729,BLOCK,1,,<empty>,,,,1,,ANY
320732,BLOCK,1,,<empty>,,,,1,,ANY
320739,BLOCK,1,,<empty>,,,,1,,ANY
320743,BLOCK,1,,<empty>,,,,1,,ANY
320750,BLOCK,1,,<empty>,,,,1,,ANY
320754,BLOCK,1,,<empty>,,,,1,,ANY
320760,BLOCK,1,,<empty>,,,,1,,ANY
320764,BLOCK,1,,<empty>,,,,1,,ANY
320770,BLOCK,1,,<empty>,,,,1,,ANY
320774,BLOCK,1,,<empty>,,,,1,,ANY
320781,BLOCK,1,,<empty>,,,,1,,ANY
320785,BLOCK,1,,<empty>,,,,1,,ANY
320789,BLOCK,1,,<empty>,,,,1,,ANY
320793,BLOCK,1,,<empty>,,,,1,,ANY
320801,BLOCK,1,,<empty>,,,,1,,ANY
320804,BLOCK,1,,<empty>,,,,1,,ANY
320807,BLOCK,1,,<empty>,,,,1,,ANY
320810,BLOCK,1,,<empty>,,,,1,,ANY
320813,BLOCK,1,,<empty>,,,,1,,ANY
320818,BLOCK,1,,<empty>,,,,1,,ANY
320823,BLOCK,1,,<empty>,,,,1,,ANY
320827,BLOCK,1,,<empty>,,,,1,,ANY
320831,BLOCK,1,,<empty>,,,,1,,ANY
320841,BLOCK,1,,<empty>,,,,1,,ANY
320846,BLOCK,1,,<empty>,,,,1,,ANY
320849,BLOCK,1,,<empty>,,,,1,,ANY
320854,BLOCK,1,,<empty>,,,,1,,ANY
320859,BLOCK,1,,<empty>,,,,1,,ANY
320863,BLOCK,1,,<empty>,,,,1,,ANY
320867,BLOCK,1,,<empty>,,,,1,,ANY
320871,BLOCK,1,,<empty>,,,,1,,ANY
320875,BLOCK,1,,<empty>,,,,1,,ANY
320880,BLOCK,1,,<empty>,,,,1,,ANY
320884,BLOCK,1,,<empty>,,,,1,,ANY
320888,BLOCK,1,,<empty>,,,,1,,ANY
320893,BLOCK,1,,<empty>,,,,1,,ANY
320897,BLOCK,1,,<empty>,,,,1,,ANY
320901,BLOCK,1,,<empty>,,,,1,,ANY
320906,BLOCK,1,,<empty>,,,,1,,ANY
320910,BLOCK,1,,<empty>,,,,1,,ANY
320914,BLOCK,1,,<empty>,,,,1,,ANY
320918,BLOCK,1,,<empty>,,,,1,,ANY
320921,BLOCK,1,,<empty>,,,,1,,ANY
320925,BLOCK,1,,<empty>,,,,1,,ANY
320929,BLOCK,1,,<empty>,,,,1,,ANY
320937,BLOCK,1,,<empty>,,,,1,,ANY
320944,BLOCK,1,,<empty>,,,,1,,ANY
320949,BLOCK,1,,<empty>,,,,1,,ANY
320953,BLOCK,1,,<empty>,,,,1,,ANY
320959,BLOCK,1,,<empty>,,,,1,,ANY
320963,BLOCK,1,,<empty>,,,,1,,ANY
320968,BLOCK,1,,<empty>,,,,1,,ANY
320973,BLOCK,1,,<empty>,,,,1,,ANY
320977,BLOCK,1,,<empty>,,,,1,,ANY
320982,BLOCK,1,,<empty>,,,,1,,ANY
320986,BLOCK,1,,<empty>,,,,1,,ANY
320993,BLOCK,1,,<empty>,,,,1,,ANY
320997,BLOCK,1,,<empty>,,,,1,,ANY
321001,BLOCK,1,,<empty>,,,,1,,ANY
321007,BLOCK,1,,<empty>,,,,1,,ANY
321012,BLOCK,1,,<empty>,,,,1,,ANY
321018,BLOCK,1,,<empty>,,,,1,,ANY
321023,BLOCK,1,,<empty>,,,,1,,ANY
321028,BLOCK,1,,<empty>,,,,1,,ANY
321033,BLOCK,1,,<empty>,,,,1,,ANY
321037,BLOCK,1,,<empty>,,,,1,,ANY
321041,BLOCK,1,,<empty>,,,,1,,ANY
321047,BLOCK,1,,<empty>,,,,1,,ANY
321050,BLOCK,1,,<empty>,,,,1,,ANY
321057,BLOCK,1,,<empty>,,,,1,,ANY
321061,BLOCK,1,,<empty>,,,,1,,ANY
321066,BLOCK,1,,<empty>,,,,1,,ANY
321070,BLOCK,1,,<empty>,,,,1,,ANY
321074,BLOCK,1,,<empty>,,,,1,,ANY
321080,BLOCK,1,,<empty>,,,,1,,ANY
321086,BLOCK,1,,<empty>,,,,1,,ANY
321091,BLOCK,1,,<empty>,,,,1,,ANY
321097,BLOCK,1,,<empty>,,,,1,,ANY
321101,BLOCK,1,,<empty>,,,,1,,ANY
321106,BLOCK,1,,<empty>,,,,1,,ANY
321109,BLOCK,1,,<empty>,,,,1,,ANY
321113,BLOCK,1,,<empty>,,,,1,,ANY
321119,BLOCK,1,,<empty>,,,,1,,ANY
321125,BLOCK,1,,<empty>,,,,1,,ANY
321130,BLOCK,1,,<empty>,,,,1,,ANY
321136,BLOCK,1,,<empty>,,,,1,,ANY
321143,BLOCK,1,,<empty>,,,,1,,ANY
321147,BLOCK,1,,<empty>,,,,1,,ANY
321152,BLOCK,1,,<empty>,,,,1,,ANY
321156,BLOCK,1,,<empty>,,,,1,,ANY
321160,BLOCK,1,,<empty>,,,,1,,ANY
321166,BLOCK,1,,<empty>,,,,1,,ANY
321173,BLOCK,1,,<empty>,,,,1,,ANY
321177,BLOCK,1,,<empty>,,,,1,,ANY
321182,BLOCK,1,,<empty>,,,,1,,ANY
321187,BLOCK,1,,<empty>,,,,1,,ANY
321191,BLOCK,1,,<empty>,,,,1,,ANY
321199,BLOCK,1,,<empty>,,,,1,,ANY
321203,BLOCK,1,,<empty>,,,,1,,ANY
321207,BLOCK,1,,<empty>,,,,1,,ANY
321211,BLOCK,1,,<empty>,,,,1,,ANY
321214,BLOCK,1,,<empty>,,,,1,,ANY
321218,BLOCK,1,,<empty>,,,,1,,ANY
321222,BLOCK,1,,<empty>,,,,1,,ANY
321226,BLOCK,1,,<empty>,,,,1,,ANY
321229,BLOCK,1,,<empty>,,,,1,,ANY
321238,BLOCK,1,,<empty>,,,,1,,ANY
321242,BLOCK,1,,<empty>,,,,1,,ANY
321247,BLOCK,1,,<empty>,,,,1,,ANY
321251,BLOCK,1,,<empty>,,,,1,,ANY
321254,BLOCK,1,,<empty>,,,,1,,ANY
321261,BLOCK,1,,<empty>,,,,1,,ANY
321267,BLOCK,1,,<empty>,,,,1,,ANY
321273,BLOCK,1,,<empty>,,,,1,,ANY
321279,BLOCK,1,,<empty>,,,,1,,ANY
321284,BLOCK,1,,<empty>,,,,1,,ANY
321290,BLOCK,1,,<empty>,,,,1,,ANY
321296,BLOCK,1,,<empty>,,,,1,,ANY
321302,BLOCK,1,,<empty>,,,,1,,ANY
321308,BLOCK,1,,<empty>,,,,1,,ANY
321314,BLOCK,1,,<empty>,,,,1,,ANY
321317,BLOCK,1,,<empty>,,,,1,,ANY
321322,BLOCK,1,,<empty>,,,,1,,ANY
321327,BLOCK,1,,<empty>,,,,1,,ANY
321333,BLOCK,1,,<empty>,,,,1,,ANY
321339,BLOCK,1,,<empty>,,,,1,,ANY
321345,BLOCK,1,,<empty>,,,,1,,ANY
321350,BLOCK,1,,<empty>,,,,1,,ANY
321356,BLOCK,1,,<empty>,,,,1,,ANY
321362,BLOCK,1,,<empty>,,,,1,,ANY
321368,BLOCK,1,,<empty>,,,,1,,ANY
321372,BLOCK,1,,<empty>,,,,1,,ANY
321376,BLOCK,1,,<empty>,,,,1,,ANY
321383,BLOCK,1,,<empty>,,,,1,,ANY
321388,BLOCK,1,,<empty>,,,,1,,ANY
321395,BLOCK,1,,<empty>,,,,1,,ANY
321404,BLOCK,1,,<empty>,,,,1,,ANY
321409,BLOCK,1,,<empty>,,,,1,,ANY
321414,BLOCK,1,,<empty>,,,,1,,ANY
321418,BLOCK,1,,<empty>,,,,1,,ANY
321422,BLOCK,1,,<empty>,,,,1,,ANY
321428,BLOCK,1,,<empty>,,,,1,,ANY
321435,BLOCK,1,,<empty>,,,,1,,ANY
321440,BLOCK,1,,<empty>,,,,1,,ANY
321445,BLOCK,1,,<empty>,,,,1,,ANY
321449,BLOCK,1,,<empty>,,,,1,,ANY
321455,BLOCK,1,,<empty>,,,,1,,ANY
321461,BLOCK,1,,<empty>,,,,1,,ANY
321467,BLOCK,1,,<empty>,,,,1,,ANY
321471,BLOCK,1,,<empty>,,,,1,,ANY
321476,BLOCK,1,,<empty>,,,,1,,ANY
321480,BLOCK,1,,<empty>,,,,1,,ANY
321487,BLOCK,1,,<empty>,,,,1,,ANY
321491,BLOCK,1,,<empty>,,,,1,,ANY
321495,BLOCK,1,,<empty>,,,,1,,ANY
321503,BLOCK,1,,<empty>,,,,1,,ANY
321507,BLOCK,1,,<empty>,,,,1,,ANY
321510,BLOCK,1,,<empty>,,,,1,,ANY
321514,BLOCK,1,,<empty>,,,,1,,ANY
321518,BLOCK,1,,<empty>,,,,1,,ANY
321523,BLOCK,1,,<empty>,,,,1,,ANY
321527,BLOCK,1,,<empty>,,,,1,,ANY
321531,BLOCK,1,,<empty>,,,,1,,ANY
321536,BLOCK,1,,<empty>,,,,1,,ANY
321541,BLOCK,1,,<empty>,,,,1,,ANY
321545,BLOCK,1,,<empty>,,,,1,,ANY
321556,BLOCK,1,,<empty>,,,,1,,ANY
321559,BLOCK,1,,<empty>,,,,1,,ANY
321565,BLOCK,1,,<empty>,,,,1,,ANY
321569,BLOCK,1,,<empty>,,,,1,,ANY
321576,BLOCK,1,,<empty>,,,,1,,ANY
321582,BLOCK,1,,<empty>,,,,1,,ANY
321589,BLOCK,1,,<empty>,,,,1,,ANY
321593,BLOCK,1,,<empty>,,,,1,,ANY
321600,BLOCK,1,,<empty>,,,,1,,ANY
321604,BLOCK,1,,<empty>,,,,1,,ANY
321609,BLOCK,1,,<empty>,,,,1,,ANY
321614,BLOCK,1,,<empty>,,,,1,,ANY
321620,BLOCK,1,,<empty>,,,,1,,ANY
321624,BLOCK,1,,<empty>,,,,1,,ANY
321629,BLOCK,1,,<empty>,,,,1,,ANY
321634,BLOCK,1,,<empty>,,,,1,,ANY
321641,BLOCK,1,,<empty>,,,,1,,ANY
321645,BLOCK,1,,<empty>,,,,1,,ANY
321649,BLOCK,1,,<empty>,,,,1,,ANY
321654,BLOCK,1,,<empty>,,,,1,,ANY
321659,BLOCK,1,,<empty>,,,,1,,ANY
321665,BLOCK,1,,<empty>,,,,1,,ANY
321669,BLOCK,1,,<empty>,,,,1,,ANY
321673,BLOCK,1,,<empty>,,,,1,,ANY
321677,BLOCK,1,,<empty>,,,,1,,ANY
321681,BLOCK,1,,<empty>,,,,1,,ANY
321685,BLOCK,1,,<empty>,,,,1,,ANY
321691,BLOCK,1,,<empty>,,,,1,,ANY
321695,BLOCK,1,,<empty>,,,,1,,ANY
321702,BLOCK,1,,<empty>,,,,1,,ANY
321705,BLOCK,1,,<empty>,,,,1,,ANY
321710,BLOCK,1,,<empty>,,,,1,,ANY
321715,BLOCK,1,,<empty>,,,,1,,ANY
321719,BLOCK,1,,<empty>,,,,1,,ANY
321730,BLOCK,1,,<empty>,,,,1,,ANY
321741,BLOCK,1,,<empty>,,,,1,,ANY
321746,BLOCK,1,,<empty>,,,,1,,ANY
321751,BLOCK,1,,<empty>,,,,1,,ANY
321754,BLOCK,1,,<empty>,,,,1,,ANY
321759,BLOCK,1,,<empty>,,,,1,,ANY
321763,BLOCK,1,,<empty>,,,,1,,ANY
321768,BLOCK,1,,<empty>,,,,1,,ANY
321773,BLOCK,1,,<empty>,,,,1,,ANY
321777,BLOCK,1,,<empty>,,,,1,,ANY
321783,BLOCK,1,,<empty>,,,,1,,ANY
321787,BLOCK,1,,<empty>,,,,1,,ANY
321795,BLOCK,1,,<empty>,,,,1,,ANY
321800,BLOCK,1,,<empty>,,,,1,,ANY
321807,BLOCK,1,,<empty>,,,,1,,ANY
321811,BLOCK,1,,<empty>,,,,1,,ANY
321815,BLOCK,1,,<empty>,,,,1,,ANY
321819,BLOCK,1,,<empty>,,,,1,,ANY
321826,BLOCK,1,,<empty>,,,,1,,ANY
321831,BLOCK,1,,<empty>,,,,1,,ANY
321836,BLOCK,1,,<empty>,,,,1,,ANY
321840,BLOCK,1,,<empty>,,,,1,,ANY
321844,BLOCK,1,,<empty>,,,,1,,ANY
321850,BLOCK,1,,<empty>,,,,1,,ANY
321854,BLOCK,1,,<empty>,,,,1,,ANY
321860,BLOCK,1,,<empty>,,,,1,,ANY
321864,BLOCK,1,,<empty>,,,,1,,ANY
321870,BLOCK,1,,<empty>,,,,1,,ANY
321874,BLOCK,1,,<empty>,,,,1,,ANY
321878,BLOCK,1,,<empty>,,,,1,,ANY
321882,BLOCK,1,,<empty>,,,,1,,ANY
321886,BLOCK,1,,<empty>,,,,1,,ANY
321890,BLOCK,1,,<empty>,,,,1,,ANY
321894,BLOCK,1,,<empty>,,,,1,,ANY
321898,BLOCK,1,,<empty>,,,,1,,ANY
321902,BLOCK,1,,<empty>,,,,1,,ANY
321908,BLOCK,1,,<empty>,,,,1,,ANY
321913,BLOCK,1,,<empty>,,,,1,,ANY
321920,BLOCK,1,,<empty>,,,,1,,ANY
321926,BLOCK,1,,<empty>,,,,1,,ANY
321933,BLOCK,1,,<empty>,,,,1,,ANY
321938,BLOCK,1,,<empty>,,,,1,,ANY
321945,BLOCK,1,,<empty>,,,,1,,ANY
321952,BLOCK,1,,<empty>,,,,1,,ANY
321958,BLOCK,1,,<empty>,,,,1,,ANY
321963,BLOCK,1,,<empty>,,,,1,,ANY
321968,BLOCK,1,,<empty>,,,,1,,ANY
321977,BLOCK,1,,<empty>,,,,1,,ANY
321981,BLOCK,1,,<empty>,,,,1,,ANY
321985,BLOCK,1,,<empty>,,,,1,,ANY
321989,BLOCK,1,,<empty>,,,,1,,ANY
321993,BLOCK,1,,<empty>,,,,1,,ANY
321997,BLOCK,1,,<empty>,,,,1,,ANY
322001,BLOCK,1,,<empty>,,,,1,,ANY
322012,BLOCK,1,,<empty>,,,,1,,ANY
322018,BLOCK,1,,<empty>,,,,1,,ANY
322023,BLOCK,1,,<empty>,,,,1,,ANY
322027,BLOCK,1,,<empty>,,,,1,,ANY
322033,BLOCK,1,,<empty>,,,,1,,ANY
322038,BLOCK,1,,<empty>,,,,1,,ANY
322042,BLOCK,1,,<empty>,,,,1,,ANY
322046,BLOCK,1,,<empty>,,,,1,,ANY
322050,BLOCK,1,,<empty>,,,,1,,ANY
322054,BLOCK,1,,<empty>,,,,1,,ANY
322059,BLOCK,1,,<empty>,,,,1,,ANY
322063,BLOCK,1,,<empty>,,,,1,,ANY
322067,BLOCK,1,,<empty>,,,,1,,ANY
322075,BLOCK,1,,<empty>,,,,1,,ANY
322081,BLOCK,1,,<empty>,,,,1,,ANY
322086,BLOCK,1,,<empty>,,,,1,,ANY
322092,BLOCK,1,,<empty>,,,,1,,ANY
322098,BLOCK,1,,<empty>,,,,1,,ANY
322104,BLOCK,1,,<empty>,,,,1,,ANY
322109,BLOCK,1,,<empty>,,,,1,,ANY
322113,BLOCK,1,,<empty>,,,,1,,ANY
322118,BLOCK,1,,<empty>,,,,1,,ANY
322123,BLOCK,1,,<empty>,,,,1,,ANY
322128,BLOCK,1,,<empty>,,,,1,,ANY
322131,BLOCK,1,,<empty>,,,,1,,ANY
322134,BLOCK,1,,<empty>,,,,1,,ANY
322137,BLOCK,1,,<empty>,,,,1,,ANY
322140,BLOCK,1,,<empty>,,,,1,,ANY
322143,BLOCK,1,,<empty>,,,,1,,ANY
322147,BLOCK,1,,<empty>,,,,1,,ANY
322151,BLOCK,1,,<empty>,,,,1,,ANY
322157,BLOCK,1,,<empty>,,,,1,,ANY
322161,BLOCK,1,,<empty>,,,,1,,ANY
322166,BLOCK,1,,<empty>,,,,1,,ANY
322173,BLOCK,1,,<empty>,,,,1,,ANY
322177,BLOCK,1,,<empty>,,,,1,,ANY
322180,BLOCK,1,,<empty>,,,,1,,ANY
322185,BLOCK,1,,<empty>,,,,1,,ANY
322188,BLOCK,1,,<empty>,,,,1,,ANY
322192,BLOCK,1,,<empty>,,,,1,,ANY
322195,BLOCK,1,,<empty>,,,,1,,ANY
322198,BLOCK,1,,<empty>,,,,1,,ANY
322209,BLOCK,1,,<empty>,,,,1,,ANY
322216,BLOCK,1,,<empty>,,,,1,,ANY
322219,BLOCK,1,,<empty>,,,,1,,ANY
322230,BLOCK,1,,<empty>,,,,1,,ANY
322235,BLOCK,1,,<empty>,,,,1,,ANY
322240,BLOCK,1,,<empty>,,,,1,,ANY
322247,BLOCK,1,,<empty>,,,,1,,ANY
322260,BLOCK,1,,<empty>,,,,1,,ANY
322265,BLOCK,1,,<empty>,,,,1,,ANY
322269,BLOCK,1,,<empty>,,,,1,,ANY
322273,BLOCK,1,,<empty>,,,,1,,ANY
322277,BLOCK,1,,<empty>,,,,1,,ANY
322282,BLOCK,1,,<empty>,,,,1,,ANY
322287,BLOCK,1,,<empty>,,,,1,,ANY
322291,BLOCK,1,,<empty>,,,,1,,ANY
322302,BLOCK,1,,<empty>,,,,1,,ANY
322307,BLOCK,1,,<empty>,,,,1,,ANY
322316,BLOCK,1,,<empty>,,,,1,,ANY
322324,BLOCK,1,,<empty>,,,,1,,ANY
322328,BLOCK,1,,<empty>,,,,1,,ANY
322339,BLOCK,1,,<empty>,,,,1,,ANY
322350,BLOCK,1,,<empty>,,,,1,,ANY
322354,BLOCK,1,,<empty>,,,,1,,ANY
322360,BLOCK,1,,<empty>,,,,1,,ANY
322366,BLOCK,1,,<empty>,,,,1,,ANY
322371,BLOCK,1,,<empty>,,,,1,,ANY
322375,BLOCK,1,,<empty>,,,,1,,ANY
322386,BLOCK,1,,<empty>,,,,1,,ANY
322397,BLOCK,1,,<empty>,,,,1,,ANY
322402,BLOCK,1,,<empty>,,,,1,,ANY
322407,BLOCK,1,,<empty>,,,,1,,ANY
322411,BLOCK,1,,<empty>,,,,1,,ANY
322414,BLOCK,1,,<empty>,,,,1,,ANY
322419,BLOCK,1,,<empty>,,,,1,,ANY
322423,BLOCK,1,,<empty>,,,,1,,ANY
322426,BLOCK,1,,<empty>,,,,1,,ANY
322431,BLOCK,1,,<empty>,,,,1,,ANY
322436,BLOCK,1,,<empty>,,,,1,,ANY
322442,BLOCK,1,,<empty>,,,,1,,ANY
322446,BLOCK,1,,<empty>,,,,1,,ANY
322451,BLOCK,1,,<empty>,,,,1,,ANY
322455,BLOCK,1,,<empty>,,,,1,,ANY
322459,BLOCK,1,,<empty>,,,,1,,ANY
322462,BLOCK,1,,<empty>,,,,1,,ANY
322466,BLOCK,1,,<empty>,,,,1,,ANY
322471,BLOCK,1,,<empty>,,,,1,,ANY
322476,BLOCK,1,,<empty>,,,,1,,ANY
322481,BLOCK,1,,<empty>,,,,1,,ANY
322485,BLOCK,1,,<empty>,,,,1,,ANY
322490,BLOCK,1,,<empty>,,,,1,,ANY
322494,BLOCK,1,,<empty>,,,,1,,ANY
322498,BLOCK,1,,<empty>,,,,1,,ANY
322503,BLOCK,1,,<empty>,,,,1,,ANY
322509,BLOCK,1,,<empty>,,,,1,,ANY
322513,BLOCK,1,,<empty>,,,,1,,ANY
322525,BLOCK,1,,<empty>,,,,1,,ANY
322530,BLOCK,1,,<empty>,,,,1,,ANY
322535,BLOCK,1,,<empty>,,,,1,,ANY
322539,BLOCK,1,,<empty>,,,,1,,ANY
322545,BLOCK,1,,<empty>,,,,1,,ANY
322549,BLOCK,1,,<empty>,,,,1,,ANY
322554,BLOCK,1,,<empty>,,,,1,,ANY
322559,BLOCK,1,,<empty>,,,,1,,ANY
322564,BLOCK,1,,<empty>,,,,1,,ANY
322569,BLOCK,1,,<empty>,,,,1,,ANY
322573,BLOCK,1,,<empty>,,,,1,,ANY
322580,BLOCK,1,,<empty>,,,,1,,ANY
322584,BLOCK,1,,<empty>,,,,1,,ANY
322588,BLOCK,1,,<empty>,,,,1,,ANY
322593,BLOCK,1,,<empty>,,,,1,,ANY
322598,BLOCK,1,,<empty>,,,,1,,ANY
322602,BLOCK,1,,<empty>,,,,1,,ANY
322607,BLOCK,1,,<empty>,,,,1,,ANY
322611,BLOCK,1,,<empty>,,,,1,,ANY
322615,BLOCK,1,,<empty>,,,,1,,ANY
322619,BLOCK,1,,<empty>,,,,1,,ANY
322623,BLOCK,1,,<empty>,,,,1,,ANY
322628,BLOCK,1,,<empty>,,,,1,,ANY
322633,BLOCK,1,,<empty>,,,,1,,ANY
322640,BLOCK,1,,<empty>,,,,1,,ANY
322644,BLOCK,1,,<empty>,,,,1,,ANY
322648,BLOCK,1,,<empty>,,,,1,,ANY
322653,BLOCK,1,,<empty>,,,,1,,ANY
322658,BLOCK,1,,<empty>,,,,1,,ANY
322663,BLOCK,1,,<empty>,,,,1,,ANY
322666,BLOCK,1,,<empty>,,,,1,,ANY
322670,BLOCK,1,,<empty>,,,,1,,ANY
322674,BLOCK,1,,<empty>,,,,1,,ANY
322678,BLOCK,1,,<empty>,,,,1,,ANY
322682,BLOCK,1,,<empty>,,,,1,,ANY
322687,BLOCK,1,,<empty>,,,,1,,ANY
322692,BLOCK,1,,<empty>,,,,1,,ANY
322697,BLOCK,1,,<empty>,,,,1,,ANY
322703,BLOCK,1,,<empty>,,,,1,,ANY
322711,BLOCK,1,,<empty>,,,,1,,ANY
322715,BLOCK,1,,<empty>,,,,1,,ANY
322719,BLOCK,1,,<empty>,,,,1,,ANY
322722,BLOCK,1,,<empty>,,,,1,,ANY
322728,BLOCK,1,,<empty>,,,,1,,ANY
322735,BLOCK,1,,<empty>,,,,1,,ANY
322739,BLOCK,1,,<empty>,,,,1,,ANY
322743,BLOCK,1,,<empty>,,,,1,,ANY
322748,BLOCK,1,,<empty>,,,,1,,ANY
322755,BLOCK,1,,<empty>,,,,1,,ANY
322762,BLOCK,1,,<empty>,,,,1,,ANY
322767,BLOCK,1,,<empty>,,,,1,,ANY
322772,BLOCK,1,,<empty>,,,,1,,ANY
322777,BLOCK,1,,<empty>,,,,1,,ANY
322782,BLOCK,1,,<empty>,,,,1,,ANY
322787,BLOCK,1,,<empty>,,,,1,,ANY
322792,BLOCK,1,,<empty>,,,,1,,ANY
322796,BLOCK,1,,<empty>,,,,1,,ANY
322800,BLOCK,1,,<empty>,,,,1,,ANY
322804,BLOCK,1,,<empty>,,,,1,,ANY
322808,BLOCK,1,,<empty>,,,,1,,ANY
322812,BLOCK,1,,<empty>,,,,1,,ANY
322817,BLOCK,1,,<empty>,,,,1,,ANY
322822,BLOCK,1,,<empty>,,,,1,,ANY
322829,BLOCK,1,,<empty>,,,,1,,ANY
322833,BLOCK,1,,<empty>,,,,1,,ANY
322837,BLOCK,1,,<empty>,,,,1,,ANY
322841,BLOCK,1,,<empty>,,,,1,,ANY
322844,BLOCK,1,,<empty>,,,,1,,ANY
322848,BLOCK,1,,<empty>,,,,1,,ANY
322853,BLOCK,1,,<empty>,,,,1,,ANY
322857,BLOCK,1,,<empty>,,,,1,,ANY
322862,BLOCK,1,,<empty>,,,,1,,ANY
322866,BLOCK,1,,<empty>,,,,1,,ANY
322870,BLOCK,1,,<empty>,,,,1,,ANY
322874,BLOCK,1,,<empty>,,,,1,,ANY
322878,BLOCK,1,,<empty>,,,,1,,ANY
322886,BLOCK,1,,<empty>,,,,1,,ANY
322890,BLOCK,1,,<empty>,,,,1,,ANY
322895,BLOCK,1,,<empty>,,,,1,,ANY
322900,BLOCK,1,,<empty>,,,,1,,ANY
322904,BLOCK,1,,<empty>,,,,1,,ANY
322908,BLOCK,1,,<empty>,,,,1,,ANY
322911,BLOCK,1,,<empty>,,,,1,,ANY
322915,BLOCK,1,,<empty>,,,,1,,ANY
322921,BLOCK,1,,<empty>,,,,1,,ANY
322925,BLOCK,1,,<empty>,,,,1,,ANY
322928,BLOCK,1,,<empty>,,,,1,,ANY
322939,BLOCK,1,,<empty>,,,,1,,ANY
322942,BLOCK,1,,<empty>,,,,1,,ANY
322953,BLOCK,1,,<empty>,,,,1,,ANY
322957,BLOCK,1,,<empty>,,,,1,,ANY
322961,BLOCK,1,,<empty>,,,,1,,ANY
322965,BLOCK,1,,<empty>,,,,1,,ANY
322970,BLOCK,1,,<empty>,,,,1,,ANY
322974,BLOCK,1,,<empty>,,,,1,,ANY
322978,BLOCK,1,,<empty>,,,,1,,ANY
322982,BLOCK,1,,<empty>,,,,1,,ANY
322986,BLOCK,1,,<empty>,,,,1,,ANY
322990,BLOCK,1,,<empty>,,,,1,,ANY
322994,BLOCK,1,,<empty>,,,,1,,ANY
322998,BLOCK,1,,<empty>,,,,1,,ANY
323004,BLOCK,1,,<empty>,,,,1,,ANY
323008,BLOCK,1,,<empty>,,,,1,,ANY
323011,BLOCK,1,,<empty>,,,,1,,ANY
323017,BLOCK,1,,<empty>,,,,1,,ANY
323021,BLOCK,1,,<empty>,,,,1,,ANY
323025,BLOCK,1,,<empty>,,,,1,,ANY
323038,BLOCK,1,,<empty>,,,,1,,ANY
323042,BLOCK,1,,<empty>,,,,1,,ANY
323047,BLOCK,1,,<empty>,,,,1,,ANY
323052,BLOCK,1,,<empty>,,,,1,,ANY
323056,BLOCK,1,,<empty>,,,,1,,ANY
323061,BLOCK,1,,<empty>,,,,1,,ANY
323065,BLOCK,1,,<empty>,,,,1,,ANY
323069,BLOCK,1,,<empty>,,,,1,,ANY
323073,BLOCK,1,,<empty>,,,,1,,ANY
323078,BLOCK,1,,<empty>,,,,1,,ANY
323084,BLOCK,1,,<empty>,,,,1,,ANY
323089,BLOCK,1,,<empty>,,,,1,,ANY
323093,BLOCK,1,,<empty>,,,,1,,ANY
323104,BLOCK,1,,<empty>,,,,1,,ANY
323115,BLOCK,1,,<empty>,,,,1,,ANY
323120,BLOCK,1,,<empty>,,,,1,,ANY
323131,BLOCK,1,,<empty>,,,,1,,ANY
323135,BLOCK,1,,<empty>,,,,1,,ANY
323145,BLOCK,1,,<empty>,,,,1,,ANY
323150,BLOCK,1,,<empty>,,,,1,,ANY
323154,BLOCK,1,,<empty>,,,,1,,ANY
323165,BLOCK,1,,<empty>,,,,1,,ANY
323176,BLOCK,1,,<empty>,,,,1,,ANY
323181,BLOCK,1,,<empty>,,,,1,,ANY
323185,BLOCK,1,,<empty>,,,,1,,ANY
323196,BLOCK,1,,<empty>,,,,1,,ANY
323207,BLOCK,1,,<empty>,,,,1,,ANY
323218,BLOCK,1,,<empty>,,,,1,,ANY
323222,BLOCK,1,,<empty>,,,,1,,ANY
323233,BLOCK,1,,<empty>,,,,1,,ANY
323244,BLOCK,1,,<empty>,,,,1,,ANY
323249,BLOCK,1,,<empty>,,,,1,,ANY
323253,BLOCK,1,,<empty>,,,,1,,ANY
323264,BLOCK,1,,<empty>,,,,1,,ANY
323275,BLOCK,1,,<empty>,,,,1,,ANY
323282,BLOCK,1,,<empty>,,,,1,,ANY
323287,BLOCK,1,,<empty>,,,,1,,ANY
323291,BLOCK,1,,<empty>,,,,1,,ANY
323306,BLOCK,1,,<empty>,,,,1,,ANY
323317,BLOCK,1,,<empty>,,,,1,,ANY
323328,BLOCK,1,,<empty>,,,,1,,ANY
323333,BLOCK,1,,<empty>,,,,1,,ANY
323338,BLOCK,1,,<empty>,,,,1,,ANY
323343,BLOCK,1,,<empty>,,,,1,,ANY
323347,BLOCK,1,,<empty>,,,,1,,ANY
323358,BLOCK,1,,<empty>,,,,1,,ANY
323369,BLOCK,1,,<empty>,,,,1,,ANY
323374,BLOCK,1,,<empty>,,,,1,,ANY
323378,BLOCK,1,,<empty>,,,,1,,ANY
323389,BLOCK,1,,<empty>,,,,1,,ANY
323400,BLOCK,1,,<empty>,,,,1,,ANY
323405,BLOCK,1,,<empty>,,,,1,,ANY
323410,BLOCK,1,,<empty>,,,,1,,ANY
323415,BLOCK,1,,<empty>,,,,1,,ANY
323419,BLOCK,1,,<empty>,,,,1,,ANY
323430,BLOCK,1,,<empty>,,,,1,,ANY
323441,BLOCK,1,,<empty>,,,,1,,ANY
323452,BLOCK,1,,<empty>,,,,1,,ANY
323456,BLOCK,1,,<empty>,,,,1,,ANY
323467,BLOCK,1,,<empty>,,,,1,,ANY
323478,BLOCK,1,,<empty>,,,,1,,ANY
323489,BLOCK,1,,<empty>,,,,1,,ANY
323493,BLOCK,1,,<empty>,,,,1,,ANY
323504,BLOCK,1,,<empty>,,,,1,,ANY
323515,BLOCK,1,,<empty>,,,,1,,ANY
323526,BLOCK,1,,<empty>,,,,1,,ANY
323530,BLOCK,1,,<empty>,,,,1,,ANY
323541,BLOCK,1,,<empty>,,,,1,,ANY
323552,BLOCK,1,,<empty>,,,,1,,ANY
323557,BLOCK,1,,<empty>,,,,1,,ANY
323561,BLOCK,1,,<empty>,,,,1,,ANY
323572,BLOCK,1,,<empty>,,,,1,,ANY
323583,BLOCK,1,,<empty>,,,,1,,ANY
323588,BLOCK,1,,<empty>,,,,1,,ANY
323592,BLOCK,1,,<empty>,,,,1,,ANY
323603,BLOCK,1,,<empty>,,,,1,,ANY
323614,BLOCK,1,,<empty>,,,,1,,ANY
323619,BLOCK,1,,<empty>,,,,1,,ANY
323623,BLOCK,1,,<empty>,,,,1,,ANY
323631,BLOCK,1,,<empty>,,,,1,,ANY
323635,BLOCK,1,,<empty>,,,,1,,ANY
323643,BLOCK,1,,<empty>,,,,1,,ANY
323654,BLOCK,1,,<empty>,,,,1,,ANY
323662,BLOCK,1,,<empty>,,,,1,,ANY
323673,BLOCK,1,,<empty>,,,,1,,ANY
323678,BLOCK,1,,<empty>,,,,1,,ANY
323682,BLOCK,1,,<empty>,,,,1,,ANY
323693,BLOCK,1,,<empty>,,,,1,,ANY
323704,BLOCK,1,,<empty>,,,,1,,ANY
323709,BLOCK,1,,<empty>,,,,1,,ANY
323714,BLOCK,1,,<empty>,,,,1,,ANY
323718,BLOCK,1,,<empty>,,,,1,,ANY
323729,BLOCK,1,,<empty>,,,,1,,ANY
323740,BLOCK,1,,<empty>,,,,1,,ANY
323746,BLOCK,1,,<empty>,,,,1,,ANY
323751,BLOCK,1,,<empty>,,,,1,,ANY
323756,BLOCK,1,,<empty>,,,,1,,ANY
323760,BLOCK,1,,<empty>,,,,1,,ANY
323771,BLOCK,1,,<empty>,,,,1,,ANY
323782,BLOCK,1,,<empty>,,,,1,,ANY
323787,BLOCK,1,,<empty>,,,,1,,ANY
323791,BLOCK,1,,<empty>,,,,1,,ANY
323802,BLOCK,1,,<empty>,,,,1,,ANY
323813,BLOCK,1,,<empty>,,,,1,,ANY
323820,BLOCK,1,,<empty>,,,,1,,ANY
323824,BLOCK,1,,<empty>,,,,1,,ANY
323835,BLOCK,1,,<empty>,,,,1,,ANY
323839,BLOCK,1,,<empty>,,,,1,,ANY
323850,BLOCK,1,,<empty>,,,,1,,ANY
323863,BLOCK,1,,<empty>,,,,1,,ANY
323867,BLOCK,1,,<empty>,,,,1,,ANY
323871,BLOCK,1,,<empty>,,,,1,,ANY
323875,BLOCK,1,,<empty>,,,,1,,ANY
323878,BLOCK,1,,<empty>,,,,1,,ANY
323882,BLOCK,1,,<empty>,,,,1,,ANY
323886,BLOCK,1,,<empty>,,,,1,,ANY
323893,BLOCK,1,,<empty>,,,,1,,ANY
323897,BLOCK,1,,<empty>,,,,1,,ANY
323901,BLOCK,1,,<empty>,,,,1,,ANY
323912,BLOCK,1,,<empty>,,,,1,,ANY
323916,BLOCK,1,,<empty>,,,,1,,ANY
323927,BLOCK,1,,<empty>,,,,1,,ANY
323940,BLOCK,1,,<empty>,,,,1,,ANY
323945,BLOCK,1,,<empty>,,,,1,,ANY
323949,BLOCK,1,,<empty>,,,,1,,ANY
323960,BLOCK,1,,<empty>,,,,1,,ANY
323971,BLOCK,1,,<empty>,,,,1,,ANY
323982,BLOCK,1,,<empty>,,,,1,,ANY
323986,BLOCK,1,,<empty>,,,,1,,ANY
323997,BLOCK,1,,<empty>,,,,1,,ANY
324008,BLOCK,1,,<empty>,,,,1,,ANY
324013,BLOCK,1,,<empty>,,,,1,,ANY
324017,BLOCK,1,,<empty>,,,,1,,ANY
324028,BLOCK,1,,<empty>,,,,1,,ANY
324039,BLOCK,1,,<empty>,,,,1,,ANY
324050,BLOCK,1,,<empty>,,,,1,,ANY
324054,BLOCK,1,,<empty>,,,,1,,ANY
324065,BLOCK,1,,<empty>,,,,1,,ANY
324076,BLOCK,1,,<empty>,,,,1,,ANY
324081,BLOCK,1,,<empty>,,,,1,,ANY
324085,BLOCK,1,,<empty>,,,,1,,ANY
324096,BLOCK,1,,<empty>,,,,1,,ANY
324107,BLOCK,1,,<empty>,,,,1,,ANY
324112,BLOCK,1,,<empty>,,,,1,,ANY
324116,BLOCK,1,,<empty>,,,,1,,ANY
324127,BLOCK,1,,<empty>,,,,1,,ANY
324138,BLOCK,1,,<empty>,,,,1,,ANY
324149,BLOCK,1,,<empty>,,,,1,,ANY
324153,BLOCK,1,,<empty>,,,,1,,ANY
324164,BLOCK,1,,<empty>,,,,1,,ANY
324175,BLOCK,1,,<empty>,,,,1,,ANY
324180,BLOCK,1,,<empty>,,,,1,,ANY
324184,BLOCK,1,,<empty>,,,,1,,ANY
324195,BLOCK,1,,<empty>,,,,1,,ANY
324206,BLOCK,1,,<empty>,,,,1,,ANY
324211,BLOCK,1,,<empty>,,,,1,,ANY
324216,BLOCK,1,,<empty>,,,,1,,ANY
324220,BLOCK,1,,<empty>,,,,1,,ANY
324231,BLOCK,1,,<empty>,,,,1,,ANY
324242,BLOCK,1,,<empty>,,,,1,,ANY
324248,BLOCK,1,,<empty>,,,,1,,ANY
324253,BLOCK,1,,<empty>,,,,1,,ANY
324258,BLOCK,1,,<empty>,,,,1,,ANY
324263,BLOCK,1,,<empty>,,,,1,,ANY
324268,BLOCK,1,,<empty>,,,,1,,ANY
324272,BLOCK,1,,<empty>,,,,1,,ANY
324277,BLOCK,1,,<empty>,,,,1,,ANY
324282,BLOCK,1,,<empty>,,,,1,,ANY
324286,BLOCK,1,,<empty>,,,,1,,ANY
324291,BLOCK,1,,<empty>,,,,1,,ANY
324295,BLOCK,1,,<empty>,,,,1,,ANY
324298,BLOCK,1,,<empty>,,,,1,,ANY
324302,BLOCK,1,,<empty>,,,,1,,ANY
324307,BLOCK,1,,<empty>,,,,1,,ANY
324311,BLOCK,1,,<empty>,,,,1,,ANY
324315,BLOCK,1,,<empty>,,,,1,,ANY
324320,BLOCK,1,,<empty>,,,,1,,ANY
324323,BLOCK,1,,<empty>,,,,1,,ANY
324327,BLOCK,1,,<empty>,,,,1,,ANY
324332,BLOCK,1,,<empty>,,,,1,,ANY
324337,BLOCK,1,,<empty>,,,,1,,ANY
324342,BLOCK,1,,<empty>,,,,1,,ANY
324347,BLOCK,1,,<empty>,,,,1,,ANY
324352,BLOCK,1,,<empty>,,,,1,,ANY
324357,BLOCK,1,,<empty>,,,,1,,ANY
324362,BLOCK,1,,<empty>,,,,1,,ANY
324366,BLOCK,1,,<empty>,,,,1,,ANY
324370,BLOCK,1,,<empty>,,,,1,,ANY
324374,BLOCK,1,,<empty>,,,,1,,ANY
324378,BLOCK,1,,<empty>,,,,1,,ANY
324382,BLOCK,1,,<empty>,,,,1,,ANY
324387,BLOCK,1,,<empty>,,,,1,,ANY
324391,BLOCK,1,,<empty>,,,,1,,ANY
324397,BLOCK,1,,<empty>,,,,1,,ANY
324404,BLOCK,1,,<empty>,,,,1,,ANY
324408,BLOCK,1,,<empty>,,,,1,,ANY
324415,BLOCK,1,,<empty>,,,,1,,ANY
324422,BLOCK,1,,<empty>,,,,1,,ANY
324427,BLOCK,1,,<empty>,,,,1,,ANY
324431,BLOCK,1,,<empty>,,,,1,,ANY
324436,BLOCK,1,,<empty>,,,,1,,ANY
324441,BLOCK,1,,<empty>,,,,1,,ANY
324446,BLOCK,1,,<empty>,,,,1,,ANY
324451,BLOCK,1,,<empty>,,,,1,,ANY
324456,BLOCK,1,,<empty>,,,,1,,ANY
324461,BLOCK,1,,<empty>,,,,1,,ANY
324466,BLOCK,1,,<empty>,,,,1,,ANY
324471,BLOCK,1,,<empty>,,,,1,,ANY
324476,BLOCK,1,,<empty>,,,,1,,ANY
324481,BLOCK,1,,<empty>,,,,1,,ANY
324486,BLOCK,1,,<empty>,,,,1,,ANY
324491,BLOCK,1,,<empty>,,,,1,,ANY
324495,BLOCK,1,,<empty>,,,,1,,ANY
324500,BLOCK,1,,<empty>,,,,1,,ANY
324504,BLOCK,1,,<empty>,,,,1,,ANY
324508,BLOCK,1,,<empty>,,,,1,,ANY
324512,BLOCK,1,,<empty>,,,,1,,ANY
324516,BLOCK,1,,<empty>,,,,1,,ANY
324520,BLOCK,1,,<empty>,,,,1,,ANY
324524,BLOCK,1,,<empty>,,,,1,,ANY
324528,BLOCK,1,,<empty>,,,,1,,ANY
324531,BLOCK,1,,<empty>,,,,1,,ANY
324535,BLOCK,1,,<empty>,,,,1,,ANY
324539,BLOCK,1,,<empty>,,,,1,,ANY
324542,BLOCK,1,,<empty>,,,,1,,ANY
324545,BLOCK,1,,<empty>,,,,1,,ANY
324549,BLOCK,1,,<empty>,,,,1,,ANY
324553,BLOCK,1,,<empty>,,,,1,,ANY
324557,BLOCK,1,,<empty>,,,,1,,ANY
324560,BLOCK,1,,<empty>,,,,1,,ANY
324564,BLOCK,1,,<empty>,,,,1,,ANY
324568,BLOCK,1,,<empty>,,,,1,,ANY
324572,BLOCK,1,,<empty>,,,,1,,ANY
324575,BLOCK,1,,<empty>,,,,1,,ANY
324579,BLOCK,1,,<empty>,,,,1,,ANY
324583,BLOCK,1,,<empty>,,,,1,,ANY
324587,BLOCK,1,,<empty>,,,,1,,ANY
324591,BLOCK,1,,<empty>,,,,1,,ANY
324595,BLOCK,1,,<empty>,,,,1,,ANY
324599,BLOCK,1,,<empty>,,,,1,,ANY
324603,BLOCK,1,,<empty>,,,,1,,ANY
324607,BLOCK,1,,<empty>,,,,1,,ANY
324611,BLOCK,1,,<empty>,,,,1,,ANY
324614,BLOCK,1,,<empty>,,,,1,,ANY
324617,BLOCK,1,,<empty>,,,,1,,ANY
324620,BLOCK,1,,<empty>,,,,1,,ANY
324625,BLOCK,1,,<empty>,,,,1,,ANY
324628,BLOCK,1,,<empty>,,,,1,,ANY
324631,BLOCK,1,,<empty>,,,,1,,ANY
324635,BLOCK,1,,<empty>,,,,1,,ANY
324638,BLOCK,1,,<empty>,,,,1,,ANY
324642,BLOCK,1,,<empty>,,,,1,,ANY
324645,BLOCK,1,,<empty>,,,,1,,ANY
324648,BLOCK,1,,<empty>,,,,1,,ANY
324653,BLOCK,1,,<empty>,,,,1,,ANY
324657,BLOCK,1,,<empty>,,,,1,,ANY
324662,BLOCK,1,,<empty>,,,,1,,ANY
324666,BLOCK,1,,<empty>,,,,1,,ANY
324671,BLOCK,1,,<empty>,,,,1,,ANY
324675,BLOCK,1,,<empty>,,,,1,,ANY
324679,BLOCK,1,,<empty>,,,,1,,ANY
324683,BLOCK,1,,<empty>,,,,1,,ANY
324689,BLOCK,1,,<empty>,,,,1,,ANY
324692,BLOCK,1,,<empty>,,,,1,,ANY
324695,BLOCK,1,,<empty>,,,,1,,ANY
324699,BLOCK,1,,<empty>,,,,1,,ANY
324703,BLOCK,1,,<empty>,,,,1,,ANY
324707,BLOCK,1,,<empty>,,,,1,,ANY
324715,BLOCK,1,,<empty>,,,,1,,ANY
324722,BLOCK,1,,<empty>,,,,1,,ANY
324727,BLOCK,1,,<empty>,,,,1,,ANY
324734,BLOCK,1,,<empty>,,,,1,,ANY
324739,BLOCK,1,,<empty>,,,,1,,ANY
324744,BLOCK,1,,<empty>,,,,1,,ANY
324749,BLOCK,1,,<empty>,,,,1,,ANY
324754,BLOCK,1,,<empty>,,,,1,,ANY
324759,BLOCK,1,,<empty>,,,,1,,ANY
324764,BLOCK,1,,<empty>,,,,1,,ANY
324769,BLOCK,1,,<empty>,,,,1,,ANY
324774,BLOCK,1,,<empty>,,,,1,,ANY
324779,BLOCK,1,,<empty>,,,,1,,ANY
324783,BLOCK,1,,<empty>,,,,1,,ANY
324787,BLOCK,1,,<empty>,,,,1,,ANY
324791,BLOCK,1,,<empty>,,,,1,,ANY
324796,BLOCK,1,,<empty>,,,,1,,ANY
324800,BLOCK,1,,<empty>,,,,1,,ANY
324804,BLOCK,1,,<empty>,,,,1,,ANY
324809,BLOCK,1,,<empty>,,,,1,,ANY
324812,BLOCK,1,,<empty>,,,,1,,ANY
324818,BLOCK,1,,<empty>,,,,1,,ANY
324821,BLOCK,1,,<empty>,,,,1,,ANY
324827,BLOCK,1,,<empty>,,,,1,,ANY
324833,BLOCK,1,,<empty>,,,,1,,ANY
324837,BLOCK,1,,<empty>,,,,1,,ANY
324845,BLOCK,1,,<empty>,,,,1,,ANY
324849,BLOCK,1,,<empty>,,,,1,,ANY
324853,BLOCK,1,,<empty>,,,,1,,ANY
324858,BLOCK,1,,<empty>,,,,1,,ANY
324862,BLOCK,1,,<empty>,,,,1,,ANY
324866,BLOCK,1,,<empty>,,,,1,,ANY
324870,BLOCK,1,,<empty>,,,,1,,ANY
324874,BLOCK,1,,<empty>,,,,1,,ANY
324878,BLOCK,1,,<empty>,,,,1,,ANY
324882,BLOCK,1,,<empty>,,,,1,,ANY
324886,BLOCK,1,,<empty>,,,,1,,ANY
324890,BLOCK,1,,<empty>,,,,1,,ANY
324894,BLOCK,1,,<empty>,,,,1,,ANY
324897,BLOCK,1,,<empty>,,,,1,,ANY
324901,BLOCK,1,,<empty>,,,,1,,ANY
324905,BLOCK,1,,<empty>,,,,1,,ANY
324908,BLOCK,1,,<empty>,,,,1,,ANY
324912,BLOCK,1,,<empty>,,,,1,,ANY
324916,BLOCK,1,,<empty>,,,,1,,ANY
324919,BLOCK,1,,<empty>,,,,1,,ANY
324922,BLOCK,1,,<empty>,,,,1,,ANY
324927,BLOCK,1,,<empty>,,,,1,,ANY
324931,BLOCK,1,,<empty>,,,,1,,ANY
324934,BLOCK,1,,<empty>,,,,1,,ANY
324939,BLOCK,1,,<empty>,,,,1,,ANY
324945,BLOCK,1,,<empty>,,,,1,,ANY
324948,BLOCK,1,,<empty>,,,,1,,ANY
324953,BLOCK,1,,<empty>,,,,1,,ANY
324962,BLOCK,1,,<empty>,,,,1,,ANY
324966,BLOCK,1,,<empty>,,,,1,,ANY
324970,BLOCK,1,,<empty>,,,,1,,ANY
324975,BLOCK,1,,<empty>,,,,1,,ANY
324979,BLOCK,1,,<empty>,,,,1,,ANY
324984,BLOCK,1,,<empty>,,,,1,,ANY
324987,BLOCK,1,,<empty>,,,,1,,ANY
324990,BLOCK,1,,<empty>,,,,1,,ANY
324995,BLOCK,1,,<empty>,,,,1,,ANY
325000,BLOCK,1,,<empty>,,,,1,,ANY
325005,BLOCK,1,,<empty>,,,,1,,ANY
325009,BLOCK,1,,<empty>,,,,1,,ANY
325017,BLOCK,1,,<empty>,,,,1,,ANY
325027,BLOCK,1,,<empty>,,,,1,,ANY
325031,BLOCK,1,,<empty>,,,,1,,ANY
325038,BLOCK,1,,<empty>,,,,1,,ANY
325045,BLOCK,1,,<empty>,,,,1,,ANY
325051,BLOCK,1,,<empty>,,,,1,,ANY
325058,BLOCK,1,,<empty>,,,,1,,ANY
325062,BLOCK,1,,<empty>,,,,1,,ANY
325067,BLOCK,1,,<empty>,,,,1,,ANY
325076,BLOCK,1,,<empty>,,,,1,,ANY
325079,BLOCK,1,,<empty>,,,,1,,ANY
325082,BLOCK,1,,<empty>,,,,1,,ANY
325086,BLOCK,1,,<empty>,,,,1,,ANY
325091,BLOCK,1,,<empty>,,,,1,,ANY
325098,BLOCK,1,,<empty>,,,,1,,ANY
325103,BLOCK,1,,<empty>,,,,1,,ANY
325108,BLOCK,1,,<empty>,,,,1,,ANY
325114,BLOCK,1,,<empty>,,,,1,,ANY
325118,BLOCK,1,,<empty>,,,,1,,ANY
325122,BLOCK,1,,<empty>,,,,1,,ANY
325126,BLOCK,1,,<empty>,,,,1,,ANY
325131,BLOCK,1,,<empty>,,,,1,,ANY
325136,BLOCK,1,,<empty>,,,,1,,ANY
325141,BLOCK,1,,<empty>,,,,1,,ANY
325148,BLOCK,1,,<empty>,,,,1,,ANY
325154,BLOCK,1,,<empty>,,,,1,,ANY
325158,BLOCK,1,,<empty>,,,,1,,ANY
325162,BLOCK,1,,<empty>,,,,1,,ANY
325166,BLOCK,1,,<empty>,,,,1,,ANY
325170,BLOCK,1,,<empty>,,,,1,,ANY
325174,BLOCK,1,,<empty>,,,,1,,ANY
325178,BLOCK,1,,<empty>,,,,1,,ANY
325182,BLOCK,1,,<empty>,,,,1,,ANY
325186,BLOCK,1,,<empty>,,,,1,,ANY
325190,BLOCK,1,,<empty>,,,,1,,ANY
325195,BLOCK,1,,<empty>,,,,1,,ANY
325203,BLOCK,1,,<empty>,,,,1,,ANY
325210,BLOCK,1,,<empty>,,,,1,,ANY
325215,BLOCK,1,,<empty>,,,,1,,ANY
325224,BLOCK,1,,<empty>,,,,1,,ANY
325232,BLOCK,1,,<empty>,,,,1,,ANY
325236,BLOCK,1,,<empty>,,,,1,,ANY
325242,BLOCK,1,,<empty>,,,,1,,ANY
325247,BLOCK,1,,<empty>,,,,1,,ANY
325252,BLOCK,1,,<empty>,,,,1,,ANY
325259,BLOCK,1,,<empty>,,,,1,,ANY
325265,BLOCK,1,,<empty>,,,,1,,ANY
325269,BLOCK,1,,<empty>,,,,1,,ANY
325273,BLOCK,1,,<empty>,,,,1,,ANY
325277,BLOCK,1,,<empty>,,,,1,,ANY
325282,BLOCK,1,,<empty>,,,,1,,ANY
325287,BLOCK,1,,<empty>,,,,1,,ANY
325292,BLOCK,1,,<empty>,,,,1,,ANY
325302,BLOCK,1,,<empty>,,,,1,,ANY
325309,BLOCK,1,,<empty>,,,,1,,ANY
325318,BLOCK,1,,<empty>,,,,1,,ANY
325323,BLOCK,1,,<empty>,,,,1,,ANY
325329,BLOCK,1,,<empty>,,,,1,,ANY
325335,BLOCK,1,,<empty>,,,,1,,ANY
325340,BLOCK,1,,<empty>,,,,1,,ANY
325344,BLOCK,1,,<empty>,,,,1,,ANY
325348,BLOCK,1,,<empty>,,,,1,,ANY
325354,BLOCK,1,,<empty>,,,,1,,ANY
325358,BLOCK,1,,<empty>,,,,1,,ANY
325362,BLOCK,1,,<empty>,,,,1,,ANY
325366,BLOCK,1,,<empty>,,,,1,,ANY
325370,BLOCK,1,,<empty>,,,,1,,ANY
325374,BLOCK,1,,<empty>,,,,1,,ANY
325378,BLOCK,1,,<empty>,,,,1,,ANY
325382,BLOCK,1,,<empty>,,,,1,,ANY
325386,BLOCK,1,,<empty>,,,,1,,ANY
325390,BLOCK,1,,<empty>,,,,1,,ANY
325394,BLOCK,1,,<empty>,,,,1,,ANY
325398,BLOCK,1,,<empty>,,,,1,,ANY
325402,BLOCK,1,,<empty>,,,,1,,ANY
325407,BLOCK,1,,<empty>,,,,1,,ANY
325411,BLOCK,1,,<empty>,,,,1,,ANY
325415,BLOCK,1,,<empty>,,,,1,,ANY
325419,BLOCK,1,,<empty>,,,,1,,ANY
325423,BLOCK,1,,<empty>,,,,1,,ANY
325427,BLOCK,1,,<empty>,,,,1,,ANY
325431,BLOCK,1,,<empty>,,,,1,,ANY
325439,BLOCK,1,,<empty>,,,,1,,ANY
325447,BLOCK,1,,<empty>,,,,1,,ANY
325455,BLOCK,1,,<empty>,,,,1,,ANY
325463,BLOCK,1,,<empty>,,,,1,,ANY
325471,BLOCK,1,,<empty>,,,,1,,ANY
325479,BLOCK,1,,<empty>,,,,1,,ANY
325487,BLOCK,1,,<empty>,,,,1,,ANY
325495,BLOCK,1,,<empty>,,,,1,,ANY
325503,BLOCK,1,,<empty>,,,,1,,ANY
325511,BLOCK,1,,<empty>,,,,1,,ANY
325516,BLOCK,1,,<empty>,,,,1,,ANY
325521,BLOCK,1,,<empty>,,,,1,,ANY
325526,BLOCK,1,,<empty>,,,,1,,ANY
325530,BLOCK,1,,<empty>,,,,1,,ANY
325538,BLOCK,1,,<empty>,,,,1,,ANY
325544,BLOCK,1,,<empty>,,,,1,,ANY
325549,BLOCK,1,,<empty>,,,,1,,ANY
325554,BLOCK,1,,<empty>,,,,1,,ANY
325560,BLOCK,1,,<empty>,,,,1,,ANY
325564,BLOCK,1,,<empty>,,,,1,,ANY
325567,BLOCK,1,,<empty>,,,,1,,ANY
325571,BLOCK,1,,<empty>,,,,1,,ANY
325575,BLOCK,1,,<empty>,,,,1,,ANY
325579,BLOCK,1,,<empty>,,,,1,,ANY
325582,BLOCK,1,,<empty>,,,,1,,ANY
325585,BLOCK,1,,<empty>,,,,1,,ANY
325589,BLOCK,1,,<empty>,,,,1,,ANY
325594,BLOCK,1,,<empty>,,,,1,,ANY
325598,BLOCK,1,,<empty>,,,,1,,ANY
325603,BLOCK,1,,<empty>,,,,1,,ANY
325607,BLOCK,1,,<empty>,,,,1,,ANY
325612,BLOCK,1,,<empty>,,,,1,,ANY
325617,BLOCK,1,,<empty>,,,,1,,ANY
325622,BLOCK,1,,<empty>,,,,1,,ANY
325626,BLOCK,1,,<empty>,,,,1,,ANY
325630,BLOCK,1,,<empty>,,,,1,,ANY
325634,BLOCK,1,,<empty>,,,,1,,ANY
325638,BLOCK,1,,<empty>,,,,1,,ANY
325641,BLOCK,1,,<empty>,,,,1,,ANY
325645,BLOCK,1,,<empty>,,,,1,,ANY
325649,BLOCK,1,,<empty>,,,,1,,ANY
325653,BLOCK,1,,<empty>,,,,1,,ANY
325657,BLOCK,1,,<empty>,,,,1,,ANY
325662,BLOCK,1,,<empty>,,,,1,,ANY
325666,BLOCK,1,,<empty>,,,,1,,ANY
325671,BLOCK,1,,<empty>,,,,1,,ANY
325676,BLOCK,1,,<empty>,,,,1,,ANY
325681,BLOCK,1,,<empty>,,,,1,,ANY
325686,BLOCK,1,,<empty>,,,,1,,ANY
325691,BLOCK,1,,<empty>,,,,1,,ANY
325695,BLOCK,1,,<empty>,,,,1,,ANY
325699,BLOCK,1,,<empty>,,,,1,,ANY
325703,BLOCK,1,,<empty>,,,,1,,ANY
325707,BLOCK,1,,<empty>,,,,1,,ANY
325711,BLOCK,1,,<empty>,,,,1,,ANY
325715,BLOCK,1,,<empty>,,,,1,,ANY
325719,BLOCK,1,,<empty>,,,,1,,ANY
325724,BLOCK,1,,<empty>,,,,1,,ANY
325728,BLOCK,1,,<empty>,,,,1,,ANY
325732,BLOCK,1,,<empty>,,,,1,,ANY
325737,BLOCK,1,,<empty>,,,,1,,ANY
325742,BLOCK,1,,<empty>,,,,1,,ANY
325748,BLOCK,1,,<empty>,,,,1,,ANY
325752,BLOCK,1,,<empty>,,,,1,,ANY
325756,BLOCK,1,,<empty>,,,,1,,ANY
325760,BLOCK,1,,<empty>,,,,1,,ANY
325766,BLOCK,1,,<empty>,,,,1,,ANY
325770,BLOCK,1,,<empty>,,,,1,,ANY
325776,BLOCK,1,,<empty>,,,,1,,ANY
325781,BLOCK,1,,<empty>,,,,1,,ANY
325787,BLOCK,1,,<empty>,,,,1,,ANY
325791,BLOCK,1,,<empty>,,,,1,,ANY
325796,BLOCK,1,,<empty>,,,,1,,ANY
325801,BLOCK,1,,<empty>,,,,1,,ANY
325805,BLOCK,1,,<empty>,,,,1,,ANY
325809,BLOCK,1,,<empty>,,,,1,,ANY
325816,BLOCK,1,,<empty>,,,,1,,ANY
325821,BLOCK,1,,<empty>,,,,1,,ANY
325827,BLOCK,1,,<empty>,,,,1,,ANY
325831,BLOCK,1,,<empty>,,,,1,,ANY
325835,BLOCK,1,,<empty>,,,,1,,ANY
325839,BLOCK,1,,<empty>,,,,1,,ANY
325844,BLOCK,1,,<empty>,,,,1,,ANY
325849,BLOCK,1,,<empty>,,,,1,,ANY
325853,BLOCK,1,,<empty>,,,,1,,ANY
325858,BLOCK,1,,<empty>,,,,1,,ANY
325862,BLOCK,1,,<empty>,,,,1,,ANY
325868,BLOCK,1,,<empty>,,,,1,,ANY
325873,BLOCK,1,,<empty>,,,,1,,ANY
325877,BLOCK,1,,<empty>,,,,1,,ANY
325882,BLOCK,1,,<empty>,,,,1,,ANY
325886,BLOCK,1,,<empty>,,,,1,,ANY
325890,BLOCK,1,,<empty>,,,,1,,ANY
325895,BLOCK,1,,<empty>,,,,1,,ANY
325899,BLOCK,1,,<empty>,,,,1,,ANY
325903,BLOCK,1,,<empty>,,,,1,,ANY
325907,BLOCK,1,,<empty>,,,,1,,ANY
325911,BLOCK,1,,<empty>,,,,1,,ANY
325915,BLOCK,1,,<empty>,,,,1,,ANY
325919,BLOCK,1,,<empty>,,,,1,,ANY
325924,BLOCK,1,,<empty>,,,,1,,ANY
325928,BLOCK,1,,<empty>,,,,1,,ANY
325931,BLOCK,1,,<empty>,,,,1,,ANY
325935,BLOCK,1,,<empty>,,,,1,,ANY
325939,BLOCK,1,,<empty>,,,,1,,ANY
325943,BLOCK,1,,<empty>,,,,1,,ANY
325947,BLOCK,1,,<empty>,,,,1,,ANY
325951,BLOCK,1,,<empty>,,,,1,,ANY
325956,BLOCK,1,,<empty>,,,,1,,ANY
325960,BLOCK,1,,<empty>,,,,1,,ANY
325964,BLOCK,1,,<empty>,,,,1,,ANY
325968,BLOCK,1,,<empty>,,,,1,,ANY
325973,BLOCK,1,,<empty>,,,,1,,ANY
325979,BLOCK,1,,<empty>,,,,1,,ANY
325983,BLOCK,1,,<empty>,,,,1,,ANY
325987,BLOCK,1,,<empty>,,,,1,,ANY
325994,BLOCK,1,,<empty>,,,,1,,ANY
325998,BLOCK,1,,<empty>,,,,1,,ANY
326003,BLOCK,1,,<empty>,,,,1,,ANY
326007,BLOCK,1,,<empty>,,,,1,,ANY
326011,BLOCK,1,,<empty>,,,,1,,ANY
326018,BLOCK,1,,<empty>,,,,1,,ANY
326022,BLOCK,1,,<empty>,,,,1,,ANY
326030,BLOCK,1,,<empty>,,,,1,,ANY
326034,BLOCK,1,,<empty>,,,,1,,ANY
326040,BLOCK,1,,<empty>,,,,1,,ANY
326044,BLOCK,1,,<empty>,,,,1,,ANY
326049,BLOCK,1,,<empty>,,,,1,,ANY
326053,BLOCK,1,,<empty>,,,,1,,ANY
326057,BLOCK,1,,<empty>,,,,1,,ANY
326061,BLOCK,1,,<empty>,,,,1,,ANY
326065,BLOCK,1,,<empty>,,,,1,,ANY
326069,BLOCK,1,,<empty>,,,,1,,ANY
326074,BLOCK,1,,<empty>,,,,1,,ANY
326078,BLOCK,1,,<empty>,,,,1,,ANY
326081,BLOCK,1,,<empty>,,,,1,,ANY
326085,BLOCK,1,,<empty>,,,,1,,ANY
326089,BLOCK,1,,<empty>,,,,1,,ANY
326093,BLOCK,1,,<empty>,,,,1,,ANY
326097,BLOCK,1,,<empty>,,,,1,,ANY
326101,BLOCK,1,,<empty>,,,,1,,ANY
326106,BLOCK,1,,<empty>,,,,1,,ANY
326111,BLOCK,1,,<empty>,,,,1,,ANY
326116,BLOCK,1,,<empty>,,,,1,,ANY
326122,BLOCK,1,,<empty>,,,,1,,ANY
326126,BLOCK,1,,<empty>,,,,1,,ANY
326130,BLOCK,1,,<empty>,,,,1,,ANY
326135,BLOCK,1,,<empty>,,,,1,,ANY
326138,BLOCK,1,,<empty>,,,,1,,ANY
326142,BLOCK,1,,<empty>,,,,1,,ANY
326145,BLOCK,1,,<empty>,,,,1,,ANY
326148,BLOCK,1,,<empty>,,,,1,,ANY
326151,BLOCK,1,,<empty>,,,,1,,ANY
326154,BLOCK,1,,<empty>,,,,1,,ANY
326157,BLOCK,1,,<empty>,,,,1,,ANY
326160,BLOCK,1,,<empty>,,,,1,,ANY
326163,BLOCK,1,,<empty>,,,,1,,ANY
326167,BLOCK,1,,<empty>,,,,1,,ANY
326172,BLOCK,1,,<empty>,,,,1,,ANY
326175,BLOCK,1,,<empty>,,,,1,,ANY
326180,BLOCK,1,,<empty>,,,,1,,ANY
326186,BLOCK,1,,<empty>,,,,1,,ANY
326192,BLOCK,1,,<empty>,,,,1,,ANY
326197,BLOCK,1,,<empty>,,,,1,,ANY
326202,BLOCK,1,,<empty>,,,,1,,ANY
326206,BLOCK,1,,<empty>,,,,1,,ANY
326210,BLOCK,1,,<empty>,,,,1,,ANY
326215,BLOCK,1,,<empty>,,,,1,,ANY
326221,BLOCK,1,,<empty>,,,,1,,ANY
326225,BLOCK,1,,<empty>,,,,1,,ANY
326229,BLOCK,1,,<empty>,,,,1,,ANY
326234,BLOCK,1,,<empty>,,,,1,,ANY
326240,BLOCK,1,,<empty>,,,,1,,ANY
326245,BLOCK,1,,<empty>,,,,1,,ANY
326250,BLOCK,1,,<empty>,,,,1,,ANY
326254,BLOCK,1,,<empty>,,,,1,,ANY
326260,BLOCK,1,,<empty>,,,,1,,ANY
326264,BLOCK,1,,<empty>,,,,1,,ANY
326268,BLOCK,1,,<empty>,,,,1,,ANY
326272,BLOCK,1,,<empty>,,,,1,,ANY
326276,BLOCK,1,,<empty>,,,,1,,ANY
326280,BLOCK,1,,<empty>,,,,1,,ANY
326284,BLOCK,1,,<empty>,,,,1,,ANY
326288,BLOCK,1,,<empty>,,,,1,,ANY
326292,BLOCK,1,,<empty>,,,,1,,ANY
326296,BLOCK,1,,<empty>,,,,1,,ANY
326300,BLOCK,1,,<empty>,,,,1,,ANY
326305,BLOCK,1,,<empty>,,,,1,,ANY
326312,BLOCK,1,,<empty>,,,,1,,ANY
326316,BLOCK,1,,<empty>,,,,1,,ANY
326321,BLOCK,1,,<empty>,,,,1,,ANY
326326,BLOCK,1,,<empty>,,,,1,,ANY
326330,BLOCK,1,,<empty>,,,,1,,ANY
326334,BLOCK,1,,<empty>,,,,1,,ANY
326338,BLOCK,1,,<empty>,,,,1,,ANY
326343,BLOCK,1,,<empty>,,,,1,,ANY
326347,BLOCK,1,,<empty>,,,,1,,ANY
326351,BLOCK,1,,<empty>,,,,1,,ANY
326357,BLOCK,1,,<empty>,,,,1,,ANY
326361,BLOCK,1,,<empty>,,,,1,,ANY
326366,BLOCK,1,,<empty>,,,,1,,ANY
326371,BLOCK,1,,<empty>,,,,1,,ANY
326375,BLOCK,1,,<empty>,,,,1,,ANY
326379,BLOCK,1,,<empty>,,,,1,,ANY
326383,BLOCK,1,,<empty>,,,,1,,ANY
326387,BLOCK,1,,<empty>,,,,1,,ANY
326391,BLOCK,1,,<empty>,,,,1,,ANY
326395,BLOCK,1,,<empty>,,,,1,,ANY
326399,BLOCK,1,,<empty>,,,,1,,ANY
326404,BLOCK,1,,<empty>,,,,1,,ANY
326409,BLOCK,1,,<empty>,,,,1,,ANY
326412,BLOCK,1,,<empty>,,,,1,,ANY
326418,BLOCK,1,,<empty>,,,,1,,ANY
326425,BLOCK,1,,<empty>,,,,1,,ANY
326429,BLOCK,1,,<empty>,,,,1,,ANY
326434,BLOCK,1,,<empty>,,,,1,,ANY
326438,BLOCK,1,,<empty>,,,,1,,ANY
326441,BLOCK,1,,<empty>,,,,1,,ANY
326447,BLOCK,1,,<empty>,,,,1,,ANY
326453,BLOCK,1,,<empty>,,,,1,,ANY
326459,BLOCK,1,,<empty>,,,,1,,ANY
326465,BLOCK,1,,<empty>,,,,1,,ANY
326471,BLOCK,1,,<empty>,,,,1,,ANY
326475,BLOCK,1,,<empty>,,,,1,,ANY
326479,BLOCK,1,,<empty>,,,,1,,ANY
326483,BLOCK,1,,<empty>,,,,1,,ANY
326487,BLOCK,1,,<empty>,,,,1,,ANY
326491,BLOCK,1,,<empty>,,,,1,,ANY
326495,BLOCK,1,,<empty>,,,,1,,ANY
326503,BLOCK,1,,<empty>,,,,1,,ANY
326507,BLOCK,1,,<empty>,,,,1,,ANY
326510,BLOCK,1,,<empty>,,,,1,,ANY
326516,BLOCK,1,,<empty>,,,,1,,ANY
326524,BLOCK,1,,<empty>,,,,1,,ANY
326532,BLOCK,1,,<empty>,,,,1,,ANY
326540,BLOCK,1,,<empty>,,,,1,,ANY
326548,BLOCK,1,,<empty>,,,,1,,ANY
326556,BLOCK,1,,<empty>,,,,1,,ANY
326564,BLOCK,1,,<empty>,,,,1,,ANY
326572,BLOCK,1,,<empty>,,,,1,,ANY
326580,BLOCK,1,,<empty>,,,,1,,ANY
326588,BLOCK,1,,<empty>,,,,1,,ANY
326596,BLOCK,1,,<empty>,,,,1,,ANY
326604,BLOCK,1,,<empty>,,,,1,,ANY
326609,BLOCK,1,,<empty>,,,,1,,ANY
326614,BLOCK,1,,<empty>,,,,1,,ANY
326618,BLOCK,1,,<empty>,,,,1,,ANY
326622,BLOCK,1,,<empty>,,,,1,,ANY
326626,BLOCK,1,,<empty>,,,,1,,ANY
326630,BLOCK,1,,<empty>,,,,1,,ANY
326637,BLOCK,1,,<empty>,,,,1,,ANY
326641,BLOCK,1,,<empty>,,,,1,,ANY
326645,BLOCK,1,,<empty>,,,,1,,ANY
326649,BLOCK,1,,<empty>,,,,1,,ANY
326654,BLOCK,1,,<empty>,,,,1,,ANY
326658,BLOCK,1,,<empty>,,,,1,,ANY
326662,BLOCK,1,,<empty>,,,,1,,ANY
326666,BLOCK,1,,<empty>,,,,1,,ANY
326671,BLOCK,1,,<empty>,,,,1,,ANY
326675,BLOCK,1,,<empty>,,,,1,,ANY
326679,BLOCK,1,,<empty>,,,,1,,ANY
326683,BLOCK,1,,<empty>,,,,1,,ANY
326689,BLOCK,1,,<empty>,,,,1,,ANY
326693,BLOCK,1,,<empty>,,,,1,,ANY
326697,BLOCK,1,,<empty>,,,,1,,ANY
326701,BLOCK,1,,<empty>,,,,1,,ANY
326706,BLOCK,1,,<empty>,,,,1,,ANY
326710,BLOCK,1,,<empty>,,,,1,,ANY
326714,BLOCK,1,,<empty>,,,,1,,ANY
326718,BLOCK,1,,<empty>,,,,1,,ANY
326722,BLOCK,1,,<empty>,,,,1,,ANY
326728,BLOCK,1,,<empty>,,,,1,,ANY
326731,BLOCK,1,,<empty>,,,,1,,ANY
326738,BLOCK,1,,<empty>,,,,1,,ANY
326742,BLOCK,1,,<empty>,,,,1,,ANY
326747,BLOCK,1,,<empty>,,,,1,,ANY
326751,BLOCK,1,,<empty>,,,,1,,ANY
326759,BLOCK,1,,<empty>,,,,1,,ANY
326763,BLOCK,1,,<empty>,,,,1,,ANY
326767,BLOCK,1,,<empty>,,,,1,,ANY
326771,BLOCK,1,,<empty>,,,,1,,ANY
326774,BLOCK,1,,<empty>,,,,1,,ANY
326777,BLOCK,1,,<empty>,,,,1,,ANY
326781,BLOCK,1,,<empty>,,,,1,,ANY
326784,BLOCK,1,,<empty>,,,,1,,ANY
326788,BLOCK,1,,<empty>,,,,1,,ANY
326791,BLOCK,1,,<empty>,,,,1,,ANY
326795,BLOCK,1,,<empty>,,,,1,,ANY
326799,BLOCK,1,,<empty>,,,,1,,ANY
326803,BLOCK,1,,<empty>,,,,1,,ANY
326809,BLOCK,1,,<empty>,,,,1,,ANY
326812,BLOCK,1,,<empty>,,,,1,,ANY
326816,BLOCK,1,,<empty>,,,,1,,ANY
326821,BLOCK,1,,<empty>,,,,1,,ANY
326826,BLOCK,1,,<empty>,,,,1,,ANY
326830,BLOCK,1,,<empty>,,,,1,,ANY
326834,BLOCK,1,,<empty>,,,,1,,ANY
326838,BLOCK,1,,<empty>,,,,1,,ANY
326842,BLOCK,1,,<empty>,,,,1,,ANY
326846,BLOCK,1,,<empty>,,,,1,,ANY
326850,BLOCK,1,,<empty>,,,,1,,ANY
326853,BLOCK,1,,<empty>,,,,1,,ANY
326857,BLOCK,1,,<empty>,,,,1,,ANY
326861,BLOCK,1,,<empty>,,,,1,,ANY
326865,BLOCK,1,,<empty>,,,,1,,ANY
326869,BLOCK,1,,<empty>,,,,1,,ANY
326873,BLOCK,1,,<empty>,,,,1,,ANY
326879,BLOCK,1,,<empty>,,,,1,,ANY
326884,BLOCK,1,,<empty>,,,,1,,ANY
326888,BLOCK,1,,<empty>,,,,1,,ANY
326893,BLOCK,1,,<empty>,,,,1,,ANY
326897,BLOCK,1,,<empty>,,,,1,,ANY
326900,BLOCK,1,,<empty>,,,,1,,ANY
326904,BLOCK,1,,<empty>,,,,1,,ANY
326908,BLOCK,1,,<empty>,,,,1,,ANY
326912,BLOCK,1,,<empty>,,,,1,,ANY
326918,BLOCK,1,,<empty>,,,,1,,ANY
326922,BLOCK,1,,<empty>,,,,1,,ANY
326926,BLOCK,1,,<empty>,,,,1,,ANY
326930,BLOCK,1,,<empty>,,,,1,,ANY
326934,BLOCK,1,,<empty>,,,,1,,ANY
326938,BLOCK,1,,<empty>,,,,1,,ANY
326942,BLOCK,1,,<empty>,,,,1,,ANY
326946,BLOCK,1,,<empty>,,,,1,,ANY
326950,BLOCK,1,,<empty>,,,,1,,ANY
326954,BLOCK,1,,<empty>,,,,1,,ANY
326958,BLOCK,1,,<empty>,,,,1,,ANY
326962,BLOCK,1,,<empty>,,,,1,,ANY
326966,BLOCK,1,,<empty>,,,,1,,ANY
326970,BLOCK,1,,<empty>,,,,1,,ANY
326974,BLOCK,1,,<empty>,,,,1,,ANY
326978,BLOCK,1,,<empty>,,,,1,,ANY
326982,BLOCK,1,,<empty>,,,,1,,ANY
326988,BLOCK,1,,<empty>,,,,1,,ANY
326991,BLOCK,1,,<empty>,,,,1,,ANY
326994,BLOCK,1,,<empty>,,,,1,,ANY
326999,BLOCK,1,,<empty>,,,,1,,ANY
327003,BLOCK,1,,<empty>,,,,1,,ANY
327008,BLOCK,1,,<empty>,,,,1,,ANY
327016,BLOCK,1,,<empty>,,,,1,,ANY
327021,BLOCK,1,,<empty>,,,,1,,ANY
327026,BLOCK,1,,<empty>,,,,1,,ANY
327030,BLOCK,1,,<empty>,,,,1,,ANY
327035,BLOCK,1,,<empty>,,,,1,,ANY
327039,BLOCK,1,,<empty>,,,,1,,ANY
327043,BLOCK,1,,<empty>,,,,1,,ANY
327048,BLOCK,1,,<empty>,,,,1,,ANY
327054,BLOCK,1,,<empty>,,,,1,,ANY
327058,BLOCK,1,,<empty>,,,,1,,ANY
327062,BLOCK,1,,<empty>,,,,1,,ANY
327067,BLOCK,1,,<empty>,,,,1,,ANY
327072,BLOCK,1,,<empty>,,,,1,,ANY
327076,BLOCK,1,,<empty>,,,,1,,ANY
327080,BLOCK,1,,<empty>,,,,1,,ANY
327084,BLOCK,1,,<empty>,,,,1,,ANY
327091,BLOCK,1,,<empty>,,,,1,,ANY
327096,BLOCK,1,,<empty>,,,,1,,ANY
327100,BLOCK,1,,<empty>,,,,1,,ANY
327104,BLOCK,1,,<empty>,,,,1,,ANY
327108,BLOCK,1,,<empty>,,,,1,,ANY
327112,BLOCK,1,,<empty>,,,,1,,ANY
327116,BLOCK,1,,<empty>,,,,1,,ANY
327121,BLOCK,1,,<empty>,,,,1,,ANY
327125,BLOCK,1,,<empty>,,,,1,,ANY
327129,BLOCK,1,,<empty>,,,,1,,ANY
327134,BLOCK,1,,<empty>,,,,1,,ANY
327138,BLOCK,1,,<empty>,,,,1,,ANY
327142,BLOCK,1,,<empty>,,,,1,,ANY
327146,BLOCK,1,,<empty>,,,,1,,ANY
327150,BLOCK,1,,<empty>,,,,1,,ANY
327154,BLOCK,1,,<empty>,,,,1,,ANY
327159,BLOCK,1,,<empty>,,,,1,,ANY
327164,BLOCK,1,,<empty>,,,,1,,ANY
327168,BLOCK,1,,<empty>,,,,1,,ANY
327173,BLOCK,1,,<empty>,,,,1,,ANY
327177,BLOCK,1,,<empty>,,,,1,,ANY
327185,BLOCK,1,,<empty>,,,,1,,ANY
327190,BLOCK,1,,<empty>,,,,1,,ANY
327196,BLOCK,1,,<empty>,,,,1,,ANY
327202,BLOCK,1,,<empty>,,,,1,,ANY
327208,BLOCK,1,,<empty>,,,,1,,ANY
327212,BLOCK,1,,<empty>,,,,1,,ANY
327216,BLOCK,1,,<empty>,,,,1,,ANY
327220,BLOCK,1,,<empty>,,,,1,,ANY
327224,BLOCK,1,,<empty>,,,,1,,ANY
327228,BLOCK,1,,<empty>,,,,1,,ANY
327232,BLOCK,1,,<empty>,,,,1,,ANY
327236,BLOCK,1,,<empty>,,,,1,,ANY
327240,BLOCK,1,,<empty>,,,,1,,ANY
327244,BLOCK,1,,<empty>,,,,1,,ANY
327248,BLOCK,1,,<empty>,,,,1,,ANY
327252,BLOCK,1,,<empty>,,,,1,,ANY
327256,BLOCK,1,,<empty>,,,,1,,ANY
327260,BLOCK,1,,<empty>,,,,1,,ANY
327264,BLOCK,1,,<empty>,,,,1,,ANY
327269,BLOCK,1,,<empty>,,,,1,,ANY
327273,BLOCK,1,,<empty>,,,,1,,ANY
327277,BLOCK,1,,<empty>,,,,1,,ANY
327283,BLOCK,1,,<empty>,,,,1,,ANY
327289,BLOCK,1,,<empty>,,,,1,,ANY
327293,BLOCK,1,,<empty>,,,,1,,ANY
327305,BLOCK,1,,<empty>,,,,1,,ANY
327310,BLOCK,1,,<empty>,,,,1,,ANY
327316,BLOCK,1,,<empty>,,,,1,,ANY
327321,BLOCK,1,,<empty>,,,,1,,ANY
327329,BLOCK,1,,<empty>,,,,1,,ANY
327334,BLOCK,1,,<empty>,,,,1,,ANY
327340,BLOCK,1,,<empty>,,,,1,,ANY
327347,BLOCK,1,,<empty>,,,,1,,ANY
327353,BLOCK,1,,<empty>,,,,1,,ANY
327359,BLOCK,1,,<empty>,,,,1,,ANY
327365,BLOCK,1,,<empty>,,,,1,,ANY
327370,BLOCK,1,,<empty>,,,,1,,ANY
327376,BLOCK,1,,<empty>,,,,1,,ANY
327382,BLOCK,1,,<empty>,,,,1,,ANY
327388,BLOCK,1,,<empty>,,,,1,,ANY
327392,BLOCK,1,,<empty>,,,,1,,ANY
327397,BLOCK,1,,<empty>,,,,1,,ANY
327402,BLOCK,1,,<empty>,,,,1,,ANY
327407,BLOCK,1,,<empty>,,,,1,,ANY
327411,BLOCK,1,,<empty>,,,,1,,ANY
327417,BLOCK,1,,<empty>,,,,1,,ANY
327421,BLOCK,1,,<empty>,,,,1,,ANY
327426,BLOCK,1,,<empty>,,,,1,,ANY
327431,BLOCK,1,,<empty>,,,,1,,ANY
327436,BLOCK,1,,<empty>,,,,1,,ANY
327440,BLOCK,1,,<empty>,,,,1,,ANY
327444,BLOCK,1,,<empty>,,,,1,,ANY
327450,BLOCK,1,,<empty>,,,,1,,ANY
327453,BLOCK,1,,<empty>,,,,1,,ANY
327457,BLOCK,1,,<empty>,,,,1,,ANY
327462,BLOCK,1,,<empty>,,,,1,,ANY
327466,BLOCK,1,,<empty>,,,,1,,ANY
327470,BLOCK,1,,<empty>,,,,1,,ANY
327473,BLOCK,1,,<empty>,,,,1,,ANY
327476,BLOCK,1,,<empty>,,,,1,,ANY
327479,BLOCK,1,,<empty>,,,,1,,ANY
327484,BLOCK,1,,<empty>,,,,1,,ANY
327489,BLOCK,1,,<empty>,,,,1,,ANY
327494,BLOCK,1,,<empty>,,,,1,,ANY
327498,BLOCK,1,,<empty>,,,,1,,ANY
327502,BLOCK,1,,<empty>,,,,1,,ANY
327506,BLOCK,1,,<empty>,,,,1,,ANY
327510,BLOCK,1,,<empty>,,,,1,,ANY
327516,BLOCK,1,,<empty>,,,,1,,ANY
327519,BLOCK,1,,<empty>,,,,1,,ANY
327523,BLOCK,1,,<empty>,,,,1,,ANY
327529,BLOCK,1,,<empty>,,,,1,,ANY
327534,BLOCK,1,,<empty>,,,,1,,ANY
327539,BLOCK,1,,<empty>,,,,1,,ANY
327544,BLOCK,1,,<empty>,,,,1,,ANY
327550,BLOCK,1,,<empty>,,,,1,,ANY
327554,BLOCK,1,,<empty>,,,,1,,ANY
327558,BLOCK,1,,<empty>,,,,1,,ANY
327563,BLOCK,1,,<empty>,,,,1,,ANY
327567,BLOCK,1,,<empty>,,,,1,,ANY
327573,BLOCK,1,,<empty>,,,,1,,ANY
327577,BLOCK,1,,<empty>,,,,1,,ANY
327582,BLOCK,1,,<empty>,,,,1,,ANY
327587,BLOCK,1,,<empty>,,,,1,,ANY
327593,BLOCK,1,,<empty>,,,,1,,ANY
327597,BLOCK,1,,<empty>,,,,1,,ANY
327602,BLOCK,1,,<empty>,,,,1,,ANY
327607,BLOCK,1,,<empty>,,,,1,,ANY
327612,BLOCK,1,,<empty>,,,,1,,ANY
327616,BLOCK,1,,<empty>,,,,1,,ANY
327620,BLOCK,1,,<empty>,,,,1,,ANY
327626,BLOCK,1,,<empty>,,,,1,,ANY
327629,BLOCK,1,,<empty>,,,,1,,ANY
327634,BLOCK,1,,<empty>,,,,1,,ANY
327639,BLOCK,1,,<empty>,,,,1,,ANY
327643,BLOCK,1,,<empty>,,,,1,,ANY
327647,BLOCK,1,,<empty>,,,,1,,ANY
327652,BLOCK,1,,<empty>,,,,1,,ANY
327655,BLOCK,1,,<empty>,,,,1,,ANY
327658,BLOCK,1,,<empty>,,,,1,,ANY
327662,BLOCK,1,,<empty>,,,,1,,ANY
327666,BLOCK,1,,<empty>,,,,1,,ANY
327671,BLOCK,1,,<empty>,,,,1,,ANY
327674,BLOCK,1,,<empty>,,,,1,,ANY
327677,BLOCK,1,,<empty>,,,,1,,ANY
327680,BLOCK,1,,<empty>,,,,1,,ANY
327683,BLOCK,1,,<empty>,,,,1,,ANY
327687,BLOCK,1,,<empty>,,,,1,,ANY
327691,BLOCK,1,,<empty>,,,,1,,ANY
327695,BLOCK,1,,<empty>,,,,1,,ANY
327699,BLOCK,1,,<empty>,,,,1,,ANY
327703,BLOCK,1,,<empty>,,,,1,,ANY
327706,BLOCK,1,,<empty>,,,,1,,ANY
327711,BLOCK,1,,<empty>,,,,1,,ANY
327716,BLOCK,1,,<empty>,,,,1,,ANY
327721,BLOCK,1,,<empty>,,,,1,,ANY
327726,BLOCK,1,,<empty>,,,,1,,ANY
327730,BLOCK,1,,<empty>,,,,1,,ANY
327733,BLOCK,1,,<empty>,,,,1,,ANY
327737,BLOCK,1,,<empty>,,,,1,,ANY
327741,BLOCK,1,,<empty>,,,,1,,ANY
327745,BLOCK,1,,<empty>,,,,1,,ANY
327749,BLOCK,1,,<empty>,,,,1,,ANY
327753,BLOCK,1,,<empty>,,,,1,,ANY
327757,BLOCK,1,,<empty>,,,,1,,ANY
327761,BLOCK,1,,<empty>,,,,1,,ANY
327765,BLOCK,1,,<empty>,,,,1,,ANY
327771,BLOCK,1,,<empty>,,,,1,,ANY
327776,BLOCK,1,,<empty>,,,,1,,ANY
327782,BLOCK,1,,<empty>,,,,1,,ANY
327786,BLOCK,1,,<empty>,,,,1,,ANY
327790,BLOCK,1,,<empty>,,,,1,,ANY
327793,BLOCK,1,,<empty>,,,,1,,ANY
327801,BLOCK,1,,<empty>,,,,1,,ANY
327807,BLOCK,1,,<empty>,,,,1,,ANY
327811,BLOCK,1,,<empty>,,,,1,,ANY
327819,BLOCK,1,,<empty>,,,,1,,ANY
327824,BLOCK,1,,<empty>,,,,1,,ANY
327830,BLOCK,1,,<empty>,,,,1,,ANY
327835,BLOCK,1,,<empty>,,,,1,,ANY
327839,BLOCK,1,,<empty>,,,,1,,ANY
327843,BLOCK,1,,<empty>,,,,1,,ANY
327850,BLOCK,1,,<empty>,,,,1,,ANY
327855,BLOCK,1,,<empty>,,,,1,,ANY
327859,BLOCK,1,,<empty>,,,,1,,ANY
327863,BLOCK,1,,<empty>,,,,1,,ANY
327867,BLOCK,1,,<empty>,,,,1,,ANY
327872,BLOCK,1,,<empty>,,,,1,,ANY
327877,BLOCK,1,,<empty>,,,,1,,ANY
327882,BLOCK,1,,<empty>,,,,1,,ANY
327886,BLOCK,1,,<empty>,,,,1,,ANY
327893,BLOCK,1,,<empty>,,,,1,,ANY
327897,BLOCK,1,,<empty>,,,,1,,ANY
327901,BLOCK,1,,<empty>,,,,1,,ANY
327908,BLOCK,1,,<empty>,,,,1,,ANY
327913,BLOCK,1,,<empty>,,,,1,,ANY
327917,BLOCK,1,,<empty>,,,,1,,ANY
327922,BLOCK,1,,<empty>,,,,1,,ANY
327927,BLOCK,1,,<empty>,,,,1,,ANY
327932,BLOCK,1,,<empty>,,,,1,,ANY
327937,BLOCK,1,,<empty>,,,,1,,ANY
327942,BLOCK,1,,<empty>,,,,1,,ANY
327947,BLOCK,1,,<empty>,,,,1,,ANY
327953,BLOCK,1,,<empty>,,,,1,,ANY
327959,BLOCK,1,,<empty>,,,,1,,ANY
327965,BLOCK,1,,<empty>,,,,1,,ANY
327971,BLOCK,1,,<empty>,,,,1,,ANY
327976,BLOCK,1,,<empty>,,,,1,,ANY
327981,BLOCK,1,,<empty>,,,,1,,ANY
327987,BLOCK,1,,<empty>,,,,1,,ANY
327992,BLOCK,1,,<empty>,,,,1,,ANY
327997,BLOCK,1,,<empty>,,,,1,,ANY
328001,BLOCK,1,,<empty>,,,,1,,ANY
328004,BLOCK,1,,<empty>,,,,1,,ANY
328010,BLOCK,1,,<empty>,,,,1,,ANY
328015,BLOCK,1,,<empty>,,,,1,,ANY
328021,BLOCK,1,,<empty>,,,,1,,ANY
328027,BLOCK,1,,<empty>,,,,1,,ANY
328032,BLOCK,1,,<empty>,,,,1,,ANY
328037,BLOCK,1,,<empty>,,,,1,,ANY
328043,BLOCK,1,,<empty>,,,,1,,ANY
328047,BLOCK,1,,<empty>,,,,1,,ANY
328052,BLOCK,1,,<empty>,,,,1,,ANY
328055,BLOCK,1,,<empty>,,,,1,,ANY
328059,BLOCK,1,,<empty>,,,,1,,ANY
328063,BLOCK,1,,<empty>,,,,1,,ANY
328068,BLOCK,1,,<empty>,,,,1,,ANY
328072,BLOCK,1,,<empty>,,,,1,,ANY
328076,BLOCK,1,,<empty>,,,,1,,ANY
328080,BLOCK,1,,<empty>,,,,1,,ANY
328085,BLOCK,1,,<empty>,,,,1,,ANY
328091,BLOCK,1,,<empty>,,,,1,,ANY
328096,BLOCK,1,,<empty>,,,,1,,ANY
328104,BLOCK,1,,<empty>,,,,1,,ANY
328111,BLOCK,1,,<empty>,,,,1,,ANY
328116,BLOCK,1,,<empty>,,,,1,,ANY
328120,BLOCK,1,,<empty>,,,,1,,ANY
328124,BLOCK,1,,<empty>,,,,1,,ANY
328133,BLOCK,1,,<empty>,,,,1,,ANY
328139,BLOCK,1,,<empty>,,,,1,,ANY
328143,BLOCK,1,,<empty>,,,,1,,ANY
328147,BLOCK,1,,<empty>,,,,1,,ANY
328153,BLOCK,1,,<empty>,,,,1,,ANY
328158,BLOCK,1,,<empty>,,,,1,,ANY
328163,BLOCK,1,,<empty>,,,,1,,ANY
328171,BLOCK,1,,<empty>,,,,1,,ANY
328179,BLOCK,1,,<empty>,,,,1,,ANY
328187,BLOCK,1,,<empty>,,,,1,,ANY
328195,BLOCK,1,,<empty>,,,,1,,ANY
328199,BLOCK,1,,<empty>,,,,1,,ANY
328202,BLOCK,1,,<empty>,,,,1,,ANY
328208,BLOCK,1,,<empty>,,,,1,,ANY
328214,BLOCK,1,,<empty>,,,,1,,ANY
328218,BLOCK,1,,<empty>,,,,1,,ANY
328223,BLOCK,1,,<empty>,,,,1,,ANY
328228,BLOCK,1,,<empty>,,,,1,,ANY
328232,BLOCK,1,,<empty>,,,,1,,ANY
328236,BLOCK,1,,<empty>,,,,1,,ANY
328240,BLOCK,1,,<empty>,,,,1,,ANY
328244,BLOCK,1,,<empty>,,,,1,,ANY
328248,BLOCK,1,,<empty>,,,,1,,ANY
328251,BLOCK,1,,<empty>,,,,1,,ANY
328256,BLOCK,1,,<empty>,,,,1,,ANY
328261,BLOCK,1,,<empty>,,,,1,,ANY
328265,BLOCK,1,,<empty>,,,,1,,ANY
328270,BLOCK,1,,<empty>,,,,1,,ANY
328275,BLOCK,1,,<empty>,,,,1,,ANY
328279,BLOCK,1,,<empty>,,,,1,,ANY
328284,BLOCK,1,,<empty>,,,,1,,ANY
328289,BLOCK,1,,<empty>,,,,1,,ANY
328294,BLOCK,1,,<empty>,,,,1,,ANY
328298,BLOCK,1,,<empty>,,,,1,,ANY
328304,BLOCK,1,,<empty>,,,,1,,ANY
328308,BLOCK,1,,<empty>,,,,1,,ANY
328313,BLOCK,1,,<empty>,,,,1,,ANY
328318,BLOCK,1,,<empty>,,,,1,,ANY
328323,BLOCK,1,,<empty>,,,,1,,ANY
328328,BLOCK,1,,<empty>,,,,1,,ANY
328333,BLOCK,1,,<empty>,,,,1,,ANY
328338,BLOCK,1,,<empty>,,,,1,,ANY
328343,BLOCK,1,,<empty>,,,,1,,ANY
328348,BLOCK,1,,<empty>,,,,1,,ANY
328353,BLOCK,1,,<empty>,,,,1,,ANY
328357,BLOCK,1,,<empty>,,,,1,,ANY
328361,BLOCK,1,,<empty>,,,,1,,ANY
328365,BLOCK,1,,<empty>,,,,1,,ANY
328369,BLOCK,1,,<empty>,,,,1,,ANY
328373,BLOCK,1,,<empty>,,,,1,,ANY
328378,BLOCK,1,,<empty>,,,,1,,ANY
328382,BLOCK,1,,<empty>,,,,1,,ANY
328386,BLOCK,1,,<empty>,,,,1,,ANY
328391,BLOCK,1,,<empty>,,,,1,,ANY
328395,BLOCK,1,,<empty>,,,,1,,ANY
328399,BLOCK,1,,<empty>,,,,1,,ANY
328403,BLOCK,1,,<empty>,,,,1,,ANY
328406,BLOCK,1,,<empty>,,,,1,,ANY
328412,BLOCK,1,,<empty>,,,,1,,ANY
328418,BLOCK,1,,<empty>,,,,1,,ANY
328424,BLOCK,1,,<empty>,,,,1,,ANY
328427,BLOCK,1,,<empty>,,,,1,,ANY
328433,BLOCK,1,,<empty>,,,,1,,ANY
328439,BLOCK,1,,<empty>,,,,1,,ANY
328445,BLOCK,1,,<empty>,,,,1,,ANY
328448,BLOCK,1,,<empty>,,,,1,,ANY
328454,BLOCK,1,,<empty>,,,,1,,ANY
328460,BLOCK,1,,<empty>,,,,1,,ANY
328466,BLOCK,1,,<empty>,,,,1,,ANY
328472,BLOCK,1,,<empty>,,,,1,,ANY
328478,BLOCK,1,,<empty>,,,,1,,ANY
328484,BLOCK,1,,<empty>,,,,1,,ANY
328487,BLOCK,1,,<empty>,,,,1,,ANY
328491,BLOCK,1,,<empty>,,,,1,,ANY
328494,BLOCK,1,,<empty>,,,,1,,ANY
328497,BLOCK,1,,<empty>,,,,1,,ANY
328501,BLOCK,1,,<empty>,,,,1,,ANY
328506,BLOCK,1,,<empty>,,,,1,,ANY
328510,BLOCK,1,,<empty>,,,,1,,ANY
328514,BLOCK,1,,<empty>,,,,1,,ANY
328519,BLOCK,1,,<empty>,,,,1,,ANY
328523,BLOCK,1,,<empty>,,,,1,,ANY
328527,BLOCK,1,,<empty>,,,,1,,ANY
328532,BLOCK,1,,<empty>,,,,1,,ANY
328536,BLOCK,1,,<empty>,,,,1,,ANY
328540,BLOCK,1,,<empty>,,,,1,,ANY
328544,BLOCK,1,,<empty>,,,,1,,ANY
328549,BLOCK,1,,<empty>,,,,1,,ANY
328555,BLOCK,1,,<empty>,,,,1,,ANY
328559,BLOCK,1,,<empty>,,,,1,,ANY
328563,BLOCK,1,,<empty>,,,,1,,ANY
328568,BLOCK,1,,<empty>,,,,1,,ANY
328573,BLOCK,1,,<empty>,,,,1,,ANY
328578,BLOCK,1,,<empty>,,,,1,,ANY
328581,BLOCK,1,,<empty>,,,,1,,ANY
328586,BLOCK,1,,<empty>,,,,1,,ANY
328589,BLOCK,1,,<empty>,,,,1,,ANY
328594,BLOCK,1,,<empty>,,,,1,,ANY
328600,BLOCK,1,,<empty>,,,,1,,ANY
328604,BLOCK,1,,<empty>,,,,1,,ANY
328610,BLOCK,1,,<empty>,,,,1,,ANY
328616,BLOCK,1,,<empty>,,,,1,,ANY
328620,BLOCK,1,,<empty>,,,,1,,ANY
328624,BLOCK,1,,<empty>,,,,1,,ANY
328628,BLOCK,1,,<empty>,,,,1,,ANY
328635,BLOCK,1,,<empty>,,,,1,,ANY
328639,BLOCK,1,,<empty>,,,,1,,ANY
328646,BLOCK,1,,<empty>,,,,1,,ANY
328652,BLOCK,1,,<empty>,,,,1,,ANY
328658,BLOCK,1,,<empty>,,,,1,,ANY
328664,BLOCK,1,,<empty>,,,,1,,ANY
328670,BLOCK,1,,<empty>,,,,1,,ANY
328676,BLOCK,1,,<empty>,,,,1,,ANY
328682,BLOCK,1,,<empty>,,,,1,,ANY
328688,BLOCK,1,,<empty>,,,,1,,ANY
328694,BLOCK,1,,<empty>,,,,1,,ANY
328701,BLOCK,1,,<empty>,,,,1,,ANY
328705,BLOCK,1,,<empty>,,,,1,,ANY
328711,BLOCK,1,,<empty>,,,,1,,ANY
328717,BLOCK,1,,<empty>,,,,1,,ANY
328725,BLOCK,1,,<empty>,,,,1,,ANY
328732,BLOCK,1,,<empty>,,,,1,,ANY
328737,BLOCK,1,,<empty>,,,,1,,ANY
328742,BLOCK,1,,<empty>,,,,1,,ANY
328748,BLOCK,1,,<empty>,,,,1,,ANY
328754,BLOCK,1,,<empty>,,,,1,,ANY
328760,BLOCK,1,,<empty>,,,,1,,ANY
328767,BLOCK,1,,<empty>,,,,1,,ANY
328773,BLOCK,1,,<empty>,,,,1,,ANY
328779,BLOCK,1,,<empty>,,,,1,,ANY
328785,BLOCK,1,,<empty>,,,,1,,ANY
328793,BLOCK,1,,<empty>,,,,1,,ANY
328801,BLOCK,1,,<empty>,,,,1,,ANY
328810,BLOCK,1,,<empty>,,,,1,,ANY
328816,BLOCK,1,,<empty>,,,,1,,ANY
328822,BLOCK,1,,<empty>,,,,1,,ANY
328829,BLOCK,1,,<empty>,,,,1,,ANY
328837,BLOCK,1,,<empty>,,,,1,,ANY
328846,BLOCK,1,,<empty>,,,,1,,ANY
328854,BLOCK,1,,<empty>,,,,1,,ANY
328863,BLOCK,1,,<empty>,,,,1,,ANY
328869,BLOCK,1,,<empty>,,,,1,,ANY
328877,BLOCK,1,,<empty>,,,,1,,ANY
328883,BLOCK,1,,<empty>,,,,1,,ANY
328888,BLOCK,1,,<empty>,,,,1,,ANY
328894,BLOCK,1,,<empty>,,,,1,,ANY
328902,BLOCK,1,,<empty>,,,,1,,ANY
328909,BLOCK,1,,<empty>,,,,1,,ANY
328918,BLOCK,1,,<empty>,,,,1,,ANY
328929,BLOCK,1,,<empty>,,,,1,,ANY
328940,BLOCK,1,,<empty>,,,,1,,ANY
328953,BLOCK,1,,<empty>,,,,1,,ANY
328963,BLOCK,1,,<empty>,,,,1,,ANY
328970,BLOCK,1,,<empty>,,,,1,,ANY
328980,BLOCK,1,,<empty>,,,,1,,ANY
328989,BLOCK,1,,<empty>,,,,1,,ANY
328996,BLOCK,1,,<empty>,,,,1,,ANY
329002,BLOCK,1,,<empty>,,,,1,,ANY
329010,BLOCK,1,,<empty>,,,,1,,ANY
329016,BLOCK,1,,<empty>,,,,1,,ANY
329021,BLOCK,1,,<empty>,,,,1,,ANY
329026,BLOCK,1,,<empty>,,,,1,,ANY
329032,BLOCK,1,,<empty>,,,,1,,ANY
329036,BLOCK,1,,<empty>,,,,1,,ANY
329043,BLOCK,1,,<empty>,,,,1,,ANY
329047,BLOCK,1,,<empty>,,,,1,,ANY
329057,BLOCK,1,,<empty>,,,,1,,ANY
329063,BLOCK,1,,<empty>,,,,1,,ANY
329067,BLOCK,1,,<empty>,,,,1,,ANY
329076,BLOCK,1,,<empty>,,,,1,,ANY
329082,BLOCK,1,,<empty>,,,,1,,ANY
329086,BLOCK,1,,<empty>,,,,1,,ANY
329090,BLOCK,1,,<empty>,,,,1,,ANY
329094,BLOCK,1,,<empty>,,,,1,,ANY
329102,BLOCK,1,,<empty>,,,,1,,ANY
329110,BLOCK,1,,<empty>,,,,1,,ANY
329118,BLOCK,1,,<empty>,,,,1,,ANY
329126,BLOCK,1,,<empty>,,,,1,,ANY
329134,BLOCK,1,,<empty>,,,,1,,ANY
329142,BLOCK,1,,<empty>,,,,1,,ANY
329150,BLOCK,1,,<empty>,,,,1,,ANY
329158,BLOCK,1,,<empty>,,,,1,,ANY
329166,BLOCK,1,,<empty>,,,,1,,ANY
329174,BLOCK,1,,<empty>,,,,1,,ANY
329182,BLOCK,1,,<empty>,,,,1,,ANY
329190,BLOCK,1,,<empty>,,,,1,,ANY
329198,BLOCK,1,,<empty>,,,,1,,ANY
329206,BLOCK,1,,<empty>,,,,1,,ANY
329214,BLOCK,1,,<empty>,,,,1,,ANY
329222,BLOCK,1,,<empty>,,,,1,,ANY
329230,BLOCK,1,,<empty>,,,,1,,ANY
329238,BLOCK,1,,<empty>,,,,1,,ANY
329246,BLOCK,1,,<empty>,,,,1,,ANY
329254,BLOCK,1,,<empty>,,,,1,,ANY
329262,BLOCK,1,,<empty>,,,,1,,ANY
329270,BLOCK,1,,<empty>,,,,1,,ANY
329278,BLOCK,1,,<empty>,,,,1,,ANY
329286,BLOCK,1,,<empty>,,,,1,,ANY
329294,BLOCK,1,,<empty>,,,,1,,ANY
329302,BLOCK,1,,<empty>,,,,1,,ANY
329310,BLOCK,1,,<empty>,,,,1,,ANY
329318,BLOCK,1,,<empty>,,,,1,,ANY
329326,BLOCK,1,,<empty>,,,,1,,ANY
329334,BLOCK,1,,<empty>,,,,1,,ANY
329342,BLOCK,1,,<empty>,,,,1,,ANY
329350,BLOCK,1,,<empty>,,,,1,,ANY
329358,BLOCK,1,,<empty>,,,,1,,ANY
329366,BLOCK,1,,<empty>,,,,1,,ANY
329374,BLOCK,1,,<empty>,,,,1,,ANY
329382,BLOCK,1,,<empty>,,,,1,,ANY
329390,BLOCK,1,,<empty>,,,,1,,ANY
329398,BLOCK,1,,<empty>,,,,1,,ANY
329406,BLOCK,1,,<empty>,,,,1,,ANY
329414,BLOCK,1,,<empty>,,,,1,,ANY
329422,BLOCK,1,,<empty>,,,,1,,ANY
329430,BLOCK,1,,<empty>,,,,1,,ANY
329438,BLOCK,1,,<empty>,,,,1,,ANY
329446,BLOCK,1,,<empty>,,,,1,,ANY
329454,BLOCK,1,,<empty>,,,,1,,ANY
329462,BLOCK,1,,<empty>,,,,1,,ANY
329469,BLOCK,1,,<empty>,,,,1,,ANY
329473,BLOCK,1,,<empty>,,,,1,,ANY
329478,BLOCK,1,,<empty>,,,,1,,ANY
329483,BLOCK,1,,<empty>,,,,1,,ANY
329489,BLOCK,1,,<empty>,,,,1,,ANY
329495,BLOCK,1,,<empty>,,,,1,,ANY
329501,BLOCK,1,,<empty>,,,,1,,ANY
329507,BLOCK,1,,<empty>,,,,1,,ANY
329511,BLOCK,1,,<empty>,,,,1,,ANY
329516,BLOCK,1,,<empty>,,,,1,,ANY
329521,BLOCK,1,,<empty>,,,,1,,ANY
329525,BLOCK,1,,<empty>,,,,1,,ANY
329529,BLOCK,1,,<empty>,,,,1,,ANY
329534,BLOCK,1,,<empty>,,,,1,,ANY
329541,BLOCK,1,,<empty>,,,,1,,ANY
329544,BLOCK,1,,<empty>,,,,1,,ANY
329548,BLOCK,1,,<empty>,,,,1,,ANY
329552,BLOCK,1,,<empty>,,,,1,,ANY
329556,BLOCK,1,,<empty>,,,,1,,ANY
329560,BLOCK,1,,<empty>,,,,1,,ANY
329565,BLOCK,1,,<empty>,,,,1,,ANY
329571,BLOCK,1,,<empty>,,,,1,,ANY
329576,BLOCK,1,,<empty>,,,,1,,ANY
329580,BLOCK,1,,<empty>,,,,1,,ANY
329586,BLOCK,1,,<empty>,,,,1,,ANY
329590,BLOCK,1,,<empty>,,,,1,,ANY
329594,BLOCK,1,,<empty>,,,,1,,ANY
329599,BLOCK,1,,<empty>,,,,1,,ANY
329603,BLOCK,1,,<empty>,,,,1,,ANY
329608,BLOCK,1,,<empty>,,,,1,,ANY
329613,BLOCK,1,,<empty>,,,,1,,ANY
329618,BLOCK,1,,<empty>,,,,1,,ANY
329623,BLOCK,1,,<empty>,,,,1,,ANY
329627,BLOCK,1,,<empty>,,,,1,,ANY
329632,BLOCK,1,,<empty>,,,,1,,ANY
329638,BLOCK,1,,<empty>,,,,1,,ANY
329643,BLOCK,1,,<empty>,,,,1,,ANY
329648,BLOCK,1,,<empty>,,,,1,,ANY
329653,BLOCK,1,,<empty>,,,,1,,ANY
329657,BLOCK,1,,<empty>,,,,1,,ANY
329661,BLOCK,1,,<empty>,,,,1,,ANY
329665,BLOCK,1,,<empty>,,,,1,,ANY
329668,BLOCK,1,,<empty>,,,,1,,ANY
329673,BLOCK,1,,<empty>,,,,1,,ANY
329677,BLOCK,1,,<empty>,,,,1,,ANY
329682,BLOCK,1,,<empty>,,,,1,,ANY
329686,BLOCK,1,,<empty>,,,,1,,ANY
329690,BLOCK,1,,<empty>,,,,1,,ANY
329694,BLOCK,1,,<empty>,,,,1,,ANY
329700,BLOCK,1,,<empty>,,,,1,,ANY
329704,BLOCK,1,,<empty>,,,,1,,ANY
329708,BLOCK,1,,<empty>,,,,1,,ANY
329713,BLOCK,1,,<empty>,,,,1,,ANY
329718,BLOCK,1,,<empty>,,,,1,,ANY
329722,BLOCK,1,,<empty>,,,,1,,ANY
329729,BLOCK,1,,<empty>,,,,1,,ANY
329734,BLOCK,1,,<empty>,,,,1,,ANY
329739,BLOCK,1,,<empty>,,,,1,,ANY
329744,BLOCK,1,,<empty>,,,,1,,ANY
329751,BLOCK,1,,<empty>,,,,1,,ANY
329756,BLOCK,1,,<empty>,,,,1,,ANY
329760,BLOCK,1,,<empty>,,,,1,,ANY
329764,BLOCK,1,,<empty>,,,,1,,ANY
329769,BLOCK,1,,<empty>,,,,1,,ANY
329777,BLOCK,1,,<empty>,,,,1,,ANY
329785,BLOCK,1,,<empty>,,,,1,,ANY
329793,BLOCK,1,,<empty>,,,,1,,ANY
329801,BLOCK,1,,<empty>,,,,1,,ANY
329809,BLOCK,1,,<empty>,,,,1,,ANY
329812,BLOCK,1,,<empty>,,,,1,,ANY
329816,BLOCK,1,,<empty>,,,,1,,ANY
329825,BLOCK,1,,<empty>,,,,1,,ANY
329833,BLOCK,1,,<empty>,,,,1,,ANY
329838,BLOCK,1,,<empty>,,,,1,,ANY
329842,BLOCK,1,,<empty>,,,,1,,ANY
329846,BLOCK,1,,<empty>,,,,1,,ANY
329850,BLOCK,1,,<empty>,,,,1,,ANY
329853,BLOCK,1,,<empty>,,,,1,,ANY
329856,BLOCK,1,,<empty>,,,,1,,ANY
329862,BLOCK,1,,<empty>,,,,1,,ANY
329866,BLOCK,1,,<empty>,,,,1,,ANY
329870,BLOCK,1,,<empty>,,,,1,,ANY
329875,BLOCK,1,,<empty>,,,,1,,ANY
329880,BLOCK,1,,<empty>,,,,1,,ANY
329884,BLOCK,1,,<empty>,,,,1,,ANY
329890,BLOCK,1,,<empty>,,,,1,,ANY
329895,BLOCK,1,,<empty>,,,,1,,ANY
329900,BLOCK,1,,<empty>,,,,1,,ANY
329904,BLOCK,1,,<empty>,,,,1,,ANY
329910,BLOCK,1,,<empty>,,,,1,,ANY
329916,BLOCK,1,,<empty>,,,,1,,ANY
329921,BLOCK,1,,<empty>,,,,1,,ANY
329926,BLOCK,1,,<empty>,,,,1,,ANY
329929,BLOCK,1,,<empty>,,,,1,,ANY
329933,BLOCK,1,,<empty>,,,,1,,ANY
329939,BLOCK,1,,<empty>,,,,1,,ANY
329946,BLOCK,1,,<empty>,,,,1,,ANY
329952,BLOCK,1,,<empty>,,,,1,,ANY
329956,BLOCK,1,,<empty>,,,,1,,ANY
329960,BLOCK,1,,<empty>,,,,1,,ANY
329964,BLOCK,1,,<empty>,,,,1,,ANY
329967,BLOCK,1,,<empty>,,,,1,,ANY
329972,BLOCK,1,,<empty>,,,,1,,ANY
329978,BLOCK,1,,<empty>,,,,1,,ANY
329981,BLOCK,1,,<empty>,,,,1,,ANY
329985,BLOCK,1,,<empty>,,,,1,,ANY
329989,BLOCK,1,,<empty>,,,,1,,ANY
329993,BLOCK,1,,<empty>,,,,1,,ANY
329997,BLOCK,1,,<empty>,,,,1,,ANY
330001,BLOCK,1,,<empty>,,,,1,,ANY
330005,BLOCK,1,,<empty>,,,,1,,ANY
330008,BLOCK,1,,<empty>,,,,1,,ANY
330011,BLOCK,1,,<empty>,,,,1,,ANY
330014,BLOCK,1,,<empty>,,,,1,,ANY
330017,BLOCK,1,,<empty>,,,,1,,ANY
330020,BLOCK,1,,<empty>,,,,1,,ANY
330023,BLOCK,1,,<empty>,,,,1,,ANY
330026,BLOCK,1,,<empty>,,,,1,,ANY
330035,BLOCK,1,,<empty>,,,,1,,ANY
330040,BLOCK,1,,<empty>,,,,1,,ANY
330046,BLOCK,1,,<empty>,,,,1,,ANY
330052,BLOCK,1,,<empty>,,,,1,,ANY
330062,BLOCK,1,,<empty>,,,,1,,ANY
330068,BLOCK,1,,<empty>,,,,1,,ANY
330074,BLOCK,1,,<empty>,,,,1,,ANY
330080,BLOCK,1,,<empty>,,,,1,,ANY
330089,BLOCK,1,,<empty>,,,,1,,ANY
330093,BLOCK,1,,<empty>,,,,1,,ANY
330097,BLOCK,1,,<empty>,,,,1,,ANY
330103,BLOCK,1,,<empty>,,,,1,,ANY
330109,BLOCK,1,,<empty>,,,,1,,ANY
330115,BLOCK,1,,<empty>,,,,1,,ANY
330120,BLOCK,1,,<empty>,,,,1,,ANY
330125,BLOCK,1,,<empty>,,,,1,,ANY
330130,BLOCK,1,,<empty>,,,,1,,ANY
330138,BLOCK,1,,<empty>,,,,1,,ANY
330146,BLOCK,1,,<empty>,,,,1,,ANY
330154,BLOCK,1,,<empty>,,,,1,,ANY
330162,BLOCK,1,,<empty>,,,,1,,ANY
330170,BLOCK,1,,<empty>,,,,1,,ANY
330178,BLOCK,1,,<empty>,,,,1,,ANY
330186,BLOCK,1,,<empty>,,,,1,,ANY
330194,BLOCK,1,,<empty>,,,,1,,ANY
330202,BLOCK,1,,<empty>,,,,1,,ANY
330210,BLOCK,1,,<empty>,,,,1,,ANY
330218,BLOCK,1,,<empty>,,,,1,,ANY
330226,BLOCK,1,,<empty>,,,,1,,ANY
330234,BLOCK,1,,<empty>,,,,1,,ANY
330242,BLOCK,1,,<empty>,,,,1,,ANY
330250,BLOCK,1,,<empty>,,,,1,,ANY
330258,BLOCK,1,,<empty>,,,,1,,ANY
330266,BLOCK,1,,<empty>,,,,1,,ANY
330274,BLOCK,1,,<empty>,,,,1,,ANY
330282,BLOCK,1,,<empty>,,,,1,,ANY
330290,BLOCK,1,,<empty>,,,,1,,ANY
330298,BLOCK,1,,<empty>,,,,1,,ANY
330306,BLOCK,1,,<empty>,,,,1,,ANY
330314,BLOCK,1,,<empty>,,,,1,,ANY
330322,BLOCK,1,,<empty>,,,,1,,ANY
330330,BLOCK,1,,<empty>,,,,1,,ANY
330338,BLOCK,1,,<empty>,,,,1,,ANY
330346,BLOCK,1,,<empty>,,,,1,,ANY
330354,BLOCK,1,,<empty>,,,,1,,ANY
330362,BLOCK,1,,<empty>,,,,1,,ANY
330370,BLOCK,1,,<empty>,,,,1,,ANY
330378,BLOCK,1,,<empty>,,,,1,,ANY
330386,BLOCK,1,,<empty>,,,,1,,ANY
330394,BLOCK,1,,<empty>,,,,1,,ANY
330402,BLOCK,1,,<empty>,,,,1,,ANY
330410,BLOCK,1,,<empty>,,,,1,,ANY
330418,BLOCK,1,,<empty>,,,,1,,ANY
330426,BLOCK,1,,<empty>,,,,1,,ANY
330434,BLOCK,1,,<empty>,,,,1,,ANY
330442,BLOCK,1,,<empty>,,,,1,,ANY
330450,BLOCK,1,,<empty>,,,,1,,ANY
330458,BLOCK,1,,<empty>,,,,1,,ANY
330466,BLOCK,1,,<empty>,,,,1,,ANY
330474,BLOCK,1,,<empty>,,,,1,,ANY
330482,BLOCK,1,,<empty>,,,,1,,ANY
330490,BLOCK,1,,<empty>,,,,1,,ANY
330498,BLOCK,1,,<empty>,,,,1,,ANY
330506,BLOCK,1,,<empty>,,,,1,,ANY
330514,BLOCK,1,,<empty>,,,,1,,ANY
330522,BLOCK,1,,<empty>,,,,1,,ANY
330530,BLOCK,1,,<empty>,,,,1,,ANY
330538,BLOCK,1,,<empty>,,,,1,,ANY
330546,BLOCK,1,,<empty>,,,,1,,ANY
330554,BLOCK,1,,<empty>,,,,1,,ANY
330562,BLOCK,1,,<empty>,,,,1,,ANY
330570,BLOCK,1,,<empty>,,,,1,,ANY
330578,BLOCK,1,,<empty>,,,,1,,ANY
330586,BLOCK,1,,<empty>,,,,1,,ANY
330594,BLOCK,1,,<empty>,,,,1,,ANY
330602,BLOCK,1,,<empty>,,,,1,,ANY
330610,BLOCK,1,,<empty>,,,,1,,ANY
330618,BLOCK,1,,<empty>,,,,1,,ANY
330626,BLOCK,1,,<empty>,,,,1,,ANY
330634,BLOCK,1,,<empty>,,,,1,,ANY
330642,BLOCK,1,,<empty>,,,,1,,ANY
330650,BLOCK,1,,<empty>,,,,1,,ANY
330658,BLOCK,1,,<empty>,,,,1,,ANY
330666,BLOCK,1,,<empty>,,,,1,,ANY
330674,BLOCK,1,,<empty>,,,,1,,ANY
330682,BLOCK,1,,<empty>,,,,1,,ANY
330690,BLOCK,1,,<empty>,,,,1,,ANY
330698,BLOCK,1,,<empty>,,,,1,,ANY
330706,BLOCK,1,,<empty>,,,,1,,ANY
330714,BLOCK,1,,<empty>,,,,1,,ANY
330722,BLOCK,1,,<empty>,,,,1,,ANY
330730,BLOCK,1,,<empty>,,,,1,,ANY
330738,BLOCK,1,,<empty>,,,,1,,ANY
330746,BLOCK,1,,<empty>,,,,1,,ANY
330754,BLOCK,1,,<empty>,,,,1,,ANY
330762,BLOCK,1,,<empty>,,,,1,,ANY
330770,BLOCK,1,,<empty>,,,,1,,ANY
330778,BLOCK,1,,<empty>,,,,1,,ANY
330786,BLOCK,1,,<empty>,,,,1,,ANY
330794,BLOCK,1,,<empty>,,,,1,,ANY
330802,BLOCK,1,,<empty>,,,,1,,ANY
330810,BLOCK,1,,<empty>,,,,1,,ANY
330818,BLOCK,1,,<empty>,,,,1,,ANY
330826,BLOCK,1,,<empty>,,,,1,,ANY
330834,BLOCK,1,,<empty>,,,,1,,ANY
330842,BLOCK,1,,<empty>,,,,1,,ANY
330850,BLOCK,1,,<empty>,,,,1,,ANY
330858,BLOCK,1,,<empty>,,,,1,,ANY
330866,BLOCK,1,,<empty>,,,,1,,ANY
330874,BLOCK,1,,<empty>,,,,1,,ANY
330882,BLOCK,1,,<empty>,,,,1,,ANY
330890,BLOCK,1,,<empty>,,,,1,,ANY
330898,BLOCK,1,,<empty>,,,,1,,ANY
330906,BLOCK,1,,<empty>,,,,1,,ANY
330914,BLOCK,1,,<empty>,,,,1,,ANY
330922,BLOCK,1,,<empty>,,,,1,,ANY
330930,BLOCK,1,,<empty>,,,,1,,ANY
330938,BLOCK,1,,<empty>,,,,1,,ANY
330946,BLOCK,1,,<empty>,,,,1,,ANY
330954,BLOCK,1,,<empty>,,,,1,,ANY
330962,BLOCK,1,,<empty>,,,,1,,ANY
330970,BLOCK,1,,<empty>,,,,1,,ANY
330978,BLOCK,1,,<empty>,,,,1,,ANY
330986,BLOCK,1,,<empty>,,,,1,,ANY
330990,BLOCK,1,,<empty>,,,,1,,ANY
330996,BLOCK,1,,<empty>,,,,1,,ANY
331001,BLOCK,1,,<empty>,,,,1,,ANY
331005,BLOCK,1,,<empty>,,,,1,,ANY
331010,BLOCK,1,,<empty>,,,,1,,ANY
331014,BLOCK,1,,<empty>,,,,1,,ANY
331020,BLOCK,1,,<empty>,,,,1,,ANY
331025,BLOCK,1,,<empty>,,,,1,,ANY
331029,BLOCK,1,,<empty>,,,,1,,ANY
331034,BLOCK,1,,<empty>,,,,1,,ANY
331039,BLOCK,1,,<empty>,,,,1,,ANY
331044,BLOCK,1,,<empty>,,,,1,,ANY
331048,BLOCK,1,,<empty>,,,,1,,ANY
331052,BLOCK,1,,<empty>,,,,1,,ANY
331056,BLOCK,1,,<empty>,,,,1,,ANY
331060,BLOCK,1,,<empty>,,,,1,,ANY
331064,BLOCK,1,,<empty>,,,,1,,ANY
331068,BLOCK,1,,<empty>,,,,1,,ANY
331072,BLOCK,1,,<empty>,,,,1,,ANY
331076,BLOCK,1,,<empty>,,,,1,,ANY
331080,BLOCK,1,,<empty>,,,,1,,ANY
331085,BLOCK,1,,<empty>,,,,1,,ANY
331090,BLOCK,1,,<empty>,,,,1,,ANY
331098,BLOCK,1,,<empty>,,,,1,,ANY
331106,BLOCK,1,,<empty>,,,,1,,ANY
331114,BLOCK,1,,<empty>,,,,1,,ANY
331122,BLOCK,1,,<empty>,,,,1,,ANY
331130,BLOCK,1,,<empty>,,,,1,,ANY
331136,BLOCK,1,,<empty>,,,,1,,ANY
331141,BLOCK,1,,<empty>,,,,1,,ANY
331146,BLOCK,1,,<empty>,,,,1,,ANY
331151,BLOCK,1,,<empty>,,,,1,,ANY
331155,BLOCK,1,,<empty>,,,,1,,ANY
331161,BLOCK,1,,<empty>,,,,1,,ANY
331165,BLOCK,1,,<empty>,,,,1,,ANY
331169,BLOCK,1,,<empty>,,,,1,,ANY
331173,BLOCK,1,,<empty>,,,,1,,ANY
331178,BLOCK,1,,<empty>,,,,1,,ANY
331182,BLOCK,1,,<empty>,,,,1,,ANY
331186,BLOCK,1,,<empty>,,,,1,,ANY
331190,BLOCK,1,,<empty>,,,,1,,ANY
331194,BLOCK,1,,<empty>,,,,1,,ANY
331199,BLOCK,1,,<empty>,,,,1,,ANY
331203,BLOCK,1,,<empty>,,,,1,,ANY
331208,BLOCK,1,,<empty>,,,,1,,ANY
331212,BLOCK,1,,<empty>,,,,1,,ANY
331217,BLOCK,1,,<empty>,,,,1,,ANY
331221,BLOCK,1,,<empty>,,,,1,,ANY
331226,BLOCK,1,,<empty>,,,,1,,ANY
331230,BLOCK,1,,<empty>,,,,1,,ANY
331234,BLOCK,1,,<empty>,,,,1,,ANY
331238,BLOCK,1,,<empty>,,,,1,,ANY
331242,BLOCK,1,,<empty>,,,,1,,ANY
331248,BLOCK,1,,<empty>,,,,1,,ANY
331252,BLOCK,1,,<empty>,,,,1,,ANY
331257,BLOCK,1,,<empty>,,,,1,,ANY
331262,BLOCK,1,,<empty>,,,,1,,ANY
331266,BLOCK,1,,<empty>,,,,1,,ANY
331271,BLOCK,1,,<empty>,,,,1,,ANY
331275,BLOCK,1,,<empty>,,,,1,,ANY
331281,BLOCK,1,,<empty>,,,,1,,ANY
331285,BLOCK,1,,<empty>,,,,1,,ANY
331289,BLOCK,1,,<empty>,,,,1,,ANY
331293,BLOCK,1,,<empty>,,,,1,,ANY
331297,BLOCK,1,,<empty>,,,,1,,ANY
331300,BLOCK,1,,<empty>,,,,1,,ANY
331303,BLOCK,1,,<empty>,,,,1,,ANY
331307,BLOCK,1,,<empty>,,,,1,,ANY
331313,BLOCK,1,,<empty>,,,,1,,ANY
331316,BLOCK,1,,<empty>,,,,1,,ANY
331319,BLOCK,1,,<empty>,,,,1,,ANY
331323,BLOCK,1,,<empty>,,,,1,,ANY
331328,BLOCK,1,,<empty>,,,,1,,ANY
331333,BLOCK,1,,<empty>,,,,1,,ANY
331337,BLOCK,1,,<empty>,,,,1,,ANY
331342,BLOCK,1,,<empty>,,,,1,,ANY
331346,BLOCK,1,,<empty>,,,,1,,ANY
331351,BLOCK,1,,<empty>,,,,1,,ANY
331356,BLOCK,1,,<empty>,,,,1,,ANY
331360,BLOCK,1,,<empty>,,,,1,,ANY
331363,BLOCK,1,,<empty>,,,,1,,ANY
331366,BLOCK,1,,<empty>,,,,1,,ANY
331370,BLOCK,1,,<empty>,,,,1,,ANY
331373,BLOCK,1,,<empty>,,,,1,,ANY
331376,BLOCK,1,,<empty>,,,,1,,ANY
331380,BLOCK,1,,<empty>,,,,1,,ANY
331383,BLOCK,1,,<empty>,,,,1,,ANY
331386,BLOCK,1,,<empty>,,,,1,,ANY
331390,BLOCK,1,,<empty>,,,,1,,ANY
331394,BLOCK,1,,<empty>,,,,1,,ANY
331398,BLOCK,1,,<empty>,,,,1,,ANY
331401,BLOCK,1,,<empty>,,,,1,,ANY
331405,BLOCK,1,,<empty>,,,,1,,ANY
331410,BLOCK,1,,<empty>,,,,1,,ANY
331415,BLOCK,1,,<empty>,,,,1,,ANY
331420,BLOCK,1,,<empty>,,,,1,,ANY
331424,BLOCK,1,,<empty>,,,,1,,ANY
331428,BLOCK,1,,<empty>,,,,1,,ANY
331432,BLOCK,1,,<empty>,,,,1,,ANY
331437,BLOCK,1,,<empty>,,,,1,,ANY
331441,BLOCK,1,,<empty>,,,,1,,ANY
331445,BLOCK,1,,<empty>,,,,1,,ANY
331449,BLOCK,1,,<empty>,,,,1,,ANY
331453,BLOCK,1,,<empty>,,,,1,,ANY
331460,BLOCK,1,,<empty>,,,,1,,ANY
331464,BLOCK,1,,<empty>,,,,1,,ANY
331469,BLOCK,1,,<empty>,,,,1,,ANY
331473,BLOCK,1,,<empty>,,,,1,,ANY
331477,BLOCK,1,,<empty>,,,,1,,ANY
331482,BLOCK,1,,<empty>,,,,1,,ANY
331488,BLOCK,1,,<empty>,,,,1,,ANY
331492,BLOCK,1,,<empty>,,,,1,,ANY
331496,BLOCK,1,,<empty>,,,,1,,ANY
331500,BLOCK,1,,<empty>,,,,1,,ANY
331505,BLOCK,1,,<empty>,,,,1,,ANY
331509,BLOCK,1,,<empty>,,,,1,,ANY
331514,BLOCK,1,,<empty>,,,,1,,ANY
331518,BLOCK,1,,<empty>,,,,1,,ANY
331522,BLOCK,1,,<empty>,,,,1,,ANY
331526,BLOCK,1,,<empty>,,,,1,,ANY
331530,BLOCK,1,,<empty>,,,,1,,ANY
331537,BLOCK,1,,<empty>,,,,1,,ANY
331541,BLOCK,1,,<empty>,,,,1,,ANY
331545,BLOCK,1,,<empty>,,,,1,,ANY
331549,BLOCK,1,,<empty>,,,,1,,ANY
331554,BLOCK,1,,<empty>,,,,1,,ANY
331559,BLOCK,1,,<empty>,,,,1,,ANY
331564,BLOCK,1,,<empty>,,,,1,,ANY
331573,BLOCK,1,,<empty>,,,,1,,ANY
331577,BLOCK,1,,<empty>,,,,1,,ANY
331581,BLOCK,1,,<empty>,,,,1,,ANY
331585,BLOCK,1,,<empty>,,,,1,,ANY
331590,BLOCK,1,,<empty>,,,,1,,ANY
331593,BLOCK,1,,<empty>,,,,1,,ANY
331598,BLOCK,1,,<empty>,,,,1,,ANY
331604,BLOCK,1,,<empty>,,,,1,,ANY
331610,BLOCK,1,,<empty>,,,,1,,ANY
331616,BLOCK,1,,<empty>,,,,1,,ANY
331620,BLOCK,1,,<empty>,,,,1,,ANY
331624,BLOCK,1,,<empty>,,,,1,,ANY
331628,BLOCK,1,,<empty>,,,,1,,ANY
331632,BLOCK,1,,<empty>,,,,1,,ANY
331636,BLOCK,1,,<empty>,,,,1,,ANY
331640,BLOCK,1,,<empty>,,,,1,,ANY
331644,BLOCK,1,,<empty>,,,,1,,ANY
331648,BLOCK,1,,<empty>,,,,1,,ANY
331652,BLOCK,1,,<empty>,,,,1,,ANY
331656,BLOCK,1,,<empty>,,,,1,,ANY
331662,BLOCK,1,,<empty>,,,,1,,ANY
331667,BLOCK,1,,<empty>,,,,1,,ANY
331671,BLOCK,1,,<empty>,,,,1,,ANY
331674,BLOCK,1,,<empty>,,,,1,,ANY
331681,BLOCK,1,,<empty>,,,,1,,ANY
331687,BLOCK,1,,<empty>,,,,1,,ANY
331693,BLOCK,1,,<empty>,,,,1,,ANY
331698,BLOCK,1,,<empty>,,,,1,,ANY
331703,BLOCK,1,,<empty>,,,,1,,ANY
331711,BLOCK,1,,<empty>,,,,1,,ANY
331719,BLOCK,1,,<empty>,,,,1,,ANY
331727,BLOCK,1,,<empty>,,,,1,,ANY
331735,BLOCK,1,,<empty>,,,,1,,ANY
331739,BLOCK,1,,<empty>,,,,1,,ANY
331744,BLOCK,1,,<empty>,,,,1,,ANY
331749,BLOCK,1,,<empty>,,,,1,,ANY
331752,BLOCK,1,,<empty>,,,,1,,ANY
331756,BLOCK,1,,<empty>,,,,1,,ANY
331760,BLOCK,1,,<empty>,,,,1,,ANY
331764,BLOCK,1,,<empty>,,,,1,,ANY
331768,BLOCK,1,,<empty>,,,,1,,ANY
331773,BLOCK,1,,<empty>,,,,1,,ANY
331778,BLOCK,1,,<empty>,,,,1,,ANY
331784,BLOCK,1,,<empty>,,,,1,,ANY
331789,BLOCK,1,,<empty>,,,,1,,ANY
331793,BLOCK,1,,<empty>,,,,1,,ANY
331796,BLOCK,1,,<empty>,,,,1,,ANY
331803,BLOCK,1,,<empty>,,,,1,,ANY
331808,BLOCK,1,,<empty>,,,,1,,ANY
331816,BLOCK,1,,<empty>,,,,1,,ANY
331821,BLOCK,1,,<empty>,,,,1,,ANY
331826,BLOCK,1,,<empty>,,,,1,,ANY
331832,BLOCK,1,,<empty>,,,,1,,ANY
331838,BLOCK,1,,<empty>,,,,1,,ANY
331842,BLOCK,1,,<empty>,,,,1,,ANY
331850,BLOCK,1,,<empty>,,,,1,,ANY
331857,BLOCK,1,,<empty>,,,,1,,ANY
331864,BLOCK,1,,<empty>,,,,1,,ANY
331867,BLOCK,1,,<empty>,,,,1,,ANY
331871,BLOCK,1,,<empty>,,,,1,,ANY
331876,BLOCK,1,,<empty>,,,,1,,ANY
331882,BLOCK,1,,<empty>,,,,1,,ANY
331887,BLOCK,1,,<empty>,,,,1,,ANY
331894,BLOCK,1,,<empty>,,,,1,,ANY
331898,BLOCK,1,,<empty>,,,,1,,ANY
331903,BLOCK,1,,<empty>,,,,1,,ANY
331909,BLOCK,1,,<empty>,,,,1,,ANY
331914,BLOCK,1,,<empty>,,,,1,,ANY
331920,BLOCK,1,,<empty>,,,,1,,ANY
331928,BLOCK,1,,<empty>,,,,1,,ANY
331936,BLOCK,1,,<empty>,,,,1,,ANY
331941,BLOCK,1,,<empty>,,,,1,,ANY
331949,BLOCK,1,,<empty>,,,,1,,ANY
331957,BLOCK,1,,<empty>,,,,1,,ANY
331965,BLOCK,1,,<empty>,,,,1,,ANY
331968,BLOCK,1,,<empty>,,,,1,,ANY
331971,BLOCK,1,,<empty>,,,,1,,ANY
331974,BLOCK,1,,<empty>,,,,1,,ANY
331977,BLOCK,1,,<empty>,,,,1,,ANY
331984,BLOCK,1,,<empty>,,,,1,,ANY
331989,BLOCK,1,,<empty>,,,,1,,ANY
331993,BLOCK,1,,<empty>,,,,1,,ANY
332000,BLOCK,1,,<empty>,,,,1,,ANY
332005,BLOCK,1,,<empty>,,,,1,,ANY
332008,BLOCK,1,,<empty>,,,,1,,ANY
332014,BLOCK,1,,<empty>,,,,1,,ANY
332020,BLOCK,1,,<empty>,,,,1,,ANY
332026,BLOCK,1,,<empty>,,,,1,,ANY
332032,BLOCK,1,,<empty>,,,,1,,ANY
332038,BLOCK,1,,<empty>,,,,1,,ANY
332044,BLOCK,1,,<empty>,,,,1,,ANY
332049,BLOCK,1,,<empty>,,,,1,,ANY
332056,BLOCK,1,,<empty>,,,,1,,ANY
332063,BLOCK,1,,<empty>,,,,1,,ANY
332070,BLOCK,1,,<empty>,,,,1,,ANY
332077,BLOCK,1,,<empty>,,,,1,,ANY
332084,BLOCK,1,,<empty>,,,,1,,ANY
332091,BLOCK,1,,<empty>,,,,1,,ANY
332098,BLOCK,1,,<empty>,,,,1,,ANY
332105,BLOCK,1,,<empty>,,,,1,,ANY
332109,BLOCK,1,,<empty>,,,,1,,ANY
332114,BLOCK,1,,<empty>,,,,1,,ANY
332122,BLOCK,1,,<empty>,,,,1,,ANY
332127,BLOCK,1,,<empty>,,,,1,,ANY
332133,BLOCK,1,,<empty>,,,,1,,ANY
332138,BLOCK,1,,<empty>,,,,1,,ANY
332143,BLOCK,1,,<empty>,,,,1,,ANY
332148,BLOCK,1,,<empty>,,,,1,,ANY
332153,BLOCK,1,,<empty>,,,,1,,ANY
332157,BLOCK,1,,<empty>,,,,1,,ANY
332163,BLOCK,1,,<empty>,,,,1,,ANY
332168,BLOCK,1,,<empty>,,,,1,,ANY
332173,BLOCK,1,,<empty>,,,,1,,ANY
332177,BLOCK,1,,<empty>,,,,1,,ANY
332182,BLOCK,1,,<empty>,,,,1,,ANY
332187,BLOCK,1,,<empty>,,,,1,,ANY
332192,BLOCK,1,,<empty>,,,,1,,ANY
332197,BLOCK,1,,<empty>,,,,1,,ANY
332205,BLOCK,1,,<empty>,,,,1,,ANY
332209,BLOCK,1,,<empty>,,,,1,,ANY
332213,BLOCK,1,,<empty>,,,,1,,ANY
332217,BLOCK,1,,<empty>,,,,1,,ANY
332222,BLOCK,1,,<empty>,,,,1,,ANY
332227,BLOCK,1,,<empty>,,,,1,,ANY
332230,BLOCK,1,,<empty>,,,,1,,ANY
332233,BLOCK,1,,<empty>,,,,1,,ANY
332239,BLOCK,1,,<empty>,,,,1,,ANY
332244,BLOCK,1,,<empty>,,,,1,,ANY
332248,BLOCK,1,,<empty>,,,,1,,ANY
332253,BLOCK,1,,<empty>,,,,1,,ANY
332258,BLOCK,1,,<empty>,,,,1,,ANY
332262,BLOCK,1,,<empty>,,,,1,,ANY
332265,BLOCK,1,,<empty>,,,,1,,ANY
332268,BLOCK,1,,<empty>,,,,1,,ANY
332271,BLOCK,1,,<empty>,,,,1,,ANY
332274,BLOCK,1,,<empty>,,,,1,,ANY
332279,BLOCK,1,,<empty>,,,,1,,ANY
332282,BLOCK,1,,<empty>,,,,1,,ANY
332286,BLOCK,1,,<empty>,,,,1,,ANY
332302,BLOCK,1,,<empty>,,,,1,,ANY
332308,BLOCK,1,,<empty>,,,,1,,ANY
332312,BLOCK,1,,<empty>,,,,1,,ANY
332320,BLOCK,1,,<empty>,,,,1,,ANY
332325,BLOCK,1,,<empty>,,,,1,,ANY
332328,BLOCK,1,,<empty>,,,,1,,ANY
332331,BLOCK,1,,<empty>,,,,1,,ANY
332336,BLOCK,1,,<empty>,,,,1,,ANY
332340,BLOCK,1,,<empty>,,,,1,,ANY
332344,BLOCK,1,,<empty>,,,,1,,ANY
332348,BLOCK,1,,<empty>,,,,1,,ANY
332352,BLOCK,1,,<empty>,,,,1,,ANY
332355,BLOCK,1,,<empty>,,,,1,,ANY
332362,BLOCK,1,,<empty>,,,,1,,ANY
332366,BLOCK,1,,<empty>,,,,1,,ANY
332372,BLOCK,1,,<empty>,,,,1,,ANY
332375,BLOCK,1,,<empty>,,,,1,,ANY
332379,BLOCK,1,,<empty>,,,,1,,ANY
332383,BLOCK,1,,<empty>,,,,1,,ANY
332388,BLOCK,1,,<empty>,,,,1,,ANY
332392,BLOCK,1,,<empty>,,,,1,,ANY
332396,BLOCK,1,,<empty>,,,,1,,ANY
332400,BLOCK,1,,<empty>,,,,1,,ANY
332404,BLOCK,1,,<empty>,,,,1,,ANY
332409,BLOCK,1,,<empty>,,,,1,,ANY
332412,BLOCK,1,,<empty>,,,,1,,ANY
332415,BLOCK,1,,<empty>,,,,1,,ANY
332421,BLOCK,1,,<empty>,,,,1,,ANY
332424,BLOCK,1,,<empty>,,,,1,,ANY
332439,BLOCK,1,,<empty>,,,,1,,ANY
332442,BLOCK,1,,<empty>,,,,1,,ANY
332449,BLOCK,1,,<empty>,,,,1,,ANY
332452,BLOCK,1,,<empty>,,,,1,,ANY
332457,BLOCK,1,,<empty>,,,,1,,ANY
332461,BLOCK,1,,<empty>,,,,1,,ANY
332465,BLOCK,1,,<empty>,,,,1,,ANY
332469,BLOCK,1,,<empty>,,,,1,,ANY
332472,BLOCK,1,,<empty>,,,,1,,ANY
332477,BLOCK,1,,<empty>,,,,1,,ANY
332482,BLOCK,1,,<empty>,,,,1,,ANY
332487,BLOCK,1,,<empty>,,,,1,,ANY
332494,BLOCK,1,,<empty>,,,,1,,ANY
332499,BLOCK,1,,<empty>,,,,1,,ANY
332503,BLOCK,1,,<empty>,,,,1,,ANY
332507,BLOCK,1,,<empty>,,,,1,,ANY
332512,BLOCK,1,,<empty>,,,,1,,ANY
332517,BLOCK,1,,<empty>,,,,1,,ANY
332525,BLOCK,1,,<empty>,,,,1,,ANY
332533,BLOCK,1,,<empty>,,,,1,,ANY
332539,BLOCK,1,,<empty>,,,,1,,ANY
332544,BLOCK,1,,<empty>,,,,1,,ANY
332549,BLOCK,1,,<empty>,,,,1,,ANY
332554,BLOCK,1,,<empty>,,,,1,,ANY
332559,BLOCK,1,,<empty>,,,,1,,ANY
332564,BLOCK,1,,<empty>,,,,1,,ANY
332569,BLOCK,1,,<empty>,,,,1,,ANY
332576,BLOCK,1,,<empty>,,,,1,,ANY
332581,BLOCK,1,,<empty>,,,,1,,ANY
332586,BLOCK,1,,<empty>,,,,1,,ANY
332591,BLOCK,1,,<empty>,,,,1,,ANY
332599,BLOCK,1,,<empty>,,,,1,,ANY
332604,BLOCK,1,,<empty>,,,,1,,ANY
332611,BLOCK,1,,<empty>,,,,1,,ANY
332615,BLOCK,1,,<empty>,,,,1,,ANY
332620,BLOCK,1,,<empty>,,,,1,,ANY
332625,BLOCK,1,,<empty>,,,,1,,ANY
332630,BLOCK,1,,<empty>,,,,1,,ANY
332635,BLOCK,1,,<empty>,,,,1,,ANY
332639,BLOCK,1,,<empty>,,,,1,,ANY
332645,BLOCK,1,,<empty>,,,,1,,ANY
332649,BLOCK,1,,<empty>,,,,1,,ANY
332653,BLOCK,1,,<empty>,,,,1,,ANY
332657,BLOCK,1,,<empty>,,,,1,,ANY
332661,BLOCK,1,,<empty>,,,,1,,ANY
332665,BLOCK,1,,<empty>,,,,1,,ANY
332671,BLOCK,1,,<empty>,,,,1,,ANY
332674,BLOCK,1,,<empty>,,,,1,,ANY
332678,BLOCK,1,,<empty>,,,,1,,ANY
332683,BLOCK,1,,<empty>,,,,1,,ANY
332691,BLOCK,1,,<empty>,,,,1,,ANY
332696,BLOCK,1,,<empty>,,,,1,,ANY
332701,BLOCK,1,,<empty>,,,,1,,ANY
332705,BLOCK,1,,<empty>,,,,1,,ANY
332711,BLOCK,1,,<empty>,,,,1,,ANY
332715,BLOCK,1,,<empty>,,,,1,,ANY
332722,BLOCK,1,,<empty>,,,,1,,ANY
332727,BLOCK,1,,<empty>,,,,1,,ANY
332732,BLOCK,1,,<empty>,,,,1,,ANY
332736,BLOCK,1,,<empty>,,,,1,,ANY
332741,BLOCK,1,,<empty>,,,,1,,ANY
332746,BLOCK,1,,<empty>,,,,1,,ANY
332750,BLOCK,1,,<empty>,,,,1,,ANY
332754,BLOCK,1,,<empty>,,,,1,,ANY
332757,BLOCK,1,,<empty>,,,,1,,ANY
332761,BLOCK,1,,<empty>,,,,1,,ANY
332765,BLOCK,1,,<empty>,,,,1,,ANY
