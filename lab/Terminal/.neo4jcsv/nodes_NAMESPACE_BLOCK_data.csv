2,NAMESPACE_BLOCK,<empty>,,<unknown>,<global>,,<global>,1
9,NAMESPACE_BLOCK,<empty>,,audio\midi\MidiAudio.cpp,audio\midi\MidiAudio.cpp:<global>,,<global>,1
107,NAMESPACE_BLOCK,<empty>,,audio\midi\MidiAudio.hpp,audio\midi\MidiAudio.hpp:<global>,,<global>,1
162,NAMESPACE_BLOCK,<empty>,,audio\midi\precomp.cpp,audio\midi\precomp.cpp:<global>,,<global>,1
175,NAMESPACE_BLOCK,<empty>,,audio\midi\precomp.hpp,audio\midi\precomp.hpp:<global>,,<global>,1
180,NAMESPACE_BLOCK,<empty>,,buffer\out\DbcsAttribute.hpp,buffer\out\DbcsAttribute.hpp:<global>,,<global>,1
212,NAMESPACE_BLOCK,<empty>,,buffer\out\LineRendition.hpp,buffer\out\LineRendition.hpp:<global>,,<global>,1
286,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCell.cpp,buffer\out\OutputCell.cpp:<global>,,<global>,1
431,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCell.hpp,buffer\out\OutputCell.hpp:<global>,,<global>,1
573,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellIterator.cpp,buffer\out\OutputCellIterator.cpp:<global>,,<global>,1
1215,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellIterator.hpp,buffer\out\OutputCellIterator.hpp:<global>,,<global>,1
1385,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellRect.cpp,buffer\out\OutputCellRect.cpp:<global>,,<global>,1
1503,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellRect.hpp,buffer\out\OutputCellRect.hpp:<global>,,<global>,1
1549,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellView.cpp,buffer\out\OutputCellView.cpp:<global>,,<global>,1
1643,NAMESPACE_BLOCK,<empty>,,buffer\out\OutputCellView.hpp,buffer\out\OutputCellView.hpp:<global>,,<global>,1
1736,NAMESPACE_BLOCK,<empty>,,buffer\out\Row.cpp,buffer\out\Row.cpp:<global>,,<global>,1
4363,NAMESPACE_BLOCK,<empty>,,buffer\out\Row.hpp,buffer\out\Row.hpp:<global>,,<global>,1
4920,NAMESPACE_BLOCK,<empty>,,buffer\out\TextAttribute.cpp,buffer\out\TextAttribute.cpp:<global>,,<global>,1
4942,NAMESPACE_BLOCK,"namespace
{
    constexpr std::array<TextColor, 16> s_initLegacyColorMap(const BYTE defaultIndex)
    {
        std::array<TextColor, 16> legacyColorMap;
        for (auto i = 0u; i < legacyColorMap.size(); i++)
        {
            const auto legacyIndex = TextColor::TransposeLegacyIndex(i);
            gsl::at(legacyColorMap, i) = i == defaultIndex ? TextColor{} : TextColor{ legacyIndex, true };
        }
        return legacyColorMap;
    }

    BYTE s_legacyDefaultForeground = 7;
    BYTE s_legacyDefaultBackground = 0;
    BYTE s_ansiDefaultForeground = 7;
    BYTE s_ansiDefaultBackground = 0;
}",1,buffer\out\TextAttribute.cpp,anonymous_namespace_0,17,,5
5779,NAMESPACE_BLOCK,<empty>,,buffer\out\TextAttribute.hpp,buffer\out\TextAttribute.hpp:<global>,,<global>,1
6240,NAMESPACE_BLOCK,<empty>,,buffer\out\TextColor.cpp,buffer\out\TextColor.cpp:<global>,,<global>,1
7070,NAMESPACE_BLOCK,<empty>,,buffer\out\TextColor.hpp,buffer\out\TextColor.hpp:<global>,,<global>,1
7330,NAMESPACE_BLOCK,<empty>,,buffer\out\UTextAdapter.cpp,buffer\out\UTextAdapter.cpp:<global>,,<global>,1
7617,NAMESPACE_BLOCK,<empty>,,buffer\out\UTextAdapter.hpp,buffer\out\UTextAdapter.hpp:<global>,,<global>,1
7622,NAMESPACE_BLOCK,"namespace Microsoft::Console::ICU
{
    using unique_uregex = wistd::unique_ptr<URegularExpression, wil::function_deleter<decltype(&uregex_close), &uregex_close>>;

    UText UTextFromTextBuffer(const TextBuffer& textBuffer, til::CoordType rowBeg, til::CoordType rowEnd) noexcept;
    unique_uregex CreateRegex(const std::wstring_view& pattern, uint32_t flags, UErrorCode* status) noexcept;
    til::point_span BufferRangeFromMatch(UText* ut, URegularExpression* re);
}",1,buffer\out\UTextAdapter.hpp,Microsoft,10,Microsoft,2
7623,NAMESPACE_BLOCK,"namespace Microsoft::Console::ICU
{
    using unique_uregex = wistd::unique_ptr<URegularExpression, wil::function_deleter<decltype(&uregex_close), &uregex_close>>;

    UText UTextFromTextBuffer(const TextBuffer& textBuffer, til::CoordType rowBeg, til::CoordType rowEnd) noexcept;
    unique_uregex CreateRegex(const std::wstring_view& pattern, uint32_t flags, UErrorCode* status) noexcept;
    til::point_span BufferRangeFromMatch(UText* ut, URegularExpression* re);
}",1,buffer\out\UTextAdapter.hpp,Microsoft.Console,10,Console,1
7624,NAMESPACE_BLOCK,"namespace Microsoft::Console::ICU
{
    using unique_uregex = wistd::unique_ptr<URegularExpression, wil::function_deleter<decltype(&uregex_close), &uregex_close>>;

    UText UTextFromTextBuffer(const TextBuffer& textBuffer, til::CoordType rowBeg, til::CoordType rowEnd) noexcept;
    unique_uregex CreateRegex(const std::wstring_view& pattern, uint32_t flags, UErrorCode* status) noexcept;
    til::point_span BufferRangeFromMatch(UText* ut, URegularExpression* re);
}",1,buffer\out\UTextAdapter.hpp,Microsoft.Console.ICU,10,ICU,1
7653,NAMESPACE_BLOCK,<empty>,,buffer\out\cursor.cpp,buffer\out\cursor.cpp:<global>,,<global>,1
8062,NAMESPACE_BLOCK,<empty>,,buffer\out\cursor.hpp,buffer\out\cursor.hpp:<global>,,<global>,1
8301,NAMESPACE_BLOCK,<empty>,,buffer\out\precomp.cpp,buffer\out\precomp.cpp:<global>,,<global>,1
8310,NAMESPACE_BLOCK,<empty>,,buffer\out\precomp.hpp,buffer\out\precomp.hpp:<global>,,<global>,1
8321,NAMESPACE_BLOCK,<empty>,,buffer\out\search.cpp,buffer\out\search.cpp:<global>,,<global>,1
8743,NAMESPACE_BLOCK,<empty>,,buffer\out\search.hpp,buffer\out\search.hpp:<global>,,<global>,1
9045,NAMESPACE_BLOCK,<empty>,,buffer\out\textBuffer.cpp,buffer\out\textBuffer.cpp:<global>,,<global>,1
15504,NAMESPACE_BLOCK,<empty>,,buffer\out\textBuffer.hpp,buffer\out\textBuffer.hpp:<global>,,<global>,1
15509,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
}",1,buffer\out\textBuffer.hpp,Microsoft,64,Microsoft,2
15510,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
}",1,buffer\out\textBuffer.hpp,Microsoft.Console,64,Console,1
15511,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
}",1,buffer\out\textBuffer.hpp,Microsoft.Console.Render,64,Render,1
16349,NAMESPACE_BLOCK,<empty>,,buffer\out\textBufferCellIterator.cpp,buffer\out\textBufferCellIterator.cpp:<global>,,<global>,1
16936,NAMESPACE_BLOCK,<empty>,,buffer\out\textBufferCellIterator.hpp,buffer\out\textBufferCellIterator.hpp:<global>,,<global>,1
17056,NAMESPACE_BLOCK,<empty>,,buffer\out\textBufferTextIterator.cpp,buffer\out\textBufferTextIterator.cpp:<global>,,<global>,1
17087,NAMESPACE_BLOCK,<empty>,,buffer\out\textBufferTextIterator.hpp,buffer\out\textBufferTextIterator.hpp:<global>,,<global>,1
17122,NAMESPACE_BLOCK,<empty>,,buffer\out\ut_textbuffer\ReflowTests.cpp,buffer\out\ut_textbuffer\ReflowTests.cpp:<global>,,<global>,1
17144,NAMESPACE_BLOCK,"namespace
{
    struct TestRow
    {
        std::wstring_view text;
        bool wrap;
    };

    struct TestBuffer
    {
        til::size size;
        std::vector<TestRow> rows;
        til::point cursor;
    };

    struct TestCase
    {
        std::wstring_view name;
        std::vector<TestBuffer> buffers;
    };

    static const TestCase testCases[] = {
        TestCase{
            L""No reflow required"",
            {
                TestBuffer{
                    { 6, 5 },
                    {
                        { L""AB    "", false },
                        { L""$     "", false },
                        { L""CD    "", false },
                        { L""EFG   "", false },
                        { L""      "", false },
                    },
                    { 0, 1 }, // cursor on $
                },
                TestBuffer{
                    { 5, 5 }, // reduce width by 1
                    {
                        { L""AB   "", false },
                    ...",1,buffer\out\ut_textbuffer\ReflowTests.cpp,anonymous_namespace_0,28,,2
18821,NAMESPACE_BLOCK,<empty>,,buffer\out\ut_textbuffer\TextAttributeTests.cpp,buffer\out\ut_textbuffer\TextAttributeTests.cpp:<global>,,<global>,1
20206,NAMESPACE_BLOCK,<empty>,,buffer\out\ut_textbuffer\TextColorTests.cpp,buffer\out\ut_textbuffer\TextColorTests.cpp:<global>,,<global>,1
20959,NAMESPACE_BLOCK,<empty>,,buffer\out\ut_textbuffer\precomp.cpp,buffer\out\ut_textbuffer\precomp.cpp:<global>,,<global>,1
20974,NAMESPACE_BLOCK,<empty>,,buffer\out\ut_textbuffer\precomp.hpp,buffer\out\ut_textbuffer\precomp.hpp:<global>,,<global>,1
21051,NAMESPACE_BLOCK,<empty>,,cascadia\ElevateShim\elevate-shim.cpp,cascadia\ElevateShim\elevate-shim.cpp:<global>,,<global>,1
21164,NAMESPACE_BLOCK,<empty>,,cascadia\ElevateShim\resource.hpp,cascadia\ElevateShim\resource.hpp:<global>,,<global>,1
21179,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\ColorSchemeTests.cpp,cascadia\LocalTests_SettingsModel\ColorSchemeTests.cpp:<global>,,<global>,1
21183,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class ColorSchemeTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(ColorSchemeTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleColorScheme);
        TEST_METHOD(LayerColorSchemesOnArray);
        TEST_METHOD(Updat...",1,cascadia\LocalTests_SettingsModel\ColorSchemeTests.cpp,SettingsModelLocalTests,18,SettingsModelLocalTests,1
21878,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\CommandTests.cpp,cascadia\LocalTests_SettingsModel\CommandTests.cpp:<global>,,<global>,1
21882,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class CommandTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(CommandTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ManyCommandsSameAction);
        TEST_METHOD(LayerCommand);
        TEST_METHOD(TestSplitPaneArgs);
     ...",1,cascadia\LocalTests_SettingsModel\CommandTests.cpp,SettingsModelLocalTests,18,SettingsModelLocalTests,1
24268,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\DeserializationTests.cpp,cascadia\LocalTests_SettingsModel\DeserializationTests.cpp:<global>,,<global>,1
24272,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class DeserializationTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(DeserializationTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ValidateProfilesExist);
        TEST_METHOD(ValidateDefaultProfileExists);
        TEST_M...",1,cascadia\LocalTests_SettingsModel\DeserializationTests.cpp,SettingsModelLocalTests,22,SettingsModelLocalTests,2
29107,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\JsonTestClass.hpp,cascadia\LocalTests_SettingsModel\JsonTestClass.hpp:<global>,,<global>,1
29239,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\KeyBindingsTests.cpp,cascadia\LocalTests_SettingsModel\KeyBindingsTests.cpp:<global>,,<global>,1
29243,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class KeyBindingsTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(KeyBindingsTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(KeyChords);
        TEST_METHOD(ManyKeysSameAction);
        TEST_METHOD(LayerKeybindings);
     ...",1,cascadia\LocalTests_SettingsModel\KeyBindingsTests.cpp,SettingsModelLocalTests,20,SettingsModelLocalTests,2
32369,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\NewTabMenuTests.cpp,cascadia\LocalTests_SettingsModel\NewTabMenuTests.cpp:<global>,,<global>,1
32373,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class NewTabMenuTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(NewTabMenuTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(DefaultsToRemainingProfiles);
        TEST_METHOD(ParseEmptyFolder);
    };

    void NewTabMenuTes...",1,cascadia\LocalTests_SettingsModel\NewTabMenuTests.cpp,SettingsModelLocalTests,21,SettingsModelLocalTests,1
32596,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\ProfileTests.cpp,cascadia\LocalTests_SettingsModel\ProfileTests.cpp:<global>,,<global>,1
32600,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class ProfileTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(ProfileTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ProfileGeneratesGuid);
        TEST_METHOD(LayerProfileProperties);
        TEST_METHOD(LayerProfileIcon)...",1,cascadia\LocalTests_SettingsModel\ProfileTests.cpp,SettingsModelLocalTests,18,SettingsModelLocalTests,1
33932,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\SerializationTests.cpp,cascadia\LocalTests_SettingsModel\SerializationTests.cpp:<global>,,<global>,1
33936,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class SerializationTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(SerializationTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(GlobalSettings);
        TEST_METHOD(Profile);
        TEST_METHOD(ColorScheme);
        TEST...",1,cascadia\LocalTests_SettingsModel\SerializationTests.cpp,SettingsModelLocalTests,19,SettingsModelLocalTests,1
34584,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp:<global>,,<global>,1
34587,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class TerminalSettingsTests
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(TerminalSettingsTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(TryCreateWinRTType);
        TEST_METHOD(TestTerminalArgsForBinding);
        TEST_METHOD(CommandLineToArgvW);...",1,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp,SettingsModelLocalTests,19,SettingsModelLocalTests,1
37962,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\TestUtils.hpp,cascadia\LocalTests_SettingsModel\TestUtils.hpp:<global>,,<global>,1
38079,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\ThemeTests.cpp,cascadia\LocalTests_SettingsModel\ThemeTests.cpp:<global>,,<global>,1
38083,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class ThemeTests : public JsonTestClass
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(ThemeTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleTheme);
        TEST_METHOD(ParseEmptyTheme);
        TEST_METHOD(ParseNoWindowTheme);
        TES...",1,cascadia\LocalTests_SettingsModel\ThemeTests.cpp,SettingsModelLocalTests,20,SettingsModelLocalTests,1
38816,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\pch.cpp,cascadia\LocalTests_SettingsModel\pch.cpp:<global>,,<global>,1
38891,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_SettingsModel\pch.hpp,cascadia\LocalTests_SettingsModel\pch.hpp:<global>,,<global>,1
39075,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp:<global>,,<global>,1
39078,NAMESPACE_BLOCK,"namespace winrt
{
    namespace appImpl = TerminalApp::implementation;
}",1,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp,winrt,22,winrt,1
39079,NAMESPACE_BLOCK,namespace appImpl = TerminalApp::implementation;,5,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp,TerminalApp.implementation,24,appImpl,1
39080,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.
    class CommandlineTest
    {
        // Use a custom AppxManifest to ensure that we can activate winrt types
        // from our test. This property will tell taef to manually use this as
        // the AppxManifest for this test class.
        // This does not yet work for anything XAML-y. See TabTests.cpp for more
        // details on that.
        BEGIN_TEST_CLASS(CommandlineTest)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleCommandline);
        TEST_METHOD(ParseTrickyCommandlines);
        TEST_METHOD(TestEscapeDelimiters);

        TE...",1,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp,TerminalAppLocalTests,27,TerminalAppLocalTests,2
49528,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp:<global>,,<global>,1
49537,NAMESPACE_BLOCK,"namespace details
{
    class Event
    {
    public:
        Event() :
            m_handle(::CreateEvent(nullptr, FALSE, FALSE, nullptr))
        {
        }

        ~Event()
        {
            if (IsValid())
            {
                ::CloseHandle(m_handle);
            }
        }

        void Set()
        {
            ::SetEvent(m_handle);
        }

        HRESULT Wait()
        {
            return Thread_Wait_For(m_handle, INFINITE);
        }

        bool IsValid()
        {
            return m_handle != nullptr;
        }

        HANDLE m_handle;
    };
}",1,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp,details,21,details,2
50919,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp:<global>,,<global>,1
50922,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class FilteredCommandTests
    {
        BEGIN_TEST_CLASS(FilteredCommandTests)
            TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(VerifyHighlighting);
        TEST_METHOD(VerifyWeight);
        TEST_METHOD(VerifyCompare);
        TEST_METHOD(VerifyCompareIgnoreCase);
    };

    void FilteredCommandTests::VerifyHighlighting()
    {
        auto result = RunOnUIThread([]() {
            const auto paletteItem{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""AAAAAABBBBBBCCC"") };
            {
                Log::Comment(L""Testing command name segmentation with no filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                auto segments = filteredCommand->_computeHighlightedName().Segments();
          ...",1,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp,TerminalAppLocalTests,16,TerminalAppLocalTests,1
50981,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\SettingsTests.cpp,cascadia\LocalTests_TerminalApp\SettingsTests.cpp:<global>,,<global>,1
50985,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    static constexpr std::wstring_view inboxSettings{ LR""({
        ""schemes"": [{
            ""name"": ""Campbell"",
            ""foreground"": ""#CCCCCC"",
            ""background"": ""#0C0C0C"",
            ""cursorColor"": ""#FFFFFF"",
            ""black"": ""#0C0C0C"",
            ""red"": ""#C50F1F"",
            ""green"": ""#13A10E"",
            ""yellow"": ""#C19C00"",
            ""blue"": ""#0037DA"",
            ""purple"": ""#881798"",
            ""cyan"": ""#3A96DD"",
            ""white"": ""#CCCCCC"",
            ""brightBlack"": ""#767676"",
            ""brightRed"": ""#E74856"",
            ""brightGreen"": ""#16C60C"",
            ""brightYellow"": ""#F9F1A5"",
            ""brightBlue"": ""#3B78FF"",
            ""brightPurple"": ""#B4009E"",
            ""brightCyan"": ""#61D6D6"",
            ""brightWhite"": ""#F2F2F2""
        }]
    })"" };

    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us ins...",1,cascadia\LocalTests_TerminalApp\SettingsTests.cpp,TerminalAppLocalTests,17,TerminalAppLocalTests,1
59478,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\TabTests.cpp,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>,,<global>,1
59481,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\LocalTests_TerminalApp\TabTests.cpp,winrt,33,winrt,1
59482,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\LocalTests_TerminalApp\TabTests.cpp,Microsoft.UI.Xaml,35,MUX,1
59483,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\LocalTests_TerminalApp\TabTests.cpp,Windows.UI.Xaml,36,WUX,2
59485,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    // TODO:microsoft/terminal#3838:
    // Unfortunately, these tests _WILL NOT_ work in our CI. We're waiting for
    // an updated TAEF that will let us install framework packages when the test
    // package is deployed. Until then, these tests won't deploy in CI.

    class TabTests
    {
        // For this set of tests, we need to activate some XAML content. For
        // release builds, the application runs as a centennial application,
        // which lets us run full trust, and means that we need to use XAML
        // Islands to host our UI. However, in these tests, we don't really need
        // to run full trust - we just need to get some UI elements created. So
        // we can just rely on the normal UWP activation to create us.
        //
        // IMPORTANTLY! When tests need to make XAML objects, or do XAML things,
        // make sure to use RunOnUIThread. This helper will dispatch a lambda to
        // be run on the UI threa...",1,cascadia\LocalTests_TerminalApp\TabTests.cpp,TerminalAppLocalTests,40,TerminalAppLocalTests,2
60898,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.cpp,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.cpp:<global>,,<global>,1
60902,NAMESPACE_BLOCK,"namespace TestHostApp
{
    /// <summary>
    /// Initializes the singleton application object.  This is the first line of authored code
    /// executed, and as such is the logical equivalent of main() or WinMain().
    /// </summary>
    App::App()
    {
        InitializeComponent();
    }

    /// <summary>
    /// Invoked when the application is launched normally by the end user.    Other entry points
    /// will be used such as when the application is launched to open a specific file.
    /// </summary>
    /// <param name=""e"">Details about the launch request and process.</param>
    void App::OnLaunched(Windows::ApplicationModel::Activation::LaunchActivatedEventArgs ^ e)
    {
        Windows::UI::Xaml::Window::Current->Activate();
        Microsoft::VisualStudio::TestPlatform::TestExecutor::WinRTCore::UnitTestClient::Run(e->Arguments);
    }
}",1,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.cpp,TestHostApp,6,TestHostApp,1
60912,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.hpp,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.hpp:<global>,,<global>,1
60916,NAMESPACE_BLOCK,"namespace TestHostApp
{
    /// <summary>
    /// Provides application-specific behavior to supplement the default Application class.
    /// </summary>
    ref class App sealed
    {
    protected:
        virtual void OnLaunched(Windows::ApplicationModel::Activation::LaunchActivatedEventArgs ^ e) override;

        internal :
            App();
    };
}",1,cascadia\LocalTests_TerminalApp\TestHostApp\UnitTestApp.xaml.hpp,TestHostApp,14,TestHostApp,1
60921,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\TestHostApp\pch.cpp,cascadia\LocalTests_TerminalApp\TestHostApp\pch.cpp:<global>,,<global>,1
60928,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\TestHostApp\pch.hpp,cascadia\LocalTests_TerminalApp\TestHostApp\pch.hpp:<global>,,<global>,1
60935,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\pch.cpp,cascadia\LocalTests_TerminalApp\pch.cpp:<global>,,<global>,1
61014,NAMESPACE_BLOCK,<empty>,,cascadia\LocalTests_TerminalApp\pch.hpp,cascadia\LocalTests_TerminalApp\pch.hpp:<global>,,<global>,1
61025,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\CommandlineArgs.cpp,cascadia\Remoting\CommandlineArgs.cpp:<global>,,<global>,1
61029,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    // LOAD BEARING CODE
    // If you try to move this into the header, you will experience P A I N
    // It must be defined after CommandlineArgs.g.cpp, otherwise the compiler
    // will give you just the most impossible template errors to try and
    // decipher.
    void CommandlineArgs::Commandline(const winrt::array_view<const winrt::hstring>& value)
    {
        _args = { value.begin(), value.end() };
    }

    winrt::com_array<winrt::hstring> CommandlineArgs::Commandline()
    {
        return winrt::com_array<winrt::hstring>{ _args.begin(), _args.end() };
    }
}",1,cascadia\Remoting\CommandlineArgs.cpp,winrt,9,winrt,1
61030,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    // LOAD BEARING CODE
    // If you try to move this into the header, you will experience P A I N
    // It must be defined after CommandlineArgs.g.cpp, otherwise the compiler
    // will give you just the most impossible template errors to try and
    // decipher.
    void CommandlineArgs::Commandline(const winrt::array_view<const winrt::hstring>& value)
    {
        _args = { value.begin(), value.end() };
    }

    winrt::com_array<winrt::hstring> CommandlineArgs::Commandline()
    {
        return winrt::com_array<winrt::hstring>{ _args.begin(), _args.end() };
    }
}",1,cascadia\Remoting\CommandlineArgs.cpp,winrt.Microsoft,9,Microsoft,1
61031,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    // LOAD BEARING CODE
    // If you try to move this into the header, you will experience P A I N
    // It must be defined after CommandlineArgs.g.cpp, otherwise the compiler
    // will give you just the most impossible template errors to try and
    // decipher.
    void CommandlineArgs::Commandline(const winrt::array_view<const winrt::hstring>& value)
    {
        _args = { value.begin(), value.end() };
    }

    winrt::com_array<winrt::hstring> CommandlineArgs::Commandline()
    {
        return winrt::com_array<winrt::hstring>{ _args.begin(), _args.end() };
    }
}",1,cascadia\Remoting\CommandlineArgs.cpp,winrt.Microsoft.Terminal,9,Terminal,1
61032,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    // LOAD BEARING CODE
    // If you try to move this into the header, you will experience P A I N
    // It must be defined after CommandlineArgs.g.cpp, otherwise the compiler
    // will give you just the most impossible template errors to try and
    // decipher.
    void CommandlineArgs::Commandline(const winrt::array_view<const winrt::hstring>& value)
    {
        _args = { value.begin(), value.end() };
    }

    winrt::com_array<winrt::hstring> CommandlineArgs::Commandline()
    {
        return winrt::com_array<winrt::hstring>{ _args.begin(), _args.end() };
    }
}",1,cascadia\Remoting\CommandlineArgs.cpp,winrt.Microsoft.Terminal.Remoting,9,Remoting,1
61033,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    // LOAD BEARING CODE
    // If you try to move this into the header, you will experience P A I N
    // It must be defined after CommandlineArgs.g.cpp, otherwise the compiler
    // will give you just the most impossible template errors to try and
    // decipher.
    void CommandlineArgs::Commandline(const winrt::array_view<const winrt::hstring>& value)
    {
        _args = { value.begin(), value.end() };
    }

    winrt::com_array<winrt::hstring> CommandlineArgs::Commandline()
    {
        return winrt::com_array<winrt::hstring>{ _args.begin(), _args.end() };
    }
}",1,cascadia\Remoting\CommandlineArgs.cpp,winrt.Microsoft.Terminal.Remoting.implementation,9,implementation,1
61059,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\CommandlineArgs.hpp,cascadia\Remoting\CommandlineArgs.hpp:<global>,,<global>,1
61063,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CommandlineArgs : public CommandlineArgsT<CommandlineArgs>
    {
    public:
        CommandlineArgs() :
            _args{},
            _cwd{ L"""" }
        {
        }

        CommandlineArgs(const winrt::array_view<const winrt::hstring>& args,
                        winrt::hstring currentDirectory,
                        const uint32_t showWindowCommand,
                        winrt::hstring envString) :
            _args{ args.begin(), args.end() },
            _cwd{ currentDirectory },
            _ShowWindowCommand{ showWindowCommand },
            CurrentEnvironment{ envString }
        {
        }

        winrt::hstring CurrentDirectory() { return _cwd; };

        void Commandline(const winrt::array_view<const winrt::hstring>& value);
        winrt::com_array<winrt::hstring> Commandline();

        til::property<winrt::hstring> CurrentEnvironment;

        WINRT_PROPERTY(uint32_t, ShowWindowCom...",1,cascadia\Remoting\CommandlineArgs.hpp,winrt,5,winrt,1
61064,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CommandlineArgs : public CommandlineArgsT<CommandlineArgs>
    {
    public:
        CommandlineArgs() :
            _args{},
            _cwd{ L"""" }
        {
        }

        CommandlineArgs(const winrt::array_view<const winrt::hstring>& args,
                        winrt::hstring currentDirectory,
                        const uint32_t showWindowCommand,
                        winrt::hstring envString) :
            _args{ args.begin(), args.end() },
            _cwd{ currentDirectory },
            _ShowWindowCommand{ showWindowCommand },
            CurrentEnvironment{ envString }
        {
        }

        winrt::hstring CurrentDirectory() { return _cwd; };

        void Commandline(const winrt::array_view<const winrt::hstring>& value);
        winrt::com_array<winrt::hstring> Commandline();

        til::property<winrt::hstring> CurrentEnvironment;

        WINRT_PROPERTY(uint32_t, ShowWindowCom...",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft,5,Microsoft,1
61065,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CommandlineArgs : public CommandlineArgsT<CommandlineArgs>
    {
    public:
        CommandlineArgs() :
            _args{},
            _cwd{ L"""" }
        {
        }

        CommandlineArgs(const winrt::array_view<const winrt::hstring>& args,
                        winrt::hstring currentDirectory,
                        const uint32_t showWindowCommand,
                        winrt::hstring envString) :
            _args{ args.begin(), args.end() },
            _cwd{ currentDirectory },
            _ShowWindowCommand{ showWindowCommand },
            CurrentEnvironment{ envString }
        {
        }

        winrt::hstring CurrentDirectory() { return _cwd; };

        void Commandline(const winrt::array_view<const winrt::hstring>& value);
        winrt::com_array<winrt::hstring> Commandline();

        til::property<winrt::hstring> CurrentEnvironment;

        WINRT_PROPERTY(uint32_t, ShowWindowCom...",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal,5,Terminal,1
61066,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CommandlineArgs : public CommandlineArgsT<CommandlineArgs>
    {
    public:
        CommandlineArgs() :
            _args{},
            _cwd{ L"""" }
        {
        }

        CommandlineArgs(const winrt::array_view<const winrt::hstring>& args,
                        winrt::hstring currentDirectory,
                        const uint32_t showWindowCommand,
                        winrt::hstring envString) :
            _args{ args.begin(), args.end() },
            _cwd{ currentDirectory },
            _ShowWindowCommand{ showWindowCommand },
            CurrentEnvironment{ envString }
        {
        }

        winrt::hstring CurrentDirectory() { return _cwd; };

        void Commandline(const winrt::array_view<const winrt::hstring>& value);
        winrt::com_array<winrt::hstring> Commandline();

        til::property<winrt::hstring> CurrentEnvironment;

        WINRT_PROPERTY(uint32_t, ShowWindowCom...",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal.Remoting,5,Remoting,1
61067,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CommandlineArgs : public CommandlineArgsT<CommandlineArgs>
    {
    public:
        CommandlineArgs() :
            _args{},
            _cwd{ L"""" }
        {
        }

        CommandlineArgs(const winrt::array_view<const winrt::hstring>& args,
                        winrt::hstring currentDirectory,
                        const uint32_t showWindowCommand,
                        winrt::hstring envString) :
            _args{ args.begin(), args.end() },
            _cwd{ currentDirectory },
            _ShowWindowCommand{ showWindowCommand },
            CurrentEnvironment{ envString }
        {
        }

        winrt::hstring CurrentDirectory() { return _cwd; };

        void Commandline(const winrt::array_view<const winrt::hstring>& value);
        winrt::com_array<winrt::hstring> Commandline();

        til::property<winrt::hstring> CurrentEnvironment;

        WINRT_PROPERTY(uint32_t, ShowWindowCom...",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,5,implementation,1
61100,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(CommandlineArgs);
}",1,cascadia\Remoting\CommandlineArgs.hpp,winrt,43,winrt,2
61101,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(CommandlineArgs);
}",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft,43,Microsoft,1
61102,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(CommandlineArgs);
}",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal,43,Terminal,1
61103,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(CommandlineArgs);
}",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal.Remoting,43,Remoting,1
61104,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(CommandlineArgs);
}",1,cascadia\Remoting\CommandlineArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,43,factory_implementation,1
61113,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\FindTargetWindowArgs.cpp,cascadia\Remoting\FindTargetWindowArgs.cpp:<global>,,<global>,1
61120,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\FindTargetWindowArgs.hpp,cascadia\Remoting\FindTargetWindowArgs.hpp:<global>,,<global>,1
61124,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct FindTargetWindowArgs : public FindTargetWindowArgsT<FindTargetWindowArgs>
    {
        WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);
        WINRT_PROPERTY(int, ResultTargetWindow, -1);
        WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);

    public:
        FindTargetWindowArgs(winrt::Microsoft::Terminal::Remoting::CommandlineArgs args) :
            _Args{ args } {};
    };
}",1,cascadia\Remoting\FindTargetWindowArgs.hpp,winrt,23,winrt,1
61125,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct FindTargetWindowArgs : public FindTargetWindowArgsT<FindTargetWindowArgs>
    {
        WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);
        WINRT_PROPERTY(int, ResultTargetWindow, -1);
        WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);

    public:
        FindTargetWindowArgs(winrt::Microsoft::Terminal::Remoting::CommandlineArgs args) :
            _Args{ args } {};
    };
}",1,cascadia\Remoting\FindTargetWindowArgs.hpp,winrt.Microsoft,23,Microsoft,1
61126,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct FindTargetWindowArgs : public FindTargetWindowArgsT<FindTargetWindowArgs>
    {
        WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);
        WINRT_PROPERTY(int, ResultTargetWindow, -1);
        WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);

    public:
        FindTargetWindowArgs(winrt::Microsoft::Terminal::Remoting::CommandlineArgs args) :
            _Args{ args } {};
    };
}",1,cascadia\Remoting\FindTargetWindowArgs.hpp,winrt.Microsoft.Terminal,23,Terminal,1
61127,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct FindTargetWindowArgs : public FindTargetWindowArgsT<FindTargetWindowArgs>
    {
        WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);
        WINRT_PROPERTY(int, ResultTargetWindow, -1);
        WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);

    public:
        FindTargetWindowArgs(winrt::Microsoft::Terminal::Remoting::CommandlineArgs args) :
            _Args{ args } {};
    };
}",1,cascadia\Remoting\FindTargetWindowArgs.hpp,winrt.Microsoft.Terminal.Remoting,23,Remoting,1
61128,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct FindTargetWindowArgs : public FindTargetWindowArgsT<FindTargetWindowArgs>
    {
        WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);
        WINRT_PROPERTY(int, ResultTargetWindow, -1);
        WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);

    public:
        FindTargetWindowArgs(winrt::Microsoft::Terminal::Remoting::CommandlineArgs args) :
            _Args{ args } {};
    };
}",1,cascadia\Remoting\FindTargetWindowArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,23,implementation,1
61145,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\GetWindowLayoutArgs.cpp,cascadia\Remoting\GetWindowLayoutArgs.cpp:<global>,,<global>,1
61152,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\GetWindowLayoutArgs.hpp,cascadia\Remoting\GetWindowLayoutArgs.hpp:<global>,,<global>,1
61156,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct GetWindowLayoutArgs : public GetWindowLayoutArgsT<GetWindowLayoutArgs>
    {
        WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)
    };
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt,19,winrt,1
61157,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct GetWindowLayoutArgs : public GetWindowLayoutArgsT<GetWindowLayoutArgs>
    {
        WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)
    };
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft,19,Microsoft,1
61158,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct GetWindowLayoutArgs : public GetWindowLayoutArgsT<GetWindowLayoutArgs>
    {
        WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)
    };
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal,19,Terminal,1
61159,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct GetWindowLayoutArgs : public GetWindowLayoutArgsT<GetWindowLayoutArgs>
    {
        WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)
    };
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal.Remoting,19,Remoting,1
61160,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct GetWindowLayoutArgs : public GetWindowLayoutArgsT<GetWindowLayoutArgs>
    {
        WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)
    };
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,19,implementation,1
61164,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(GetWindowLayoutArgs);
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt,28,winrt,2
61165,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(GetWindowLayoutArgs);
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft,28,Microsoft,1
61166,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(GetWindowLayoutArgs);
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal,28,Terminal,1
61167,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(GetWindowLayoutArgs);
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal.Remoting,28,Remoting,1
61168,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(GetWindowLayoutArgs);
}",1,cascadia\Remoting\GetWindowLayoutArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,28,factory_implementation,1
61545,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\Monarch.cpp,cascadia\Remoting\Monarch.cpp:<global>,,<global>,1
61548,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Monarch::Monarch() :
        _ourPID{ GetCurrentProcessId() }
    {
        try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Monarch::Monarch(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    Monarch::~Monarch() = default;

    uint64_t Monarch::GetPID()
    {
        return _ourPID;
    }

    // Method Description:
    // - Add the given peasant to the list of peasants we're tracking. This
    //   Peasant may have already been assigned an ID. If it hasn't, then give
    //   it an ID.
    // - NB: this takes a unique_lock on _p...",1,cascadia\Remoting\Monarch.cpp,winrt,21,winrt,1
61549,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Monarch::Monarch() :
        _ourPID{ GetCurrentProcessId() }
    {
        try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Monarch::Monarch(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    Monarch::~Monarch() = default;

    uint64_t Monarch::GetPID()
    {
        return _ourPID;
    }

    // Method Description:
    // - Add the given peasant to the list of peasants we're tracking. This
    //   Peasant may have already been assigned an ID. If it hasn't, then give
    //   it an ID.
    // - NB: this takes a unique_lock on _p...",1,cascadia\Remoting\Monarch.cpp,winrt.Microsoft,21,Microsoft,1
61550,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Monarch::Monarch() :
        _ourPID{ GetCurrentProcessId() }
    {
        try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Monarch::Monarch(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    Monarch::~Monarch() = default;

    uint64_t Monarch::GetPID()
    {
        return _ourPID;
    }

    // Method Description:
    // - Add the given peasant to the list of peasants we're tracking. This
    //   Peasant may have already been assigned an ID. If it hasn't, then give
    //   it an ID.
    // - NB: this takes a unique_lock on _p...",1,cascadia\Remoting\Monarch.cpp,winrt.Microsoft.Terminal,21,Terminal,1
61551,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Monarch::Monarch() :
        _ourPID{ GetCurrentProcessId() }
    {
        try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Monarch::Monarch(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    Monarch::~Monarch() = default;

    uint64_t Monarch::GetPID()
    {
        return _ourPID;
    }

    // Method Description:
    // - Add the given peasant to the list of peasants we're tracking. This
    //   Peasant may have already been assigned an ID. If it hasn't, then give
    //   it an ID.
    // - NB: this takes a unique_lock on _p...",1,cascadia\Remoting\Monarch.cpp,winrt.Microsoft.Terminal.Remoting,21,Remoting,1
61552,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Monarch::Monarch() :
        _ourPID{ GetCurrentProcessId() }
    {
        try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Monarch::Monarch(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    Monarch::~Monarch() = default;

    uint64_t Monarch::GetPID()
    {
        return _ourPID;
    }

    // Method Description:
    // - Add the given peasant to the list of peasants we're tracking. This
    //   Peasant may have already been assigned an ID. If it hasn't, then give
    //   it an ID.
    // - NB: this takes a unique_lock on _p...",1,cascadia\Remoting\Monarch.cpp,winrt.Microsoft.Terminal.Remoting.implementation,21,implementation,1
63399,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\Monarch.hpp,cascadia\Remoting\Monarch.hpp:<global>,,<global>,1
63419,NAMESPACE_BLOCK,"namespace RemotingUnitTests
{
    class RemotingTests;
}",1,cascadia\Remoting\Monarch.hpp,RemotingUnitTests,38,RemotingUnitTests,3
63421,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowRequestedArgs : public WindowRequestedArgsT<WindowRequestedArgs>
    {
    public:
        WindowRequestedArgs(const Remoting::ProposeCommandlineResult& windowInfo, const Remoting::CommandlineArgs& command) :
            _Id{ windowInfo.Id() ? windowInfo.Id().Value() : 0 }, // We'll use 0 as a sentinel, since no window will ever get to have that ID
            _WindowName{ windowInfo.WindowName() },
            _args{ command.Commandline() },
            _CurrentDirectory{ command.CurrentDirectory() },
            _ShowWindowCommand{ command.ShowWindowCommand() },
            _CurrentEnvironment{ command.CurrentEnvironment() } {};

        WindowRequestedArgs(const winrt::hstring& window, const winrt::hstring& content, const Windows::Foundation::IReference<Windows::Foundation::Rect>& bounds) :
            _Id{ 0u },
            _WindowName{ window },
            _args{},
            _CurrentDirectory{}...",1,cascadia\Remoting\Monarch.hpp,winrt,43,winrt,4
63422,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowRequestedArgs : public WindowRequestedArgsT<WindowRequestedArgs>
    {
    public:
        WindowRequestedArgs(const Remoting::ProposeCommandlineResult& windowInfo, const Remoting::CommandlineArgs& command) :
            _Id{ windowInfo.Id() ? windowInfo.Id().Value() : 0 }, // We'll use 0 as a sentinel, since no window will ever get to have that ID
            _WindowName{ windowInfo.WindowName() },
            _args{ command.Commandline() },
            _CurrentDirectory{ command.CurrentDirectory() },
            _ShowWindowCommand{ command.ShowWindowCommand() },
            _CurrentEnvironment{ command.CurrentEnvironment() } {};

        WindowRequestedArgs(const winrt::hstring& window, const winrt::hstring& content, const Windows::Foundation::IReference<Windows::Foundation::Rect>& bounds) :
            _Id{ 0u },
            _WindowName{ window },
            _args{},
            _CurrentDirectory{}...",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft,43,Microsoft,1
63423,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowRequestedArgs : public WindowRequestedArgsT<WindowRequestedArgs>
    {
    public:
        WindowRequestedArgs(const Remoting::ProposeCommandlineResult& windowInfo, const Remoting::CommandlineArgs& command) :
            _Id{ windowInfo.Id() ? windowInfo.Id().Value() : 0 }, // We'll use 0 as a sentinel, since no window will ever get to have that ID
            _WindowName{ windowInfo.WindowName() },
            _args{ command.Commandline() },
            _CurrentDirectory{ command.CurrentDirectory() },
            _ShowWindowCommand{ command.ShowWindowCommand() },
            _CurrentEnvironment{ command.CurrentEnvironment() } {};

        WindowRequestedArgs(const winrt::hstring& window, const winrt::hstring& content, const Windows::Foundation::IReference<Windows::Foundation::Rect>& bounds) :
            _Id{ 0u },
            _WindowName{ window },
            _args{},
            _CurrentDirectory{}...",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal,43,Terminal,1
63424,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowRequestedArgs : public WindowRequestedArgsT<WindowRequestedArgs>
    {
    public:
        WindowRequestedArgs(const Remoting::ProposeCommandlineResult& windowInfo, const Remoting::CommandlineArgs& command) :
            _Id{ windowInfo.Id() ? windowInfo.Id().Value() : 0 }, // We'll use 0 as a sentinel, since no window will ever get to have that ID
            _WindowName{ windowInfo.WindowName() },
            _args{ command.Commandline() },
            _CurrentDirectory{ command.CurrentDirectory() },
            _ShowWindowCommand{ command.ShowWindowCommand() },
            _CurrentEnvironment{ command.CurrentEnvironment() } {};

        WindowRequestedArgs(const winrt::hstring& window, const winrt::hstring& content, const Windows::Foundation::IReference<Windows::Foundation::Rect>& bounds) :
            _Id{ 0u },
            _WindowName{ window },
            _args{},
            _CurrentDirectory{}...",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal.Remoting,43,Remoting,1
63425,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowRequestedArgs : public WindowRequestedArgsT<WindowRequestedArgs>
    {
    public:
        WindowRequestedArgs(const Remoting::ProposeCommandlineResult& windowInfo, const Remoting::CommandlineArgs& command) :
            _Id{ windowInfo.Id() ? windowInfo.Id().Value() : 0 }, // We'll use 0 as a sentinel, since no window will ever get to have that ID
            _WindowName{ windowInfo.WindowName() },
            _args{ command.Commandline() },
            _CurrentDirectory{ command.CurrentDirectory() },
            _ShowWindowCommand{ command.ShowWindowCommand() },
            _CurrentEnvironment{ command.CurrentEnvironment() } {};

        WindowRequestedArgs(const winrt::hstring& window, const winrt::hstring& content, const Windows::Foundation::IReference<Windows::Foundation::Rect>& bounds) :
            _Id{ 0u },
            _WindowName{ window },
            _args{},
            _CurrentDirectory{}...",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal.Remoting.implementation,43,implementation,1
63743,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Monarch);
    BASIC_FACTORY(WindowRequestedArgs);
}",1,cascadia\Remoting\Monarch.hpp,winrt,234,winrt,5
63744,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Monarch);
    BASIC_FACTORY(WindowRequestedArgs);
}",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft,234,Microsoft,1
63745,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Monarch);
    BASIC_FACTORY(WindowRequestedArgs);
}",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal,234,Terminal,1
63746,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Monarch);
    BASIC_FACTORY(WindowRequestedArgs);
}",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal.Remoting,234,Remoting,1
63747,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Monarch);
    BASIC_FACTORY(WindowRequestedArgs);
}",1,cascadia\Remoting\Monarch.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,234,factory_implementation,1
63755,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\MonarchFactory.hpp,cascadia\Remoting\MonarchFactory.hpp:<global>,,<global>,1
63851,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\Peasant.cpp,cascadia\Remoting\Peasant.cpp:<global>,,<global>,1
63855,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Peasant::Peasant() :
        _ourPID{ GetCurrentProcessId() }
    {
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Peasant::Peasant(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }

    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return _ourPID;
    }

    bool Peasant::ExecuteCommandline(const Remoting::CommandlineArgs& args)
    {
        // If this is the first set of args we were ever told about, stash them
        // away. We'll need to get at them later, when we setup the startup
        // actions for the window.
        if (_initialArgs == nullptr)
...",1,cascadia\Remoting\Peasant.cpp,winrt,19,winrt,1
63856,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Peasant::Peasant() :
        _ourPID{ GetCurrentProcessId() }
    {
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Peasant::Peasant(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }

    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return _ourPID;
    }

    bool Peasant::ExecuteCommandline(const Remoting::CommandlineArgs& args)
    {
        // If this is the first set of args we were ever told about, stash them
        // away. We'll need to get at them later, when we setup the startup
        // actions for the window.
        if (_initialArgs == nullptr)
...",1,cascadia\Remoting\Peasant.cpp,winrt.Microsoft,19,Microsoft,1
63857,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Peasant::Peasant() :
        _ourPID{ GetCurrentProcessId() }
    {
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Peasant::Peasant(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }

    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return _ourPID;
    }

    bool Peasant::ExecuteCommandline(const Remoting::CommandlineArgs& args)
    {
        // If this is the first set of args we were ever told about, stash them
        // away. We'll need to get at them later, when we setup the startup
        // actions for the window.
        if (_initialArgs == nullptr)
...",1,cascadia\Remoting\Peasant.cpp,winrt.Microsoft.Terminal,19,Terminal,1
63858,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Peasant::Peasant() :
        _ourPID{ GetCurrentProcessId() }
    {
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Peasant::Peasant(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }

    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return _ourPID;
    }

    bool Peasant::ExecuteCommandline(const Remoting::CommandlineArgs& args)
    {
        // If this is the first set of args we were ever told about, stash them
        // away. We'll need to get at them later, when we setup the startup
        // actions for the window.
        if (_initialArgs == nullptr)
...",1,cascadia\Remoting\Peasant.cpp,winrt.Microsoft.Terminal.Remoting,19,Remoting,1
63859,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    Peasant::Peasant() :
        _ourPID{ GetCurrentProcessId() }
    {
    }

    // This constructor is intended to be used in unit tests,
    // but we need to make it public in order to use make_self
    // in the tests. It's not exposed through the idl though
    // so it's not _truly_ fully public which should be acceptable.
    Peasant::Peasant(const uint64_t testPID) :
        _ourPID{ testPID }
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }

    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return _ourPID;
    }

    bool Peasant::ExecuteCommandline(const Remoting::CommandlineArgs& args)
    {
        // If this is the first set of args we were ever told about, stash them
        // away. We'll need to get at them later, when we setup the startup
        // actions for the window.
        if (_initialArgs == nullptr)
...",1,cascadia\Remoting\Peasant.cpp,winrt.Microsoft.Terminal.Remoting.implementation,19,implementation,1
64309,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\Peasant.hpp,cascadia\Remoting\Peasant.hpp:<global>,,<global>,1
64313,NAMESPACE_BLOCK,"namespace RemotingUnitTests
{
    class RemotingTests;
}",1,cascadia\Remoting\Peasant.hpp,RemotingUnitTests,11,RemotingUnitTests,1
64315,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct AttachRequest : public AttachRequestT<AttachRequest>
    {
        WINRT_PROPERTY(winrt::hstring, Content);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        AttachRequest(winrt::hstring content,
                      uint32_t tabIndex) :
            _Content{ content },
            _TabIndex{ tabIndex } {};
    };

    struct RequestReceiveContentArgs : RequestReceiveContentArgsT<RequestReceiveContentArgs>
    {
        WINRT_PROPERTY(uint64_t, SourceWindow);
        WINRT_PROPERTY(uint64_t, TargetWindow);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        RequestReceiveContentArgs(const uint64_t src, const uint64_t tgt, const uint32_t tabIndex) :
            _SourceWindow{ src },
            _TargetWindow{ tgt },
            _TabIndex{ tabIndex } {};
    };

    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint6...",1,cascadia\Remoting\Peasant.hpp,winrt,15,winrt,2
64316,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct AttachRequest : public AttachRequestT<AttachRequest>
    {
        WINRT_PROPERTY(winrt::hstring, Content);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        AttachRequest(winrt::hstring content,
                      uint32_t tabIndex) :
            _Content{ content },
            _TabIndex{ tabIndex } {};
    };

    struct RequestReceiveContentArgs : RequestReceiveContentArgsT<RequestReceiveContentArgs>
    {
        WINRT_PROPERTY(uint64_t, SourceWindow);
        WINRT_PROPERTY(uint64_t, TargetWindow);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        RequestReceiveContentArgs(const uint64_t src, const uint64_t tgt, const uint32_t tabIndex) :
            _SourceWindow{ src },
            _TargetWindow{ tgt },
            _TabIndex{ tabIndex } {};
    };

    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint6...",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft,15,Microsoft,1
64317,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct AttachRequest : public AttachRequestT<AttachRequest>
    {
        WINRT_PROPERTY(winrt::hstring, Content);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        AttachRequest(winrt::hstring content,
                      uint32_t tabIndex) :
            _Content{ content },
            _TabIndex{ tabIndex } {};
    };

    struct RequestReceiveContentArgs : RequestReceiveContentArgsT<RequestReceiveContentArgs>
    {
        WINRT_PROPERTY(uint64_t, SourceWindow);
        WINRT_PROPERTY(uint64_t, TargetWindow);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        RequestReceiveContentArgs(const uint64_t src, const uint64_t tgt, const uint32_t tabIndex) :
            _SourceWindow{ src },
            _TargetWindow{ tgt },
            _TabIndex{ tabIndex } {};
    };

    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint6...",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal,15,Terminal,1
64318,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct AttachRequest : public AttachRequestT<AttachRequest>
    {
        WINRT_PROPERTY(winrt::hstring, Content);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        AttachRequest(winrt::hstring content,
                      uint32_t tabIndex) :
            _Content{ content },
            _TabIndex{ tabIndex } {};
    };

    struct RequestReceiveContentArgs : RequestReceiveContentArgsT<RequestReceiveContentArgs>
    {
        WINRT_PROPERTY(uint64_t, SourceWindow);
        WINRT_PROPERTY(uint64_t, TargetWindow);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        RequestReceiveContentArgs(const uint64_t src, const uint64_t tgt, const uint32_t tabIndex) :
            _SourceWindow{ src },
            _TargetWindow{ tgt },
            _TabIndex{ tabIndex } {};
    };

    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint6...",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal.Remoting,15,Remoting,1
64319,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct AttachRequest : public AttachRequestT<AttachRequest>
    {
        WINRT_PROPERTY(winrt::hstring, Content);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        AttachRequest(winrt::hstring content,
                      uint32_t tabIndex) :
            _Content{ content },
            _TabIndex{ tabIndex } {};
    };

    struct RequestReceiveContentArgs : RequestReceiveContentArgsT<RequestReceiveContentArgs>
    {
        WINRT_PROPERTY(uint64_t, SourceWindow);
        WINRT_PROPERTY(uint64_t, TargetWindow);
        WINRT_PROPERTY(uint32_t, TabIndex);

    public:
        RequestReceiveContentArgs(const uint64_t src, const uint64_t tgt, const uint32_t tabIndex) :
            _SourceWindow{ src },
            _TargetWindow{ tgt },
            _TabIndex{ tabIndex } {};
    };

    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint6...",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal.Remoting.implementation,15,implementation,1
64465,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Peasant);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\Remoting\Peasant.hpp,winrt,103,winrt,3
64466,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Peasant);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft,103,Microsoft,1
64467,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Peasant);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal,103,Terminal,1
64468,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Peasant);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal.Remoting,103,Remoting,1
64469,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(Peasant);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\Remoting\Peasant.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,103,factory_implementation,1
64479,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\ProposeCommandlineResult.cpp,cascadia\Remoting\ProposeCommandlineResult.cpp:<global>,,<global>,1
64486,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\ProposeCommandlineResult.hpp,cascadia\Remoting\ProposeCommandlineResult.hpp:<global>,,<global>,1
64490,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct ProposeCommandlineResult : public ProposeCommandlineResultT<ProposeCommandlineResult>
    {
    public:
        ProposeCommandlineResult(const Remoting::ProposeCommandlineResult& other) :
            _Id{ other.Id() },
            _WindowName{ other.WindowName() },
            _ShouldCreateWindow{ other.ShouldCreateWindow() } {};

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);
        WINRT_PROPERTY(winrt::hstring, WindowName);
        WINRT_PROPERTY(bool, ShouldCreateWindow, true);

    public:
        ProposeCommandlineResult(bool shouldCreateWindow) :
            _ShouldCreateWindow{ shouldCreateWindow } {};
    };
}",1,cascadia\Remoting\ProposeCommandlineResult.hpp,winrt,23,winrt,1
64491,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct ProposeCommandlineResult : public ProposeCommandlineResultT<ProposeCommandlineResult>
    {
    public:
        ProposeCommandlineResult(const Remoting::ProposeCommandlineResult& other) :
            _Id{ other.Id() },
            _WindowName{ other.WindowName() },
            _ShouldCreateWindow{ other.ShouldCreateWindow() } {};

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);
        WINRT_PROPERTY(winrt::hstring, WindowName);
        WINRT_PROPERTY(bool, ShouldCreateWindow, true);

    public:
        ProposeCommandlineResult(bool shouldCreateWindow) :
            _ShouldCreateWindow{ shouldCreateWindow } {};
    };
}",1,cascadia\Remoting\ProposeCommandlineResult.hpp,winrt.Microsoft,23,Microsoft,1
64492,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct ProposeCommandlineResult : public ProposeCommandlineResultT<ProposeCommandlineResult>
    {
    public:
        ProposeCommandlineResult(const Remoting::ProposeCommandlineResult& other) :
            _Id{ other.Id() },
            _WindowName{ other.WindowName() },
            _ShouldCreateWindow{ other.ShouldCreateWindow() } {};

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);
        WINRT_PROPERTY(winrt::hstring, WindowName);
        WINRT_PROPERTY(bool, ShouldCreateWindow, true);

    public:
        ProposeCommandlineResult(bool shouldCreateWindow) :
            _ShouldCreateWindow{ shouldCreateWindow } {};
    };
}",1,cascadia\Remoting\ProposeCommandlineResult.hpp,winrt.Microsoft.Terminal,23,Terminal,1
64493,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct ProposeCommandlineResult : public ProposeCommandlineResultT<ProposeCommandlineResult>
    {
    public:
        ProposeCommandlineResult(const Remoting::ProposeCommandlineResult& other) :
            _Id{ other.Id() },
            _WindowName{ other.WindowName() },
            _ShouldCreateWindow{ other.ShouldCreateWindow() } {};

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);
        WINRT_PROPERTY(winrt::hstring, WindowName);
        WINRT_PROPERTY(bool, ShouldCreateWindow, true);

    public:
        ProposeCommandlineResult(bool shouldCreateWindow) :
            _ShouldCreateWindow{ shouldCreateWindow } {};
    };
}",1,cascadia\Remoting\ProposeCommandlineResult.hpp,winrt.Microsoft.Terminal.Remoting,23,Remoting,1
64494,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct ProposeCommandlineResult : public ProposeCommandlineResultT<ProposeCommandlineResult>
    {
    public:
        ProposeCommandlineResult(const Remoting::ProposeCommandlineResult& other) :
            _Id{ other.Id() },
            _WindowName{ other.WindowName() },
            _ShouldCreateWindow{ other.ShouldCreateWindow() } {};

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);
        WINRT_PROPERTY(winrt::hstring, WindowName);
        WINRT_PROPERTY(bool, ShouldCreateWindow, true);

    public:
        ProposeCommandlineResult(bool shouldCreateWindow) :
            _ShouldCreateWindow{ shouldCreateWindow } {};
    };
}",1,cascadia\Remoting\ProposeCommandlineResult.hpp,winrt.Microsoft.Terminal.Remoting.implementation,23,implementation,1
64516,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\QuitAllRequestedArgs.cpp,cascadia\Remoting\QuitAllRequestedArgs.cpp:<global>,,<global>,1
64523,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\QuitAllRequestedArgs.hpp,cascadia\Remoting\QuitAllRequestedArgs.hpp:<global>,,<global>,1
64527,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct QuitAllRequestedArgs : public QuitAllRequestedArgsT<QuitAllRequestedArgs>
    {
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)
    };
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt,18,winrt,1
64528,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct QuitAllRequestedArgs : public QuitAllRequestedArgsT<QuitAllRequestedArgs>
    {
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)
    };
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft,18,Microsoft,1
64529,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct QuitAllRequestedArgs : public QuitAllRequestedArgsT<QuitAllRequestedArgs>
    {
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)
    };
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal,18,Terminal,1
64530,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct QuitAllRequestedArgs : public QuitAllRequestedArgsT<QuitAllRequestedArgs>
    {
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)
    };
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal.Remoting,18,Remoting,1
64531,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct QuitAllRequestedArgs : public QuitAllRequestedArgsT<QuitAllRequestedArgs>
    {
        WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)
    };
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,18,implementation,1
64534,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(QuitAllRequestedArgs);
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt,26,winrt,2
64535,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(QuitAllRequestedArgs);
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft,26,Microsoft,1
64536,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(QuitAllRequestedArgs);
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal,26,Terminal,1
64537,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(QuitAllRequestedArgs);
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal.Remoting,26,Remoting,1
64538,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(QuitAllRequestedArgs);
}",1,cascadia\Remoting\QuitAllRequestedArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,26,factory_implementation,1
64547,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\RenameRequestArgs.cpp,cascadia\Remoting\RenameRequestArgs.cpp:<global>,,<global>,1
64554,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\RenameRequestArgs.hpp,cascadia\Remoting\RenameRequestArgs.hpp:<global>,,<global>,1
64558,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct RenameRequestArgs : public RenameRequestArgsT<RenameRequestArgs>
    {
        WINRT_PROPERTY(winrt::hstring, NewName);
        WINRT_PROPERTY(bool, Succeeded, false);

    public:
        RenameRequestArgs(winrt::hstring newName) :
            _NewName{ newName } {};
    };
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt,13,winrt,1
64559,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct RenameRequestArgs : public RenameRequestArgsT<RenameRequestArgs>
    {
        WINRT_PROPERTY(winrt::hstring, NewName);
        WINRT_PROPERTY(bool, Succeeded, false);

    public:
        RenameRequestArgs(winrt::hstring newName) :
            _NewName{ newName } {};
    };
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft,13,Microsoft,1
64560,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct RenameRequestArgs : public RenameRequestArgsT<RenameRequestArgs>
    {
        WINRT_PROPERTY(winrt::hstring, NewName);
        WINRT_PROPERTY(bool, Succeeded, false);

    public:
        RenameRequestArgs(winrt::hstring newName) :
            _NewName{ newName } {};
    };
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal,13,Terminal,1
64561,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct RenameRequestArgs : public RenameRequestArgsT<RenameRequestArgs>
    {
        WINRT_PROPERTY(winrt::hstring, NewName);
        WINRT_PROPERTY(bool, Succeeded, false);

    public:
        RenameRequestArgs(winrt::hstring newName) :
            _NewName{ newName } {};
    };
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal.Remoting,13,Remoting,1
64562,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct RenameRequestArgs : public RenameRequestArgsT<RenameRequestArgs>
    {
        WINRT_PROPERTY(winrt::hstring, NewName);
        WINRT_PROPERTY(bool, Succeeded, false);

    public:
        RenameRequestArgs(winrt::hstring newName) :
            _NewName{ newName } {};
    };
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,13,implementation,1
64571,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(RenameRequestArgs);
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt,26,winrt,2
64572,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(RenameRequestArgs);
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft,26,Microsoft,1
64573,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(RenameRequestArgs);
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal,26,Terminal,1
64574,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(RenameRequestArgs);
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal.Remoting,26,Remoting,1
64575,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(RenameRequestArgs);
}",1,cascadia\Remoting\RenameRequestArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,26,factory_implementation,1
64584,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\SummonWindowBehavior.cpp,cascadia\Remoting\SummonWindowBehavior.cpp:<global>,,<global>,1
64591,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\SummonWindowBehavior.hpp,cascadia\Remoting\SummonWindowBehavior.hpp:<global>,,<global>,1
64595,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowBehavior : public SummonWindowBehaviorT<SummonWindowBehavior>
    {
    public:
        SummonWindowBehavior() = default;
        WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);
        WINRT_PROPERTY(bool, ToggleVisibility, true);
        WINRT_PROPERTY(uint32_t, DropdownDuration, 0);
        WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);

    public:
        SummonWindowBehavior(const Remoting::SummonWindowBehavior& other) :
            _MoveToCurrentDesktop{ other.MoveToCurrentDesktop() },
            _ToMonitor{ other.ToMonitor() },
            _DropdownDuration{ other.DropdownDuration() },
            _ToggleVisibility{ other.ToggleVisibility() } {};
    };
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt,21,winrt,1
64596,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowBehavior : public SummonWindowBehaviorT<SummonWindowBehavior>
    {
    public:
        SummonWindowBehavior() = default;
        WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);
        WINRT_PROPERTY(bool, ToggleVisibility, true);
        WINRT_PROPERTY(uint32_t, DropdownDuration, 0);
        WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);

    public:
        SummonWindowBehavior(const Remoting::SummonWindowBehavior& other) :
            _MoveToCurrentDesktop{ other.MoveToCurrentDesktop() },
            _ToMonitor{ other.ToMonitor() },
            _DropdownDuration{ other.DropdownDuration() },
            _ToggleVisibility{ other.ToggleVisibility() } {};
    };
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft,21,Microsoft,1
64597,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowBehavior : public SummonWindowBehaviorT<SummonWindowBehavior>
    {
    public:
        SummonWindowBehavior() = default;
        WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);
        WINRT_PROPERTY(bool, ToggleVisibility, true);
        WINRT_PROPERTY(uint32_t, DropdownDuration, 0);
        WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);

    public:
        SummonWindowBehavior(const Remoting::SummonWindowBehavior& other) :
            _MoveToCurrentDesktop{ other.MoveToCurrentDesktop() },
            _ToMonitor{ other.ToMonitor() },
            _DropdownDuration{ other.DropdownDuration() },
            _ToggleVisibility{ other.ToggleVisibility() } {};
    };
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal,21,Terminal,1
64598,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowBehavior : public SummonWindowBehaviorT<SummonWindowBehavior>
    {
    public:
        SummonWindowBehavior() = default;
        WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);
        WINRT_PROPERTY(bool, ToggleVisibility, true);
        WINRT_PROPERTY(uint32_t, DropdownDuration, 0);
        WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);

    public:
        SummonWindowBehavior(const Remoting::SummonWindowBehavior& other) :
            _MoveToCurrentDesktop{ other.MoveToCurrentDesktop() },
            _ToMonitor{ other.ToMonitor() },
            _DropdownDuration{ other.DropdownDuration() },
            _ToggleVisibility{ other.ToggleVisibility() } {};
    };
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal.Remoting,21,Remoting,1
64599,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowBehavior : public SummonWindowBehaviorT<SummonWindowBehavior>
    {
    public:
        SummonWindowBehavior() = default;
        WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);
        WINRT_PROPERTY(bool, ToggleVisibility, true);
        WINRT_PROPERTY(uint32_t, DropdownDuration, 0);
        WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);

    public:
        SummonWindowBehavior(const Remoting::SummonWindowBehavior& other) :
            _MoveToCurrentDesktop{ other.MoveToCurrentDesktop() },
            _ToMonitor{ other.ToMonitor() },
            _DropdownDuration{ other.DropdownDuration() },
            _ToggleVisibility{ other.ToggleVisibility() } {};
    };
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal.Remoting.implementation,21,implementation,1
64614,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowBehavior);
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt,41,winrt,2
64615,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowBehavior);
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft,41,Microsoft,1
64616,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowBehavior);
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal,41,Terminal,1
64617,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowBehavior);
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal.Remoting,41,Remoting,1
64618,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowBehavior);
}",1,cascadia\Remoting\SummonWindowBehavior.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,41,factory_implementation,1
64627,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\SummonWindowSelectionArgs.cpp,cascadia\Remoting\SummonWindowSelectionArgs.cpp:<global>,,<global>,1
64634,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\SummonWindowSelectionArgs.hpp,cascadia\Remoting\SummonWindowSelectionArgs.hpp:<global>,,<global>,1
64638,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowSelectionArgs : public SummonWindowSelectionArgsT<SummonWindowSelectionArgs>
    {
    public:
        SummonWindowSelectionArgs() = default;
        SummonWindowSelectionArgs(winrt::hstring name) :
            _WindowName{ name } {};

        WINRT_PROPERTY(winrt::hstring, WindowName);

        WINRT_PROPERTY(bool, FoundMatch, false);
        WINRT_PROPERTY(bool, OnCurrentDesktop, false);
        WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);
    };
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt,22,winrt,1
64639,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowSelectionArgs : public SummonWindowSelectionArgsT<SummonWindowSelectionArgs>
    {
    public:
        SummonWindowSelectionArgs() = default;
        SummonWindowSelectionArgs(winrt::hstring name) :
            _WindowName{ name } {};

        WINRT_PROPERTY(winrt::hstring, WindowName);

        WINRT_PROPERTY(bool, FoundMatch, false);
        WINRT_PROPERTY(bool, OnCurrentDesktop, false);
        WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);
    };
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft,22,Microsoft,1
64640,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowSelectionArgs : public SummonWindowSelectionArgsT<SummonWindowSelectionArgs>
    {
    public:
        SummonWindowSelectionArgs() = default;
        SummonWindowSelectionArgs(winrt::hstring name) :
            _WindowName{ name } {};

        WINRT_PROPERTY(winrt::hstring, WindowName);

        WINRT_PROPERTY(bool, FoundMatch, false);
        WINRT_PROPERTY(bool, OnCurrentDesktop, false);
        WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);
    };
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal,22,Terminal,1
64641,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowSelectionArgs : public SummonWindowSelectionArgsT<SummonWindowSelectionArgs>
    {
    public:
        SummonWindowSelectionArgs() = default;
        SummonWindowSelectionArgs(winrt::hstring name) :
            _WindowName{ name } {};

        WINRT_PROPERTY(winrt::hstring, WindowName);

        WINRT_PROPERTY(bool, FoundMatch, false);
        WINRT_PROPERTY(bool, OnCurrentDesktop, false);
        WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);
    };
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal.Remoting,22,Remoting,1
64642,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct SummonWindowSelectionArgs : public SummonWindowSelectionArgsT<SummonWindowSelectionArgs>
    {
    public:
        SummonWindowSelectionArgs() = default;
        SummonWindowSelectionArgs(winrt::hstring name) :
            _WindowName{ name } {};

        WINRT_PROPERTY(winrt::hstring, WindowName);

        WINRT_PROPERTY(bool, FoundMatch, false);
        WINRT_PROPERTY(bool, OnCurrentDesktop, false);
        WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);

        WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);
    };
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,22,implementation,1
64658,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowSelectionArgs);
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt,41,winrt,2
64659,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowSelectionArgs);
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft,41,Microsoft,1
64660,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowSelectionArgs);
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal,41,Terminal,1
64661,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowSelectionArgs);
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal.Remoting,41,Remoting,1
64662,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(SummonWindowSelectionArgs);
}",1,cascadia\Remoting\SummonWindowSelectionArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,41,factory_implementation,1
64671,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\WindowActivatedArgs.cpp,cascadia\Remoting\WindowActivatedArgs.cpp:<global>,,<global>,1
64678,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\WindowActivatedArgs.hpp,cascadia\Remoting\WindowActivatedArgs.hpp:<global>,,<global>,1
64682,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CompareWindowActivatedArgs
    {
        bool operator()(const Remoting::WindowActivatedArgs& lhs, const Remoting::WindowActivatedArgs& rhs) const
        {
            return lhs.ActivatedTime() > rhs.ActivatedTime();
        }
    };
    struct WindowActivatedArgs : public WindowActivatedArgsT<WindowActivatedArgs>
    {
        WINRT_PROPERTY(uint64_t, PeasantID, 0);
        WINRT_PROPERTY(winrt::guid, DesktopID);
        WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {});
        WINRT_PROPERTY(uint64_t, Hwnd, 0);

    public:
        WindowActivatedArgs(uint64_t peasantID,
                            uint64_t hwnd,
                            winrt::guid desktopID,
                            winrt::Windows::Foundation::DateTime timestamp) :
            _PeasantID{ peasantID },
            _Hwnd{ hwnd },
            _DesktopID{ desktopID },
            _ActivatedTime{ timestamp } {};...",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt,18,winrt,1
64683,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CompareWindowActivatedArgs
    {
        bool operator()(const Remoting::WindowActivatedArgs& lhs, const Remoting::WindowActivatedArgs& rhs) const
        {
            return lhs.ActivatedTime() > rhs.ActivatedTime();
        }
    };
    struct WindowActivatedArgs : public WindowActivatedArgsT<WindowActivatedArgs>
    {
        WINRT_PROPERTY(uint64_t, PeasantID, 0);
        WINRT_PROPERTY(winrt::guid, DesktopID);
        WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {});
        WINRT_PROPERTY(uint64_t, Hwnd, 0);

    public:
        WindowActivatedArgs(uint64_t peasantID,
                            uint64_t hwnd,
                            winrt::guid desktopID,
                            winrt::Windows::Foundation::DateTime timestamp) :
            _PeasantID{ peasantID },
            _Hwnd{ hwnd },
            _DesktopID{ desktopID },
            _ActivatedTime{ timestamp } {};...",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft,18,Microsoft,1
64684,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CompareWindowActivatedArgs
    {
        bool operator()(const Remoting::WindowActivatedArgs& lhs, const Remoting::WindowActivatedArgs& rhs) const
        {
            return lhs.ActivatedTime() > rhs.ActivatedTime();
        }
    };
    struct WindowActivatedArgs : public WindowActivatedArgsT<WindowActivatedArgs>
    {
        WINRT_PROPERTY(uint64_t, PeasantID, 0);
        WINRT_PROPERTY(winrt::guid, DesktopID);
        WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {});
        WINRT_PROPERTY(uint64_t, Hwnd, 0);

    public:
        WindowActivatedArgs(uint64_t peasantID,
                            uint64_t hwnd,
                            winrt::guid desktopID,
                            winrt::Windows::Foundation::DateTime timestamp) :
            _PeasantID{ peasantID },
            _Hwnd{ hwnd },
            _DesktopID{ desktopID },
            _ActivatedTime{ timestamp } {};...",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal,18,Terminal,1
64685,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CompareWindowActivatedArgs
    {
        bool operator()(const Remoting::WindowActivatedArgs& lhs, const Remoting::WindowActivatedArgs& rhs) const
        {
            return lhs.ActivatedTime() > rhs.ActivatedTime();
        }
    };
    struct WindowActivatedArgs : public WindowActivatedArgsT<WindowActivatedArgs>
    {
        WINRT_PROPERTY(uint64_t, PeasantID, 0);
        WINRT_PROPERTY(winrt::guid, DesktopID);
        WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {});
        WINRT_PROPERTY(uint64_t, Hwnd, 0);

    public:
        WindowActivatedArgs(uint64_t peasantID,
                            uint64_t hwnd,
                            winrt::guid desktopID,
                            winrt::Windows::Foundation::DateTime timestamp) :
            _PeasantID{ peasantID },
            _Hwnd{ hwnd },
            _DesktopID{ desktopID },
            _ActivatedTime{ timestamp } {};...",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal.Remoting,18,Remoting,1
64686,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct CompareWindowActivatedArgs
    {
        bool operator()(const Remoting::WindowActivatedArgs& lhs, const Remoting::WindowActivatedArgs& rhs) const
        {
            return lhs.ActivatedTime() > rhs.ActivatedTime();
        }
    };
    struct WindowActivatedArgs : public WindowActivatedArgsT<WindowActivatedArgs>
    {
        WINRT_PROPERTY(uint64_t, PeasantID, 0);
        WINRT_PROPERTY(winrt::guid, DesktopID);
        WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {});
        WINRT_PROPERTY(uint64_t, Hwnd, 0);

    public:
        WindowActivatedArgs(uint64_t peasantID,
                            uint64_t hwnd,
                            winrt::guid desktopID,
                            winrt::Windows::Foundation::DateTime timestamp) :
            _PeasantID{ peasantID },
            _Hwnd{ hwnd },
            _DesktopID{ desktopID },
            _ActivatedTime{ timestamp } {};...",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal.Remoting.implementation,18,implementation,1
64730,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowActivatedArgs);
}",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt,57,winrt,2
64731,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowActivatedArgs);
}",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft,57,Microsoft,1
64732,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowActivatedArgs);
}",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal,57,Terminal,1
64733,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowActivatedArgs);
}",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal.Remoting,57,Remoting,1
64734,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowActivatedArgs);
}",1,cascadia\Remoting\WindowActivatedArgs.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,57,factory_implementation,1
64815,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\WindowManager.cpp,cascadia\Remoting\WindowManager.cpp:<global>,,<global>,1
64818,NAMESPACE_BLOCK,"namespace
{
    const GUID& MonarchCLSID()
    {
        if (!IsPackaged()) [[unlikely]]
        {
            // Unpackaged installations don't have the luxury of magic package isolation
            // to stop them from accidentally touching each other's monarchs.
            // We need to enforce that ourselves by making their monarch CLSIDs unique
            // per install.
            // This applies in both portable mode and normal unpackaged mode.
            // We'll use a v5 UUID based on the install folder to unique them.
            static GUID processRootHashedGuid = []() {
                // {5456C4DB-557D-4A22-B043-B1577418E4AF}
                static constexpr GUID processRootHashedGuidBase = { 0x5456c4db, 0x557d, 0x4a22, { 0xb0, 0x43, 0xb1, 0x57, 0x74, 0x18, 0xe4, 0xaf } };

                // Make a temporary monarch CLSID based on the unpackaged install root
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstan...",1,cascadia\Remoting\WindowManager.cpp,anonymous_namespace_0,25,,1
64836,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    WindowManager::WindowManager()
    {
    }
    WindowManager::~WindowManager()
    {
        // IMPORTANT! Tear down the registration as soon as we exit. If we're not a
        // real peasant window (the monarch passed our commandline to someone else),
        // then the monarch dies, we don't want our registration becoming the active
        // monarch!
        CoRevokeClassObject(_registrationHostClass);
        _registrationHostClass = 0;
    }

    void WindowManager::_createMonarch()
    {
        // Heads up! This only works because we're using
        // ""metadata-based-marshalling"" for our WinRT types. That means the OS is
        // using the .winmd file we generate to figure out the proxy/stub
        // definitions for our types automatically. This only works in the following
        // cases:
        //
        // * If we're running unpackaged: the .winmd must be a sibling of the .exe
        // * If ...",1,cascadia\Remoting\WindowManager.cpp,winrt,53,winrt,2
64837,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    WindowManager::WindowManager()
    {
    }
    WindowManager::~WindowManager()
    {
        // IMPORTANT! Tear down the registration as soon as we exit. If we're not a
        // real peasant window (the monarch passed our commandline to someone else),
        // then the monarch dies, we don't want our registration becoming the active
        // monarch!
        CoRevokeClassObject(_registrationHostClass);
        _registrationHostClass = 0;
    }

    void WindowManager::_createMonarch()
    {
        // Heads up! This only works because we're using
        // ""metadata-based-marshalling"" for our WinRT types. That means the OS is
        // using the .winmd file we generate to figure out the proxy/stub
        // definitions for our types automatically. This only works in the following
        // cases:
        //
        // * If we're running unpackaged: the .winmd must be a sibling of the .exe
        // * If ...",1,cascadia\Remoting\WindowManager.cpp,winrt.Microsoft,53,Microsoft,1
64838,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    WindowManager::WindowManager()
    {
    }
    WindowManager::~WindowManager()
    {
        // IMPORTANT! Tear down the registration as soon as we exit. If we're not a
        // real peasant window (the monarch passed our commandline to someone else),
        // then the monarch dies, we don't want our registration becoming the active
        // monarch!
        CoRevokeClassObject(_registrationHostClass);
        _registrationHostClass = 0;
    }

    void WindowManager::_createMonarch()
    {
        // Heads up! This only works because we're using
        // ""metadata-based-marshalling"" for our WinRT types. That means the OS is
        // using the .winmd file we generate to figure out the proxy/stub
        // definitions for our types automatically. This only works in the following
        // cases:
        //
        // * If we're running unpackaged: the .winmd must be a sibling of the .exe
        // * If ...",1,cascadia\Remoting\WindowManager.cpp,winrt.Microsoft.Terminal,53,Terminal,1
64839,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    WindowManager::WindowManager()
    {
    }
    WindowManager::~WindowManager()
    {
        // IMPORTANT! Tear down the registration as soon as we exit. If we're not a
        // real peasant window (the monarch passed our commandline to someone else),
        // then the monarch dies, we don't want our registration becoming the active
        // monarch!
        CoRevokeClassObject(_registrationHostClass);
        _registrationHostClass = 0;
    }

    void WindowManager::_createMonarch()
    {
        // Heads up! This only works because we're using
        // ""metadata-based-marshalling"" for our WinRT types. That means the OS is
        // using the .winmd file we generate to figure out the proxy/stub
        // definitions for our types automatically. This only works in the following
        // cases:
        //
        // * If we're running unpackaged: the .winmd must be a sibling of the .exe
        // * If ...",1,cascadia\Remoting\WindowManager.cpp,winrt.Microsoft.Terminal.Remoting,53,Remoting,1
64840,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    WindowManager::WindowManager()
    {
    }
    WindowManager::~WindowManager()
    {
        // IMPORTANT! Tear down the registration as soon as we exit. If we're not a
        // real peasant window (the monarch passed our commandline to someone else),
        // then the monarch dies, we don't want our registration becoming the active
        // monarch!
        CoRevokeClassObject(_registrationHostClass);
        _registrationHostClass = 0;
    }

    void WindowManager::_createMonarch()
    {
        // Heads up! This only works because we're using
        // ""metadata-based-marshalling"" for our WinRT types. That means the OS is
        // using the .winmd file we generate to figure out the proxy/stub
        // definitions for our types automatically. This only works in the following
        // cases:
        //
        // * If we're running unpackaged: the .winmd must be a sibling of the .exe
        // * If ...",1,cascadia\Remoting\WindowManager.cpp,winrt.Microsoft.Terminal.Remoting.implementation,53,implementation,1
65418,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\WindowManager.hpp,cascadia\Remoting\WindowManager.hpp:<global>,,<global>,1
65422,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowManager : public WindowManagerT<WindowManager>
    {
    public:
        WindowManager();
        ~WindowManager();
        winrt::Microsoft::Terminal::Remoting::ProposeCommandlineResult ProposeCommandline(const winrt::Microsoft::Terminal::Remoting::CommandlineArgs& args, const bool isolatedMode);
        Remoting::Peasant CreatePeasant(const Remoting::WindowRequestedArgs& args);

        void SignalClose(const Remoting::Peasant& peasant);
        void SummonWindow(const Remoting::SummonWindowSelectionArgs& args);
        void SummonAllWindows();
        Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Terminal::Remoting::PeasantInfo> GetPeasantInfos();

        uint64_t GetNumberOfPeasants();

        static winrt::fire_and_forget RequestQuitAll(Remoting::Peasant peasant);
        void UpdateActiveTabTitle(const winrt::hstring& title, const Remoting::Peasant& peasant);

        Windows:...",1,cascadia\Remoting\WindowManager.hpp,winrt,24,winrt,1
65423,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowManager : public WindowManagerT<WindowManager>
    {
    public:
        WindowManager();
        ~WindowManager();
        winrt::Microsoft::Terminal::Remoting::ProposeCommandlineResult ProposeCommandline(const winrt::Microsoft::Terminal::Remoting::CommandlineArgs& args, const bool isolatedMode);
        Remoting::Peasant CreatePeasant(const Remoting::WindowRequestedArgs& args);

        void SignalClose(const Remoting::Peasant& peasant);
        void SummonWindow(const Remoting::SummonWindowSelectionArgs& args);
        void SummonAllWindows();
        Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Terminal::Remoting::PeasantInfo> GetPeasantInfos();

        uint64_t GetNumberOfPeasants();

        static winrt::fire_and_forget RequestQuitAll(Remoting::Peasant peasant);
        void UpdateActiveTabTitle(const winrt::hstring& title, const Remoting::Peasant& peasant);

        Windows:...",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft,24,Microsoft,1
65424,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowManager : public WindowManagerT<WindowManager>
    {
    public:
        WindowManager();
        ~WindowManager();
        winrt::Microsoft::Terminal::Remoting::ProposeCommandlineResult ProposeCommandline(const winrt::Microsoft::Terminal::Remoting::CommandlineArgs& args, const bool isolatedMode);
        Remoting::Peasant CreatePeasant(const Remoting::WindowRequestedArgs& args);

        void SignalClose(const Remoting::Peasant& peasant);
        void SummonWindow(const Remoting::SummonWindowSelectionArgs& args);
        void SummonAllWindows();
        Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Terminal::Remoting::PeasantInfo> GetPeasantInfos();

        uint64_t GetNumberOfPeasants();

        static winrt::fire_and_forget RequestQuitAll(Remoting::Peasant peasant);
        void UpdateActiveTabTitle(const winrt::hstring& title, const Remoting::Peasant& peasant);

        Windows:...",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal,24,Terminal,1
65425,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowManager : public WindowManagerT<WindowManager>
    {
    public:
        WindowManager();
        ~WindowManager();
        winrt::Microsoft::Terminal::Remoting::ProposeCommandlineResult ProposeCommandline(const winrt::Microsoft::Terminal::Remoting::CommandlineArgs& args, const bool isolatedMode);
        Remoting::Peasant CreatePeasant(const Remoting::WindowRequestedArgs& args);

        void SignalClose(const Remoting::Peasant& peasant);
        void SummonWindow(const Remoting::SummonWindowSelectionArgs& args);
        void SummonAllWindows();
        Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Terminal::Remoting::PeasantInfo> GetPeasantInfos();

        uint64_t GetNumberOfPeasants();

        static winrt::fire_and_forget RequestQuitAll(Remoting::Peasant peasant);
        void UpdateActiveTabTitle(const winrt::hstring& title, const Remoting::Peasant& peasant);

        Windows:...",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal.Remoting,24,Remoting,1
65426,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::implementation
{
    struct WindowManager : public WindowManagerT<WindowManager>
    {
    public:
        WindowManager();
        ~WindowManager();
        winrt::Microsoft::Terminal::Remoting::ProposeCommandlineResult ProposeCommandline(const winrt::Microsoft::Terminal::Remoting::CommandlineArgs& args, const bool isolatedMode);
        Remoting::Peasant CreatePeasant(const Remoting::WindowRequestedArgs& args);

        void SignalClose(const Remoting::Peasant& peasant);
        void SummonWindow(const Remoting::SummonWindowSelectionArgs& args);
        void SummonAllWindows();
        Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Terminal::Remoting::PeasantInfo> GetPeasantInfos();

        uint64_t GetNumberOfPeasants();

        static winrt::fire_and_forget RequestQuitAll(Remoting::Peasant peasant);
        void UpdateActiveTabTitle(const winrt::hstring& title, const Remoting::Peasant& peasant);

        Windows:...",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal.Remoting.implementation,24,implementation,1
65550,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowManager);
}",1,cascadia\Remoting\WindowManager.hpp,winrt,76,winrt,2
65551,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowManager);
}",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft,76,Microsoft,1
65552,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowManager);
}",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal,76,Terminal,1
65553,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowManager);
}",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal.Remoting,76,Remoting,1
65554,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Remoting::factory_implementation
{
    BASIC_FACTORY(WindowManager);
}",1,cascadia\Remoting\WindowManager.hpp,winrt.Microsoft.Terminal.Remoting.factory_implementation,76,factory_implementation,1
65563,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\init.cpp,cascadia\Remoting\init.cpp:<global>,,<global>,1
65609,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\pch.cpp,cascadia\Remoting\pch.cpp:<global>,,<global>,1
65648,NAMESPACE_BLOCK,<empty>,,cascadia\Remoting\pch.hpp,cascadia\Remoting\pch.hpp:<global>,,<global>,1
65666,NAMESPACE_BLOCK,<empty>,,cascadia\ShellExtension\OpenTerminalHere.cpp,cascadia\ShellExtension\OpenTerminalHere.cpp:<global>,,<global>,1
65971,NAMESPACE_BLOCK,<empty>,,cascadia\ShellExtension\OpenTerminalHere.hpp,cascadia\ShellExtension\OpenTerminalHere.hpp:<global>,,<global>,1
66057,NAMESPACE_BLOCK,<empty>,,cascadia\ShellExtension\dllmain.cpp,cascadia\ShellExtension\dllmain.cpp:<global>,,<global>,1
66094,NAMESPACE_BLOCK,<empty>,,cascadia\ShellExtension\pch.cpp,cascadia\ShellExtension\pch.cpp:<global>,,<global>,1
66117,NAMESPACE_BLOCK,<empty>,,cascadia\ShellExtension\pch.hpp,cascadia\ShellExtension\pch.hpp:<global>,,<global>,1
66136,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AboutDialog.cpp,cascadia\TerminalApp\AboutDialog.cpp:<global>,,<global>,1
66140,NAMESPACE_BLOCK,"namespace winrt
{
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\AboutDialog.cpp,winrt,21,winrt,1
66141,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\AboutDialog.cpp,Windows.UI.Xaml,23,WUX,1
66143,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    AboutDialog::AboutDialog()
    {
        InitializeComponent();
        _queueUpdateCheck();
    }

    winrt::hstring AboutDialog::ApplicationDisplayName()
    {
        return CascadiaSettings::ApplicationDisplayName();
    }

    winrt::hstring AboutDialog::ApplicationVersion()
    {
        return CascadiaSettings::ApplicationVersion();
    }

    void AboutDialog::_SendFeedbackOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& /*eventArgs*/)
    {
#if defined(WT_BRANDING_RELEASE)
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2125419"", nullptr, nullptr, SW_SHOW);
#else
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2204904"", nullptr, nullptr, SW_SHOW);
#endif
    }

    void AboutDialog::_ThirdPartyNoticesOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
  ...",1,cascadia\TerminalApp\AboutDialog.cpp,winrt,27,winrt,2
66144,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    AboutDialog::AboutDialog()
    {
        InitializeComponent();
        _queueUpdateCheck();
    }

    winrt::hstring AboutDialog::ApplicationDisplayName()
    {
        return CascadiaSettings::ApplicationDisplayName();
    }

    winrt::hstring AboutDialog::ApplicationVersion()
    {
        return CascadiaSettings::ApplicationVersion();
    }

    void AboutDialog::_SendFeedbackOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& /*eventArgs*/)
    {
#if defined(WT_BRANDING_RELEASE)
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2125419"", nullptr, nullptr, SW_SHOW);
#else
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2204904"", nullptr, nullptr, SW_SHOW);
#endif
    }

    void AboutDialog::_ThirdPartyNoticesOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
  ...",1,cascadia\TerminalApp\AboutDialog.cpp,winrt.TerminalApp,27,TerminalApp,1
66145,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    AboutDialog::AboutDialog()
    {
        InitializeComponent();
        _queueUpdateCheck();
    }

    winrt::hstring AboutDialog::ApplicationDisplayName()
    {
        return CascadiaSettings::ApplicationDisplayName();
    }

    winrt::hstring AboutDialog::ApplicationVersion()
    {
        return CascadiaSettings::ApplicationVersion();
    }

    void AboutDialog::_SendFeedbackOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& /*eventArgs*/)
    {
#if defined(WT_BRANDING_RELEASE)
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2125419"", nullptr, nullptr, SW_SHOW);
#else
        ShellExecute(nullptr, nullptr, L""https://go.microsoft.com/fwlink/?linkid=2204904"", nullptr, nullptr, SW_SHOW);
#endif
    }

    void AboutDialog::_ThirdPartyNoticesOnClick(const IInspectable& /*sender*/, const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
  ...",1,cascadia\TerminalApp\AboutDialog.cpp,winrt.TerminalApp.implementation,27,implementation,1
66437,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AboutDialog.hpp,cascadia\TerminalApp\AboutDialog.hpp:<global>,,<global>,1
66441,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AboutDialog : AboutDialogT<AboutDialog>
    {
    public:
        AboutDialog();

        winrt::hstring ApplicationDisplayName();
        winrt::hstring ApplicationVersion();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, UpdatesAvailable, _PropertyChangedHandlers, false);
        WINRT_OBSERVABLE_PROPERTY(bool, CheckingForUpdates, _PropertyChangedHandlers, false);

    private:
        friend struct AboutDialogT<AboutDialog>; // for Xaml to bind events

        std::chrono::system_clock::time_point _lastUpdateCheck{};

        void _ThirdPartyNoticesOnClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void _SendFeedbackOnClick(const IInspectable& sender, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& eventArgs);
        winrt::fire_and_forget _queueUpdateCheck();
    };
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt,8,winrt,1
66442,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AboutDialog : AboutDialogT<AboutDialog>
    {
    public:
        AboutDialog();

        winrt::hstring ApplicationDisplayName();
        winrt::hstring ApplicationVersion();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, UpdatesAvailable, _PropertyChangedHandlers, false);
        WINRT_OBSERVABLE_PROPERTY(bool, CheckingForUpdates, _PropertyChangedHandlers, false);

    private:
        friend struct AboutDialogT<AboutDialog>; // for Xaml to bind events

        std::chrono::system_clock::time_point _lastUpdateCheck{};

        void _ThirdPartyNoticesOnClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void _SendFeedbackOnClick(const IInspectable& sender, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& eventArgs);
        winrt::fire_and_forget _queueUpdateCheck();
    };
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt.TerminalApp,8,TerminalApp,1
66443,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AboutDialog : AboutDialogT<AboutDialog>
    {
    public:
        AboutDialog();

        winrt::hstring ApplicationDisplayName();
        winrt::hstring ApplicationVersion();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, UpdatesAvailable, _PropertyChangedHandlers, false);
        WINRT_OBSERVABLE_PROPERTY(bool, CheckingForUpdates, _PropertyChangedHandlers, false);

    private:
        friend struct AboutDialogT<AboutDialog>; // for Xaml to bind events

        std::chrono::system_clock::time_point _lastUpdateCheck{};

        void _ThirdPartyNoticesOnClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void _SendFeedbackOnClick(const IInspectable& sender, const Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs& eventArgs);
        winrt::fire_and_forget _queueUpdateCheck();
    };
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt.TerminalApp.implementation,8,implementation,1
66485,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AboutDialog);
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt,33,winrt,2
66486,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AboutDialog);
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt.TerminalApp,33,TerminalApp,1
66487,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AboutDialog);
}",1,cascadia\TerminalApp\AboutDialog.hpp,winrt.TerminalApp.factory_implementation,33,factory_implementation,1
66498,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ActionPaletteItem.cpp,cascadia\TerminalApp\ActionPaletteItem.cpp:<global>,,<global>,1
66502,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ActionPaletteItem::ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command) :
        _Command(command)
    {
        Name(command.Name());
        KeyChordText(command.KeyChordText());
        Icon(command.IconPath());
    }
}",1,cascadia\TerminalApp\ActionPaletteItem.cpp,winrt,19,winrt,1
66503,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ActionPaletteItem::ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command) :
        _Command(command)
    {
        Name(command.Name());
        KeyChordText(command.KeyChordText());
        Icon(command.IconPath());
    }
}",1,cascadia\TerminalApp\ActionPaletteItem.cpp,winrt.TerminalApp,19,TerminalApp,1
66504,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ActionPaletteItem::ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command) :
        _Command(command)
    {
        Name(command.Name());
        KeyChordText(command.KeyChordText());
        Icon(command.IconPath());
    }
}",1,cascadia\TerminalApp\ActionPaletteItem.cpp,winrt.TerminalApp.implementation,19,implementation,1
66530,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ActionPaletteItem.hpp,cascadia\TerminalApp\ActionPaletteItem.hpp:<global>,,<global>,1
66534,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ActionPaletteItem : ActionPaletteItemT<ActionPaletteItem, PaletteItem>
    {
        ActionPaletteItem() = default;
        ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command);

        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::Command, Command, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _commandChangedRevoker;
    };
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt,9,winrt,1
66535,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ActionPaletteItem : ActionPaletteItemT<ActionPaletteItem, PaletteItem>
    {
        ActionPaletteItem() = default;
        ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command);

        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::Command, Command, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _commandChangedRevoker;
    };
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt.TerminalApp,9,TerminalApp,1
66536,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ActionPaletteItem : ActionPaletteItemT<ActionPaletteItem, PaletteItem>
    {
        ActionPaletteItem() = default;
        ActionPaletteItem(const Microsoft::Terminal::Settings::Model::Command& command);

        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::Command, Command, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _commandChangedRevoker;
    };
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt.TerminalApp.implementation,9,implementation,1
66549,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ActionPaletteItem);
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt,23,winrt,2
66550,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ActionPaletteItem);
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt.TerminalApp,23,TerminalApp,1
66551,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ActionPaletteItem);
}",1,cascadia\TerminalApp\ActionPaletteItem.hpp,winrt.TerminalApp.factory_implementation,23,factory_implementation,1
66664,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ActionPreviewHandlers.cpp,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>,,<global>,1
66667,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\ActionPreviewHandlers.cpp,winrt,26,winrt,1
66668,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\ActionPreviewHandlers.cpp,Microsoft.UI.Xaml,28,MUX,1
66669,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\ActionPreviewHandlers.cpp,Windows.UI.Xaml,29,WUX,2
66671,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Stop previewing the currently previewed action. We can use this to
    //   clean up any state from that action's preview.
    // - We use _lastPreviewedAction to determine what type of action to clean up.
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TerminalPage::_EndPreview()
    {
        if (_lastPreviewedAction == nullptr)
        {
            return;
        }
        switch (_lastPreviewedAction.Action())
        {
        case ShortcutAction::SetColorScheme:
        case ShortcutAction::AdjustOpacity:
        {
            _RunRestorePreviews();
            break;
        }
        }
        _lastPreviewedAction = nullptr;
    }

    // Method Description:
    // - Revert any changes from the preview action. This will run the restore
    //   function that the preview added to _restorePreviewFuncs
    // Arguments:
    // - <none>
    // Return Value:
    //...",1,cascadia\TerminalApp\ActionPreviewHandlers.cpp,winrt,33,winrt,2
66672,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Stop previewing the currently previewed action. We can use this to
    //   clean up any state from that action's preview.
    // - We use _lastPreviewedAction to determine what type of action to clean up.
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TerminalPage::_EndPreview()
    {
        if (_lastPreviewedAction == nullptr)
        {
            return;
        }
        switch (_lastPreviewedAction.Action())
        {
        case ShortcutAction::SetColorScheme:
        case ShortcutAction::AdjustOpacity:
        {
            _RunRestorePreviews();
            break;
        }
        }
        _lastPreviewedAction = nullptr;
    }

    // Method Description:
    // - Revert any changes from the preview action. This will run the restore
    //   function that the preview added to _restorePreviewFuncs
    // Arguments:
    // - <none>
    // Return Value:
    //...",1,cascadia\TerminalApp\ActionPreviewHandlers.cpp,winrt.TerminalApp,33,TerminalApp,1
66673,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Stop previewing the currently previewed action. We can use this to
    //   clean up any state from that action's preview.
    // - We use _lastPreviewedAction to determine what type of action to clean up.
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TerminalPage::_EndPreview()
    {
        if (_lastPreviewedAction == nullptr)
        {
            return;
        }
        switch (_lastPreviewedAction.Action())
        {
        case ShortcutAction::SetColorScheme:
        case ShortcutAction::AdjustOpacity:
        {
            _RunRestorePreviews();
            break;
        }
        }
        _lastPreviewedAction = nullptr;
    }

    // Method Description:
    // - Revert any changes from the preview action. This will run the restore
    //   function that the preview added to _restorePreviewFuncs
    // Arguments:
    // - <none>
    // Return Value:
    //...",1,cascadia\TerminalApp\ActionPreviewHandlers.cpp,winrt.TerminalApp.implementation,33,implementation,1
66834,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\App.base.hpp,cascadia\TerminalApp\App.base.hpp:<global>,,<global>,1
66838,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    template<typename D, typename... I>
    struct App_baseWithProvider : public App_base<D, ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider>
    {
        using IXamlType = ::winrt::Windows::UI::Xaml::Markup::IXamlType;

        IXamlType GetXamlType(const ::winrt::Windows::UI::Xaml::Interop::TypeName& type)
        {
            return AppProvider()->GetXamlType(type);
        }

        IXamlType GetXamlType(const ::winrt::hstring& fullName)
        {
            return AppProvider()->GetXamlType(fullName);
        }

        ::winrt::com_array<::winrt::Windows::UI::Xaml::Markup::XmlnsDefinition> GetXmlnsDefinitions()
        {
            return AppProvider()->GetXmlnsDefinitions();
        }

        void AddOtherProvider(const ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider& provider)
        {
            AppProvider()->AddOtherProvider(provider);
        }

    private:
        bool _contentLoaded{ false };
 ...",1,cascadia\TerminalApp\App.base.hpp,winrt,3,winrt,1
66839,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    template<typename D, typename... I>
    struct App_baseWithProvider : public App_base<D, ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider>
    {
        using IXamlType = ::winrt::Windows::UI::Xaml::Markup::IXamlType;

        IXamlType GetXamlType(const ::winrt::Windows::UI::Xaml::Interop::TypeName& type)
        {
            return AppProvider()->GetXamlType(type);
        }

        IXamlType GetXamlType(const ::winrt::hstring& fullName)
        {
            return AppProvider()->GetXamlType(fullName);
        }

        ::winrt::com_array<::winrt::Windows::UI::Xaml::Markup::XmlnsDefinition> GetXmlnsDefinitions()
        {
            return AppProvider()->GetXmlnsDefinitions();
        }

        void AddOtherProvider(const ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider& provider)
        {
            AppProvider()->AddOtherProvider(provider);
        }

    private:
        bool _contentLoaded{ false };
 ...",1,cascadia\TerminalApp\App.base.hpp,winrt.TerminalApp,3,TerminalApp,1
66840,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    template<typename D, typename... I>
    struct App_baseWithProvider : public App_base<D, ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider>
    {
        using IXamlType = ::winrt::Windows::UI::Xaml::Markup::IXamlType;

        IXamlType GetXamlType(const ::winrt::Windows::UI::Xaml::Interop::TypeName& type)
        {
            return AppProvider()->GetXamlType(type);
        }

        IXamlType GetXamlType(const ::winrt::hstring& fullName)
        {
            return AppProvider()->GetXamlType(fullName);
        }

        ::winrt::com_array<::winrt::Windows::UI::Xaml::Markup::XmlnsDefinition> GetXmlnsDefinitions()
        {
            return AppProvider()->GetXmlnsDefinitions();
        }

        void AddOtherProvider(const ::winrt::Windows::UI::Xaml::Markup::IXamlMetadataProvider& provider)
        {
            AppProvider()->AddOtherProvider(provider);
        }

    private:
        bool _contentLoaded{ false };
 ...",1,cascadia\TerminalApp\App.base.hpp,winrt.TerminalApp.implementation,3,implementation,1
66920,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\App.cpp,cascadia\TerminalApp\App.cpp:<global>,,<global>,1
66924,NAMESPACE_BLOCK,namespace xaml = ::winrt::Windows::UI::Xaml;,1,cascadia\TerminalApp\App.cpp,winrt.Windows.UI.Xaml,16,xaml,1
66925,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    App::App()
    {
        Initialize();

        // Disable XAML's automatic backplating of text when in High Contrast
        // mode: we want full control of and responsibility for the foreground
        // and background colors that we draw in XAML.
        HighContrastAdjustment(::winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment::None);
    }

    void App::Initialize()
    {
        // LOAD BEARING
        AddOtherProvider(winrt::Microsoft::Terminal::Control::XamlMetaDataProvider{});
        AddOtherProvider(winrt::Microsoft::UI::Xaml::XamlTypeInfo::XamlControlsXamlMetaDataProvider{});

        const auto dispatcherQueue = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();
        if (!dispatcherQueue)
        {
            _windowsXamlManager = xaml::Hosting::WindowsXamlManager::InitializeForCurrentThread();

            // As of Process Model v3, terminal windows are all created on their
            // ...",1,cascadia\TerminalApp\App.cpp,winrt,18,winrt,2
66926,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    App::App()
    {
        Initialize();

        // Disable XAML's automatic backplating of text when in High Contrast
        // mode: we want full control of and responsibility for the foreground
        // and background colors that we draw in XAML.
        HighContrastAdjustment(::winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment::None);
    }

    void App::Initialize()
    {
        // LOAD BEARING
        AddOtherProvider(winrt::Microsoft::Terminal::Control::XamlMetaDataProvider{});
        AddOtherProvider(winrt::Microsoft::UI::Xaml::XamlTypeInfo::XamlControlsXamlMetaDataProvider{});

        const auto dispatcherQueue = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();
        if (!dispatcherQueue)
        {
            _windowsXamlManager = xaml::Hosting::WindowsXamlManager::InitializeForCurrentThread();

            // As of Process Model v3, terminal windows are all created on their
            // ...",1,cascadia\TerminalApp\App.cpp,winrt.TerminalApp,18,TerminalApp,1
66927,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    App::App()
    {
        Initialize();

        // Disable XAML's automatic backplating of text when in High Contrast
        // mode: we want full control of and responsibility for the foreground
        // and background colors that we draw in XAML.
        HighContrastAdjustment(::winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment::None);
    }

    void App::Initialize()
    {
        // LOAD BEARING
        AddOtherProvider(winrt::Microsoft::Terminal::Control::XamlMetaDataProvider{});
        AddOtherProvider(winrt::Microsoft::UI::Xaml::XamlTypeInfo::XamlControlsXamlMetaDataProvider{});

        const auto dispatcherQueue = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();
        if (!dispatcherQueue)
        {
            _windowsXamlManager = xaml::Hosting::WindowsXamlManager::InitializeForCurrentThread();

            // As of Process Model v3, terminal windows are all created on their
            // ...",1,cascadia\TerminalApp\App.cpp,winrt.TerminalApp.implementation,18,implementation,1
67110,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\App.hpp,cascadia\TerminalApp\App.hpp:<global>,,<global>,1
67114,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct App : AppT2<App>
    {
    public:
        App();
        void OnLaunched(const Windows::ApplicationModel::Activation::LaunchActivatedEventArgs&);
        void Initialize();

        TerminalApp::AppLogic Logic();

        void Close();
        void PrepareForSettingsUI();

        bool IsDisposed() const
        {
            return _bIsClosed;
        }

    private:
        winrt::Windows::UI::Xaml::Hosting::WindowsXamlManager _windowsXamlManager = nullptr;
        bool _bIsClosed = false;
        bool _preparedForSettingsUI{ false };
    };
}",1,cascadia\TerminalApp\App.hpp,winrt,10,winrt,1
67115,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct App : AppT2<App>
    {
    public:
        App();
        void OnLaunched(const Windows::ApplicationModel::Activation::LaunchActivatedEventArgs&);
        void Initialize();

        TerminalApp::AppLogic Logic();

        void Close();
        void PrepareForSettingsUI();

        bool IsDisposed() const
        {
            return _bIsClosed;
        }

    private:
        winrt::Windows::UI::Xaml::Hosting::WindowsXamlManager _windowsXamlManager = nullptr;
        bool _bIsClosed = false;
        bool _preparedForSettingsUI{ false };
    };
}",1,cascadia\TerminalApp\App.hpp,winrt.TerminalApp,10,TerminalApp,1
67116,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct App : AppT2<App>
    {
    public:
        App();
        void OnLaunched(const Windows::ApplicationModel::Activation::LaunchActivatedEventArgs&);
        void Initialize();

        TerminalApp::AppLogic Logic();

        void Close();
        void PrepareForSettingsUI();

        bool IsDisposed() const
        {
            return _bIsClosed;
        }

    private:
        winrt::Windows::UI::Xaml::Hosting::WindowsXamlManager _windowsXamlManager = nullptr;
        bool _bIsClosed = false;
        bool _preparedForSettingsUI{ false };
    };
}",1,cascadia\TerminalApp\App.hpp,winrt.TerminalApp.implementation,10,implementation,1
67166,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    struct App : AppT<App, implementation::App>
    {
    };
}",1,cascadia\TerminalApp\App.hpp,winrt,36,winrt,2
67167,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    struct App : AppT<App, implementation::App>
    {
    };
}",1,cascadia\TerminalApp\App.hpp,winrt.TerminalApp,36,TerminalApp,1
67168,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    struct App : AppT<App, implementation::App>
    {
    };
}",1,cascadia\TerminalApp\App.hpp,winrt.TerminalApp.factory_implementation,36,factory_implementation,1
67504,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppActionHandlers.cpp,cascadia\TerminalApp\AppActionHandlers.cpp:<global>,,<global>,1
67507,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\AppActionHandlers.cpp,winrt,24,winrt,1
67508,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\AppActionHandlers.cpp,Microsoft.UI.Xaml,26,MUX,1
67510,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TermControl TerminalPage::_senderOrActiveControl(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto arg{ sender.try_as<TermControl>() })
            {
                return arg;
            }
        }
        return _GetActiveControl();
    }
    winrt::com_ptr<TerminalTab> TerminalPage::_senderOrFocusedTab(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto tab{ sender.try_as<TerminalApp::TerminalTab>() })
            {
                return _GetTerminalTabImpl(tab);
            }
        }
        return _GetFocusedTabImpl();
    }

    void TerminalPage::_HandleOpenNewTabDropdown(const IInspectable& /*sender*/,
                                                 const ActionEventArgs& args)
    {
        _OpenNewTabDropdown();
        args.Handled(true);
    }

    void TerminalPage::_HandleDuplicateTab(const IInspectable& /*sender*/,
                             ...",1,cascadia\TerminalApp\AppActionHandlers.cpp,winrt,30,winrt,2
67511,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TermControl TerminalPage::_senderOrActiveControl(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto arg{ sender.try_as<TermControl>() })
            {
                return arg;
            }
        }
        return _GetActiveControl();
    }
    winrt::com_ptr<TerminalTab> TerminalPage::_senderOrFocusedTab(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto tab{ sender.try_as<TerminalApp::TerminalTab>() })
            {
                return _GetTerminalTabImpl(tab);
            }
        }
        return _GetFocusedTabImpl();
    }

    void TerminalPage::_HandleOpenNewTabDropdown(const IInspectable& /*sender*/,
                                                 const ActionEventArgs& args)
    {
        _OpenNewTabDropdown();
        args.Handled(true);
    }

    void TerminalPage::_HandleDuplicateTab(const IInspectable& /*sender*/,
                             ...",1,cascadia\TerminalApp\AppActionHandlers.cpp,winrt.TerminalApp,30,TerminalApp,1
67512,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TermControl TerminalPage::_senderOrActiveControl(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto arg{ sender.try_as<TermControl>() })
            {
                return arg;
            }
        }
        return _GetActiveControl();
    }
    winrt::com_ptr<TerminalTab> TerminalPage::_senderOrFocusedTab(const IInspectable& sender)
    {
        if (sender)
        {
            if (auto tab{ sender.try_as<TerminalApp::TerminalTab>() })
            {
                return _GetTerminalTabImpl(tab);
            }
        }
        return _GetFocusedTabImpl();
    }

    void TerminalPage::_HandleOpenNewTabDropdown(const IInspectable& /*sender*/,
                                                 const ActionEventArgs& args)
    {
        _OpenNewTabDropdown();
        args.Handled(true);
    }

    void TerminalPage::_HandleDuplicateTab(const IInspectable& /*sender*/,
                             ...",1,cascadia\TerminalApp\AppActionHandlers.cpp,winrt.TerminalApp.implementation,30,implementation,1
71651,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppCommandlineArgs.cpp,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>,,<global>,1
73174,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppCommandlineArgs.hpp,cascadia\TerminalApp\AppCommandlineArgs.hpp:<global>,,<global>,1
73178,NAMESPACE_BLOCK,"namespace TerminalApp
{
    class AppCommandlineArgs;
}",1,cascadia\TerminalApp\AppCommandlineArgs.hpp,TerminalApp,15,TerminalApp,1
73524,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppKeyBindings.cpp,cascadia\TerminalApp\AppKeyBindings.cpp:<global>,,<global>,1
73528,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    bool AppKeyBindings::TryKeyChord(const KeyChord& kc)
    {
        if (const auto cmd{ _actionMap.GetActionByKeyChord(kc) })
        {
            return _dispatch.DoAction(cmd.ActionAndArgs());
        }
        return false;
    }

    bool AppKeyBindings::IsKeyChordExplicitlyUnbound(const KeyChord& kc)
    {
        return _actionMap.IsKeyChordExplicitlyUnbound(kc);
    }

    void AppKeyBindings::SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch)
    {
        _dispatch = dispatch;
    }

    void AppKeyBindings::SetActionMap(const winrt::Microsoft::Terminal::Settings::Model::IActionMapView& actionMap)
    {
        _actionMap = actionMap;
    }
}",1,cascadia\TerminalApp\AppKeyBindings.cpp,winrt,13,winrt,1
73529,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    bool AppKeyBindings::TryKeyChord(const KeyChord& kc)
    {
        if (const auto cmd{ _actionMap.GetActionByKeyChord(kc) })
        {
            return _dispatch.DoAction(cmd.ActionAndArgs());
        }
        return false;
    }

    bool AppKeyBindings::IsKeyChordExplicitlyUnbound(const KeyChord& kc)
    {
        return _actionMap.IsKeyChordExplicitlyUnbound(kc);
    }

    void AppKeyBindings::SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch)
    {
        _dispatch = dispatch;
    }

    void AppKeyBindings::SetActionMap(const winrt::Microsoft::Terminal::Settings::Model::IActionMapView& actionMap)
    {
        _actionMap = actionMap;
    }
}",1,cascadia\TerminalApp\AppKeyBindings.cpp,winrt.TerminalApp,13,TerminalApp,1
73530,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    bool AppKeyBindings::TryKeyChord(const KeyChord& kc)
    {
        if (const auto cmd{ _actionMap.GetActionByKeyChord(kc) })
        {
            return _dispatch.DoAction(cmd.ActionAndArgs());
        }
        return false;
    }

    bool AppKeyBindings::IsKeyChordExplicitlyUnbound(const KeyChord& kc)
    {
        return _actionMap.IsKeyChordExplicitlyUnbound(kc);
    }

    void AppKeyBindings::SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch)
    {
        _dispatch = dispatch;
    }

    void AppKeyBindings::SetActionMap(const winrt::Microsoft::Terminal::Settings::Model::IActionMapView& actionMap)
    {
        _actionMap = actionMap;
    }
}",1,cascadia\TerminalApp\AppKeyBindings.cpp,winrt.TerminalApp.implementation,13,implementation,1
73591,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppKeyBindings.hpp,cascadia\TerminalApp\AppKeyBindings.hpp:<global>,,<global>,1
73595,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class SettingsTests;
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,TerminalAppLocalTests,10,TerminalAppLocalTests,1
73597,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AppKeyBindings : AppKeyBindingsT<AppKeyBindings>
    {
        AppKeyBindings() = default;

        bool TryKeyChord(const winrt::Microsoft::Terminal::Control::KeyChord& kc);
        bool IsKeyChordExplicitlyUnbound(const winrt::Microsoft::Terminal::Control::KeyChord& kc);

        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

    private:
        winrt::Microsoft::Terminal::Settings::Model::IActionMapView _actionMap{ nullptr };

        winrt::TerminalApp::ShortcutActionDispatch _dispatch{ nullptr };

        friend class TerminalAppLocalTests::SettingsTests;
    };
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt,15,winrt,2
73598,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AppKeyBindings : AppKeyBindingsT<AppKeyBindings>
    {
        AppKeyBindings() = default;

        bool TryKeyChord(const winrt::Microsoft::Terminal::Control::KeyChord& kc);
        bool IsKeyChordExplicitlyUnbound(const winrt::Microsoft::Terminal::Control::KeyChord& kc);

        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

    private:
        winrt::Microsoft::Terminal::Settings::Model::IActionMapView _actionMap{ nullptr };

        winrt::TerminalApp::ShortcutActionDispatch _dispatch{ nullptr };

        friend class TerminalAppLocalTests::SettingsTests;
    };
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt.TerminalApp,15,TerminalApp,1
73599,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct AppKeyBindings : AppKeyBindingsT<AppKeyBindings>
    {
        AppKeyBindings() = default;

        bool TryKeyChord(const winrt::Microsoft::Terminal::Control::KeyChord& kc);
        bool IsKeyChordExplicitlyUnbound(const winrt::Microsoft::Terminal::Control::KeyChord& kc);

        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

    private:
        winrt::Microsoft::Terminal::Settings::Model::IActionMapView _actionMap{ nullptr };

        winrt::TerminalApp::ShortcutActionDispatch _dispatch{ nullptr };

        friend class TerminalAppLocalTests::SettingsTests;
    };
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt.TerminalApp.implementation,15,implementation,1
73640,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppKeyBindings);
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt,36,winrt,3
73641,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppKeyBindings);
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt.TerminalApp,36,TerminalApp,1
73642,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppKeyBindings);
}",1,cascadia\TerminalApp\AppKeyBindings.hpp,winrt.TerminalApp.factory_implementation,36,factory_implementation,1
73772,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppLogic.cpp,cascadia\TerminalApp\AppLogic.cpp:<global>,,<global>,1
73775,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\AppLogic.cpp,winrt,28,winrt,1
73776,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\AppLogic.cpp,Microsoft.UI.Xaml,30,MUX,1
73835,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Function Description:
    // - Get the AppLogic for the current active Xaml application, or null if there isn't one.
    // Return value:
    // - A pointer (bare) to the AppLogic, or nullptr. The app logic outlives all other objects,
    //   unless the application is in a terrible way, so this is ""safe.""
    AppLogic* AppLogic::Current() noexcept
    try
    {
        if (auto currentXamlApp{ winrt::Windows::UI::Xaml::Application::Current().try_as<winrt::TerminalApp::App>() })
        {
            if (auto appLogicPointer{ winrt::get_self<AppLogic>(currentXamlApp.Logic()) })
            {
                return appLogicPointer;
            }
        }
        return nullptr;
    }
    catch (...)
    {
        LOG_CAUGHT_EXCEPTION();
        return nullptr;
    }

    // Method Description:
    // - Returns the settings currently in use by the entire Terminal application.
    // - IMPORTANT! This can throw! Make sure to try/ca...",1,cascadia\TerminalApp\AppLogic.cpp,winrt,88,winrt,9
73836,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Function Description:
    // - Get the AppLogic for the current active Xaml application, or null if there isn't one.
    // Return value:
    // - A pointer (bare) to the AppLogic, or nullptr. The app logic outlives all other objects,
    //   unless the application is in a terrible way, so this is ""safe.""
    AppLogic* AppLogic::Current() noexcept
    try
    {
        if (auto currentXamlApp{ winrt::Windows::UI::Xaml::Application::Current().try_as<winrt::TerminalApp::App>() })
        {
            if (auto appLogicPointer{ winrt::get_self<AppLogic>(currentXamlApp.Logic()) })
            {
                return appLogicPointer;
            }
        }
        return nullptr;
    }
    catch (...)
    {
        LOG_CAUGHT_EXCEPTION();
        return nullptr;
    }

    // Method Description:
    // - Returns the settings currently in use by the entire Terminal application.
    // - IMPORTANT! This can throw! Make sure to try/ca...",1,cascadia\TerminalApp\AppLogic.cpp,winrt.TerminalApp,88,TerminalApp,1
73837,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Function Description:
    // - Get the AppLogic for the current active Xaml application, or null if there isn't one.
    // Return value:
    // - A pointer (bare) to the AppLogic, or nullptr. The app logic outlives all other objects,
    //   unless the application is in a terrible way, so this is ""safe.""
    AppLogic* AppLogic::Current() noexcept
    try
    {
        if (auto currentXamlApp{ winrt::Windows::UI::Xaml::Application::Current().try_as<winrt::TerminalApp::App>() })
        {
            if (auto appLogicPointer{ winrt::get_self<AppLogic>(currentXamlApp.Logic()) })
            {
                return appLogicPointer;
            }
        }
        return nullptr;
    }
    catch (...)
    {
        LOG_CAUGHT_EXCEPTION();
        return nullptr;
    }

    // Method Description:
    // - Returns the settings currently in use by the entire Terminal application.
    // - IMPORTANT! This can throw! Make sure to try/ca...",1,cascadia\TerminalApp\AppLogic.cpp,winrt.TerminalApp.implementation,88,implementation,1
74966,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\AppLogic.hpp,cascadia\TerminalApp\AppLogic.hpp:<global>,,<global>,1
74970,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FindTargetWindowResult : FindTargetWindowResultT<FindTargetWindowResult>
    {
        WINRT_PROPERTY(int32_t, WindowId, -1);
        WINRT_PROPERTY(winrt::hstring, WindowName, L"""");

    public:
        FindTargetWindowResult(const int32_t id, const winrt::hstring& name) :
            _WindowId{ id }, _WindowName{ name } {};

        FindTargetWindowResult(const int32_t id) :
            FindTargetWindowResult(id, L""""){};
    };

    struct AppLogic : AppLogicT<AppLogic>
    {
    public:
        static AppLogic* Current() noexcept;
        static const Microsoft::Terminal::Settings::Model::CascadiaSettings CurrentAppSettings();

        AppLogic();

        void Create();
        bool IsRunningElevated() const noexcept;
        bool CanDragDrop() const noexcept;
        void ReloadSettings();
        void NotifyRootInitialized();

        bool HasSettingsStartupActions() const noexcept;

        bool ShouldUsePersistedLayou...",1,cascadia\TerminalApp\AppLogic.hpp,winrt,26,winrt,1
74971,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FindTargetWindowResult : FindTargetWindowResultT<FindTargetWindowResult>
    {
        WINRT_PROPERTY(int32_t, WindowId, -1);
        WINRT_PROPERTY(winrt::hstring, WindowName, L"""");

    public:
        FindTargetWindowResult(const int32_t id, const winrt::hstring& name) :
            _WindowId{ id }, _WindowName{ name } {};

        FindTargetWindowResult(const int32_t id) :
            FindTargetWindowResult(id, L""""){};
    };

    struct AppLogic : AppLogicT<AppLogic>
    {
    public:
        static AppLogic* Current() noexcept;
        static const Microsoft::Terminal::Settings::Model::CascadiaSettings CurrentAppSettings();

        AppLogic();

        void Create();
        bool IsRunningElevated() const noexcept;
        bool CanDragDrop() const noexcept;
        void ReloadSettings();
        void NotifyRootInitialized();

        bool HasSettingsStartupActions() const noexcept;

        bool ShouldUsePersistedLayou...",1,cascadia\TerminalApp\AppLogic.hpp,winrt.TerminalApp,26,TerminalApp,1
74972,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FindTargetWindowResult : FindTargetWindowResultT<FindTargetWindowResult>
    {
        WINRT_PROPERTY(int32_t, WindowId, -1);
        WINRT_PROPERTY(winrt::hstring, WindowName, L"""");

    public:
        FindTargetWindowResult(const int32_t id, const winrt::hstring& name) :
            _WindowId{ id }, _WindowName{ name } {};

        FindTargetWindowResult(const int32_t id) :
            FindTargetWindowResult(id, L""""){};
    };

    struct AppLogic : AppLogicT<AppLogic>
    {
    public:
        static AppLogic* Current() noexcept;
        static const Microsoft::Terminal::Settings::Model::CascadiaSettings CurrentAppSettings();

        AppLogic();

        void Create();
        bool IsRunningElevated() const noexcept;
        bool CanDragDrop() const noexcept;
        void ReloadSettings();
        void NotifyRootInitialized();

        bool HasSettingsStartupActions() const noexcept;

        bool ShouldUsePersistedLayou...",1,cascadia\TerminalApp\AppLogic.hpp,winrt.TerminalApp.implementation,26,implementation,1
75162,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppLogic);
}",1,cascadia\TerminalApp\AppLogic.hpp,winrt,122,winrt,2
75163,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppLogic);
}",1,cascadia\TerminalApp\AppLogic.hpp,winrt.TerminalApp,122,TerminalApp,1
75164,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(AppLogic);
}",1,cascadia\TerminalApp\AppLogic.hpp,winrt.TerminalApp.factory_implementation,122,factory_implementation,1
75169,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ColorHelper.cpp,cascadia\TerminalApp\ColorHelper.cpp:<global>,,<global>,1
76083,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ColorHelper.hpp,cascadia\TerminalApp\ColorHelper.hpp:<global>,,<global>,1
76087,NAMESPACE_BLOCK,"namespace winrt::TerminalApp
{
    class HSL
    {
    public:
        float H;
        float S;
        float L;
    };

    class ColorHelper
    {
    public:
        static bool IsBrightColor(const Windows::UI::Color& color);
        static HSL RgbToHsl(const Windows::UI::Color& color);
        static Windows::UI::Color HslToRgb(const HSL& color);
        static Windows::UI::Color Lighten(const Windows::UI::Color& color, float amount = 10.f);
        static Windows::UI::Color Darken(const Windows::UI::Color& color, float amount = 10.f);
        static Windows::UI::Color GetAccentColor(const Windows::UI::Color& color);
        static float GetLuminance(const Windows::UI::Color& color);
        static float GetReadability(const Windows::UI::Color& first, const Windows::UI::Color& second);
        static float GetReadability(const HSL& first, const HSL& second);

    private:
        static float HueToRgb(float p, float q, float t);
    };
}",1,cascadia\TerminalApp\ColorHelper.hpp,winrt,5,winrt,1
76088,NAMESPACE_BLOCK,"namespace winrt::TerminalApp
{
    class HSL
    {
    public:
        float H;
        float S;
        float L;
    };

    class ColorHelper
    {
    public:
        static bool IsBrightColor(const Windows::UI::Color& color);
        static HSL RgbToHsl(const Windows::UI::Color& color);
        static Windows::UI::Color HslToRgb(const HSL& color);
        static Windows::UI::Color Lighten(const Windows::UI::Color& color, float amount = 10.f);
        static Windows::UI::Color Darken(const Windows::UI::Color& color, float amount = 10.f);
        static Windows::UI::Color GetAccentColor(const Windows::UI::Color& color);
        static float GetLuminance(const Windows::UI::Color& color);
        static float GetReadability(const Windows::UI::Color& first, const Windows::UI::Color& second);
        static float GetReadability(const HSL& first, const HSL& second);

    private:
        static float HueToRgb(float p, float q, float t);
    };
}",1,cascadia\TerminalApp\ColorHelper.hpp,winrt.TerminalApp,5,TerminalApp,1
76159,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ColorPickupFlyout.cpp,cascadia\TerminalApp\ColorPickupFlyout.cpp:<global>,,<global>,1
76163,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Default constructor, localizes the buttons and hooks
    // up the event fired by the custom color picker, so that
    // the tab color is set on the fly when selecting a non-preset color
    // Arguments:
    // - <none>
    ColorPickupFlyout::ColorPickupFlyout()
    {
        InitializeComponent();

        OkButton().Content(winrt::box_value(RS_(L""Ok"")));
        CustomColorButton().Content(winrt::box_value(RS_(L""TabColorCustomButton/Content"")));
        ClearColorButton().Content(winrt::box_value(RS_(L""TabColorClearButton/Content"")));
    }

    // Method Description:
    // - Handler of the click event for the preset color swatches.
    // Reads the color from the clicked rectangle and fires an event
    // with the selected color. After that hides the flyout
    // Arguments:
    // - sender: the rectangle that got clicked
    // Return Value:
    // - <none>
    void ColorPickupFlyout::ColorBut...",1,cascadia\TerminalApp\ColorPickupFlyout.cpp,winrt,6,winrt,1
76164,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Default constructor, localizes the buttons and hooks
    // up the event fired by the custom color picker, so that
    // the tab color is set on the fly when selecting a non-preset color
    // Arguments:
    // - <none>
    ColorPickupFlyout::ColorPickupFlyout()
    {
        InitializeComponent();

        OkButton().Content(winrt::box_value(RS_(L""Ok"")));
        CustomColorButton().Content(winrt::box_value(RS_(L""TabColorCustomButton/Content"")));
        ClearColorButton().Content(winrt::box_value(RS_(L""TabColorClearButton/Content"")));
    }

    // Method Description:
    // - Handler of the click event for the preset color swatches.
    // Reads the color from the clicked rectangle and fires an event
    // with the selected color. After that hides the flyout
    // Arguments:
    // - sender: the rectangle that got clicked
    // Return Value:
    // - <none>
    void ColorPickupFlyout::ColorBut...",1,cascadia\TerminalApp\ColorPickupFlyout.cpp,winrt.TerminalApp,6,TerminalApp,1
76165,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Default constructor, localizes the buttons and hooks
    // up the event fired by the custom color picker, so that
    // the tab color is set on the fly when selecting a non-preset color
    // Arguments:
    // - <none>
    ColorPickupFlyout::ColorPickupFlyout()
    {
        InitializeComponent();

        OkButton().Content(winrt::box_value(RS_(L""Ok"")));
        CustomColorButton().Content(winrt::box_value(RS_(L""TabColorCustomButton/Content"")));
        ClearColorButton().Content(winrt::box_value(RS_(L""TabColorClearButton/Content"")));
    }

    // Method Description:
    // - Handler of the click event for the preset color swatches.
    // Reads the color from the clicked rectangle and fires an event
    // with the selected color. After that hides the flyout
    // Arguments:
    // - sender: the rectangle that got clicked
    // Return Value:
    // - <none>
    void ColorPickupFlyout::ColorBut...",1,cascadia\TerminalApp\ColorPickupFlyout.cpp,winrt.TerminalApp.implementation,6,implementation,1
76330,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ColorPickupFlyout.hpp,cascadia\TerminalApp\ColorPickupFlyout.hpp:<global>,,<global>,1
76334,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ColorPickupFlyout : ColorPickupFlyoutT<ColorPickupFlyout>
    {
        ColorPickupFlyout();

        void ColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ShowColorPickerButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void CustomColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ClearColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ColorPicker_ColorChanged(const Microsoft::UI::Xaml::Controls::ColorPicker&, const Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);

        WINRT_CALLBACK(ColorCleared, TerminalApp::ColorClearedArgs);
        WINRT_CALLBACK(ColorSelected, TerminalApp::ColorSelectedArgs);
    };
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt,4,winrt,1
76335,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ColorPickupFlyout : ColorPickupFlyoutT<ColorPickupFlyout>
    {
        ColorPickupFlyout();

        void ColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ShowColorPickerButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void CustomColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ClearColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ColorPicker_ColorChanged(const Microsoft::UI::Xaml::Controls::ColorPicker&, const Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);

        WINRT_CALLBACK(ColorCleared, TerminalApp::ColorClearedArgs);
        WINRT_CALLBACK(ColorSelected, TerminalApp::ColorSelectedArgs);
    };
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt.TerminalApp,4,TerminalApp,1
76336,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ColorPickupFlyout : ColorPickupFlyoutT<ColorPickupFlyout>
    {
        ColorPickupFlyout();

        void ColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ShowColorPickerButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void CustomColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ClearColorButton_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& args);
        void ColorPicker_ColorChanged(const Microsoft::UI::Xaml::Controls::ColorPicker&, const Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);

        WINRT_CALLBACK(ColorCleared, TerminalApp::ColorClearedArgs);
        WINRT_CALLBACK(ColorSelected, TerminalApp::ColorSelectedArgs);
    };
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt.TerminalApp.implementation,4,implementation,1
76374,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ColorPickupFlyout);
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt,21,winrt,2
76375,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ColorPickupFlyout);
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt.TerminalApp,21,TerminalApp,1
76376,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ColorPickupFlyout);
}",1,cascadia\TerminalApp\ColorPickupFlyout.hpp,winrt.TerminalApp.factory_implementation,21,factory_implementation,1
76387,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\CommandLinePaletteItem.cpp,cascadia\TerminalApp\CommandLinePaletteItem.cpp:<global>,,<global>,1
76391,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandLinePaletteItem::CommandLinePaletteItem(const winrt::hstring& commandLine) :
        _CommandLine(commandLine)
    {
        Name(commandLine);
    }
}",1,cascadia\TerminalApp\CommandLinePaletteItem.cpp,winrt,19,winrt,1
76392,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandLinePaletteItem::CommandLinePaletteItem(const winrt::hstring& commandLine) :
        _CommandLine(commandLine)
    {
        Name(commandLine);
    }
}",1,cascadia\TerminalApp\CommandLinePaletteItem.cpp,winrt.TerminalApp,19,TerminalApp,1
76393,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandLinePaletteItem::CommandLinePaletteItem(const winrt::hstring& commandLine) :
        _CommandLine(commandLine)
    {
        Name(commandLine);
    }
}",1,cascadia\TerminalApp\CommandLinePaletteItem.cpp,winrt.TerminalApp.implementation,19,implementation,1
76406,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\CommandLinePaletteItem.hpp,cascadia\TerminalApp\CommandLinePaletteItem.hpp:<global>,,<global>,1
76410,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct CommandLinePaletteItem : CommandLinePaletteItemT<CommandLinePaletteItem, PaletteItem>
    {
        CommandLinePaletteItem() = default;
        CommandLinePaletteItem(const winrt::hstring& commandLine);

        WINRT_PROPERTY(winrt::hstring, CommandLine);
    };
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt,9,winrt,1
76411,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct CommandLinePaletteItem : CommandLinePaletteItemT<CommandLinePaletteItem, PaletteItem>
    {
        CommandLinePaletteItem() = default;
        CommandLinePaletteItem(const winrt::hstring& commandLine);

        WINRT_PROPERTY(winrt::hstring, CommandLine);
    };
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt.TerminalApp,9,TerminalApp,1
76412,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct CommandLinePaletteItem : CommandLinePaletteItemT<CommandLinePaletteItem, PaletteItem>
    {
        CommandLinePaletteItem() = default;
        CommandLinePaletteItem(const winrt::hstring& commandLine);

        WINRT_PROPERTY(winrt::hstring, CommandLine);
    };
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt.TerminalApp.implementation,9,implementation,1
76424,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandLinePaletteItem);
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt,20,winrt,2
76425,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandLinePaletteItem);
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt.TerminalApp,20,TerminalApp,1
76426,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandLinePaletteItem);
}",1,cascadia\TerminalApp\CommandLinePaletteItem.hpp,winrt.TerminalApp.factory_implementation,20,factory_implementation,1
76575,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\CommandPalette.cpp,cascadia\TerminalApp\CommandPalette.cpp:<global>,,<global>,1
76578,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandPalette::CommandPalette() :
        _switcherStartIdx{ 0 }
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _tabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _mruTabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

...",1,cascadia\TerminalApp\CommandPalette.cpp,winrt,23,winrt,1
76579,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandPalette::CommandPalette() :
        _switcherStartIdx{ 0 }
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _tabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _mruTabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

...",1,cascadia\TerminalApp\CommandPalette.cpp,winrt.TerminalApp,23,TerminalApp,1
76580,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    CommandPalette::CommandPalette() :
        _switcherStartIdx{ 0 }
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _tabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _mruTabActions = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

...",1,cascadia\TerminalApp\CommandPalette.cpp,winrt.TerminalApp.implementation,23,implementation,1
79803,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\CommandPalette.hpp,cascadia\TerminalApp\CommandPalette.hpp:<global>,,<global>,1
79807,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\CommandPalette.hpp,TerminalAppLocalTests,13,TerminalAppLocalTests,1
79809,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    enum class CommandPaletteMode
    {
        ActionMode = 0,
        TabSearchMode,
        TabSwitchMode,
        CommandlineMode
    };

    struct CommandPalette : CommandPaletteT<CommandPalette>
    {
        CommandPalette();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetTabs(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& tabs, const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& mruTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        vo...",1,cascadia\TerminalApp\CommandPalette.hpp,winrt,18,winrt,2
79810,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    enum class CommandPaletteMode
    {
        ActionMode = 0,
        TabSearchMode,
        TabSwitchMode,
        CommandlineMode
    };

    struct CommandPalette : CommandPaletteT<CommandPalette>
    {
        CommandPalette();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetTabs(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& tabs, const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& mruTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        vo...",1,cascadia\TerminalApp\CommandPalette.hpp,winrt.TerminalApp,18,TerminalApp,1
79811,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    enum class CommandPaletteMode
    {
        ActionMode = 0,
        TabSearchMode,
        TabSwitchMode,
        CommandlineMode
    };

    struct CommandPalette : CommandPaletteT<CommandPalette>
    {
        CommandPalette();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetTabs(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& tabs, const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::TabBase>& mruTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        vo...",1,cascadia\TerminalApp\CommandPalette.hpp,winrt.TerminalApp.implementation,18,implementation,1
80143,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandPalette);
}",1,cascadia\TerminalApp\CommandPalette.hpp,winrt,161,winrt,3
80144,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandPalette);
}",1,cascadia\TerminalApp\CommandPalette.hpp,winrt.TerminalApp,161,TerminalApp,1
80145,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(CommandPalette);
}",1,cascadia\TerminalApp\CommandPalette.hpp,winrt.TerminalApp.factory_implementation,161,factory_implementation,1
80152,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Commandline.cpp,cascadia\TerminalApp\Commandline.cpp:<global>,,<global>,1
80232,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Commandline.hpp,cascadia\TerminalApp\Commandline.hpp:<global>,,<global>,1
80236,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class CommandlineTest;
}",1,cascadia\TerminalApp\Commandline.hpp,TerminalAppLocalTests,22,TerminalAppLocalTests,1
80238,NAMESPACE_BLOCK,"namespace TerminalApp
{
    class Commandline;
}",1,cascadia\TerminalApp\Commandline.hpp,TerminalApp,26,TerminalApp,2
80281,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ContentManager.cpp,cascadia\TerminalApp\ContentManager.cpp:<global>,,<global>,1
80285,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ControlInteractivity ContentManager::CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                    const IControlAppearance& unfocusedAppearance,
                                                    const TerminalConnection::ITerminalConnection& connection)
    {
        ControlInteractivity content{ settings, unfocusedAppearance, connection };
        content.Closed({ get_weak(), &ContentManager::_closedHandler });

        _content.emplace(content.Id(), content);

        return content;
    }

    ControlInteractivity ContentManager::TryLookupCore(uint64_t id)
    {
        const auto it = _content.find(id);
        return it != _content.end() ? it->second : ControlInteractivity{ nullptr };
    }

    void ContentManager::Detach(const Microsoft::Terminal::Control::TermControl& control)
    {
        const auto contentId{ control.ContentId() };
        if (const auto&...",1,cascadia\TerminalApp\ContentManager.cpp,winrt,22,winrt,1
80286,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ControlInteractivity ContentManager::CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                    const IControlAppearance& unfocusedAppearance,
                                                    const TerminalConnection::ITerminalConnection& connection)
    {
        ControlInteractivity content{ settings, unfocusedAppearance, connection };
        content.Closed({ get_weak(), &ContentManager::_closedHandler });

        _content.emplace(content.Id(), content);

        return content;
    }

    ControlInteractivity ContentManager::TryLookupCore(uint64_t id)
    {
        const auto it = _content.find(id);
        return it != _content.end() ? it->second : ControlInteractivity{ nullptr };
    }

    void ContentManager::Detach(const Microsoft::Terminal::Control::TermControl& control)
    {
        const auto contentId{ control.ContentId() };
        if (const auto&...",1,cascadia\TerminalApp\ContentManager.cpp,winrt.TerminalApp,22,TerminalApp,1
80287,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    ControlInteractivity ContentManager::CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                    const IControlAppearance& unfocusedAppearance,
                                                    const TerminalConnection::ITerminalConnection& connection)
    {
        ControlInteractivity content{ settings, unfocusedAppearance, connection };
        content.Closed({ get_weak(), &ContentManager::_closedHandler });

        _content.emplace(content.Id(), content);

        return content;
    }

    ControlInteractivity ContentManager::TryLookupCore(uint64_t id)
    {
        const auto it = _content.find(id);
        return it != _content.end() ? it->second : ControlInteractivity{ nullptr };
    }

    void ContentManager::Detach(const Microsoft::Terminal::Control::TermControl& control)
    {
        const auto contentId{ control.ContentId() };
        if (const auto&...",1,cascadia\TerminalApp\ContentManager.cpp,winrt.TerminalApp.implementation,22,implementation,1
80411,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ContentManager.hpp,cascadia\TerminalApp\ContentManager.hpp:<global>,,<global>,1
80415,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ContentManager : ContentManagerT<ContentManager>
    {
    public:
        ContentManager() = default;
        Microsoft::Terminal::Control::ControlInteractivity CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                                      const Microsoft::Terminal::Control::IControlAppearance& unfocusedAppearance,
                                                                      const Microsoft::Terminal::TerminalConnection::ITerminalConnection& connection);
        Microsoft::Terminal::Control::ControlInteractivity TryLookupCore(uint64_t id);

        void Detach(const Microsoft::Terminal::Control::TermControl& control);

    private:
        std::unordered_map<uint64_t, Microsoft::Terminal::Control::ControlInteractivity> _content;

        void _closedHandler(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt...",1,cascadia\TerminalApp\ContentManager.hpp,winrt,30,winrt,1
80416,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ContentManager : ContentManagerT<ContentManager>
    {
    public:
        ContentManager() = default;
        Microsoft::Terminal::Control::ControlInteractivity CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                                      const Microsoft::Terminal::Control::IControlAppearance& unfocusedAppearance,
                                                                      const Microsoft::Terminal::TerminalConnection::ITerminalConnection& connection);
        Microsoft::Terminal::Control::ControlInteractivity TryLookupCore(uint64_t id);

        void Detach(const Microsoft::Terminal::Control::TermControl& control);

    private:
        std::unordered_map<uint64_t, Microsoft::Terminal::Control::ControlInteractivity> _content;

        void _closedHandler(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt...",1,cascadia\TerminalApp\ContentManager.hpp,winrt.TerminalApp,30,TerminalApp,1
80417,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ContentManager : ContentManagerT<ContentManager>
    {
    public:
        ContentManager() = default;
        Microsoft::Terminal::Control::ControlInteractivity CreateCore(const Microsoft::Terminal::Control::IControlSettings& settings,
                                                                      const Microsoft::Terminal::Control::IControlAppearance& unfocusedAppearance,
                                                                      const Microsoft::Terminal::TerminalConnection::ITerminalConnection& connection);
        Microsoft::Terminal::Control::ControlInteractivity TryLookupCore(uint64_t id);

        void Detach(const Microsoft::Terminal::Control::TermControl& control);

    private:
        std::unordered_map<uint64_t, Microsoft::Terminal::Control::ControlInteractivity> _content;

        void _closedHandler(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt...",1,cascadia\TerminalApp\ContentManager.hpp,winrt.TerminalApp.implementation,30,implementation,1
80464,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\DebugTapConnection.cpp,cascadia\TerminalApp\DebugTapConnection.cpp:<global>,,<global>,1
80467,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    // DebugInputTapConnection is an implementation detail of DebugTapConnection.
    // It wraps the _actual_ connection so it can hook WriteInput and forward it
    // into the actual debug panel.
    class DebugInputTapConnection : public winrt::implements<DebugInputTapConnection, ITerminalConnection>
    {
    public:
        DebugInputTapConnection(winrt::com_ptr<DebugTapConnection> pairedTap, ITerminalConnection wrappedConnection) :
            _pairedTap{ pairedTap },
            _wrappedConnection{ std::move(wrappedConnection) }
        {
        }
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) {}
        ~DebugInputTapConnection() = default;
        winrt::fire_and_forget Start()
        {
            // GH#11282: It's possible that we're about to be started, _before_
            // our paired connection is started. Both will get Start()'ed when
            // their owning Ter...",1,cascadia\TerminalApp\DebugTapConnection.cpp,winrt,9,winrt,1
80468,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    // DebugInputTapConnection is an implementation detail of DebugTapConnection.
    // It wraps the _actual_ connection so it can hook WriteInput and forward it
    // into the actual debug panel.
    class DebugInputTapConnection : public winrt::implements<DebugInputTapConnection, ITerminalConnection>
    {
    public:
        DebugInputTapConnection(winrt::com_ptr<DebugTapConnection> pairedTap, ITerminalConnection wrappedConnection) :
            _pairedTap{ pairedTap },
            _wrappedConnection{ std::move(wrappedConnection) }
        {
        }
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) {}
        ~DebugInputTapConnection() = default;
        winrt::fire_and_forget Start()
        {
            // GH#11282: It's possible that we're about to be started, _before_
            // our paired connection is started. Both will get Start()'ed when
            // their owning Ter...",1,cascadia\TerminalApp\DebugTapConnection.cpp,winrt.Microsoft,9,Microsoft,1
80469,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    // DebugInputTapConnection is an implementation detail of DebugTapConnection.
    // It wraps the _actual_ connection so it can hook WriteInput and forward it
    // into the actual debug panel.
    class DebugInputTapConnection : public winrt::implements<DebugInputTapConnection, ITerminalConnection>
    {
    public:
        DebugInputTapConnection(winrt::com_ptr<DebugTapConnection> pairedTap, ITerminalConnection wrappedConnection) :
            _pairedTap{ pairedTap },
            _wrappedConnection{ std::move(wrappedConnection) }
        {
        }
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) {}
        ~DebugInputTapConnection() = default;
        winrt::fire_and_forget Start()
        {
            // GH#11282: It's possible that we're about to be started, _before_
            // our paired connection is started. Both will get Start()'ed when
            // their owning Ter...",1,cascadia\TerminalApp\DebugTapConnection.cpp,winrt.Microsoft.TerminalApp,9,TerminalApp,1
80470,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    // DebugInputTapConnection is an implementation detail of DebugTapConnection.
    // It wraps the _actual_ connection so it can hook WriteInput and forward it
    // into the actual debug panel.
    class DebugInputTapConnection : public winrt::implements<DebugInputTapConnection, ITerminalConnection>
    {
    public:
        DebugInputTapConnection(winrt::com_ptr<DebugTapConnection> pairedTap, ITerminalConnection wrappedConnection) :
            _pairedTap{ pairedTap },
            _wrappedConnection{ std::move(wrappedConnection) }
        {
        }
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) {}
        ~DebugInputTapConnection() = default;
        winrt::fire_and_forget Start()
        {
            // GH#11282: It's possible that we're about to be started, _before_
            // our paired connection is started. Both will get Start()'ed when
            // their owning Ter...",1,cascadia\TerminalApp\DebugTapConnection.cpp,winrt.Microsoft.TerminalApp.implementation,9,implementation,1
80858,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\DebugTapConnection.hpp,cascadia\TerminalApp\DebugTapConnection.hpp:<global>,,<global>,1
80862,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    class DebugInputTapConnection;
    class DebugTapConnection : public winrt::implements<DebugTapConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        explicit DebugTapConnection(Microsoft::Terminal::TerminalConnection::ITerminalConnection wrappedConnection);
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/){};
        ~DebugTapConnection();
        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();
        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept;

        void SetInputTap(const Microsoft::Terminal::TerminalConnection::ITerminalConnection& inputTap);

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);

        TYPED_EVENT(StateChanged, winrt::Mic...",1,cascadia\TerminalApp\DebugTapConnection.hpp,winrt,9,winrt,1
80863,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    class DebugInputTapConnection;
    class DebugTapConnection : public winrt::implements<DebugTapConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        explicit DebugTapConnection(Microsoft::Terminal::TerminalConnection::ITerminalConnection wrappedConnection);
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/){};
        ~DebugTapConnection();
        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();
        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept;

        void SetInputTap(const Microsoft::Terminal::TerminalConnection::ITerminalConnection& inputTap);

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);

        TYPED_EVENT(StateChanged, winrt::Mic...",1,cascadia\TerminalApp\DebugTapConnection.hpp,winrt.Microsoft,9,Microsoft,1
80864,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    class DebugInputTapConnection;
    class DebugTapConnection : public winrt::implements<DebugTapConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        explicit DebugTapConnection(Microsoft::Terminal::TerminalConnection::ITerminalConnection wrappedConnection);
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/){};
        ~DebugTapConnection();
        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();
        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept;

        void SetInputTap(const Microsoft::Terminal::TerminalConnection::ITerminalConnection& inputTap);

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);

        TYPED_EVENT(StateChanged, winrt::Mic...",1,cascadia\TerminalApp\DebugTapConnection.hpp,winrt.Microsoft.TerminalApp,9,TerminalApp,1
80865,NAMESPACE_BLOCK,"namespace winrt::Microsoft::TerminalApp::implementation
{
    class DebugInputTapConnection;
    class DebugTapConnection : public winrt::implements<DebugTapConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        explicit DebugTapConnection(Microsoft::Terminal::TerminalConnection::ITerminalConnection wrappedConnection);
        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/){};
        ~DebugTapConnection();
        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();
        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept;

        void SetInputTap(const Microsoft::Terminal::TerminalConnection::ITerminalConnection& inputTap);

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);

        TYPED_EVENT(StateChanged, winrt::Mic...",1,cascadia\TerminalApp\DebugTapConnection.hpp,winrt.Microsoft.TerminalApp.implementation,9,implementation,1
80948,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\EmptyStringVisibilityConverter.cpp,cascadia\TerminalApp\EmptyStringVisibilityConverter.cpp:<global>,,<global>,1
80952,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Attempt to convert something into another type. For the
    //   EmptyStringVisibilityConverter, we're gonna check if `value` is a
    //   string, and try and convert it into a Visibility value. If the input
    //   param wasn't a string, or was the empty string, we'll return
    //   Visibility::Collapsed. Otherwise, we'll return Visible.

    // Arguments:
    // - value: the input object to attempt to convert into a Visibility.
    // Return Value:
    // - Visible if the object was a string and wasn't the empty string.
    Foundation::IInspectable EmptyStringVisibilityConverter::Convert(const Foundation::IInspectable& value,
                                                                     const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                     const Foundation::IInspectable& /* parameter */,
                          ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.cpp,winrt,8,winrt,1
80953,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Attempt to convert something into another type. For the
    //   EmptyStringVisibilityConverter, we're gonna check if `value` is a
    //   string, and try and convert it into a Visibility value. If the input
    //   param wasn't a string, or was the empty string, we'll return
    //   Visibility::Collapsed. Otherwise, we'll return Visible.

    // Arguments:
    // - value: the input object to attempt to convert into a Visibility.
    // Return Value:
    // - Visible if the object was a string and wasn't the empty string.
    Foundation::IInspectable EmptyStringVisibilityConverter::Convert(const Foundation::IInspectable& value,
                                                                     const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                     const Foundation::IInspectable& /* parameter */,
                          ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.cpp,winrt.TerminalApp,8,TerminalApp,1
80954,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Attempt to convert something into another type. For the
    //   EmptyStringVisibilityConverter, we're gonna check if `value` is a
    //   string, and try and convert it into a Visibility value. If the input
    //   param wasn't a string, or was the empty string, we'll return
    //   Visibility::Collapsed. Otherwise, we'll return Visible.

    // Arguments:
    // - value: the input object to attempt to convert into a Visibility.
    // Return Value:
    // - Visible if the object was a string and wasn't the empty string.
    Foundation::IInspectable EmptyStringVisibilityConverter::Convert(const Foundation::IInspectable& value,
                                                                     const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                     const Foundation::IInspectable& /* parameter */,
                          ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.cpp,winrt.TerminalApp.implementation,8,implementation,1
81005,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp:<global>,,<global>,1
81009,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct EmptyStringVisibilityConverter : EmptyStringVisibilityConverterT<EmptyStringVisibilityConverter>
    {
        EmptyStringVisibilityConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);
  ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt,5,winrt,1
81010,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct EmptyStringVisibilityConverter : EmptyStringVisibilityConverterT<EmptyStringVisibilityConverter>
    {
        EmptyStringVisibilityConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);
  ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt.TerminalApp,5,TerminalApp,1
81011,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct EmptyStringVisibilityConverter : EmptyStringVisibilityConverterT<EmptyStringVisibilityConverter>
    {
        EmptyStringVisibilityConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);
  ...",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt.TerminalApp.implementation,5,implementation,1
81033,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(EmptyStringVisibilityConverter);
}",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt,23,winrt,2
81034,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(EmptyStringVisibilityConverter);
}",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt.TerminalApp,23,TerminalApp,1
81035,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(EmptyStringVisibilityConverter);
}",1,cascadia\TerminalApp\EmptyStringVisibilityConverter.hpp,winrt.TerminalApp.factory_implementation,23,factory_implementation,1
81090,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\FilteredCommand.cpp,cascadia\TerminalApp\FilteredCommand.cpp:<global>,,<global>,1
81093,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // This class is a wrapper of PaletteItem, that is used as an item of a filterable list in CommandPalette.
    // It manages a highlighted text that is computed by matching search filter characters to item name
    FilteredCommand::FilteredCommand(const winrt::TerminalApp::PaletteItem& item) :
        _Item(item),
        _Filter(L""""),
        _Weight(0)
    {
        _HighlightedName = _computeHighlightedName();

        // Recompute the highlighted name if the item name changes
        _itemChangedRevoker = _Item.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& /*sender*/, auto& e) {
            auto filteredCommand{ weakThis.get() };
            if (filteredCommand && e.PropertyName() == L""Name"")
            {
                filteredCommand->HighlightedName(filteredCommand->_computeHighlightedName());
                filteredCommand->Weight(filteredCommand->_computeWeight());
            }
        });
    }

  ...",1,cascadia\TerminalApp\FilteredCommand.cpp,winrt,20,winrt,1
81094,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // This class is a wrapper of PaletteItem, that is used as an item of a filterable list in CommandPalette.
    // It manages a highlighted text that is computed by matching search filter characters to item name
    FilteredCommand::FilteredCommand(const winrt::TerminalApp::PaletteItem& item) :
        _Item(item),
        _Filter(L""""),
        _Weight(0)
    {
        _HighlightedName = _computeHighlightedName();

        // Recompute the highlighted name if the item name changes
        _itemChangedRevoker = _Item.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& /*sender*/, auto& e) {
            auto filteredCommand{ weakThis.get() };
            if (filteredCommand && e.PropertyName() == L""Name"")
            {
                filteredCommand->HighlightedName(filteredCommand->_computeHighlightedName());
                filteredCommand->Weight(filteredCommand->_computeWeight());
            }
        });
    }

  ...",1,cascadia\TerminalApp\FilteredCommand.cpp,winrt.TerminalApp,20,TerminalApp,1
81095,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // This class is a wrapper of PaletteItem, that is used as an item of a filterable list in CommandPalette.
    // It manages a highlighted text that is computed by matching search filter characters to item name
    FilteredCommand::FilteredCommand(const winrt::TerminalApp::PaletteItem& item) :
        _Item(item),
        _Filter(L""""),
        _Weight(0)
    {
        _HighlightedName = _computeHighlightedName();

        // Recompute the highlighted name if the item name changes
        _itemChangedRevoker = _Item.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& /*sender*/, auto& e) {
            auto filteredCommand{ weakThis.get() };
            if (filteredCommand && e.PropertyName() == L""Name"")
            {
                filteredCommand->HighlightedName(filteredCommand->_computeHighlightedName());
                filteredCommand->Weight(filteredCommand->_computeWeight());
            }
        });
    }

  ...",1,cascadia\TerminalApp\FilteredCommand.cpp,winrt.TerminalApp.implementation,20,implementation,1
81528,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\FilteredCommand.hpp,cascadia\TerminalApp\FilteredCommand.hpp:<global>,,<global>,1
81532,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class FilteredCommandTests;
}",1,cascadia\TerminalApp\FilteredCommand.hpp,TerminalAppLocalTests,10,TerminalAppLocalTests,1
81534,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FilteredCommand : FilteredCommandT<FilteredCommand>
    {
        FilteredCommand() = default;
        FilteredCommand(const winrt::TerminalApp::PaletteItem& item);

        void UpdateFilter(const winrt::hstring& filter);

        static int Compare(const winrt::TerminalApp::FilteredCommand& first, const winrt::TerminalApp::FilteredCommand& second);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::PaletteItem, Item, _PropertyChangedHandlers, nullptr);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Filter, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::HighlightedText, HighlightedName, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(int, Weight, _PropertyChangedHandlers);

    private:
        winrt::TerminalApp::HighlightedText _computeHighlightedName();
        int _computeWe...",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt,15,winrt,2
81535,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FilteredCommand : FilteredCommandT<FilteredCommand>
    {
        FilteredCommand() = default;
        FilteredCommand(const winrt::TerminalApp::PaletteItem& item);

        void UpdateFilter(const winrt::hstring& filter);

        static int Compare(const winrt::TerminalApp::FilteredCommand& first, const winrt::TerminalApp::FilteredCommand& second);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::PaletteItem, Item, _PropertyChangedHandlers, nullptr);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Filter, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::HighlightedText, HighlightedName, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(int, Weight, _PropertyChangedHandlers);

    private:
        winrt::TerminalApp::HighlightedText _computeHighlightedName();
        int _computeWe...",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt.TerminalApp,15,TerminalApp,1
81536,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct FilteredCommand : FilteredCommandT<FilteredCommand>
    {
        FilteredCommand() = default;
        FilteredCommand(const winrt::TerminalApp::PaletteItem& item);

        void UpdateFilter(const winrt::hstring& filter);

        static int Compare(const winrt::TerminalApp::FilteredCommand& first, const winrt::TerminalApp::FilteredCommand& second);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::PaletteItem, Item, _PropertyChangedHandlers, nullptr);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Filter, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::HighlightedText, HighlightedName, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(int, Weight, _PropertyChangedHandlers);

    private:
        winrt::TerminalApp::HighlightedText _computeHighlightedName();
        int _computeWe...",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt.TerminalApp.implementation,15,implementation,1
81573,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(FilteredCommand);
}",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt,41,winrt,3
81574,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(FilteredCommand);
}",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt.TerminalApp,41,TerminalApp,1
81575,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(FilteredCommand);
}",1,cascadia\TerminalApp\FilteredCommand.hpp,winrt.TerminalApp.factory_implementation,41,factory_implementation,1
81586,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\HighlightedText.cpp,cascadia\TerminalApp\HighlightedText.cpp:<global>,,<global>,1
81590,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    HighlightedTextSegment::HighlightedTextSegment(const winrt::hstring& textSegment, bool isHighlighted) :
        _TextSegment(textSegment),
        _IsHighlighted(isHighlighted)
    {
    }

    HighlightedText::HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments) :
        _Segments(segments)
    {
    }
}",1,cascadia\TerminalApp\HighlightedText.cpp,winrt,19,winrt,1
81591,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    HighlightedTextSegment::HighlightedTextSegment(const winrt::hstring& textSegment, bool isHighlighted) :
        _TextSegment(textSegment),
        _IsHighlighted(isHighlighted)
    {
    }

    HighlightedText::HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments) :
        _Segments(segments)
    {
    }
}",1,cascadia\TerminalApp\HighlightedText.cpp,winrt.TerminalApp,19,TerminalApp,1
81592,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    HighlightedTextSegment::HighlightedTextSegment(const winrt::hstring& textSegment, bool isHighlighted) :
        _TextSegment(textSegment),
        _IsHighlighted(isHighlighted)
    {
    }

    HighlightedText::HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments) :
        _Segments(segments)
    {
    }
}",1,cascadia\TerminalApp\HighlightedText.cpp,winrt.TerminalApp.implementation,19,implementation,1
81609,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\HighlightedText.hpp,cascadia\TerminalApp\HighlightedText.hpp:<global>,,<global>,1
81613,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextSegment : HighlightedTextSegmentT<HighlightedTextSegment>
    {
        HighlightedTextSegment() = default;
        HighlightedTextSegment(const winrt::hstring& text, bool isHighlighted);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, TextSegment, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsHighlighted, _PropertyChangedHandlers);
    };

    struct HighlightedText : HighlightedTextT<HighlightedText>
    {
        HighlightedText() = default;
        HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTex...",1,cascadia\TerminalApp\HighlightedText.hpp,winrt,9,winrt,1
81614,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextSegment : HighlightedTextSegmentT<HighlightedTextSegment>
    {
        HighlightedTextSegment() = default;
        HighlightedTextSegment(const winrt::hstring& text, bool isHighlighted);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, TextSegment, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsHighlighted, _PropertyChangedHandlers);
    };

    struct HighlightedText : HighlightedTextT<HighlightedText>
    {
        HighlightedText() = default;
        HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTex...",1,cascadia\TerminalApp\HighlightedText.hpp,winrt.TerminalApp,9,TerminalApp,1
81615,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextSegment : HighlightedTextSegmentT<HighlightedTextSegment>
    {
        HighlightedTextSegment() = default;
        HighlightedTextSegment(const winrt::hstring& text, bool isHighlighted);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, TextSegment, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsHighlighted, _PropertyChangedHandlers);
    };

    struct HighlightedText : HighlightedTextT<HighlightedText>
    {
        HighlightedText() = default;
        HighlightedText(const Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>& segments);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTex...",1,cascadia\TerminalApp\HighlightedText.hpp,winrt.TerminalApp.implementation,9,implementation,1
81642,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextSegment);
    BASIC_FACTORY(HighlightedText);
}",1,cascadia\TerminalApp\HighlightedText.hpp,winrt,31,winrt,2
81643,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextSegment);
    BASIC_FACTORY(HighlightedText);
}",1,cascadia\TerminalApp\HighlightedText.hpp,winrt.TerminalApp,31,TerminalApp,1
81644,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextSegment);
    BASIC_FACTORY(HighlightedText);
}",1,cascadia\TerminalApp\HighlightedText.hpp,winrt.TerminalApp.factory_implementation,31,factory_implementation,1
81656,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\HighlightedTextControl.cpp,cascadia\TerminalApp\HighlightedTextControl.cpp:<global>,,<global>,1
81660,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Our control exposes a ""Text"" property to be used with Data Binding
    // To allow this we need to register a Dependency Property Identifier to be used by the property system
    // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)
    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(
        L""Text"",
        xaml_typename<winrt::TerminalApp::HighlightedText>(),
        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),
        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));

    HighlightedTextControl::HighlightedTextControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Returns the Identifier of the ""Text"" dependency property
    DependencyProperty HighlightedTextControl::TextProperty()
    {
        return _textProperty;
    }

    // Method Description:
    // - Returns the TextBlock ...",1,cascadia\TerminalApp\HighlightedTextControl.cpp,winrt,20,winrt,1
81661,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Our control exposes a ""Text"" property to be used with Data Binding
    // To allow this we need to register a Dependency Property Identifier to be used by the property system
    // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)
    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(
        L""Text"",
        xaml_typename<winrt::TerminalApp::HighlightedText>(),
        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),
        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));

    HighlightedTextControl::HighlightedTextControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Returns the Identifier of the ""Text"" dependency property
    DependencyProperty HighlightedTextControl::TextProperty()
    {
        return _textProperty;
    }

    // Method Description:
    // - Returns the TextBlock ...",1,cascadia\TerminalApp\HighlightedTextControl.cpp,winrt.TerminalApp,20,TerminalApp,1
81662,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Our control exposes a ""Text"" property to be used with Data Binding
    // To allow this we need to register a Dependency Property Identifier to be used by the property system
    // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)
    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(
        L""Text"",
        xaml_typename<winrt::TerminalApp::HighlightedText>(),
        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),
        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));

    HighlightedTextControl::HighlightedTextControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Returns the Identifier of the ""Text"" dependency property
    DependencyProperty HighlightedTextControl::TextProperty()
    {
        return _textProperty;
    }

    // Method Description:
    // - Returns the TextBlock ...",1,cascadia\TerminalApp\HighlightedTextControl.cpp,winrt.TerminalApp.implementation,20,implementation,1
81819,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\HighlightedTextControl.hpp,cascadia\TerminalApp\HighlightedTextControl.hpp:<global>,,<global>,1
81823,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextControl : HighlightedTextControlT<HighlightedTextControl>
    {
        HighlightedTextControl();

        static Windows::UI::Xaml::DependencyProperty TextProperty();

        winrt::TerminalApp::HighlightedText Text();
        void Text(const winrt::TerminalApp::HighlightedText& value);

        Windows::UI::Xaml::Controls::TextBlock TextView();

    private:
        static Windows::UI::Xaml::DependencyProperty _textProperty;
        static void _onTextChanged(const Windows::UI::Xaml::DependencyObject& o, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt,10,winrt,1
81824,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextControl : HighlightedTextControlT<HighlightedTextControl>
    {
        HighlightedTextControl();

        static Windows::UI::Xaml::DependencyProperty TextProperty();

        winrt::TerminalApp::HighlightedText Text();
        void Text(const winrt::TerminalApp::HighlightedText& value);

        Windows::UI::Xaml::Controls::TextBlock TextView();

    private:
        static Windows::UI::Xaml::DependencyProperty _textProperty;
        static void _onTextChanged(const Windows::UI::Xaml::DependencyObject& o, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt.TerminalApp,10,TerminalApp,1
81825,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct HighlightedTextControl : HighlightedTextControlT<HighlightedTextControl>
    {
        HighlightedTextControl();

        static Windows::UI::Xaml::DependencyProperty TextProperty();

        winrt::TerminalApp::HighlightedText Text();
        void Text(const winrt::TerminalApp::HighlightedText& value);

        Windows::UI::Xaml::Controls::TextBlock TextView();

    private:
        static Windows::UI::Xaml::DependencyProperty _textProperty;
        static void _onTextChanged(const Windows::UI::Xaml::DependencyObject& o, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt.TerminalApp.implementation,10,implementation,1
81855,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextControl);
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt,29,winrt,2
81856,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextControl);
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt.TerminalApp,29,TerminalApp,1
81857,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(HighlightedTextControl);
}",1,cascadia\TerminalApp\HighlightedTextControl.hpp,winrt.TerminalApp.factory_implementation,29,factory_implementation,1
81870,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Jumplist.cpp,cascadia\TerminalApp\Jumplist.cpp:<global>,,<global>,1
82242,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Jumplist.hpp,cascadia\TerminalApp\Jumplist.hpp:<global>,,<global>,1
82272,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\LanguageProfileNotifier.cpp,cascadia\TerminalApp\LanguageProfileNotifier.cpp:<global>,,<global>,1
82353,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\LanguageProfileNotifier.hpp,cascadia\TerminalApp\LanguageProfileNotifier.hpp:<global>,,<global>,1
82357,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    class LanguageProfileNotifier : public winrt::implements<LanguageProfileNotifier, ITfInputProcessorProfileActivationSink>
    {
    public:
        explicit LanguageProfileNotifier(std::function<void()>&& callback);
        ~LanguageProfileNotifier();
        STDMETHODIMP OnActivated(DWORD dwProfileType, LANGID langid, REFCLSID clsid, REFGUID catid, REFGUID guidProfile, HKL hkl, DWORD dwFlags);

    private:
        std::function<void()> _callback;
        wil::com_ptr<ITfSource> _source;
        DWORD _cookie = TF_INVALID_COOKIE;
        HKL _currentKeyboardLayout;
    };
}",1,cascadia\TerminalApp\LanguageProfileNotifier.hpp,winrt,6,winrt,1
82358,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    class LanguageProfileNotifier : public winrt::implements<LanguageProfileNotifier, ITfInputProcessorProfileActivationSink>
    {
    public:
        explicit LanguageProfileNotifier(std::function<void()>&& callback);
        ~LanguageProfileNotifier();
        STDMETHODIMP OnActivated(DWORD dwProfileType, LANGID langid, REFCLSID clsid, REFGUID catid, REFGUID guidProfile, HKL hkl, DWORD dwFlags);

    private:
        std::function<void()> _callback;
        wil::com_ptr<ITfSource> _source;
        DWORD _cookie = TF_INVALID_COOKIE;
        HKL _currentKeyboardLayout;
    };
}",1,cascadia\TerminalApp\LanguageProfileNotifier.hpp,winrt.TerminalApp,6,TerminalApp,1
82359,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    class LanguageProfileNotifier : public winrt::implements<LanguageProfileNotifier, ITfInputProcessorProfileActivationSink>
    {
    public:
        explicit LanguageProfileNotifier(std::function<void()>&& callback);
        ~LanguageProfileNotifier();
        STDMETHODIMP OnActivated(DWORD dwProfileType, LANGID langid, REFCLSID clsid, REFGUID catid, REFGUID guidProfile, HKL hkl, DWORD dwFlags);

    private:
        std::function<void()> _callback;
        wil::com_ptr<ITfSource> _source;
        DWORD _cookie = TF_INVALID_COOKIE;
        HKL _currentKeyboardLayout;
    };
}",1,cascadia\TerminalApp\LanguageProfileNotifier.hpp,winrt.TerminalApp.implementation,6,implementation,1
82525,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\MinMaxCloseControl.cpp,cascadia\TerminalApp\MinMaxCloseControl.cpp:<global>,,<global>,1
82528,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    static void closeToolTipForButton(const Controls::Button& button)
    {
        if (auto tt{ Controls::ToolTipService::GetToolTip(button) })
        {
            if (auto tooltip{ tt.try_as<Controls::ToolTip>() })
            {
                tooltip.IsOpen(false);
            }
        }
    }

    MinMaxCloseControl::MinMaxCloseControl()
    {
        // Get our dispatcher. This will get us the same dispatcher as
        // Dispatcher(), but it's a DispatcherQueue, so we can use it with
        // ThrottledFunc
        auto dispatcher = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();

        InitializeComponent();

        // Get the tooltip hover time from the system, or default to 400ms
        // (which should be the default, see:
        // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)
        unsigned int hoverTimeoutMillis{ 400 };
        LOG_IF_WIN32_BOOL_F...",1,cascadia\TerminalApp\MinMaxCloseControl.cpp,winrt,12,winrt,1
82529,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    static void closeToolTipForButton(const Controls::Button& button)
    {
        if (auto tt{ Controls::ToolTipService::GetToolTip(button) })
        {
            if (auto tooltip{ tt.try_as<Controls::ToolTip>() })
            {
                tooltip.IsOpen(false);
            }
        }
    }

    MinMaxCloseControl::MinMaxCloseControl()
    {
        // Get our dispatcher. This will get us the same dispatcher as
        // Dispatcher(), but it's a DispatcherQueue, so we can use it with
        // ThrottledFunc
        auto dispatcher = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();

        InitializeComponent();

        // Get the tooltip hover time from the system, or default to 400ms
        // (which should be the default, see:
        // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)
        unsigned int hoverTimeoutMillis{ 400 };
        LOG_IF_WIN32_BOOL_F...",1,cascadia\TerminalApp\MinMaxCloseControl.cpp,winrt.TerminalApp,12,TerminalApp,1
82530,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    static void closeToolTipForButton(const Controls::Button& button)
    {
        if (auto tt{ Controls::ToolTipService::GetToolTip(button) })
        {
            if (auto tooltip{ tt.try_as<Controls::ToolTip>() })
            {
                tooltip.IsOpen(false);
            }
        }
    }

    MinMaxCloseControl::MinMaxCloseControl()
    {
        // Get our dispatcher. This will get us the same dispatcher as
        // Dispatcher(), but it's a DispatcherQueue, so we can use it with
        // ThrottledFunc
        auto dispatcher = winrt::Windows::System::DispatcherQueue::GetForCurrentThread();

        InitializeComponent();

        // Get the tooltip hover time from the system, or default to 400ms
        // (which should be the default, see:
        // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)
        unsigned int hoverTimeoutMillis{ 400 };
        LOG_IF_WIN32_BOOL_F...",1,cascadia\TerminalApp\MinMaxCloseControl.cpp,winrt.TerminalApp.implementation,12,implementation,1
83010,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\MinMaxCloseControl.hpp,cascadia\TerminalApp\MinMaxCloseControl.hpp:<global>,,<global>,1
83014,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct MinMaxCloseControl : MinMaxCloseControlT<MinMaxCloseControl>
    {
        MinMaxCloseControl();

        void SetWindowVisualState(WindowVisualState visualState);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        void ReleaseButtons();

        void _MinimizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _MaximizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _CloseClick(const winrt::Windows::Foundation::IInspectable& sender,
                         const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        TYPED_EVENT(MinimizeClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);
        TYPED_EVENT(MaximizeClick, TerminalA...",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt,12,winrt,1
83015,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct MinMaxCloseControl : MinMaxCloseControlT<MinMaxCloseControl>
    {
        MinMaxCloseControl();

        void SetWindowVisualState(WindowVisualState visualState);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        void ReleaseButtons();

        void _MinimizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _MaximizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _CloseClick(const winrt::Windows::Foundation::IInspectable& sender,
                         const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        TYPED_EVENT(MinimizeClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);
        TYPED_EVENT(MaximizeClick, TerminalA...",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt.TerminalApp,12,TerminalApp,1
83016,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct MinMaxCloseControl : MinMaxCloseControlT<MinMaxCloseControl>
    {
        MinMaxCloseControl();

        void SetWindowVisualState(WindowVisualState visualState);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        void ReleaseButtons();

        void _MinimizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _MaximizeClick(const winrt::Windows::Foundation::IInspectable& sender,
                            const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void _CloseClick(const winrt::Windows::Foundation::IInspectable& sender,
                         const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        TYPED_EVENT(MinimizeClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);
        TYPED_EVENT(MaximizeClick, TerminalA...",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt.TerminalApp.implementation,12,implementation,1
83078,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(MinMaxCloseControl);
}",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt,40,winrt,2
83079,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(MinMaxCloseControl);
}",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt.TerminalApp,40,TerminalApp,1
83080,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(MinMaxCloseControl);
}",1,cascadia\TerminalApp\MinMaxCloseControl.hpp,winrt.TerminalApp.factory_implementation,40,factory_implementation,1
83091,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\PaletteItem.cpp,cascadia\TerminalApp\PaletteItem.cpp:<global>,,<global>,1
83095,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Controls::IconElement PaletteItem::ResolvedIcon()
    {
        const auto icon = IconPathConverter::IconWUX(Icon());
        icon.Width(16);
        icon.Height(16);
        return icon;
    }
}",1,cascadia\TerminalApp\PaletteItem.cpp,winrt,16,winrt,1
83096,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Controls::IconElement PaletteItem::ResolvedIcon()
    {
        const auto icon = IconPathConverter::IconWUX(Icon());
        icon.Width(16);
        icon.Height(16);
        return icon;
    }
}",1,cascadia\TerminalApp\PaletteItem.cpp,winrt.TerminalApp,16,TerminalApp,1
83097,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Controls::IconElement PaletteItem::ResolvedIcon()
    {
        const auto icon = IconPathConverter::IconWUX(Icon());
        icon.Width(16);
        icon.Height(16);
        return icon;
    }
}",1,cascadia\TerminalApp\PaletteItem.cpp,winrt.TerminalApp.implementation,16,implementation,1
83125,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\PaletteItem.hpp,cascadia\TerminalApp\PaletteItem.hpp:<global>,,<global>,1
83129,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItem : PaletteItemT<PaletteItem>
    {
    public:
        Windows::UI::Xaml::Controls::IconElement ResolvedIcon();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Name, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Icon, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, KeyChordText, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\PaletteItem.hpp,winrt,7,winrt,1
83130,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItem : PaletteItemT<PaletteItem>
    {
    public:
        Windows::UI::Xaml::Controls::IconElement ResolvedIcon();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Name, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Icon, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, KeyChordText, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\PaletteItem.hpp,winrt.TerminalApp,7,TerminalApp,1
83131,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItem : PaletteItemT<PaletteItem>
    {
    public:
        Windows::UI::Xaml::Controls::IconElement ResolvedIcon();

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Name, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Icon, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, KeyChordText, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\PaletteItem.hpp,winrt.TerminalApp.implementation,7,implementation,1
83150,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\PaletteItemTemplateSelector.cpp,cascadia\TerminalApp\PaletteItemTemplateSelector.cpp:<global>,,<global>,1
83154,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::SelectTemplateCore(const winrt::Windows::Foundation::IInspectable& item, const winrt::Windows::UI::Xaml::DependencyObject& /*container*/)
    {
        return SelectTemplateCore(item);
    }

    // Method Description:
    // - This method is called once command palette decides how to render a filtered command.
    //   Currently we support two ways to render command, that depend on its palette item type:
    //   - For TabPalette item we render an icon, a title, and some tab-related indicators like progress bar (as defined by TabItemTemplate)
    //   - All other items are currently rendered with icon, title and optional key-chord (as defined by GeneralItemTemplate)
    // Arguments:
    // - item - an instance of filtered command to render
    // Return Value:
    // - data template to use for rendering
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::Sel...",1,cascadia\TerminalApp\PaletteItemTemplateSelector.cpp,winrt,9,winrt,1
83155,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::SelectTemplateCore(const winrt::Windows::Foundation::IInspectable& item, const winrt::Windows::UI::Xaml::DependencyObject& /*container*/)
    {
        return SelectTemplateCore(item);
    }

    // Method Description:
    // - This method is called once command palette decides how to render a filtered command.
    //   Currently we support two ways to render command, that depend on its palette item type:
    //   - For TabPalette item we render an icon, a title, and some tab-related indicators like progress bar (as defined by TabItemTemplate)
    //   - All other items are currently rendered with icon, title and optional key-chord (as defined by GeneralItemTemplate)
    // Arguments:
    // - item - an instance of filtered command to render
    // Return Value:
    // - data template to use for rendering
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::Sel...",1,cascadia\TerminalApp\PaletteItemTemplateSelector.cpp,winrt.TerminalApp,9,TerminalApp,1
83156,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::SelectTemplateCore(const winrt::Windows::Foundation::IInspectable& item, const winrt::Windows::UI::Xaml::DependencyObject& /*container*/)
    {
        return SelectTemplateCore(item);
    }

    // Method Description:
    // - This method is called once command palette decides how to render a filtered command.
    //   Currently we support two ways to render command, that depend on its palette item type:
    //   - For TabPalette item we render an icon, a title, and some tab-related indicators like progress bar (as defined by TabItemTemplate)
    //   - All other items are currently rendered with icon, title and optional key-chord (as defined by GeneralItemTemplate)
    // Arguments:
    // - item - an instance of filtered command to render
    // Return Value:
    // - data template to use for rendering
    Windows::UI::Xaml::DataTemplate PaletteItemTemplateSelector::Sel...",1,cascadia\TerminalApp\PaletteItemTemplateSelector.cpp,winrt.TerminalApp.implementation,9,implementation,1
83225,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp:<global>,,<global>,1
83229,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItemTemplateSelector : PaletteItemTemplateSelectorT<PaletteItemTemplateSelector>
    {
        PaletteItemTemplateSelector() = default;

        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&, const winrt::Windows::UI::Xaml::DependencyObject&);
        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&);

        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, TabItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, NestedItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, GeneralItemTemplate);
    };
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt,8,winrt,1
83230,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItemTemplateSelector : PaletteItemTemplateSelectorT<PaletteItemTemplateSelector>
    {
        PaletteItemTemplateSelector() = default;

        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&, const winrt::Windows::UI::Xaml::DependencyObject&);
        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&);

        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, TabItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, NestedItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, GeneralItemTemplate);
    };
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt.TerminalApp,8,TerminalApp,1
83231,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct PaletteItemTemplateSelector : PaletteItemTemplateSelectorT<PaletteItemTemplateSelector>
    {
        PaletteItemTemplateSelector() = default;

        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&, const winrt::Windows::UI::Xaml::DependencyObject&);
        Windows::UI::Xaml::DataTemplate SelectTemplateCore(const winrt::Windows::Foundation::IInspectable&);

        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, TabItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, NestedItemTemplate);
        WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, GeneralItemTemplate);
    };
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt.TerminalApp.implementation,8,implementation,1
83251,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(PaletteItemTemplateSelector);
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt,23,winrt,2
83252,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(PaletteItemTemplateSelector);
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt.TerminalApp,23,TerminalApp,1
83253,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(PaletteItemTemplateSelector);
}",1,cascadia\TerminalApp\PaletteItemTemplateSelector.hpp,winrt.TerminalApp.factory_implementation,23,factory_implementation,1
83260,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Pane.LayoutSizeNode.cpp,cascadia\TerminalApp\Pane.LayoutSizeNode.cpp:<global>,,<global>,1
84466,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Pane.cpp,cascadia\TerminalApp\Pane.cpp:<global>,,<global>,1
90245,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Pane.hpp,cascadia\TerminalApp\Pane.hpp:<global>,,<global>,1
90249,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\Pane.hpp,TerminalAppLocalTests,26,TerminalAppLocalTests,1
90251,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab;
}",1,cascadia\TerminalApp\Pane.hpp,winrt,31,winrt,2
90252,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab;
}",1,cascadia\TerminalApp\Pane.hpp,winrt.TerminalApp,31,TerminalApp,1
90253,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab;
}",1,cascadia\TerminalApp\Pane.hpp,winrt.TerminalApp.implementation,31,implementation,1
91081,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\SettingsLoadEventArgs.hpp,cascadia\TerminalApp\SettingsLoadEventArgs.hpp:<global>,,<global>,1
91085,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsLoadEventArgs : SettingsLoadEventArgsT<SettingsLoadEventArgs>
    {
        WINRT_PROPERTY(bool, Reload, false);
        WINRT_PROPERTY(uint64_t, Result, S_OK);
        WINRT_PROPERTY(winrt::hstring, ExceptionText, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings>, Warnings, nullptr);
        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::CascadiaSettings, NewSettings, nullptr);

    public:
        SettingsLoadEventArgs(bool reload,
                              uint64_t result,
                              winrt::hstring exceptionText,
                              winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings> warnings,
                              Microsoft::Terminal::Settings::Model::CascadiaSettings newSettings) :
            _Reload{ reload },
            ...",1,cascadia\TerminalApp\SettingsLoadEventArgs.hpp,winrt,8,winrt,1
91086,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsLoadEventArgs : SettingsLoadEventArgsT<SettingsLoadEventArgs>
    {
        WINRT_PROPERTY(bool, Reload, false);
        WINRT_PROPERTY(uint64_t, Result, S_OK);
        WINRT_PROPERTY(winrt::hstring, ExceptionText, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings>, Warnings, nullptr);
        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::CascadiaSettings, NewSettings, nullptr);

    public:
        SettingsLoadEventArgs(bool reload,
                              uint64_t result,
                              winrt::hstring exceptionText,
                              winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings> warnings,
                              Microsoft::Terminal::Settings::Model::CascadiaSettings newSettings) :
            _Reload{ reload },
            ...",1,cascadia\TerminalApp\SettingsLoadEventArgs.hpp,winrt.TerminalApp,8,TerminalApp,1
91087,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsLoadEventArgs : SettingsLoadEventArgsT<SettingsLoadEventArgs>
    {
        WINRT_PROPERTY(bool, Reload, false);
        WINRT_PROPERTY(uint64_t, Result, S_OK);
        WINRT_PROPERTY(winrt::hstring, ExceptionText, L"""");
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings>, Warnings, nullptr);
        WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::CascadiaSettings, NewSettings, nullptr);

    public:
        SettingsLoadEventArgs(bool reload,
                              uint64_t result,
                              winrt::hstring exceptionText,
                              winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings> warnings,
                              Microsoft::Terminal::Settings::Model::CascadiaSettings newSettings) :
            _Reload{ reload },
            ...",1,cascadia\TerminalApp\SettingsLoadEventArgs.hpp,winrt.TerminalApp.implementation,8,implementation,1
91114,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\SettingsTab.cpp,cascadia\TerminalApp\SettingsTab.cpp:<global>,,<global>,1
91118,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalApp\SettingsTab.cpp,winrt,18,winrt,1
91119,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\SettingsTab.cpp,Microsoft.UI.Xaml,20,MUX,1
91120,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\SettingsTab.cpp,Windows.UI.Xaml,21,WUX,2
91121,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SettingsTab::SettingsTab(MainPage settingsUI,
                             winrt::Windows::UI::Xaml::ElementTheme requestedTheme)
    {
        Content(settingsUI);
        _requestedTheme = requestedTheme;

        _MakeTabViewItem();
        _CreateContextMenu();
        _CreateIcon();
    }

    void SettingsTab::UpdateSettings(CascadiaSettings settings)
    {
        ASSERT_UI_THREAD();

        auto settingsUI{ Content().as<MainPage>() };
        settingsUI.UpdateSettings(settings);

        // Stash away the current requested theme of the app. We'll need that in
        // _BackgroundBrush() to do a theme-aware resource lookup
        _requestedTheme = settings.GlobalSettings().CurrentTheme().RequestedTheme();
    }

    // Method Description:
    // - Creates a list of actions that can be run to recreate the state of this tab
    // Arguments:
    // - asContent: unused. There's nothing different we need to do when
    //   s...",1,cascadia\TerminalApp\SettingsTab.cpp,winrt,26,winrt,2
91122,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SettingsTab::SettingsTab(MainPage settingsUI,
                             winrt::Windows::UI::Xaml::ElementTheme requestedTheme)
    {
        Content(settingsUI);
        _requestedTheme = requestedTheme;

        _MakeTabViewItem();
        _CreateContextMenu();
        _CreateIcon();
    }

    void SettingsTab::UpdateSettings(CascadiaSettings settings)
    {
        ASSERT_UI_THREAD();

        auto settingsUI{ Content().as<MainPage>() };
        settingsUI.UpdateSettings(settings);

        // Stash away the current requested theme of the app. We'll need that in
        // _BackgroundBrush() to do a theme-aware resource lookup
        _requestedTheme = settings.GlobalSettings().CurrentTheme().RequestedTheme();
    }

    // Method Description:
    // - Creates a list of actions that can be run to recreate the state of this tab
    // Arguments:
    // - asContent: unused. There's nothing different we need to do when
    //   s...",1,cascadia\TerminalApp\SettingsTab.cpp,winrt.TerminalApp,26,TerminalApp,1
91123,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SettingsTab::SettingsTab(MainPage settingsUI,
                             winrt::Windows::UI::Xaml::ElementTheme requestedTheme)
    {
        Content(settingsUI);
        _requestedTheme = requestedTheme;

        _MakeTabViewItem();
        _CreateContextMenu();
        _CreateIcon();
    }

    void SettingsTab::UpdateSettings(CascadiaSettings settings)
    {
        ASSERT_UI_THREAD();

        auto settingsUI{ Content().as<MainPage>() };
        settingsUI.UpdateSettings(settings);

        // Stash away the current requested theme of the app. We'll need that in
        // _BackgroundBrush() to do a theme-aware resource lookup
        _requestedTheme = settings.GlobalSettings().CurrentTheme().RequestedTheme();
    }

    // Method Description:
    // - Creates a list of actions that can be run to recreate the state of this tab
    // Arguments:
    // - asContent: unused. There's nothing different we need to do when
    //   s...",1,cascadia\TerminalApp\SettingsTab.cpp,winrt.TerminalApp.implementation,26,implementation,1
91328,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\SettingsTab.hpp,cascadia\TerminalApp\SettingsTab.hpp:<global>,,<global>,1
91332,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsTab : SettingsTabT<SettingsTab, TabBase>
    {
    public:
        SettingsTab(winrt::Microsoft::Terminal::Settings::Editor::MainPage settingsUI,
                    winrt::Windows::UI::Xaml::ElementTheme requestedTheme);

        void UpdateSettings(Microsoft::Terminal::Settings::Model::CascadiaSettings settings);
        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const override;

    private:
        winrt::Windows::UI::Xaml::ElementTheme _requestedTheme;

        void _MakeTabViewItem() override;
        void _CreateIcon();

        virtual winrt::Windows::UI::Xaml::Media::Brush _BackgroundBrush() override;
    };
}",1,cascadia\TerminalApp\SettingsTab.hpp,winrt,22,winrt,1
91333,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsTab : SettingsTabT<SettingsTab, TabBase>
    {
    public:
        SettingsTab(winrt::Microsoft::Terminal::Settings::Editor::MainPage settingsUI,
                    winrt::Windows::UI::Xaml::ElementTheme requestedTheme);

        void UpdateSettings(Microsoft::Terminal::Settings::Model::CascadiaSettings settings);
        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const override;

    private:
        winrt::Windows::UI::Xaml::ElementTheme _requestedTheme;

        void _MakeTabViewItem() override;
        void _CreateIcon();

        virtual winrt::Windows::UI::Xaml::Media::Brush _BackgroundBrush() override;
    };
}",1,cascadia\TerminalApp\SettingsTab.hpp,winrt.TerminalApp,22,TerminalApp,1
91334,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SettingsTab : SettingsTabT<SettingsTab, TabBase>
    {
    public:
        SettingsTab(winrt::Microsoft::Terminal::Settings::Editor::MainPage settingsUI,
                    winrt::Windows::UI::Xaml::ElementTheme requestedTheme);

        void UpdateSettings(Microsoft::Terminal::Settings::Model::CascadiaSettings settings);
        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const override;

    private:
        winrt::Windows::UI::Xaml::ElementTheme _requestedTheme;

        void _MakeTabViewItem() override;
        void _CreateIcon();

        virtual winrt::Windows::UI::Xaml::Media::Brush _BackgroundBrush() override;
    };
}",1,cascadia\TerminalApp\SettingsTab.hpp,winrt.TerminalApp.implementation,22,implementation,1
91377,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ShortcutActionDispatch.cpp,cascadia\TerminalApp\ShortcutActionDispatch.cpp:<global>,,<global>,1
91381,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Dispatch the appropriate event for the given ActionAndArgs. Constructs
    //   an ActionEventArgs to hold the IActionArgs payload for the event, and
    //   calls the matching handlers for that event.
    // Arguments:
    // - actionAndArgs: the ShortcutAction and associated args to raise an event for.
    // Return Value:
    // - true if we handled the event was handled, else false.
    bool ShortcutActionDispatch::DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                                          const ActionAndArgs& actionAndArgs)
    {
        if (!actionAndArgs)
        {
            return false;
        }

        const auto& action = actionAndArgs.Action();
        const auto& args = actionAndArgs.Args();
        auto eventArgs = args ? ActionEventArgs{ args } :
                                ActionEventArgs{};

        switch (action)
        {
#define ON_ALL_ACTIO...",1,cascadia\TerminalApp\ShortcutActionDispatch.cpp,winrt,20,winrt,1
91382,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Dispatch the appropriate event for the given ActionAndArgs. Constructs
    //   an ActionEventArgs to hold the IActionArgs payload for the event, and
    //   calls the matching handlers for that event.
    // Arguments:
    // - actionAndArgs: the ShortcutAction and associated args to raise an event for.
    // Return Value:
    // - true if we handled the event was handled, else false.
    bool ShortcutActionDispatch::DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                                          const ActionAndArgs& actionAndArgs)
    {
        if (!actionAndArgs)
        {
            return false;
        }

        const auto& action = actionAndArgs.Action();
        const auto& args = actionAndArgs.Args();
        auto eventArgs = args ? ActionEventArgs{ args } :
                                ActionEventArgs{};

        switch (action)
        {
#define ON_ALL_ACTIO...",1,cascadia\TerminalApp\ShortcutActionDispatch.cpp,winrt.TerminalApp,20,TerminalApp,1
91383,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Dispatch the appropriate event for the given ActionAndArgs. Constructs
    //   an ActionEventArgs to hold the IActionArgs payload for the event, and
    //   calls the matching handlers for that event.
    // Arguments:
    // - actionAndArgs: the ShortcutAction and associated args to raise an event for.
    // Return Value:
    // - true if we handled the event was handled, else false.
    bool ShortcutActionDispatch::DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                                          const ActionAndArgs& actionAndArgs)
    {
        if (!actionAndArgs)
        {
            return false;
        }

        const auto& action = actionAndArgs.Action();
        const auto& args = actionAndArgs.Args();
        auto eventArgs = args ? ActionEventArgs{ args } :
                                ActionEventArgs{};

        switch (action)
        {
#define ON_ALL_ACTIO...",1,cascadia\TerminalApp\ShortcutActionDispatch.cpp,winrt.TerminalApp.implementation,20,implementation,1
92493,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\ShortcutActionDispatch.hpp,cascadia\TerminalApp\ShortcutActionDispatch.hpp:<global>,,<global>,1
92497,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class SettingsTests;
    class KeyBindingsTests;
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,TerminalAppLocalTests,10,TerminalAppLocalTests,1
92500,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ShortcutActionDispatch : ShortcutActionDispatchT<ShortcutActionDispatch>
    {
        ShortcutActionDispatch() = default;

        bool DoAction(const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);
        bool DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                      const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);

#define ON_ALL_ACTIONS(action) DECLARE_ACTION(action);
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS

    private:
        friend class TerminalAppLocalTests::SettingsTests;
        friend class TerminalAppLocalTests::KeyBindingsTests;
    };
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt,18,winrt,2
92501,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ShortcutActionDispatch : ShortcutActionDispatchT<ShortcutActionDispatch>
    {
        ShortcutActionDispatch() = default;

        bool DoAction(const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);
        bool DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                      const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);

#define ON_ALL_ACTIONS(action) DECLARE_ACTION(action);
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS

    private:
        friend class TerminalAppLocalTests::SettingsTests;
        friend class TerminalAppLocalTests::KeyBindingsTests;
    };
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt.TerminalApp,18,TerminalApp,1
92502,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct ShortcutActionDispatch : ShortcutActionDispatchT<ShortcutActionDispatch>
    {
        ShortcutActionDispatch() = default;

        bool DoAction(const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);
        bool DoAction(const winrt::Windows::Foundation::IInspectable& sender,
                      const Microsoft::Terminal::Settings::Model::ActionAndArgs& actionAndArgs);

#define ON_ALL_ACTIONS(action) DECLARE_ACTION(action);
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS

    private:
        friend class TerminalAppLocalTests::SettingsTests;
        friend class TerminalAppLocalTests::KeyBindingsTests;
    };
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt.TerminalApp.implementation,18,implementation,1
92608,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ShortcutActionDispatch);
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt,38,winrt,3
92609,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ShortcutActionDispatch);
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt.TerminalApp,38,TerminalApp,1
92610,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(ShortcutActionDispatch);
}",1,cascadia\TerminalApp\ShortcutActionDispatch.hpp,winrt.TerminalApp.factory_implementation,38,factory_implementation,1
92807,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\SuggestionsControl.cpp,cascadia\TerminalApp\SuggestionsControl.cpp:<global>,,<global>,1
92810,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SuggestionsControl::SuggestionsControl()
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

        _switchToMode();

        // Whatever is hosting us will enable us by setting our visibility to
        // ""Visible"". When that happens, set focus to our search box.
        RegisterPropertyChangedCallbac...",1,cascadia\TerminalApp\SuggestionsControl.cpp,winrt,22,winrt,1
92811,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SuggestionsControl::SuggestionsControl()
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

        _switchToMode();

        // Whatever is hosting us will enable us by setting our visibility to
        // ""Visible"". When that happens, set focus to our search box.
        RegisterPropertyChangedCallbac...",1,cascadia\TerminalApp\SuggestionsControl.cpp,winrt.TerminalApp,22,TerminalApp,1
92812,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    SuggestionsControl::SuggestionsControl()
    {
        InitializeComponent();

        _itemTemplateSelector = Resources().Lookup(winrt::box_value(L""PaletteItemTemplateSelector"")).try_as<PaletteItemTemplateSelector>();
        _listItemTemplate = Resources().Lookup(winrt::box_value(L""ListItemTemplate"")).try_as<DataTemplate>();

        _filteredActions = winrt::single_threaded_observable_vector<winrt::TerminalApp::FilteredCommand>();
        _nestedActionStack = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _currentNestedCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();
        _allCommands = winrt::single_threaded_vector<winrt::TerminalApp::FilteredCommand>();

        _switchToMode();

        // Whatever is hosting us will enable us by setting our visibility to
        // ""Visible"". When that happens, set focus to our search box.
        RegisterPropertyChangedCallbac...",1,cascadia\TerminalApp\SuggestionsControl.cpp,winrt.TerminalApp.implementation,22,implementation,1
95154,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\SuggestionsControl.hpp,cascadia\TerminalApp\SuggestionsControl.hpp:<global>,,<global>,1
95158,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\SuggestionsControl.hpp,TerminalAppLocalTests,13,TerminalAppLocalTests,1
95160,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SuggestionsControl : SuggestionsControlT<SuggestionsControl>
    {
        SuggestionsControl();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        void ScrollPageUp();
        void ScrollPageDown();
        void ScrollToTop();
        void ScrollToBottom();

        Windows::UI::Xaml::FrameworkElement SelectedItem();

        TerminalApp::SuggestionsMode Mode() const;
        void Mode(TerminalApp::SuggestionsMode mode);

        void Open(TerminalApp::SuggestionsMode mode,
         ...",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt,18,winrt,2
95161,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SuggestionsControl : SuggestionsControlT<SuggestionsControl>
    {
        SuggestionsControl();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        void ScrollPageUp();
        void ScrollPageDown();
        void ScrollToTop();
        void ScrollToBottom();

        Windows::UI::Xaml::FrameworkElement SelectedItem();

        TerminalApp::SuggestionsMode Mode() const;
        void Mode(TerminalApp::SuggestionsMode mode);

        void Open(TerminalApp::SuggestionsMode mode,
         ...",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt.TerminalApp,18,TerminalApp,1
95162,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SuggestionsControl : SuggestionsControlT<SuggestionsControl>
    {
        SuggestionsControl();

        Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::FilteredCommand> FilteredActions();

        void SetCommands(const Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::Command>& actions);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);

        bool OnDirectKeyEvent(const uint32_t vkey, const uint8_t scanCode, const bool down);

        void SelectNextItem(const bool moveDown);

        void ScrollPageUp();
        void ScrollPageDown();
        void ScrollToTop();
        void ScrollToBottom();

        Windows::UI::Xaml::FrameworkElement SelectedItem();

        TerminalApp::SuggestionsMode Mode() const;
        void Mode(TerminalApp::SuggestionsMode mode);

        void Open(TerminalApp::SuggestionsMode mode,
         ...",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt.TerminalApp.implementation,18,implementation,1
95449,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(SuggestionsControl);
}",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt,130,winrt,3
95450,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(SuggestionsControl);
}",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt.TerminalApp,130,TerminalApp,1
95451,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(SuggestionsControl);
}",1,cascadia\TerminalApp\SuggestionsControl.hpp,winrt.TerminalApp.factory_implementation,130,factory_implementation,1
95581,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabBase.cpp,cascadia\TerminalApp\TabBase.cpp:<global>,,<global>,1
95584,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalApp\TabBase.cpp,winrt,18,winrt,1
95585,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TabBase.cpp,Microsoft.UI.Xaml,20,MUX,1
95586,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TabBase.cpp,Windows.UI.Xaml,21,WUX,2
95587,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{

    // Method Description:
    // - Prepares this tab for being removed from the UI hierarchy
    void TabBase::Shutdown()
    {
        ASSERT_UI_THREAD();

        Content(nullptr);
    }

    // Method Description:
    // - Creates a context menu attached to the tab.
    // Currently contains elements allowing the user to close the selected tab
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TabBase::_CreateContextMenu()
    {
        auto weakThis{ get_weak() };

        // Build the menu
        Controls::MenuFlyout contextMenuFlyout;
        // GH#5750 - When the context menu is dismissed with ESC, toss the focus
        // back to our control.
        contextMenuFlyout.Closed([weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        });
        _AppendCloseMenuItems(contextMenuFlyout);
   ...",1,cascadia\TerminalApp\TabBase.cpp,winrt,26,winrt,2
95588,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{

    // Method Description:
    // - Prepares this tab for being removed from the UI hierarchy
    void TabBase::Shutdown()
    {
        ASSERT_UI_THREAD();

        Content(nullptr);
    }

    // Method Description:
    // - Creates a context menu attached to the tab.
    // Currently contains elements allowing the user to close the selected tab
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TabBase::_CreateContextMenu()
    {
        auto weakThis{ get_weak() };

        // Build the menu
        Controls::MenuFlyout contextMenuFlyout;
        // GH#5750 - When the context menu is dismissed with ESC, toss the focus
        // back to our control.
        contextMenuFlyout.Closed([weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        });
        _AppendCloseMenuItems(contextMenuFlyout);
   ...",1,cascadia\TerminalApp\TabBase.cpp,winrt.TerminalApp,26,TerminalApp,1
95589,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{

    // Method Description:
    // - Prepares this tab for being removed from the UI hierarchy
    void TabBase::Shutdown()
    {
        ASSERT_UI_THREAD();

        Content(nullptr);
    }

    // Method Description:
    // - Creates a context menu attached to the tab.
    // Currently contains elements allowing the user to close the selected tab
    // Arguments:
    // - <none>
    // Return Value:
    // - <none>
    void TabBase::_CreateContextMenu()
    {
        auto weakThis{ get_weak() };

        // Build the menu
        Controls::MenuFlyout contextMenuFlyout;
        // GH#5750 - When the context menu is dismissed with ESC, toss the focus
        // back to our control.
        contextMenuFlyout.Closed([weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        });
        _AppendCloseMenuItems(contextMenuFlyout);
   ...",1,cascadia\TerminalApp\TabBase.cpp,winrt.TerminalApp.implementation,26,implementation,1
97018,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabBase.hpp,cascadia\TerminalApp\TabBase.hpp:<global>,,<global>,1
97022,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\TabBase.hpp,TerminalAppLocalTests,8,TerminalAppLocalTests,1
97024,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabBase : TabBaseT<TabBase>
    {
    public:
        virtual void Focus(winrt::Windows::UI::Xaml::FocusState focusState) = 0;

        virtual void Shutdown();
        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);

        void UpdateTabViewIndex(const uint32_t idx, const uint32_t numTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);
        virtual std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const = 0;

        virtual std::optional<winrt::Windows::UI::Color> GetTabColor();
        void ThemeColor(const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& focused,
                        const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& unfocused,
                        const til::color& tabRowColor);

        Microsoft::Terminal::Settings::Model::TabC...",1,cascadia\TerminalApp\TabBase.hpp,winrt,13,winrt,2
97025,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabBase : TabBaseT<TabBase>
    {
    public:
        virtual void Focus(winrt::Windows::UI::Xaml::FocusState focusState) = 0;

        virtual void Shutdown();
        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);

        void UpdateTabViewIndex(const uint32_t idx, const uint32_t numTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);
        virtual std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const = 0;

        virtual std::optional<winrt::Windows::UI::Color> GetTabColor();
        void ThemeColor(const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& focused,
                        const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& unfocused,
                        const til::color& tabRowColor);

        Microsoft::Terminal::Settings::Model::TabC...",1,cascadia\TerminalApp\TabBase.hpp,winrt.TerminalApp,13,TerminalApp,1
97026,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabBase : TabBaseT<TabBase>
    {
    public:
        virtual void Focus(winrt::Windows::UI::Xaml::FocusState focusState) = 0;

        virtual void Shutdown();
        void SetDispatch(const winrt::TerminalApp::ShortcutActionDispatch& dispatch);

        void UpdateTabViewIndex(const uint32_t idx, const uint32_t numTabs);
        void SetActionMap(const Microsoft::Terminal::Settings::Model::IActionMapView& actionMap);
        virtual std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> BuildStartupActions(const bool asContent = false) const = 0;

        virtual std::optional<winrt::Windows::UI::Color> GetTabColor();
        void ThemeColor(const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& focused,
                        const winrt::Microsoft::Terminal::Settings::Model::ThemeColor& unfocused,
                        const til::color& tabRowColor);

        Microsoft::Terminal::Settings::Model::TabC...",1,cascadia\TerminalApp\TabBase.hpp,winrt.TerminalApp.implementation,13,implementation,1
97340,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabHeaderControl.cpp,cascadia\TerminalApp\TabHeaderControl.cpp:<global>,,<global>,1
97343,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabHeaderControl::TabHeaderControl()
    {
        InitializeComponent();

        // We'll only process the KeyUp event if we received an initial KeyDown event first.
        // Avoids issue immediately closing the tab rename when we see the enter KeyUp event that was
        // sent to the command palette to trigger the openTabRenamer action in the first place.
        HeaderRenamerTextBox().KeyDown([&](auto&&, auto&& e) {
            _receivedKeyDown = true;

            // GH#9632 - mark navigation buttons as handled.
            // This should prevent the tab view to use this key for navigation between tabs
            if (e.OriginalKey() == Windows::System::VirtualKey::Down ||
                e.OriginalKey() == Windows::System::VirtualKey::Up ||
                e.OriginalKey() == Windows::System::VirtualKey::Left ||
                e.OriginalKey() == Windows::System::VirtualKey::Right)
            {
                e.Handled(t...",1,cascadia\TerminalApp\TabHeaderControl.cpp,winrt,12,winrt,1
97344,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabHeaderControl::TabHeaderControl()
    {
        InitializeComponent();

        // We'll only process the KeyUp event if we received an initial KeyDown event first.
        // Avoids issue immediately closing the tab rename when we see the enter KeyUp event that was
        // sent to the command palette to trigger the openTabRenamer action in the first place.
        HeaderRenamerTextBox().KeyDown([&](auto&&, auto&& e) {
            _receivedKeyDown = true;

            // GH#9632 - mark navigation buttons as handled.
            // This should prevent the tab view to use this key for navigation between tabs
            if (e.OriginalKey() == Windows::System::VirtualKey::Down ||
                e.OriginalKey() == Windows::System::VirtualKey::Up ||
                e.OriginalKey() == Windows::System::VirtualKey::Left ||
                e.OriginalKey() == Windows::System::VirtualKey::Right)
            {
                e.Handled(t...",1,cascadia\TerminalApp\TabHeaderControl.cpp,winrt.TerminalApp,12,TerminalApp,1
97345,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabHeaderControl::TabHeaderControl()
    {
        InitializeComponent();

        // We'll only process the KeyUp event if we received an initial KeyDown event first.
        // Avoids issue immediately closing the tab rename when we see the enter KeyUp event that was
        // sent to the command palette to trigger the openTabRenamer action in the first place.
        HeaderRenamerTextBox().KeyDown([&](auto&&, auto&& e) {
            _receivedKeyDown = true;

            // GH#9632 - mark navigation buttons as handled.
            // This should prevent the tab view to use this key for navigation between tabs
            if (e.OriginalKey() == Windows::System::VirtualKey::Down ||
                e.OriginalKey() == Windows::System::VirtualKey::Up ||
                e.OriginalKey() == Windows::System::VirtualKey::Left ||
                e.OriginalKey() == Windows::System::VirtualKey::Right)
            {
                e.Handled(t...",1,cascadia\TerminalApp\TabHeaderControl.cpp,winrt.TerminalApp.implementation,12,implementation,1
97547,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabHeaderControl.hpp,cascadia\TerminalApp\TabHeaderControl.hpp:<global>,,<global>,1
97551,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabHeaderControl : TabHeaderControlT<TabHeaderControl>
    {
        TabHeaderControl();
        void BeginRename();

        void RenameBoxLostFocusHandler(const winrt::Windows::Foundation::IInspectable& sender,
                                       const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        bool InRename();

        WINRT_CALLBACK(TitleChangeRequested, TerminalApp::TitleChangeRequestedArgs);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Title, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(double, RenamerMaxWidth, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

        TYPED_EVENT(RenameEnded, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        bool...",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt,10,winrt,1
97552,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabHeaderControl : TabHeaderControlT<TabHeaderControl>
    {
        TabHeaderControl();
        void BeginRename();

        void RenameBoxLostFocusHandler(const winrt::Windows::Foundation::IInspectable& sender,
                                       const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        bool InRename();

        WINRT_CALLBACK(TitleChangeRequested, TerminalApp::TitleChangeRequestedArgs);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Title, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(double, RenamerMaxWidth, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

        TYPED_EVENT(RenameEnded, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        bool...",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt.TerminalApp,10,TerminalApp,1
97553,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabHeaderControl : TabHeaderControlT<TabHeaderControl>
    {
        TabHeaderControl();
        void BeginRename();

        void RenameBoxLostFocusHandler(const winrt::Windows::Foundation::IInspectable& sender,
                                       const winrt::Windows::UI::Xaml::RoutedEventArgs& e);

        bool InRename();

        WINRT_CALLBACK(TitleChangeRequested, TerminalApp::TitleChangeRequestedArgs);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Title, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(double, RenamerMaxWidth, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

        TYPED_EVENT(RenameEnded, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        bool...",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt.TerminalApp.implementation,10,implementation,1
97597,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabHeaderControl);
}",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt,39,winrt,2
97598,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabHeaderControl);
}",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt.TerminalApp,39,TerminalApp,1
97599,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabHeaderControl);
}",1,cascadia\TerminalApp\TabHeaderControl.hpp,winrt.TerminalApp.factory_implementation,39,factory_implementation,1
97864,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabManagement.cpp,cascadia\TerminalApp\TabManagement.cpp:<global>,,<global>,1
97867,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\TabManagement.cpp,winrt,45,winrt,1
97868,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TabManagement.cpp,Microsoft.UI.Xaml,47,MUX,1
97869,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TabManagement.cpp,Windows.UI.Xaml,48,WUX,2
97871,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Open a new tab. This will create the TerminalControl hosting the
    //   terminal, and add a new Tab to our list of tabs. The method can
    //   optionally be provided a NewTerminalArgs, which will be used to create
    //   a tab using the values in that object.
    // Arguments:
    // - newTerminalArgs: An object that may contain a blob of parameters to
    //   control which profile is created and with possible other
    //   configurations. See TerminalSettings::CreateWithNewTerminalArgs for more details.
    // - existingConnection: An optional connection that is already established to a PTY
    //   for this tab to host instead of creating one.
    //   If not defined, the tab will create the connection.
    HRESULT TerminalPage::_OpenNewTab(const NewTerminalArgs& newTerminalArgs, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection existingConnection)
    try
    {
        con...",1,cascadia\TerminalApp\TabManagement.cpp,winrt,52,winrt,2
97872,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Open a new tab. This will create the TerminalControl hosting the
    //   terminal, and add a new Tab to our list of tabs. The method can
    //   optionally be provided a NewTerminalArgs, which will be used to create
    //   a tab using the values in that object.
    // Arguments:
    // - newTerminalArgs: An object that may contain a blob of parameters to
    //   control which profile is created and with possible other
    //   configurations. See TerminalSettings::CreateWithNewTerminalArgs for more details.
    // - existingConnection: An optional connection that is already established to a PTY
    //   for this tab to host instead of creating one.
    //   If not defined, the tab will create the connection.
    HRESULT TerminalPage::_OpenNewTab(const NewTerminalArgs& newTerminalArgs, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection existingConnection)
    try
    {
        con...",1,cascadia\TerminalApp\TabManagement.cpp,winrt.TerminalApp,52,TerminalApp,1
97873,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Method Description:
    // - Open a new tab. This will create the TerminalControl hosting the
    //   terminal, and add a new Tab to our list of tabs. The method can
    //   optionally be provided a NewTerminalArgs, which will be used to create
    //   a tab using the values in that object.
    // Arguments:
    // - newTerminalArgs: An object that may contain a blob of parameters to
    //   control which profile is created and with possible other
    //   configurations. See TerminalSettings::CreateWithNewTerminalArgs for more details.
    // - existingConnection: An optional connection that is already established to a PTY
    //   for this tab to host instead of creating one.
    //   If not defined, the tab will create the connection.
    HRESULT TerminalPage::_OpenNewTab(const NewTerminalArgs& newTerminalArgs, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection existingConnection)
    try
    {
        con...",1,cascadia\TerminalApp\TabManagement.cpp,winrt.TerminalApp.implementation,52,implementation,1
99945,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabPaletteItem.cpp,cascadia\TerminalApp\TabPaletteItem.cpp:<global>,,<global>,1
99948,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabPaletteItem::TabPaletteItem(const winrt::TerminalApp::TabBase& tab) :
        _tab(tab)
    {
        Name(tab.Title());
        Icon(tab.Icon());

        _tabChangedRevoker = tab.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& sender, auto& e) {
            auto item{ weakThis.get() };
            auto senderTab{ sender.try_as<winrt::TerminalApp::TabBase>() };

            if (item && senderTab)
            {
                auto changedProperty = e.PropertyName();
                if (changedProperty == L""Title"")
                {
                    item->Name(senderTab.Title());
                }
                else if (changedProperty == L""Icon"")
                {
                    item->Icon(senderTab.Icon());
                }
            }
        });

        if (const auto terminalTab{ tab.try_as<winrt::TerminalApp::TerminalTab>() })
        {
            const auto status = terminalTab.TabStatus()...",1,cascadia\TerminalApp\TabPaletteItem.cpp,winrt,20,winrt,1
99949,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabPaletteItem::TabPaletteItem(const winrt::TerminalApp::TabBase& tab) :
        _tab(tab)
    {
        Name(tab.Title());
        Icon(tab.Icon());

        _tabChangedRevoker = tab.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& sender, auto& e) {
            auto item{ weakThis.get() };
            auto senderTab{ sender.try_as<winrt::TerminalApp::TabBase>() };

            if (item && senderTab)
            {
                auto changedProperty = e.PropertyName();
                if (changedProperty == L""Title"")
                {
                    item->Name(senderTab.Title());
                }
                else if (changedProperty == L""Icon"")
                {
                    item->Icon(senderTab.Icon());
                }
            }
        });

        if (const auto terminalTab{ tab.try_as<winrt::TerminalApp::TerminalTab>() })
        {
            const auto status = terminalTab.TabStatus()...",1,cascadia\TerminalApp\TabPaletteItem.cpp,winrt.TerminalApp,20,TerminalApp,1
99950,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabPaletteItem::TabPaletteItem(const winrt::TerminalApp::TabBase& tab) :
        _tab(tab)
    {
        Name(tab.Title());
        Icon(tab.Icon());

        _tabChangedRevoker = tab.PropertyChanged(winrt::auto_revoke, [weakThis{ get_weak() }](auto& sender, auto& e) {
            auto item{ weakThis.get() };
            auto senderTab{ sender.try_as<winrt::TerminalApp::TabBase>() };

            if (item && senderTab)
            {
                auto changedProperty = e.PropertyName();
                if (changedProperty == L""Title"")
                {
                    item->Name(senderTab.Title());
                }
                else if (changedProperty == L""Icon"")
                {
                    item->Icon(senderTab.Icon());
                }
            }
        });

        if (const auto terminalTab{ tab.try_as<winrt::TerminalApp::TerminalTab>() })
        {
            const auto status = terminalTab.TabStatus()...",1,cascadia\TerminalApp\TabPaletteItem.cpp,winrt.TerminalApp.implementation,20,implementation,1
100011,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabPaletteItem.hpp,cascadia\TerminalApp\TabPaletteItem.hpp:<global>,,<global>,1
100015,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabPaletteItem : TabPaletteItemT<TabPaletteItem, PaletteItem>
    {
        TabPaletteItem() = default;
        TabPaletteItem(const winrt::TerminalApp::TabBase& tab);

        winrt::TerminalApp::TabBase Tab() const noexcept
        {
            return _tab.get();
        }

        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

    private:
        winrt::weak_ref<winrt::TerminalApp::TabBase> _tab;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabChangedRevoker;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabStatusChangedRevoker;
    };
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt,9,winrt,1
100016,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabPaletteItem : TabPaletteItemT<TabPaletteItem, PaletteItem>
    {
        TabPaletteItem() = default;
        TabPaletteItem(const winrt::TerminalApp::TabBase& tab);

        winrt::TerminalApp::TabBase Tab() const noexcept
        {
            return _tab.get();
        }

        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

    private:
        winrt::weak_ref<winrt::TerminalApp::TabBase> _tab;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabChangedRevoker;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabStatusChangedRevoker;
    };
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt.TerminalApp,9,TerminalApp,1
100017,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabPaletteItem : TabPaletteItemT<TabPaletteItem, PaletteItem>
    {
        TabPaletteItem() = default;
        TabPaletteItem(const winrt::TerminalApp::TabBase& tab);

        winrt::TerminalApp::TabBase Tab() const noexcept
        {
            return _tab.get();
        }

        WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);

    private:
        winrt::weak_ref<winrt::TerminalApp::TabBase> _tab;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabChangedRevoker;
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _tabStatusChangedRevoker;
    };
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt.TerminalApp.implementation,9,implementation,1
100041,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabPaletteItem);
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt,30,winrt,2
100042,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabPaletteItem);
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt.TerminalApp,30,TerminalApp,1
100043,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabPaletteItem);
}",1,cascadia\TerminalApp\TabPaletteItem.hpp,winrt.TerminalApp.factory_implementation,30,factory_implementation,1
100054,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabRowControl.cpp,cascadia\TerminalApp\TabRowControl.cpp:<global>,,<global>,1
100058,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalApp\TabRowControl.cpp,winrt,16,winrt,1
100059,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TabRowControl.cpp,Microsoft.UI.Xaml,18,MUX,1
100060,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TabRowControl.cpp,Windows.UI.Xaml,19,WUX,2
100061,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabRowControl::TabRowControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Bound in the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonClick(const IInspectable&, const Controls::SplitButtonClickEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag&Drop of the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonDrop(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag-over of the Xaml editor to the [+] button.
    // Allows drop of 'StorageItems' which will be used as StartingDirectory
    // Arguments:
    //  - <unused>
    //  - e: DragEventArgs which hold the items
    void TabRowControl::OnNewTabButtonDragOver(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs& e)
    {
    ...",1,cascadia\TerminalApp\TabRowControl.cpp,winrt,22,winrt,2
100062,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabRowControl::TabRowControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Bound in the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonClick(const IInspectable&, const Controls::SplitButtonClickEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag&Drop of the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonDrop(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag-over of the Xaml editor to the [+] button.
    // Allows drop of 'StorageItems' which will be used as StartingDirectory
    // Arguments:
    //  - <unused>
    //  - e: DragEventArgs which hold the items
    void TabRowControl::OnNewTabButtonDragOver(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs& e)
    {
    ...",1,cascadia\TerminalApp\TabRowControl.cpp,winrt.TerminalApp,22,TerminalApp,1
100063,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TabRowControl::TabRowControl()
    {
        InitializeComponent();
    }

    // Method Description:
    // - Bound in the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonClick(const IInspectable&, const Controls::SplitButtonClickEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag&Drop of the Xaml editor to the [+] button.
    // Arguments:
    // <unused>
    void TabRowControl::OnNewTabButtonDrop(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs&)
    {
    }

    // Method Description:
    // - Bound in Drag-over of the Xaml editor to the [+] button.
    // Allows drop of 'StorageItems' which will be used as StartingDirectory
    // Arguments:
    //  - <unused>
    //  - e: DragEventArgs which hold the items
    void TabRowControl::OnNewTabButtonDragOver(const IInspectable&, const winrt::Windows::UI::Xaml::DragEventArgs& e)
    {
    ...",1,cascadia\TerminalApp\TabRowControl.cpp,winrt.TerminalApp.implementation,22,implementation,1
100200,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TabRowControl.hpp,cascadia\TerminalApp\TabRowControl.hpp:<global>,,<global>,1
100204,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabRowControl : TabRowControlT<TabRowControl>
    {
        TabRowControl();

        void OnNewTabButtonClick(const Windows::Foundation::IInspectable& sender, const Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs& args);
        void OnNewTabButtonDrop(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);
        void OnNewTabButtonDragOver(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, ShowElevationShield, _PropertyChangedHandlers, false);
    };
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt,10,winrt,1
100205,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabRowControl : TabRowControlT<TabRowControl>
    {
        TabRowControl();

        void OnNewTabButtonClick(const Windows::Foundation::IInspectable& sender, const Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs& args);
        void OnNewTabButtonDrop(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);
        void OnNewTabButtonDragOver(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, ShowElevationShield, _PropertyChangedHandlers, false);
    };
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt.TerminalApp,10,TerminalApp,1
100206,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TabRowControl : TabRowControlT<TabRowControl>
    {
        TabRowControl();

        void OnNewTabButtonClick(const Windows::Foundation::IInspectable& sender, const Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs& args);
        void OnNewTabButtonDrop(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);
        void OnNewTabButtonDragOver(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::DragEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, ShowElevationShield, _PropertyChangedHandlers, false);
    };
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt.TerminalApp.implementation,10,implementation,1
100232,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabRowControl);
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt,25,winrt,2
100233,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabRowControl);
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt.TerminalApp,25,TerminalApp,1
100234,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TabRowControl);
}",1,cascadia\TerminalApp\TabRowControl.hpp,winrt.TerminalApp.factory_implementation,25,factory_implementation,1
100243,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TaskbarState.cpp,cascadia\TerminalApp\TaskbarState.cpp:<global>,,<global>,1
100247,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Default to unset, 0%.
    TaskbarState::TaskbarState() :
        TaskbarState(0, 0){};

    TaskbarState::TaskbarState(const uint64_t dispatchTypesState, const uint64_t progressParam) :
        _State{ dispatchTypesState },
        _Progress{ progressParam } {}

    uint64_t TaskbarState::Priority() const
    {
        // This seemingly nonsensical ordering is from
        // https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#how-the-taskbar-button-chooses-the-progress-indicator-for-a-group
        switch (_State)
        {
        case 0: // Clear = 0,
            return 5;
        case 1: // Set = 1,
            return 3;
        case 2: // Error = 2,
            return 1;
        case 3: // Indeterminate = 3,
            return 4;
        case 4: // Paused = 4
            return 2;
        }
        // Here, return 6, to definitely be greater than all the other vali...",1,cascadia\TerminalApp\TaskbarState.cpp,winrt,8,winrt,1
100248,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Default to unset, 0%.
    TaskbarState::TaskbarState() :
        TaskbarState(0, 0){};

    TaskbarState::TaskbarState(const uint64_t dispatchTypesState, const uint64_t progressParam) :
        _State{ dispatchTypesState },
        _Progress{ progressParam } {}

    uint64_t TaskbarState::Priority() const
    {
        // This seemingly nonsensical ordering is from
        // https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#how-the-taskbar-button-chooses-the-progress-indicator-for-a-group
        switch (_State)
        {
        case 0: // Clear = 0,
            return 5;
        case 1: // Set = 1,
            return 3;
        case 2: // Error = 2,
            return 1;
        case 3: // Indeterminate = 3,
            return 4;
        case 4: // Paused = 4
            return 2;
        }
        // Here, return 6, to definitely be greater than all the other vali...",1,cascadia\TerminalApp\TaskbarState.cpp,winrt.TerminalApp,8,TerminalApp,1
100249,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    // Default to unset, 0%.
    TaskbarState::TaskbarState() :
        TaskbarState(0, 0){};

    TaskbarState::TaskbarState(const uint64_t dispatchTypesState, const uint64_t progressParam) :
        _State{ dispatchTypesState },
        _Progress{ progressParam } {}

    uint64_t TaskbarState::Priority() const
    {
        // This seemingly nonsensical ordering is from
        // https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#how-the-taskbar-button-chooses-the-progress-indicator-for-a-group
        switch (_State)
        {
        case 0: // Clear = 0,
            return 5;
        case 1: // Set = 1,
            return 3;
        case 2: // Error = 2,
            return 1;
        case 3: // Indeterminate = 3,
            return 4;
        case 4: // Paused = 4
            return 2;
        }
        // Here, return 6, to definitely be greater than all the other vali...",1,cascadia\TerminalApp\TaskbarState.cpp,winrt.TerminalApp.implementation,8,implementation,1
100308,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TaskbarState.hpp,cascadia\TerminalApp\TaskbarState.hpp:<global>,,<global>,1
100312,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\TaskbarState.hpp,TerminalAppLocalTests,8,TerminalAppLocalTests,1
100314,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TaskbarState : TaskbarStateT<TaskbarState>
    {
    public:
        TaskbarState();
        TaskbarState(const uint64_t dispatchTypesState, const uint64_t progress);

        static int ComparePriority(const winrt::TerminalApp::TaskbarState& lhs, const winrt::TerminalApp::TaskbarState& rhs);

        uint64_t Priority() const;

        WINRT_PROPERTY(uint64_t, State, 0);
        WINRT_PROPERTY(uint64_t, Progress, 0);
    };
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt,13,winrt,2
100315,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TaskbarState : TaskbarStateT<TaskbarState>
    {
    public:
        TaskbarState();
        TaskbarState(const uint64_t dispatchTypesState, const uint64_t progress);

        static int ComparePriority(const winrt::TerminalApp::TaskbarState& lhs, const winrt::TerminalApp::TaskbarState& rhs);

        uint64_t Priority() const;

        WINRT_PROPERTY(uint64_t, State, 0);
        WINRT_PROPERTY(uint64_t, Progress, 0);
    };
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt.TerminalApp,13,TerminalApp,1
100316,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TaskbarState : TaskbarStateT<TaskbarState>
    {
    public:
        TaskbarState();
        TaskbarState(const uint64_t dispatchTypesState, const uint64_t progress);

        static int ComparePriority(const winrt::TerminalApp::TaskbarState& lhs, const winrt::TerminalApp::TaskbarState& rhs);

        uint64_t Priority() const;

        WINRT_PROPERTY(uint64_t, State, 0);
        WINRT_PROPERTY(uint64_t, Progress, 0);
    };
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt.TerminalApp.implementation,13,implementation,1
100340,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TaskbarState);
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt,30,winrt,3
100341,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TaskbarState);
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt.TerminalApp,30,TerminalApp,1
100342,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TaskbarState);
}",1,cascadia\TerminalApp\TaskbarState.hpp,winrt.TerminalApp.factory_implementation,30,factory_implementation,1
101240,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalPage.cpp,cascadia\TerminalApp\TerminalPage.cpp:<global>,,<global>,1
101243,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
    using VirtualKeyModifiers = Windows::System::VirtualKeyModifiers;
}",1,cascadia\TerminalApp\TerminalPage.cpp,winrt,50,winrt,1
101244,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TerminalPage.cpp,Microsoft.UI.Xaml,52,MUX,1
101245,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TerminalPage.cpp,Windows.UI.Xaml,53,WUX,2
101248,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalPage::TerminalPage(TerminalApp::WindowProperties properties, const TerminalApp::ContentManager& manager) :
        _tabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _mruTabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _startupActions{ winrt::single_threaded_vector<ActionAndArgs>() },
        _manager{ manager },
        _hostingHwnd{},
        _WindowProperties{ std::move(properties) }
    {
        InitializeComponent();

        _WindowProperties.PropertyChanged({ get_weak(), &TerminalPage::_windowPropertyChanged });
    }

    // Method Description:
    // - implements the IInitializeWithWindow interface from shobjidl_core.
    // - We're going to use this HWND as the owner for the ConPTY windows, via
    //   ConptyConnection::ReparentWindow. We need this for applications that
    //   call GetConsoleWindow, and attempt to open a MessageBox for the
    // ...",1,cascadia\TerminalApp\TerminalPage.cpp,winrt,58,winrt,2
101249,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalPage::TerminalPage(TerminalApp::WindowProperties properties, const TerminalApp::ContentManager& manager) :
        _tabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _mruTabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _startupActions{ winrt::single_threaded_vector<ActionAndArgs>() },
        _manager{ manager },
        _hostingHwnd{},
        _WindowProperties{ std::move(properties) }
    {
        InitializeComponent();

        _WindowProperties.PropertyChanged({ get_weak(), &TerminalPage::_windowPropertyChanged });
    }

    // Method Description:
    // - implements the IInitializeWithWindow interface from shobjidl_core.
    // - We're going to use this HWND as the owner for the ConPTY windows, via
    //   ConptyConnection::ReparentWindow. We need this for applications that
    //   call GetConsoleWindow, and attempt to open a MessageBox for the
    // ...",1,cascadia\TerminalApp\TerminalPage.cpp,winrt.TerminalApp,58,TerminalApp,1
101250,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalPage::TerminalPage(TerminalApp::WindowProperties properties, const TerminalApp::ContentManager& manager) :
        _tabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _mruTabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },
        _startupActions{ winrt::single_threaded_vector<ActionAndArgs>() },
        _manager{ manager },
        _hostingHwnd{},
        _WindowProperties{ std::move(properties) }
    {
        InitializeComponent();

        _WindowProperties.PropertyChanged({ get_weak(), &TerminalPage::_windowPropertyChanged });
    }

    // Method Description:
    // - implements the IInitializeWithWindow interface from shobjidl_core.
    // - We're going to use this HWND as the owner for the ConPTY windows, via
    //   ConptyConnection::ReparentWindow. We need this for applications that
    //   call GetConsoleWindow, and attempt to open a MessageBox for the
    // ...",1,cascadia\TerminalApp\TerminalPage.cpp,winrt.TerminalApp.implementation,58,implementation,1
112545,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalPage.hpp,cascadia\TerminalApp\TerminalPage.hpp:<global>,,<global>,1
112549,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
    class SettingsTests;
}",1,cascadia\TerminalApp\TerminalPage.hpp,TerminalAppLocalTests,18,TerminalAppLocalTests,1
112552,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalApp\TerminalPage.hpp,Microsoft,24,Microsoft,2
112553,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalApp\TerminalPage.hpp,Microsoft.Terminal,24,Terminal,1
112554,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalApp\TerminalPage.hpp,Microsoft.Terminal.Core,24,Core,1
112556,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    inline constexpr uint32_t DefaultRowsToScroll{ 3 };
    inline constexpr std::wstring_view TabletInputServiceKey{ L""TabletInputService"" };

    enum StartupState : int
    {
        NotInitialized = 0,
        InStartup = 1,
        Initialized = 2
    };

    enum ScrollDirection : int
    {
        ScrollUp = 0,
        ScrollDown = 1
    };

    struct LastTabClosedEventArgs : LastTabClosedEventArgsT<LastTabClosedEventArgs>
    {
        WINRT_PROPERTY(bool, ClearPersistedState);

    public:
        LastTabClosedEventArgs(const bool& shouldClear) :
            _ClearPersistedState{ shouldClear } {};
    };

    struct RenameWindowRequestedArgs : RenameWindowRequestedArgsT<RenameWindowRequestedArgs>
    {
        WINRT_PROPERTY(winrt::hstring, ProposedName);

    public:
        RenameWindowRequestedArgs(const winrt::hstring& name) :
            _ProposedName{ name } {};
    };

    struct RequestMoveContentArgs : RequestMoveCont...",1,cascadia\TerminalApp\TerminalPage.hpp,winrt,29,winrt,3
112557,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    inline constexpr uint32_t DefaultRowsToScroll{ 3 };
    inline constexpr std::wstring_view TabletInputServiceKey{ L""TabletInputService"" };

    enum StartupState : int
    {
        NotInitialized = 0,
        InStartup = 1,
        Initialized = 2
    };

    enum ScrollDirection : int
    {
        ScrollUp = 0,
        ScrollDown = 1
    };

    struct LastTabClosedEventArgs : LastTabClosedEventArgsT<LastTabClosedEventArgs>
    {
        WINRT_PROPERTY(bool, ClearPersistedState);

    public:
        LastTabClosedEventArgs(const bool& shouldClear) :
            _ClearPersistedState{ shouldClear } {};
    };

    struct RenameWindowRequestedArgs : RenameWindowRequestedArgsT<RenameWindowRequestedArgs>
    {
        WINRT_PROPERTY(winrt::hstring, ProposedName);

    public:
        RenameWindowRequestedArgs(const winrt::hstring& name) :
            _ProposedName{ name } {};
    };

    struct RequestMoveContentArgs : RequestMoveCont...",1,cascadia\TerminalApp\TerminalPage.hpp,winrt.TerminalApp,29,TerminalApp,1
112558,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    inline constexpr uint32_t DefaultRowsToScroll{ 3 };
    inline constexpr std::wstring_view TabletInputServiceKey{ L""TabletInputService"" };

    enum StartupState : int
    {
        NotInitialized = 0,
        InStartup = 1,
        Initialized = 2
    };

    enum ScrollDirection : int
    {
        ScrollUp = 0,
        ScrollDown = 1
    };

    struct LastTabClosedEventArgs : LastTabClosedEventArgsT<LastTabClosedEventArgs>
    {
        WINRT_PROPERTY(bool, ClearPersistedState);

    public:
        LastTabClosedEventArgs(const bool& shouldClear) :
            _ClearPersistedState{ shouldClear } {};
    };

    struct RenameWindowRequestedArgs : RenameWindowRequestedArgsT<RenameWindowRequestedArgs>
    {
        WINRT_PROPERTY(winrt::hstring, ProposedName);

    public:
        RenameWindowRequestedArgs(const winrt::hstring& name) :
            _ProposedName{ name } {};
    };

    struct RequestMoveContentArgs : RequestMoveCont...",1,cascadia\TerminalApp\TerminalPage.hpp,winrt.TerminalApp.implementation,29,implementation,1
114531,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalPage);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\TerminalApp\TerminalPage.hpp,winrt,558,winrt,4
114532,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalPage);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\TerminalApp\TerminalPage.hpp,winrt.TerminalApp,558,TerminalApp,1
114533,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalPage);
    BASIC_FACTORY(RequestReceiveContentArgs);
}",1,cascadia\TerminalApp\TerminalPage.hpp,winrt.TerminalApp.factory_implementation,558,factory_implementation,1
115884,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalTab.cpp,cascadia\TerminalApp\TerminalTab.cpp:<global>,,<global>,1
115887,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalApp\TerminalTab.cpp,winrt,23,winrt,1
115888,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TerminalTab.cpp,Microsoft.UI.Xaml,25,MUX,1
115889,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TerminalTab.cpp,Windows.UI.Xaml,26,WUX,2
115890,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalTab::TerminalTab(std::shared_ptr<Pane> rootPane)
    {
        _rootPane = rootPane;
        _activePane = nullptr;

        _closePaneMenuItem.Visibility(WUX::Visibility::Collapsed);
        _restartConnectionMenuItem.Visibility(WUX::Visibility::Collapsed);

        auto firstId = _nextPaneId;

        _rootPane->WalkTree([&](std::shared_ptr<Pane> pane) {
            // update the IDs on each pane
            if (pane->_IsLeaf())
            {
                pane->Id(_nextPaneId);
                _nextPaneId++;
            }
            // Try to find the pane marked active (if it exists)
            if (pane->_lastActive)
            {
                _activePane = pane;
            }
        });

        // In case none of the panes were already marked as the focus, just
        // focus the first one.
        if (_activePane == nullptr)
        {
            const auto firstPane = _rootPane->FindPane(firstId);
         ...",1,cascadia\TerminalApp\TerminalTab.cpp,winrt,31,winrt,2
115891,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalTab::TerminalTab(std::shared_ptr<Pane> rootPane)
    {
        _rootPane = rootPane;
        _activePane = nullptr;

        _closePaneMenuItem.Visibility(WUX::Visibility::Collapsed);
        _restartConnectionMenuItem.Visibility(WUX::Visibility::Collapsed);

        auto firstId = _nextPaneId;

        _rootPane->WalkTree([&](std::shared_ptr<Pane> pane) {
            // update the IDs on each pane
            if (pane->_IsLeaf())
            {
                pane->Id(_nextPaneId);
                _nextPaneId++;
            }
            // Try to find the pane marked active (if it exists)
            if (pane->_lastActive)
            {
                _activePane = pane;
            }
        });

        // In case none of the panes were already marked as the focus, just
        // focus the first one.
        if (_activePane == nullptr)
        {
            const auto firstPane = _rootPane->FindPane(firstId);
         ...",1,cascadia\TerminalApp\TerminalTab.cpp,winrt.TerminalApp,31,TerminalApp,1
115892,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalTab::TerminalTab(std::shared_ptr<Pane> rootPane)
    {
        _rootPane = rootPane;
        _activePane = nullptr;

        _closePaneMenuItem.Visibility(WUX::Visibility::Collapsed);
        _restartConnectionMenuItem.Visibility(WUX::Visibility::Collapsed);

        auto firstId = _nextPaneId;

        _rootPane->WalkTree([&](std::shared_ptr<Pane> pane) {
            // update the IDs on each pane
            if (pane->_IsLeaf())
            {
                pane->Id(_nextPaneId);
                _nextPaneId++;
            }
            // Try to find the pane marked active (if it exists)
            if (pane->_lastActive)
            {
                _activePane = pane;
            }
        });

        // In case none of the panes were already marked as the focus, just
        // focus the first one.
        if (_activePane == nullptr)
        {
            const auto firstPane = _rootPane->FindPane(firstId);
         ...",1,cascadia\TerminalApp\TerminalTab.cpp,winrt.TerminalApp.implementation,31,implementation,1
119154,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalTab.hpp,cascadia\TerminalApp\TerminalTab.hpp:<global>,,<global>,1
119158,NAMESPACE_BLOCK,"namespace TerminalAppLocalTests
{
    class TabTests;
}",1,cascadia\TerminalApp\TerminalTab.hpp,TerminalAppLocalTests,11,TerminalAppLocalTests,1
119160,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab : TerminalTabT<TerminalTab, TabBase>
    {
    public:
        TerminalTab(std::shared_ptr<Pane> rootPane);

        // Called after construction to perform the necessary setup, which relies on weak_ptr
        void Initialize();

        winrt::Microsoft::Terminal::Control::TermControl GetActiveTerminalControl() const;
        winrt::Microsoft::Terminal::Settings::Model::Profile GetFocusedProfile() const noexcept;

        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        void Scroll(const int delta);

        std::shared_ptr<Pane> DetachRoot();
        std::shared_ptr<Pane> DetachPane();
        void AttachPane(std::shared_ptr<Pane> pane);

        void AttachColorPicker(winrt::TerminalApp::ColorPickupFlyout& colorPicker);

        std::pair<std::shared_ptr<Pane>, std::shared_ptr<Pane>> SplitPane(winrt::Microsoft::Terminal::Settings::Model::SplitDirection splitType,
                 ...",1,cascadia\TerminalApp\TerminalTab.hpp,winrt,16,winrt,2
119161,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab : TerminalTabT<TerminalTab, TabBase>
    {
    public:
        TerminalTab(std::shared_ptr<Pane> rootPane);

        // Called after construction to perform the necessary setup, which relies on weak_ptr
        void Initialize();

        winrt::Microsoft::Terminal::Control::TermControl GetActiveTerminalControl() const;
        winrt::Microsoft::Terminal::Settings::Model::Profile GetFocusedProfile() const noexcept;

        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        void Scroll(const int delta);

        std::shared_ptr<Pane> DetachRoot();
        std::shared_ptr<Pane> DetachPane();
        void AttachPane(std::shared_ptr<Pane> pane);

        void AttachColorPicker(winrt::TerminalApp::ColorPickupFlyout& colorPicker);

        std::pair<std::shared_ptr<Pane>, std::shared_ptr<Pane>> SplitPane(winrt::Microsoft::Terminal::Settings::Model::SplitDirection splitType,
                 ...",1,cascadia\TerminalApp\TerminalTab.hpp,winrt.TerminalApp,16,TerminalApp,1
119162,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTab : TerminalTabT<TerminalTab, TabBase>
    {
    public:
        TerminalTab(std::shared_ptr<Pane> rootPane);

        // Called after construction to perform the necessary setup, which relies on weak_ptr
        void Initialize();

        winrt::Microsoft::Terminal::Control::TermControl GetActiveTerminalControl() const;
        winrt::Microsoft::Terminal::Settings::Model::Profile GetFocusedProfile() const noexcept;

        void Focus(winrt::Windows::UI::Xaml::FocusState focusState) override;

        void Scroll(const int delta);

        std::shared_ptr<Pane> DetachRoot();
        std::shared_ptr<Pane> DetachPane();
        void AttachPane(std::shared_ptr<Pane> pane);

        void AttachColorPicker(winrt::TerminalApp::ColorPickupFlyout& colorPicker);

        std::pair<std::shared_ptr<Pane>, std::shared_ptr<Pane>> SplitPane(winrt::Microsoft::Terminal::Settings::Model::SplitDirection splitType,
                 ...",1,cascadia\TerminalApp\TerminalTab.hpp,winrt.TerminalApp.implementation,16,implementation,1
119631,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalTabStatus.cpp,cascadia\TerminalApp\TerminalTabStatus.cpp:<global>,,<global>,1
119635,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
}",1,cascadia\TerminalApp\TerminalTabStatus.cpp,winrt,8,winrt,1
119636,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
}",1,cascadia\TerminalApp\TerminalTabStatus.cpp,winrt.TerminalApp,8,TerminalApp,1
119637,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
}",1,cascadia\TerminalApp\TerminalTabStatus.cpp,winrt.TerminalApp.implementation,8,implementation,1
119641,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalTabStatus.hpp,cascadia\TerminalApp\TerminalTabStatus.hpp:<global>,,<global>,1
119645,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTabStatus : TerminalTabStatusT<TerminalTabStatus>
    {
        TerminalTabStatus() = default;

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, IsConnectionClosed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsPaneZoomed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingIndeterminate, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, BellIndicator, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsReadOnlyActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(uint32_t, ProgressValue, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsInputBroadcastActive, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt,8,winrt,1
119646,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTabStatus : TerminalTabStatusT<TerminalTabStatus>
    {
        TerminalTabStatus() = default;

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, IsConnectionClosed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsPaneZoomed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingIndeterminate, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, BellIndicator, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsReadOnlyActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(uint32_t, ProgressValue, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsInputBroadcastActive, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt.TerminalApp,8,TerminalApp,1
119647,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TerminalTabStatus : TerminalTabStatusT<TerminalTabStatus>
    {
        TerminalTabStatus() = default;

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(bool, IsConnectionClosed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsPaneZoomed, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingIndeterminate, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, BellIndicator, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsReadOnlyActive, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(uint32_t, ProgressValue, _PropertyChangedHandlers);
        WINRT_OBSERVABLE_PROPERTY(bool, IsInputBroadcastActive, _PropertyChangedHandlers);
    };
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt.TerminalApp.implementation,8,implementation,1
119662,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalTabStatus);
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt,26,winrt,2
119663,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalTabStatus);
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt.TerminalApp,26,TerminalApp,1
119664,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalTabStatus);
}",1,cascadia\TerminalApp\TerminalTabStatus.hpp,winrt.TerminalApp.factory_implementation,26,factory_implementation,1
119735,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalWindow.cpp,cascadia\TerminalApp\TerminalWindow.cpp:<global>,,<global>,1
119738,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
    using IInspectable = Windows::Foundation::IInspectable;
}",1,cascadia\TerminalApp\TerminalWindow.cpp,winrt,28,winrt,1
119739,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalApp\TerminalWindow.cpp,Microsoft.UI.Xaml,30,MUX,1
119740,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalApp\TerminalWindow.cpp,Windows.UI.Xaml,31,WUX,2
119876,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalWindow::TerminalWindow(const TerminalApp::SettingsLoadEventArgs& settingsLoadedResult,
                                   const TerminalApp::ContentManager& manager) :
        _settings{ settingsLoadedResult.NewSettings() },
        _manager{ manager },
        _initialLoadResult{ settingsLoadedResult },
        _WindowProperties{ winrt::make_self<TerminalApp::implementation::WindowProperties>() }
    {
        // The TerminalPage has to ABSOLUTELY NOT BE constructed during our
        // construction. We can't do ANY xaml till Initialize() is called.

        // For your own sanity, it's better to do setup outside the ctor.
        // If you do any setup in the ctor that ends up throwing an exception,
        // then it might look like App just failed to activate, which will
        // cause you to chase down the rabbit hole of ""why is App not
        // registered?"" when it definitely is.
    }

    // Method Description:
...",1,cascadia\TerminalApp\TerminalWindow.cpp,winrt,121,winrt,8
119877,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalWindow::TerminalWindow(const TerminalApp::SettingsLoadEventArgs& settingsLoadedResult,
                                   const TerminalApp::ContentManager& manager) :
        _settings{ settingsLoadedResult.NewSettings() },
        _manager{ manager },
        _initialLoadResult{ settingsLoadedResult },
        _WindowProperties{ winrt::make_self<TerminalApp::implementation::WindowProperties>() }
    {
        // The TerminalPage has to ABSOLUTELY NOT BE constructed during our
        // construction. We can't do ANY xaml till Initialize() is called.

        // For your own sanity, it's better to do setup outside the ctor.
        // If you do any setup in the ctor that ends up throwing an exception,
        // then it might look like App just failed to activate, which will
        // cause you to chase down the rabbit hole of ""why is App not
        // registered?"" when it definitely is.
    }

    // Method Description:
...",1,cascadia\TerminalApp\TerminalWindow.cpp,winrt.TerminalApp,121,TerminalApp,1
119878,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TerminalWindow::TerminalWindow(const TerminalApp::SettingsLoadEventArgs& settingsLoadedResult,
                                   const TerminalApp::ContentManager& manager) :
        _settings{ settingsLoadedResult.NewSettings() },
        _manager{ manager },
        _initialLoadResult{ settingsLoadedResult },
        _WindowProperties{ winrt::make_self<TerminalApp::implementation::WindowProperties>() }
    {
        // The TerminalPage has to ABSOLUTELY NOT BE constructed during our
        // construction. We can't do ANY xaml till Initialize() is called.

        // For your own sanity, it's better to do setup outside the ctor.
        // If you do any setup in the ctor that ends up throwing an exception,
        // then it might look like App just failed to activate, which will
        // cause you to chase down the rabbit hole of ""why is App not
        // registered?"" when it definitely is.
    }

    // Method Description:
...",1,cascadia\TerminalApp\TerminalWindow.cpp,winrt.TerminalApp.implementation,121,implementation,1
122305,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TerminalWindow.hpp,cascadia\TerminalApp\TerminalWindow.hpp:<global>,,<global>,1
122309,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SystemMenuChangeArgs : SystemMenuChangeArgsT<SystemMenuChangeArgs>
    {
        WINRT_PROPERTY(winrt::hstring, Name, L"""");
        WINRT_PROPERTY(SystemMenuChangeAction, Action, SystemMenuChangeAction::Add);
        WINRT_PROPERTY(SystemMenuItemHandler, Handler, nullptr);

    public:
        SystemMenuChangeArgs(const winrt::hstring& name, SystemMenuChangeAction action, SystemMenuItemHandler handler = nullptr) :
            _Name{ name }, _Action{ action }, _Handler{ handler } {};
    };

    struct WindowProperties : WindowPropertiesT<WindowProperties>
    {
        // Normally, WindowName and WindowId would be
        // WINRT_OBSERVABLE_PROPERTY's, but we want them to raise
        // WindowNameForDisplay and WindowIdForDisplay instead
        winrt::hstring WindowName() const noexcept;
        void WindowName(const winrt::hstring& value);
        uint64_t WindowId() const noexcept;
        void WindowId(const uint64_t& ...",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt,25,winrt,1
122310,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SystemMenuChangeArgs : SystemMenuChangeArgsT<SystemMenuChangeArgs>
    {
        WINRT_PROPERTY(winrt::hstring, Name, L"""");
        WINRT_PROPERTY(SystemMenuChangeAction, Action, SystemMenuChangeAction::Add);
        WINRT_PROPERTY(SystemMenuItemHandler, Handler, nullptr);

    public:
        SystemMenuChangeArgs(const winrt::hstring& name, SystemMenuChangeAction action, SystemMenuItemHandler handler = nullptr) :
            _Name{ name }, _Action{ action }, _Handler{ handler } {};
    };

    struct WindowProperties : WindowPropertiesT<WindowProperties>
    {
        // Normally, WindowName and WindowId would be
        // WINRT_OBSERVABLE_PROPERTY's, but we want them to raise
        // WindowNameForDisplay and WindowIdForDisplay instead
        winrt::hstring WindowName() const noexcept;
        void WindowName(const winrt::hstring& value);
        uint64_t WindowId() const noexcept;
        void WindowId(const uint64_t& ...",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt.TerminalApp,25,TerminalApp,1
122311,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct SystemMenuChangeArgs : SystemMenuChangeArgsT<SystemMenuChangeArgs>
    {
        WINRT_PROPERTY(winrt::hstring, Name, L"""");
        WINRT_PROPERTY(SystemMenuChangeAction, Action, SystemMenuChangeAction::Add);
        WINRT_PROPERTY(SystemMenuItemHandler, Handler, nullptr);

    public:
        SystemMenuChangeArgs(const winrt::hstring& name, SystemMenuChangeAction action, SystemMenuItemHandler handler = nullptr) :
            _Name{ name }, _Action{ action }, _Handler{ handler } {};
    };

    struct WindowProperties : WindowPropertiesT<WindowProperties>
    {
        // Normally, WindowName and WindowId would be
        // WINRT_OBSERVABLE_PROPERTY's, but we want them to raise
        // WindowNameForDisplay and WindowIdForDisplay instead
        winrt::hstring WindowName() const noexcept;
        void WindowName(const winrt::hstring& value);
        uint64_t WindowId() const noexcept;
        void WindowId(const uint64_t& ...",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt.TerminalApp.implementation,25,implementation,1
122827,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalWindow);
}",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt,248,winrt,2
122828,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalWindow);
}",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt.TerminalApp,248,TerminalApp,1
122829,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TerminalWindow);
}",1,cascadia\TerminalApp\TerminalWindow.hpp,winrt.TerminalApp.factory_implementation,248,factory_implementation,1
122873,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TitlebarControl.cpp,cascadia\TerminalApp\TitlebarControl.cpp:<global>,,<global>,1
122876,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TitlebarControl::TitlebarControl(uint64_t handle) :
        _window{ reinterpret_cast<HWND>(handle) }
    {
        InitializeComponent();

        // Register our event handlers on the MMC buttons.
        MinMaxCloseControl().MinimizeClick({ this, &TitlebarControl::Minimize_Click });
        MinMaxCloseControl().MaximizeClick({ this, &TitlebarControl::Maximize_Click });
        MinMaxCloseControl().CloseClick({ this, &TitlebarControl::Close_Click });

        // Listen for changes to the Background. If the Background changes,
        // we'll want to manually adjust the RequestedTheme of our caption
        // buttons, so the foreground stands out against whatever BG color was
        // selected for us.
        //
        // This is how you register a PropertyChanged event for the Background
        // property of a Grid. The Background property is defined in the base
        // class Panel.
        const auto bgProperty{ winrt::...",1,cascadia\TerminalApp\TitlebarControl.cpp,winrt,15,winrt,1
122877,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TitlebarControl::TitlebarControl(uint64_t handle) :
        _window{ reinterpret_cast<HWND>(handle) }
    {
        InitializeComponent();

        // Register our event handlers on the MMC buttons.
        MinMaxCloseControl().MinimizeClick({ this, &TitlebarControl::Minimize_Click });
        MinMaxCloseControl().MaximizeClick({ this, &TitlebarControl::Maximize_Click });
        MinMaxCloseControl().CloseClick({ this, &TitlebarControl::Close_Click });

        // Listen for changes to the Background. If the Background changes,
        // we'll want to manually adjust the RequestedTheme of our caption
        // buttons, so the foreground stands out against whatever BG color was
        // selected for us.
        //
        // This is how you register a PropertyChanged event for the Background
        // property of a Grid. The Background property is defined in the base
        // class Panel.
        const auto bgProperty{ winrt::...",1,cascadia\TerminalApp\TitlebarControl.cpp,winrt.TerminalApp,15,TerminalApp,1
122878,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    TitlebarControl::TitlebarControl(uint64_t handle) :
        _window{ reinterpret_cast<HWND>(handle) }
    {
        InitializeComponent();

        // Register our event handlers on the MMC buttons.
        MinMaxCloseControl().MinimizeClick({ this, &TitlebarControl::Minimize_Click });
        MinMaxCloseControl().MaximizeClick({ this, &TitlebarControl::Maximize_Click });
        MinMaxCloseControl().CloseClick({ this, &TitlebarControl::Close_Click });

        // Listen for changes to the Background. If the Background changes,
        // we'll want to manually adjust the RequestedTheme of our caption
        // buttons, so the foreground stands out against whatever BG color was
        // selected for us.
        //
        // This is how you register a PropertyChanged event for the Background
        // property of a Grid. The Background property is defined in the base
        // class Panel.
        const auto bgProperty{ winrt::...",1,cascadia\TerminalApp\TitlebarControl.cpp,winrt.TerminalApp.implementation,15,implementation,1
123307,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\TitlebarControl.hpp,cascadia\TerminalApp\TitlebarControl.hpp:<global>,,<global>,1
123311,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TitlebarControl : TitlebarControlT<TitlebarControl>
    {
        TitlebarControl(uint64_t handle);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        winrt::fire_and_forget ClickButton(CaptionButton button);
        void ReleaseButtons();
        double CaptionButtonWidth();

        IInspectable Content();
        void Content(IInspectable content);

        void SetWindowVisualState(WindowVisualState visualState);
        void Root_SizeChanged(const IInspectable& sender, const Windows::UI::Xaml::SizeChangedEventArgs& e);

        void Minimize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Maximize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Close_Click(const winrt::Windows::Foundation::IInspectable& sender,...",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt,8,winrt,1
123312,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TitlebarControl : TitlebarControlT<TitlebarControl>
    {
        TitlebarControl(uint64_t handle);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        winrt::fire_and_forget ClickButton(CaptionButton button);
        void ReleaseButtons();
        double CaptionButtonWidth();

        IInspectable Content();
        void Content(IInspectable content);

        void SetWindowVisualState(WindowVisualState visualState);
        void Root_SizeChanged(const IInspectable& sender, const Windows::UI::Xaml::SizeChangedEventArgs& e);

        void Minimize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Maximize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Close_Click(const winrt::Windows::Foundation::IInspectable& sender,...",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt.TerminalApp,8,TerminalApp,1
123313,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::implementation
{
    struct TitlebarControl : TitlebarControlT<TitlebarControl>
    {
        TitlebarControl(uint64_t handle);

        void HoverButton(CaptionButton button);
        void PressButton(CaptionButton button);
        winrt::fire_and_forget ClickButton(CaptionButton button);
        void ReleaseButtons();
        double CaptionButtonWidth();

        IInspectable Content();
        void Content(IInspectable content);

        void SetWindowVisualState(WindowVisualState visualState);
        void Root_SizeChanged(const IInspectable& sender, const Windows::UI::Xaml::SizeChangedEventArgs& e);

        void Minimize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Maximize_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void Close_Click(const winrt::Windows::Foundation::IInspectable& sender,...",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt.TerminalApp.implementation,8,implementation,1
123406,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TitlebarControl);
}",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt,39,winrt,2
123407,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TitlebarControl);
}",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt.TerminalApp,39,TerminalApp,1
123408,NAMESPACE_BLOCK,"namespace winrt::TerminalApp::factory_implementation
{
    BASIC_FACTORY(TitlebarControl);
}",1,cascadia\TerminalApp\TitlebarControl.hpp,winrt.TerminalApp.factory_implementation,39,factory_implementation,1
123447,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Toast.cpp,cascadia\TerminalApp\Toast.cpp:<global>,,<global>,1
123495,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\Toast.hpp,cascadia\TerminalApp\Toast.hpp:<global>,,<global>,1
123514,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\dll\pch.cpp,cascadia\TerminalApp\dll\pch.cpp:<global>,,<global>,1
123519,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\dll\pch.hpp,cascadia\TerminalApp\dll\pch.hpp:<global>,,<global>,1
123530,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\init.cpp,cascadia\TerminalApp\init.cpp:<global>,,<global>,1
123576,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\pch.cpp,cascadia\TerminalApp\pch.cpp:<global>,,<global>,1
123687,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalApp\pch.hpp,cascadia\TerminalApp\pch.hpp:<global>,,<global>,1
123699,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalAzBridge\ConsoleInputReader.cpp,cascadia\TerminalAzBridge\ConsoleInputReader.cpp:<global>,,<global>,1
123943,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalAzBridge\ConsoleInputReader.hpp,cascadia\TerminalAzBridge\ConsoleInputReader.hpp:<global>,,<global>,1
124142,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalAzBridge\main.cpp,cascadia\TerminalAzBridge\main.cpp:<global>,,<global>,1
124380,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalAzBridge\pch.cpp,cascadia\TerminalAzBridge\pch.cpp:<global>,,<global>,1
124405,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalAzBridge\pch.hpp,cascadia\TerminalAzBridge\pch.hpp:<global>,,<global>,1
124410,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\AzureClient.hpp,cascadia\TerminalConnection\AzureClient.hpp:<global>,,<global>,1
124414,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Azure
{
    class AzureException : public std::runtime_error
    {
        std::wstring _code;

    public:
        static bool IsErrorPayload(const winrt::Windows::Data::Json::JsonObject& errorObject)
        {
            if (!errorObject.HasKey(L""error""))
            {
                return false;
            }

            if (errorObject.GetNamedValue(L""error"").ValueType() != winrt::Windows::Data::Json::JsonValueType::String)
            {
                return false;
            }

            return true;
        }

        AzureException(const winrt::Windows::Data::Json::JsonObject& errorObject) :
            runtime_error(til::u16u8(errorObject.GetNamedString(L""error_description""))), // surface the human-readable description as .what()
            _code(errorObject.GetNamedString(L""error""))
        {
        }

        std::wstring_view GetCode() const noexcept
        {
            return _code;
        }
    };

    namespace ErrorCodes
  ...",1,cascadia\TerminalConnection\AzureClient.hpp,Microsoft,6,Microsoft,1
124415,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Azure
{
    class AzureException : public std::runtime_error
    {
        std::wstring _code;

    public:
        static bool IsErrorPayload(const winrt::Windows::Data::Json::JsonObject& errorObject)
        {
            if (!errorObject.HasKey(L""error""))
            {
                return false;
            }

            if (errorObject.GetNamedValue(L""error"").ValueType() != winrt::Windows::Data::Json::JsonValueType::String)
            {
                return false;
            }

            return true;
        }

        AzureException(const winrt::Windows::Data::Json::JsonObject& errorObject) :
            runtime_error(til::u16u8(errorObject.GetNamedString(L""error_description""))), // surface the human-readable description as .what()
            _code(errorObject.GetNamedString(L""error""))
        {
        }

        std::wstring_view GetCode() const noexcept
        {
            return _code;
        }
    };

    namespace ErrorCodes
  ...",1,cascadia\TerminalConnection\AzureClient.hpp,Microsoft.Terminal,6,Terminal,1
124416,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Azure
{
    class AzureException : public std::runtime_error
    {
        std::wstring _code;

    public:
        static bool IsErrorPayload(const winrt::Windows::Data::Json::JsonObject& errorObject)
        {
            if (!errorObject.HasKey(L""error""))
            {
                return false;
            }

            if (errorObject.GetNamedValue(L""error"").ValueType() != winrt::Windows::Data::Json::JsonValueType::String)
            {
                return false;
            }

            return true;
        }

        AzureException(const winrt::Windows::Data::Json::JsonObject& errorObject) :
            runtime_error(til::u16u8(errorObject.GetNamedString(L""error_description""))), // surface the human-readable description as .what()
            _code(errorObject.GetNamedString(L""error""))
        {
        }

        std::wstring_view GetCode() const noexcept
        {
            return _code;
        }
    };

    namespace ErrorCodes
  ...",1,cascadia\TerminalConnection\AzureClient.hpp,Microsoft.Terminal.Azure,6,Azure,1
124471,NAMESPACE_BLOCK,"namespace ErrorCodes
    {
        static constexpr std::wstring_view AuthorizationPending{ L""authorization_pending"" };
        static constexpr std::wstring_view InvalidGrant{ L""invalid_grant"" };
    }",5,cascadia\TerminalConnection\AzureClient.hpp,Microsoft.Terminal.Azure.ErrorCodes,40,ErrorCodes,2
124487,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\AzureClientID.hpp,cascadia\TerminalConnection\AzureClientID.hpp:<global>,,<global>,1
124563,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\AzureConnection.cpp,cascadia\TerminalConnection\AzureConnection.cpp:<global>,,<global>,1
124586,NAMESPACE_BLOCK,namespace WDJ = ::winrt::Windows::Data::Json;,1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Windows.Data.Json,32,WDJ,11
124587,NAMESPACE_BLOCK,namespace WSS = ::winrt::Windows::Storage::Streams;,1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Windows.Storage.Streams,33,WSS,12
124588,NAMESPACE_BLOCK,namespace WWH = ::winrt::Windows::Web::Http;,1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Windows.Web.Http,34,WWH,13
124681,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    winrt::guid AzureConnection::ConnectionType() noexcept
    {
        return AzureConnectionType;
    }

    // This function exists because the clientID only gets added by the release pipelines
    // and is not available on local builds, so we want to be able to make sure we don't
    // try to make an Azure connection if its a local build
    bool AzureConnection::IsAzureConnectionAvailable() noexcept
    {
        return (AzureClientID != L""0"");
    }

    void AzureConnection::Initialize(const Windows::Foundation::Collections::ValueSet& settings)
    {
        if (settings)
        {
            _initialRows = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialRows"").try_as<Windows::Foundation::IPropertyValue>(), _initialRows));
            _initialCols = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialCols"").try_as<Windows::...",1,cascadia\TerminalConnection\AzureConnection.cpp,winrt,61,winrt,19
124682,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    winrt::guid AzureConnection::ConnectionType() noexcept
    {
        return AzureConnectionType;
    }

    // This function exists because the clientID only gets added by the release pipelines
    // and is not available on local builds, so we want to be able to make sure we don't
    // try to make an Azure connection if its a local build
    bool AzureConnection::IsAzureConnectionAvailable() noexcept
    {
        return (AzureClientID != L""0"");
    }

    void AzureConnection::Initialize(const Windows::Foundation::Collections::ValueSet& settings)
    {
        if (settings)
        {
            _initialRows = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialRows"").try_as<Windows::Foundation::IPropertyValue>(), _initialRows));
            _initialCols = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialCols"").try_as<Windows::...",1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Microsoft,61,Microsoft,1
124683,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    winrt::guid AzureConnection::ConnectionType() noexcept
    {
        return AzureConnectionType;
    }

    // This function exists because the clientID only gets added by the release pipelines
    // and is not available on local builds, so we want to be able to make sure we don't
    // try to make an Azure connection if its a local build
    bool AzureConnection::IsAzureConnectionAvailable() noexcept
    {
        return (AzureClientID != L""0"");
    }

    void AzureConnection::Initialize(const Windows::Foundation::Collections::ValueSet& settings)
    {
        if (settings)
        {
            _initialRows = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialRows"").try_as<Windows::Foundation::IPropertyValue>(), _initialRows));
            _initialCols = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialCols"").try_as<Windows::...",1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Microsoft.Terminal,61,Terminal,1
124684,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    winrt::guid AzureConnection::ConnectionType() noexcept
    {
        return AzureConnectionType;
    }

    // This function exists because the clientID only gets added by the release pipelines
    // and is not available on local builds, so we want to be able to make sure we don't
    // try to make an Azure connection if its a local build
    bool AzureConnection::IsAzureConnectionAvailable() noexcept
    {
        return (AzureClientID != L""0"");
    }

    void AzureConnection::Initialize(const Windows::Foundation::Collections::ValueSet& settings)
    {
        if (settings)
        {
            _initialRows = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialRows"").try_as<Windows::Foundation::IPropertyValue>(), _initialRows));
            _initialCols = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialCols"").try_as<Windows::...",1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection,61,TerminalConnection,1
124685,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    winrt::guid AzureConnection::ConnectionType() noexcept
    {
        return AzureConnectionType;
    }

    // This function exists because the clientID only gets added by the release pipelines
    // and is not available on local builds, so we want to be able to make sure we don't
    // try to make an Azure connection if its a local build
    bool AzureConnection::IsAzureConnectionAvailable() noexcept
    {
        return (AzureClientID != L""0"");
    }

    void AzureConnection::Initialize(const Windows::Foundation::Collections::ValueSet& settings)
    {
        if (settings)
        {
            _initialRows = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialRows"").try_as<Windows::Foundation::IPropertyValue>(), _initialRows));
            _initialCols = gsl::narrow<til::CoordType>(winrt::unbox_value_or<uint32_t>(settings.TryLookup(L""initialCols"").try_as<Windows::...",1,cascadia\TerminalConnection\AzureConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,61,implementation,1
127147,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\AzureConnection.hpp,cascadia\TerminalConnection\AzureConnection.hpp:<global>,,<global>,1
127151,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct AzureConnection : AzureConnectionT<AzureConnection>, ConnectionStateHolder<AzureConnection>
    {
        static winrt::guid ConnectionType() noexcept;
        static bool IsAzureConnectionAvailable() noexcept;

        AzureConnection() = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);

    private:
        til::CoordType _initialRows{};
        til::CoordType _initialCols{};

        enum class AzureState
        {
            AccessStored,
            DeviceFlow,
            TenantChoice,
            StoreTokens,
            TermConnecting,
            TermConnected,
        };

        AzureState _state{ AzureState::AccessStored };

        wil...",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt,14,winrt,1
127152,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct AzureConnection : AzureConnectionT<AzureConnection>, ConnectionStateHolder<AzureConnection>
    {
        static winrt::guid ConnectionType() noexcept;
        static bool IsAzureConnectionAvailable() noexcept;

        AzureConnection() = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);

    private:
        til::CoordType _initialRows{};
        til::CoordType _initialCols{};

        enum class AzureState
        {
            AccessStored,
            DeviceFlow,
            TenantChoice,
            StoreTokens,
            TermConnecting,
            TermConnected,
        };

        AzureState _state{ AzureState::AccessStored };

        wil...",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft,14,Microsoft,1
127153,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct AzureConnection : AzureConnectionT<AzureConnection>, ConnectionStateHolder<AzureConnection>
    {
        static winrt::guid ConnectionType() noexcept;
        static bool IsAzureConnectionAvailable() noexcept;

        AzureConnection() = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);

    private:
        til::CoordType _initialRows{};
        til::CoordType _initialCols{};

        enum class AzureState
        {
            AccessStored,
            DeviceFlow,
            TenantChoice,
            StoreTokens,
            TermConnecting,
            TermConnected,
        };

        AzureState _state{ AzureState::AccessStored };

        wil...",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal,14,Terminal,1
127154,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct AzureConnection : AzureConnectionT<AzureConnection>, ConnectionStateHolder<AzureConnection>
    {
        static winrt::guid ConnectionType() noexcept;
        static bool IsAzureConnectionAvailable() noexcept;

        AzureConnection() = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);

    private:
        til::CoordType _initialRows{};
        til::CoordType _initialCols{};

        enum class AzureState
        {
            AccessStored,
            DeviceFlow,
            TenantChoice,
            StoreTokens,
            TermConnecting,
            TermConnected,
        };

        AzureState _state{ AzureState::AccessStored };

        wil...",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,14,TerminalConnection,1
127155,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct AzureConnection : AzureConnectionT<AzureConnection>, ConnectionStateHolder<AzureConnection>
    {
        static winrt::guid ConnectionType() noexcept;
        static bool IsAzureConnectionAvailable() noexcept;

        AzureConnection() = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close();

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);

    private:
        til::CoordType _initialRows{};
        til::CoordType _initialCols{};

        enum class AzureState
        {
            AccessStored,
            DeviceFlow,
            TenantChoice,
            StoreTokens,
            TermConnecting,
            TermConnected,
        };

        AzureState _state{ AzureState::AccessStored };

        wil...",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,14,implementation,1
127385,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(AzureConnection);
}",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt,108,winrt,2
127386,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(AzureConnection);
}",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft,108,Microsoft,1
127387,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(AzureConnection);
}",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal,108,Terminal,1
127388,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(AzureConnection);
}",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,108,TerminalConnection,1
127389,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(AzureConnection);
}",1,cascadia\TerminalConnection\AzureConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.factory_implementation,108,factory_implementation,1
127396,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\CTerminalHandoff.cpp,cascadia\TerminalConnection\CTerminalHandoff.cpp:<global>,,<global>,1
127547,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\CTerminalHandoff.hpp,cascadia\TerminalConnection\CTerminalHandoff.hpp:<global>,,<global>,1
127585,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\ConnectionInformation.cpp,cascadia\TerminalConnection\ConnectionInformation.cpp:<global>,,<global>,1
127589,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    ConnectionInformation::ConnectionInformation(const hstring& className,
                                                 const Windows::Foundation::Collections::ValueSet& settings) :
        _ClassName{ className },
        _Settings{ settings }
    {
    }

    // Function Description:
    // - Create an instance of the connection specified in the
    //   ConnectionInformation, and Initialize it.
    // - This static method allows the content process to create a connection
    //   from information that lives in the window process.
    // Arguments:
    // - info: A ConnectionInformation object that possibly lives out-of-proc,
    //   containing the name of the WinRT class we should activate for this
    //   connection, and a bag of setting to use to initialize that object.
    // Return Value:
    // - <none>
    TerminalConnection::ITerminalConnection ConnectionInformation::CreateConnection(TerminalC...",1,cascadia\TerminalConnection\ConnectionInformation.cpp,winrt,5,winrt,1
127590,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    ConnectionInformation::ConnectionInformation(const hstring& className,
                                                 const Windows::Foundation::Collections::ValueSet& settings) :
        _ClassName{ className },
        _Settings{ settings }
    {
    }

    // Function Description:
    // - Create an instance of the connection specified in the
    //   ConnectionInformation, and Initialize it.
    // - This static method allows the content process to create a connection
    //   from information that lives in the window process.
    // Arguments:
    // - info: A ConnectionInformation object that possibly lives out-of-proc,
    //   containing the name of the WinRT class we should activate for this
    //   connection, and a bag of setting to use to initialize that object.
    // Return Value:
    // - <none>
    TerminalConnection::ITerminalConnection ConnectionInformation::CreateConnection(TerminalC...",1,cascadia\TerminalConnection\ConnectionInformation.cpp,winrt.Microsoft,5,Microsoft,1
127591,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    ConnectionInformation::ConnectionInformation(const hstring& className,
                                                 const Windows::Foundation::Collections::ValueSet& settings) :
        _ClassName{ className },
        _Settings{ settings }
    {
    }

    // Function Description:
    // - Create an instance of the connection specified in the
    //   ConnectionInformation, and Initialize it.
    // - This static method allows the content process to create a connection
    //   from information that lives in the window process.
    // Arguments:
    // - info: A ConnectionInformation object that possibly lives out-of-proc,
    //   containing the name of the WinRT class we should activate for this
    //   connection, and a bag of setting to use to initialize that object.
    // Return Value:
    // - <none>
    TerminalConnection::ITerminalConnection ConnectionInformation::CreateConnection(TerminalC...",1,cascadia\TerminalConnection\ConnectionInformation.cpp,winrt.Microsoft.Terminal,5,Terminal,1
127592,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    ConnectionInformation::ConnectionInformation(const hstring& className,
                                                 const Windows::Foundation::Collections::ValueSet& settings) :
        _ClassName{ className },
        _Settings{ settings }
    {
    }

    // Function Description:
    // - Create an instance of the connection specified in the
    //   ConnectionInformation, and Initialize it.
    // - This static method allows the content process to create a connection
    //   from information that lives in the window process.
    // Arguments:
    // - info: A ConnectionInformation object that possibly lives out-of-proc,
    //   containing the name of the WinRT class we should activate for this
    //   connection, and a bag of setting to use to initialize that object.
    // Return Value:
    // - <none>
    TerminalConnection::ITerminalConnection ConnectionInformation::CreateConnection(TerminalC...",1,cascadia\TerminalConnection\ConnectionInformation.cpp,winrt.Microsoft.Terminal.TerminalConnection,5,TerminalConnection,1
127593,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    ConnectionInformation::ConnectionInformation(const hstring& className,
                                                 const Windows::Foundation::Collections::ValueSet& settings) :
        _ClassName{ className },
        _Settings{ settings }
    {
    }

    // Function Description:
    // - Create an instance of the connection specified in the
    //   ConnectionInformation, and Initialize it.
    // - This static method allows the content process to create a connection
    //   from information that lives in the window process.
    // Arguments:
    // - info: A ConnectionInformation object that possibly lives out-of-proc,
    //   containing the name of the WinRT class we should activate for this
    //   connection, and a bag of setting to use to initialize that object.
    // Return Value:
    // - <none>
    TerminalConnection::ITerminalConnection ConnectionInformation::CreateConnection(TerminalC...",1,cascadia\TerminalConnection\ConnectionInformation.cpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,5,implementation,1
127670,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\ConnectionInformation.hpp,cascadia\TerminalConnection\ConnectionInformation.hpp:<global>,,<global>,1
127674,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConnectionInformation : ConnectionInformationT<ConnectionInformation>
    {
        ConnectionInformation(const hstring& className,
                              const Windows::Foundation::Collections::ValueSet& settings);

        static TerminalConnection::ITerminalConnection CreateConnection(TerminalConnection::ConnectionInformation info);

        winrt::hstring ClassName() const { return _ClassName; }
        void ClassName(const winrt::hstring& value) { _ClassName = value; }

        WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);

    private:
        winrt::hstring _ClassName{};
    };
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt,21,winrt,1
127675,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConnectionInformation : ConnectionInformationT<ConnectionInformation>
    {
        ConnectionInformation(const hstring& className,
                              const Windows::Foundation::Collections::ValueSet& settings);

        static TerminalConnection::ITerminalConnection CreateConnection(TerminalConnection::ConnectionInformation info);

        winrt::hstring ClassName() const { return _ClassName; }
        void ClassName(const winrt::hstring& value) { _ClassName = value; }

        WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);

    private:
        winrt::hstring _ClassName{};
    };
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft,21,Microsoft,1
127676,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConnectionInformation : ConnectionInformationT<ConnectionInformation>
    {
        ConnectionInformation(const hstring& className,
                              const Windows::Foundation::Collections::ValueSet& settings);

        static TerminalConnection::ITerminalConnection CreateConnection(TerminalConnection::ConnectionInformation info);

        winrt::hstring ClassName() const { return _ClassName; }
        void ClassName(const winrt::hstring& value) { _ClassName = value; }

        WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);

    private:
        winrt::hstring _ClassName{};
    };
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal,21,Terminal,1
127677,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConnectionInformation : ConnectionInformationT<ConnectionInformation>
    {
        ConnectionInformation(const hstring& className,
                              const Windows::Foundation::Collections::ValueSet& settings);

        static TerminalConnection::ITerminalConnection CreateConnection(TerminalConnection::ConnectionInformation info);

        winrt::hstring ClassName() const { return _ClassName; }
        void ClassName(const winrt::hstring& value) { _ClassName = value; }

        WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);

    private:
        winrt::hstring _ClassName{};
    };
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal.TerminalConnection,21,TerminalConnection,1
127678,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConnectionInformation : ConnectionInformationT<ConnectionInformation>
    {
        ConnectionInformation(const hstring& className,
                              const Windows::Foundation::Collections::ValueSet& settings);

        static TerminalConnection::ITerminalConnection CreateConnection(TerminalConnection::ConnectionInformation info);

        winrt::hstring ClassName() const { return _ClassName; }
        void ClassName(const winrt::hstring& value) { _ClassName = value; }

        WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);

    private:
        winrt::hstring _ClassName{};
    };
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,21,implementation,1
127714,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConnectionInformation);
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt,39,winrt,2
127715,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConnectionInformation);
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft,39,Microsoft,1
127716,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConnectionInformation);
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal,39,Terminal,1
127717,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConnectionInformation);
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal.TerminalConnection,39,TerminalConnection,1
127718,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConnectionInformation);
}",1,cascadia\TerminalConnection\ConnectionInformation.hpp,winrt.Microsoft.Terminal.TerminalConnection.factory_implementation,39,factory_implementation,1
127721,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\ConnectionStateHolder.hpp,cascadia\TerminalConnection\ConnectionStateHolder.hpp:<global>,,<global>,1
127725,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    template<typename T>
    struct ConnectionStateHolder
    {
    public:
        ConnectionState State() const noexcept { return _connectionState; }
        TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);

    protected:
#pragma warning(push)
#pragma warning(disable : 26447) // Analyzer is still upset about noexcepts throwing even with function level try.
        // Method Description:
        // - Attempt to transition to and signal the specified connection state.
        //   The transition will only be effected if the state is ""beyond"" the current state.
        // Arguments:
        // - state: the new state
        // Return Value:
        //   Whether we've successfully transitioned to the new state.
        bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ ...",1,cascadia\TerminalConnection\ConnectionStateHolder.hpp,winrt,4,winrt,1
127726,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    template<typename T>
    struct ConnectionStateHolder
    {
    public:
        ConnectionState State() const noexcept { return _connectionState; }
        TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);

    protected:
#pragma warning(push)
#pragma warning(disable : 26447) // Analyzer is still upset about noexcepts throwing even with function level try.
        // Method Description:
        // - Attempt to transition to and signal the specified connection state.
        //   The transition will only be effected if the state is ""beyond"" the current state.
        // Arguments:
        // - state: the new state
        // Return Value:
        //   Whether we've successfully transitioned to the new state.
        bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ ...",1,cascadia\TerminalConnection\ConnectionStateHolder.hpp,winrt.Microsoft,4,Microsoft,1
127727,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    template<typename T>
    struct ConnectionStateHolder
    {
    public:
        ConnectionState State() const noexcept { return _connectionState; }
        TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);

    protected:
#pragma warning(push)
#pragma warning(disable : 26447) // Analyzer is still upset about noexcepts throwing even with function level try.
        // Method Description:
        // - Attempt to transition to and signal the specified connection state.
        //   The transition will only be effected if the state is ""beyond"" the current state.
        // Arguments:
        // - state: the new state
        // Return Value:
        //   Whether we've successfully transitioned to the new state.
        bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ ...",1,cascadia\TerminalConnection\ConnectionStateHolder.hpp,winrt.Microsoft.Terminal,4,Terminal,1
127728,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    template<typename T>
    struct ConnectionStateHolder
    {
    public:
        ConnectionState State() const noexcept { return _connectionState; }
        TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);

    protected:
#pragma warning(push)
#pragma warning(disable : 26447) // Analyzer is still upset about noexcepts throwing even with function level try.
        // Method Description:
        // - Attempt to transition to and signal the specified connection state.
        //   The transition will only be effected if the state is ""beyond"" the current state.
        // Arguments:
        // - state: the new state
        // Return Value:
        //   Whether we've successfully transitioned to the new state.
        bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ ...",1,cascadia\TerminalConnection\ConnectionStateHolder.hpp,winrt.Microsoft.Terminal.TerminalConnection,4,TerminalConnection,1
127729,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    template<typename T>
    struct ConnectionStateHolder
    {
    public:
        ConnectionState State() const noexcept { return _connectionState; }
        TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);

    protected:
#pragma warning(push)
#pragma warning(disable : 26447) // Analyzer is still upset about noexcepts throwing even with function level try.
        // Method Description:
        // - Attempt to transition to and signal the specified connection state.
        //   The transition will only be effected if the state is ""beyond"" the current state.
        // Arguments:
        // - state: the new state
        // Return Value:
        //   Whether we've successfully transitioned to the new state.
        bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ ...",1,cascadia\TerminalConnection\ConnectionStateHolder.hpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,4,implementation,1
127801,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\ConptyConnection.cpp,cascadia\TerminalConnection\ConptyConnection.cpp:<global>,,<global>,1
127808,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    // Function Description:
    // - creates some basic anonymous pipes and passes them to CreatePseudoConsole
    // Arguments:
    // - size: The size of the conpty to create, in characters.
    // - phInput: Receives the handle to the newly-created anonymous pipe for writing input to the conpty.
    // - phOutput: Receives the handle to the newly-created anonymous pipe for reading the output of the conpty.
    // - phPc: Receives a token value to identify this conpty
#pragma warning(suppress : 26430) // This statement sufficiently checks the out parameters. Analyzer cannot find this.
    static HRESULT _CreatePseudoConsoleAndPipes(const COORD size, const DWORD dwFlags, HANDLE* phInput, HANDLE* phOutput, HPCON* phPC) noexcept
    {
        RETURN_HR_IF(E_INVALIDARG, phPC == nullptr || phInput == nullptr || phOutput == nullptr);

        wil::unique_hfile outPipeOurSide, outPipePseudoConsoleSide;
        wi...",1,cascadia\TerminalConnection\ConptyConnection.cpp,winrt,34,winrt,3
127809,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    // Function Description:
    // - creates some basic anonymous pipes and passes them to CreatePseudoConsole
    // Arguments:
    // - size: The size of the conpty to create, in characters.
    // - phInput: Receives the handle to the newly-created anonymous pipe for writing input to the conpty.
    // - phOutput: Receives the handle to the newly-created anonymous pipe for reading the output of the conpty.
    // - phPc: Receives a token value to identify this conpty
#pragma warning(suppress : 26430) // This statement sufficiently checks the out parameters. Analyzer cannot find this.
    static HRESULT _CreatePseudoConsoleAndPipes(const COORD size, const DWORD dwFlags, HANDLE* phInput, HANDLE* phOutput, HPCON* phPC) noexcept
    {
        RETURN_HR_IF(E_INVALIDARG, phPC == nullptr || phInput == nullptr || phOutput == nullptr);

        wil::unique_hfile outPipeOurSide, outPipePseudoConsoleSide;
        wi...",1,cascadia\TerminalConnection\ConptyConnection.cpp,winrt.Microsoft,34,Microsoft,1
127810,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    // Function Description:
    // - creates some basic anonymous pipes and passes them to CreatePseudoConsole
    // Arguments:
    // - size: The size of the conpty to create, in characters.
    // - phInput: Receives the handle to the newly-created anonymous pipe for writing input to the conpty.
    // - phOutput: Receives the handle to the newly-created anonymous pipe for reading the output of the conpty.
    // - phPc: Receives a token value to identify this conpty
#pragma warning(suppress : 26430) // This statement sufficiently checks the out parameters. Analyzer cannot find this.
    static HRESULT _CreatePseudoConsoleAndPipes(const COORD size, const DWORD dwFlags, HANDLE* phInput, HANDLE* phOutput, HPCON* phPC) noexcept
    {
        RETURN_HR_IF(E_INVALIDARG, phPC == nullptr || phInput == nullptr || phOutput == nullptr);

        wil::unique_hfile outPipeOurSide, outPipePseudoConsoleSide;
        wi...",1,cascadia\TerminalConnection\ConptyConnection.cpp,winrt.Microsoft.Terminal,34,Terminal,1
127811,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    // Function Description:
    // - creates some basic anonymous pipes and passes them to CreatePseudoConsole
    // Arguments:
    // - size: The size of the conpty to create, in characters.
    // - phInput: Receives the handle to the newly-created anonymous pipe for writing input to the conpty.
    // - phOutput: Receives the handle to the newly-created anonymous pipe for reading the output of the conpty.
    // - phPc: Receives a token value to identify this conpty
#pragma warning(suppress : 26430) // This statement sufficiently checks the out parameters. Analyzer cannot find this.
    static HRESULT _CreatePseudoConsoleAndPipes(const COORD size, const DWORD dwFlags, HANDLE* phInput, HANDLE* phOutput, HPCON* phPC) noexcept
    {
        RETURN_HR_IF(E_INVALIDARG, phPC == nullptr || phInput == nullptr || phOutput == nullptr);

        wil::unique_hfile outPipeOurSide, outPipePseudoConsoleSide;
        wi...",1,cascadia\TerminalConnection\ConptyConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection,34,TerminalConnection,1
127812,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    // Function Description:
    // - creates some basic anonymous pipes and passes them to CreatePseudoConsole
    // Arguments:
    // - size: The size of the conpty to create, in characters.
    // - phInput: Receives the handle to the newly-created anonymous pipe for writing input to the conpty.
    // - phOutput: Receives the handle to the newly-created anonymous pipe for reading the output of the conpty.
    // - phPc: Receives a token value to identify this conpty
#pragma warning(suppress : 26430) // This statement sufficiently checks the out parameters. Analyzer cannot find this.
    static HRESULT _CreatePseudoConsoleAndPipes(const COORD size, const DWORD dwFlags, HANDLE* phInput, HANDLE* phOutput, HPCON* phPC) noexcept
    {
        RETURN_HR_IF(E_INVALIDARG, phPC == nullptr || phInput == nullptr || phOutput == nullptr);

        wil::unique_hfile outPipeOurSide, outPipePseudoConsoleSide;
        wi...",1,cascadia\TerminalConnection\ConptyConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,34,implementation,1
128864,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\ConptyConnection.hpp,cascadia\TerminalConnection\ConptyConnection.hpp:<global>,,<global>,1
128868,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConptyConnection : ConptyConnectionT<ConptyConnection>, ConnectionStateHolder<ConptyConnection>
    {
        ConptyConnection(const HANDLE hSig,
                         const HANDLE hIn,
                         const HANDLE hOut,
                         const HANDLE hRef,
                         const HANDLE hServerProcess,
                         const HANDLE hClientProcess,
                         TERMINAL_STARTUP_INFO startupInfo);

        ConptyConnection() noexcept = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        static winrt::fire_and_forget final_release(std::unique_ptr<ConptyConnection> connection);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close() noexcept;
        void ClearBuffer();

        void ShowHide(const bool show);

        ...",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt,12,winrt,1
128869,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConptyConnection : ConptyConnectionT<ConptyConnection>, ConnectionStateHolder<ConptyConnection>
    {
        ConptyConnection(const HANDLE hSig,
                         const HANDLE hIn,
                         const HANDLE hOut,
                         const HANDLE hRef,
                         const HANDLE hServerProcess,
                         const HANDLE hClientProcess,
                         TERMINAL_STARTUP_INFO startupInfo);

        ConptyConnection() noexcept = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        static winrt::fire_and_forget final_release(std::unique_ptr<ConptyConnection> connection);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close() noexcept;
        void ClearBuffer();

        void ShowHide(const bool show);

        ...",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft,12,Microsoft,1
128870,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConptyConnection : ConptyConnectionT<ConptyConnection>, ConnectionStateHolder<ConptyConnection>
    {
        ConptyConnection(const HANDLE hSig,
                         const HANDLE hIn,
                         const HANDLE hOut,
                         const HANDLE hRef,
                         const HANDLE hServerProcess,
                         const HANDLE hClientProcess,
                         TERMINAL_STARTUP_INFO startupInfo);

        ConptyConnection() noexcept = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        static winrt::fire_and_forget final_release(std::unique_ptr<ConptyConnection> connection);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close() noexcept;
        void ClearBuffer();

        void ShowHide(const bool show);

        ...",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal,12,Terminal,1
128871,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConptyConnection : ConptyConnectionT<ConptyConnection>, ConnectionStateHolder<ConptyConnection>
    {
        ConptyConnection(const HANDLE hSig,
                         const HANDLE hIn,
                         const HANDLE hOut,
                         const HANDLE hRef,
                         const HANDLE hServerProcess,
                         const HANDLE hClientProcess,
                         TERMINAL_STARTUP_INFO startupInfo);

        ConptyConnection() noexcept = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        static winrt::fire_and_forget final_release(std::unique_ptr<ConptyConnection> connection);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close() noexcept;
        void ClearBuffer();

        void ShowHide(const bool show);

        ...",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,12,TerminalConnection,1
128872,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct ConptyConnection : ConptyConnectionT<ConptyConnection>, ConnectionStateHolder<ConptyConnection>
    {
        ConptyConnection(const HANDLE hSig,
                         const HANDLE hIn,
                         const HANDLE hOut,
                         const HANDLE hRef,
                         const HANDLE hServerProcess,
                         const HANDLE hClientProcess,
                         TERMINAL_STARTUP_INFO startupInfo);

        ConptyConnection() noexcept = default;
        void Initialize(const Windows::Foundation::Collections::ValueSet& settings);

        static winrt::fire_and_forget final_release(std::unique_ptr<ConptyConnection> connection);

        void Start();
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns);
        void Close() noexcept;
        void ClearBuffer();

        void ShowHide(const bool show);

        ...",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,12,implementation,1
129134,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConptyConnection);
}",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt,114,winrt,2
129135,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConptyConnection);
}",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft,114,Microsoft,1
129136,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConptyConnection);
}",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal,114,Terminal,1
129137,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConptyConnection);
}",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,114,TerminalConnection,1
129138,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(ConptyConnection);
}",1,cascadia\TerminalConnection\ConptyConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.factory_implementation,114,factory_implementation,1
129149,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\EchoConnection.cpp,cascadia\TerminalConnection\EchoConnection.cpp:<global>,,<global>,1
129153,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    EchoConnection::EchoConnection() noexcept = default;

    void EchoConnection::Start() noexcept
    {
    }

    void EchoConnection::WriteInput(const hstring& data)
    {
        std::wstringstream prettyPrint;
        for (const auto& wch : data)
        {
            if (wch < 0x20)
            {
                prettyPrint << L""^"" << gsl::narrow_cast<wchar_t>(wch + 0x40);
            }
            else if (wch == 0x7f)
            {
                prettyPrint << L""0x7f"";
            }
            else
            {
                prettyPrint << wch;
            }
        }
        _TerminalOutputHandlers(prettyPrint.str());
    }

    void EchoConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void EchoConnection::Close() noexcept
    {
    }
}",1,cascadia\TerminalConnection\EchoConnection.cpp,winrt,10,winrt,1
129154,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    EchoConnection::EchoConnection() noexcept = default;

    void EchoConnection::Start() noexcept
    {
    }

    void EchoConnection::WriteInput(const hstring& data)
    {
        std::wstringstream prettyPrint;
        for (const auto& wch : data)
        {
            if (wch < 0x20)
            {
                prettyPrint << L""^"" << gsl::narrow_cast<wchar_t>(wch + 0x40);
            }
            else if (wch == 0x7f)
            {
                prettyPrint << L""0x7f"";
            }
            else
            {
                prettyPrint << wch;
            }
        }
        _TerminalOutputHandlers(prettyPrint.str());
    }

    void EchoConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void EchoConnection::Close() noexcept
    {
    }
}",1,cascadia\TerminalConnection\EchoConnection.cpp,winrt.Microsoft,10,Microsoft,1
129155,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    EchoConnection::EchoConnection() noexcept = default;

    void EchoConnection::Start() noexcept
    {
    }

    void EchoConnection::WriteInput(const hstring& data)
    {
        std::wstringstream prettyPrint;
        for (const auto& wch : data)
        {
            if (wch < 0x20)
            {
                prettyPrint << L""^"" << gsl::narrow_cast<wchar_t>(wch + 0x40);
            }
            else if (wch == 0x7f)
            {
                prettyPrint << L""0x7f"";
            }
            else
            {
                prettyPrint << wch;
            }
        }
        _TerminalOutputHandlers(prettyPrint.str());
    }

    void EchoConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void EchoConnection::Close() noexcept
    {
    }
}",1,cascadia\TerminalConnection\EchoConnection.cpp,winrt.Microsoft.Terminal,10,Terminal,1
129156,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    EchoConnection::EchoConnection() noexcept = default;

    void EchoConnection::Start() noexcept
    {
    }

    void EchoConnection::WriteInput(const hstring& data)
    {
        std::wstringstream prettyPrint;
        for (const auto& wch : data)
        {
            if (wch < 0x20)
            {
                prettyPrint << L""^"" << gsl::narrow_cast<wchar_t>(wch + 0x40);
            }
            else if (wch == 0x7f)
            {
                prettyPrint << L""0x7f"";
            }
            else
            {
                prettyPrint << wch;
            }
        }
        _TerminalOutputHandlers(prettyPrint.str());
    }

    void EchoConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void EchoConnection::Close() noexcept
    {
    }
}",1,cascadia\TerminalConnection\EchoConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection,10,TerminalConnection,1
129157,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    EchoConnection::EchoConnection() noexcept = default;

    void EchoConnection::Start() noexcept
    {
    }

    void EchoConnection::WriteInput(const hstring& data)
    {
        std::wstringstream prettyPrint;
        for (const auto& wch : data)
        {
            if (wch < 0x20)
            {
                prettyPrint << L""^"" << gsl::narrow_cast<wchar_t>(wch + 0x40);
            }
            else if (wch == 0x7f)
            {
                prettyPrint << L""0x7f"";
            }
            else
            {
                prettyPrint << wch;
            }
        }
        _TerminalOutputHandlers(prettyPrint.str());
    }

    void EchoConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void EchoConnection::Close() noexcept
    {
    }
}",1,cascadia\TerminalConnection\EchoConnection.cpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,10,implementation,1
129225,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\EchoConnection.hpp,cascadia\TerminalConnection\EchoConnection.hpp:<global>,,<global>,1
129229,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct EchoConnection : EchoConnectionT<EchoConnection>
    {
        EchoConnection() noexcept;

        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) const noexcept {};

        ConnectionState State() const noexcept { return ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);
        TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);
    };
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt,8,winrt,1
129230,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct EchoConnection : EchoConnectionT<EchoConnection>
    {
        EchoConnection() noexcept;

        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) const noexcept {};

        ConnectionState State() const noexcept { return ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);
        TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);
    };
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft,8,Microsoft,1
129231,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct EchoConnection : EchoConnectionT<EchoConnection>
    {
        EchoConnection() noexcept;

        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) const noexcept {};

        ConnectionState State() const noexcept { return ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);
        TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);
    };
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal,8,Terminal,1
129232,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct EchoConnection : EchoConnectionT<EchoConnection>
    {
        EchoConnection() noexcept;

        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) const noexcept {};

        ConnectionState State() const noexcept { return ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);
        TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);
    };
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,8,TerminalConnection,1
129233,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::implementation
{
    struct EchoConnection : EchoConnectionT<EchoConnection>
    {
        EchoConnection() noexcept;

        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) const noexcept {};

        ConnectionState State() const noexcept { return ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);
        TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);
    };
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.implementation,8,implementation,1
129273,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(EchoConnection);
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt,28,winrt,2
129274,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(EchoConnection);
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft,28,Microsoft,1
129275,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(EchoConnection);
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal,28,Terminal,1
129276,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(EchoConnection);
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection,28,TerminalConnection,1
129277,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::TerminalConnection::factory_implementation
{
    BASIC_FACTORY(EchoConnection);
}",1,cascadia\TerminalConnection\EchoConnection.hpp,winrt.Microsoft.Terminal.TerminalConnection.factory_implementation,28,factory_implementation,1
129286,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\init.cpp,cascadia\TerminalConnection\init.cpp:<global>,,<global>,1
129334,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\pch.cpp,cascadia\TerminalConnection\pch.cpp:<global>,,<global>,1
129371,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalConnection\pch.hpp,cascadia\TerminalConnection\pch.hpp:<global>,,<global>,1
129385,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlAppearance.hpp,cascadia\TerminalControl\ControlAppearance.hpp:<global>,,<global>,1
129389,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlAppearance : public winrt::implements<ControlAppearance, Microsoft::Terminal::Core::ICoreAppearance, Microsoft::Terminal::Control::IControlAppearance>
    {
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color color) noexcept
        {
            _ColorTable.at(index) = color;
        }

        ControlAppearance(Control::I...",1,cascadia\TerminalControl\ControlAppearance.hpp,winrt,12,winrt,1
129390,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlAppearance : public winrt::implements<ControlAppearance, Microsoft::Terminal::Core::ICoreAppearance, Microsoft::Terminal::Control::IControlAppearance>
    {
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color color) noexcept
        {
            _ColorTable.at(index) = color;
        }

        ControlAppearance(Control::I...",1,cascadia\TerminalControl\ControlAppearance.hpp,winrt.Microsoft,12,Microsoft,1
129391,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlAppearance : public winrt::implements<ControlAppearance, Microsoft::Terminal::Core::ICoreAppearance, Microsoft::Terminal::Control::IControlAppearance>
    {
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color color) noexcept
        {
            _ColorTable.at(index) = color;
        }

        ControlAppearance(Control::I...",1,cascadia\TerminalControl\ControlAppearance.hpp,winrt.Microsoft.Terminal,12,Terminal,1
129392,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlAppearance : public winrt::implements<ControlAppearance, Microsoft::Terminal::Core::ICoreAppearance, Microsoft::Terminal::Control::IControlAppearance>
    {
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color color) noexcept
        {
            _ColorTable.at(index) = color;
        }

        ControlAppearance(Control::I...",1,cascadia\TerminalControl\ControlAppearance.hpp,winrt.Microsoft.Terminal.Control,12,Control,1
129393,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlAppearance : public winrt::implements<ControlAppearance, Microsoft::Terminal::Core::ICoreAppearance, Microsoft::Terminal::Control::IControlAppearance>
    {
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color color) noexcept
        {
            _ColorTable.at(index) = color;
        }

        ControlAppearance(Control::I...",1,cascadia\TerminalControl\ControlAppearance.hpp,winrt.Microsoft.Terminal.Control.implementation,12,implementation,1
130238,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlCore.cpp,cascadia\TerminalControl\ControlCore.cpp:<global>,,<global>,1
130281,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const til::color& c)
    {
        Core::OptionalColor result;
        result.Color = c;
        result.HasValue = true;
        return result;
    }
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const std::optional<til::color>& c)
    {
        Core::OptionalColor result;
        if (c.has_value())
        {
            result.Color = *c;
            result.HasValue = true;
        }
        else
        {
            result.HasValue = false;
        }
        return result;
    }

    TextColor SelectionColor::AsTextColor() const noexcept
    {
        if (IsIndex16())
        {
            return { Color().r, false };
        }
        else
        {
            return { static_cast<COLORREF>(Color()) };
        }
    }

    ControlCore::ControlCore(Control::IControlSettings settings,
                          ...",1,cascadia\TerminalControl\ControlCore.cpp,winrt,45,winrt,9
130282,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const til::color& c)
    {
        Core::OptionalColor result;
        result.Color = c;
        result.HasValue = true;
        return result;
    }
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const std::optional<til::color>& c)
    {
        Core::OptionalColor result;
        if (c.has_value())
        {
            result.Color = *c;
            result.HasValue = true;
        }
        else
        {
            result.HasValue = false;
        }
        return result;
    }

    TextColor SelectionColor::AsTextColor() const noexcept
    {
        if (IsIndex16())
        {
            return { Color().r, false };
        }
        else
        {
            return { static_cast<COLORREF>(Color()) };
        }
    }

    ControlCore::ControlCore(Control::IControlSettings settings,
                          ...",1,cascadia\TerminalControl\ControlCore.cpp,winrt.Microsoft,45,Microsoft,1
130283,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const til::color& c)
    {
        Core::OptionalColor result;
        result.Color = c;
        result.HasValue = true;
        return result;
    }
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const std::optional<til::color>& c)
    {
        Core::OptionalColor result;
        if (c.has_value())
        {
            result.Color = *c;
            result.HasValue = true;
        }
        else
        {
            result.HasValue = false;
        }
        return result;
    }

    TextColor SelectionColor::AsTextColor() const noexcept
    {
        if (IsIndex16())
        {
            return { Color().r, false };
        }
        else
        {
            return { static_cast<COLORREF>(Color()) };
        }
    }

    ControlCore::ControlCore(Control::IControlSettings settings,
                          ...",1,cascadia\TerminalControl\ControlCore.cpp,winrt.Microsoft.Terminal,45,Terminal,1
130284,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const til::color& c)
    {
        Core::OptionalColor result;
        result.Color = c;
        result.HasValue = true;
        return result;
    }
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const std::optional<til::color>& c)
    {
        Core::OptionalColor result;
        if (c.has_value())
        {
            result.Color = *c;
            result.HasValue = true;
        }
        else
        {
            result.HasValue = false;
        }
        return result;
    }

    TextColor SelectionColor::AsTextColor() const noexcept
    {
        if (IsIndex16())
        {
            return { Color().r, false };
        }
        else
        {
            return { static_cast<COLORREF>(Color()) };
        }
    }

    ControlCore::ControlCore(Control::IControlSettings settings,
                          ...",1,cascadia\TerminalControl\ControlCore.cpp,winrt.Microsoft.Terminal.Control,45,Control,1
130285,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const til::color& c)
    {
        Core::OptionalColor result;
        result.Color = c;
        result.HasValue = true;
        return result;
    }
    static winrt::Microsoft::Terminal::Core::OptionalColor OptionalFromColor(const std::optional<til::color>& c)
    {
        Core::OptionalColor result;
        if (c.has_value())
        {
            result.Color = *c;
            result.HasValue = true;
        }
        else
        {
            result.HasValue = false;
        }
        return result;
    }

    TextColor SelectionColor::AsTextColor() const noexcept
    {
        if (IsIndex16())
        {
            return { Color().r, false };
        }
        else
        {
            return { static_cast<COLORREF>(Color()) };
        }
    }

    ControlCore::ControlCore(Control::IControlSettings settings,
                          ...",1,cascadia\TerminalControl\ControlCore.cpp,winrt.Microsoft.Terminal.Control.implementation,45,implementation,1
137092,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlCore.hpp,cascadia\TerminalControl\ControlCore.hpp:<global>,,<global>,1
137096,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class ControlCoreTests;
    class ControlInteractivityTests;
}",1,cascadia\TerminalControl\ControlCore.hpp,ControlUnitTests,28,ControlUnitTests,1
137099,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SelectionColor : SelectionColorT<SelectionColor>
    {
        TextColor AsTextColor() const noexcept;

        til::property<til::color> Color;
        til::property<bool> IsIndex16;
    };
    struct CommandHistoryContext : CommandHistoryContextT<CommandHistoryContext>
    {
        til::property<Windows::Foundation::Collections::IVector<winrt::hstring>> History;
        til::property<winrt::hstring> CurrentCommandline;

        CommandHistoryContext(std::vector<winrt::hstring>&& history)
        {
            History(winrt::single_threaded_vector<winrt::hstring>(std::move(history)));
        }
    };

    struct ControlCore : ControlCoreT<ControlCore>
    {
    public:
        ControlCore(Control::IControlSettings settings,
                    Control::IControlAppearance unfocusedAppearance,
                    TerminalConnection::ITerminalConnection connection);
        ~ControlCore();

        bool Initi...",1,cascadia\TerminalControl\ControlCore.hpp,winrt,48,winrt,2
137100,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SelectionColor : SelectionColorT<SelectionColor>
    {
        TextColor AsTextColor() const noexcept;

        til::property<til::color> Color;
        til::property<bool> IsIndex16;
    };
    struct CommandHistoryContext : CommandHistoryContextT<CommandHistoryContext>
    {
        til::property<Windows::Foundation::Collections::IVector<winrt::hstring>> History;
        til::property<winrt::hstring> CurrentCommandline;

        CommandHistoryContext(std::vector<winrt::hstring>&& history)
        {
            History(winrt::single_threaded_vector<winrt::hstring>(std::move(history)));
        }
    };

    struct ControlCore : ControlCoreT<ControlCore>
    {
    public:
        ControlCore(Control::IControlSettings settings,
                    Control::IControlAppearance unfocusedAppearance,
                    TerminalConnection::ITerminalConnection connection);
        ~ControlCore();

        bool Initi...",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft,48,Microsoft,1
137101,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SelectionColor : SelectionColorT<SelectionColor>
    {
        TextColor AsTextColor() const noexcept;

        til::property<til::color> Color;
        til::property<bool> IsIndex16;
    };
    struct CommandHistoryContext : CommandHistoryContextT<CommandHistoryContext>
    {
        til::property<Windows::Foundation::Collections::IVector<winrt::hstring>> History;
        til::property<winrt::hstring> CurrentCommandline;

        CommandHistoryContext(std::vector<winrt::hstring>&& history)
        {
            History(winrt::single_threaded_vector<winrt::hstring>(std::move(history)));
        }
    };

    struct ControlCore : ControlCoreT<ControlCore>
    {
    public:
        ControlCore(Control::IControlSettings settings,
                    Control::IControlAppearance unfocusedAppearance,
                    TerminalConnection::ITerminalConnection connection);
        ~ControlCore();

        bool Initi...",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal,48,Terminal,1
137102,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SelectionColor : SelectionColorT<SelectionColor>
    {
        TextColor AsTextColor() const noexcept;

        til::property<til::color> Color;
        til::property<bool> IsIndex16;
    };
    struct CommandHistoryContext : CommandHistoryContextT<CommandHistoryContext>
    {
        til::property<Windows::Foundation::Collections::IVector<winrt::hstring>> History;
        til::property<winrt::hstring> CurrentCommandline;

        CommandHistoryContext(std::vector<winrt::hstring>&& history)
        {
            History(winrt::single_threaded_vector<winrt::hstring>(std::move(history)));
        }
    };

    struct ControlCore : ControlCoreT<ControlCore>
    {
    public:
        ControlCore(Control::IControlSettings settings,
                    Control::IControlAppearance unfocusedAppearance,
                    TerminalConnection::ITerminalConnection connection);
        ~ControlCore();

        bool Initi...",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal.Control,48,Control,1
137103,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SelectionColor : SelectionColorT<SelectionColor>
    {
        TextColor AsTextColor() const noexcept;

        til::property<til::color> Color;
        til::property<bool> IsIndex16;
    };
    struct CommandHistoryContext : CommandHistoryContextT<CommandHistoryContext>
    {
        til::property<Windows::Foundation::Collections::IVector<winrt::hstring>> History;
        til::property<winrt::hstring> CurrentCommandline;

        CommandHistoryContext(std::vector<winrt::hstring>&& history)
        {
            History(winrt::single_threaded_vector<winrt::hstring>(std::move(history)));
        }
    };

    struct ControlCore : ControlCoreT<ControlCore>
    {
    public:
        ControlCore(Control::IControlSettings settings,
                    Control::IControlAppearance unfocusedAppearance,
                    TerminalConnection::ITerminalConnection connection);
        ~ControlCore();

        bool Initi...",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal.Control.implementation,48,implementation,1
138598,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlCore);
    BASIC_FACTORY(SelectionColor);
}",1,cascadia\TerminalControl\ControlCore.hpp,winrt,425,winrt,3
138599,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlCore);
    BASIC_FACTORY(SelectionColor);
}",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft,425,Microsoft,1
138600,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlCore);
    BASIC_FACTORY(SelectionColor);
}",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal,425,Terminal,1
138601,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlCore);
    BASIC_FACTORY(SelectionColor);
}",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal.Control,425,Control,1
138602,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlCore);
    BASIC_FACTORY(SelectionColor);
}",1,cascadia\TerminalControl\ControlCore.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,425,factory_implementation,1
138667,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlInteractivity.cpp,cascadia\TerminalControl\ControlInteractivity.cpp:<global>,,<global>,1
138674,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    std::atomic<uint64_t> ControlInteractivity::_nextId{ 1 };

    static constexpr TerminalInput::MouseButtonState toInternalMouseState(const Control::MouseButtonState& state)
    {
        return TerminalInput::MouseButtonState{
            WI_IsFlagSet(state, MouseButtonState::IsLeftButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsMiddleButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsRightButtonDown)
        };
    }

    ControlInteractivity::ControlInteractivity(IControlSettings settings,
                                               Control::IControlAppearance unfocusedAppearance,
                                               TerminalConnection::ITerminalConnection connection) :
        _touchAnchor{ std::nullopt },
        _lastMouseClickTimestamp{},
        _lastMouseClickPos{},
        _selectionNeedsToBeCopied{ false }
    {
        _id = _nextId.fetch_add(1, std::memory_orde...",1,cascadia\TerminalControl\ControlInteractivity.cpp,winrt,28,winrt,3
138675,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    std::atomic<uint64_t> ControlInteractivity::_nextId{ 1 };

    static constexpr TerminalInput::MouseButtonState toInternalMouseState(const Control::MouseButtonState& state)
    {
        return TerminalInput::MouseButtonState{
            WI_IsFlagSet(state, MouseButtonState::IsLeftButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsMiddleButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsRightButtonDown)
        };
    }

    ControlInteractivity::ControlInteractivity(IControlSettings settings,
                                               Control::IControlAppearance unfocusedAppearance,
                                               TerminalConnection::ITerminalConnection connection) :
        _touchAnchor{ std::nullopt },
        _lastMouseClickTimestamp{},
        _lastMouseClickPos{},
        _selectionNeedsToBeCopied{ false }
    {
        _id = _nextId.fetch_add(1, std::memory_orde...",1,cascadia\TerminalControl\ControlInteractivity.cpp,winrt.Microsoft,28,Microsoft,1
138676,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    std::atomic<uint64_t> ControlInteractivity::_nextId{ 1 };

    static constexpr TerminalInput::MouseButtonState toInternalMouseState(const Control::MouseButtonState& state)
    {
        return TerminalInput::MouseButtonState{
            WI_IsFlagSet(state, MouseButtonState::IsLeftButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsMiddleButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsRightButtonDown)
        };
    }

    ControlInteractivity::ControlInteractivity(IControlSettings settings,
                                               Control::IControlAppearance unfocusedAppearance,
                                               TerminalConnection::ITerminalConnection connection) :
        _touchAnchor{ std::nullopt },
        _lastMouseClickTimestamp{},
        _lastMouseClickPos{},
        _selectionNeedsToBeCopied{ false }
    {
        _id = _nextId.fetch_add(1, std::memory_orde...",1,cascadia\TerminalControl\ControlInteractivity.cpp,winrt.Microsoft.Terminal,28,Terminal,1
138677,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    std::atomic<uint64_t> ControlInteractivity::_nextId{ 1 };

    static constexpr TerminalInput::MouseButtonState toInternalMouseState(const Control::MouseButtonState& state)
    {
        return TerminalInput::MouseButtonState{
            WI_IsFlagSet(state, MouseButtonState::IsLeftButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsMiddleButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsRightButtonDown)
        };
    }

    ControlInteractivity::ControlInteractivity(IControlSettings settings,
                                               Control::IControlAppearance unfocusedAppearance,
                                               TerminalConnection::ITerminalConnection connection) :
        _touchAnchor{ std::nullopt },
        _lastMouseClickTimestamp{},
        _lastMouseClickPos{},
        _selectionNeedsToBeCopied{ false }
    {
        _id = _nextId.fetch_add(1, std::memory_orde...",1,cascadia\TerminalControl\ControlInteractivity.cpp,winrt.Microsoft.Terminal.Control,28,Control,1
138678,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    std::atomic<uint64_t> ControlInteractivity::_nextId{ 1 };

    static constexpr TerminalInput::MouseButtonState toInternalMouseState(const Control::MouseButtonState& state)
    {
        return TerminalInput::MouseButtonState{
            WI_IsFlagSet(state, MouseButtonState::IsLeftButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsMiddleButtonDown),
            WI_IsFlagSet(state, MouseButtonState::IsRightButtonDown)
        };
    }

    ControlInteractivity::ControlInteractivity(IControlSettings settings,
                                               Control::IControlAppearance unfocusedAppearance,
                                               TerminalConnection::ITerminalConnection connection) :
        _touchAnchor{ std::nullopt },
        _lastMouseClickTimestamp{},
        _lastMouseClickPos{},
        _selectionNeedsToBeCopied{ false }
    {
        _id = _nextId.fetch_add(1, std::memory_orde...",1,cascadia\TerminalControl\ControlInteractivity.cpp,winrt.Microsoft.Terminal.Control.implementation,28,implementation,1
139984,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlInteractivity.hpp,cascadia\TerminalControl\ControlInteractivity.hpp:<global>,,<global>,1
139988,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class ControlCoreTests;
    class ControlInteractivityTests;
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,ControlUnitTests,26,ControlUnitTests,1
139991,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlInteractivity : ControlInteractivityT<ControlInteractivity>
    {
    public:
        ControlInteractivity(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection);

        void GotFocus();
        void LostFocus();
        void UpdateSettings();
        void Initialize();
        Control::ControlCore Core();

        void Close();
        void Detach();

        Control::InteractivityAutomationPeer OnCreateAutomationPeer();
        ::Microsoft::Console::Render::IRenderData* GetRenderData() const;

#pragma region Input Methods
        void PointerPressed(Control::MouseButtonState buttonState,
                            const unsigned int pointerUpdateKind,
                            const uint64_t timestamp,
                            const ::Microsoft::Terminal::Core::Co...",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt,32,winrt,2
139992,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlInteractivity : ControlInteractivityT<ControlInteractivity>
    {
    public:
        ControlInteractivity(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection);

        void GotFocus();
        void LostFocus();
        void UpdateSettings();
        void Initialize();
        Control::ControlCore Core();

        void Close();
        void Detach();

        Control::InteractivityAutomationPeer OnCreateAutomationPeer();
        ::Microsoft::Console::Render::IRenderData* GetRenderData() const;

#pragma region Input Methods
        void PointerPressed(Control::MouseButtonState buttonState,
                            const unsigned int pointerUpdateKind,
                            const uint64_t timestamp,
                            const ::Microsoft::Terminal::Core::Co...",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft,32,Microsoft,1
139993,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlInteractivity : ControlInteractivityT<ControlInteractivity>
    {
    public:
        ControlInteractivity(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection);

        void GotFocus();
        void LostFocus();
        void UpdateSettings();
        void Initialize();
        Control::ControlCore Core();

        void Close();
        void Detach();

        Control::InteractivityAutomationPeer OnCreateAutomationPeer();
        ::Microsoft::Console::Render::IRenderData* GetRenderData() const;

#pragma region Input Methods
        void PointerPressed(Control::MouseButtonState buttonState,
                            const unsigned int pointerUpdateKind,
                            const uint64_t timestamp,
                            const ::Microsoft::Terminal::Core::Co...",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal,32,Terminal,1
139994,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlInteractivity : ControlInteractivityT<ControlInteractivity>
    {
    public:
        ControlInteractivity(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection);

        void GotFocus();
        void LostFocus();
        void UpdateSettings();
        void Initialize();
        Control::ControlCore Core();

        void Close();
        void Detach();

        Control::InteractivityAutomationPeer OnCreateAutomationPeer();
        ::Microsoft::Console::Render::IRenderData* GetRenderData() const;

#pragma region Input Methods
        void PointerPressed(Control::MouseButtonState buttonState,
                            const unsigned int pointerUpdateKind,
                            const uint64_t timestamp,
                            const ::Microsoft::Terminal::Core::Co...",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal.Control,32,Control,1
139995,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlInteractivity : ControlInteractivityT<ControlInteractivity>
    {
    public:
        ControlInteractivity(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection);

        void GotFocus();
        void LostFocus();
        void UpdateSettings();
        void Initialize();
        Control::ControlCore Core();

        void Close();
        void Detach();

        Control::InteractivityAutomationPeer OnCreateAutomationPeer();
        ::Microsoft::Console::Render::IRenderData* GetRenderData() const;

#pragma region Input Methods
        void PointerPressed(Control::MouseButtonState buttonState,
                            const unsigned int pointerUpdateKind,
                            const uint64_t timestamp,
                            const ::Microsoft::Terminal::Core::Co...",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal.Control.implementation,32,implementation,1
140360,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlInteractivity);
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt,171,winrt,3
140361,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlInteractivity);
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft,171,Microsoft,1
140362,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlInteractivity);
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal,171,Terminal,1
140363,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlInteractivity);
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal.Control,171,Control,1
140364,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(ControlInteractivity);
}",1,cascadia\TerminalControl\ControlInteractivity.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,171,factory_implementation,1
140377,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ControlSettings.hpp,cascadia\TerminalControl\ControlSettings.hpp:<global>,,<global>,1
140383,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlSettings : public winrt::implements<ControlSettings, Microsoft::Terminal::Control::IControlSettings, Microsoft::Terminal::Control::IControlAppearance, Microsoft::Terminal::Core::ICoreSettings, Microsoft::Terminal::Core::ICoreAppearance>
    {
        // Getters and setters for each *Setting member. We're not using
        // WINRT_PROPERTY for these, because they actually exist inside the
        // _focusedAppearance member. We don't need to reserve another member to
        // hold them.
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        winrt::com_ptr<ControlAppearance> _unfocusedAppearance{ nullptr };
        winrt::com_ptr<ControlAppearance> _focusedAppearance{ nullptr };
        bool _hasUnfocusedAppearance{ false };

    public:
        ControlSettings(...",1,cascadia\TerminalControl\ControlSettings.hpp,winrt,16,winrt,3
140384,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlSettings : public winrt::implements<ControlSettings, Microsoft::Terminal::Control::IControlSettings, Microsoft::Terminal::Control::IControlAppearance, Microsoft::Terminal::Core::ICoreSettings, Microsoft::Terminal::Core::ICoreAppearance>
    {
        // Getters and setters for each *Setting member. We're not using
        // WINRT_PROPERTY for these, because they actually exist inside the
        // _focusedAppearance member. We don't need to reserve another member to
        // hold them.
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        winrt::com_ptr<ControlAppearance> _unfocusedAppearance{ nullptr };
        winrt::com_ptr<ControlAppearance> _focusedAppearance{ nullptr };
        bool _hasUnfocusedAppearance{ false };

    public:
        ControlSettings(...",1,cascadia\TerminalControl\ControlSettings.hpp,winrt.Microsoft,16,Microsoft,1
140385,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlSettings : public winrt::implements<ControlSettings, Microsoft::Terminal::Control::IControlSettings, Microsoft::Terminal::Control::IControlAppearance, Microsoft::Terminal::Core::ICoreSettings, Microsoft::Terminal::Core::ICoreAppearance>
    {
        // Getters and setters for each *Setting member. We're not using
        // WINRT_PROPERTY for these, because they actually exist inside the
        // _focusedAppearance member. We don't need to reserve another member to
        // hold them.
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        winrt::com_ptr<ControlAppearance> _unfocusedAppearance{ nullptr };
        winrt::com_ptr<ControlAppearance> _focusedAppearance{ nullptr };
        bool _hasUnfocusedAppearance{ false };

    public:
        ControlSettings(...",1,cascadia\TerminalControl\ControlSettings.hpp,winrt.Microsoft.Terminal,16,Terminal,1
140386,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlSettings : public winrt::implements<ControlSettings, Microsoft::Terminal::Control::IControlSettings, Microsoft::Terminal::Control::IControlAppearance, Microsoft::Terminal::Core::ICoreSettings, Microsoft::Terminal::Core::ICoreAppearance>
    {
        // Getters and setters for each *Setting member. We're not using
        // WINRT_PROPERTY for these, because they actually exist inside the
        // _focusedAppearance member. We don't need to reserve another member to
        // hold them.
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        winrt::com_ptr<ControlAppearance> _unfocusedAppearance{ nullptr };
        winrt::com_ptr<ControlAppearance> _focusedAppearance{ nullptr };
        bool _hasUnfocusedAppearance{ false };

    public:
        ControlSettings(...",1,cascadia\TerminalControl\ControlSettings.hpp,winrt.Microsoft.Terminal.Control,16,Control,1
140387,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ControlSettings : public winrt::implements<ControlSettings, Microsoft::Terminal::Control::IControlSettings, Microsoft::Terminal::Control::IControlAppearance, Microsoft::Terminal::Core::ICoreSettings, Microsoft::Terminal::Core::ICoreAppearance>
    {
        // Getters and setters for each *Setting member. We're not using
        // WINRT_PROPERTY for these, because they actually exist inside the
        // _focusedAppearance member. We don't need to reserve another member to
        // hold them.
#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    private:
        winrt::com_ptr<ControlAppearance> _unfocusedAppearance{ nullptr };
        winrt::com_ptr<ControlAppearance> _focusedAppearance{ nullptr };
        bool _hasUnfocusedAppearance{ false };

    public:
        ControlSettings(...",1,cascadia\TerminalControl\ControlSettings.hpp,winrt.Microsoft.Terminal.Control.implementation,16,implementation,1
141868,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\EventArgs.cpp,cascadia\TerminalControl\EventArgs.cpp:<global>,,<global>,1
141907,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\EventArgs.hpp,cascadia\TerminalControl\EventArgs.hpp:<global>,,<global>,1
141911,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{

    struct FontSizeChangedArgs : public FontSizeChangedArgsT<FontSizeChangedArgs>
    {
    public:
        FontSizeChangedArgs(int32_t width,
                            int32_t height) :
            Width(width),
            Height(height)
        {
        }

        til::property<int32_t> Width;
        til::property<int32_t> Height;
    };

    struct TitleChangedEventArgs : public TitleChangedEventArgsT<TitleChangedEventArgs>
    {
    public:
        TitleChangedEventArgs(hstring title) :
            _Title(title) {}

        WINRT_PROPERTY(hstring, Title);
    };

    struct CopyToClipboardEventArgs : public CopyToClipboardEventArgsT<CopyToClipboardEventArgs>
    {
    public:
        CopyToClipboardEventArgs(hstring text) :
            _text(text),
            _html(),
            _rtf(),
            _formats(static_cast<CopyFormat>(0)) {}

        CopyToClipboardEventArgs(hstring text, hstring html, hstring r...",1,cascadia\TerminalControl\EventArgs.hpp,winrt,24,winrt,1
141912,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{

    struct FontSizeChangedArgs : public FontSizeChangedArgsT<FontSizeChangedArgs>
    {
    public:
        FontSizeChangedArgs(int32_t width,
                            int32_t height) :
            Width(width),
            Height(height)
        {
        }

        til::property<int32_t> Width;
        til::property<int32_t> Height;
    };

    struct TitleChangedEventArgs : public TitleChangedEventArgsT<TitleChangedEventArgs>
    {
    public:
        TitleChangedEventArgs(hstring title) :
            _Title(title) {}

        WINRT_PROPERTY(hstring, Title);
    };

    struct CopyToClipboardEventArgs : public CopyToClipboardEventArgsT<CopyToClipboardEventArgs>
    {
    public:
        CopyToClipboardEventArgs(hstring text) :
            _text(text),
            _html(),
            _rtf(),
            _formats(static_cast<CopyFormat>(0)) {}

        CopyToClipboardEventArgs(hstring text, hstring html, hstring r...",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft,24,Microsoft,1
141913,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{

    struct FontSizeChangedArgs : public FontSizeChangedArgsT<FontSizeChangedArgs>
    {
    public:
        FontSizeChangedArgs(int32_t width,
                            int32_t height) :
            Width(width),
            Height(height)
        {
        }

        til::property<int32_t> Width;
        til::property<int32_t> Height;
    };

    struct TitleChangedEventArgs : public TitleChangedEventArgsT<TitleChangedEventArgs>
    {
    public:
        TitleChangedEventArgs(hstring title) :
            _Title(title) {}

        WINRT_PROPERTY(hstring, Title);
    };

    struct CopyToClipboardEventArgs : public CopyToClipboardEventArgsT<CopyToClipboardEventArgs>
    {
    public:
        CopyToClipboardEventArgs(hstring text) :
            _text(text),
            _html(),
            _rtf(),
            _formats(static_cast<CopyFormat>(0)) {}

        CopyToClipboardEventArgs(hstring text, hstring html, hstring r...",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal,24,Terminal,1
141914,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{

    struct FontSizeChangedArgs : public FontSizeChangedArgsT<FontSizeChangedArgs>
    {
    public:
        FontSizeChangedArgs(int32_t width,
                            int32_t height) :
            Width(width),
            Height(height)
        {
        }

        til::property<int32_t> Width;
        til::property<int32_t> Height;
    };

    struct TitleChangedEventArgs : public TitleChangedEventArgsT<TitleChangedEventArgs>
    {
    public:
        TitleChangedEventArgs(hstring title) :
            _Title(title) {}

        WINRT_PROPERTY(hstring, Title);
    };

    struct CopyToClipboardEventArgs : public CopyToClipboardEventArgsT<CopyToClipboardEventArgs>
    {
    public:
        CopyToClipboardEventArgs(hstring text) :
            _text(text),
            _html(),
            _rtf(),
            _formats(static_cast<CopyFormat>(0)) {}

        CopyToClipboardEventArgs(hstring text, hstring html, hstring r...",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal.Control,24,Control,1
141915,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{

    struct FontSizeChangedArgs : public FontSizeChangedArgsT<FontSizeChangedArgs>
    {
    public:
        FontSizeChangedArgs(int32_t width,
                            int32_t height) :
            Width(width),
            Height(height)
        {
        }

        til::property<int32_t> Width;
        til::property<int32_t> Height;
    };

    struct TitleChangedEventArgs : public TitleChangedEventArgsT<TitleChangedEventArgs>
    {
    public:
        TitleChangedEventArgs(hstring title) :
            _Title(title) {}

        WINRT_PROPERTY(hstring, Title);
    };

    struct CopyToClipboardEventArgs : public CopyToClipboardEventArgsT<CopyToClipboardEventArgs>
    {
    public:
        CopyToClipboardEventArgs(hstring text) :
            _text(text),
            _html(),
            _rtf(),
            _formats(static_cast<CopyFormat>(0)) {}

        CopyToClipboardEventArgs(hstring text, hstring html, hstring r...",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal.Control.implementation,24,implementation,1
142119,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(OpenHyperlinkEventArgs);
}",1,cascadia\TerminalControl\EventArgs.hpp,winrt,256,winrt,2
142120,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(OpenHyperlinkEventArgs);
}",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft,256,Microsoft,1
142121,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(OpenHyperlinkEventArgs);
}",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal,256,Terminal,1
142122,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(OpenHyperlinkEventArgs);
}",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal.Control,256,Control,1
142123,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(OpenHyperlinkEventArgs);
}",1,cascadia\TerminalControl\EventArgs.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,256,factory_implementation,1
142147,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\HwndTerminal.cpp,cascadia\TerminalControl\HwndTerminal.cpp:<global>,,<global>,1
143339,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\HwndTerminal.hpp,cascadia\TerminalControl\HwndTerminal.hpp:<global>,,<global>,1
143618,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\HwndTerminalAutomationPeer.cpp,cascadia\TerminalControl\HwndTerminalAutomationPeer.cpp:<global>,,<global>,1
143876,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\HwndTerminalAutomationPeer.hpp,cascadia\TerminalControl\HwndTerminalAutomationPeer.hpp:<global>,,<global>,1
143934,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,cascadia\TerminalControl\InteractivityAutomationPeer.cpp:<global>,,<global>,1
143938,NAMESPACE_BLOCK,"namespace UIA
{
    using ::ITextRangeProvider;
    using ::SupportedTextSelection;
}",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,UIA,17,UIA,1
143939,NAMESPACE_BLOCK,"namespace XamlAutomation
{
    using winrt::Windows::UI::Xaml::Automation::SupportedTextSelection;
    using winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple;
    using winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider;
}",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,XamlAutomation,23,XamlAutomation,2
143940,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    InteractivityAutomationPeer::InteractivityAutomationPeer(Control::implementation::ControlInteractivity* owner) :
        _interactivity{ owner }
    {
        THROW_IF_FAILED(::Microsoft::WRL::MakeAndInitialize<::Microsoft::Terminal::TermControlUiaProvider>(&_uiaProvider, _interactivity->GetRenderData(), this));
    };

    void InteractivityAutomationPeer::SetControlBounds(const Windows::Foundation::Rect bounds)
    {
        _controlBounds = til::rect{ til::math::rounding, bounds };
    }
    void InteractivityAutomationPeer::SetControlPadding(const Core::Padding padding)
    {
        _controlPadding = til::rect{ til::math::rounding, padding };
    }
    void InteractivityAutomationPeer::ParentProvider(AutomationPeer parentProvider)
    {
        _parentProvider = parentProvider;
    }

    // Method Description:
    // - Signals the ui automation client that the terminal's selection has
    //   changed and shou...",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,winrt,30,winrt,3
143941,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    InteractivityAutomationPeer::InteractivityAutomationPeer(Control::implementation::ControlInteractivity* owner) :
        _interactivity{ owner }
    {
        THROW_IF_FAILED(::Microsoft::WRL::MakeAndInitialize<::Microsoft::Terminal::TermControlUiaProvider>(&_uiaProvider, _interactivity->GetRenderData(), this));
    };

    void InteractivityAutomationPeer::SetControlBounds(const Windows::Foundation::Rect bounds)
    {
        _controlBounds = til::rect{ til::math::rounding, bounds };
    }
    void InteractivityAutomationPeer::SetControlPadding(const Core::Padding padding)
    {
        _controlPadding = til::rect{ til::math::rounding, padding };
    }
    void InteractivityAutomationPeer::ParentProvider(AutomationPeer parentProvider)
    {
        _parentProvider = parentProvider;
    }

    // Method Description:
    // - Signals the ui automation client that the terminal's selection has
    //   changed and shou...",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,winrt.Microsoft,30,Microsoft,1
143942,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    InteractivityAutomationPeer::InteractivityAutomationPeer(Control::implementation::ControlInteractivity* owner) :
        _interactivity{ owner }
    {
        THROW_IF_FAILED(::Microsoft::WRL::MakeAndInitialize<::Microsoft::Terminal::TermControlUiaProvider>(&_uiaProvider, _interactivity->GetRenderData(), this));
    };

    void InteractivityAutomationPeer::SetControlBounds(const Windows::Foundation::Rect bounds)
    {
        _controlBounds = til::rect{ til::math::rounding, bounds };
    }
    void InteractivityAutomationPeer::SetControlPadding(const Core::Padding padding)
    {
        _controlPadding = til::rect{ til::math::rounding, padding };
    }
    void InteractivityAutomationPeer::ParentProvider(AutomationPeer parentProvider)
    {
        _parentProvider = parentProvider;
    }

    // Method Description:
    // - Signals the ui automation client that the terminal's selection has
    //   changed and shou...",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,winrt.Microsoft.Terminal,30,Terminal,1
143943,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    InteractivityAutomationPeer::InteractivityAutomationPeer(Control::implementation::ControlInteractivity* owner) :
        _interactivity{ owner }
    {
        THROW_IF_FAILED(::Microsoft::WRL::MakeAndInitialize<::Microsoft::Terminal::TermControlUiaProvider>(&_uiaProvider, _interactivity->GetRenderData(), this));
    };

    void InteractivityAutomationPeer::SetControlBounds(const Windows::Foundation::Rect bounds)
    {
        _controlBounds = til::rect{ til::math::rounding, bounds };
    }
    void InteractivityAutomationPeer::SetControlPadding(const Core::Padding padding)
    {
        _controlPadding = til::rect{ til::math::rounding, padding };
    }
    void InteractivityAutomationPeer::ParentProvider(AutomationPeer parentProvider)
    {
        _parentProvider = parentProvider;
    }

    // Method Description:
    // - Signals the ui automation client that the terminal's selection has
    //   changed and shou...",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,winrt.Microsoft.Terminal.Control,30,Control,1
143944,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    InteractivityAutomationPeer::InteractivityAutomationPeer(Control::implementation::ControlInteractivity* owner) :
        _interactivity{ owner }
    {
        THROW_IF_FAILED(::Microsoft::WRL::MakeAndInitialize<::Microsoft::Terminal::TermControlUiaProvider>(&_uiaProvider, _interactivity->GetRenderData(), this));
    };

    void InteractivityAutomationPeer::SetControlBounds(const Windows::Foundation::Rect bounds)
    {
        _controlBounds = til::rect{ til::math::rounding, bounds };
    }
    void InteractivityAutomationPeer::SetControlPadding(const Core::Padding padding)
    {
        _controlPadding = til::rect{ til::math::rounding, padding };
    }
    void InteractivityAutomationPeer::ParentProvider(AutomationPeer parentProvider)
    {
        _parentProvider = parentProvider;
    }

    // Method Description:
    // - Signals the ui automation client that the terminal's selection has
    //   changed and shou...",1,cascadia\TerminalControl\InteractivityAutomationPeer.cpp,winrt.Microsoft.Terminal.Control.implementation,30,implementation,1
144336,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,cascadia\TerminalControl\InteractivityAutomationPeer.hpp:<global>,,<global>,1
144340,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct InteractivityAutomationPeer :
        public InteractivityAutomationPeerT<InteractivityAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher,
        ::Microsoft::Console::Types::IControlAccessibilityInfo
    {
    public:
        InteractivityAutomationPeer(Microsoft::Terminal::Control::implementation::ControlInteractivity* owner);

        void SetControlBounds(const Windows::Foundation::Rect bounds);
        void SetControlPadding(const Core::Padding padding);
        void ParentProvider(Windows::UI::Xaml::Automation::Peers::AutomationPeer parentProvider);

#pragma region IUiaEventDispatcher
        void SignalSelectionChanged() override;
        void SignalTextChanged() override;
        void SignalCursorChanged() override;
        void NotifyNewOutput(std::wstring_view newOutput) override;
#pragma endregion

#pragma region ITextProvider Pattern
        Windows::UI::Xaml::Automation::P...",1,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,winrt,34,winrt,1
144341,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct InteractivityAutomationPeer :
        public InteractivityAutomationPeerT<InteractivityAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher,
        ::Microsoft::Console::Types::IControlAccessibilityInfo
    {
    public:
        InteractivityAutomationPeer(Microsoft::Terminal::Control::implementation::ControlInteractivity* owner);

        void SetControlBounds(const Windows::Foundation::Rect bounds);
        void SetControlPadding(const Core::Padding padding);
        void ParentProvider(Windows::UI::Xaml::Automation::Peers::AutomationPeer parentProvider);

#pragma region IUiaEventDispatcher
        void SignalSelectionChanged() override;
        void SignalTextChanged() override;
        void SignalCursorChanged() override;
        void NotifyNewOutput(std::wstring_view newOutput) override;
#pragma endregion

#pragma region ITextProvider Pattern
        Windows::UI::Xaml::Automation::P...",1,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,winrt.Microsoft,34,Microsoft,1
144342,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct InteractivityAutomationPeer :
        public InteractivityAutomationPeerT<InteractivityAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher,
        ::Microsoft::Console::Types::IControlAccessibilityInfo
    {
    public:
        InteractivityAutomationPeer(Microsoft::Terminal::Control::implementation::ControlInteractivity* owner);

        void SetControlBounds(const Windows::Foundation::Rect bounds);
        void SetControlPadding(const Core::Padding padding);
        void ParentProvider(Windows::UI::Xaml::Automation::Peers::AutomationPeer parentProvider);

#pragma region IUiaEventDispatcher
        void SignalSelectionChanged() override;
        void SignalTextChanged() override;
        void SignalCursorChanged() override;
        void NotifyNewOutput(std::wstring_view newOutput) override;
#pragma endregion

#pragma region ITextProvider Pattern
        Windows::UI::Xaml::Automation::P...",1,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,winrt.Microsoft.Terminal,34,Terminal,1
144343,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct InteractivityAutomationPeer :
        public InteractivityAutomationPeerT<InteractivityAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher,
        ::Microsoft::Console::Types::IControlAccessibilityInfo
    {
    public:
        InteractivityAutomationPeer(Microsoft::Terminal::Control::implementation::ControlInteractivity* owner);

        void SetControlBounds(const Windows::Foundation::Rect bounds);
        void SetControlPadding(const Core::Padding padding);
        void ParentProvider(Windows::UI::Xaml::Automation::Peers::AutomationPeer parentProvider);

#pragma region IUiaEventDispatcher
        void SignalSelectionChanged() override;
        void SignalTextChanged() override;
        void SignalCursorChanged() override;
        void NotifyNewOutput(std::wstring_view newOutput) override;
#pragma endregion

#pragma region ITextProvider Pattern
        Windows::UI::Xaml::Automation::P...",1,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,winrt.Microsoft.Terminal.Control,34,Control,1
144344,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct InteractivityAutomationPeer :
        public InteractivityAutomationPeerT<InteractivityAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher,
        ::Microsoft::Console::Types::IControlAccessibilityInfo
    {
    public:
        InteractivityAutomationPeer(Microsoft::Terminal::Control::implementation::ControlInteractivity* owner);

        void SetControlBounds(const Windows::Foundation::Rect bounds);
        void SetControlPadding(const Core::Padding padding);
        void ParentProvider(Windows::UI::Xaml::Automation::Peers::AutomationPeer parentProvider);

#pragma region IUiaEventDispatcher
        void SignalSelectionChanged() override;
        void SignalTextChanged() override;
        void SignalCursorChanged() override;
        void NotifyNewOutput(std::wstring_view newOutput) override;
#pragma endregion

#pragma region ITextProvider Pattern
        Windows::UI::Xaml::Automation::P...",1,cascadia\TerminalControl\InteractivityAutomationPeer.hpp,winrt.Microsoft.Terminal.Control.implementation,34,implementation,1
144555,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\KeyChord.cpp,cascadia\TerminalControl\KeyChord.cpp:<global>,,<global>,1
144560,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static VirtualKeyModifiers modifiersFromBooleans(bool ctrl, bool alt, bool shift, bool win)
    {
        auto modifiers = VirtualKeyModifiers::None;
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Control, ctrl);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Menu, alt);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Shift, shift);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Windows, win);
        return modifiers;
    }

    KeyChord::KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept :
        KeyChord(modifiersFromBooleans(ctrl, alt, shift, win), vkey, scanCode)
    {
    }

    KeyChord::KeyChord(const VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept :
        _modifiers{ modifiers },
        _vkey{ vkey },
        _scanCode{ scanCode }
    {
        // ActionMap needs to identify KeyChords which should ""layer"" (overwrite...",1,cascadia\TerminalControl\KeyChord.cpp,winrt,11,winrt,2
144561,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static VirtualKeyModifiers modifiersFromBooleans(bool ctrl, bool alt, bool shift, bool win)
    {
        auto modifiers = VirtualKeyModifiers::None;
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Control, ctrl);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Menu, alt);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Shift, shift);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Windows, win);
        return modifiers;
    }

    KeyChord::KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept :
        KeyChord(modifiersFromBooleans(ctrl, alt, shift, win), vkey, scanCode)
    {
    }

    KeyChord::KeyChord(const VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept :
        _modifiers{ modifiers },
        _vkey{ vkey },
        _scanCode{ scanCode }
    {
        // ActionMap needs to identify KeyChords which should ""layer"" (overwrite...",1,cascadia\TerminalControl\KeyChord.cpp,winrt.Microsoft,11,Microsoft,1
144562,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static VirtualKeyModifiers modifiersFromBooleans(bool ctrl, bool alt, bool shift, bool win)
    {
        auto modifiers = VirtualKeyModifiers::None;
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Control, ctrl);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Menu, alt);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Shift, shift);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Windows, win);
        return modifiers;
    }

    KeyChord::KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept :
        KeyChord(modifiersFromBooleans(ctrl, alt, shift, win), vkey, scanCode)
    {
    }

    KeyChord::KeyChord(const VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept :
        _modifiers{ modifiers },
        _vkey{ vkey },
        _scanCode{ scanCode }
    {
        // ActionMap needs to identify KeyChords which should ""layer"" (overwrite...",1,cascadia\TerminalControl\KeyChord.cpp,winrt.Microsoft.Terminal,11,Terminal,1
144563,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static VirtualKeyModifiers modifiersFromBooleans(bool ctrl, bool alt, bool shift, bool win)
    {
        auto modifiers = VirtualKeyModifiers::None;
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Control, ctrl);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Menu, alt);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Shift, shift);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Windows, win);
        return modifiers;
    }

    KeyChord::KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept :
        KeyChord(modifiersFromBooleans(ctrl, alt, shift, win), vkey, scanCode)
    {
    }

    KeyChord::KeyChord(const VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept :
        _modifiers{ modifiers },
        _vkey{ vkey },
        _scanCode{ scanCode }
    {
        // ActionMap needs to identify KeyChords which should ""layer"" (overwrite...",1,cascadia\TerminalControl\KeyChord.cpp,winrt.Microsoft.Terminal.Control,11,Control,1
144564,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    static VirtualKeyModifiers modifiersFromBooleans(bool ctrl, bool alt, bool shift, bool win)
    {
        auto modifiers = VirtualKeyModifiers::None;
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Control, ctrl);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Menu, alt);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Shift, shift);
        WI_SetFlagIf(modifiers, VirtualKeyModifiers::Windows, win);
        return modifiers;
    }

    KeyChord::KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept :
        KeyChord(modifiersFromBooleans(ctrl, alt, shift, win), vkey, scanCode)
    {
    }

    KeyChord::KeyChord(const VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept :
        _modifiers{ modifiers },
        _vkey{ vkey },
        _scanCode{ scanCode }
    {
        // ActionMap needs to identify KeyChords which should ""layer"" (overwrite...",1,cascadia\TerminalControl\KeyChord.cpp,winrt.Microsoft.Terminal.Control.implementation,11,implementation,1
144763,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\KeyChord.hpp,cascadia\TerminalControl\KeyChord.hpp:<global>,,<global>,1
144767,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct KeyChord : KeyChordT<KeyChord>
    {
        KeyChord() noexcept = default;
        KeyChord(const winrt::Windows::System::VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept;
        KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept;

        uint64_t Hash() const noexcept;
        bool Equals(const Control::KeyChord& other) const noexcept;

        winrt::Windows::System::VirtualKeyModifiers Modifiers() const noexcept;
        void Modifiers(const winrt::Windows::System::VirtualKeyModifiers value) noexcept;
        int32_t Vkey() const noexcept;
        void Vkey(int32_t value) noexcept;
        int32_t ScanCode() const noexcept;
        void ScanCode(int32_t value) noexcept;

    private:
        winrt::Windows::System::VirtualKeyModifiers _modifiers{};
        int32_t _vkey{};
        int32_t _scanCode{};
    };
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt,8,winrt,1
144768,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct KeyChord : KeyChordT<KeyChord>
    {
        KeyChord() noexcept = default;
        KeyChord(const winrt::Windows::System::VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept;
        KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept;

        uint64_t Hash() const noexcept;
        bool Equals(const Control::KeyChord& other) const noexcept;

        winrt::Windows::System::VirtualKeyModifiers Modifiers() const noexcept;
        void Modifiers(const winrt::Windows::System::VirtualKeyModifiers value) noexcept;
        int32_t Vkey() const noexcept;
        void Vkey(int32_t value) noexcept;
        int32_t ScanCode() const noexcept;
        void ScanCode(int32_t value) noexcept;

    private:
        winrt::Windows::System::VirtualKeyModifiers _modifiers{};
        int32_t _vkey{};
        int32_t _scanCode{};
    };
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft,8,Microsoft,1
144769,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct KeyChord : KeyChordT<KeyChord>
    {
        KeyChord() noexcept = default;
        KeyChord(const winrt::Windows::System::VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept;
        KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept;

        uint64_t Hash() const noexcept;
        bool Equals(const Control::KeyChord& other) const noexcept;

        winrt::Windows::System::VirtualKeyModifiers Modifiers() const noexcept;
        void Modifiers(const winrt::Windows::System::VirtualKeyModifiers value) noexcept;
        int32_t Vkey() const noexcept;
        void Vkey(int32_t value) noexcept;
        int32_t ScanCode() const noexcept;
        void ScanCode(int32_t value) noexcept;

    private:
        winrt::Windows::System::VirtualKeyModifiers _modifiers{};
        int32_t _vkey{};
        int32_t _scanCode{};
    };
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal,8,Terminal,1
144770,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct KeyChord : KeyChordT<KeyChord>
    {
        KeyChord() noexcept = default;
        KeyChord(const winrt::Windows::System::VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept;
        KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept;

        uint64_t Hash() const noexcept;
        bool Equals(const Control::KeyChord& other) const noexcept;

        winrt::Windows::System::VirtualKeyModifiers Modifiers() const noexcept;
        void Modifiers(const winrt::Windows::System::VirtualKeyModifiers value) noexcept;
        int32_t Vkey() const noexcept;
        void Vkey(int32_t value) noexcept;
        int32_t ScanCode() const noexcept;
        void ScanCode(int32_t value) noexcept;

    private:
        winrt::Windows::System::VirtualKeyModifiers _modifiers{};
        int32_t _vkey{};
        int32_t _scanCode{};
    };
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal.Control,8,Control,1
144771,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct KeyChord : KeyChordT<KeyChord>
    {
        KeyChord() noexcept = default;
        KeyChord(const winrt::Windows::System::VirtualKeyModifiers modifiers, int32_t vkey, int32_t scanCode) noexcept;
        KeyChord(bool ctrl, bool alt, bool shift, bool win, int32_t vkey, int32_t scanCode) noexcept;

        uint64_t Hash() const noexcept;
        bool Equals(const Control::KeyChord& other) const noexcept;

        winrt::Windows::System::VirtualKeyModifiers Modifiers() const noexcept;
        void Modifiers(const winrt::Windows::System::VirtualKeyModifiers value) noexcept;
        int32_t Vkey() const noexcept;
        void Vkey(int32_t value) noexcept;
        int32_t ScanCode() const noexcept;
        void ScanCode(int32_t value) noexcept;

    private:
        winrt::Windows::System::VirtualKeyModifiers _modifiers{};
        int32_t _vkey{};
        int32_t _scanCode{};
    };
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal.Control.implementation,8,implementation,1
144846,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(KeyChord);
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt,33,winrt,2
144847,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(KeyChord);
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft,33,Microsoft,1
144848,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(KeyChord);
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal,33,Terminal,1
144849,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(KeyChord);
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal.Control,33,Control,1
144850,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(KeyChord);
}",1,cascadia\TerminalControl\KeyChord.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,33,factory_implementation,1
144859,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp:<global>,,<global>,1
144863,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    bool ScrollBarVisualStateManager::GoToStateCore(
        winrt::Windows::UI::Xaml::Controls::Control const& control,
        winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot,
        winrt::hstring const& stateName,
        winrt::Windows::UI::Xaml::VisualStateGroup const& group,
        winrt::Windows::UI::Xaml::VisualState const& state,
        bool useTransitions)
    {
        if (!_initialized)
        {
            _initialized = true;

            Control::TermControl termControl{ nullptr };

            for (auto parent = VisualTreeHelper::GetParent(control); parent; parent = VisualTreeHelper::GetParent(parent))
            {
                if (parent.try_as(termControl))
                {
                    _termControl = winrt::get_self<TermControl>(termControl)->get_weak();
                    break;
                }
            }

            assert(termControl);
        }

        if (c...",1,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,winrt,10,winrt,1
144864,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    bool ScrollBarVisualStateManager::GoToStateCore(
        winrt::Windows::UI::Xaml::Controls::Control const& control,
        winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot,
        winrt::hstring const& stateName,
        winrt::Windows::UI::Xaml::VisualStateGroup const& group,
        winrt::Windows::UI::Xaml::VisualState const& state,
        bool useTransitions)
    {
        if (!_initialized)
        {
            _initialized = true;

            Control::TermControl termControl{ nullptr };

            for (auto parent = VisualTreeHelper::GetParent(control); parent; parent = VisualTreeHelper::GetParent(parent))
            {
                if (parent.try_as(termControl))
                {
                    _termControl = winrt::get_self<TermControl>(termControl)->get_weak();
                    break;
                }
            }

            assert(termControl);
        }

        if (c...",1,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,winrt.Microsoft,10,Microsoft,1
144865,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    bool ScrollBarVisualStateManager::GoToStateCore(
        winrt::Windows::UI::Xaml::Controls::Control const& control,
        winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot,
        winrt::hstring const& stateName,
        winrt::Windows::UI::Xaml::VisualStateGroup const& group,
        winrt::Windows::UI::Xaml::VisualState const& state,
        bool useTransitions)
    {
        if (!_initialized)
        {
            _initialized = true;

            Control::TermControl termControl{ nullptr };

            for (auto parent = VisualTreeHelper::GetParent(control); parent; parent = VisualTreeHelper::GetParent(parent))
            {
                if (parent.try_as(termControl))
                {
                    _termControl = winrt::get_self<TermControl>(termControl)->get_weak();
                    break;
                }
            }

            assert(termControl);
        }

        if (c...",1,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,winrt.Microsoft.Terminal,10,Terminal,1
144866,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    bool ScrollBarVisualStateManager::GoToStateCore(
        winrt::Windows::UI::Xaml::Controls::Control const& control,
        winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot,
        winrt::hstring const& stateName,
        winrt::Windows::UI::Xaml::VisualStateGroup const& group,
        winrt::Windows::UI::Xaml::VisualState const& state,
        bool useTransitions)
    {
        if (!_initialized)
        {
            _initialized = true;

            Control::TermControl termControl{ nullptr };

            for (auto parent = VisualTreeHelper::GetParent(control); parent; parent = VisualTreeHelper::GetParent(parent))
            {
                if (parent.try_as(termControl))
                {
                    _termControl = winrt::get_self<TermControl>(termControl)->get_weak();
                    break;
                }
            }

            assert(termControl);
        }

        if (c...",1,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,winrt.Microsoft.Terminal.Control,10,Control,1
144867,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    bool ScrollBarVisualStateManager::GoToStateCore(
        winrt::Windows::UI::Xaml::Controls::Control const& control,
        winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot,
        winrt::hstring const& stateName,
        winrt::Windows::UI::Xaml::VisualStateGroup const& group,
        winrt::Windows::UI::Xaml::VisualState const& state,
        bool useTransitions)
    {
        if (!_initialized)
        {
            _initialized = true;

            Control::TermControl termControl{ nullptr };

            for (auto parent = VisualTreeHelper::GetParent(control); parent; parent = VisualTreeHelper::GetParent(parent))
            {
                if (parent.try_as(termControl))
                {
                    _termControl = winrt::get_self<TermControl>(termControl)->get_weak();
                    break;
                }
            }

            assert(termControl);
        }

        if (c...",1,cascadia\TerminalControl\ScrollBarVisualStateManager.cpp,winrt.Microsoft.Terminal.Control.implementation,10,implementation,1
145016,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp:<global>,,<global>,1
145020,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager>
    {
        bool GoToStateCore(winrt::Windows::UI::Xaml::Controls::Control const& control, winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot, hstring const& stateName, winrt::Windows::UI::Xaml::VisualStateGroup const& group, winrt::Windows::UI::Xaml::VisualState const& state, bool useTransitions);

    private:
        winrt::weak_ref<TermControl> _termControl;
        bool _initialized = false;
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt,21,winrt,1
145021,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager>
    {
        bool GoToStateCore(winrt::Windows::UI::Xaml::Controls::Control const& control, winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot, hstring const& stateName, winrt::Windows::UI::Xaml::VisualStateGroup const& group, winrt::Windows::UI::Xaml::VisualState const& state, bool useTransitions);

    private:
        winrt::weak_ref<TermControl> _termControl;
        bool _initialized = false;
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft,21,Microsoft,1
145022,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager>
    {
        bool GoToStateCore(winrt::Windows::UI::Xaml::Controls::Control const& control, winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot, hstring const& stateName, winrt::Windows::UI::Xaml::VisualStateGroup const& group, winrt::Windows::UI::Xaml::VisualState const& state, bool useTransitions);

    private:
        winrt::weak_ref<TermControl> _termControl;
        bool _initialized = false;
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal,21,Terminal,1
145023,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager>
    {
        bool GoToStateCore(winrt::Windows::UI::Xaml::Controls::Control const& control, winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot, hstring const& stateName, winrt::Windows::UI::Xaml::VisualStateGroup const& group, winrt::Windows::UI::Xaml::VisualState const& state, bool useTransitions);

    private:
        winrt::weak_ref<TermControl> _termControl;
        bool _initialized = false;
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal.Control,21,Control,1
145024,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager>
    {
        bool GoToStateCore(winrt::Windows::UI::Xaml::Controls::Control const& control, winrt::Windows::UI::Xaml::FrameworkElement const& templateRoot, hstring const& stateName, winrt::Windows::UI::Xaml::VisualStateGroup const& group, winrt::Windows::UI::Xaml::VisualState const& state, bool useTransitions);

    private:
        winrt::weak_ref<TermControl> _termControl;
        bool _initialized = false;
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal.Control.implementation,21,implementation,1
145045,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager, implementation::ScrollBarVisualStateManager>
    {
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt,33,winrt,2
145046,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager, implementation::ScrollBarVisualStateManager>
    {
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft,33,Microsoft,1
145047,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager, implementation::ScrollBarVisualStateManager>
    {
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal,33,Terminal,1
145048,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager, implementation::ScrollBarVisualStateManager>
    {
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal.Control,33,Control,1
145049,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    struct ScrollBarVisualStateManager : ScrollBarVisualStateManagerT<ScrollBarVisualStateManager, implementation::ScrollBarVisualStateManager>
    {
    };
}",1,cascadia\TerminalControl\ScrollBarVisualStateManager.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,33,factory_implementation,1
145082,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\SearchBoxControl.cpp,cascadia\TerminalControl\SearchBoxControl.cpp:<global>,,<global>,1
145085,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    // Constructor
    SearchBoxControl::SearchBoxControl()
    {
        InitializeComponent();

        this->CharacterReceived({ this, &SearchBoxControl::_CharacterHandler });
        this->KeyDown({ this, &SearchBoxControl::_KeyDownHandler });
        this->RegisterPropertyChangedCallback(UIElement::VisibilityProperty(), [this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _...",1,cascadia\TerminalControl\SearchBoxControl.cpp,winrt,13,winrt,1
145086,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    // Constructor
    SearchBoxControl::SearchBoxControl()
    {
        InitializeComponent();

        this->CharacterReceived({ this, &SearchBoxControl::_CharacterHandler });
        this->KeyDown({ this, &SearchBoxControl::_KeyDownHandler });
        this->RegisterPropertyChangedCallback(UIElement::VisibilityProperty(), [this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _...",1,cascadia\TerminalControl\SearchBoxControl.cpp,winrt.Microsoft,13,Microsoft,1
145087,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    // Constructor
    SearchBoxControl::SearchBoxControl()
    {
        InitializeComponent();

        this->CharacterReceived({ this, &SearchBoxControl::_CharacterHandler });
        this->KeyDown({ this, &SearchBoxControl::_KeyDownHandler });
        this->RegisterPropertyChangedCallback(UIElement::VisibilityProperty(), [this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _...",1,cascadia\TerminalControl\SearchBoxControl.cpp,winrt.Microsoft.Terminal,13,Terminal,1
145088,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    // Constructor
    SearchBoxControl::SearchBoxControl()
    {
        InitializeComponent();

        this->CharacterReceived({ this, &SearchBoxControl::_CharacterHandler });
        this->KeyDown({ this, &SearchBoxControl::_KeyDownHandler });
        this->RegisterPropertyChangedCallback(UIElement::VisibilityProperty(), [this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _...",1,cascadia\TerminalControl\SearchBoxControl.cpp,winrt.Microsoft.Terminal.Control,13,Control,1
145089,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    // Constructor
    SearchBoxControl::SearchBoxControl()
    {
        InitializeComponent();

        this->CharacterReceived({ this, &SearchBoxControl::_CharacterHandler });
        this->KeyDown({ this, &SearchBoxControl::_KeyDownHandler });
        this->RegisterPropertyChangedCallback(UIElement::VisibilityProperty(), [this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _...",1,cascadia\TerminalControl\SearchBoxControl.cpp,winrt.Microsoft.Terminal.Control.implementation,13,implementation,1
145679,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\SearchBoxControl.hpp,cascadia\TerminalControl\SearchBoxControl.hpp:<global>,,<global>,1
145683,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SearchBoxControl : SearchBoxControlT<SearchBoxControl>
    {
        static constexpr int32_t MaximumTotalResultsToShowInStatus = 999;
        static constexpr std::wstring_view TotalResultsTooHighStatus = L""999+"";
        static constexpr std::wstring_view CurrentIndexTooHighStatus = L""?"";
        static constexpr std::wstring_view StatusDelimiter = L""/"";

        SearchBoxControl();

        void TextBoxKeyDown(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        void SetFocusOnTextbox();
        void PopulateTextbox(const winrt::hstring& text);
        bool ContainsFocus();
        void SetStatus(int32_t totalMatches, int32_t currentMatch);
        bool NavigationEnabled();
        void NavigationEnabled(bool enabled);

        void GoBackwardClicked(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Window...",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt,20,winrt,1
145684,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SearchBoxControl : SearchBoxControlT<SearchBoxControl>
    {
        static constexpr int32_t MaximumTotalResultsToShowInStatus = 999;
        static constexpr std::wstring_view TotalResultsTooHighStatus = L""999+"";
        static constexpr std::wstring_view CurrentIndexTooHighStatus = L""?"";
        static constexpr std::wstring_view StatusDelimiter = L""/"";

        SearchBoxControl();

        void TextBoxKeyDown(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        void SetFocusOnTextbox();
        void PopulateTextbox(const winrt::hstring& text);
        bool ContainsFocus();
        void SetStatus(int32_t totalMatches, int32_t currentMatch);
        bool NavigationEnabled();
        void NavigationEnabled(bool enabled);

        void GoBackwardClicked(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Window...",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft,20,Microsoft,1
145685,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SearchBoxControl : SearchBoxControlT<SearchBoxControl>
    {
        static constexpr int32_t MaximumTotalResultsToShowInStatus = 999;
        static constexpr std::wstring_view TotalResultsTooHighStatus = L""999+"";
        static constexpr std::wstring_view CurrentIndexTooHighStatus = L""?"";
        static constexpr std::wstring_view StatusDelimiter = L""/"";

        SearchBoxControl();

        void TextBoxKeyDown(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        void SetFocusOnTextbox();
        void PopulateTextbox(const winrt::hstring& text);
        bool ContainsFocus();
        void SetStatus(int32_t totalMatches, int32_t currentMatch);
        bool NavigationEnabled();
        void NavigationEnabled(bool enabled);

        void GoBackwardClicked(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Window...",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal,20,Terminal,1
145686,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SearchBoxControl : SearchBoxControlT<SearchBoxControl>
    {
        static constexpr int32_t MaximumTotalResultsToShowInStatus = 999;
        static constexpr std::wstring_view TotalResultsTooHighStatus = L""999+"";
        static constexpr std::wstring_view CurrentIndexTooHighStatus = L""?"";
        static constexpr std::wstring_view StatusDelimiter = L""/"";

        SearchBoxControl();

        void TextBoxKeyDown(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        void SetFocusOnTextbox();
        void PopulateTextbox(const winrt::hstring& text);
        bool ContainsFocus();
        void SetStatus(int32_t totalMatches, int32_t currentMatch);
        bool NavigationEnabled();
        void NavigationEnabled(bool enabled);

        void GoBackwardClicked(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Window...",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal.Control,20,Control,1
145687,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct SearchBoxControl : SearchBoxControlT<SearchBoxControl>
    {
        static constexpr int32_t MaximumTotalResultsToShowInStatus = 999;
        static constexpr std::wstring_view TotalResultsTooHighStatus = L""999+"";
        static constexpr std::wstring_view CurrentIndexTooHighStatus = L""?"";
        static constexpr std::wstring_view StatusDelimiter = L""/"";

        SearchBoxControl();

        void TextBoxKeyDown(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        void SetFocusOnTextbox();
        void PopulateTextbox(const winrt::hstring& text);
        bool ContainsFocus();
        void SetStatus(int32_t totalMatches, int32_t currentMatch);
        bool NavigationEnabled();
        void NavigationEnabled(bool enabled);

        void GoBackwardClicked(const winrt::Windows::Foundation::IInspectable& /*sender*/, const winrt::Window...",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal.Control.implementation,20,implementation,1
145817,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(SearchBoxControl);
}",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt,65,winrt,2
145818,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(SearchBoxControl);
}",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft,65,Microsoft,1
145819,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(SearchBoxControl);
}",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal,65,Terminal,1
145820,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(SearchBoxControl);
}",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal.Control,65,Control,1
145821,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(SearchBoxControl);
}",1,cascadia\TerminalControl\SearchBoxControl.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,65,factory_implementation,1
145830,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TSFInputControl.cpp,cascadia\TerminalControl\TSFInputControl.cpp:<global>,,<global>,1
145834,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TSFInputControl::TSFInputControl()
    {
        InitializeComponent();

        // Create a CoreTextEditingContext for since we are acting like a custom edit control
        auto manager = CoreTextServicesManager::GetForCurrentView();
        _editContext = manager.CreateEditContext();

        // InputPane is manually shown inside of TermControl.
        _editContext.InputPaneDisplayPolicy(CoreTextInputPaneDisplayPolicy::Manual);

        // Set the input scope to AlphanumericHalfWidth in order to facilitate those CJK input methods to open in English mode by default.
        // AlphanumericHalfWidth scope doesn't prevent input method from switching to composition mode, it accepts any character too.
        // Besides, Text scope turns on typing intelligence, but that doesn't work in this project.
        _editContext.InputScope(CoreTextInputScope::AlphanumericHalfWidth);

        _textRequestedRevoker = _editConte...",1,cascadia\TerminalControl\TSFInputControl.cpp,winrt,15,winrt,1
145835,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TSFInputControl::TSFInputControl()
    {
        InitializeComponent();

        // Create a CoreTextEditingContext for since we are acting like a custom edit control
        auto manager = CoreTextServicesManager::GetForCurrentView();
        _editContext = manager.CreateEditContext();

        // InputPane is manually shown inside of TermControl.
        _editContext.InputPaneDisplayPolicy(CoreTextInputPaneDisplayPolicy::Manual);

        // Set the input scope to AlphanumericHalfWidth in order to facilitate those CJK input methods to open in English mode by default.
        // AlphanumericHalfWidth scope doesn't prevent input method from switching to composition mode, it accepts any character too.
        // Besides, Text scope turns on typing intelligence, but that doesn't work in this project.
        _editContext.InputScope(CoreTextInputScope::AlphanumericHalfWidth);

        _textRequestedRevoker = _editConte...",1,cascadia\TerminalControl\TSFInputControl.cpp,winrt.Microsoft,15,Microsoft,1
145836,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TSFInputControl::TSFInputControl()
    {
        InitializeComponent();

        // Create a CoreTextEditingContext for since we are acting like a custom edit control
        auto manager = CoreTextServicesManager::GetForCurrentView();
        _editContext = manager.CreateEditContext();

        // InputPane is manually shown inside of TermControl.
        _editContext.InputPaneDisplayPolicy(CoreTextInputPaneDisplayPolicy::Manual);

        // Set the input scope to AlphanumericHalfWidth in order to facilitate those CJK input methods to open in English mode by default.
        // AlphanumericHalfWidth scope doesn't prevent input method from switching to composition mode, it accepts any character too.
        // Besides, Text scope turns on typing intelligence, but that doesn't work in this project.
        _editContext.InputScope(CoreTextInputScope::AlphanumericHalfWidth);

        _textRequestedRevoker = _editConte...",1,cascadia\TerminalControl\TSFInputControl.cpp,winrt.Microsoft.Terminal,15,Terminal,1
145837,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TSFInputControl::TSFInputControl()
    {
        InitializeComponent();

        // Create a CoreTextEditingContext for since we are acting like a custom edit control
        auto manager = CoreTextServicesManager::GetForCurrentView();
        _editContext = manager.CreateEditContext();

        // InputPane is manually shown inside of TermControl.
        _editContext.InputPaneDisplayPolicy(CoreTextInputPaneDisplayPolicy::Manual);

        // Set the input scope to AlphanumericHalfWidth in order to facilitate those CJK input methods to open in English mode by default.
        // AlphanumericHalfWidth scope doesn't prevent input method from switching to composition mode, it accepts any character too.
        // Besides, Text scope turns on typing intelligence, but that doesn't work in this project.
        _editContext.InputScope(CoreTextInputScope::AlphanumericHalfWidth);

        _textRequestedRevoker = _editConte...",1,cascadia\TerminalControl\TSFInputControl.cpp,winrt.Microsoft.Terminal.Control,15,Control,1
145838,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TSFInputControl::TSFInputControl()
    {
        InitializeComponent();

        // Create a CoreTextEditingContext for since we are acting like a custom edit control
        auto manager = CoreTextServicesManager::GetForCurrentView();
        _editContext = manager.CreateEditContext();

        // InputPane is manually shown inside of TermControl.
        _editContext.InputPaneDisplayPolicy(CoreTextInputPaneDisplayPolicy::Manual);

        // Set the input scope to AlphanumericHalfWidth in order to facilitate those CJK input methods to open in English mode by default.
        // AlphanumericHalfWidth scope doesn't prevent input method from switching to composition mode, it accepts any character too.
        // Besides, Text scope turns on typing intelligence, but that doesn't work in this project.
        _editContext.InputScope(CoreTextInputScope::AlphanumericHalfWidth);

        _textRequestedRevoker = _editConte...",1,cascadia\TerminalControl\TSFInputControl.cpp,winrt.Microsoft.Terminal.Control.implementation,15,implementation,1
146329,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TSFInputControl.hpp,cascadia\TerminalControl\TSFInputControl.hpp:<global>,,<global>,1
146333,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct CursorPositionEventArgs :
        public CursorPositionEventArgsT<CursorPositionEventArgs>
    {
    public:
        CursorPositionEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);
    };

    struct FontInfoEventArgs :
        public FontInfoEventArgsT<FontInfoEventArgs>
    {
    public:
        FontInfoEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Size, FontSize);

        WINRT_PROPERTY(winrt::hstring, FontFace);

        WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);
    };

    struct TSFInputControl : TSFInputControlT<TSFInputControl>
    {
    public:
        TSFInputControl();

        void NotifyFocusEnter();
        void NotifyFocusLeave();
        void ClearBuffer();
        void TryRedrawCanvas();

        void Close();

        // -------------------------------- WinRT Events ---------------------------------
        TY...",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt,9,winrt,1
146334,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct CursorPositionEventArgs :
        public CursorPositionEventArgsT<CursorPositionEventArgs>
    {
    public:
        CursorPositionEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);
    };

    struct FontInfoEventArgs :
        public FontInfoEventArgsT<FontInfoEventArgs>
    {
    public:
        FontInfoEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Size, FontSize);

        WINRT_PROPERTY(winrt::hstring, FontFace);

        WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);
    };

    struct TSFInputControl : TSFInputControlT<TSFInputControl>
    {
    public:
        TSFInputControl();

        void NotifyFocusEnter();
        void NotifyFocusLeave();
        void ClearBuffer();
        void TryRedrawCanvas();

        void Close();

        // -------------------------------- WinRT Events ---------------------------------
        TY...",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft,9,Microsoft,1
146335,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct CursorPositionEventArgs :
        public CursorPositionEventArgsT<CursorPositionEventArgs>
    {
    public:
        CursorPositionEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);
    };

    struct FontInfoEventArgs :
        public FontInfoEventArgsT<FontInfoEventArgs>
    {
    public:
        FontInfoEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Size, FontSize);

        WINRT_PROPERTY(winrt::hstring, FontFace);

        WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);
    };

    struct TSFInputControl : TSFInputControlT<TSFInputControl>
    {
    public:
        TSFInputControl();

        void NotifyFocusEnter();
        void NotifyFocusLeave();
        void ClearBuffer();
        void TryRedrawCanvas();

        void Close();

        // -------------------------------- WinRT Events ---------------------------------
        TY...",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal,9,Terminal,1
146336,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct CursorPositionEventArgs :
        public CursorPositionEventArgsT<CursorPositionEventArgs>
    {
    public:
        CursorPositionEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);
    };

    struct FontInfoEventArgs :
        public FontInfoEventArgsT<FontInfoEventArgs>
    {
    public:
        FontInfoEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Size, FontSize);

        WINRT_PROPERTY(winrt::hstring, FontFace);

        WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);
    };

    struct TSFInputControl : TSFInputControlT<TSFInputControl>
    {
    public:
        TSFInputControl();

        void NotifyFocusEnter();
        void NotifyFocusLeave();
        void ClearBuffer();
        void TryRedrawCanvas();

        void Close();

        // -------------------------------- WinRT Events ---------------------------------
        TY...",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal.Control,9,Control,1
146337,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct CursorPositionEventArgs :
        public CursorPositionEventArgsT<CursorPositionEventArgs>
    {
    public:
        CursorPositionEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);
    };

    struct FontInfoEventArgs :
        public FontInfoEventArgsT<FontInfoEventArgs>
    {
    public:
        FontInfoEventArgs() = default;

        WINRT_PROPERTY(Windows::Foundation::Size, FontSize);

        WINRT_PROPERTY(winrt::hstring, FontFace);

        WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);
    };

    struct TSFInputControl : TSFInputControlT<TSFInputControl>
    {
    public:
        TSFInputControl();

        void NotifyFocusEnter();
        void NotifyFocusLeave();
        void ClearBuffer();
        void TryRedrawCanvas();

        void Close();

        // -------------------------------- WinRT Events ---------------------------------
        TY...",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal.Control.implementation,9,implementation,1
146501,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TSFInputControl);
}",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt,89,winrt,2
146502,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TSFInputControl);
}",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft,89,Microsoft,1
146503,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TSFInputControl);
}",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal,89,Terminal,1
146504,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TSFInputControl);
}",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal.Control,89,Control,1
146505,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TSFInputControl);
}",1,cascadia\TerminalControl\TSFInputControl.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,89,factory_implementation,1
146997,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TermControl.cpp,cascadia\TerminalControl\TermControl.cpp:<global>,,<global>,1
147042,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControl::TermControl(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection) :
        TermControl{ winrt::make<implementation::ControlInteractivity>(settings, unfocusedAppearance, connection) }
    {
    }

    TermControl::TermControl(Control::ControlInteractivity content) :
        _interactivity{ content },
        _isInternalScrollBarUpdate{ false },
        _autoScrollVelocity{ 0 },
        _autoScrollingPointerPoint{ std::nullopt },
        _lastAutoScrollUpdateTime{ std::nullopt },
        _searchBox{ nullptr }
    {
        InitializeComponent();

        _core = _interactivity.Core();

        // This event is specifically triggered by the renderer thread, a BG thread. Use a weak ref here.
        _revokers.RendererEnteredErrorState = _core.RendererEnteredErrorState(winrt::a...",1,cascadia\TerminalControl\TermControl.cpp,winrt,46,winrt,11
147043,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControl::TermControl(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection) :
        TermControl{ winrt::make<implementation::ControlInteractivity>(settings, unfocusedAppearance, connection) }
    {
    }

    TermControl::TermControl(Control::ControlInteractivity content) :
        _interactivity{ content },
        _isInternalScrollBarUpdate{ false },
        _autoScrollVelocity{ 0 },
        _autoScrollingPointerPoint{ std::nullopt },
        _lastAutoScrollUpdateTime{ std::nullopt },
        _searchBox{ nullptr }
    {
        InitializeComponent();

        _core = _interactivity.Core();

        // This event is specifically triggered by the renderer thread, a BG thread. Use a weak ref here.
        _revokers.RendererEnteredErrorState = _core.RendererEnteredErrorState(winrt::a...",1,cascadia\TerminalControl\TermControl.cpp,winrt.Microsoft,46,Microsoft,1
147044,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControl::TermControl(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection) :
        TermControl{ winrt::make<implementation::ControlInteractivity>(settings, unfocusedAppearance, connection) }
    {
    }

    TermControl::TermControl(Control::ControlInteractivity content) :
        _interactivity{ content },
        _isInternalScrollBarUpdate{ false },
        _autoScrollVelocity{ 0 },
        _autoScrollingPointerPoint{ std::nullopt },
        _lastAutoScrollUpdateTime{ std::nullopt },
        _searchBox{ nullptr }
    {
        InitializeComponent();

        _core = _interactivity.Core();

        // This event is specifically triggered by the renderer thread, a BG thread. Use a weak ref here.
        _revokers.RendererEnteredErrorState = _core.RendererEnteredErrorState(winrt::a...",1,cascadia\TerminalControl\TermControl.cpp,winrt.Microsoft.Terminal,46,Terminal,1
147045,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControl::TermControl(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection) :
        TermControl{ winrt::make<implementation::ControlInteractivity>(settings, unfocusedAppearance, connection) }
    {
    }

    TermControl::TermControl(Control::ControlInteractivity content) :
        _interactivity{ content },
        _isInternalScrollBarUpdate{ false },
        _autoScrollVelocity{ 0 },
        _autoScrollingPointerPoint{ std::nullopt },
        _lastAutoScrollUpdateTime{ std::nullopt },
        _searchBox{ nullptr }
    {
        InitializeComponent();

        _core = _interactivity.Core();

        // This event is specifically triggered by the renderer thread, a BG thread. Use a weak ref here.
        _revokers.RendererEnteredErrorState = _core.RendererEnteredErrorState(winrt::a...",1,cascadia\TerminalControl\TermControl.cpp,winrt.Microsoft.Terminal.Control,46,Control,1
147046,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControl::TermControl(IControlSettings settings,
                             Control::IControlAppearance unfocusedAppearance,
                             TerminalConnection::ITerminalConnection connection) :
        TermControl{ winrt::make<implementation::ControlInteractivity>(settings, unfocusedAppearance, connection) }
    {
    }

    TermControl::TermControl(Control::ControlInteractivity content) :
        _interactivity{ content },
        _isInternalScrollBarUpdate{ false },
        _autoScrollVelocity{ 0 },
        _autoScrollingPointerPoint{ std::nullopt },
        _lastAutoScrollUpdateTime{ std::nullopt },
        _searchBox{ nullptr }
    {
        InitializeComponent();

        _core = _interactivity.Core();

        // This event is specifically triggered by the renderer thread, a BG thread. Use a weak ref here.
        _revokers.RendererEnteredErrorState = _core.RendererEnteredErrorState(winrt::a...",1,cascadia\TerminalControl\TermControl.cpp,winrt.Microsoft.Terminal.Control.implementation,46,implementation,1
154962,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TermControl.hpp,cascadia\TerminalControl\TermControl.hpp:<global>,,<global>,1
154966,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    struct MouseButtonState;
}",1,cascadia\TerminalControl\TermControl.hpp,Microsoft,19,Microsoft,1
154967,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    struct MouseButtonState;
}",1,cascadia\TerminalControl\TermControl.hpp,Microsoft.Console,19,Console,1
154968,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    struct MouseButtonState;
}",1,cascadia\TerminalControl\TermControl.hpp,Microsoft.Console.VirtualTerminal,19,VirtualTerminal,1
154970,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControl : TermControlT<TermControl>
    {
        TermControl(Control::ControlInteractivity content);

        TermControl(IControlSettings settings, Control::IControlAppearance unfocusedAppearance, TerminalConnection::ITerminalConnection connection);

        static Control::TermControl NewControlByAttachingContent(Control::ControlInteractivity content, const Microsoft::Terminal::Control::IKeyBindings& keyBindings);

        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings);
        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings, Control::IControlAppearance unfocusedAppearance);
        IControlSettings Settings() const;

        uint64_t ContentId() const;

        hstring GetProfileName() const;

        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);
      ...",1,cascadia\TerminalControl\TermControl.hpp,winrt,24,winrt,2
154971,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControl : TermControlT<TermControl>
    {
        TermControl(Control::ControlInteractivity content);

        TermControl(IControlSettings settings, Control::IControlAppearance unfocusedAppearance, TerminalConnection::ITerminalConnection connection);

        static Control::TermControl NewControlByAttachingContent(Control::ControlInteractivity content, const Microsoft::Terminal::Control::IKeyBindings& keyBindings);

        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings);
        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings, Control::IControlAppearance unfocusedAppearance);
        IControlSettings Settings() const;

        uint64_t ContentId() const;

        hstring GetProfileName() const;

        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);
      ...",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft,24,Microsoft,1
154972,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControl : TermControlT<TermControl>
    {
        TermControl(Control::ControlInteractivity content);

        TermControl(IControlSettings settings, Control::IControlAppearance unfocusedAppearance, TerminalConnection::ITerminalConnection connection);

        static Control::TermControl NewControlByAttachingContent(Control::ControlInteractivity content, const Microsoft::Terminal::Control::IKeyBindings& keyBindings);

        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings);
        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings, Control::IControlAppearance unfocusedAppearance);
        IControlSettings Settings() const;

        uint64_t ContentId() const;

        hstring GetProfileName() const;

        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);
      ...",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal,24,Terminal,1
154973,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControl : TermControlT<TermControl>
    {
        TermControl(Control::ControlInteractivity content);

        TermControl(IControlSettings settings, Control::IControlAppearance unfocusedAppearance, TerminalConnection::ITerminalConnection connection);

        static Control::TermControl NewControlByAttachingContent(Control::ControlInteractivity content, const Microsoft::Terminal::Control::IKeyBindings& keyBindings);

        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings);
        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings, Control::IControlAppearance unfocusedAppearance);
        IControlSettings Settings() const;

        uint64_t ContentId() const;

        hstring GetProfileName() const;

        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);
      ...",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal.Control,24,Control,1
154974,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControl : TermControlT<TermControl>
    {
        TermControl(Control::ControlInteractivity content);

        TermControl(IControlSettings settings, Control::IControlAppearance unfocusedAppearance, TerminalConnection::ITerminalConnection connection);

        static Control::TermControl NewControlByAttachingContent(Control::ControlInteractivity content, const Microsoft::Terminal::Control::IKeyBindings& keyBindings);

        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings);
        winrt::fire_and_forget UpdateControlSettings(Control::IControlSettings settings, Control::IControlAppearance unfocusedAppearance);
        IControlSettings Settings() const;

        uint64_t ContentId() const;

        hstring GetProfileName() const;

        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);
      ...",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal.Control.implementation,24,implementation,1
156584,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TermControl);
}",1,cascadia\TerminalControl\TermControl.hpp,winrt,419,winrt,3
156585,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TermControl);
}",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft,419,Microsoft,1
156586,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TermControl);
}",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal,419,Terminal,1
156587,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TermControl);
}",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal.Control,419,Control,1
156588,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(TermControl);
}",1,cascadia\TerminalControl\TermControl.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,419,factory_implementation,1
156798,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TermControlAutomationPeer.cpp,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>,,<global>,1
156801,NAMESPACE_BLOCK,"namespace UIA
{
    using ::ITextRangeProvider;
    using ::SupportedTextSelection;
}",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,UIA,18,UIA,1
156802,NAMESPACE_BLOCK,"namespace XamlAutomation
{
    using winrt::Windows::UI::Xaml::Automation::SupportedTextSelection;
    using winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple;
    using winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider;
}",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,XamlAutomation,24,XamlAutomation,2
156858,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControlAutomationPeer::TermControlAutomationPeer(winrt::com_ptr<TermControl> owner,
                                                         const Core::Padding padding,
                                                         Control::InteractivityAutomationPeer impl) :
        TermControlAutomationPeerT<TermControlAutomationPeer>(*owner.get()), // pass owner to FrameworkElementAutomationPeer
        _termControl{ owner },
        _contentAutomationPeer{ impl }
    {
        UpdateControlBounds();
        SetControlPadding(padding);
        // Listen for UIA signalling events from the implementation. We need to
        // be the one to actually raise these automation events, so they go
        // through the UI tree correctly.
        _contentAutomationPeer.SelectionChanged([this](auto&&, auto&&) { SignalSelectionChanged(); });
        _contentAutomationPeer.TextChanged([this](auto&&, auto&&) { SignalTextChange...",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,winrt,68,winrt,7
156859,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControlAutomationPeer::TermControlAutomationPeer(winrt::com_ptr<TermControl> owner,
                                                         const Core::Padding padding,
                                                         Control::InteractivityAutomationPeer impl) :
        TermControlAutomationPeerT<TermControlAutomationPeer>(*owner.get()), // pass owner to FrameworkElementAutomationPeer
        _termControl{ owner },
        _contentAutomationPeer{ impl }
    {
        UpdateControlBounds();
        SetControlPadding(padding);
        // Listen for UIA signalling events from the implementation. We need to
        // be the one to actually raise these automation events, so they go
        // through the UI tree correctly.
        _contentAutomationPeer.SelectionChanged([this](auto&&, auto&&) { SignalSelectionChanged(); });
        _contentAutomationPeer.TextChanged([this](auto&&, auto&&) { SignalTextChange...",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,winrt.Microsoft,68,Microsoft,1
156860,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControlAutomationPeer::TermControlAutomationPeer(winrt::com_ptr<TermControl> owner,
                                                         const Core::Padding padding,
                                                         Control::InteractivityAutomationPeer impl) :
        TermControlAutomationPeerT<TermControlAutomationPeer>(*owner.get()), // pass owner to FrameworkElementAutomationPeer
        _termControl{ owner },
        _contentAutomationPeer{ impl }
    {
        UpdateControlBounds();
        SetControlPadding(padding);
        // Listen for UIA signalling events from the implementation. We need to
        // be the one to actually raise these automation events, so they go
        // through the UI tree correctly.
        _contentAutomationPeer.SelectionChanged([this](auto&&, auto&&) { SignalSelectionChanged(); });
        _contentAutomationPeer.TextChanged([this](auto&&, auto&&) { SignalTextChange...",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,winrt.Microsoft.Terminal,68,Terminal,1
156861,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControlAutomationPeer::TermControlAutomationPeer(winrt::com_ptr<TermControl> owner,
                                                         const Core::Padding padding,
                                                         Control::InteractivityAutomationPeer impl) :
        TermControlAutomationPeerT<TermControlAutomationPeer>(*owner.get()), // pass owner to FrameworkElementAutomationPeer
        _termControl{ owner },
        _contentAutomationPeer{ impl }
    {
        UpdateControlBounds();
        SetControlPadding(padding);
        // Listen for UIA signalling events from the implementation. We need to
        // be the one to actually raise these automation events, so they go
        // through the UI tree correctly.
        _contentAutomationPeer.SelectionChanged([this](auto&&, auto&&) { SignalSelectionChanged(); });
        _contentAutomationPeer.TextChanged([this](auto&&, auto&&) { SignalTextChange...",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,winrt.Microsoft.Terminal.Control,68,Control,1
156862,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    TermControlAutomationPeer::TermControlAutomationPeer(winrt::com_ptr<TermControl> owner,
                                                         const Core::Padding padding,
                                                         Control::InteractivityAutomationPeer impl) :
        TermControlAutomationPeerT<TermControlAutomationPeer>(*owner.get()), // pass owner to FrameworkElementAutomationPeer
        _termControl{ owner },
        _contentAutomationPeer{ impl }
    {
        UpdateControlBounds();
        SetControlPadding(padding);
        // Listen for UIA signalling events from the implementation. We need to
        // be the one to actually raise these automation events, so they go
        // through the UI tree correctly.
        _contentAutomationPeer.SelectionChanged([this](auto&&, auto&&) { SignalSelectionChanged(); });
        _contentAutomationPeer.TextChanged([this](auto&&, auto&&) { SignalTextChange...",1,cascadia\TerminalControl\TermControlAutomationPeer.cpp,winrt.Microsoft.Terminal.Control.implementation,68,implementation,1
157336,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\TermControlAutomationPeer.hpp,cascadia\TerminalControl\TermControlAutomationPeer.hpp:<global>,,<global>,1
157340,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControlAutomationPeer :
        public TermControlAutomationPeerT<TermControlAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher
    {
    public:
        TermControlAutomationPeer(winrt::com_ptr<Microsoft::Terminal::Control::implementation::TermControl> owner,
                                  const Core::Padding padding,
                                  Control::InteractivityAutomationPeer implementation);

        void UpdateControlBounds();
        void SetControlPadding(const Core::Padding padding);
        void RecordKeyEvent(const WORD vkey);
        void Close();

#pragma region FrameworkElementAutomationPeer
        hstring GetClassNameCore() const;
        Windows::UI::Xaml::Automation::Peers::AutomationControlType GetAutomationControlTypeCore() const;
        hstring GetLocalizedControlTypeCore() const;
        Windows::Foundation::IInspectable GetPatternCore(Windows::UI:...",1,cascadia\TerminalControl\TermControlAutomationPeer.hpp,winrt,38,winrt,1
157341,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControlAutomationPeer :
        public TermControlAutomationPeerT<TermControlAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher
    {
    public:
        TermControlAutomationPeer(winrt::com_ptr<Microsoft::Terminal::Control::implementation::TermControl> owner,
                                  const Core::Padding padding,
                                  Control::InteractivityAutomationPeer implementation);

        void UpdateControlBounds();
        void SetControlPadding(const Core::Padding padding);
        void RecordKeyEvent(const WORD vkey);
        void Close();

#pragma region FrameworkElementAutomationPeer
        hstring GetClassNameCore() const;
        Windows::UI::Xaml::Automation::Peers::AutomationControlType GetAutomationControlTypeCore() const;
        hstring GetLocalizedControlTypeCore() const;
        Windows::Foundation::IInspectable GetPatternCore(Windows::UI:...",1,cascadia\TerminalControl\TermControlAutomationPeer.hpp,winrt.Microsoft,38,Microsoft,1
157342,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControlAutomationPeer :
        public TermControlAutomationPeerT<TermControlAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher
    {
    public:
        TermControlAutomationPeer(winrt::com_ptr<Microsoft::Terminal::Control::implementation::TermControl> owner,
                                  const Core::Padding padding,
                                  Control::InteractivityAutomationPeer implementation);

        void UpdateControlBounds();
        void SetControlPadding(const Core::Padding padding);
        void RecordKeyEvent(const WORD vkey);
        void Close();

#pragma region FrameworkElementAutomationPeer
        hstring GetClassNameCore() const;
        Windows::UI::Xaml::Automation::Peers::AutomationControlType GetAutomationControlTypeCore() const;
        hstring GetLocalizedControlTypeCore() const;
        Windows::Foundation::IInspectable GetPatternCore(Windows::UI:...",1,cascadia\TerminalControl\TermControlAutomationPeer.hpp,winrt.Microsoft.Terminal,38,Terminal,1
157343,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControlAutomationPeer :
        public TermControlAutomationPeerT<TermControlAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher
    {
    public:
        TermControlAutomationPeer(winrt::com_ptr<Microsoft::Terminal::Control::implementation::TermControl> owner,
                                  const Core::Padding padding,
                                  Control::InteractivityAutomationPeer implementation);

        void UpdateControlBounds();
        void SetControlPadding(const Core::Padding padding);
        void RecordKeyEvent(const WORD vkey);
        void Close();

#pragma region FrameworkElementAutomationPeer
        hstring GetClassNameCore() const;
        Windows::UI::Xaml::Automation::Peers::AutomationControlType GetAutomationControlTypeCore() const;
        hstring GetLocalizedControlTypeCore() const;
        Windows::Foundation::IInspectable GetPatternCore(Windows::UI:...",1,cascadia\TerminalControl\TermControlAutomationPeer.hpp,winrt.Microsoft.Terminal.Control,38,Control,1
157344,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct TermControlAutomationPeer :
        public TermControlAutomationPeerT<TermControlAutomationPeer>,
        ::Microsoft::Console::Types::IUiaEventDispatcher
    {
    public:
        TermControlAutomationPeer(winrt::com_ptr<Microsoft::Terminal::Control::implementation::TermControl> owner,
                                  const Core::Padding padding,
                                  Control::InteractivityAutomationPeer implementation);

        void UpdateControlBounds();
        void SetControlPadding(const Core::Padding padding);
        void RecordKeyEvent(const WORD vkey);
        void Close();

#pragma region FrameworkElementAutomationPeer
        hstring GetClassNameCore() const;
        Windows::UI::Xaml::Automation::Peers::AutomationControlType GetAutomationControlTypeCore() const;
        hstring GetLocalizedControlTypeCore() const;
        Windows::Foundation::IInspectable GetPatternCore(Windows::UI:...",1,cascadia\TerminalControl\TermControlAutomationPeer.hpp,winrt.Microsoft.Terminal.Control.implementation,38,implementation,1
157459,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\XamlLights.cpp,cascadia\TerminalControl\XamlLights.cpp:<global>,,<global>,1
157463,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    DependencyProperty VisualBellLight::_IsTargetProperty{ nullptr };

    VisualBellLight::VisualBellLight()
    {
        _InitializeProperties();
    }

    void VisualBellLight::_InitializeProperties()
    {
        // Initialize any dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_IsTargetProperty)
        {
            _IsTargetProperty =
                DependencyProperty::RegisterAttached(
                    L""IsTarget"",
                    winrt::xaml_typename<bool>(),
                    winrt::xaml_typename<Control::VisualBellLight>(),
                    PropertyMetadata{ winrt::box_value(false), PropertyChangedCallback{ &VisualBellLight::OnIsTargetChanged } });
        }
    }

    // Method Description:
    // - This function is called when the first target UIElement is shown on the screen,
    /...",1,cascadia\TerminalControl\XamlLights.cpp,winrt,12,winrt,1
157464,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    DependencyProperty VisualBellLight::_IsTargetProperty{ nullptr };

    VisualBellLight::VisualBellLight()
    {
        _InitializeProperties();
    }

    void VisualBellLight::_InitializeProperties()
    {
        // Initialize any dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_IsTargetProperty)
        {
            _IsTargetProperty =
                DependencyProperty::RegisterAttached(
                    L""IsTarget"",
                    winrt::xaml_typename<bool>(),
                    winrt::xaml_typename<Control::VisualBellLight>(),
                    PropertyMetadata{ winrt::box_value(false), PropertyChangedCallback{ &VisualBellLight::OnIsTargetChanged } });
        }
    }

    // Method Description:
    // - This function is called when the first target UIElement is shown on the screen,
    /...",1,cascadia\TerminalControl\XamlLights.cpp,winrt.Microsoft,12,Microsoft,1
157465,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    DependencyProperty VisualBellLight::_IsTargetProperty{ nullptr };

    VisualBellLight::VisualBellLight()
    {
        _InitializeProperties();
    }

    void VisualBellLight::_InitializeProperties()
    {
        // Initialize any dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_IsTargetProperty)
        {
            _IsTargetProperty =
                DependencyProperty::RegisterAttached(
                    L""IsTarget"",
                    winrt::xaml_typename<bool>(),
                    winrt::xaml_typename<Control::VisualBellLight>(),
                    PropertyMetadata{ winrt::box_value(false), PropertyChangedCallback{ &VisualBellLight::OnIsTargetChanged } });
        }
    }

    // Method Description:
    // - This function is called when the first target UIElement is shown on the screen,
    /...",1,cascadia\TerminalControl\XamlLights.cpp,winrt.Microsoft.Terminal,12,Terminal,1
157466,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    DependencyProperty VisualBellLight::_IsTargetProperty{ nullptr };

    VisualBellLight::VisualBellLight()
    {
        _InitializeProperties();
    }

    void VisualBellLight::_InitializeProperties()
    {
        // Initialize any dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_IsTargetProperty)
        {
            _IsTargetProperty =
                DependencyProperty::RegisterAttached(
                    L""IsTarget"",
                    winrt::xaml_typename<bool>(),
                    winrt::xaml_typename<Control::VisualBellLight>(),
                    PropertyMetadata{ winrt::box_value(false), PropertyChangedCallback{ &VisualBellLight::OnIsTargetChanged } });
        }
    }

    // Method Description:
    // - This function is called when the first target UIElement is shown on the screen,
    /...",1,cascadia\TerminalControl\XamlLights.cpp,winrt.Microsoft.Terminal.Control,12,Control,1
157467,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    DependencyProperty VisualBellLight::_IsTargetProperty{ nullptr };

    VisualBellLight::VisualBellLight()
    {
        _InitializeProperties();
    }

    void VisualBellLight::_InitializeProperties()
    {
        // Initialize any dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_IsTargetProperty)
        {
            _IsTargetProperty =
                DependencyProperty::RegisterAttached(
                    L""IsTarget"",
                    winrt::xaml_typename<bool>(),
                    winrt::xaml_typename<Control::VisualBellLight>(),
                    PropertyMetadata{ winrt::box_value(false), PropertyChangedCallback{ &VisualBellLight::OnIsTargetChanged } });
        }
    }

    // Method Description:
    // - This function is called when the first target UIElement is shown on the screen,
    /...",1,cascadia\TerminalControl\XamlLights.cpp,winrt.Microsoft.Terminal.Control.implementation,12,implementation,1
157657,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\XamlLights.hpp,cascadia\TerminalControl\XamlLights.hpp:<global>,,<global>,1
157661,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct VisualBellLight : VisualBellLightT<VisualBellLight>
    {
        VisualBellLight();

        winrt::hstring GetId();

        static Windows::UI::Xaml::DependencyProperty IsTargetProperty() { return _IsTargetProperty; }

        static bool GetIsTarget(const Windows::UI::Xaml::DependencyObject& target)
        {
            return winrt::unbox_value<bool>(target.GetValue(_IsTargetProperty));
        }

        static void SetIsTarget(const Windows::UI::Xaml::DependencyObject& target, bool value)
        {
            target.SetValue(_IsTargetProperty, winrt::box_value(value));
        }

        void OnConnected(const Windows::UI::Xaml::UIElement& newElement);
        void OnDisconnected(const Windows::UI::Xaml::UIElement& oldElement);

        static void OnIsTargetChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);

        inline static wi...",1,cascadia\TerminalControl\XamlLights.hpp,winrt,8,winrt,1
157662,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct VisualBellLight : VisualBellLightT<VisualBellLight>
    {
        VisualBellLight();

        winrt::hstring GetId();

        static Windows::UI::Xaml::DependencyProperty IsTargetProperty() { return _IsTargetProperty; }

        static bool GetIsTarget(const Windows::UI::Xaml::DependencyObject& target)
        {
            return winrt::unbox_value<bool>(target.GetValue(_IsTargetProperty));
        }

        static void SetIsTarget(const Windows::UI::Xaml::DependencyObject& target, bool value)
        {
            target.SetValue(_IsTargetProperty, winrt::box_value(value));
        }

        void OnConnected(const Windows::UI::Xaml::UIElement& newElement);
        void OnDisconnected(const Windows::UI::Xaml::UIElement& oldElement);

        static void OnIsTargetChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);

        inline static wi...",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft,8,Microsoft,1
157663,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct VisualBellLight : VisualBellLightT<VisualBellLight>
    {
        VisualBellLight();

        winrt::hstring GetId();

        static Windows::UI::Xaml::DependencyProperty IsTargetProperty() { return _IsTargetProperty; }

        static bool GetIsTarget(const Windows::UI::Xaml::DependencyObject& target)
        {
            return winrt::unbox_value<bool>(target.GetValue(_IsTargetProperty));
        }

        static void SetIsTarget(const Windows::UI::Xaml::DependencyObject& target, bool value)
        {
            target.SetValue(_IsTargetProperty, winrt::box_value(value));
        }

        void OnConnected(const Windows::UI::Xaml::UIElement& newElement);
        void OnDisconnected(const Windows::UI::Xaml::UIElement& oldElement);

        static void OnIsTargetChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);

        inline static wi...",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal,8,Terminal,1
157664,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct VisualBellLight : VisualBellLightT<VisualBellLight>
    {
        VisualBellLight();

        winrt::hstring GetId();

        static Windows::UI::Xaml::DependencyProperty IsTargetProperty() { return _IsTargetProperty; }

        static bool GetIsTarget(const Windows::UI::Xaml::DependencyObject& target)
        {
            return winrt::unbox_value<bool>(target.GetValue(_IsTargetProperty));
        }

        static void SetIsTarget(const Windows::UI::Xaml::DependencyObject& target, bool value)
        {
            target.SetValue(_IsTargetProperty, winrt::box_value(value));
        }

        void OnConnected(const Windows::UI::Xaml::UIElement& newElement);
        void OnDisconnected(const Windows::UI::Xaml::UIElement& oldElement);

        static void OnIsTargetChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);

        inline static wi...",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal.Control,8,Control,1
157665,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    struct VisualBellLight : VisualBellLightT<VisualBellLight>
    {
        VisualBellLight();

        winrt::hstring GetId();

        static Windows::UI::Xaml::DependencyProperty IsTargetProperty() { return _IsTargetProperty; }

        static bool GetIsTarget(const Windows::UI::Xaml::DependencyObject& target)
        {
            return winrt::unbox_value<bool>(target.GetValue(_IsTargetProperty));
        }

        static void SetIsTarget(const Windows::UI::Xaml::DependencyObject& target, bool value)
        {
            target.SetValue(_IsTargetProperty, winrt::box_value(value));
        }

        void OnConnected(const Windows::UI::Xaml::UIElement& newElement);
        void OnDisconnected(const Windows::UI::Xaml::UIElement& oldElement);

        static void OnIsTargetChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);

        inline static wi...",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal.Control.implementation,8,implementation,1
157744,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(VisualBellLight);
}",1,cascadia\TerminalControl\XamlLights.hpp,winrt,45,winrt,2
157745,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(VisualBellLight);
}",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft,45,Microsoft,1
157746,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(VisualBellLight);
}",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal,45,Terminal,1
157747,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(VisualBellLight);
}",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal.Control,45,Control,1
157748,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::factory_implementation
{
    BASIC_FACTORY(VisualBellLight);
}",1,cascadia\TerminalControl\XamlLights.hpp,winrt.Microsoft.Terminal.Control.factory_implementation,45,factory_implementation,1
157763,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\XamlUiaTextRange.cpp,cascadia\TerminalControl\XamlUiaTextRange.cpp:<global>,,<global>,1
157767,NAMESPACE_BLOCK,"namespace UIA
{
    using ::ITextRangeProvider;
    using ::SupportedTextSelection;
    using ::TextPatternRangeEndpoint;
    using ::TextUnit;
}",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,UIA,15,UIA,1
157768,NAMESPACE_BLOCK,"namespace XamlAutomation
{
    using winrt::Windows::UI::Xaml::Automation::SupportedTextSelection;
    using winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple;
    using winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider;
    using winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint;
    using winrt::Windows::UI::Xaml::Automation::Text::TextUnit;
}",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,XamlAutomation,23,XamlAutomation,2
157769,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    XamlAutomation::ITextRangeProvider XamlUiaTextRange::Clone() const
    {
        UIA::ITextRangeProvider* pReturn;
        THROW_IF_FAILED(_uiaProvider->Clone(&pReturn));
        auto xutr = winrt::make_self<XamlUiaTextRange>(pReturn, _parentProvider);
        return xutr.as<XamlAutomation::ITextRangeProvider>();
    }

    bool XamlUiaTextRange::Compare(XamlAutomation::ITextRangeProvider pRange) const
    {
        auto self = winrt::get_self<XamlUiaTextRange>(pRange);

        BOOL returnVal;
        THROW_IF_FAILED(_uiaProvider->Compare(self->_uiaProvider.get(), &returnVal));
        return returnVal;
    }

    int32_t XamlUiaTextRange::CompareEndpoints(XamlAutomation::TextPatternRangeEndpoint endpoint,
                                               XamlAutomation::ITextRangeProvider pTargetRange,
                                               XamlAutomation::TextPatternRangeEndpoint targetEndpoint)
    {
      ...",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,winrt,32,winrt,3
157770,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    XamlAutomation::ITextRangeProvider XamlUiaTextRange::Clone() const
    {
        UIA::ITextRangeProvider* pReturn;
        THROW_IF_FAILED(_uiaProvider->Clone(&pReturn));
        auto xutr = winrt::make_self<XamlUiaTextRange>(pReturn, _parentProvider);
        return xutr.as<XamlAutomation::ITextRangeProvider>();
    }

    bool XamlUiaTextRange::Compare(XamlAutomation::ITextRangeProvider pRange) const
    {
        auto self = winrt::get_self<XamlUiaTextRange>(pRange);

        BOOL returnVal;
        THROW_IF_FAILED(_uiaProvider->Compare(self->_uiaProvider.get(), &returnVal));
        return returnVal;
    }

    int32_t XamlUiaTextRange::CompareEndpoints(XamlAutomation::TextPatternRangeEndpoint endpoint,
                                               XamlAutomation::ITextRangeProvider pTargetRange,
                                               XamlAutomation::TextPatternRangeEndpoint targetEndpoint)
    {
      ...",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,winrt.Microsoft,32,Microsoft,1
157771,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    XamlAutomation::ITextRangeProvider XamlUiaTextRange::Clone() const
    {
        UIA::ITextRangeProvider* pReturn;
        THROW_IF_FAILED(_uiaProvider->Clone(&pReturn));
        auto xutr = winrt::make_self<XamlUiaTextRange>(pReturn, _parentProvider);
        return xutr.as<XamlAutomation::ITextRangeProvider>();
    }

    bool XamlUiaTextRange::Compare(XamlAutomation::ITextRangeProvider pRange) const
    {
        auto self = winrt::get_self<XamlUiaTextRange>(pRange);

        BOOL returnVal;
        THROW_IF_FAILED(_uiaProvider->Compare(self->_uiaProvider.get(), &returnVal));
        return returnVal;
    }

    int32_t XamlUiaTextRange::CompareEndpoints(XamlAutomation::TextPatternRangeEndpoint endpoint,
                                               XamlAutomation::ITextRangeProvider pTargetRange,
                                               XamlAutomation::TextPatternRangeEndpoint targetEndpoint)
    {
      ...",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,winrt.Microsoft.Terminal,32,Terminal,1
157772,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    XamlAutomation::ITextRangeProvider XamlUiaTextRange::Clone() const
    {
        UIA::ITextRangeProvider* pReturn;
        THROW_IF_FAILED(_uiaProvider->Clone(&pReturn));
        auto xutr = winrt::make_self<XamlUiaTextRange>(pReturn, _parentProvider);
        return xutr.as<XamlAutomation::ITextRangeProvider>();
    }

    bool XamlUiaTextRange::Compare(XamlAutomation::ITextRangeProvider pRange) const
    {
        auto self = winrt::get_self<XamlUiaTextRange>(pRange);

        BOOL returnVal;
        THROW_IF_FAILED(_uiaProvider->Compare(self->_uiaProvider.get(), &returnVal));
        return returnVal;
    }

    int32_t XamlUiaTextRange::CompareEndpoints(XamlAutomation::TextPatternRangeEndpoint endpoint,
                                               XamlAutomation::ITextRangeProvider pTargetRange,
                                               XamlAutomation::TextPatternRangeEndpoint targetEndpoint)
    {
      ...",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,winrt.Microsoft.Terminal.Control,32,Control,1
157773,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    XamlAutomation::ITextRangeProvider XamlUiaTextRange::Clone() const
    {
        UIA::ITextRangeProvider* pReturn;
        THROW_IF_FAILED(_uiaProvider->Clone(&pReturn));
        auto xutr = winrt::make_self<XamlUiaTextRange>(pReturn, _parentProvider);
        return xutr.as<XamlAutomation::ITextRangeProvider>();
    }

    bool XamlUiaTextRange::Compare(XamlAutomation::ITextRangeProvider pRange) const
    {
        auto self = winrt::get_self<XamlUiaTextRange>(pRange);

        BOOL returnVal;
        THROW_IF_FAILED(_uiaProvider->Compare(self->_uiaProvider.get(), &returnVal));
        return returnVal;
    }

    int32_t XamlUiaTextRange::CompareEndpoints(XamlAutomation::TextPatternRangeEndpoint endpoint,
                                               XamlAutomation::ITextRangeProvider pTargetRange,
                                               XamlAutomation::TextPatternRangeEndpoint targetEndpoint)
    {
      ...",1,cascadia\TerminalControl\XamlUiaTextRange.cpp,winrt.Microsoft.Terminal.Control.implementation,32,implementation,1
158316,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\XamlUiaTextRange.hpp,cascadia\TerminalControl\XamlUiaTextRange.hpp:<global>,,<global>,1
158320,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    class XamlUiaTextRange :
        public winrt::implements<XamlUiaTextRange, Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
    public:
        XamlUiaTextRange(::ITextRangeProvider* uiaProvider, Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple parentProvider) :
            _parentProvider{ parentProvider }
        {
            _uiaProvider.attach(uiaProvider);
        }

#pragma region ITextRangeProvider
        Windows::UI::Xaml::Automation::Provider::ITextRangeProvider Clone() const;
        bool Compare(Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pRange) const;
        int32_t CompareEndpoints(Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint endpoint,
                                 Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pTargetRange,
                                 Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpo...",1,cascadia\TerminalControl\XamlUiaTextRange.hpp,winrt,27,winrt,1
158321,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    class XamlUiaTextRange :
        public winrt::implements<XamlUiaTextRange, Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
    public:
        XamlUiaTextRange(::ITextRangeProvider* uiaProvider, Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple parentProvider) :
            _parentProvider{ parentProvider }
        {
            _uiaProvider.attach(uiaProvider);
        }

#pragma region ITextRangeProvider
        Windows::UI::Xaml::Automation::Provider::ITextRangeProvider Clone() const;
        bool Compare(Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pRange) const;
        int32_t CompareEndpoints(Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint endpoint,
                                 Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pTargetRange,
                                 Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpo...",1,cascadia\TerminalControl\XamlUiaTextRange.hpp,winrt.Microsoft,27,Microsoft,1
158322,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    class XamlUiaTextRange :
        public winrt::implements<XamlUiaTextRange, Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
    public:
        XamlUiaTextRange(::ITextRangeProvider* uiaProvider, Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple parentProvider) :
            _parentProvider{ parentProvider }
        {
            _uiaProvider.attach(uiaProvider);
        }

#pragma region ITextRangeProvider
        Windows::UI::Xaml::Automation::Provider::ITextRangeProvider Clone() const;
        bool Compare(Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pRange) const;
        int32_t CompareEndpoints(Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint endpoint,
                                 Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pTargetRange,
                                 Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpo...",1,cascadia\TerminalControl\XamlUiaTextRange.hpp,winrt.Microsoft.Terminal,27,Terminal,1
158323,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    class XamlUiaTextRange :
        public winrt::implements<XamlUiaTextRange, Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
    public:
        XamlUiaTextRange(::ITextRangeProvider* uiaProvider, Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple parentProvider) :
            _parentProvider{ parentProvider }
        {
            _uiaProvider.attach(uiaProvider);
        }

#pragma region ITextRangeProvider
        Windows::UI::Xaml::Automation::Provider::ITextRangeProvider Clone() const;
        bool Compare(Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pRange) const;
        int32_t CompareEndpoints(Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint endpoint,
                                 Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pTargetRange,
                                 Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpo...",1,cascadia\TerminalControl\XamlUiaTextRange.hpp,winrt.Microsoft.Terminal.Control,27,Control,1
158324,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Control::implementation
{
    class XamlUiaTextRange :
        public winrt::implements<XamlUiaTextRange, Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
    public:
        XamlUiaTextRange(::ITextRangeProvider* uiaProvider, Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple parentProvider) :
            _parentProvider{ parentProvider }
        {
            _uiaProvider.attach(uiaProvider);
        }

#pragma region ITextRangeProvider
        Windows::UI::Xaml::Automation::Provider::ITextRangeProvider Clone() const;
        bool Compare(Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pRange) const;
        int32_t CompareEndpoints(Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint endpoint,
                                 Windows::UI::Xaml::Automation::Provider::ITextRangeProvider pTargetRange,
                                 Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpo...",1,cascadia\TerminalControl\XamlUiaTextRange.hpp,winrt.Microsoft.Terminal.Control.implementation,27,implementation,1
158437,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\dll\pch.cpp,cascadia\TerminalControl\dll\pch.cpp:<global>,,<global>,1
158442,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\dll\pch.hpp,cascadia\TerminalControl\dll\pch.hpp:<global>,,<global>,1
158455,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\init.cpp,cascadia\TerminalControl\init.cpp:<global>,,<global>,1
158503,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\pch.cpp,cascadia\TerminalControl\pch.cpp:<global>,,<global>,1
158600,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalControl\pch.hpp,cascadia\TerminalControl\pch.hpp:<global>,,<global>,1
158606,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\ControlKeyStates.hpp,cascadia\TerminalCore\ControlKeyStates.hpp:<global>,,<global>,1
158618,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalCore\ControlKeyStates.hpp,Microsoft,14,Microsoft,5
158619,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalCore\ControlKeyStates.hpp,Microsoft.Terminal,14,Terminal,1
158620,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ControlKeyStates;
}",1,cascadia\TerminalCore\ControlKeyStates.hpp,Microsoft.Terminal.Core,14,Core,1
158899,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\ITerminalInput.hpp,cascadia\TerminalCore\ITerminalInput.hpp:<global>,,<global>,1
158903,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ITerminalInput
    {
    public:
        virtual ~ITerminalInput() {}
        ITerminalInput(const ITerminalInput&) = default;
        ITerminalInput(ITerminalInput&&) = default;
        ITerminalInput& operator=(const ITerminalInput&) = default;
        ITerminalInput& operator=(ITerminalInput&&) = default;

        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendKeyEvent(const WORD vkey, const WORD scanCode, const ControlKeyStates states, const bool keyDown) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendMouseEvent(const til::point viewportPos, const unsigned int uiButton, const ControlKeyStates states, const short wheelDelta, const Microsoft::Console::VirtualTerminal::TerminalInput::MouseButtonState state) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendCharEvent(const wchar_t ch...",1,cascadia\TerminalCore\ITerminalInput.hpp,Microsoft,8,Microsoft,1
158904,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ITerminalInput
    {
    public:
        virtual ~ITerminalInput() {}
        ITerminalInput(const ITerminalInput&) = default;
        ITerminalInput(ITerminalInput&&) = default;
        ITerminalInput& operator=(const ITerminalInput&) = default;
        ITerminalInput& operator=(ITerminalInput&&) = default;

        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendKeyEvent(const WORD vkey, const WORD scanCode, const ControlKeyStates states, const bool keyDown) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendMouseEvent(const til::point viewportPos, const unsigned int uiButton, const ControlKeyStates states, const short wheelDelta, const Microsoft::Console::VirtualTerminal::TerminalInput::MouseButtonState state) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendCharEvent(const wchar_t ch...",1,cascadia\TerminalCore\ITerminalInput.hpp,Microsoft.Terminal,8,Terminal,1
158905,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class ITerminalInput
    {
    public:
        virtual ~ITerminalInput() {}
        ITerminalInput(const ITerminalInput&) = default;
        ITerminalInput(ITerminalInput&&) = default;
        ITerminalInput& operator=(const ITerminalInput&) = default;
        ITerminalInput& operator=(ITerminalInput&&) = default;

        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendKeyEvent(const WORD vkey, const WORD scanCode, const ControlKeyStates states, const bool keyDown) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendMouseEvent(const til::point viewportPos, const unsigned int uiButton, const ControlKeyStates states, const short wheelDelta, const Microsoft::Console::VirtualTerminal::TerminalInput::MouseButtonState state) = 0;
        virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendCharEvent(const wchar_t ch...",1,cascadia\TerminalCore\ITerminalInput.hpp,Microsoft.Terminal.Core,8,Core,1
159073,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\Terminal.cpp,cascadia\TerminalCore\Terminal.cpp:<global>,,<global>,1
162279,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\Terminal.hpp,cascadia\TerminalCore\Terminal.hpp:<global>,,<global>,1
162288,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Core
{
    struct ICoreSettings;
    struct ICoreAppearance;
    struct Scheme;
    enum class MatchMode;
}",1,cascadia\TerminalCore\Terminal.hpp,winrt,26,winrt,3
162289,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Core
{
    struct ICoreSettings;
    struct ICoreAppearance;
    struct Scheme;
    enum class MatchMode;
}",1,cascadia\TerminalCore\Terminal.hpp,winrt.Microsoft,26,Microsoft,1
162290,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Core
{
    struct ICoreSettings;
    struct ICoreAppearance;
    struct Scheme;
    enum class MatchMode;
}",1,cascadia\TerminalCore\Terminal.hpp,winrt.Microsoft.Terminal,26,Terminal,1
162291,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Core
{
    struct ICoreSettings;
    struct ICoreAppearance;
    struct Scheme;
    enum class MatchMode;
}",1,cascadia\TerminalCore\Terminal.hpp,winrt.Microsoft.Terminal.Core,26,Core,1
162296,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft,34,Microsoft,4
162297,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft.Console,34,Console,1
162298,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft.Console.VirtualTerminal,34,VirtualTerminal,1
162300,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class Terminal;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft,39,Microsoft,5
162301,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class Terminal;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft.Terminal,39,Terminal,1
162302,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Core
{
    class Terminal;
}",1,cascadia\TerminalCore\Terminal.hpp,Microsoft.Terminal.Core,39,Core,1
163349,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\TerminalApi.cpp,cascadia\TerminalCore\TerminalApi.cpp:<global>,,<global>,1
164417,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\TerminalSelection.cpp,cascadia\TerminalCore\TerminalSelection.cpp:<global>,,<global>,1
166536,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\pch.cpp,cascadia\TerminalCore\pch.cpp:<global>,,<global>,1
166549,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\pch.hpp,cascadia\TerminalCore\pch.hpp:<global>,,<global>,1
166560,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\terminalrenderdata.cpp,cascadia\TerminalCore\terminalrenderdata.cpp:<global>,,<global>,1
166973,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalCore\tracing.hpp,cascadia\TerminalCore\tracing.hpp:<global>,,<global>,1
167238,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Actions.cpp,cascadia\TerminalSettingsEditor\Actions.cpp:<global>,,<global>,1
167241,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt,22,winrt,1
167242,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt.Microsoft,22,Microsoft,1
167243,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt.Microsoft.Terminal,22,Terminal,1
167244,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
167245,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt.Microsoft.Terminal.Settings.Editor,22,Editor,1
167246,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    KeyBindingViewModel::KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions) :
        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}

    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :
        _CurrentKeys{ keys },
        _KeyChordText{ KeyChordSerialization::ToString(keys) },
        _CurrentAction{ actionName },
        _ProposedAction{ box_value(actionName) },
        _AvailableActions{ availableActions }
    {
        // Add a property changed handler to our own property changed event.
        // This propagates changes from the settings model to anybody listening to our
        //  unique view model members.
        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {
            const auto ...",1,cascadia\TerminalSettingsEditor\Actions.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,22,implementation,1
168255,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Actions.hpp,cascadia\TerminalSettingsEditor\Actions.hpp:<global>,,<global>,1
168259,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt,13,winrt,1
168260,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft,13,Microsoft,1
168261,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal,13,Terminal,1
168262,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings,13,Settings,1
168263,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings.Editor,13,Editor,1
168264,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyBindingViewModelComparator
    {
        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const
        {
            return lhs.Name() < rhs.Name();
        }
    };

    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>
    {
    public:
        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :
            _OldKeys{ oldKeys },
            _NewKeys{ newKeys },
            _OldActionName{ std::move(oldActionName) },
            _NewActionName{ std::move(newActionName) } {}

        WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);
        WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);
        WINRT_PROPERTY(hstring, OldActionName);
        WINRT_PROPERTY(hstring, NewActionName);
    };

    struct KeyB...",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,13,implementation,1
168791,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt,138,winrt,2
168792,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft,138,Microsoft,1
168793,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal,138,Terminal,1
168794,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings,138,Settings,1
168795,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings.Editor,138,Editor,1
168796,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Actions);
}",1,cascadia\TerminalSettingsEditor\Actions.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,138,factory_implementation,1
168811,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\AddProfile.cpp,cascadia\TerminalSettingsEditor\AddProfile.cpp:<global>,,<global>,1
168815,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt,19,winrt,1
168816,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt.Microsoft,19,Microsoft,1
168817,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt.Microsoft.Terminal,19,Terminal,1
168818,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt.Microsoft.Terminal.Settings,19,Settings,1
168819,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt.Microsoft.Terminal.Settings.Editor,19,Editor,1
168820,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    AddProfile::AddProfile()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""AddProfile_AddNewTextBlock/Text""));
        Automation::AutomationProperties::SetName(DuplicateButton(), RS_(L""AddProfile_DuplicateTextBlock/Text""));
    }

    void AddProfile::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _State = e.Parameter().as<Editor::AddProfilePageNavigationState>();
    }

    void AddProfile::AddNewClick(const IInspectable& /*sender*/,
                                 const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        _State.RequestAddNew();
    }

    void AddProfile::DuplicateClick(const IInspectable& /*sender*/,
                                    const Windows::UI::Xaml::RoutedEventArgs& /*eventArgs*/)
    {
        if (const auto selected = Profiles().SelectedItem())
        {
            _State.RequestDuplicate(...",1,cascadia\TerminalSettingsEditor\AddProfile.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,19,implementation,1
168914,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\AddProfile.hpp,cascadia\TerminalSettingsEditor\AddProfile.hpp:<global>,,<global>,1
168918,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt,24,winrt,1
168919,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft,24,Microsoft,1
168920,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal,24,Terminal,1
168921,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings,24,Settings,1
168922,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings.Editor,24,Editor,1
168923,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct AddProfilePageNavigationState : AddProfilePageNavigationStateT<AddProfilePageNavigationState>
    {
    public:
        AddProfilePageNavigationState(const Model::CascadiaSettings& settings) :
            _Settings{ settings } {}

        void RequestAddNew()
        {
            _AddNewHandlers(winrt::guid{});
        }

        void RequestDuplicate(GUID profile)
        {
            _AddNewHandlers(profile);
        }

        WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);
    };

    struct AddProfile : public HasScrollViewer<AddProfile>, AddProfileT<AddProfile>
    {
    public:
        AddProfile();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNewClick(const IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& eventArgs);
        void DuplicateClick(const IIn...",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,24,implementation,1
168976,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt,63,winrt,2
168977,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft,63,Microsoft,1
168978,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal,63,Terminal,1
168979,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings,63,Settings,1
168980,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings.Editor,63,Editor,1
168981,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(AddProfile);
}",1,cascadia\TerminalSettingsEditor\AddProfile.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,63,factory_implementation,1
169190,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Appearances.cpp,cascadia\TerminalSettingsEditor\Appearances.cpp:<global>,,<global>,1
169193,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt,21,winrt,1
169194,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt.Microsoft,21,Microsoft,1
169195,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt.Microsoft.Terminal,21,Terminal,1
169196,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
169197,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt.Microsoft.Terminal.Settings.Editor,21,Editor,1
169198,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    bool Font::HasPowerlineCharacters()
    {
        if (!_hasPowerlineCharacters.has_value())
        {
            try
            {
                winrt::com_ptr<IDWriteFont> font;
                THROW_IF_FAILED(_family->GetFont(0, font.put()));
                BOOL exists{};
                // We're actually checking for the ""Extended"" PowerLine glyph set.
                // They're more fun.
                THROW_IF_FAILED(font->HasCharacter(0xE0B6, &exists));
                _hasPowerlineCharacters = (exists == TRUE);
            }
            catch (...)
            {
                _hasPowerlineCharacters = false;
            }
        }
        return _hasPowerlineCharacters.value_or(false);
    }

    AppearanceViewModel::AppearanceViewModel(const Model::AppearanceConfig& appearance) :
        _appearance{ appearance }
    {
        // Add a property changed handler to our own property changed eve...",1,cascadia\TerminalSettingsEditor\Appearances.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,21,implementation,1
171023,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Appearances.hpp,cascadia\TerminalSettingsEditor\Appearances.hpp:<global>,,<global>,1
171027,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt,26,winrt,1
171028,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft,26,Microsoft,1
171029,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal,26,Terminal,1
171030,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings,26,Settings,1
171031,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings.Editor,26,Editor,1
171032,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct FontComparator
    {
        bool operator()(const Font& lhs, const Font& rhs) const
        {
            return lhs.LocalizedName() < rhs.LocalizedName();
        }
    };

    struct Font : FontT<Font>
    {
    public:
        Font(std::wstring name, std::wstring localizedName, IDWriteFontFamily* family) :
            _Name{ name },
            _LocalizedName{ localizedName }
        {
            _family.copy_from(family);
        }

        hstring ToString() { return _LocalizedName; }
        bool HasPowerlineCharacters();

        WINRT_PROPERTY(hstring, Name);
        WINRT_PROPERTY(hstring, LocalizedName);

    private:
        winrt::com_ptr<IDWriteFontFamily> _family;
        std::optional<bool> _hasPowerlineCharacters;
    };

    struct AppearanceViewModel : AppearanceViewModelT<AppearanceViewModel>, ViewModelHelper<AppearanceViewModel>
    {
    public:
        AppearanceViewModel(cons...",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,26,implementation,1
172571,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt,160,winrt,2
172572,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft,160,Microsoft,1
172573,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal,160,Terminal,1
172574,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings,160,Settings,1
172575,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings.Editor,160,Editor,1
172576,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Appearances);
}",1,cascadia\TerminalSettingsEditor\Appearances.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,160,factory_implementation,1
172589,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp:<global>,,<global>,1
172593,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt,11,winrt,1
172594,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt.Microsoft,11,Microsoft,1
172595,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt.Microsoft.Terminal,11,Terminal,1
172596,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
172597,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
172598,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemeViewModel::ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings) :
        _scheme{ scheme },
        _settings{ settings },
        _NonBrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _BrightColorTable{ single_threaded_observable_vector<Editor::ColorTableEntry>() },
        _parentPageVM{ parentPageVM }
    {
        _Name = scheme.Name();

        for (uint8_t i = 0; i < ColorTableSize; ++i)
        {
            til::color currentColor{ scheme.Table()[i] };
            const auto& entry{ winrt::make<ColorTableEntry>(i, currentColor) };
            entry.PropertyChanged({ get_weak(), &ColorSchemeViewModel::_ColorEntryChangedHandler });
            if (i < ColorTableDivider)
            {
                _NonBrightColorTable.Append(entry);
            }
       ...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
173209,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp:<global>,,<global>,1
173213,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt,11,winrt,1
173214,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt.Microsoft,11,Microsoft,1
173215,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt.Microsoft.Terminal,11,Terminal,1
173216,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
173217,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
173218,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline constexpr uint8_t ColorTableDivider{ 8 };
    inline constexpr uint8_t ColorTableSize{ 16 };

    inline constexpr std::wstring_view ForegroundColorTag{ L""Foreground"" };
    inline constexpr std::wstring_view BackgroundColorTag{ L""Background"" };
    inline constexpr std::wstring_view CursorColorTag{ L""CursorColor"" };
    inline constexpr std::wstring_view SelectionBackgroundColorTag{ L""SelectionBackground"" };

    struct ColorSchemeViewModel : ColorSchemeViewModelT<ColorSchemeViewModel>, ViewModelHelper<ColorSchemeViewModel>
    {
    public:
        ColorSchemeViewModel(const Model::ColorScheme scheme, const Editor::ColorSchemesPageViewModel parentPageVM, const Model::CascadiaSettings& settings);

        winrt::hstring Name();
        void Name(winrt::hstring newName);
        hstring ToString();

        bool RequestRename(winrt::hstring newName);

        Editor::ColorTableEntry ColorEntryAt(uint...",1,cascadia\TerminalSettingsEditor\ColorSchemeViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
173402,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,cascadia\TerminalSettingsEditor\ColorSchemes.cpp:<global>,,<global>,1
173405,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt,21,winrt,1
173406,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,Microsoft.UI.Xaml,23,MUX,1
173407,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,Windows.UI.Xaml,24,WUX,2
173408,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt,27,winrt,2
173409,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt.Microsoft,27,Microsoft,1
173410,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt.Microsoft.Terminal,27,Terminal,1
173411,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt.Microsoft.Terminal.Settings,27,Settings,1
173412,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt.Microsoft.Terminal.Settings.Editor,27,Editor,1
173413,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    ColorSchemes::ColorSchemes()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(AddNewButton(), RS_(L""ColorScheme_AddNewButton/Text""));
    }

    void ColorSchemes::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::ColorSchemesPageViewModel>();
        _ViewModel.CurrentPage(ColorSchemesSubPage::Base);

        _layoutUpdatedRevoker = LayoutUpdated(winrt::auto_revoke, [this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        });
    }

    void ColorSchemes::AddNew_Click(const IInspectable& /*sender*/, const RoutedEventArgs& /*e*/)
    {
        if (const auto newSchemeVM{ _ViewModel.RequestAddNew() })
        {
            ColorSchemeListView().SelectedItem(newSchemeVM);
            _View...",1,cascadia\TerminalSettingsEditor\ColorSchemes.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,27,implementation,1
173524,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,cascadia\TerminalSettingsEditor\ColorSchemes.hpp:<global>,,<global>,1
173528,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt,12,winrt,1
173529,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft,12,Microsoft,1
173530,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal,12,Terminal,1
173531,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings,12,Settings,1
173532,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings.Editor,12,Editor,1
173533,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemes : public HasScrollViewer<ColorSchemes>, ColorSchemesT<ColorSchemes>
    {
    public:
        ColorSchemes();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void AddNew_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void ListView_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);
        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);

    private:
        winrt::Windows::UI::Xaml::FrameworkElement::LayoutUpdated_revoker _layoutUpdatedRevoker;
    ...",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,12,implementation,1
173560,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt,34,winrt,2
173561,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft,34,Microsoft,1
173562,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal,34,Terminal,1
173563,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings,34,Settings,1
173564,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings.Editor,34,Editor,1
173565,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemes);
}",1,cascadia\TerminalSettingsEditor\ColorSchemes.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,34,factory_implementation,1
173574,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp:<global>,,<global>,1
173578,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt,8,winrt,1
173579,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt.Microsoft,8,Microsoft,1
173580,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt.Microsoft.Terminal,8,Terminal,1
173581,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt.Microsoft.Terminal.Settings,8,Settings,1
173582,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,8,Editor,1
173583,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    inline static constexpr std::array<std::wstring_view, 9> InBoxSchemes = {
        L""Campbell"",
        L""Campbell Powershell"",
        L""Vintage"",
        L""One Half Dark"",
        L""One Half Light"",
        L""Solarized Dark"",
        L""Solarized Light"",
        L""Tango Dark"",
        L""Tango Light""
    };

    ColorSchemesPageViewModel::ColorSchemesPageViewModel(const Model::CascadiaSettings& settings) :
        _settings{ settings },
        _viewModelToSchemeMap{ winrt::single_threaded_map<Editor::ColorSchemeViewModel, Model::ColorScheme>() }
    {
        _MakeColorSchemeVMsHelper();
    }

    void ColorSchemesPageViewModel::UpdateSettings(const Model::CascadiaSettings& settings)
    {
        _settings = settings;

        // We want to re-initialize our AllColorSchemes list, but we want to make sure
        // we still have the same CurrentScheme as before (if that scheme still exists)

        // St...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,8,implementation,1
174166,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp:<global>,,<global>,1
174170,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt,12,winrt,1
174171,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft,12,Microsoft,1
174172,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal,12,Terminal,1
174173,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings,12,Settings,1
174174,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,12,Editor,1
174175,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct ColorSchemesPageViewModel : ColorSchemesPageViewModelT<ColorSchemesPageViewModel>, ViewModelHelper<ColorSchemesPageViewModel>
    {
    public:
        ColorSchemesPageViewModel(const Model::CascadiaSettings& settings);
        void UpdateSettings(const Model::CascadiaSettings& settings);

        void CurrentScheme(const Editor::ColorSchemeViewModel& newSelectedScheme);
        Editor::ColorSchemeViewModel CurrentScheme();
        bool HasCurrentScheme() const noexcept;

        Editor::ColorSchemeViewModel RequestAddNew();
        bool RequestRenameCurrentScheme(winrt::hstring newName);
        void RequestDeleteCurrentScheme();
        void RequestEditSelectedScheme();
        void RequestSetSelectedSchemeAsDefault();

        bool CanDeleteCurrentScheme() const;

        void SchemeListItemClicked(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Controls::It...",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,12,implementation,1
174248,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt,49,winrt,2
174249,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft,49,Microsoft,1
174250,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal,49,Terminal,1
174251,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings,49,Settings,1
174252,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,49,Editor,1
174253,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(ColorSchemesPageViewModel);
}",1,cascadia\TerminalSettingsEditor\ColorSchemesPageViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,49,factory_implementation,1
174262,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Converters.cpp,cascadia\TerminalSettingsEditor\Converters.cpp:<global>,,<global>,1
174266,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt,7,winrt,1
174267,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt.Microsoft,7,Microsoft,1
174268,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt.Microsoft.Terminal,7,Terminal,1
174269,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt.Microsoft.Terminal.Settings,7,Settings,1
174270,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt.Microsoft.Terminal.Settings.Editor,7,Editor,1
174271,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    winrt::hstring Converters::AppendPercentageSign(double value)
    {
        const auto number{ value };
        return to_hstring((int)number) + L""%"";
    }

    winrt::Windows::UI::Xaml::Media::SolidColorBrush Converters::ColorToBrush(winrt::Windows::UI::Color color)
    {
        return Windows::UI::Xaml::Media::SolidColorBrush(color);
    }

    winrt::Windows::UI::Text::FontWeight Converters::DoubleToFontWeight(double value)
    {
        return winrt::Windows::UI::Text::FontWeight{ base::ClampedNumeric<uint16_t>(value) };
    }

    double Converters::FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight)
    {
        return fontWeight.Weight;
    }

    bool Converters::InvertBoolean(bool value)
    {
        return !value;
    }

    winrt::Windows::UI::Xaml::Visibility Converters::InvertedBooleanToVisibility(bool value)
    {
        return value ? winrt::Windows::UI::Xaml::Visibility:...",1,cascadia\TerminalSettingsEditor\Converters.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,7,implementation,1
174510,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Converters.hpp,cascadia\TerminalSettingsEditor\Converters.hpp:<global>,,<global>,1
174514,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt,8,winrt,1
174515,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft,8,Microsoft,1
174516,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal,8,Terminal,1
174517,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings,8,Settings,1
174518,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings.Editor,8,Editor,1
174519,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Converters : ConvertersT<Converters>
    {
        static winrt::hstring AppendPercentageSign(double value);
        static winrt::Windows::UI::Text::FontWeight DoubleToFontWeight(double value);
        static winrt::Windows::UI::Xaml::Media::SolidColorBrush ColorToBrush(winrt::Windows::UI::Color color);
        static double FontWeightToDouble(winrt::Windows::UI::Text::FontWeight fontWeight);
        static bool InvertBoolean(bool value);
        static winrt::Windows::UI::Xaml::Visibility InvertedBooleanToVisibility(bool value);
        static double MaxValueFromPaddingString(winrt::hstring paddingString);
        static int PercentageToPercentageValue(double value);
        static double PercentageValueToPercentage(double value);
        static bool StringsAreNotEqual(winrt::hstring expected, winrt::hstring actual);
        static winrt::Windows::UI::Xaml::Visibility StringNotEmptyToVisibility(win...",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,8,implementation,1
174583,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt,27,winrt,2
174584,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft,27,Microsoft,1
174585,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal,27,Terminal,1
174586,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings,27,Settings,1
174587,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings.Editor,27,Editor,1
174588,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Converters);
}",1,cascadia\TerminalSettingsEditor\Converters.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,27,factory_implementation,1
174599,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,cascadia\TerminalSettingsEditor\EditColorScheme.cpp:<global>,,<global>,1
174603,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt,20,winrt,1
174604,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,Microsoft.UI.Xaml,22,MUX,1
174605,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,Windows.UI.Xaml,23,WUX,2
174606,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt,26,winrt,2
174607,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt.Microsoft,26,Microsoft,1
174608,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt.Microsoft.Terminal,26,Terminal,1
174609,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt.Microsoft.Terminal.Settings,26,Settings,1
174610,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt.Microsoft.Terminal.Settings.Editor,26,Editor,1
174611,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    EditColorScheme::EditColorScheme()
    {
        InitializeComponent();

        Automation::AutomationProperties::SetName(NameBox(), RS_(L""ColorScheme_Name/Header""));
        Automation::AutomationProperties::SetFullDescription(NameBox(), RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        ToolTipService::SetToolTip(NameBox(), box_value(RS_(L""ColorScheme_Name/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip"")));
        Automation::AutomationProperties::SetName(RenameAcceptButton(), RS_(L""RenameAccept/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(RenameCancelButton(), RS_(L""RenameCancel/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetName(SetAsDefaultButton(), RS_(L""ColorScheme_SetAsDefault/Header""));
        Automation::AutomationProperties::Set...",1,cascadia\TerminalSettingsEditor\EditColorScheme.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,26,implementation,1
175025,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,cascadia\TerminalSettingsEditor\EditColorScheme.hpp:<global>,,<global>,1
175029,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt,10,winrt,1
175030,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft,10,Microsoft,1
175031,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal,10,Terminal,1
175032,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
175033,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
175034,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct EditColorScheme : public HasScrollViewer<EditColorScheme>, EditColorSchemeT<EditColorScheme>
    {
        EditColorScheme();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void ColorPickerChanged(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs& args);
        void RenameAccept_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void RenameCancel_Click(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::RoutedEventArgs& e);
        void NameBox_PreviewKeyDown(const winrt::Windows::Foundation::IInspectable& sender, const winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChang...",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
175076,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt,32,winrt,2
175077,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft,32,Microsoft,1
175078,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal,32,Terminal,1
175079,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings,32,Settings,1
175080,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Editor,32,Editor,1
175081,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(EditColorScheme);
}",1,cascadia\TerminalSettingsEditor\EditColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,32,factory_implementation,1
175088,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\EnumEntry.hpp,cascadia\TerminalSettingsEditor\EnumEntry.hpp:<global>,,<global>,1
175092,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt,22,winrt,1
175093,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt.Microsoft,22,Microsoft,1
175094,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt.Microsoft.Terminal,22,Terminal,1
175095,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
175096,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt.Microsoft.Terminal.Settings.Editor,22,Editor,1
175097,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    template<typename T>
    struct EnumEntryComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() < rhs.EnumValue().as<T>();
        }
    };

    template<typename T>
    struct EnumEntryReverseComparator
    {
        bool operator()(const Editor::EnumEntry& lhs, const Editor::EnumEntry& rhs) const
        {
            return lhs.EnumValue().as<T>() > rhs.EnumValue().as<T>();
        }
    };

    struct EnumEntry : EnumEntryT<EnumEntry>
    {
    public:
        EnumEntry(const winrt::hstring enumName, const winrt::Windows::Foundation::IInspectable& enumValue) :
            _EnumName{ enumName },
            _EnumValue{ enumValue } {}

        hstring ToString()
        {
            return EnumName();
        }

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandl...",1,cascadia\TerminalSettingsEditor\EnumEntry.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,22,implementation,1
175171,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp:<global>,,<global>,1
175175,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt,18,winrt,1
175176,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt.Microsoft,18,Microsoft,1
175177,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt.Microsoft.Terminal,18,Terminal,1
175178,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt.Microsoft.Terminal.Settings,18,Settings,1
175179,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt.Microsoft.Terminal.Settings.Editor,18,Editor,1
175180,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    GlobalAppearance::GlobalAppearance()
    {
        InitializeComponent();
    }

    void GlobalAppearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::GlobalAppearanceViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,18,implementation,1
175205,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp:<global>,,<global>,1
175209,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt,9,winrt,1
175210,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft,9,Microsoft,1
175211,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal,9,Terminal,1
175212,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
175213,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
175214,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearance : public HasScrollViewer<GlobalAppearance>, GlobalAppearanceT<GlobalAppearance>
    {
    public:
        GlobalAppearance();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
175227,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt,23,winrt,2
175228,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft,23,Microsoft,1
175229,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal,23,Terminal,1
175230,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings,23,Settings,1
175231,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings.Editor,23,Editor,1
175232,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearance);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearance.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,23,factory_implementation,1
175261,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp:<global>,,<global>,1
175264,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt,19,winrt,1
175265,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt.Microsoft,19,Microsoft,1
175266,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt.Microsoft.Terminal,19,Terminal,1
175267,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt.Microsoft.Terminal.Settings,19,Settings,1
175268,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,19,Editor,1
175269,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    // For ComboBox an empty SelectedItem string denotes no selection.
    // What we want instead is for ""Use system language"" to be selected by default.
    // --> ""und"" is synonymous for ""Use system language"".
    constexpr std::wstring_view systemLanguageTag{ L""und"" };

    static constexpr std::array appLanguageTags{
        L""en-US"",
        L""de-DE"",
        L""es-ES"",
        L""fr-FR"",
        L""it-IT"",
        L""ja"",
        L""ko"",
        L""pt-BR"",
        L""qps-PLOC"",
        L""qps-PLOCA"",
        L""qps-PLOCM"",
        L""ru"",
        L""zh-Hans"",
        L""zh-Hant"",
    };

    constexpr std::wstring_view systemThemeName{ L""system"" };
    constexpr std::wstring_view darkThemeName{ L""dark"" };
    constexpr std::wstring_view lightThemeName{ L""light"" };
    constexpr std::wstring_view legacySystemThemeName{ L""legacySystem"" };
    constexpr std::wstring_view legacyDarkThemeName{ L""legacyDark"" };
    conste...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,19,implementation,1
176029,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp:<global>,,<global>,1
176033,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt,10,winrt,1
176034,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft,10,Microsoft,1
176035,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal,10,Terminal,1
176036,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
176037,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
176038,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct GlobalAppearanceViewModel : GlobalAppearanceViewModelT<GlobalAppearanceViewModel>, ViewModelHelper<GlobalAppearanceViewModel>
    {
    public:
        GlobalAppearanceViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<GlobalAppearanceViewModel>::PropertyChanged;

        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);
        GETSET_BINDABLE_ENUM_SETTING(NewTabPosition, Model::NewTabPosition, _GlobalSettings.NewTabPosition);
        GETSET_BINDABLE_ENUM_SETTING(TabWidthMode, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, _GlobalSettings.TabWidthMode);

    public:
        // LanguageDisplayConverter maps the given BCP 47 tag to a localized string.
        // For instance ""en-US"" produ...",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
176529,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt,63,winrt,2
176530,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft,63,Microsoft,1
176531,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal,63,Terminal,1
176532,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings,63,Settings,1
176533,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,63,Editor,1
176534,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(GlobalAppearanceViewModel);
}",1,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,63,factory_implementation,1
176543,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Interaction.cpp,cascadia\TerminalSettingsEditor\Interaction.cpp:<global>,,<global>,1
176547,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt,11,winrt,1
176548,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt.Microsoft,11,Microsoft,1
176549,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt.Microsoft.Terminal,11,Terminal,1
176550,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
176551,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
176552,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Interaction::Interaction()
    {
        InitializeComponent();
    }

    void Interaction::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::InteractionViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Interaction.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
176577,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Interaction.hpp,cascadia\TerminalSettingsEditor\Interaction.hpp:<global>,,<global>,1
176581,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt,9,winrt,1
176582,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft,9,Microsoft,1
176583,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal,9,Terminal,1
176584,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
176585,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
176586,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Interaction : public HasScrollViewer<Interaction>, InteractionT<Interaction>
    {
        Interaction();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
176599,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt,22,winrt,2
176600,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft,22,Microsoft,1
176601,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal,22,Terminal,1
176602,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
176603,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings.Editor,22,Editor,1
176604,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Interaction);
}",1,cascadia\TerminalSettingsEditor\Interaction.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,22,factory_implementation,1
176615,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp:<global>,,<global>,1
176619,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt,13,winrt,1
176620,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt.Microsoft,13,Microsoft,1
176621,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt.Microsoft.Terminal,13,Terminal,1
176622,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt.Microsoft.Terminal.Settings,13,Settings,1
176623,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,13,Editor,1
176624,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    InteractionViewModel::InteractionViewModel(Model::GlobalAppSettings globalSettings) :
        _GlobalSettings{ globalSettings }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(TabSwitcherMode, TabSwitcherMode, TabSwitcherMode, L""Globals_TabSwitcherMode"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(CopyFormat, CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, L""Globals_CopyFormat"", L""Content"");
    }
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,13,implementation,1
176930,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp:<global>,,<global>,1
176934,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt,10,winrt,1
176935,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft,10,Microsoft,1
176936,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal,10,Terminal,1
176937,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
176938,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
176939,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct InteractionViewModel : InteractionViewModelT<InteractionViewModel>, ViewModelHelper<InteractionViewModel>
    {
    public:
        InteractionViewModel(Model::GlobalAppSettings globalSettings);

        // DON'T YOU DARE ADD A `WINRT_CALLBACK(PropertyChanged` TO A CLASS DERIVED FROM ViewModelHelper. Do this instead:
        using ViewModelHelper<InteractionViewModel>::PropertyChanged;

        GETSET_BINDABLE_ENUM_SETTING(TabSwitcherMode, Model::TabSwitcherMode, _GlobalSettings.TabSwitcherMode);
        GETSET_BINDABLE_ENUM_SETTING(CopyFormat, winrt::Microsoft::Terminal::Control::CopyFormat, _GlobalSettings.CopyFormatting);

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste);
        PERMANENT_OBSERVABLE_PROJECTED_...",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
177369,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt,37,winrt,2
177370,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft,37,Microsoft,1
177371,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal,37,Terminal,1
177372,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings,37,Settings,1
177373,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,37,Editor,1
177374,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(InteractionViewModel);
}",1,cascadia\TerminalSettingsEditor\InteractionViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,37,factory_implementation,1
177385,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,cascadia\TerminalSettingsEditor\KeyChordListener.cpp:<global>,,<global>,1
177389,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt,17,winrt,1
177390,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt.Microsoft,17,Microsoft,1
177391,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt.Microsoft.Terminal,17,Terminal,1
177392,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt.Microsoft.Terminal.Settings,17,Settings,1
177393,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt.Microsoft.Terminal.Settings.Editor,17,Editor,1
177394,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty KeyChordListener::_KeysProperty{ nullptr };

    // The ModifierKeys have been sorted by value.
    // Not just binary search, but also your CPU likes sorted data.
    static constexpr std::array ModifierKeys{
        VirtualKey::Shift,
        VirtualKey::Control,
        VirtualKey::Menu,
        VirtualKey::LeftWindows,
        VirtualKey::RightWindows,
        VirtualKey::LeftShift,
        VirtualKey::LeftControl,
        VirtualKey::RightControl,
        VirtualKey::LeftMenu,
        VirtualKey::RightMenu
    };

    static VirtualKeyModifiers _GetModifiers()
    {
        const auto window{ CoreWindow::GetForCurrentThread() };

        auto flags = VirtualKeyModifiers::None;
        for (const auto mod : ModifierKeys)
        {
            const auto state = window.GetKeyState(mod);
            const auto isDown = WI_IsFlagSet(state, CoreVirtualKeyStates::Down);

            if (is...",1,cascadia\TerminalSettingsEditor\KeyChordListener.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,17,implementation,1
177741,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,cascadia\TerminalSettingsEditor\KeyChordListener.hpp:<global>,,<global>,1
177745,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt,9,winrt,1
177746,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft,9,Microsoft,1
177747,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal,9,Terminal,1
177748,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
177749,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
177750,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct KeyChordListener : KeyChordListenerT<KeyChordListener>
    {
    public:
        KeyChordListener();

        void KeyChordTextBox_KeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e);

        DEPENDENCY_PROPERTY(Control::KeyChord, Keys);

    private:
        static void _InitializeProperties();
        static void _OnKeysChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
    };
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
177806,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt,26,winrt,2
177807,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft,26,Microsoft,1
177808,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal,26,Terminal,1
177809,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings,26,Settings,1
177810,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings.Editor,26,Editor,1
177811,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(KeyChordListener);
}",1,cascadia\TerminalSettingsEditor\KeyChordListener.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,26,factory_implementation,1
177824,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Launch.cpp,cascadia\TerminalSettingsEditor\Launch.cpp:<global>,,<global>,1
177828,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt,16,winrt,1
177829,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt.Microsoft,16,Microsoft,1
177830,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt.Microsoft.Terminal,16,Terminal,1
177831,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt.Microsoft.Terminal.Settings,16,Settings,1
177832,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt.Microsoft.Terminal.Settings.Editor,16,Editor,1
177833,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Launch::Launch()
    {
        InitializeComponent();

        // BODGY
        // Xaml code generator for x:Bind to this will fail to find UnloadObject() on Launch class.
        // To work around, check it ourselves on construction and FindName to force load.
        // It's specified as x:Load=false in the XAML. So it only loads if this passes.
        if (CascadiaSettings::IsDefaultTerminalAvailable())
        {
            FindName(L""DefaultTerminalDropdown"");
        }

        Automation::AutomationProperties::SetName(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/Text""));
        Automation::AutomationProperties::SetHelpText(LaunchModeComboBox(), RS_(L""Globals_LaunchModeSetting/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
        Automation::AutomationProperties::SetHelpText(PosXBox(), RS_(L""Globals_InitialPosXBox/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip""));
      ...",1,cascadia\TerminalSettingsEditor\Launch.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,16,implementation,1
177929,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Launch.hpp,cascadia\TerminalSettingsEditor\Launch.hpp:<global>,,<global>,1
177933,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt,9,winrt,1
177934,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft,9,Microsoft,1
177935,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal,9,Terminal,1
177936,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
177937,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
177938,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Launch : public HasScrollViewer<Launch>, LaunchT<Launch>
    {
    public:
        Launch();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
177951,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt,23,winrt,2
177952,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft,23,Microsoft,1
177953,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal,23,Terminal,1
177954,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings,23,Settings,1
177955,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings.Editor,23,Editor,1
177956,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Launch);
}",1,cascadia\TerminalSettingsEditor\Launch.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,23,factory_implementation,1
177992,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp:<global>,,<global>,1
177995,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt,15,winrt,1
177996,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt.Microsoft,15,Microsoft,1
177997,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt.Microsoft.Terminal,15,Terminal,1
177998,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt.Microsoft.Terminal.Settings,15,Settings,1
177999,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,15,Editor,1
178000,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    LaunchViewModel::LaunchViewModel(Model::CascadiaSettings settings) :
        _Settings{ settings }
    {
        _useDefaultLaunchPosition = isnan(InitialPosX()) && isnan(InitialPosY());

        INITIALIZE_BINDABLE_ENUM_SETTING(FirstWindowPreference, FirstWindowPreference, FirstWindowPreference, L""Globals_FirstWindowPreference"", L""Content"");
        INITIALIZE_BINDABLE_ENUM_SETTING(LaunchMode, LaunchMode, LaunchMode, L""Globals_LaunchMode"", L""Content"");
        // More options were added to the JSON mapper when the enum was made into [Flags]
        // but we want to preserve the previous set of options in the UI.
        _LaunchModeList.RemoveAt(7); // maximizedFullscreenFocus
        _LaunchModeList.RemoveAt(6); // fullscreenFocus
        _LaunchModeList.RemoveAt(3); // maximizedFullscreen
        INITIALIZE_BINDABLE_ENUM_SETTING(WindowingBehavior, WindowingMode, WindowingMode, L""Globals_WindowingBehavior...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,15,implementation,1
179001,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp:<global>,,<global>,1
179005,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt,10,winrt,1
179006,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft,10,Microsoft,1
179007,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal,10,Terminal,1
179008,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
179009,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
179010,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct LaunchViewModel : LaunchViewModelT<LaunchViewModel>, ViewModelHelper<LaunchViewModel>
    {
    public:
        LaunchViewModel(Model::CascadiaSettings settings);

        winrt::hstring LaunchParametersCurrentValue();
        double InitialPosX();
        double InitialPosY();
        void InitialPosX(double xCoord);
        void InitialPosY(double yCoord);
        void UseDefaultLaunchPosition(bool useDefaultPosition);
        bool UseDefaultLaunchPosition();

        IInspectable CurrentDefaultProfile();
        void CurrentDefaultProfile(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::Profile> DefaultProfiles() const;

        IInspectable CurrentDefaultTerminal();
        void CurrentDefaultTerminal(const IInspectable& value);
        winrt::Windows::Foundation::Collections::IObservableVector<Model::DefaultTerminal> DefaultTerminals() const;
...",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
179419,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt,55,winrt,2
179420,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft,55,Microsoft,1
179421,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal,55,Terminal,1
179422,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings,55,Settings,1
179423,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,55,Editor,1
179424,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(LaunchViewModel);
}",1,cascadia\TerminalSettingsEditor\LaunchViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,55,factory_implementation,1
179834,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\MainPage.cpp,cascadia\TerminalSettingsEditor\MainPage.cpp:<global>,,<global>,1
179837,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt,25,winrt,1
179838,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsEditor\MainPage.cpp,Microsoft.UI.Xaml,27,MUX,1
179839,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalSettingsEditor\MainPage.cpp,Windows.UI.Xaml,28,WUX,2
179879,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt,48,winrt,18
179880,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt.Microsoft,48,Microsoft,1
179881,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt.Microsoft.Terminal,48,Terminal,1
179882,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt.Microsoft.Terminal.Settings,48,Settings,1
179883,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt.Microsoft.Terminal.Settings.Editor,48,Editor,1
179884,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::ProfileViewModel _viewModelForProfile(const Model::Profile& profile, const Model::CascadiaSettings& appSettings)
    {
        return winrt::make<implementation::ProfileViewModel>(profile, appSettings);
    }

    MainPage::MainPage(const CascadiaSettings& settings) :
        _settingsSource{ settings },
        _settingsClone{ settings.Copy() }
    {
        InitializeComponent();
        _UpdateBackgroundForMica();

        _colorSchemesPageVM = winrt::make<ColorSchemesPageViewModel>(_settingsClone);
        _colorSchemesPageViewModelChangedRevoker = _colorSchemesPageVM.PropertyChanged(winrt::auto_revoke, [=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageV...",1,cascadia\TerminalSettingsEditor\MainPage.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,48,implementation,1
181742,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\MainPage.hpp,cascadia\TerminalSettingsEditor\MainPage.hpp:<global>,,<global>,1
181746,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt,10,winrt,1
181747,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft,10,Microsoft,1
181748,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal,10,Terminal,1
181749,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
181750,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
181751,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Breadcrumb : BreadcrumbT<Breadcrumb>
    {
        Breadcrumb(IInspectable tag, winrt::hstring label, BreadcrumbSubPage subPage) :
            _Tag{ tag },
            _Label{ label },
            _SubPage{ subPage } {}

        hstring ToString() { return _Label; }

        WINRT_PROPERTY(IInspectable, Tag);
        WINRT_PROPERTY(winrt::hstring, Label);
        WINRT_PROPERTY(BreadcrumbSubPage, SubPage);
    };

    struct MainPage : MainPageT<MainPage>
    {
        MainPage() = delete;
        MainPage(const Model::CascadiaSettings& settings);

        void UpdateSettings(const Model::CascadiaSettings& settings);

        void OpenJsonKeyDown(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& args);
        void OpenJsonTapped(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::Input::TappedRoutedEventArgs& args);
        voi...",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
181924,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt,83,winrt,2
181925,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft,83,Microsoft,1
181926,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal,83,Terminal,1
181927,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings,83,Settings,1
181928,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings.Editor,83,Editor,1
181929,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(MainPage);
}",1,cascadia\TerminalSettingsEditor\MainPage.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,83,factory_implementation,1
181938,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp:<global>,,<global>,1
181942,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt,11,winrt,1
181943,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt.Microsoft,11,Microsoft,1
181944,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt.Microsoft.Terminal,11,Terminal,1
181945,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
181946,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
181947,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Foundation::IInspectable PercentageSignConverter::Convert(const Foundation::IInspectable& value,
                                                              const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                              const Foundation::IInspectable& /* parameter */,
                                                              const hstring& /* language */)
    {
        const auto number{ winrt::unbox_value<double>(value) };
        return winrt::box_value(to_hstring((int)number) + L""%"");
    }

    Foundation::IInspectable PercentageSignConverter::ConvertBack(const Foundation::IInspectable& /*value*/,
                                                                  const Windows::UI::Xaml::Interop::TypeName& /* targetType */,
                                                                  const Foundation::IInspectable& /*parameter*/,
   ...",1,cascadia\TerminalSettingsEditor\PercentageSignConverter.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
181991,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\PercentageSignConverter.hpp,cascadia\TerminalSettingsEditor\PercentageSignConverter.hpp:<global>,,<global>,1
182003,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,cascadia\TerminalSettingsEditor\PreviewConnection.cpp:<global>,,<global>,1
182022,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt,28,winrt,7
182023,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt.Microsoft,28,Microsoft,1
182024,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt.Microsoft.Terminal,28,Terminal,1
182025,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt.Microsoft.Terminal.Settings,28,Settings,1
182026,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt.Microsoft.Terminal.Settings.Editor,28,Editor,1
182027,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    PreviewConnection::PreviewConnection() noexcept = default;

    void PreviewConnection::Start() noexcept
    {
        // Send the preview text
        _TerminalOutputHandlers(fmt::format(PreviewText, _displayPowerlineGlyphs ? PromptTextPowerline : PromptTextPlain));
    }

    void PreviewConnection::Initialize(const Windows::Foundation::Collections::ValueSet& /*settings*/) noexcept
    {
    }

    void PreviewConnection::WriteInput(const hstring& /*data*/)
    {
    }

    void PreviewConnection::Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept
    {
    }

    void PreviewConnection::Close() noexcept
    {
    }

    void PreviewConnection::DisplayPowerlineGlyphs(bool d) noexcept
    {
        if (_displayPowerlineGlyphs != d)
        {
            _displayPowerlineGlyphs = d;
            Start();
        }
    }
}",1,cascadia\TerminalSettingsEditor\PreviewConnection.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,28,implementation,1
182083,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,cascadia\TerminalSettingsEditor\PreviewConnection.hpp:<global>,,<global>,1
182087,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt,17,winrt,1
182088,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt.Microsoft,17,Microsoft,1
182089,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt.Microsoft.Terminal,17,Terminal,1
182090,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt.Microsoft.Terminal.Settings,17,Settings,1
182091,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt.Microsoft.Terminal.Settings.Editor,17,Editor,1
182092,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    class PreviewConnection : public winrt::implements<PreviewConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        PreviewConnection() noexcept;

        void Initialize(const Windows::Foundation::Collections::ValueSet& settings) noexcept;
        void Start() noexcept;
        void WriteInput(const hstring& data);
        void Resize(uint32_t rows, uint32_t columns) noexcept;
        void Close() noexcept;

        void DisplayPowerlineGlyphs(bool d) noexcept;

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspe...",1,cascadia\TerminalSettingsEditor\PreviewConnection.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,17,implementation,1
182238,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp:<global>,,<global>,1
182241,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt,22,winrt,1
182242,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt.Microsoft,22,Microsoft,1
182243,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt.Microsoft.Terminal,22,Terminal,1
182244,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
182245,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,22,Editor,1
182246,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    static Editor::Font _FontObjectForDWriteFont(IDWriteFontFamily* family);

    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_MonospaceFontList{ nullptr };
    Windows::Foundation::Collections::IObservableVector<Editor::Font> ProfileViewModel::_FontList{ nullptr };

    ProfileViewModel::ProfileViewModel(const Model::Profile& profile, const Model::CascadiaSettings& appSettings) :
        _profile{ profile },
        _defaultAppearanceViewModel{ winrt::make<implementation::AppearanceViewModel>(profile.DefaultAppearance().try_as<AppearanceConfig>()) },
        _originalProfileGuid{ profile.Guid() },
        _appSettings{ appSettings },
        _unfocusedAppearanceViewModel{ nullptr }
    {
        INITIALIZE_BINDABLE_ENUM_SETTING(AntiAliasingMode, TextAntialiasingMode, winrt::Microsoft::Terminal::Control::TextAntialiasingMode, L""Profile_AntialiasingMode"", L""Content"");
    ...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,22,implementation,1
183266,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp:<global>,,<global>,1
183270,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt,13,winrt,1
183271,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft,13,Microsoft,1
183272,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal,13,Terminal,1
183273,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings,13,Settings,1
183274,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,13,Editor,1
183275,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct NavigateToProfileArgs : NavigateToProfileArgsT<NavigateToProfileArgs>
    {
    public:
        NavigateToProfileArgs(ProfileViewModel profile, Editor::IHostedInWindow windowRoot) :
            _Profile(profile),
            _WindowRoot(windowRoot) {}

        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }
        Editor::ProfileViewModel Profile() const noexcept { return _Profile; }

    private:
        Editor::IHostedInWindow _WindowRoot;
        Editor::ProfileViewModel _Profile{ nullptr };
    };

    struct ProfileViewModel : ProfileViewModelT<ProfileViewModel>, ViewModelHelper<ProfileViewModel>
    {
    public:
        // font face
        static void UpdateFontList() noexcept;
        static Windows::Foundation::Collections::IObservableVector<Editor::Font> CompleteFontList() noexcept { return _FontList; };
        static Windows::Foundation::Collections::IObserva...",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,13,implementation,1
185597,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt,146,winrt,2
185598,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft,146,Microsoft,1
185599,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal,146,Terminal,1
185600,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings,146,Settings,1
185601,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,146,Editor,1
185602,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    // Since we have static functions, we need a factory.
    BASIC_FACTORY(ProfileViewModel);
}",1,cascadia\TerminalSettingsEditor\ProfileViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,146,factory_implementation,1
185619,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp:<global>,,<global>,1
185623,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt,15,winrt,1
185624,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt.Microsoft,15,Microsoft,1
185625,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt.Microsoft.Terminal,15,Terminal,1
185626,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt.Microsoft.Terminal.Settings,15,Settings,1
185627,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt.Microsoft.Terminal.Settings.Editor,15,Editor,1
185628,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Advanced::Profiles_Advanced()
    {
        InitializeComponent();
    }

    void Profiles_Advanced::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _Profile = e.Parameter().as<Editor::ProfileViewModel>();
    }

    void Profiles_Advanced::OnNavigatedFrom(const NavigationEventArgs& /*e*/)
    {
        _ViewModelChangedRevoker.revoke();
    }
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,15,implementation,1
185664,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp:<global>,,<global>,1
185668,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt,10,winrt,1
185669,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft,10,Microsoft,1
185670,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal,10,Terminal,1
185671,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
185672,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
185673,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Advanced : public HasScrollViewer<Profiles_Advanced>, Profiles_AdvancedT<Profiles_Advanced>
    {
    public:
        Profiles_Advanced();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        Windows::UI::Xaml::Data::INotifyPropertyChanged::PropertyChanged_revoker _ViewModelChangedRevoker;
    };
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
185692,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt,28,winrt,2
185693,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft,28,Microsoft,1
185694,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal,28,Terminal,1
185695,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings,28,Settings,1
185696,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings.Editor,28,Editor,1
185697,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Advanced);
}",1,cascadia\TerminalSettingsEditor\Profiles_Advanced.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,28,factory_implementation,1
185716,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp:<global>,,<global>,1
185720,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt,17,winrt,1
185721,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt.Microsoft,17,Microsoft,1
185722,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt.Microsoft.Terminal,17,Terminal,1
185723,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt.Microsoft.Terminal.Settings,17,Settings,1
185724,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt.Microsoft.Terminal.Settings.Editor,17,Editor,1
185725,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Appearance::Profiles_Appearance()
    {
        InitializeComponent();
        _previewConnection = winrt::make_self<PreviewConnection>();
    }

    void Profiles_Appearance::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // generate the font list, if we don't have one
        if (_Profile.CompleteFontList() || !_Profile.MonospaceFontList())
        {
            ProfileViewModel::UpdateFontList();
        }

        if (!_previewControl)
        {
            const auto settings = _Profile.TermSettings();
            _previewConnection->DisplayPowerlineGlyphs(_looksLikePowerlineFont());
            _previewControl = Control::TermControl(settings, settings, *_previewConnection);
            _previewControl.IsEnabled(false);
           ...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,17,implementation,1
185968,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp:<global>,,<global>,1
185972,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt,10,winrt,1
185973,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft,10,Microsoft,1
185974,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal,10,Terminal,1
185975,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
185976,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
185977,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Appearance : public HasScrollViewer<Profiles_Appearance>, Profiles_AppearanceT<Profiles_Appearance>
    {
    public:
        Profiles_Appearance();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        void CreateUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void DeleteUnfocusedAppearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);

        Editor::IHostedInWindow WindowRoot() { return _windowRoot; };

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);

    private:
        void _onProfilePropertyChanged(const...",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
186040,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt,40,winrt,2
186041,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft,40,Microsoft,1
186042,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal,40,Terminal,1
186043,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings,40,Settings,1
186044,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings.Editor,40,Editor,1
186045,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Appearance);
}",1,cascadia\TerminalSettingsEditor\Profiles_Appearance.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,40,factory_implementation,1
186183,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,cascadia\TerminalSettingsEditor\Profiles_Base.cpp:<global>,,<global>,1
186186,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt,16,winrt,1
186187,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt.Microsoft,16,Microsoft,1
186188,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt.Microsoft.Terminal,16,Terminal,1
186189,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt.Microsoft.Terminal.Settings,16,Settings,1
186190,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt.Microsoft.Terminal.Settings.Editor,16,Editor,1
186191,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Profiles_Base::Profiles_Base()
    {
        InitializeComponent();

        const auto startingDirCheckboxTooltip{ ToolTipService::GetToolTip(StartingDirectoryUseParentCheckbox()) };
        Automation::AutomationProperties::SetFullDescription(StartingDirectoryUseParentCheckbox(), unbox_value<hstring>(startingDirCheckboxTooltip));

        Automation::AutomationProperties::SetName(DeleteButton(), RS_(L""Profile_DeleteButton/Text""));
        AppearanceNavigator().Content(box_value(RS_(L""Profile_Appearance/Header"")));
        AdvancedNavigator().Content(box_value(RS_(L""Profile_Advanced/Header"")));
    }

    void Profiles_Base::OnNavigatedTo(const NavigationEventArgs& e)
    {
        const auto args = e.Parameter().as<Editor::NavigateToProfileArgs>();
        _Profile = args.Profile();
        _windowRoot = args.WindowRoot();

        // Check the use parent directory box if the starting directory is empty
 ...",1,cascadia\TerminalSettingsEditor\Profiles_Base.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,16,implementation,1
186490,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,cascadia\TerminalSettingsEditor\Profiles_Base.hpp:<global>,,<global>,1
186494,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt,10,winrt,1
186495,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft,10,Microsoft,1
186496,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal,10,Terminal,1
186497,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
186498,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
186499,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Profiles_Base : public HasScrollViewer<Profiles_Base>, Profiles_BaseT<Profiles_Base>
    {
    public:
        Profiles_Base();

        void OnNavigatedTo(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);
        void OnNavigatedFrom(const Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        fire_and_forget StartingDirectory_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Icon_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        fire_and_forget Commandline_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Appearance_Click(const Windows::Foundation::IInspectable& sender, const Windows::UI::Xaml::RoutedEventArgs& e);
        void Advanced_Click(const Windows::Foundation::IInspectable&...",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
186556,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt,37,winrt,2
186557,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft,37,Microsoft,1
186558,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal,37,Terminal,1
186559,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings,37,Settings,1
186560,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings.Editor,37,Editor,1
186561,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Profiles_Base);
}",1,cascadia\TerminalSettingsEditor\Profiles_Base.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,37,factory_implementation,1
186570,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Rendering.cpp,cascadia\TerminalSettingsEditor\Rendering.cpp:<global>,,<global>,1
186574,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt,10,winrt,1
186575,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt.Microsoft,10,Microsoft,1
186576,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt.Microsoft.Terminal,10,Terminal,1
186577,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
186578,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt.Microsoft.Terminal.Settings.Editor,10,Editor,1
186579,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    Rendering::Rendering()
    {
        InitializeComponent();
    }

    void Rendering::OnNavigatedTo(const NavigationEventArgs& e)
    {
        _ViewModel = e.Parameter().as<Editor::RenderingViewModel>();
    }
}",1,cascadia\TerminalSettingsEditor\Rendering.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,10,implementation,1
186604,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Rendering.hpp,cascadia\TerminalSettingsEditor\Rendering.hpp:<global>,,<global>,1
186608,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt,9,winrt,1
186609,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft,9,Microsoft,1
186610,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal,9,Terminal,1
186611,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
186612,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
186613,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct Rendering : public HasScrollViewer<Rendering>, RenderingT<Rendering>
    {
        Rendering();

        void OnNavigatedTo(const winrt::Windows::UI::Xaml::Navigation::NavigationEventArgs& e);

        WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);
        WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);
    };
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
186626,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt,22,winrt,2
186627,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft,22,Microsoft,1
186628,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal,22,Terminal,1
186629,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
186630,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings.Editor,22,Editor,1
186631,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(Rendering);
}",1,cascadia\TerminalSettingsEditor\Rendering.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,22,factory_implementation,1
186640,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp:<global>,,<global>,1
186644,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt,11,winrt,1
186645,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt.Microsoft,11,Microsoft,1
186646,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt.Microsoft.Terminal,11,Terminal,1
186647,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
186648,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
186649,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    RenderingViewModel::RenderingViewModel(Model::CascadiaSettings settings) noexcept :
        _settings{ std::move(settings) }
    {
    }
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
186660,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp:<global>,,<global>,1
186664,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt,9,winrt,1
186665,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft,9,Microsoft,1
186666,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal,9,Terminal,1
186667,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
186668,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,9,Editor,1
186669,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct RenderingViewModel : RenderingViewModelT<RenderingViewModel>, ViewModelHelper<RenderingViewModel>
    {
        explicit RenderingViewModel(Model::CascadiaSettings settings) noexcept;

        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering);
        PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering);

    private:
        Model::CascadiaSettings _settings{ nullptr };
    };
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,9,implementation,1
186814,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt,24,winrt,2
186815,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft,24,Microsoft,1
186816,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal,24,Terminal,1
186817,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings,24,Settings,1
186818,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor,24,Editor,1
186819,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(RenderingViewModel);
}",1,cascadia\TerminalSettingsEditor\RenderingViewModel.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,24,factory_implementation,1
186908,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\SettingContainer.cpp,cascadia\TerminalSettingsEditor\SettingContainer.cpp:<global>,,<global>,1
186911,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt,11,winrt,1
186912,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt.Microsoft,11,Microsoft,1
186913,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt.Microsoft.Terminal,11,Terminal,1
186914,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt.Microsoft.Terminal.Settings,11,Settings,1
186915,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt.Microsoft.Terminal.Settings.Editor,11,Editor,1
186916,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    DependencyProperty SettingContainer::_HeaderProperty{ nullptr };
    DependencyProperty SettingContainer::_HelpTextProperty{ nullptr };
    DependencyProperty SettingContainer::_CurrentValueProperty{ nullptr };
    DependencyProperty SettingContainer::_HasSettingValueProperty{ nullptr };
    DependencyProperty SettingContainer::_SettingOverrideSourceProperty{ nullptr };
    DependencyProperty SettingContainer::_StartExpandedProperty{ nullptr };

    SettingContainer::SettingContainer()
    {
        _InitializeProperties();
    }

    void SettingContainer::_InitializeProperties()
    {
        // Initialize any SettingContainer dependency properties here.
        // This performs a lazy load on these properties, instead of
        // initializing them when the DLL loads.
        if (!_HeaderProperty)
        {
            _HeaderProperty =
                DependencyProperty::Register(
                    L...",1,cascadia\TerminalSettingsEditor\SettingContainer.cpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,11,implementation,1
187498,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\SettingContainer.hpp,cascadia\TerminalSettingsEditor\SettingContainer.hpp:<global>,,<global>,1
187502,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt,23,winrt,1
187503,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft,23,Microsoft,1
187504,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal,23,Terminal,1
187505,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings,23,Settings,1
187506,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings.Editor,23,Editor,1
187507,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::implementation
{
    struct SettingContainer : SettingContainerT<SettingContainer>
    {
    public:
        SettingContainer();

        void OnApplyTemplate();

        DEPENDENCY_PROPERTY(Windows::Foundation::IInspectable, Header);
        DEPENDENCY_PROPERTY(hstring, HelpText);
        DEPENDENCY_PROPERTY(hstring, CurrentValue);
        DEPENDENCY_PROPERTY(bool, HasSettingValue);
        DEPENDENCY_PROPERTY(bool, StartExpanded);
        DEPENDENCY_PROPERTY(IInspectable, SettingOverrideSource);
        TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);

    private:
        static void _InitializeProperties();
        static void _OnHasSettingValueChanged(const Windows::UI::Xaml::DependencyObject& d, const Windows::UI::Xaml::DependencyPropertyChangedEventArgs& e);
        static hstring _GenerateOverrideMessage(const IInspectable& settingOrigin);
        void _UpdateOverrideSystem();...",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings.Editor.implementation,23,implementation,1
187729,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt,48,winrt,2
187730,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft,48,Microsoft,1
187731,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal,48,Terminal,1
187732,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings,48,Settings,1
187733,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings.Editor,48,Editor,1
187734,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Editor::factory_implementation
{
    BASIC_FACTORY(SettingContainer);
}",1,cascadia\TerminalSettingsEditor\SettingContainer.hpp,winrt.Microsoft.Terminal.Settings.Editor.factory_implementation,48,factory_implementation,1
187743,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Utils.cpp,cascadia\TerminalSettingsEditor\Utils.cpp:<global>,,<global>,1
187748,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable)
    {
        auto comboBox = comboBoxAsInspectable.as<Controls::ComboBox>();
        auto selectedOption = comboBox.SelectedItem().as<Controls::ComboBoxItem>();

        return unbox_value<hstring>(selectedOption.Tag());
    }

    hstring LocalizedNameForEnumName(const std::wstring_view sectionAndEnumType, const std::wstring_view enumValue, const std::wstring_view propertyType)
    {
        // Uppercase the first letter to conform to our current Resource keys
        auto fmtKey = fmt::format(L""{}{}{}/{}"", sectionAndEnumType, char(std::towupper(enumValue[0])), enumValue.substr(1), propertyType);
        return GetLibraryResourceString(fmtKey);
    }
}",1,cascadia\TerminalSettingsEditor\Utils.cpp,winrt,18,winrt,2
187749,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable)
    {
        auto comboBox = comboBoxAsInspectable.as<Controls::ComboBox>();
        auto selectedOption = comboBox.SelectedItem().as<Controls::ComboBoxItem>();

        return unbox_value<hstring>(selectedOption.Tag());
    }

    hstring LocalizedNameForEnumName(const std::wstring_view sectionAndEnumType, const std::wstring_view enumValue, const std::wstring_view propertyType)
    {
        // Uppercase the first letter to conform to our current Resource keys
        auto fmtKey = fmt::format(L""{}{}{}/{}"", sectionAndEnumType, char(std::towupper(enumValue[0])), enumValue.substr(1), propertyType);
        return GetLibraryResourceString(fmtKey);
    }
}",1,cascadia\TerminalSettingsEditor\Utils.cpp,winrt.Microsoft,18,Microsoft,1
187750,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable)
    {
        auto comboBox = comboBoxAsInspectable.as<Controls::ComboBox>();
        auto selectedOption = comboBox.SelectedItem().as<Controls::ComboBoxItem>();

        return unbox_value<hstring>(selectedOption.Tag());
    }

    hstring LocalizedNameForEnumName(const std::wstring_view sectionAndEnumType, const std::wstring_view enumValue, const std::wstring_view propertyType)
    {
        // Uppercase the first letter to conform to our current Resource keys
        auto fmtKey = fmt::format(L""{}{}{}/{}"", sectionAndEnumType, char(std::towupper(enumValue[0])), enumValue.substr(1), propertyType);
        return GetLibraryResourceString(fmtKey);
    }
}",1,cascadia\TerminalSettingsEditor\Utils.cpp,winrt.Microsoft.Terminal,18,Terminal,1
187751,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable)
    {
        auto comboBox = comboBoxAsInspectable.as<Controls::ComboBox>();
        auto selectedOption = comboBox.SelectedItem().as<Controls::ComboBoxItem>();

        return unbox_value<hstring>(selectedOption.Tag());
    }

    hstring LocalizedNameForEnumName(const std::wstring_view sectionAndEnumType, const std::wstring_view enumValue, const std::wstring_view propertyType)
    {
        // Uppercase the first letter to conform to our current Resource keys
        auto fmtKey = fmt::format(L""{}{}{}/{}"", sectionAndEnumType, char(std::towupper(enumValue[0])), enumValue.substr(1), propertyType);
        return GetLibraryResourceString(fmtKey);
    }
}",1,cascadia\TerminalSettingsEditor\Utils.cpp,winrt.Microsoft.Terminal.Settings,18,Settings,1
187818,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\Utils.hpp,cascadia\TerminalSettingsEditor\Utils.hpp:<global>,,<global>,1
187822,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    winrt::hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable);
    winrt::hstring LocalizedNameForEnumName(const std::wstring_view sectionAndType, const std::wstring_view enumValue, const std::wstring_view propertyType);
}",1,cascadia\TerminalSettingsEditor\Utils.hpp,winrt,98,winrt,1
187823,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    winrt::hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable);
    winrt::hstring LocalizedNameForEnumName(const std::wstring_view sectionAndType, const std::wstring_view enumValue, const std::wstring_view propertyType);
}",1,cascadia\TerminalSettingsEditor\Utils.hpp,winrt.Microsoft,98,Microsoft,1
187824,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    winrt::hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable);
    winrt::hstring LocalizedNameForEnumName(const std::wstring_view sectionAndType, const std::wstring_view enumValue, const std::wstring_view propertyType);
}",1,cascadia\TerminalSettingsEditor\Utils.hpp,winrt.Microsoft.Terminal,98,Terminal,1
187825,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings
{
    winrt::hstring GetSelectedItemTag(const winrt::Windows::Foundation::IInspectable& comboBoxAsInspectable);
    winrt::hstring LocalizedNameForEnumName(const std::wstring_view sectionAndType, const std::wstring_view enumValue, const std::wstring_view propertyType);
}",1,cascadia\TerminalSettingsEditor\Utils.hpp,winrt.Microsoft.Terminal.Settings,98,Settings,1
187895,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ViewModelHelpers.hpp,cascadia\TerminalSettingsEditor\ViewModelHelpers.hpp:<global>,,<global>,1
187959,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\ViewModelHelpers.idl.hpp,cascadia\TerminalSettingsEditor\ViewModelHelpers.idl.hpp:<global>,,<global>,1
187966,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\pch.cpp,cascadia\TerminalSettingsEditor\pch.cpp:<global>,,<global>,1
188037,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsEditor\pch.hpp,cascadia\TerminalSettingsEditor\pch.hpp:<global>,,<global>,1
188573,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,cascadia\TerminalSettingsModel\ActionAndArgs.cpp:<global>,,<global>,1
189026,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt,110,winrt,181
189027,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt.Microsoft,110,Microsoft,1
189028,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt.Microsoft.Terminal,110,Terminal,1
189029,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt.Microsoft.Terminal.Settings,110,Settings,1
189030,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt.Microsoft.Terminal.Settings.Model,110,Model,1
189031,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;

    // Specifically use a map here over an unordered_map. We want to be able to
    // iterate over these entries in-order when we're serializing the keybindings.
    // HERE BE DRAGONS:
    // These are string_views that are being used as keys. These string_views are
    // just pointers to other strings. This could be dangerous, if the map outlived
    // the actual strings being pointed to. However, since both these strings and
    // the map are all const for the lifetime of the app, we have nothing to worry
    // about here.
    const std::map<std::string_view, ShortcutAction, std::less<>> ActionAndArgs::ActionKeyNamesMap{
#define ON_ALL_ACTIONS(action) KEY_TO_ACTION_PAIR(action)
        ALL_SHORTCUT_ACTIONS
#undef ON_ALL_ACTIONS
    };

    static const std::map<ShortcutAction, std::string_view, std::less<>> ActionToStringMap{
#define ON_ALL_ACT...",1,cascadia\TerminalSettingsModel\ActionAndArgs.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,110,implementation,1
190989,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,cascadia\TerminalSettingsModel\ActionAndArgs.hpp:<global>,,<global>,1
190993,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt,10,winrt,1
190994,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft,10,Microsoft,1
190995,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal,10,Terminal,1
190996,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings,10,Settings,1
190997,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings.Model,10,Model,1
190998,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ActionAndArgs : public ActionAndArgsT<ActionAndArgs>
    {
        static const std::map<std::string_view, ShortcutAction, std::less<>> ActionKeyNamesMap;
        static winrt::com_ptr<ActionAndArgs> FromJson(const Json::Value& json,
                                                      std::vector<SettingsLoadWarnings>& warnings);
        static Json::Value ToJson(const Model::ActionAndArgs& val);

        static winrt::hstring Serialize(const winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs>& args);
        static winrt::Windows::Foundation::Collections::IVector<Model::ActionAndArgs> Deserialize(winrt::hstring content);

        ActionAndArgs() = default;
        ActionAndArgs(ShortcutAction action);
        ActionAndArgs(ShortcutAction action, IActionArgs args) :
            _Action{ action },
            _Args{ args } {};
        com_ptr<ActionAndArgs> Copy() const;

        h...",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,10,implementation,1
191047,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt,36,winrt,2
191048,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft,36,Microsoft,1
191049,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal,36,Terminal,1
191050,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings,36,Settings,1
191051,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings.Model,36,Model,1
191052,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionAndArgs);
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,36,factory_implementation,1
191054,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<ActionAndArgs>
    {
        ActionAndArgs FromJson(const Json::Value& json)
        {
            std::vector<SettingsLoadWarnings> v;
            return *implementation::ActionAndArgs::FromJson(json, v);
        }

        bool CanConvert(const Json::Value& json) const
        {
            // commands without args might just be a string
            return json.isString() || json.isObject();
        }

        Json::Value ToJson(const ActionAndArgs& val)
        {
            return implementation::ActionAndArgs::ToJson(val);
        }

        std::string TypeDescription() const
        {
            return ""ActionAndArgs"";
        }
    };
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,Microsoft,41,Microsoft,3
191055,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<ActionAndArgs>
    {
        ActionAndArgs FromJson(const Json::Value& json)
        {
            std::vector<SettingsLoadWarnings> v;
            return *implementation::ActionAndArgs::FromJson(json, v);
        }

        bool CanConvert(const Json::Value& json) const
        {
            // commands without args might just be a string
            return json.isString() || json.isObject();
        }

        Json::Value ToJson(const ActionAndArgs& val)
        {
            return implementation::ActionAndArgs::ToJson(val);
        }

        std::string TypeDescription() const
        {
            return ""ActionAndArgs"";
        }
    };
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,Microsoft.Terminal,41,Terminal,1
191056,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<ActionAndArgs>
    {
        ActionAndArgs FromJson(const Json::Value& json)
        {
            std::vector<SettingsLoadWarnings> v;
            return *implementation::ActionAndArgs::FromJson(json, v);
        }

        bool CanConvert(const Json::Value& json) const
        {
            // commands without args might just be a string
            return json.isString() || json.isObject();
        }

        Json::Value ToJson(const ActionAndArgs& val)
        {
            return implementation::ActionAndArgs::ToJson(val);
        }

        std::string TypeDescription() const
        {
            return ""ActionAndArgs"";
        }
    };
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,Microsoft.Terminal.Settings,41,Settings,1
191057,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<ActionAndArgs>
    {
        ActionAndArgs FromJson(const Json::Value& json)
        {
            std::vector<SettingsLoadWarnings> v;
            return *implementation::ActionAndArgs::FromJson(json, v);
        }

        bool CanConvert(const Json::Value& json) const
        {
            // commands without args might just be a string
            return json.isString() || json.isObject();
        }

        Json::Value ToJson(const ActionAndArgs& val)
        {
            return implementation::ActionAndArgs::ToJson(val);
        }

        std::string TypeDescription() const
        {
            return ""ActionAndArgs"";
        }
    };
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,Microsoft.Terminal.Settings.Model,41,Model,1
191058,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<ActionAndArgs>
    {
        ActionAndArgs FromJson(const Json::Value& json)
        {
            std::vector<SettingsLoadWarnings> v;
            return *implementation::ActionAndArgs::FromJson(json, v);
        }

        bool CanConvert(const Json::Value& json) const
        {
            // commands without args might just be a string
            return json.isString() || json.isObject();
        }

        Json::Value ToJson(const ActionAndArgs& val)
        {
            return implementation::ActionAndArgs::ToJson(val);
        }

        std::string TypeDescription() const
        {
            return ""ActionAndArgs"";
        }
    };
}",1,cascadia\TerminalSettingsModel\ActionAndArgs.hpp,Microsoft.Terminal.Settings.Model.JsonUtils,41,JsonUtils,1
191211,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionArgs.cpp,cascadia\TerminalSettingsModel\ActionArgs.cpp:<global>,,<global>,1
191215,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt,57,winrt,1
191216,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt.Microsoft,57,Microsoft,1
191217,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt.Microsoft.Terminal,57,Terminal,1
191218,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt.Microsoft.Terminal.Settings,57,Settings,1
191219,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt.Microsoft.Terminal.Settings.Model,57,Model,1
191220,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring NewTerminalArgs::GenerateName() const
    {
        std::wstringstream ss;

        if (!Profile().empty())
        {
            ss << fmt::format(L""profile: {}, "", Profile());
        }
        else if (ProfileIndex())
        {
            ss << fmt::format(L""profile index: {}, "", ProfileIndex().Value());
        }

        if (!Commandline().empty())
        {
            ss << fmt::format(L""commandline: {}, "", Commandline());
        }

        if (!StartingDirectory().empty())
        {
            ss << fmt::format(L""directory: {}, "", StartingDirectory());
        }

        if (!TabTitle().empty())
        {
            ss << fmt::format(L""title: {}, "", TabTitle());
        }

        if (TabColor())
        {
            const til::color tabColor{ TabColor().Value() };
            ss << fmt::format(L""tabColor: {}, "", tabColor.ToHexString(true));
        }
        if (!ColorScheme().em...",1,cascadia\TerminalSettingsModel\ActionArgs.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,57,implementation,1
193716,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionArgs.hpp,cascadia\TerminalSettingsModel\ActionArgs.hpp:<global>,,<global>,1
193720,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt,283,winrt,1
193721,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft,283,Microsoft,1
193722,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal,283,Terminal,1
193723,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings,283,Settings,1
193724,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model,283,Model,1
193725,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using namespace ::Microsoft::Terminal::Settings::Model;
    using FromJsonResult = std::tuple<Model::IActionArgs, std::vector<SettingsLoadWarnings>>;

    struct ActionEventArgs : public ActionEventArgsT<ActionEventArgs>
    {
        ActionEventArgs() = default;

        explicit ActionEventArgs(const Model::IActionArgs& args) :
            _ActionArgs{ args } {};
        WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);
        WINRT_PROPERTY(bool, Handled, false);
    };

    // Although it may _seem_ like NewTerminalArgs can use ACTION_ARG_BODY, it
    // actually can't, because it isn't an `IActionArgs`, which breaks some
    // assumptions made in the macro.
    struct NewTerminalArgs : public NewTerminalArgsT<NewTerminalArgs>
    {
        NewTerminalArgs() = default;
        NewTerminalArgs(int32_t& profileIndex) :
            _ProfileIndex{ profileIndex } {};
        ACTION_ARG(winrt::hstring, Comma...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,283,implementation,1
194727,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt,462,winrt,4
194728,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft,462,Microsoft,1
194729,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal,462,Terminal,1
194730,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings,462,Settings,1
194731,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model,462,Model,1
194732,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // New Tabs, Panes, and Windows all use NewTerminalArgs, which is more
    // complicated and doesn't play nice with the macro. So those we'll still
    // have to define manually.

    struct NewTabArgs : public NewTabArgsT<NewTabArgs>
    {
        NewTabArgs() = default;
        NewTabArgs(const Model::NewTerminalArgs& terminalArgs) :
            _TerminalArgs{ terminalArgs } {};
        WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);

    public:
        hstring GenerateName() const;

        bool Equals(const IActionArgs& other)
        {
            auto otherAsUs = other.try_as<NewTabArgs>();
            if (otherAsUs)
            {
                return otherAsUs->_TerminalArgs.Equals(_TerminalArgs);
            }
            return false;
        };
        static FromJsonResult FromJson(const Json::Value& json)
        {
            // LOAD BEARING: Not using make_self here _will_ b...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,462,implementation,1
203715,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt,824,winrt,5
203716,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft,824,Microsoft,1
203717,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal,824,Terminal,1
203718,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings,824,Settings,1
203719,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model,824,Model,1
203720,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ActionEventArgs);
    BASIC_FACTORY(CopyTextArgs);
    BASIC_FACTORY(SwitchToTabArgs);
    BASIC_FACTORY(NewTerminalArgs);
    BASIC_FACTORY(NewTabArgs);
    BASIC_FACTORY(MoveFocusArgs);
    BASIC_FACTORY(MovePaneArgs);
    BASIC_FACTORY(SetTabColorArgs);
    BASIC_FACTORY(RenameTabArgs);
    BASIC_FACTORY(SwapPaneArgs);
    BASIC_FACTORY(SplitPaneArgs);
    BASIC_FACTORY(SetFocusModeArgs);
    BASIC_FACTORY(SetFullScreenArgs);
    BASIC_FACTORY(SetMaximizedArgs);
    BASIC_FACTORY(SetColorSchemeArgs);
    BASIC_FACTORY(RenameWindowArgs);
    BASIC_FACTORY(ExecuteCommandlineArgs);
    BASIC_FACTORY(CloseOtherTabsArgs);
    BASIC_FACTORY(CloseTabsAfterArgs);
    BASIC_FACTORY(CloseTabArgs);
    BASIC_FACTORY(MoveTabArgs);
    BASIC_FACTORY(OpenSettingsArgs);
    BASIC_FACTORY(FindMatchArgs);
    BASIC_FACTORY(NewWindowArgs);
    BASIC_FACTORY(FocusPaneArgs);
    BASIC_FACTORY(PrevTabArg...",1,cascadia\TerminalSettingsModel\ActionArgs.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,824,factory_implementation,1
203756,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionArgsMagic.hpp,cascadia\TerminalSettingsModel\ActionArgsMagic.hpp:<global>,,<global>,1
203884,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionMap.cpp,cascadia\TerminalSettingsModel\ActionMap.cpp:<global>,,<global>,1
203887,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt,16,winrt,1
203888,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt.Microsoft,16,Microsoft,1
203889,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt.Microsoft.Terminal,16,Terminal,1
203890,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt.Microsoft.Terminal.Settings,16,Settings,1
203891,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt.Microsoft.Terminal.Settings.Model,16,Model,1
203892,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static InternalActionID Hash(const Model::ActionAndArgs& actionAndArgs)
    {
        til::hasher hasher;

        // action will be hashed last.
        // This allows us to first seed a til::hasher
        // with the return value of IActionArgs::Hash().
        const auto action = actionAndArgs.Action();

        if (const auto args = actionAndArgs.Args())
        {
            hasher = til::hasher{ gsl::narrow_cast<size_t>(args.Hash()) };
        }
        else
        {
            size_t hash = 0;

            // Args are not defined.
            // Check if the ShortcutAction supports args.
            switch (action)
            {
#define ON_ALL_ACTIONS_WITH_ARGS(action)                               \
    case ShortcutAction::action:                                       \
    {                                                                  \
        /* If it does, hash the default values for the ...",1,cascadia\TerminalSettingsModel\ActionMap.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,16,implementation,1
207457,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionMap.hpp,cascadia\TerminalSettingsModel\ActionMap.hpp:<global>,,<global>,1
207461,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    class KeyBindingsTests;
    class DeserializationTests;
    class TerminalSettingsTests;
}",1,cascadia\TerminalSettingsModel\ActionMap.hpp,SettingsModelLocalTests,23,SettingsModelLocalTests,1
207465,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt,30,winrt,2
207466,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt.Microsoft,30,Microsoft,1
207467,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt.Microsoft.Terminal,30,Terminal,1
207468,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt.Microsoft.Terminal.Settings,30,Settings,1
207469,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt.Microsoft.Terminal.Settings.Model,30,Model,1
207470,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    using InternalActionID = size_t;

    struct KeyChordHash
    {
        inline std::size_t operator()(const Control::KeyChord& key) const
        {
            return static_cast<size_t>(key.Hash());
        }
    };

    struct KeyChordEquality
    {
        inline bool operator()(const Control::KeyChord& lhs, const Control::KeyChord& rhs) const
        {
            return lhs.Equals(rhs);
        }
    };

    struct ActionMap : ActionMapT<ActionMap>, IInheritable<ActionMap>
    {
        // views
        Windows::Foundation::Collections::IMapView<hstring, Model::ActionAndArgs> AvailableActions();
        Windows::Foundation::Collections::IMapView<hstring, Model::Command> NameMap();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> GlobalHotkeys();
        Windows::Foundation::Collections::IMapView<Control::KeyChord, Model::Command> KeyBindings();
        com_ptr<Action...",1,cascadia\TerminalSettingsModel\ActionMap.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,30,implementation,1
207744,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp:<global>,,<global>,1
207747,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt,20,winrt,1
207748,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt.Microsoft,20,Microsoft,1
207749,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt.Microsoft.Terminal,20,Terminal,1
207750,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt.Microsoft.Terminal.Settings,20,Settings,1
207751,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt.Microsoft.Terminal.Settings.Model,20,Model,1
207752,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    com_ptr<ActionMap> ActionMap::FromJson(const Json::Value& json)
    {
        auto result = make_self<ActionMap>();
        result->LayerJson(json);
        return result;
    }

    // Method Description:
    // - Deserialize an ActionMap from the array `json`. The json array should contain
    //   an array of serialized `Command` objects.
    // - These actions are added to the `ActionMap`, where we automatically handle
    //   overwriting and unbinding actions.
    // Arguments:
    // - json: an array of Json::Value's to deserialize into our ActionMap.
    // Return value:
    // - a list of warnings encountered while deserializing the json
    std::vector<SettingsLoadWarnings> ActionMap::LayerJson(const Json::Value& json)
    {
        // It's possible that the user provided keybindings have some warnings in
        // them - problems that we should alert the user to, but we can recover
        // fro...",1,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,20,implementation,1
207844,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\AllShortcutActions.hpp,cascadia\TerminalSettingsModel\AllShortcutActions.hpp:<global>,,<global>,1
207859,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\AppearanceConfig.cpp,cascadia\TerminalSettingsModel\AppearanceConfig.cpp:<global>,,<global>,1
208477,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,cascadia\TerminalSettingsModel\AppearanceConfig.hpp:<global>,,<global>,1
208481,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt,25,winrt,1
208482,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt.Microsoft,25,Microsoft,1
208483,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt.Microsoft.Terminal,25,Terminal,1
208484,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt.Microsoft.Terminal.Settings,25,Settings,1
208485,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt.Microsoft.Terminal.Settings.Model,25,Model,1
208486,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct AppearanceConfig : AppearanceConfigT<AppearanceConfig>, IInheritable<AppearanceConfig>
    {
    public:
        AppearanceConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<AppearanceConfig> CopyAppearance(const AppearanceConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

        winrt::hstring ExpandedBackgroundImagePath();

        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Foreground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, Background, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConfig, Microsoft::Terminal::Core::Color, SelectionBackground, nullptr);
        INHERITABLE_NULLABLE_SETTING(Model::IAppearanceConf...",1,cascadia\TerminalSettingsModel\AppearanceConfig.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,25,implementation,1
211048,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ApplicationState.cpp,cascadia\TerminalSettingsModel\ApplicationState.cpp:<global>,,<global>,1
211082,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<WindowLayout>
    {
        WindowLayout FromJson(const Json::Value& json)
        {
            auto layout = winrt::make_self<implementation::WindowLayout>();

            GetValueForKey(json, TabLayoutKey, layout->_TabLayout);
            GetValueForKey(json, InitialPositionKey, layout->_InitialPosition);
            GetValueForKey(json, LaunchModeKey, layout->_LaunchMode);
            GetValueForKey(json, InitialSizeKey, layout->_InitialSize);

            return *layout;
        }

        bool CanConvert(const Json::Value& json)
        {
            return json.isObject();
        }

        Json::Value ToJson(const WindowLayout& val)
        {
            Json::Value json{ Json::objectValue };

            SetValueForKey(json, TabLayoutKey, val.TabLayout());
            SetValueForKey(json, InitialPositionKey,...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,Microsoft,22,Microsoft,13
211083,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<WindowLayout>
    {
        WindowLayout FromJson(const Json::Value& json)
        {
            auto layout = winrt::make_self<implementation::WindowLayout>();

            GetValueForKey(json, TabLayoutKey, layout->_TabLayout);
            GetValueForKey(json, InitialPositionKey, layout->_InitialPosition);
            GetValueForKey(json, LaunchModeKey, layout->_LaunchMode);
            GetValueForKey(json, InitialSizeKey, layout->_InitialSize);

            return *layout;
        }

        bool CanConvert(const Json::Value& json)
        {
            return json.isObject();
        }

        Json::Value ToJson(const WindowLayout& val)
        {
            Json::Value json{ Json::objectValue };

            SetValueForKey(json, TabLayoutKey, val.TabLayout());
            SetValueForKey(json, InitialPositionKey,...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,Microsoft.Terminal,22,Terminal,1
211084,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<WindowLayout>
    {
        WindowLayout FromJson(const Json::Value& json)
        {
            auto layout = winrt::make_self<implementation::WindowLayout>();

            GetValueForKey(json, TabLayoutKey, layout->_TabLayout);
            GetValueForKey(json, InitialPositionKey, layout->_InitialPosition);
            GetValueForKey(json, LaunchModeKey, layout->_LaunchMode);
            GetValueForKey(json, InitialSizeKey, layout->_InitialSize);

            return *layout;
        }

        bool CanConvert(const Json::Value& json)
        {
            return json.isObject();
        }

        Json::Value ToJson(const WindowLayout& val)
        {
            Json::Value json{ Json::objectValue };

            SetValueForKey(json, TabLayoutKey, val.TabLayout());
            SetValueForKey(json, InitialPositionKey,...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,Microsoft.Terminal.Settings,22,Settings,1
211085,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<WindowLayout>
    {
        WindowLayout FromJson(const Json::Value& json)
        {
            auto layout = winrt::make_self<implementation::WindowLayout>();

            GetValueForKey(json, TabLayoutKey, layout->_TabLayout);
            GetValueForKey(json, InitialPositionKey, layout->_InitialPosition);
            GetValueForKey(json, LaunchModeKey, layout->_LaunchMode);
            GetValueForKey(json, InitialSizeKey, layout->_InitialSize);

            return *layout;
        }

        bool CanConvert(const Json::Value& json)
        {
            return json.isObject();
        }

        Json::Value ToJson(const WindowLayout& val)
        {
            Json::Value json{ Json::objectValue };

            SetValueForKey(json, TabLayoutKey, val.TabLayout());
            SetValueForKey(json, InitialPositionKey,...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,Microsoft.Terminal.Settings.Model,22,Model,1
211086,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<WindowLayout>
    {
        WindowLayout FromJson(const Json::Value& json)
        {
            auto layout = winrt::make_self<implementation::WindowLayout>();

            GetValueForKey(json, TabLayoutKey, layout->_TabLayout);
            GetValueForKey(json, InitialPositionKey, layout->_InitialPosition);
            GetValueForKey(json, LaunchModeKey, layout->_LaunchMode);
            GetValueForKey(json, InitialSizeKey, layout->_InitialSize);

            return *layout;
        }

        bool CanConvert(const Json::Value& json)
        {
            return json.isObject();
        }

        Json::Value ToJson(const WindowLayout& val)
        {
            Json::Value json{ Json::objectValue };

            SetValueForKey(json, TabLayoutKey, val.TabLayout());
            SetValueForKey(json, InitialPositionKey,...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,Microsoft.Terminal.Settings.Model.JsonUtils,22,JsonUtils,1
211185,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt,67,winrt,14
211186,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt.Microsoft,67,Microsoft,1
211187,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt.Microsoft.Terminal,67,Terminal,1
211188,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt.Microsoft.Terminal.Settings,67,Settings,1
211189,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt.Microsoft.Terminal.Settings.Model,67,Model,1
211190,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::hstring WindowLayout::ToJson(const Model::WindowLayout& layout)
    {
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        auto json = trait.ToJson(layout);

        Json::StreamWriterBuilder wbuilder;
        const auto content = Json::writeString(wbuilder, json);
        return hstring{ til::u8u16(content) };
    }

    Model::WindowLayout WindowLayout::FromJson(const hstring& str)
    {
        auto data = til::u16u8(str);
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        Json::Value root;
        if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
        {
            throw winrt::hresult_error(WEB_E_INVALID_JSON_STRING, winrt::to_hstring(errs));
        }
        JsonUtils::ConversionTrait<Model::WindowLayout> trait;
        return trait.FromJson(root);
    }

    ApplicationSt...",1,cascadia\TerminalSettingsModel\ApplicationState.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,67,implementation,1
212019,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ApplicationState.hpp,cascadia\TerminalSettingsModel\ApplicationState.hpp:<global>,,<global>,1
212023,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt,21,winrt,1
212024,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft,21,Microsoft,1
212025,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal,21,Terminal,1
212026,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
212027,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
212028,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // If a property is Shared, then it'll be stored in `state.json`, and used
    // in both elevated and unelevated instances of the Terminal. If a property
    // is marked Local, then it will have separate values for elevated and
    // unelevated instances.
    enum FileSource : int
    {
        Shared = 0x1,
        Local = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(FileSource);

// This macro generates all getters and setters for ApplicationState.
// It provides X with the following arguments:
//   (source, type, function name, JSON key, ...variadic construction arguments)
#define MTSM_APPLICATION_STATE_FIELDS(X)                                                                                                                                  \
    X(FileSource::Shared, winrt::hstring, SettingsHash, ""settingsHash"")                                                                                               ...",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
212216,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt,106,winrt,2
212217,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft,106,Microsoft,1
212218,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal,106,Terminal,1
212219,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings,106,Settings,1
212220,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings.Model,106,Model,1
212221,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(WindowLayout)
    BASIC_FACTORY(ApplicationState);
}",1,cascadia\TerminalSettingsModel\ApplicationState.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,106,factory_implementation,1
212236,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.cpp,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.cpp:<global>,,<global>,1
212306,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp:<global>,,<global>,1
212310,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class AzureCloudShellGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,winrt,22,winrt,1
212311,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class AzureCloudShellGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,winrt.Microsoft,22,Microsoft,1
212312,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class AzureCloudShellGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,winrt.Microsoft.Terminal,22,Terminal,1
212313,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class AzureCloudShellGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
212314,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class AzureCloudShellGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\AzureCloudShellGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,22,Model,1
212532,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>,,<global>,1
215709,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,cascadia\TerminalSettingsModel\CascadiaSettings.hpp:<global>,,<global>,1
215713,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator;
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt,25,winrt,1
215714,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator;
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft,25,Microsoft,1
215715,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator;
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal,25,Terminal,1
215716,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator;
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings,25,Settings,1
215717,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator;
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,25,Model,1
215719,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt,30,winrt,2
215720,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft,30,Microsoft,1
215721,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal,30,Terminal,1
215722,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings,30,Settings,1
215723,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,30,Model,1
215724,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    winrt::com_ptr<Profile> CreateChild(const winrt::com_ptr<Profile>& parent);

    class SettingsTypedDeserializationException final : public std::runtime_error
    {
    public:
        SettingsTypedDeserializationException(const char* message) noexcept :
            std::runtime_error(message) {}
    };

    struct ParsedSettings
    {
        winrt::com_ptr<implementation::GlobalAppSettings> globals;
        winrt::com_ptr<implementation::Profile> baseLayerProfile;
        std::vector<winrt::com_ptr<implementation::Profile>> profiles;
        std::unordered_map<winrt::guid, winrt::com_ptr<implementation::Profile>> profilesByGuid;

        void clear();
    };

    struct SettingsLoader
    {
        static SettingsLoader Default(const std::string_view& userJSON, const std::string_view& inboxJSON);
        SettingsLoader(const std::string_view& userJSON, const std::string_view& inboxJSON);

        void Gene...",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,30,implementation,1
216181,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt,194,winrt,3
216182,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft,194,Microsoft,1
216183,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal,194,Terminal,1
216184,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings,194,Settings,1
216185,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,194,Model,1
216186,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(CascadiaSettings);
}",1,cascadia\TerminalSettingsModel\CascadiaSettings.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,194,factory_implementation,1
216338,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>,,<global>,1
219347,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ColorScheme.cpp,cascadia\TerminalSettingsModel\ColorScheme.cpp:<global>,,<global>,1
219881,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ColorScheme.hpp,cascadia\TerminalSettingsModel\ColorScheme.hpp:<global>,,<global>,1
219885,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt,24,winrt,1
219886,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft,24,Microsoft,1
219887,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal,24,Terminal,1
219888,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings,24,Settings,1
219889,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Model,24,Model,1
219890,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ColorScheme : ColorSchemeT<ColorScheme>
    {
        // A ColorScheme constructed with uninitialized_t
        // leaves _table uninitialized.
        struct uninitialized_t
        {
        };

    public:
        ColorScheme() noexcept;
        explicit ColorScheme(uninitialized_t) noexcept {}
        explicit ColorScheme(const winrt::hstring& name) noexcept;

        com_ptr<ColorScheme> Copy() const;

        hstring ToString()
        {
            return Name();
        }

        static com_ptr<ColorScheme> FromJson(const Json::Value& json);
        Json::Value ToJson() const;

        winrt::Microsoft::Terminal::Core::Scheme ToCoreScheme() const noexcept;

        com_array<Core::Color> Table() const noexcept;
        void SetColorTableEntry(uint8_t index, const Core::Color& value) noexcept;

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(Core::Color, Foreground, static...",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,24,implementation,1
219951,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt,67,winrt,2
219952,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft,67,Microsoft,1
219953,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal,67,Terminal,1
219954,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings,67,Settings,1
219955,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Model,67,Model,1
219956,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ColorScheme);
}",1,cascadia\TerminalSettingsModel\ColorScheme.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,67,factory_implementation,1
220244,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Command.cpp,cascadia\TerminalSettingsModel\Command.cpp:<global>,,<global>,1
220247,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalSettingsModel\Command.cpp,winrt,17,winrt,1
220248,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsModel\Command.cpp,Microsoft.UI.Xaml,19,MUX,1
220249,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalSettingsModel\Command.cpp,Windows.UI.Xaml,20,WUX,2
220300,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt,35,winrt,22
220301,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt.Microsoft,35,Microsoft,1
220302,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt.Microsoft.Terminal,35,Terminal,1
220303,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt.Microsoft.Terminal.Settings,35,Settings,1
220304,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt.Microsoft.Terminal.Settings.Model,35,Model,1
220305,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    Command::Command() = default;

    com_ptr<Command> Command::Copy() const
    {
        auto command{ winrt::make_self<Command>() };
        command->_name = _name;
        command->_ActionAndArgs = *get_self<implementation::ActionAndArgs>(_ActionAndArgs)->Copy();
        command->_keyMappings = _keyMappings;
        command->_iconPath = _iconPath;
        command->_IterateOn = _IterateOn;

        command->_originalJson = _originalJson;
        command->_nestedCommand = _nestedCommand;
        if (HasNestedCommands())
        {
            command->_subcommands = winrt::single_threaded_map<winrt::hstring, Model::Command>();
            for (auto kv : NestedCommands())
            {
                const auto subCmd{ winrt::get_self<Command>(kv.Value()) };
                command->_subcommands.Insert(kv.Key(), *subCmd->Copy());
            }
        }
        return command;
    }

    IMapView<winrt::hstrin...",1,cascadia\TerminalSettingsModel\Command.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,35,implementation,1
221746,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Command.hpp,cascadia\TerminalSettingsModel\Command.hpp:<global>,,<global>,1
221750,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    class DeserializationTests;
    class CommandTests;
}",1,cascadia\TerminalSettingsModel\Command.hpp,SettingsModelLocalTests,28,SettingsModelLocalTests,1
221753,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt,34,winrt,2
221754,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft,34,Microsoft,1
221755,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal,34,Terminal,1
221756,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings,34,Settings,1
221757,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings.Model,34,Model,1
221758,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Command : CommandT<Command>
    {
        Command();
        com_ptr<Command> Copy() const;

        static winrt::com_ptr<Command> FromJson(const Json::Value& json,
                                                std::vector<SettingsLoadWarnings>& warnings);

        static void ExpandCommands(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                   Windows::Foundation::Collections::IVectorView<Model::Profile> profiles,
                                   Windows::Foundation::Collections::IVectorView<Model::ColorScheme> schemes);

        static std::vector<SettingsLoadWarnings> LayerJson(Windows::Foundation::Collections::IMap<winrt::hstring, Model::Command>& commands,
                                                           const Json::Value& json);
        Json::Value ToJson() const;

        bool HasNestedCommands() const;
        bool I...",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,34,implementation,1
221894,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt,94,winrt,3
221895,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft,94,Microsoft,1
221896,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal,94,Terminal,1
221897,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings,94,Settings,1
221898,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings.Model,94,Model,1
221899,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Command);
}",1,cascadia\TerminalSettingsModel\Command.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,94,factory_implementation,1
221910,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\DefaultTerminal.cpp,cascadia\TerminalSettingsModel\DefaultTerminal.cpp:<global>,,<global>,1
222233,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,cascadia\TerminalSettingsModel\DefaultTerminal.hpp:<global>,,<global>,1
222237,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt,25,winrt,1
222238,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt.Microsoft,25,Microsoft,1
222239,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt.Microsoft.Terminal,25,Terminal,1
222240,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt.Microsoft.Terminal.Settings,25,Settings,1
222241,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt.Microsoft.Terminal.Settings.Model,25,Model,1
222242,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct DefaultTerminal : public DefaultTerminalT<DefaultTerminal>
    {
        explicit DefaultTerminal(DelegationConfig::DelegationPackage&& pkg);

        hstring ToString()
        {
            return hstring{ fmt::format(L""{}, {}, {}"", Name(), Author(), Version()) };
        }

        hstring Name() const;
        hstring Author() const;
        hstring Version() const;
        hstring Icon() const;

        static std::pair<std::vector<Model::DefaultTerminal>, Model::DefaultTerminal> Available();
        static bool HasCurrent();
        static void Current(const Model::DefaultTerminal& term);

    private:
        DelegationConfig::DelegationPackage _pkg;
    };
}",1,cascadia\TerminalSettingsModel\DefaultTerminal.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,25,implementation,1
222301,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\DynamicProfileUtils.cpp,cascadia\TerminalSettingsModel\DynamicProfileUtils.cpp:<global>,,<global>,1
222403,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\DynamicProfileUtils.hpp,cascadia\TerminalSettingsModel\DynamicProfileUtils.hpp:<global>,,<global>,1
222986,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\EnumMappings.cpp,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>,,<global>,1
222989,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt,30,winrt,1
222990,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt.Microsoft,30,Microsoft,1
222991,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt.Microsoft.Terminal,30,Terminal,1
222992,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt.Microsoft.Terminal.Settings,30,Settings,1
222993,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt.Microsoft.Terminal.Settings.Model,30,Model,1
222994,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // Global Settings
    DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme);
    DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition);
    DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode);
    DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference);
    DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode);
    DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat);
    DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode);

    // Profile Settings
    DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode);
    DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState);
    DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode);
    DEFINE_ENUM_MAP(Microso...",1,cascadia\TerminalSettingsModel\EnumMappings.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,30,implementation,1
223185,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\EnumMappings.hpp,cascadia\TerminalSettingsModel\EnumMappings.hpp:<global>,,<global>,1
223189,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt,21,winrt,1
223190,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft,21,Microsoft,1
223191,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal,21,Terminal,1
223192,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
223193,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
223194,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct EnumMappings : EnumMappingsT<EnumMappings>
    {
    public:
        EnumMappings() = default;

        // Global Settings
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::UI::Xaml::ElementTheme> ElementTheme();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, NewTabPosition> NewTabPosition();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode> TabViewWidthMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, FirstWindowPreference> FirstWindowPreference();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, LaunchMode> LaunchMode();
        static winrt::Windows::Foundation::Collections::IMap<winrt::hstring, TabSwitcherMode> TabSwitcherMode();
        static winrt::Windows::Foundation::Collection...",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
223268,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt,51,winrt,2
223269,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft,51,Microsoft,1
223270,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal,51,Terminal,1
223271,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings,51,Settings,1
223272,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings.Model,51,Model,1
223273,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(EnumMappings);
}",1,cascadia\TerminalSettingsModel\EnumMappings.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,51,factory_implementation,1
223437,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FileUtils.cpp,cascadia\TerminalSettingsModel\FileUtils.cpp:<global>,,<global>,1
223462,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    // Returns a path like C:\Users\<username>\AppData\Local\Packages\<packagename>\LocalState
    // You can put your settings.json or state.json in this directory.
    bool IsPortableMode()
    {
        static auto portableMode = []() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }();
        return portableMode;
    }

    std::filesystem::path GetBaseSettingsPath()
    {
        static auto baseSettingsPath = []() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories...",1,cascadia\TerminalSettingsModel\FileUtils.cpp,winrt,21,winrt,11
223463,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    // Returns a path like C:\Users\<username>\AppData\Local\Packages\<packagename>\LocalState
    // You can put your settings.json or state.json in this directory.
    bool IsPortableMode()
    {
        static auto portableMode = []() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }();
        return portableMode;
    }

    std::filesystem::path GetBaseSettingsPath()
    {
        static auto baseSettingsPath = []() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories...",1,cascadia\TerminalSettingsModel\FileUtils.cpp,winrt.Microsoft,21,Microsoft,1
223464,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    // Returns a path like C:\Users\<username>\AppData\Local\Packages\<packagename>\LocalState
    // You can put your settings.json or state.json in this directory.
    bool IsPortableMode()
    {
        static auto portableMode = []() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }();
        return portableMode;
    }

    std::filesystem::path GetBaseSettingsPath()
    {
        static auto baseSettingsPath = []() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories...",1,cascadia\TerminalSettingsModel\FileUtils.cpp,winrt.Microsoft.Terminal,21,Terminal,1
223465,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    // Returns a path like C:\Users\<username>\AppData\Local\Packages\<packagename>\LocalState
    // You can put your settings.json or state.json in this directory.
    bool IsPortableMode()
    {
        static auto portableMode = []() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }();
        return portableMode;
    }

    std::filesystem::path GetBaseSettingsPath()
    {
        static auto baseSettingsPath = []() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories...",1,cascadia\TerminalSettingsModel\FileUtils.cpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
223466,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    // Returns a path like C:\Users\<username>\AppData\Local\Packages\<packagename>\LocalState
    // You can put your settings.json or state.json in this directory.
    bool IsPortableMode()
    {
        static auto portableMode = []() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }();
        return portableMode;
    }

    std::filesystem::path GetBaseSettingsPath()
    {
        static auto baseSettingsPath = []() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories...",1,cascadia\TerminalSettingsModel\FileUtils.cpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
223939,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FileUtils.hpp,cascadia\TerminalSettingsModel\FileUtils.hpp:<global>,,<global>,1
223943,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    bool IsPortableMode();
    std::filesystem::path GetBaseSettingsPath();
    std::filesystem::path GetReleaseSettingsPath();
    std::string ReadUTF8File(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    std::optional<std::string> ReadUTF8FileIfExists(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8File(const std::filesystem::path& path, const std::string_view& content, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8FileAtomic(const std::filesystem::path& path, const std::string_view& content, FILETIME* lastWriteTime = nullptr);
}",1,cascadia\TerminalSettingsModel\FileUtils.hpp,winrt,4,winrt,1
223944,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    bool IsPortableMode();
    std::filesystem::path GetBaseSettingsPath();
    std::filesystem::path GetReleaseSettingsPath();
    std::string ReadUTF8File(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    std::optional<std::string> ReadUTF8FileIfExists(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8File(const std::filesystem::path& path, const std::string_view& content, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8FileAtomic(const std::filesystem::path& path, const std::string_view& content, FILETIME* lastWriteTime = nullptr);
}",1,cascadia\TerminalSettingsModel\FileUtils.hpp,winrt.Microsoft,4,Microsoft,1
223945,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    bool IsPortableMode();
    std::filesystem::path GetBaseSettingsPath();
    std::filesystem::path GetReleaseSettingsPath();
    std::string ReadUTF8File(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    std::optional<std::string> ReadUTF8FileIfExists(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8File(const std::filesystem::path& path, const std::string_view& content, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8FileAtomic(const std::filesystem::path& path, const std::string_view& content, FILETIME* lastWriteTime = nullptr);
}",1,cascadia\TerminalSettingsModel\FileUtils.hpp,winrt.Microsoft.Terminal,4,Terminal,1
223946,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    bool IsPortableMode();
    std::filesystem::path GetBaseSettingsPath();
    std::filesystem::path GetReleaseSettingsPath();
    std::string ReadUTF8File(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    std::optional<std::string> ReadUTF8FileIfExists(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8File(const std::filesystem::path& path, const std::string_view& content, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8FileAtomic(const std::filesystem::path& path, const std::string_view& content, FILETIME* lastWriteTime = nullptr);
}",1,cascadia\TerminalSettingsModel\FileUtils.hpp,winrt.Microsoft.Terminal.Settings,4,Settings,1
223947,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    bool IsPortableMode();
    std::filesystem::path GetBaseSettingsPath();
    std::filesystem::path GetReleaseSettingsPath();
    std::string ReadUTF8File(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    std::optional<std::string> ReadUTF8FileIfExists(const std::filesystem::path& path, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8File(const std::filesystem::path& path, const std::string_view& content, const bool elevatedOnly = false, FILETIME* lastWriteTime = nullptr);
    void WriteUTF8FileAtomic(const std::filesystem::path& path, const std::string_view& content, FILETIME* lastWriteTime = nullptr);
}",1,cascadia\TerminalSettingsModel\FileUtils.hpp,winrt.Microsoft.Terminal.Settings.Model,4,Model,1
224000,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FolderEntry.cpp,cascadia\TerminalSettingsModel\FolderEntry.cpp:<global>,,<global>,1
224291,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FolderEntry.hpp,cascadia\TerminalSettingsModel\FolderEntry.hpp:<global>,,<global>,1
224295,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt,21,winrt,1
224296,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft,21,Microsoft,1
224297,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal,21,Terminal,1
224298,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
224299,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
224300,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FolderEntry : FolderEntryT<FolderEntry, NewTabMenuEntry>
    {
    public:
        FolderEntry() noexcept;
        explicit FolderEntry(const winrt::hstring& name) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, we can set arbitrarily many profiles or nested profiles, that might not all
        // be rendered; for example, when a profile entry is invalid, or when a folder is empty.
        // Therefore, we will store the JSON entries list internally, and then expose only the
        // entries to be rendered to WinRT.
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> Entries() const;
        winrt::Windows::Foundation::Collections::IVector<Model::NewTabMenuEntry> RawEntries() const
        {
            return _Entries;
        };

        WINRT_PROPERTY(winrt::hstring...",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
224342,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt,52,winrt,2
224343,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft,52,Microsoft,1
224344,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal,52,Terminal,1
224345,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings,52,Settings,1
224346,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,52,Model,1
224347,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(FolderEntry);
}",1,cascadia\TerminalSettingsModel\FolderEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,52,factory_implementation,1
224360,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FontConfig.cpp,cascadia\TerminalSettingsModel\FontConfig.cpp:<global>,,<global>,1
224647,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\FontConfig.hpp,cascadia\TerminalSettingsModel\FontConfig.hpp:<global>,,<global>,1
224653,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt,29,winrt,3
224654,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt.Microsoft,29,Microsoft,1
224655,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt.Microsoft.Terminal,29,Terminal,1
224656,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt.Microsoft.Terminal.Settings,29,Settings,1
224657,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt.Microsoft.Terminal.Settings.Model,29,Model,1
224658,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct FontConfig : FontConfigT<FontConfig>, IInheritable<FontConfig>
    {
    public:
        FontConfig(winrt::weak_ref<Profile> sourceProfile);
        static winrt::com_ptr<FontConfig> CopyFontInfo(const FontConfig* source, winrt::weak_ref<Profile> sourceProfile);
        Json::Value ToJson() const;
        void LayerJson(const Json::Value& json);

        Model::Profile SourceProfile();

#define FONT_SETTINGS_INITIALIZE(type, name, jsonKey, ...) \
    INHERITABLE_SETTING(Model::FontConfig, type, name, ##__VA_ARGS__)
        MTSM_FONT_SETTINGS(FONT_SETTINGS_INITIALIZE)
#undef FONT_SETTINGS_INITIALIZE

    private:
        winrt::weak_ref<Profile> _sourceProfile;
    };
}",1,cascadia\TerminalSettingsModel\FontConfig.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,29,implementation,1
225622,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\GlobalAppSettings.cpp,cascadia\TerminalSettingsModel\GlobalAppSettings.cpp:<global>,,<global>,1
227148,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp:<global>,,<global>,1
227152,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    class DeserializationTests;
    class ColorSchemeTests;
}",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,SettingsModelLocalTests,30,SettingsModelLocalTests,1
227155,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt,36,winrt,2
227156,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt.Microsoft,36,Microsoft,1
227157,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt.Microsoft.Terminal,36,Terminal,1
227158,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt.Microsoft.Terminal.Settings,36,Settings,1
227159,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,36,Model,1
227160,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct GlobalAppSettings : GlobalAppSettingsT<GlobalAppSettings>, IInheritable<GlobalAppSettings>
    {
    public:
        void _FinalizeInheritance() override;
        com_ptr<GlobalAppSettings> Copy() const;

        Windows::Foundation::Collections::IMapView<hstring, Model::ColorScheme> ColorSchemes() noexcept;
        void AddColorScheme(const Model::ColorScheme& scheme);
        void RemoveColorScheme(hstring schemeName);

        Model::ActionMap ActionMap() const noexcept;

        static com_ptr<GlobalAppSettings> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);

        Json::Value ToJson() const;

        const std::vector<SettingsLoadWarnings>& KeybindingsWarnings() const;

        // This DefaultProfile() setter is called by CascadiaSettings,
        // when it parses UnparsedDefaultProfile in _finalizeSettings().
        void DefaultProfile(const guid& default...",1,cascadia\TerminalSettingsModel\GlobalAppSettings.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,36,implementation,1
233930,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\HashUtils.hpp,cascadia\TerminalSettingsModel\HashUtils.hpp:<global>,,<global>,1
233934,NAMESPACE_BLOCK,"namespace til
{
    template<typename T>
    struct hash_trait<winrt::Windows::Foundation::IReference<T>>
    {
        constexpr void operator()(hasher& h, const winrt::Windows::Foundation::IReference<T>& v) const noexcept
        {
            if (v)
            {
                h.write(v.Value());
            }
        }
    };

    template<>
    struct hash_trait<winrt::hstring>
    {
        void operator()(hasher& h, const winrt::hstring& value) const noexcept
        {
            h.write(reinterpret_cast<const uint8_t*>(value.data()), value.size() * sizeof(wchar_t));
        }
    };
}",1,cascadia\TerminalSettingsModel\HashUtils.hpp,til,22,til,1
233980,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp:<global>,,<global>,1
233984,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator
    {
    public:
        virtual ~IDynamicProfileGenerator() = default;
        virtual std::wstring_view GetNamespace() const noexcept = 0;
        virtual void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
    };
}",1,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,winrt,26,winrt,1
233985,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator
    {
    public:
        virtual ~IDynamicProfileGenerator() = default;
        virtual std::wstring_view GetNamespace() const noexcept = 0;
        virtual void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
    };
}",1,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,winrt.Microsoft,26,Microsoft,1
233986,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator
    {
    public:
        virtual ~IDynamicProfileGenerator() = default;
        virtual std::wstring_view GetNamespace() const noexcept = 0;
        virtual void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
    };
}",1,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,winrt.Microsoft.Terminal,26,Terminal,1
233987,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator
    {
    public:
        virtual ~IDynamicProfileGenerator() = default;
        virtual std::wstring_view GetNamespace() const noexcept = 0;
        virtual void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
    };
}",1,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,winrt.Microsoft.Terminal.Settings,26,Settings,1
233988,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class IDynamicProfileGenerator
    {
    public:
        virtual ~IDynamicProfileGenerator() = default;
        virtual std::wstring_view GetNamespace() const noexcept = 0;
        virtual void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
    };
}",1,cascadia\TerminalSettingsModel\IDynamicProfileGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,26,Model,1
234004,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\IInheritable.hpp,cascadia\TerminalSettingsModel\IInheritable.hpp:<global>,,<global>,1
234008,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt,17,winrt,1
234009,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt.Microsoft,17,Microsoft,1
234010,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt.Microsoft.Terminal,17,Terminal,1
234011,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt.Microsoft.Terminal.Settings,17,Settings,1
234012,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt.Microsoft.Terminal.Settings.Model,17,Model,1
234013,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    template<typename T>
    struct IInheritable
    {
    public:
        // Method Description:
        // - Create a new instance of T, but set its parent to this instance
        // Arguments:
        // - <none>
        // Return Value:
        // - a new instance of T with this instance set as its parent
        com_ptr<T> CreateChild() const
        {
            auto child{ winrt::make_self<T>() };

            // set ""this"" as the parent.
            // However, ""this"" is an IInheritable, so we need to cast it as T (the impl winrt type)
            //  to pass ownership over to the com_ptr.
            com_ptr<T> parent;
            winrt::copy_from_abi(parent, const_cast<T*>(static_cast<const T*>(this)));
            child->AddLeastImportantParent(parent);

            child->_FinalizeInheritance();
            return child;
        }

        void ClearParents()
        {
            _parents.clear();...",1,cascadia\TerminalSettingsModel\IInheritable.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,17,implementation,1
234109,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\IInheritable.idl.hpp,cascadia\TerminalSettingsModel\IInheritable.idl.hpp:<global>,,<global>,1
234128,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\IconPathConverter.cpp,cascadia\TerminalSettingsModel\IconPathConverter.cpp:<global>,,<global>,1
234132,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
}",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt,11,winrt,1
234133,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsModel\IconPathConverter.cpp,Microsoft.UI.Xaml,13,MUX,1
234134,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt,22,winrt,2
234135,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt.Microsoft,22,Microsoft,1
234136,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt.Microsoft.Terminal,22,Terminal,1
234137,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt.Microsoft.Terminal.Settings,22,Settings,1
234138,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt.Microsoft.Terminal.Settings.Model,22,Model,1
234139,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
// These are templates that help us figure out which BitmapIconSource/FontIconSource to use for a given IconSource.
// We have to do this because some of our code still wants to use WUX/MUX IconSources.
#pragma region BitmapIconSource
    template<typename TIconSource>
    struct BitmapIconSource
    {
    };

    template<>
    struct BitmapIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource;
    };

    template<>
    struct BitmapIconSource<winrt::Windows::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::Windows::UI::Xaml::Controls::BitmapIconSource;
    };
#pragma endregion

#pragma region FontIconSource
    template<typename TIconSource>
    struct FontIconSource
    {
    };

    template<>
    struct FontIconSource<winrt::Microsoft::UI::Xaml::Controls::IconSource>
    {
        using type = winrt::M...",1,cascadia\TerminalSettingsModel\IconPathConverter.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,22,implementation,1
234696,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\IconPathConverter.hpp,cascadia\TerminalSettingsModel\IconPathConverter.hpp:<global>,,<global>,1
234700,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt,5,winrt,1
234701,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft,5,Microsoft,1
234702,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal,5,Terminal,1
234703,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings,5,Settings,1
234704,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings.Model,5,Model,1
234705,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct IconPathConverter : IconPathConverterT<IconPathConverter>
    {
        IconPathConverter() = default;

        Windows::Foundation::IInspectable Convert(const Windows::Foundation::IInspectable& value,
                                                  const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                  const Windows::Foundation::IInspectable& parameter,
                                                  const hstring& language);

        Windows::Foundation::IInspectable ConvertBack(const Windows::Foundation::IInspectable& value,
                                                      const Windows::UI::Xaml::Interop::TypeName& targetType,
                                                      const Windows::Foundation::IInspectable& parameter,
                                                      const hstring& language);

        static Windows::UI::...",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,5,implementation,1
234738,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt,26,winrt,2
234739,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft,26,Microsoft,1
234740,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal,26,Terminal,1
234741,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings,26,Settings,1
234742,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings.Model,26,Model,1
234743,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(IconPathConverter);
}",1,cascadia\TerminalSettingsModel\IconPathConverter.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,26,factory_implementation,1
234791,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\JsonUtils.hpp,cascadia\TerminalSettingsModel\JsonUtils.hpp:<global>,,<global>,1
234795,NAMESPACE_BLOCK,"namespace winrt
{
    // If we don't use winrt, nobody will include the ConversionTraits for winrt stuff.
    // If nobody includes it, these forward declarations will suffice.
    struct guid;
    struct hstring;
    namespace Windows::Foundation
    {
        template<typename T>
        struct IReference;
    }
}",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,winrt,21,winrt,1
234798,NAMESPACE_BLOCK,"namespace Windows::Foundation
    {
        template<typename T>
        struct IReference;
    }",5,cascadia\TerminalSettingsModel\JsonUtils.hpp,winrt.Windows,27,Windows,3
234799,NAMESPACE_BLOCK,"namespace Windows::Foundation
    {
        template<typename T>
        struct IReference;
    }",5,cascadia\TerminalSettingsModel\JsonUtils.hpp,winrt.Windows.Foundation,27,Foundation,1
234810,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<typename T>
    struct ConversionTrait
    {
        // Forward-declare these so the linker can pick up specializations from elsewhere!
        T FromJson(const Json::Value&);
        bool CanConvert(const Json::Value& json);

        Json::Value ToJson(const T& val);

        std::string TypeDescription() const { return ""<unknown>""; }
    };

    namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }

    template<...",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft,48,Microsoft,3
234811,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<typename T>
    struct ConversionTrait
    {
        // Forward-declare these so the linker can pick up specializations from elsewhere!
        T FromJson(const Json::Value&);
        bool CanConvert(const Json::Value& json);

        Json::Value ToJson(const T& val);

        std::string TypeDescription() const { return ""<unknown>""; }
    };

    namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }

    template<...",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft.Terminal,48,Terminal,1
234812,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<typename T>
    struct ConversionTrait
    {
        // Forward-declare these so the linker can pick up specializations from elsewhere!
        T FromJson(const Json::Value&);
        bool CanConvert(const Json::Value& json);

        Json::Value ToJson(const T& val);

        std::string TypeDescription() const { return ""<unknown>""; }
    };

    namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }

    template<...",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft.Terminal.Settings,48,Settings,1
234813,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<typename T>
    struct ConversionTrait
    {
        // Forward-declare these so the linker can pick up specializations from elsewhere!
        T FromJson(const Json::Value&);
        bool CanConvert(const Json::Value& json);

        Json::Value ToJson(const T& val);

        std::string TypeDescription() const { return ""<unknown>""; }
    };

    namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }

    template<...",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft.Terminal.Settings.Model,48,Model,1
234814,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<typename T>
    struct ConversionTrait
    {
        // Forward-declare these so the linker can pick up specializations from elsewhere!
        T FromJson(const Json::Value&);
        bool CanConvert(const Json::Value& json);

        Json::Value ToJson(const T& val);

        std::string TypeDescription() const { return ""<unknown>""; }
    };

    namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }

    template<...",1,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft.Terminal.Settings.Model.JsonUtils,48,JsonUtils,1
234837,NAMESPACE_BLOCK,"namespace Detail
    {
        // Function Description:
        // - Returns a string_view to a Json::Value's internal string storage,
        //   hopefully without copying it.
        __declspec(noinline) inline const std::string_view GetStringView(const Json::Value& json)
        {
            const char* begin{ nullptr };
            const char* end{ nullptr };
            json.getString(&begin, &end);
            const std::string_view zeroCopyString{ begin, gsl::narrow_cast<size_t>(end - begin) };
            return zeroCopyString;
        }
    }",5,cascadia\TerminalSettingsModel\JsonUtils.hpp,Microsoft.Terminal.Settings.Model.JsonUtils.Detail,62,Detail,2
236589,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\KeyChordSerialization.cpp,cascadia\TerminalSettingsModel\KeyChordSerialization.cpp:<global>,,<global>,1
237932,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp:<global>,,<global>,1
237936,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt,9,winrt,1
237937,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft,9,Microsoft,1
237938,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal,9,Terminal,1
237939,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings,9,Settings,1
237940,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings.Model,9,Model,1
237941,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct KeyChordSerialization
    {
        KeyChordSerialization() = default;

        static winrt::Microsoft::Terminal::Control::KeyChord FromString(const winrt::hstring& str);
        static winrt::hstring ToString(const winrt::Microsoft::Terminal::Control::KeyChord& chord);
    };
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,9,implementation,1
237977,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt,29,winrt,3
237978,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft,29,Microsoft,1
237979,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal,29,Terminal,1
237980,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings,29,Settings,1
237981,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings.Model,29,Model,1
237982,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    // C++/WinRT generates a constructor even though one is not specified in the IDL
    BASIC_FACTORY(KeyChordSerialization);
}",1,cascadia\TerminalSettingsModel\KeyChordSerialization.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,29,factory_implementation,1
237985,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\LegacyProfileGeneratorNamespaces.hpp,cascadia\TerminalSettingsModel\LegacyProfileGeneratorNamespaces.hpp:<global>,,<global>,1
238005,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\MTSMSettings.hpp,cascadia\TerminalSettingsModel\MTSMSettings.hpp:<global>,,<global>,1
238018,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\MatchProfilesEntry.cpp,cascadia\TerminalSettingsModel\MatchProfilesEntry.cpp:<global>,,<global>,1
238164,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp:<global>,,<global>,1
238168,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt,21,winrt,1
238169,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft,21,Microsoft,1
238170,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal,21,Terminal,1
238171,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
238172,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
238173,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct MatchProfilesEntry : MatchProfilesEntryT<MatchProfilesEntry, ProfileCollectionEntry>
    {
    public:
        MatchProfilesEntry() noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        bool MatchesProfile(const Model::Profile& profile);

        WINRT_PROPERTY(winrt::hstring, Name);
        WINRT_PROPERTY(winrt::hstring, Commandline);
        WINRT_PROPERTY(winrt::hstring, Source);
    };
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
238196,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt,39,winrt,2
238197,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft,39,Microsoft,1
238198,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal,39,Terminal,1
238199,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings,39,Settings,1
238200,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,39,Model,1
238201,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(MatchProfilesEntry);
}",1,cascadia\TerminalSettingsModel\MatchProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,39,factory_implementation,1
238251,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp:<global>,,<global>,1
238361,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\NewTabMenuEntry.cpp,cascadia\TerminalSettingsModel\NewTabMenuEntry.cpp:<global>,,<global>,1
238473,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp:<global>,,<global>,1
238477,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt,21,winrt,1
238478,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt.Microsoft,21,Microsoft,1
238479,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt.Microsoft.Terminal,21,Terminal,1
238480,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
238481,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
238482,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct NewTabMenuEntry : NewTabMenuEntryT<NewTabMenuEntry>
    {
    public:
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
        virtual Json::Value ToJson() const;

        WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this base class directly and need to go through either FromJson
        // or one of the subclasses.
    protected:
        explicit NewTabMenuEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
238499,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<NewTabMenuEntry>
    {
        NewTabMenuEntry FromJson(const Json::Value& json)
        {
            const auto entry = implementation::NewTabMenuEntry::FromJson(json);
            if (entry == nullptr)
            {
                return nullptr;
            }

            return *entry;
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject();
        }

        Json::Value ToJson(const NewTabMenuEntry& val)
        {
            return winrt::get_self<implementation::NewTabMenuEntry>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""NewTabMenuEntry"";
        }
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,Microsoft,39,Microsoft,2
238500,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<NewTabMenuEntry>
    {
        NewTabMenuEntry FromJson(const Json::Value& json)
        {
            const auto entry = implementation::NewTabMenuEntry::FromJson(json);
            if (entry == nullptr)
            {
                return nullptr;
            }

            return *entry;
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject();
        }

        Json::Value ToJson(const NewTabMenuEntry& val)
        {
            return winrt::get_self<implementation::NewTabMenuEntry>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""NewTabMenuEntry"";
        }
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,Microsoft.Terminal,39,Terminal,1
238501,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<NewTabMenuEntry>
    {
        NewTabMenuEntry FromJson(const Json::Value& json)
        {
            const auto entry = implementation::NewTabMenuEntry::FromJson(json);
            if (entry == nullptr)
            {
                return nullptr;
            }

            return *entry;
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject();
        }

        Json::Value ToJson(const NewTabMenuEntry& val)
        {
            return winrt::get_self<implementation::NewTabMenuEntry>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""NewTabMenuEntry"";
        }
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,Microsoft.Terminal.Settings,39,Settings,1
238502,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<NewTabMenuEntry>
    {
        NewTabMenuEntry FromJson(const Json::Value& json)
        {
            const auto entry = implementation::NewTabMenuEntry::FromJson(json);
            if (entry == nullptr)
            {
                return nullptr;
            }

            return *entry;
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject();
        }

        Json::Value ToJson(const NewTabMenuEntry& val)
        {
            return winrt::get_self<implementation::NewTabMenuEntry>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""NewTabMenuEntry"";
        }
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,Microsoft.Terminal.Settings.Model,39,Model,1
238503,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    using namespace winrt::Microsoft::Terminal::Settings::Model;

    template<>
    struct ConversionTrait<NewTabMenuEntry>
    {
        NewTabMenuEntry FromJson(const Json::Value& json)
        {
            const auto entry = implementation::NewTabMenuEntry::FromJson(json);
            if (entry == nullptr)
            {
                return nullptr;
            }

            return *entry;
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject();
        }

        Json::Value ToJson(const NewTabMenuEntry& val)
        {
            return winrt::get_self<implementation::NewTabMenuEntry>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""NewTabMenuEntry"";
        }
    };
}",1,cascadia\TerminalSettingsModel\NewTabMenuEntry.hpp,Microsoft.Terminal.Settings.Model.JsonUtils,39,JsonUtils,1
238587,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.cpp,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.cpp:<global>,,<global>,1
238621,NAMESPACE_BLOCK,"namespace
{
    enum PowerShellFlags
    {
        None = 0,

        // These flags are used as a sort key, so they encode some native ordering.
        // They are ordered such that the ""most important"" flags have the largest
        // impact on the sort space. For example, since we want Preview to be very polar
        // we give it the highest flag value.
        // The ""ideal"" powershell instance has 0 flags (stable, native, Program Files location)
        //
        // With this ordering, the sort space ends up being (for PowerShell 6)
        // (numerically greater values are on the left; this is flipped in the final sort)
        //
        // <-- Less Valued .................................... More Valued -->
        // |                 All instances of PS 6                 | All PS7  |
        // |          Preview          |          Stable           | ~~~      |
        // |  Non-Native | Native      |  Non-Native | Native      | ~~~      |
        // | Trd  | Pack |...",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.cpp,anonymous_namespace_0,26,,13
239365,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp:<global>,,<global>,1
239369,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class PowershellCoreProfileGenerator final : public IDynamicProfileGenerator
    {
    public:
        static const std::wstring_view GetPreferredPowershellProfileName();

        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,winrt,21,winrt,1
239370,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class PowershellCoreProfileGenerator final : public IDynamicProfileGenerator
    {
    public:
        static const std::wstring_view GetPreferredPowershellProfileName();

        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,winrt.Microsoft,21,Microsoft,1
239371,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class PowershellCoreProfileGenerator final : public IDynamicProfileGenerator
    {
    public:
        static const std::wstring_view GetPreferredPowershellProfileName();

        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,winrt.Microsoft.Terminal,21,Terminal,1
239372,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class PowershellCoreProfileGenerator final : public IDynamicProfileGenerator
    {
    public:
        static const std::wstring_view GetPreferredPowershellProfileName();

        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
239373,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class PowershellCoreProfileGenerator final : public IDynamicProfileGenerator
    {
    public:
        static const std::wstring_view GetPreferredPowershellProfileName();

        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\PowershellCoreProfileGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
239405,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Profile.cpp,cascadia\TerminalSettingsModel\Profile.cpp:<global>,,<global>,1
240631,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Profile.hpp,cascadia\TerminalSettingsModel\Profile.hpp:<global>,,<global>,1
240635,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    class DeserializationTests;
    class ProfileTests;
    class ColorSchemeTests;
    class KeyBindingsTests;
}",1,cascadia\TerminalSettingsModel\Profile.hpp,SettingsModelLocalTests,57,SettingsModelLocalTests,1
240640,NAMESPACE_BLOCK,"namespace TerminalAppUnitTests
{
    class DynamicProfileTests;
    class JsonTests;
}",1,cascadia\TerminalSettingsModel\Profile.hpp,TerminalAppUnitTests,64,TerminalAppUnitTests,2
240660,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt,76,winrt,6
240661,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft,76,Microsoft,1
240662,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal,76,Terminal,1
240663,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings,76,Settings,1
240664,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings.Model,76,Model,1
240665,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct Profile : ProfileT<Profile>, IInheritable<Profile>
    {
    public:
        Profile() noexcept = default;
        Profile(guid guid) noexcept;

        void CreateUnfocusedAppearance();
        void DeleteUnfocusedAppearance();

        hstring ToString()
        {
            return Name();
        }

        static void CopyInheritanceGraphs(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited, const std::vector<winrt::com_ptr<Profile>>& source, std::vector<winrt::com_ptr<Profile>>& target);
        winrt::com_ptr<Profile>& CopyInheritanceGraph(std::unordered_map<const Profile*, winrt::com_ptr<Profile>>& visited) const;
        winrt::com_ptr<Profile> CopySettings() const;

        static com_ptr<Profile> FromJson(const Json::Value& json);
        void LayerJson(const Json::Value& json);
        Json::Value ToJson() const;

        hstring EvaluatedStartingDirectory() const;

      ...",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,76,implementation,1
244800,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt,144,winrt,7
244801,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft,144,Microsoft,1
244802,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal,144,Terminal,1
244803,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings,144,Settings,1
244804,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings.Model,144,Model,1
244805,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(Profile);
}",1,cascadia\TerminalSettingsModel\Profile.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,144,factory_implementation,1
244816,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ProfileCollectionEntry.cpp,cascadia\TerminalSettingsModel\ProfileCollectionEntry.cpp:<global>,,<global>,1
244832,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp:<global>,,<global>,1
244836,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt,23,winrt,1
244837,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt.Microsoft,23,Microsoft,1
244838,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt.Microsoft.Terminal,23,Terminal,1
244839,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt.Microsoft.Terminal.Settings,23,Settings,1
244840,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,23,Model,1
244841,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileCollectionEntry : ProfileCollectionEntryT<ProfileCollectionEntry, NewTabMenuEntry>
    {
    public:
        // Since a comma does not work very nicely in a macro and we need one
        // for our map definition, we use a macro te define a comma.
#define COMMA ,
        WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);
#undef COMMA

        // We have a protected/hidden constructor so consumers cannot instantiate
        // this class directly and need to go through one of the subclasses.
    protected:
        explicit ProfileCollectionEntry(const NewTabMenuEntryType type) noexcept;
    };
}",1,cascadia\TerminalSettingsModel\ProfileCollectionEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,23,implementation,1
244858,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ProfileEntry.cpp,cascadia\TerminalSettingsModel\ProfileEntry.cpp:<global>,,<global>,1
244943,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\ProfileEntry.hpp,cascadia\TerminalSettingsModel\ProfileEntry.hpp:<global>,,<global>,1
244947,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt,23,winrt,1
244948,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft,23,Microsoft,1
244949,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal,23,Terminal,1
244950,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings,23,Settings,1
244951,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,23,Model,1
244952,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ProfileEntry : ProfileEntryT<ProfileEntry, NewTabMenuEntry>
    {
    public:
        ProfileEntry() noexcept;
        explicit ProfileEntry(const winrt::hstring& profile) noexcept;

        Json::Value ToJson() const override;
        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);

        // In JSON, only a profile name (guid or string) can be set;
        // but the consumers of this class would like to have direct access
        // to the appropriate Model::Profile. Therefore, we have a read-only
        // property ProfileName that corresponds to the JSON value, and
        // then CascadiaSettings::_resolveNewTabMenuProfiles() will populate
        // the Profile and ProfileIndex properties appropriately
        winrt::hstring ProfileName() const noexcept { return _ProfileName; };

        WINRT_PROPERTY(Model::Profile, Profile);
        WINRT_PROPERTY(int, ProfileIndex);

  ...",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,23,implementation,1
244981,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt,50,winrt,2
244982,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft,50,Microsoft,1
244983,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal,50,Terminal,1
244984,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings,50,Settings,1
244985,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,50,Model,1
244986,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ProfileEntry);
}",1,cascadia\TerminalSettingsModel\ProfileEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,50,factory_implementation,1
244999,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\RemainingProfilesEntry.cpp,cascadia\TerminalSettingsModel\RemainingProfilesEntry.cpp:<global>,,<global>,1
245022,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp:<global>,,<global>,1
245026,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt,21,winrt,1
245027,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft,21,Microsoft,1
245028,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal,21,Terminal,1
245029,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
245030,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
245031,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct RemainingProfilesEntry : RemainingProfilesEntryT<RemainingProfilesEntry, ProfileCollectionEntry>
    {
    public:
        RemainingProfilesEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,21,implementation,1
245042,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt,32,winrt,2
245043,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft,32,Microsoft,1
245044,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal,32,Terminal,1
245045,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings,32,Settings,1
245046,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,32,Model,1
245047,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(RemainingProfilesEntry);
}",1,cascadia\TerminalSettingsModel\RemainingProfilesEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,32,factory_implementation,1
245058,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\SeparatorEntry.cpp,cascadia\TerminalSettingsModel\SeparatorEntry.cpp:<global>,,<global>,1
245081,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,cascadia\TerminalSettingsModel\SeparatorEntry.hpp:<global>,,<global>,1
245085,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt,20,winrt,1
245086,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft,20,Microsoft,1
245087,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal,20,Terminal,1
245088,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings,20,Settings,1
245089,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,20,Model,1
245090,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct SeparatorEntry : SeparatorEntryT<SeparatorEntry, NewTabMenuEntry>
    {
    public:
        SeparatorEntry() noexcept;

        static com_ptr<NewTabMenuEntry> FromJson(const Json::Value& json);
    };
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,20,implementation,1
245101,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt,31,winrt,2
245102,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft,31,Microsoft,1
245103,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal,31,Terminal,1
245104,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings,31,Settings,1
245105,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings.Model,31,Model,1
245106,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(SeparatorEntry);
}",1,cascadia\TerminalSettingsModel\SeparatorEntry.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,31,factory_implementation,1
245109,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\SettingsTypes.hpp,cascadia\TerminalSettingsModel\SettingsTypes.hpp:<global>,,<global>,1
245113,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    enum class ExpandCommandType : uint32_t
    {
        None = 0,
        Profiles,
        ColorSchemes
    };
}",1,cascadia\TerminalSettingsModel\SettingsTypes.hpp,winrt,14,winrt,1
245114,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    enum class ExpandCommandType : uint32_t
    {
        None = 0,
        Profiles,
        ColorSchemes
    };
}",1,cascadia\TerminalSettingsModel\SettingsTypes.hpp,winrt.Microsoft,14,Microsoft,1
245115,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    enum class ExpandCommandType : uint32_t
    {
        None = 0,
        Profiles,
        ColorSchemes
    };
}",1,cascadia\TerminalSettingsModel\SettingsTypes.hpp,winrt.Microsoft.Terminal,14,Terminal,1
245116,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    enum class ExpandCommandType : uint32_t
    {
        None = 0,
        Profiles,
        ColorSchemes
    };
}",1,cascadia\TerminalSettingsModel\SettingsTypes.hpp,winrt.Microsoft.Terminal.Settings,14,Settings,1
245117,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    enum class ExpandCommandType : uint32_t
    {
        None = 0,
        Profiles,
        ColorSchemes
    };
}",1,cascadia\TerminalSettingsModel\SettingsTypes.hpp,winrt.Microsoft.Terminal.Settings.Model,14,Model,1
245138,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\SshHostGenerator.cpp,cascadia\TerminalSettingsModel\SshHostGenerator.cpp:<global>,,<global>,1
245316,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,cascadia\TerminalSettingsModel\SshHostGenerator.hpp:<global>,,<global>,1
245320,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class SshHostGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        static const std::wregex _configKeyValueRegex;

        static std::wstring_view _getProfileName(const std::wstring_view& hostName) noexcept;
        static std::wstring_view _getProfileIconPath() noexcept;
        static std::wstring_view _getProfileCommandLine(const std::wstring_view& sshExePath, const std::wstring_view& hostName) noexcept;

        static bool _tryFindSshExePath(std::wstring& sshExePath) noexcept;
        static bool _tryParseConfigKeyValue(const std::wstring_view& line, std::wstring& key, std::wstring& value) noexcept;
        static void _getHostNamesFromConfigFile(const std::wstring_view& configPath, std::vector<std::wstring>& ...",1,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,winrt,21,winrt,1
245321,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class SshHostGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        static const std::wregex _configKeyValueRegex;

        static std::wstring_view _getProfileName(const std::wstring_view& hostName) noexcept;
        static std::wstring_view _getProfileIconPath() noexcept;
        static std::wstring_view _getProfileCommandLine(const std::wstring_view& sshExePath, const std::wstring_view& hostName) noexcept;

        static bool _tryFindSshExePath(std::wstring& sshExePath) noexcept;
        static bool _tryParseConfigKeyValue(const std::wstring_view& line, std::wstring& key, std::wstring& value) noexcept;
        static void _getHostNamesFromConfigFile(const std::wstring_view& configPath, std::vector<std::wstring>& ...",1,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,winrt.Microsoft,21,Microsoft,1
245322,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class SshHostGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        static const std::wregex _configKeyValueRegex;

        static std::wstring_view _getProfileName(const std::wstring_view& hostName) noexcept;
        static std::wstring_view _getProfileIconPath() noexcept;
        static std::wstring_view _getProfileCommandLine(const std::wstring_view& sshExePath, const std::wstring_view& hostName) noexcept;

        static bool _tryFindSshExePath(std::wstring& sshExePath) noexcept;
        static bool _tryParseConfigKeyValue(const std::wstring_view& line, std::wstring& key, std::wstring& value) noexcept;
        static void _getHostNamesFromConfigFile(const std::wstring_view& configPath, std::vector<std::wstring>& ...",1,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,winrt.Microsoft.Terminal,21,Terminal,1
245323,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class SshHostGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        static const std::wregex _configKeyValueRegex;

        static std::wstring_view _getProfileName(const std::wstring_view& hostName) noexcept;
        static std::wstring_view _getProfileIconPath() noexcept;
        static std::wstring_view _getProfileCommandLine(const std::wstring_view& sshExePath, const std::wstring_view& hostName) noexcept;

        static bool _tryFindSshExePath(std::wstring& sshExePath) noexcept;
        static bool _tryParseConfigKeyValue(const std::wstring_view& line, std::wstring& key, std::wstring& value) noexcept;
        static void _getHostNamesFromConfigFile(const std::wstring_view& configPath, std::vector<std::wstring>& ...",1,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
245324,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class SshHostGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        static const std::wregex _configKeyValueRegex;

        static std::wstring_view _getProfileName(const std::wstring_view& hostName) noexcept;
        static std::wstring_view _getProfileIconPath() noexcept;
        static std::wstring_view _getProfileCommandLine(const std::wstring_view& sshExePath, const std::wstring_view& hostName) noexcept;

        static bool _tryFindSshExePath(std::wstring& sshExePath) noexcept;
        static bool _tryParseConfigKeyValue(const std::wstring_view& line, std::wstring& key, std::wstring& value) noexcept;
        static void _getHostNamesFromConfigFile(const std::wstring_view& configPath, std::vector<std::wstring>& ...",1,cascadia\TerminalSettingsModel\SshHostGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
245405,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\TerminalSettings.cpp,cascadia\TerminalSettingsModel\TerminalSettings.cpp:<global>,,<global>,1
245408,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt,14,winrt,1
245409,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt.Microsoft,14,Microsoft,1
245410,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt.Microsoft.Terminal,14,Terminal,1
245411,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt.Microsoft.Terminal.Settings,14,Settings,1
245412,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt.Microsoft.Terminal.Settings.Model,14,Model,1
245413,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    static std::tuple<Windows::UI::Xaml::HorizontalAlignment, Windows::UI::Xaml::VerticalAlignment> ConvertConvergedAlignment(ConvergedAlignment alignment)
    {
        // extract horizontal alignment
        Windows::UI::Xaml::HorizontalAlignment horizAlign;
        switch (alignment & static_cast<ConvergedAlignment>(0x0F))
        {
        case ConvergedAlignment::Horizontal_Left:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Left;
            break;
        case ConvergedAlignment::Horizontal_Right:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Right;
            break;
        case ConvergedAlignment::Horizontal_Center:
        default:
            horizAlign = Windows::UI::Xaml::HorizontalAlignment::Center;
            break;
        }

        // extract vertical alignment
        Windows::UI::Xaml::VerticalAlignment vertAlign;
        switch (alignment & static_cast...",1,cascadia\TerminalSettingsModel\TerminalSettings.cpp,winrt.Microsoft.Terminal.Settings.Model.implementation,14,implementation,1
246895,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\TerminalSettings.hpp,cascadia\TerminalSettingsModel\TerminalSettings.hpp:<global>,,<global>,1
246902,NAMESPACE_BLOCK,"namespace SettingsModelLocalTests
{
    class TerminalSettingsTests;
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,SettingsModelLocalTests,28,SettingsModelLocalTests,4
246904,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt,33,winrt,5
246905,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft,33,Microsoft,1
246906,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal,33,Terminal,1
246907,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings,33,Settings,1
246908,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,33,Model,1
246909,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct TerminalSettingsCreateResult :
        public TerminalSettingsCreateResultT<TerminalSettingsCreateResult>
    {
    public:
        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings, Model::TerminalSettings unfocusedSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(unfocusedSettings) {}

        TerminalSettingsCreateResult(Model::TerminalSettings defaultSettings) :
            _defaultSettings(defaultSettings),
            _unfocusedSettings(nullptr) {}

        Model::TerminalSettings DefaultSettings() { return _defaultSettings; };
        Model::TerminalSettings UnfocusedSettings() { return _unfocusedSettings; };

    private:
        Model::TerminalSettings _defaultSettings;
        Model::TerminalSettings _unfocusedSettings;
    };

    struct TerminalSettings : TerminalSettingsT<TerminalSettings>, IInheritable<TerminalSettings>
    {
   ...",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,33,implementation,1
255239,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt,188,winrt,6
255240,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft,188,Microsoft,1
255241,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal,188,Terminal,1
255242,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings,188,Settings,1
255243,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings.Model,188,Model,1
255244,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(TerminalSettingsCreateResult);
    BASIC_FACTORY(TerminalSettings);
}",1,cascadia\TerminalSettingsModel\TerminalSettings.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,188,factory_implementation,1
255256,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\TerminalSettingsSerializationHelpers.hpp,cascadia\TerminalSettingsModel\TerminalSettingsSerializationHelpers.hpp:<global>,,<global>,1
255381,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,cascadia\TerminalSettingsModel\TerminalWarnings.hpp:<global>,,<global>,1
255385,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt,18,winrt,1
255386,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt.Microsoft,18,Microsoft,1
255387,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt.Microsoft.Terminal,18,Terminal,1
255388,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt.Microsoft.Terminal.Settings,18,Settings,1
255389,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt.Microsoft.Terminal.Settings.Model,18,Model,1
255390,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    // This is a helper class to wrap up a SettingsLoadErrors into a proper
    // exception type.
    class SettingsException : public std::runtime_error
    {
    public:
        explicit SettingsException(const SettingsLoadErrors& error) :
            std::runtime_error{ nullptr },
            _error{ error } {};

        // We don't use the what() method - we want to be able to display
        // localizable error messages. Catchers of this exception should use
        // _GetErrorText (in App.cpp) to get the localized exception string.
        const char* what() const override
        {
            return ""Exception while loading or validating Terminal settings"";
        };

        SettingsLoadErrors Error() const noexcept { return _error; };

    private:
        const SettingsLoadErrors _error;
    };
}",1,cascadia\TerminalSettingsModel\TerminalWarnings.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,18,implementation,1
255464,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Theme.cpp,cascadia\TerminalSettingsModel\Theme.cpp:<global>,,<global>,1
255467,NAMESPACE_BLOCK,"namespace winrt
{
    namespace MUX = Microsoft::UI::Xaml;
    namespace WUX = Windows::UI::Xaml;
}",1,cascadia\TerminalSettingsModel\Theme.cpp,winrt,24,winrt,1
255468,NAMESPACE_BLOCK,namespace MUX = Microsoft::UI::Xaml;,5,cascadia\TerminalSettingsModel\Theme.cpp,Microsoft.UI.Xaml,26,MUX,1
255469,NAMESPACE_BLOCK,namespace WUX = Windows::UI::Xaml;,5,cascadia\TerminalSettingsModel\Theme.cpp,Windows.UI.Xaml,27,WUX,2
256511,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\Theme.hpp,cascadia\TerminalSettingsModel\Theme.hpp:<global>,,<global>,1
256515,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt,30,winrt,1
256516,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft,30,Microsoft,1
256517,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal,30,Terminal,1
256518,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings,30,Settings,1
256519,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings.Model,30,Model,1
256520,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::implementation
{
    struct ThemePair : ThemePairT<ThemePair>
    {
    public:
        ThemePair() = default;
        explicit ThemePair(const winrt::hstring& name) noexcept :
            _DarkName{ name },
            _LightName{ name } {};

        explicit ThemePair(const winrt::hstring& lightName, const winrt::hstring& darkName) noexcept :
            _DarkName{ darkName },
            _LightName{ lightName } {};

        static com_ptr<ThemePair> FromJson(const Json::Value& json);
        Json::Value ToJson() const;
        com_ptr<ThemePair> Copy() const;

        WINRT_PROPERTY(winrt::hstring, DarkName);
        WINRT_PROPERTY(winrt::hstring, LightName);
    };

    struct ThemeColor : ThemeColorT<ThemeColor>
    {
    public:
        ThemeColor() noexcept = default;
        static winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromColor(const winrt::Microsoft::Terminal::Core::Color& coreColor) noexcept;
       ...",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings.Model.implementation,30,implementation,1
256660,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt,116,winrt,2
256661,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft,116,Microsoft,1
256662,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal,116,Terminal,1
256663,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings,116,Settings,1
256664,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings.Model,116,Model,1
256665,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation
{
    BASIC_FACTORY(ThemeColor);
    BASIC_FACTORY(Theme);
    BASIC_FACTORY(ThemePair);
}",1,cascadia\TerminalSettingsModel\Theme.hpp,winrt.Microsoft.Terminal.Settings.Model.factory_implementation,116,factory_implementation,1
256669,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<>
    struct ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemePair>
    {
        winrt::Microsoft::Terminal::Settings::Model::ThemePair FromJson(const Json::Value& json)
        {
            return *winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair::FromJson(json);
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject() || json.isString();
        }

        Json::Value ToJson(const winrt::Microsoft::Terminal::Settings::Model::ThemePair& val)
        {
            return winrt::get_self<winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""ThemePair{ string, string }"";
        }
    };
}",1,cascadia\TerminalSettingsModel\Theme.hpp,Microsoft,123,Microsoft,3
256670,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<>
    struct ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemePair>
    {
        winrt::Microsoft::Terminal::Settings::Model::ThemePair FromJson(const Json::Value& json)
        {
            return *winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair::FromJson(json);
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject() || json.isString();
        }

        Json::Value ToJson(const winrt::Microsoft::Terminal::Settings::Model::ThemePair& val)
        {
            return winrt::get_self<winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""ThemePair{ string, string }"";
        }
    };
}",1,cascadia\TerminalSettingsModel\Theme.hpp,Microsoft.Terminal,123,Terminal,1
256671,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<>
    struct ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemePair>
    {
        winrt::Microsoft::Terminal::Settings::Model::ThemePair FromJson(const Json::Value& json)
        {
            return *winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair::FromJson(json);
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject() || json.isString();
        }

        Json::Value ToJson(const winrt::Microsoft::Terminal::Settings::Model::ThemePair& val)
        {
            return winrt::get_self<winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""ThemePair{ string, string }"";
        }
    };
}",1,cascadia\TerminalSettingsModel\Theme.hpp,Microsoft.Terminal.Settings,123,Settings,1
256672,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<>
    struct ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemePair>
    {
        winrt::Microsoft::Terminal::Settings::Model::ThemePair FromJson(const Json::Value& json)
        {
            return *winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair::FromJson(json);
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject() || json.isString();
        }

        Json::Value ToJson(const winrt::Microsoft::Terminal::Settings::Model::ThemePair& val)
        {
            return winrt::get_self<winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""ThemePair{ string, string }"";
        }
    };
}",1,cascadia\TerminalSettingsModel\Theme.hpp,Microsoft.Terminal.Settings.Model,123,Model,1
256673,NAMESPACE_BLOCK,"namespace Microsoft::Terminal::Settings::Model::JsonUtils
{
    template<>
    struct ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemePair>
    {
        winrt::Microsoft::Terminal::Settings::Model::ThemePair FromJson(const Json::Value& json)
        {
            return *winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair::FromJson(json);
        }

        bool CanConvert(const Json::Value& json) const
        {
            return json.isObject() || json.isString();
        }

        Json::Value ToJson(const winrt::Microsoft::Terminal::Settings::Model::ThemePair& val)
        {
            return winrt::get_self<winrt::Microsoft::Terminal::Settings::Model::implementation::ThemePair>(val)->ToJson();
        }

        std::string TypeDescription() const
        {
            return ""ThemePair{ string, string }"";
        }
    };
}",1,cascadia\TerminalSettingsModel\Theme.hpp,Microsoft.Terminal.Settings.Model.JsonUtils,123,JsonUtils,1
256759,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VisualStudioGenerator.cpp,cascadia\TerminalSettingsModel\VisualStudioGenerator.cpp:<global>,,<global>,1
256815,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp:<global>,,<global>,1
256819,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VisualStudioGenerator : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

        class IVisualStudioProfileGenerator
        {
        public:
            virtual void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
        };
    };
}",1,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,winrt,24,winrt,1
256820,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VisualStudioGenerator : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

        class IVisualStudioProfileGenerator
        {
        public:
            virtual void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
        };
    };
}",1,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,winrt.Microsoft,24,Microsoft,1
256821,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VisualStudioGenerator : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

        class IVisualStudioProfileGenerator
        {
        public:
            virtual void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
        };
    };
}",1,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,winrt.Microsoft.Terminal,24,Terminal,1
256822,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VisualStudioGenerator : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

        class IVisualStudioProfileGenerator
        {
        public:
            virtual void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
        };
    };
}",1,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,winrt.Microsoft.Terminal.Settings,24,Settings,1
256823,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VisualStudioGenerator : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

        class IVisualStudioProfileGenerator
        {
        public:
            virtual void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const = 0;
        };
    };
}",1,cascadia\TerminalSettingsModel\VisualStudioGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,24,Model,1
256849,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsDevCmdGenerator.cpp,cascadia\TerminalSettingsModel\VsDevCmdGenerator.cpp:<global>,,<global>,1
256926,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp:<global>,,<global>,1
256930,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevCmdGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance&) const
        {
            // We only support version of VS from 15.0.
            // Per heaths: The [ISetupConfiguration] COM server only supports Visual Studio 15.0 and newer anyway.
            // Eliding the version range will improve the discovery performance by not having to parse or compare the versions.
            return true;
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevCmd"" + instance.GetInstanceId();
        }

        std::wstring GetProf...",1,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,winrt,21,winrt,1
256931,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevCmdGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance&) const
        {
            // We only support version of VS from 15.0.
            // Per heaths: The [ISetupConfiguration] COM server only supports Visual Studio 15.0 and newer anyway.
            // Eliding the version range will improve the discovery performance by not having to parse or compare the versions.
            return true;
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevCmd"" + instance.GetInstanceId();
        }

        std::wstring GetProf...",1,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,winrt.Microsoft,21,Microsoft,1
256932,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevCmdGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance&) const
        {
            // We only support version of VS from 15.0.
            // Per heaths: The [ISetupConfiguration] COM server only supports Visual Studio 15.0 and newer anyway.
            // Eliding the version range will improve the discovery performance by not having to parse or compare the versions.
            return true;
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevCmd"" + instance.GetInstanceId();
        }

        std::wstring GetProf...",1,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,winrt.Microsoft.Terminal,21,Terminal,1
256933,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevCmdGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance&) const
        {
            // We only support version of VS from 15.0.
            // Per heaths: The [ISetupConfiguration] COM server only supports Visual Studio 15.0 and newer anyway.
            // Eliding the version range will improve the discovery performance by not having to parse or compare the versions.
            return true;
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevCmd"" + instance.GetInstanceId();
        }

        std::wstring GetProf...",1,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
256934,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevCmdGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance&) const
        {
            // We only support version of VS from 15.0.
            // Per heaths: The [ISetupConfiguration] COM server only supports Visual Studio 15.0 and newer anyway.
            // Eliding the version range will improve the discovery performance by not having to parse or compare the versions.
            return true;
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevCmd"" + instance.GetInstanceId();
        }

        std::wstring GetProf...",1,cascadia\TerminalSettingsModel\VsDevCmdGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
256992,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsDevShellGenerator.cpp,cascadia\TerminalSettingsModel\VsDevShellGenerator.cpp:<global>,,<global>,1
257095,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp:<global>,,<global>,1
257099,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevShellGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return instance.VersionInRange(L""[16.2,)"");
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevShell"" + instance.GetInstanceId();
        }

        std::wstring GetProfileIconPath() const
        {
            return L""ms-appx:///ProfileIcons/{61c54bbd-c2c6-5271-96e7-009a87ff44bf}.png"";
        }

        std::wstring GetProfileName(const VsSetupConfiguration::VsSetupInstance& instance) const;
        std::wstring GetPr...",1,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,winrt,21,winrt,1
257100,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevShellGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return instance.VersionInRange(L""[16.2,)"");
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevShell"" + instance.GetInstanceId();
        }

        std::wstring GetProfileIconPath() const
        {
            return L""ms-appx:///ProfileIcons/{61c54bbd-c2c6-5271-96e7-009a87ff44bf}.png"";
        }

        std::wstring GetProfileName(const VsSetupConfiguration::VsSetupInstance& instance) const;
        std::wstring GetPr...",1,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,winrt.Microsoft,21,Microsoft,1
257101,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevShellGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return instance.VersionInRange(L""[16.2,)"");
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevShell"" + instance.GetInstanceId();
        }

        std::wstring GetProfileIconPath() const
        {
            return L""ms-appx:///ProfileIcons/{61c54bbd-c2c6-5271-96e7-009a87ff44bf}.png"";
        }

        std::wstring GetProfileName(const VsSetupConfiguration::VsSetupInstance& instance) const;
        std::wstring GetPr...",1,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,winrt.Microsoft.Terminal,21,Terminal,1
257102,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevShellGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return instance.VersionInRange(L""[16.2,)"");
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevShell"" + instance.GetInstanceId();
        }

        std::wstring GetProfileIconPath() const
        {
            return L""ms-appx:///ProfileIcons/{61c54bbd-c2c6-5271-96e7-009a87ff44bf}.png"";
        }

        std::wstring GetProfileName(const VsSetupConfiguration::VsSetupInstance& instance) const;
        std::wstring GetPr...",1,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
257103,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class VsDevShellGenerator final : public VisualStudioGenerator::IVisualStudioProfileGenerator
    {
    public:
        void GenerateProfiles(const VsSetupConfiguration::VsSetupInstance& instance, bool hidden, std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;

    private:
        bool IsInstanceValid(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return instance.VersionInRange(L""[16.2,)"");
        }

        std::wstring GetProfileGuidSeed(const VsSetupConfiguration::VsSetupInstance& instance) const
        {
            return L""VsDevShell"" + instance.GetInstanceId();
        }

        std::wstring GetProfileIconPath() const
        {
            return L""ms-appx:///ProfileIcons/{61c54bbd-c2c6-5271-96e7-009a87ff44bf}.png"";
        }

        std::wstring GetProfileName(const VsSetupConfiguration::VsSetupInstance& instance) const;
        std::wstring GetPr...",1,cascadia\TerminalSettingsModel\VsDevShellGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
257202,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsSetupConfiguration.cpp,cascadia\TerminalSettingsModel\VsSetupConfiguration.cpp:<global>,,<global>,1
257497,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp:<global>,,<global>,1
257501,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    /// <summary>
    /// See https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration?view=visualstudiosdk-2019
    /// </summary>
    class VsSetupConfiguration
    {
        typedef wil::com_ptr<ISetupConfiguration2> ComPtrSetupQuery;
        typedef wil::com_ptr<ISetupHelper> ComPtrSetupHelper;
        typedef wil::com_ptr<ISetupInstance> ComPtrSetupInstance;
        typedef wil::com_ptr<ISetupInstance2> ComPtrSetupInstance2;
        typedef wil::com_ptr<ISetupPropertyStore> ComPtrPropertyStore;
        typedef wil::com_ptr<ISetupPackageReference> ComPtrPackageReference;
        typedef wil::com_ptr<ISetupInstanceCatalog> ComPtrInstanceCatalog;
        typedef ComPtrPropertyStore ComPtrCustomPropertyStore;
        typedef ComPtrPropertyStore ComPtrCatalogPropertyStore;

    public:
        struct VsSetupInstance
        {
            VsSetupInstance(VsSetupInstance&& other) = default;
         ...",1,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,winrt,21,winrt,1
257502,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    /// <summary>
    /// See https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration?view=visualstudiosdk-2019
    /// </summary>
    class VsSetupConfiguration
    {
        typedef wil::com_ptr<ISetupConfiguration2> ComPtrSetupQuery;
        typedef wil::com_ptr<ISetupHelper> ComPtrSetupHelper;
        typedef wil::com_ptr<ISetupInstance> ComPtrSetupInstance;
        typedef wil::com_ptr<ISetupInstance2> ComPtrSetupInstance2;
        typedef wil::com_ptr<ISetupPropertyStore> ComPtrPropertyStore;
        typedef wil::com_ptr<ISetupPackageReference> ComPtrPackageReference;
        typedef wil::com_ptr<ISetupInstanceCatalog> ComPtrInstanceCatalog;
        typedef ComPtrPropertyStore ComPtrCustomPropertyStore;
        typedef ComPtrPropertyStore ComPtrCatalogPropertyStore;

    public:
        struct VsSetupInstance
        {
            VsSetupInstance(VsSetupInstance&& other) = default;
         ...",1,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,winrt.Microsoft,21,Microsoft,1
257503,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    /// <summary>
    /// See https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration?view=visualstudiosdk-2019
    /// </summary>
    class VsSetupConfiguration
    {
        typedef wil::com_ptr<ISetupConfiguration2> ComPtrSetupQuery;
        typedef wil::com_ptr<ISetupHelper> ComPtrSetupHelper;
        typedef wil::com_ptr<ISetupInstance> ComPtrSetupInstance;
        typedef wil::com_ptr<ISetupInstance2> ComPtrSetupInstance2;
        typedef wil::com_ptr<ISetupPropertyStore> ComPtrPropertyStore;
        typedef wil::com_ptr<ISetupPackageReference> ComPtrPackageReference;
        typedef wil::com_ptr<ISetupInstanceCatalog> ComPtrInstanceCatalog;
        typedef ComPtrPropertyStore ComPtrCustomPropertyStore;
        typedef ComPtrPropertyStore ComPtrCatalogPropertyStore;

    public:
        struct VsSetupInstance
        {
            VsSetupInstance(VsSetupInstance&& other) = default;
         ...",1,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,winrt.Microsoft.Terminal,21,Terminal,1
257504,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    /// <summary>
    /// See https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration?view=visualstudiosdk-2019
    /// </summary>
    class VsSetupConfiguration
    {
        typedef wil::com_ptr<ISetupConfiguration2> ComPtrSetupQuery;
        typedef wil::com_ptr<ISetupHelper> ComPtrSetupHelper;
        typedef wil::com_ptr<ISetupInstance> ComPtrSetupInstance;
        typedef wil::com_ptr<ISetupInstance2> ComPtrSetupInstance2;
        typedef wil::com_ptr<ISetupPropertyStore> ComPtrPropertyStore;
        typedef wil::com_ptr<ISetupPackageReference> ComPtrPackageReference;
        typedef wil::com_ptr<ISetupInstanceCatalog> ComPtrInstanceCatalog;
        typedef ComPtrPropertyStore ComPtrCustomPropertyStore;
        typedef ComPtrPropertyStore ComPtrCatalogPropertyStore;

    public:
        struct VsSetupInstance
        {
            VsSetupInstance(VsSetupInstance&& other) = default;
         ...",1,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
257505,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    /// <summary>
    /// See https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration?view=visualstudiosdk-2019
    /// </summary>
    class VsSetupConfiguration
    {
        typedef wil::com_ptr<ISetupConfiguration2> ComPtrSetupQuery;
        typedef wil::com_ptr<ISetupHelper> ComPtrSetupHelper;
        typedef wil::com_ptr<ISetupInstance> ComPtrSetupInstance;
        typedef wil::com_ptr<ISetupInstance2> ComPtrSetupInstance2;
        typedef wil::com_ptr<ISetupPropertyStore> ComPtrPropertyStore;
        typedef wil::com_ptr<ISetupPackageReference> ComPtrPackageReference;
        typedef wil::com_ptr<ISetupInstanceCatalog> ComPtrInstanceCatalog;
        typedef ComPtrPropertyStore ComPtrCustomPropertyStore;
        typedef ComPtrPropertyStore ComPtrCatalogPropertyStore;

    public:
        struct VsSetupInstance
        {
            VsSetupInstance(VsSetupInstance&& other) = default;
         ...",1,cascadia\TerminalSettingsModel\VsSetupConfiguration.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
258068,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\WslDistroGenerator.cpp,cascadia\TerminalSettingsModel\WslDistroGenerator.cpp:<global>,,<global>,1
258501,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp:<global>,,<global>,1
258505,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class WslDistroGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,winrt,21,winrt,1
258506,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class WslDistroGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,winrt.Microsoft,21,Microsoft,1
258507,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class WslDistroGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,winrt.Microsoft.Terminal,21,Terminal,1
258508,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class WslDistroGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,winrt.Microsoft.Terminal.Settings,21,Settings,1
258509,NAMESPACE_BLOCK,"namespace winrt::Microsoft::Terminal::Settings::Model
{
    class WslDistroGenerator final : public IDynamicProfileGenerator
    {
    public:
        std::wstring_view GetNamespace() const noexcept override;
        void GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles) const override;
    };
}",1,cascadia\TerminalSettingsModel\WslDistroGenerator.hpp,winrt.Microsoft.Terminal.Settings.Model,21,Model,1
258527,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\init.cpp,cascadia\TerminalSettingsModel\init.cpp:<global>,,<global>,1
258573,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\pch.cpp,cascadia\TerminalSettingsModel\pch.cpp:<global>,,<global>,1
258640,NAMESPACE_BLOCK,<empty>,,cascadia\TerminalSettingsModel\pch.hpp,cascadia\TerminalSettingsModel\pch.hpp:<global>,,<global>,1
258739,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\ControlCoreTests.cpp,cascadia\UnitTests_Control\ControlCoreTests.cpp:<global>,,<global>,1
258742,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class ControlCoreTests
    {
        BEGIN_TEST_CLASS(ControlCoreTests)
            TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:10"") // 10s timeout
        END_TEST_CLASS()

        TEST_METHOD(ComPtrSettings);
        TEST_METHOD(InstantiateCore);
        TEST_METHOD(TestInitialize);
        TEST_METHOD(TestAdjustAcrylic);

        TEST_METHOD(TestFreeAfterClose);

        TEST_METHOD(TestFontInitializedInCtor);

        TEST_METHOD(TestClearScrollback);
        TEST_METHOD(TestClearScreen);
        TEST_METHOD(TestClearAll);
        TEST_METHOD(TestReadEntireBuffer);

        TEST_METHOD(TestSelectCommandSimple);
        TEST_METHOD(TestSelectOutputSimple);

        TEST_METHOD(TestSimpleClickSelection);

        TEST_CLASS_SETUP(ModuleSetup)
        {
            winrt::init_apartment(winrt::apartment_type::single_threaded);

            return true;
        }
        TEST_CLASS_CLEANUP(ClassCleanup)
        {
            winrt::uninit_apartment();
...",1,cascadia\UnitTests_Control\ControlCoreTests.cpp,ControlUnitTests,19,ControlUnitTests,1
260512,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>,,<global>,1
260515,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class ControlInteractivityTests
    {
        BEGIN_TEST_CLASS(ControlInteractivityTests)
            TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:10"") // 10s timeout
        END_TEST_CLASS()

        TEST_METHOD(TestAdjustAcrylic);
        TEST_METHOD(TestScrollWithMouse);

        TEST_METHOD(CreateSubsequentSelectionWithDragging);
        TEST_METHOD(ScrollWithSelection);
        TEST_METHOD(TestScrollWithTrackpad);
        TEST_METHOD(TestQuickDragOnSelect);

        TEST_METHOD(TestDragSelectOutsideBounds);

        TEST_METHOD(PointerClickOutsideActiveRegion);
        TEST_METHOD(IncrementCircularBufferWithSelection);

        TEST_METHOD(GetMouseEventsInTest);
        TEST_METHOD(AltBufferClampMouse);

        TEST_CLASS_SETUP(ClassSetup)
        {
            winrt::init_apartment(winrt::apartment_type::single_threaded);

            return true;
        }
        TEST_CLASS_CLEANUP(ClassCleanup)
        {
            winrt::uninit_apartment();
...",1,cascadia\UnitTests_Control\ControlInteractivityTests.cpp,ControlUnitTests,22,ControlUnitTests,1
263863,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\MockConnection.hpp,cascadia\UnitTests_Control\MockConnection.hpp:<global>,,<global>,1
263867,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class MockConnection : public winrt::implements<MockConnection, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection>
    {
    public:
        MockConnection() noexcept = default;

        void Initialize(const winrt::Windows::Foundation::Collections::ValueSet& /*settings*/){};
        void Start() noexcept {};
        void WriteInput(const winrt::hstring& data)
        {
            _TerminalOutputHandlers(data);
        }
        void Resize(uint32_t /*rows*/, uint32_t /*columns*/) noexcept {}
        void Close() noexcept {}

        winrt::Microsoft::Terminal::TerminalConnection::ConnectionState State() const noexcept { return winrt::Microsoft::Terminal::TerminalConnection::ConnectionState::Connected; }

        WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);
        TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspectable);
 ...",1,cascadia\UnitTests_Control\MockConnection.hpp,ControlUnitTests,10,ControlUnitTests,1
263924,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\MockControlSettings.hpp,cascadia\UnitTests_Control\MockControlSettings.hpp:<global>,,<global>,1
263930,NAMESPACE_BLOCK,"namespace ControlUnitTests
{
    class MockControlSettings : public winrt::implements<MockControlSettings, winrt::Microsoft::Terminal::Core::ICoreSettings, winrt::Microsoft::Terminal::Control::IControlSettings, winrt::Microsoft::Terminal::Core::ICoreAppearance, winrt::Microsoft::Terminal::Control::IControlAppearance>
    {
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

#define SETTINGS_GEN(type, name, ...) WINRT_PROPERTY(type, name, __VA_ARGS__);
        CORE_SETTINGS(SETTINGS_GEN)
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
        CONTROL_SETTINGS(SETTINGS_GEN)
        CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    public:
        MockControlSettings() = default;

        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index...",1,cascadia\UnitTests_Control\MockControlSettings.hpp,ControlUnitTests,14,ControlUnitTests,3
264022,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\pch.cpp,cascadia\UnitTests_Control\pch.cpp:<global>,,<global>,1
264073,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Control\pch.hpp,cascadia\UnitTests_Control\pch.hpp:<global>,,<global>,1
265049,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Remoting\RemotingTests.cpp,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>,,<global>,1
265052,NAMESPACE_BLOCK,"namespace RemotingUnitTests
{
    struct MockDesktopManager : implements<MockDesktopManager, IVirtualDesktopManager>
    {
        IFACEMETHOD(GetWindowDesktopId)
        (HWND /*topLevelWindow*/, GUID* /*desktopId*/)
        {
            VERIFY_IS_TRUE(false, L""We shouldn't need GetWindowDesktopId in the tests."");
            return E_FAIL;
        }
        IFACEMETHOD(MoveWindowToDesktop)
        (HWND /*topLevelWindow*/, REFGUID /*desktopId*/)
        {
            VERIFY_IS_TRUE(false, L""We shouldn't need GetWindowDesktopId in the tests."");
            return E_FAIL;
        }
        IFACEMETHOD(IsWindowOnCurrentVirtualDesktop)
        (HWND topLevelWindow, BOOL* onCurrentDesktop)
        {
            if (pfnIsWindowOnCurrentVirtualDesktop)
            {
                return pfnIsWindowOnCurrentVirtualDesktop(topLevelWindow, onCurrentDesktop);
            }
            VERIFY_IS_TRUE(false, L""You didn't set up the pfnIsWindowOnCurrentVirtualDesktop for this test!"");
      ...",1,cascadia\UnitTests_Remoting\RemotingTests.cpp,RemotingUnitTests,19,RemotingUnitTests,1
274678,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Remoting\pch.cpp,cascadia\UnitTests_Remoting\pch.cpp:<global>,,<global>,1
274719,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_Remoting\pch.hpp,cascadia\UnitTests_Remoting\pch.hpp:<global>,,<global>,1
278960,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>,,<global>,1
278963,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class ConptyRoundtripTests;
}",1,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp,TerminalCoreUnitTests,43,TerminalCoreUnitTests,1
289120,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\InputTest.cpp,cascadia\UnitTests_TerminalCore\InputTest.cpp:<global>,,<global>,1
289141,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class InputTest
    {
        TEST_CLASS(InputTest);

        TEST_METHOD(AltShiftKey);
        TEST_METHOD(InvalidKeyEvent);

        Terminal term{ Terminal::TestDummyMarker{} };
    };

    void InputTest::AltShiftKey()
    {
        // Tests GH:637

        // Verify that Alt+a generates a lowercase a on the input
        VERIFY_ARE_EQUAL(escChar(L'a'), term.SendCharEvent(L'a', 0, ControlKeyStates::LeftAltPressed));

        // Verify that Alt+shift+a generates a uppercase a on the input
        VERIFY_ARE_EQUAL(escChar(L'A'), term.SendCharEvent(L'A', 0, ControlKeyStates::LeftAltPressed | ControlKeyStates::ShiftPressed));
    }

    void InputTest::InvalidKeyEvent()
    {
        // Certain applications like AutoHotKey and its keyboard remapping feature,
        // send us key events using SendInput() whose values are outside of the valid range.
        VERIFY_ARE_EQUAL(unhandled(), term.SendKeyEvent(0, 123, {}, true));
        VERIFY_ARE_EQ...",1,cascadia\UnitTests_TerminalCore\InputTest.cpp,TerminalCoreUnitTests,25,TerminalCoreUnitTests,3
289225,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\MockTermSettings.hpp,cascadia\UnitTests_TerminalCore\MockTermSettings.hpp:<global>,,<global>,1
289229,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class MockTermSettings : public winrt::implements<MockTermSettings, ICoreSettings, ICoreAppearance>
    {
        // Color Table is special because it's an array
        std::array<winrt::Microsoft::Terminal::Core::Color, COLOR_TABLE_SIZE> _ColorTable;

    public:
#define SETTINGS_GEN(type, name, ...) til::property<type> name{ __VA_ARGS__ };
        CORE_SETTINGS(SETTINGS_GEN)
        CORE_APPEARANCE_SETTINGS(SETTINGS_GEN)
#undef SETTINGS_GEN

    public:
        MockTermSettings(int32_t historySize, int32_t initialRows, int32_t initialCols) :
            HistorySize(historySize),
            InitialRows(initialRows),
            InitialCols(initialCols)
        {
        }

        winrt::Microsoft::Terminal::Core::Color GetColorTableEntry(int32_t index) noexcept
        {
            return _ColorTable.at(index);
        }
        void SetColorTableEntry(int32_t index,
                                winrt::Microsoft::Terminal::Core::Color co...",1,cascadia\UnitTests_TerminalCore\MockTermSettings.hpp,TerminalCoreUnitTests,14,TerminalCoreUnitTests,1
289426,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\ScreenSizeLimitsTest.cpp,cascadia\UnitTests_TerminalCore\ScreenSizeLimitsTest.cpp:<global>,,<global>,1
289430,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
#define WCS(x) WCSHELPER(x)
#define WCSHELPER(x) L## #x

    class ScreenSizeLimitsTest
    {
        TEST_CLASS(ScreenSizeLimitsTest);

        TEST_METHOD(ScreenWidthAndHeightAreClampedToBounds);
        TEST_METHOD(ScrollbackHistorySizeIsClampedToBounds);

        TEST_METHOD(ResizeIsClampedToBounds);
    };
}",1,cascadia\UnitTests_TerminalCore\ScreenSizeLimitsTest.cpp,TerminalCoreUnitTests,18,TerminalCoreUnitTests,1
289899,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\ScrollTest.cpp,cascadia\UnitTests_TerminalCore\ScrollTest.cpp:<global>,,<global>,1
289903,NAMESPACE_BLOCK,"namespace
{
    class MockScrollRenderEngine final : public RenderEngineBase
    {
    public:
        std::optional<til::point> TriggerScrollDelta() const
        {
            return _triggerScrollDelta;
        }

        void Reset()
        {
            _triggerScrollDelta.reset();
        }

        HRESULT StartPaint() noexcept { return S_OK; }
        HRESULT EndPaint() noexcept { return S_OK; }
        HRESULT Present() noexcept { return S_OK; }
        HRESULT PrepareForTeardown(_Out_ bool* /*pForcePaint*/) noexcept { return S_OK; }
        HRESULT ScrollFrame() noexcept { return S_OK; }
        HRESULT Invalidate(const til::rect* /*psrRegion*/) noexcept { return S_OK; }
        HRESULT InvalidateCursor(const til::rect* /*psrRegion*/) noexcept { return S_OK; }
        HRESULT InvalidateSystem(const til::rect* /*prcDirtyClient*/) noexcept { return S_OK; }
        HRESULT InvalidateSelection(const std::vector<til::rect>& /*rectangles*/) noexcept { return S_OK; }
        HRE...",1,cascadia\UnitTests_TerminalCore\ScrollTest.cpp,anonymous_namespace_0,27,,1
290079,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class ScrollTest;
}",1,cascadia\UnitTests_TerminalCore\ScrollTest.cpp,TerminalCoreUnitTests,87,TerminalCoreUnitTests,2
290527,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\SelectionTest.cpp,cascadia\UnitTests_TerminalCore\SelectionTest.cpp:<global>,,<global>,1
290530,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class SelectionTest
    {
        TEST_CLASS(SelectionTest);

        // Method Description:
        // - Validate a selection that spans only one row
        // Arguments:
        // - term: the terminal that is contains the selection
        // - expected: the expected value of the selection rect
        // Return Value:
        // - N/A
        void ValidateSingleRowSelection(Terminal& term, const til::inclusive_rect& expected)
        {
            // Simulate renderer calling TriggerSelection and acquiring selection area
            auto selectionRects = term.GetSelectionRects();

            // Validate selection area
            VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(1));
            auto selection = term.GetViewport().ConvertToOrigin(selectionRects[0]).ToInclusive();

            VERIFY_ARE_EQUAL(selection, expected);
        }

        TEST_METHOD(SelectUnit)
        {
            Terminal term{ Terminal::TestDummyM...",1,cascadia\UnitTests_TerminalCore\SelectionTest.cpp,TerminalCoreUnitTests,22,TerminalCoreUnitTests,1
291403,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\TerminalApiTest.cpp,cascadia\UnitTests_TerminalCore\TerminalApiTest.cpp:<global>,,<global>,1
291406,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
#define WCS(x) WCSHELPER(x)
#define WCSHELPER(x) L## #x

    class TerminalApiTest
    {
        TEST_CLASS(TerminalApiTest);

        TEST_METHOD(SetColorTableEntry);

        TEST_METHOD(CursorVisibility);
        TEST_METHOD(CursorVisibilityViaStateMachine);

        // Terminal::_WriteBuffer used to enter infinite loops under certain conditions.
        // This test ensures that Terminal::_WriteBuffer doesn't get stuck when
        // PrintString() is called with more code units than the buffer width.
        TEST_METHOD(PrintStringOfSurrogatePairs);
        TEST_METHOD(CheckDoubleWidthCursor);

        TEST_METHOD(AddHyperlink);
        TEST_METHOD(AddHyperlinkCustomId);
        TEST_METHOD(AddHyperlinkCustomIdDifferentUri);

        TEST_METHOD(SetTaskbarProgress);
        TEST_METHOD(SetWorkingDirectory);
    };
}",1,cascadia\UnitTests_TerminalCore\TerminalApiTest.cpp,TerminalCoreUnitTests,18,TerminalCoreUnitTests,1
293218,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\TerminalBufferTests.cpp,cascadia\UnitTests_TerminalCore\TerminalBufferTests.cpp:<global>,,<global>,1
293221,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class TerminalBufferTests;
}",1,cascadia\UnitTests_TerminalCore\TerminalBufferTests.cpp,TerminalCoreUnitTests,20,TerminalCoreUnitTests,1
295252,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp:<global>,,<global>,1
295255,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class TilWinRtHelpersTests;
}",1,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp,TerminalCoreUnitTests,29,TerminalCoreUnitTests,1
295652,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\pch.cpp,cascadia\UnitTests_TerminalCore\pch.cpp:<global>,,<global>,1
295691,NAMESPACE_BLOCK,<empty>,,cascadia\UnitTests_TerminalCore\pch.hpp,cascadia\UnitTests_TerminalCore\pch.hpp:<global>,,<global>,1
295702,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\LibraryResources.cpp,cascadia\WinRTUtils\LibraryResources.cpp:<global>,,<global>,1
295715,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\ScopedResourceLoader.cpp,cascadia\WinRTUtils\ScopedResourceLoader.cpp:<global>,,<global>,1
295797,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\Utils.cpp,cascadia\WinRTUtils\Utils.cpp:<global>,,<global>,1
295834,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\LibraryResources.hpp,cascadia\WinRTUtils\inc\LibraryResources.hpp:<global>,,<global>,1
295849,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\SafeDispatcherTimer.hpp,cascadia\WinRTUtils\inc\SafeDispatcherTimer.hpp:<global>,,<global>,1
296015,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\ScopedResourceLoader.hpp,cascadia\WinRTUtils\inc\ScopedResourceLoader.hpp:<global>,,<global>,1
296092,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\ThrottledFunc.hpp,cascadia\WinRTUtils\inc\ThrottledFunc.hpp:<global>,,<global>,1
296281,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\Utils.hpp,cascadia\WinRTUtils\inc\Utils.hpp:<global>,,<global>,1
296479,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\inc\WtExeUtils.hpp,cascadia\WinRTUtils\inc\WtExeUtils.hpp:<global>,,<global>,1
296622,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\pch.cpp,cascadia\WinRTUtils\pch.cpp:<global>,,<global>,1
296649,NAMESPACE_BLOCK,<empty>,,cascadia\WinRTUtils\pch.hpp,cascadia\WinRTUtils\pch.hpp:<global>,,<global>,1
296879,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\AppHost.cpp,cascadia\WindowsTerminal\AppHost.cpp:<global>,,<global>,1
300501,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\AppHost.hpp,cascadia\WindowsTerminal\AppHost.hpp:<global>,,<global>,1
300937,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\BaseWindow.hpp,cascadia\WindowsTerminal\BaseWindow.hpp:<global>,,<global>,1
301462,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\CustomWindowMessages.hpp,cascadia\WindowsTerminal\CustomWindowMessages.hpp:<global>,,<global>,1
301536,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\IslandWindow.cpp,cascadia\WindowsTerminal\IslandWindow.cpp:<global>,,<global>,1
304935,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\IslandWindow.hpp,cascadia\WindowsTerminal\IslandWindow.hpp:<global>,,<global>,1
305505,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\NonClientIslandWindow.cpp,cascadia\WindowsTerminal\NonClientIslandWindow.cpp:<global>,,<global>,1
307444,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\NonClientIslandWindow.hpp,cascadia\WindowsTerminal\NonClientIslandWindow.hpp:<global>,,<global>,1
307687,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\NotificationIcon.cpp,cascadia\WindowsTerminal\NotificationIcon.cpp:<global>,,<global>,1
308317,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\NotificationIcon.hpp,cascadia\WindowsTerminal\NotificationIcon.hpp:<global>,,<global>,1
308384,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\VirtualDesktopUtils.cpp,cascadia\WindowsTerminal\VirtualDesktopUtils.cpp:<global>,,<global>,1
308388,NAMESPACE_BLOCK,"namespace NonLocalizable
{
    const wchar_t RegCurrentVirtualDesktop[] = L""CurrentVirtualDesktop"";
    const wchar_t RegVirtualDesktopIds[] = L""VirtualDesktopIDs"";
    const wchar_t RegKeyVirtualDesktops[] = L""Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VirtualDesktops"";
    const wchar_t RegKeyVirtualDesktopsFromSession[] = L""Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\%d\\VirtualDesktops"";
}",1,cascadia\WindowsTerminal\VirtualDesktopUtils.cpp,NonLocalizable,16,NonLocalizable,1
308405,NAMESPACE_BLOCK,"namespace VirtualDesktopUtils
{
    // Look for the guid stored as the value `CurrentVirtualDesktop` under the
    // key
    // `HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\VirtualDesktops`
    bool NewGetCurrentDesktopId(GUID* desktopId)
    {
        wil::unique_hkey key{};
        if (RegOpenKeyExW(HKEY_CURRENT_USER, NonLocalizable::RegKeyVirtualDesktops, 0, KEY_ALL_ACCESS, &key) == ERROR_SUCCESS)
        {
            GUID value{};
            DWORD size = sizeof(GUID);
            if (RegQueryValueExW(key.get(), NonLocalizable::RegCurrentVirtualDesktop, 0, nullptr, reinterpret_cast<BYTE*>(&value), &size) == ERROR_SUCCESS)
            {
                *desktopId = value;
                return true;
            }
        }
        return false;
    }

    bool GetDesktopIdFromCurrentSession(GUID* desktopId)
    {
        DWORD sessionId;
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &sessionId))
        {
            return false;
        }

        wcha...",1,cascadia\WindowsTerminal\VirtualDesktopUtils.cpp,VirtualDesktopUtils,24,VirtualDesktopUtils,2
308802,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\VirtualDesktopUtils.hpp,cascadia\WindowsTerminal\VirtualDesktopUtils.hpp:<global>,,<global>,1
308806,NAMESPACE_BLOCK,"namespace VirtualDesktopUtils
{
    bool GetCurrentVirtualDesktopId(GUID* desktopId);
}",1,cascadia\WindowsTerminal\VirtualDesktopUtils.hpp,VirtualDesktopUtils,8,VirtualDesktopUtils,1
308939,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\WindowEmperor.cpp,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>,,<global>,1
310625,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\WindowEmperor.hpp,cascadia\WindowsTerminal\WindowEmperor.hpp:<global>,,<global>,1
310810,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\WindowThread.cpp,cascadia\WindowsTerminal\WindowThread.cpp:<global>,,<global>,1
311221,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\WindowThread.hpp,cascadia\WindowsTerminal\WindowThread.hpp:<global>,,<global>,1
311317,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\icon.cpp,cascadia\WindowsTerminal\icon.cpp:<global>,,<global>,1
311457,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\icon.hpp,cascadia\WindowsTerminal\icon.hpp:<global>,,<global>,1
311484,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\main.cpp,cascadia\WindowsTerminal\main.cpp:<global>,,<global>,1
311670,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\pch.cpp,cascadia\WindowsTerminal\pch.cpp:<global>,,<global>,1
311755,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\pch.hpp,cascadia\WindowsTerminal\pch.hpp:<global>,,<global>,1
311761,NAMESPACE_BLOCK,<empty>,,cascadia\WindowsTerminal\resource.hpp,cascadia\WindowsTerminal\resource.hpp:<global>,,<global>,1
311766,NAMESPACE_BLOCK,<empty>,,cascadia\inc\ControlProperties.hpp,cascadia\inc\ControlProperties.hpp:<global>,,<global>,1
311771,NAMESPACE_BLOCK,<empty>,,cascadia\inc\WindowingBehavior.hpp,cascadia\inc\WindowingBehavior.hpp:<global>,,<global>,1
311826,NAMESPACE_BLOCK,<empty>,,cascadia\inc\cppwinrt_utils.hpp,cascadia\inc\cppwinrt_utils.hpp:<global>,,<global>,1
311948,NAMESPACE_BLOCK,<empty>,,cascadia\ut_app\ColorHelperTests.cpp,cascadia\ut_app\ColorHelperTests.cpp:<global>,,<global>,1
311952,NAMESPACE_BLOCK,"namespace TerminalAppUnitTests
{
    class ColorHelperTests
    {
        BEGIN_TEST_CLASS(ColorHelperTests)
            TEST_CLASS_PROPERTY(L""ActivationContext"", L""TerminalApp.Unit.Tests.manifest"")
        END_TEST_CLASS()

        TEST_METHOD(ConvertRgbToHsl);
        TEST_METHOD(ConvertHslToRgb);
        TEST_METHOD(LuminanceTests);
    };

    void ColorHelperTests::ConvertHslToRgb()
    {
        auto red = winrt::Windows::UI::Colors::Red();
        auto redHsl = ColorHelper::RgbToHsl(red);
        VERIFY_ARE_EQUAL(0.f, redHsl.H);
        VERIFY_ARE_EQUAL(1.f, redHsl.S);
        VERIFY_ARE_EQUAL(0.5f, redHsl.L);

        auto green = winrt::Windows::UI::Colors::Lime();
        auto greenHsl = ColorHelper::RgbToHsl(green);
        VERIFY_ARE_EQUAL(120.f, greenHsl.H);
        VERIFY_ARE_EQUAL(1.f, greenHsl.S);
        VERIFY_ARE_EQUAL(0.5f, greenHsl.L);

        auto blue = winrt::Windows::UI::Colors::Blue();
        auto blueHsl = ColorHelper::RgbToHsl(blue);
        VERIFY_ARE_...",1,cascadia\ut_app\ColorHelperTests.cpp,TerminalAppUnitTests,18,TerminalAppUnitTests,1
312525,NAMESPACE_BLOCK,<empty>,,cascadia\ut_app\JsonUtilsTests.cpp,cascadia\ut_app\JsonUtilsTests.cpp:<global>,,<global>,1
312724,NAMESPACE_BLOCK,"namespace TerminalAppUnitTests
{
    class JsonUtilsTests
    {
        TEST_CLASS(JsonUtilsTests);

        TEST_METHOD(DocumentedBehaviors_GetValue_Returning);
        TEST_METHOD(DocumentedBehaviors_GetValue_Filling);
        TEST_METHOD(DocumentedBehaviors_GetValueForKey_Returning);
        TEST_METHOD(DocumentedBehaviors_GetValueForKey_Filling);

        TEST_METHOD(BasicTypeConversion);
        TEST_METHOD(BasicTypeWithCustomConverter);
        TEST_METHOD(CustomTypeWithConverterSpecialization);
        TEST_METHOD(EnumMapper);
        TEST_METHOD(FlagMapper);

        TEST_METHOD(NestedExceptionDuringKeyParse);

        TEST_METHOD(SetValueHStringLike);
        TEST_METHOD(GetValueHStringLike);

        TEST_METHOD(DoubleOptional);
    };

    template<typename T>
    static bool _ReturnTrueForException(T&& /*exception*/)
    {
        return true;
    }

    void JsonUtilsTests::DocumentedBehaviors_GetValue_Returning()
    {
        std::string expected{ ""correct"" };
       ...",1,cascadia\ut_app\JsonUtilsTests.cpp,TerminalAppUnitTests,136,TerminalAppUnitTests,11
314137,NAMESPACE_BLOCK,<empty>,,cascadia\ut_app\precomp.cpp,cascadia\ut_app\precomp.cpp:<global>,,<global>,1
314174,NAMESPACE_BLOCK,<empty>,,cascadia\ut_app\precomp.hpp,cascadia\ut_app\precomp.hpp:<global>,,<global>,1
314179,NAMESPACE_BLOCK,<empty>,,cascadia\wt\resource.hpp,cascadia\wt\resource.hpp:<global>,,<global>,1
314196,NAMESPACE_BLOCK,<empty>,,cascadia\wt\shim.cpp,cascadia\wt\shim.cpp:<global>,,<global>,1
314289,NAMESPACE_BLOCK,<empty>,,host\ApiRoutines.hpp,host\ApiRoutines.hpp:<global>,,<global>,1
314836,NAMESPACE_BLOCK,<empty>,,host\ConsoleArguments.cpp,host\ConsoleArguments.cpp:<global>,,<global>,1
315742,NAMESPACE_BLOCK,<empty>,,host\ConsoleArguments.hpp,host\ConsoleArguments.hpp:<global>,,<global>,1
315931,NAMESPACE_BLOCK,<empty>,,host\CursorBlinker.cpp,host\CursorBlinker.cpp:<global>,,<global>,1
316360,NAMESPACE_BLOCK,<empty>,,host\CursorBlinker.hpp,host\CursorBlinker.hpp:<global>,,<global>,1
316364,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class CursorBlinker final
    {
    public:
        CursorBlinker();
        ~CursorBlinker();

        void FocusStart() const noexcept;
        void FocusEnd() const noexcept;

        void UpdateSystemMetrics() noexcept;
        void SettingsChanged() noexcept;
        void TimerRoutine(SCREEN_INFORMATION& ScreenInfo) const noexcept;

    private:
        void SetCaretTimer() const noexcept;
        void KillCaretTimer() const noexcept;

        wil::unique_threadpool_timer_nowait _timer;
        UINT _uCaretBlinkTime;
    };
}",1,host\CursorBlinker.hpp,Microsoft,15,Microsoft,1
316365,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class CursorBlinker final
    {
    public:
        CursorBlinker();
        ~CursorBlinker();

        void FocusStart() const noexcept;
        void FocusEnd() const noexcept;

        void UpdateSystemMetrics() noexcept;
        void SettingsChanged() noexcept;
        void TimerRoutine(SCREEN_INFORMATION& ScreenInfo) const noexcept;

    private:
        void SetCaretTimer() const noexcept;
        void KillCaretTimer() const noexcept;

        wil::unique_threadpool_timer_nowait _timer;
        UINT _uCaretBlinkTime;
    };
}",1,host\CursorBlinker.hpp,Microsoft.Console,15,Console,1
316407,NAMESPACE_BLOCK,<empty>,,host\IIoProvider.hpp,host\IIoProvider.hpp:<global>,,<global>,1
316413,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class IIoProvider
    {
    public:
        virtual SCREEN_INFORMATION& GetActiveOutputBuffer() = 0;
        virtual const SCREEN_INFORMATION& GetActiveOutputBuffer() const = 0;
        virtual InputBuffer* const GetActiveInputBuffer() const = 0;
    };
}",1,host\IIoProvider.hpp,Microsoft,20,Microsoft,3
316414,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class IIoProvider
    {
    public:
        virtual SCREEN_INFORMATION& GetActiveOutputBuffer() = 0;
        virtual const SCREEN_INFORMATION& GetActiveOutputBuffer() const = 0;
        virtual InputBuffer* const GetActiveInputBuffer() const = 0;
    };
}",1,host\IIoProvider.hpp,Microsoft.Console,20,Console,1
316454,NAMESPACE_BLOCK,<empty>,,host\PtySignalInputThread.cpp,host\PtySignalInputThread.cpp:<global>,,<global>,1
316708,NAMESPACE_BLOCK,<empty>,,host\PtySignalInputThread.hpp,host\PtySignalInputThread.hpp:<global>,,<global>,1
316712,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class PtySignalInputThread final
    {
    public:
        PtySignalInputThread(_In_ wil::unique_hfile hPipe);
        ~PtySignalInputThread();

        [[nodiscard]] HRESULT Start() noexcept;
        static DWORD WINAPI StaticThreadProc(_In_ LPVOID lpParameter);

        // Prevent copying and assignment.
        PtySignalInputThread(const PtySignalInputThread&) = delete;
        PtySignalInputThread& operator=(const PtySignalInputThread&) = delete;

        void ConnectConsole() noexcept;
        void CreatePseudoWindow();

    private:
        enum class PtySignal : unsigned short
        {
            ShowHideWindow = 1,
            ClearBuffer = 2,
            SetParent = 3,
            ResizeWindow = 8
        };

        struct ResizeWindowData
        {
            unsigned short sx;
            unsigned short sy;
        };

        struct ShowHideData
        {
            unsigned short show; // used as a bool, but passed as a ushort
   ...",1,host\PtySignalInputThread.hpp,Microsoft,20,Microsoft,1
316713,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class PtySignalInputThread final
    {
    public:
        PtySignalInputThread(_In_ wil::unique_hfile hPipe);
        ~PtySignalInputThread();

        [[nodiscard]] HRESULT Start() noexcept;
        static DWORD WINAPI StaticThreadProc(_In_ LPVOID lpParameter);

        // Prevent copying and assignment.
        PtySignalInputThread(const PtySignalInputThread&) = delete;
        PtySignalInputThread& operator=(const PtySignalInputThread&) = delete;

        void ConnectConsole() noexcept;
        void CreatePseudoWindow();

    private:
        enum class PtySignal : unsigned short
        {
            ShowHideWindow = 1,
            ClearBuffer = 2,
            SetParent = 3,
            ResizeWindow = 8
        };

        struct ResizeWindowData
        {
            unsigned short sx;
            unsigned short sy;
        };

        struct ShowHideData
        {
            unsigned short show; // used as a bool, but passed as a ushort
   ...",1,host\PtySignalInputThread.hpp,Microsoft.Console,20,Console,1
316816,NAMESPACE_BLOCK,<empty>,,host\VtApiRoutines.cpp,host\VtApiRoutines.cpp:<global>,,<global>,1
318617,NAMESPACE_BLOCK,<empty>,,host\VtApiRoutines.hpp,host\VtApiRoutines.hpp:<global>,,<global>,1
319192,NAMESPACE_BLOCK,<empty>,,host\VtInputThread.cpp,host\VtInputThread.cpp:<global>,,<global>,1
319336,NAMESPACE_BLOCK,<empty>,,host\VtInputThread.hpp,host\VtInputThread.hpp:<global>,,<global>,1
319340,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class VtInputThread
    {
    public:
        VtInputThread(_In_ wil::unique_hfile hPipe, const bool inheritCursor);

        [[nodiscard]] HRESULT Start();
        static DWORD WINAPI StaticVtInputThreadProc(_In_ LPVOID lpParameter);
        bool DoReadInput();
        void SetLookingForDSR(const bool looking) noexcept;

    private:
        void _InputThread();

        wil::unique_hfile _hFile;
        wil::unique_handle _hThread;
        DWORD _dwThreadId;

        std::function<void(bool)> _pfnSetLookingForDSR;

        std::unique_ptr<Microsoft::Console::VirtualTerminal::StateMachine> _pInputStateMachine;
        til::u8state _u8State;
        std::wstring _wstr;
    };
}",1,host\VtInputThread.hpp,Microsoft,19,Microsoft,1
319341,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class VtInputThread
    {
    public:
        VtInputThread(_In_ wil::unique_hfile hPipe, const bool inheritCursor);

        [[nodiscard]] HRESULT Start();
        static DWORD WINAPI StaticVtInputThreadProc(_In_ LPVOID lpParameter);
        bool DoReadInput();
        void SetLookingForDSR(const bool looking) noexcept;

    private:
        void _InputThread();

        wil::unique_hfile _hFile;
        wil::unique_handle _hThread;
        DWORD _dwThreadId;

        std::function<void(bool)> _pfnSetLookingForDSR;

        std::unique_ptr<Microsoft::Console::VirtualTerminal::StateMachine> _pInputStateMachine;
        til::u8state _u8State;
        std::wstring _wstr;
    };
}",1,host\VtInputThread.hpp,Microsoft.Console,19,Console,1
319409,NAMESPACE_BLOCK,<empty>,,host\VtIo.cpp,host\VtIo.cpp:<global>,,<global>,1
319825,NAMESPACE_BLOCK,<empty>,,host\VtIo.hpp,host\VtIo.hpp:<global>,,<global>,1
319830,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,host\VtIo.hpp,Microsoft,13,Microsoft,2
319831,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,host\VtIo.hpp,Microsoft.Console,13,Console,1
319832,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,host\VtIo.hpp,Microsoft.Console.Render,13,Render,1
319834,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo
    {
    public:
        VtIo();

        [[nodiscard]] HRESULT Initialize(const ConsoleArguments* const pArgs);

        [[nodiscard]] HRESULT CreateAndStartSignalThread() noexcept;
        [[nodiscard]] HRESULT CreateIoHandlers() noexcept;

        bool IsUsingVt() const;

        [[nodiscard]] HRESULT StartIfNeeded();

        [[nodiscard]] static HRESULT ParseIoMode(const std::wstring& VtMode, _Out_ VtIoMode& ioMode);
        [[nodiscard]] HRESULT SuppressResizeRepaint();
        [[nodiscard]] HRESULT SetCursorPosition(const til::point coordCursor);
        [[nodiscard]] HRESULT SwitchScreenBuffer(const bool useAltBuffer);
        void SendCloseEvent();

        void CloseInput();
        void CloseOutput();

        void CorkRenderer(bool corked) const noexcept;

#ifdef UNIT_TESTING
        void EnableConptyModeForTests(std::unique_ptr<Microsoft::Console::Render::VtEngine> vtRenderEngine);
#endif

        bool IsRe...",1,host\VtIo.hpp,Microsoft,18,Microsoft,3
319835,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo
    {
    public:
        VtIo();

        [[nodiscard]] HRESULT Initialize(const ConsoleArguments* const pArgs);

        [[nodiscard]] HRESULT CreateAndStartSignalThread() noexcept;
        [[nodiscard]] HRESULT CreateIoHandlers() noexcept;

        bool IsUsingVt() const;

        [[nodiscard]] HRESULT StartIfNeeded();

        [[nodiscard]] static HRESULT ParseIoMode(const std::wstring& VtMode, _Out_ VtIoMode& ioMode);
        [[nodiscard]] HRESULT SuppressResizeRepaint();
        [[nodiscard]] HRESULT SetCursorPosition(const til::point coordCursor);
        [[nodiscard]] HRESULT SwitchScreenBuffer(const bool useAltBuffer);
        void SendCloseEvent();

        void CloseInput();
        void CloseOutput();

        void CorkRenderer(bool corked) const noexcept;

#ifdef UNIT_TESTING
        void EnableConptyModeForTests(std::unique_ptr<Microsoft::Console::Render::VtEngine> vtRenderEngine);
#endif

        bool IsRe...",1,host\VtIo.hpp,Microsoft.Console,18,Console,1
319836,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo
    {
    public:
        VtIo();

        [[nodiscard]] HRESULT Initialize(const ConsoleArguments* const pArgs);

        [[nodiscard]] HRESULT CreateAndStartSignalThread() noexcept;
        [[nodiscard]] HRESULT CreateIoHandlers() noexcept;

        bool IsUsingVt() const;

        [[nodiscard]] HRESULT StartIfNeeded();

        [[nodiscard]] static HRESULT ParseIoMode(const std::wstring& VtMode, _Out_ VtIoMode& ioMode);
        [[nodiscard]] HRESULT SuppressResizeRepaint();
        [[nodiscard]] HRESULT SetCursorPosition(const til::point coordCursor);
        [[nodiscard]] HRESULT SwitchScreenBuffer(const bool useAltBuffer);
        void SendCloseEvent();

        void CloseInput();
        void CloseOutput();

        void CorkRenderer(bool corked) const noexcept;

#ifdef UNIT_TESTING
        void EnableConptyModeForTests(std::unique_ptr<Microsoft::Console::Render::VtEngine> vtRenderEngine);
#endif

        bool IsRe...",1,host\VtIo.hpp,Microsoft.Console.VirtualTerminal,18,VirtualTerminal,1
319998,NAMESPACE_BLOCK,<empty>,,host\_output.cpp,host\_output.cpp:<global>,,<global>,1
320360,NAMESPACE_BLOCK,<empty>,,host\_output.hpp,host\_output.hpp:<global>,,<global>,1
320418,NAMESPACE_BLOCK,<empty>,,host\_stream.cpp,host\_stream.cpp:<global>,,<global>,1
320994,NAMESPACE_BLOCK,<empty>,,host\_stream.hpp,host\_stream.hpp:<global>,,<global>,1
321074,NAMESPACE_BLOCK,<empty>,,host\alias.cpp,host\alias.cpp:<global>,,<global>,1
322602,NAMESPACE_BLOCK,<empty>,,host\alias.hpp,host\alias.hpp:<global>,,<global>,1
322699,NAMESPACE_BLOCK,<empty>,,host\cmdline.cpp,host\cmdline.cpp:<global>,,<global>,1
322804,NAMESPACE_BLOCK,<empty>,,host\cmdline.hpp,host\cmdline.hpp:<global>,,<global>,1
322834,NAMESPACE_BLOCK,<empty>,,host\conapi.hpp,host\conapi.hpp:<global>,,<global>,1
322849,NAMESPACE_BLOCK,<empty>,,host\conareainfo.cpp,host\conareainfo.cpp:<global>,,<global>,1
323430,NAMESPACE_BLOCK,<empty>,,host\conareainfo.hpp,host\conareainfo.hpp:<global>,,<global>,1
323531,NAMESPACE_BLOCK,<empty>,,host\conddkrefs.hpp,host\conddkrefs.hpp:<global>,,<global>,1
323605,NAMESPACE_BLOCK,<empty>,,host\conimeinfo.cpp,host\conimeinfo.cpp:<global>,,<global>,1
324562,NAMESPACE_BLOCK,<empty>,,host\conimeinfo.hpp,host\conimeinfo.hpp:<global>,,<global>,1
324692,NAMESPACE_BLOCK,<empty>,,host\conserv.hpp,host\conserv.hpp:<global>,,<global>,1
324761,NAMESPACE_BLOCK,<empty>,,host\consoleInformation.cpp,host\consoleInformation.cpp:<global>,,<global>,1
325331,NAMESPACE_BLOCK,<empty>,,host\conv.hpp,host\conv.hpp:<global>,,<global>,1
325378,NAMESPACE_BLOCK,<empty>,,host\convarea.cpp,host\convarea.cpp:<global>,,<global>,1
325824,NAMESPACE_BLOCK,<empty>,,host\conwinuserrefs.hpp,host\conwinuserrefs.hpp:<global>,,<global>,1
325884,NAMESPACE_BLOCK,<empty>,,host\dbcs.cpp,host\dbcs.cpp:<global>,,<global>,1
326159,NAMESPACE_BLOCK,<empty>,,host\dbcs.hpp,host\dbcs.hpp:<global>,,<global>,1
326263,NAMESPACE_BLOCK,<empty>,,host\directio.cpp,host\directio.cpp:<global>,,<global>,1
326614,NAMESPACE_BLOCK,<empty>,,host\directio.hpp,host\directio.hpp:<global>,,<global>,1
326627,NAMESPACE_BLOCK,<empty>,,host\exe\CConsoleHandoff.cpp,host\exe\CConsoleHandoff.cpp:<global>,,<global>,1
326653,NAMESPACE_BLOCK,<empty>,,host\exe\CConsoleHandoff.hpp,host\exe\CConsoleHandoff.hpp:<global>,,<global>,1
326684,NAMESPACE_BLOCK,<empty>,,host\exe\exemain.cpp,host\exe\exemain.cpp:<global>,,<global>,1
326789,NAMESPACE_BLOCK,<empty>,,host\exe\resource.hpp,host\exe\resource.hpp:<global>,,<global>,1
326819,NAMESPACE_BLOCK,<empty>,,host\ft_fuzzer\fuzzmain.cpp,host\ft_fuzzer\fuzzmain.cpp:<global>,,<global>,1
327248,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_AliasTests.cpp,host\ft_host\API_AliasTests.cpp:<global>,,<global>,1
327478,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_AliasTestsHelpers.hpp,host\ft_host\API_AliasTestsHelpers.hpp:<global>,,<global>,1
327946,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_BufferTests.cpp,host\ft_host\API_BufferTests.cpp:<global>,,<global>,1
328969,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_CursorTests.cpp,host\ft_host\API_CursorTests.cpp:<global>,,<global>,1
329347,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_DimensionsTests.cpp,host\ft_host\API_DimensionsTests.cpp:<global>,,<global>,1
331086,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_FileTests.cpp,host\ft_host\API_FileTests.cpp:<global>,,<global>,1
333193,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_FillOutputTests.cpp,host\ft_host\API_FillOutputTests.cpp:<global>,,<global>,1
333341,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_FontTests.cpp,host\ft_host\API_FontTests.cpp:<global>,,<global>,1
334437,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_InputTests.cpp,host\ft_host\API_InputTests.cpp:<global>,,<global>,1
336326,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_ModeTests.cpp,host\ft_host\API_ModeTests.cpp:<global>,,<global>,1
336887,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_MultipleInflightMessageTests.cpp,host\ft_host\API_MultipleInflightMessageTests.cpp:<global>,,<global>,1
336941,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_OutputTests.cpp,host\ft_host\API_OutputTests.cpp:<global>,,<global>,1
341121,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_PolicyTests.cpp,host\ft_host\API_PolicyTests.cpp:<global>,,<global>,1
341145,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_RgbColorTests.cpp,host\ft_host\API_RgbColorTests.cpp:<global>,,<global>,1
342586,NAMESPACE_BLOCK,<empty>,,host\ft_host\API_TitleTests.cpp,host\ft_host\API_TitleTests.cpp:<global>,,<global>,1
343124,NAMESPACE_BLOCK,<empty>,,host\ft_host\CJK_DbcsTests.cpp,host\ft_host\CJK_DbcsTests.cpp:<global>,,<global>,1
343181,NAMESPACE_BLOCK,"namespace DbcsWriteRead
{
    enum WriteMode
    {
        CrtWrite = 0,
        WriteConsoleOutputFunc = 1,
        WriteConsoleOutputCharacterFunc = 2,
        WriteConsoleFunc = 3
    };

    enum ReadMode
    {
        ReadConsoleOutputFunc = 0,
        ReadConsoleOutputCharacterFunc = 1
    };

    enum UnicodeMode
    {
        Ascii = 0,
        UnicodeSingle,
        UnicodeDoubled,
    };

    void TestRunner(_In_opt_ WORD* const pwAttrOverride,
                    const bool fUseTrueType,
                    const DbcsWriteRead::WriteMode WriteMode,
                    const UnicodeMode fWriteInUnicode,
                    const DbcsWriteRead::ReadMode ReadMode,
                    const bool fReadWithUnicode);

    bool Setup(_In_ bool fIsTrueType,
               _Out_ HANDLE* const phOut,
               _Out_ WORD* const pwAttributes);

    void SendOutput(const HANDLE hOut,
                    const WriteMode WriteMode,
                    const UnicodeMode fIsUnicode,
...",1,host\ft_host\CJK_DbcsTests.cpp,DbcsWriteRead,41,DbcsWriteRead,8
343747,NAMESPACE_BLOCK,"namespace PrepPattern
{
    static constexpr WORD zeroed = 0x0000;
    static constexpr WORD white = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
    // If the lower byte in our test data is 0xff it indicates that it's ""flexible""
    // and supposed to be replaced with whatever color attributes were written.
    // The upper byte contains leading/trailing flags we're testing for.
    static constexpr WORD colored = 0x00ff;

    static constexpr WORD leading = COMMON_LVB_LEADING_BYTE;
    static constexpr WORD trailing = COMMON_LVB_TRAILING_BYTE;

    constexpr void replaceColorPlaceholders(std::span<CHAR_INFO> pattern, WORD attr)
    {
        for (auto& info : pattern)
        {
            if ((info.Attributes & colored) == colored)
            {
                info.Attributes &= 0xff00 | attr;
            }
        }
    }

    // Receive Output Table:
    // attr  | wchar  (char) | symbol
    // ------------------------------------
    // 0x029 | 0x0051 (0x51) | Q
    /...",1,host\ft_host\CJK_DbcsTests.cpp,PrepPattern,419,PrepPattern,13
347734,NAMESPACE_BLOCK,<empty>,,host\ft_host\CanaryTests.cpp,host\ft_host\CanaryTests.cpp:<global>,,<global>,1
348007,NAMESPACE_BLOCK,<empty>,,host\ft_host\Common.cpp,host\ft_host\Common.cpp:<global>,,<global>,1
348499,NAMESPACE_BLOCK,<empty>,,host\ft_host\Common.hpp,host\ft_host\Common.hpp:<global>,,<global>,1
348665,NAMESPACE_BLOCK,<empty>,,host\ft_host\InitTests.cpp,host\ft_host\InitTests.cpp:<global>,,<global>,1
348721,NAMESPACE_BLOCK,<empty>,,host\ft_host\Message_KeyPressTests.cpp,host\ft_host\Message_KeyPressTests.cpp:<global>,,<global>,1
349463,NAMESPACE_BLOCK,<empty>,,host\ft_host\OneCoreDelay.cpp,host\ft_host\OneCoreDelay.cpp:<global>,,<global>,1
349546,NAMESPACE_BLOCK,<empty>,,host\ft_host\OneCoreDelay.hpp,host\ft_host\OneCoreDelay.hpp:<global>,,<global>,1
349550,NAMESPACE_BLOCK,"namespace OneCoreDelay
{
    BOOLEAN
    __stdcall IsIsWindowPresent();

    BOOLEAN
    __stdcall IsGetSystemMetricsPresent();

    BOOLEAN
    __stdcall IsPostMessageWPresent();

    BOOLEAN
    __stdcall IsSendMessageWPresent();

    BOOL
        APIENTRY
        AddConsoleAliasA(
            _In_ LPSTR Source,
            _In_ LPSTR Target,
            _In_ LPSTR ExeName);

    BOOL
        APIENTRY
        AddConsoleAliasW(
            _In_ LPWSTR Source,
            _In_ LPWSTR Target,
            _In_ LPWSTR ExeName);

    DWORD
    APIENTRY
    GetConsoleAliasA(
        _In_ LPSTR Source,
        _Out_writes_(TargetBufferLength) LPSTR TargetBuffer,
        _In_ DWORD TargetBufferLength,
        _In_ LPSTR ExeName);

    DWORD
    APIENTRY
    GetConsoleAliasW(
        _In_ LPWSTR Source,
        _Out_writes_(TargetBufferLength) LPWSTR TargetBuffer,
        _In_ DWORD TargetBufferLength,
        _In_ LPWSTR ExeName);

    BOOL
        WINAPI
        GetCurrentConsoleFont(
   ...",1,host\ft_host\OneCoreDelay.hpp,OneCoreDelay,22,OneCoreDelay,1
349600,NAMESPACE_BLOCK,<empty>,,host\ft_host\precomp.cpp,host\ft_host\precomp.cpp:<global>,,<global>,1
349629,NAMESPACE_BLOCK,<empty>,,host\ft_host\precomp.hpp,host\ft_host\precomp.hpp:<global>,,<global>,1
349634,NAMESPACE_BLOCK,<empty>,,host\ft_host\resource.hpp,host\ft_host\resource.hpp:<global>,,<global>,1
349643,NAMESPACE_BLOCK,<empty>,,host\ft_integrity\IntegrityTest.cpp,host\ft_integrity\IntegrityTest.cpp:<global>,,<global>,1
350310,NAMESPACE_BLOCK,<empty>,,host\ft_integrity\IntegrityTest.hpp,host\ft_integrity\IntegrityTest.hpp:<global>,,<global>,1
350368,NAMESPACE_BLOCK,<empty>,,host\ft_integrity\precomp.hpp,host\ft_integrity\precomp.hpp:<global>,,<global>,1
350406,NAMESPACE_BLOCK,<empty>,,host\getset.cpp,host\getset.cpp:<global>,,<global>,1
350778,NAMESPACE_BLOCK,<empty>,,host\getset.hpp,host\getset.hpp:<global>,,<global>,1
350797,NAMESPACE_BLOCK,<empty>,,host\globals.cpp,host\globals.cpp:<global>,,<global>,1
350845,NAMESPACE_BLOCK,<empty>,,host\globals.hpp,host\globals.hpp:<global>,,<global>,1
350926,NAMESPACE_BLOCK,<empty>,,host\handle.cpp,host\handle.cpp:<global>,,<global>,1
350978,NAMESPACE_BLOCK,<empty>,,host\handle.hpp,host\handle.hpp:<global>,,<global>,1
351056,NAMESPACE_BLOCK,<empty>,,host\history.cpp,host\history.cpp:<global>,,<global>,1
352368,NAMESPACE_BLOCK,<empty>,,host\history.hpp,host\history.hpp:<global>,,<global>,1
352576,NAMESPACE_BLOCK,<empty>,,host\init.cpp,host\init.cpp:<global>,,<global>,1
352729,NAMESPACE_BLOCK,<empty>,,host\init.hpp,host\init.hpp:<global>,,<global>,1
352751,NAMESPACE_BLOCK,<empty>,,host\input.cpp,host\input.cpp:<global>,,<global>,1
353547,NAMESPACE_BLOCK,<empty>,,host\input.hpp,host\input.hpp:<global>,,<global>,1
353706,NAMESPACE_BLOCK,<empty>,,host\inputBuffer.cpp,host\inputBuffer.cpp:<global>,,<global>,1
354907,NAMESPACE_BLOCK,<empty>,,host\inputBuffer.hpp,host\inputBuffer.hpp:<global>,,<global>,1
354911,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
    class VtEngine;
}",1,host\inputBuffer.hpp,Microsoft,15,Microsoft,1
354912,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
    class VtEngine;
}",1,host\inputBuffer.hpp,Microsoft.Console,15,Console,1
354913,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;
    class VtEngine;
}",1,host\inputBuffer.hpp,Microsoft.Console.Render,15,Render,1
355106,NAMESPACE_BLOCK,<empty>,,host\inputKeyInfo.cpp,host\inputKeyInfo.cpp:<global>,,<global>,1
355225,NAMESPACE_BLOCK,<empty>,,host\inputReadHandleData.cpp,host\inputReadHandleData.cpp:<global>,,<global>,1
355324,NAMESPACE_BLOCK,<empty>,,host\inputReadHandleData.hpp,host\inputReadHandleData.hpp:<global>,,<global>,1
355417,NAMESPACE_BLOCK,<empty>,,host\misc.cpp,host\misc.cpp:<global>,,<global>,1
355493,NAMESPACE_BLOCK,<empty>,,host\misc.hpp,host\misc.hpp:<global>,,<global>,1
355510,NAMESPACE_BLOCK,<empty>,,host\ntprivapi.cpp,host\ntprivapi.cpp:<global>,,<global>,1
355514,NAMESPACE_BLOCK,"namespace
{
    struct PROCESS_BASIC_INFORMATION_EXPANDED
    {
        NTSTATUS ExitStatus;
        PVOID PebBaseAddress;
        ULONG_PTR AffinityMask;
        LONG BasePriority;
        ULONG_PTR UniqueProcessId;
        ULONG_PTR InheritedFromUniqueProcessId;
    };
}",1,host\ntprivapi.cpp,anonymous_namespace_0,8,,1
355559,NAMESPACE_BLOCK,<empty>,,host\ntprivapi.hpp,host\ntprivapi.hpp:<global>,,<global>,1
355583,NAMESPACE_BLOCK,<empty>,,host\output.cpp,host\output.cpp:<global>,,<global>,1
356630,NAMESPACE_BLOCK,<empty>,,host\output.hpp,host\output.hpp:<global>,,<global>,1
356712,NAMESPACE_BLOCK,<empty>,,host\outputStream.cpp,host\outputStream.cpp:<global>,,<global>,1
357448,NAMESPACE_BLOCK,<empty>,,host\outputStream.hpp,host\outputStream.hpp:<global>,,<global>,1
357603,NAMESPACE_BLOCK,<empty>,,host\precomp.cpp,host\precomp.cpp:<global>,,<global>,1
357672,NAMESPACE_BLOCK,<empty>,,host\precomp.hpp,host\precomp.hpp:<global>,,<global>,1
357691,NAMESPACE_BLOCK,<empty>,,host\readData.cpp,host\readData.cpp:<global>,,<global>,1
357743,NAMESPACE_BLOCK,<empty>,,host\readData.hpp,host\readData.hpp:<global>,,<global>,1
357801,NAMESPACE_BLOCK,<empty>,,host\readDataCooked.cpp,host\readDataCooked.cpp:<global>,,<global>,1
361839,NAMESPACE_BLOCK,<empty>,,host\readDataCooked.hpp,host\readDataCooked.hpp:<global>,,<global>,1
362218,NAMESPACE_BLOCK,<empty>,,host\readDataDirect.cpp,host\readDataDirect.cpp:<global>,,<global>,1
362241,NAMESPACE_BLOCK,<empty>,,host\readDataDirect.hpp,host\readDataDirect.hpp:<global>,,<global>,1
362274,NAMESPACE_BLOCK,<empty>,,host\readDataRaw.cpp,host\readDataRaw.cpp:<global>,,<global>,1
362307,NAMESPACE_BLOCK,<empty>,,host\readDataRaw.hpp,host\readDataRaw.hpp:<global>,,<global>,1
362342,NAMESPACE_BLOCK,<empty>,,host\registry.cpp,host\registry.cpp:<global>,,<global>,1
362400,NAMESPACE_BLOCK,<empty>,,host\registry.hpp,host\registry.hpp:<global>,,<global>,1
362433,NAMESPACE_BLOCK,<empty>,,host\renderData.cpp,host\renderData.cpp:<global>,,<global>,1
363076,NAMESPACE_BLOCK,<empty>,,host\renderData.hpp,host\renderData.hpp:<global>,,<global>,1
363206,NAMESPACE_BLOCK,<empty>,,host\renderFontDefaults.cpp,host\renderFontDefaults.cpp:<global>,,<global>,1
363232,NAMESPACE_BLOCK,<empty>,,host\renderFontDefaults.hpp,host\renderFontDefaults.hpp:<global>,,<global>,1
363238,NAMESPACE_BLOCK,<empty>,,host\resource.hpp,host\resource.hpp:<global>,,<global>,1
363269,NAMESPACE_BLOCK,<empty>,,host\screenInfo.cpp,host\screenInfo.cpp:<global>,,<global>,1
367071,NAMESPACE_BLOCK,<empty>,,host\screenInfo.hpp,host\screenInfo.hpp:<global>,,<global>,1
367513,NAMESPACE_BLOCK,<empty>,,host\scrolling.cpp,host\scrolling.cpp:<global>,,<global>,1
368064,NAMESPACE_BLOCK,<empty>,,host\scrolling.hpp,host\scrolling.hpp:<global>,,<global>,1
368115,NAMESPACE_BLOCK,<empty>,,host\selection.cpp,host\selection.cpp:<global>,,<global>,1
369025,NAMESPACE_BLOCK,<empty>,,host\selection.hpp,host\selection.hpp:<global>,,<global>,1
369280,NAMESPACE_BLOCK,<empty>,,host\selectionInput.cpp,host\selectionInput.cpp:<global>,,<global>,1
370905,NAMESPACE_BLOCK,<empty>,,host\selectionState.cpp,host\selectionState.cpp:<global>,,<global>,1
371223,NAMESPACE_BLOCK,<empty>,,host\server.hpp,host\server.hpp:<global>,,<global>,1
371451,NAMESPACE_BLOCK,<empty>,,host\settings.cpp,host\settings.cpp:<global>,,<global>,1
373050,NAMESPACE_BLOCK,<empty>,,host\settings.hpp,host\settings.hpp:<global>,,<global>,1
373593,NAMESPACE_BLOCK,<empty>,,host\srvinit.cpp,host\srvinit.cpp:<global>,,<global>,1
374101,NAMESPACE_BLOCK,<empty>,,host\srvinit.hpp,host\srvinit.hpp:<global>,,<global>,1
374143,NAMESPACE_BLOCK,<empty>,,host\stream.cpp,host\stream.cpp:<global>,,<global>,1
374405,NAMESPACE_BLOCK,<empty>,,host\stream.hpp,host\stream.hpp:<global>,,<global>,1
374439,NAMESPACE_BLOCK,<empty>,,host\telemetry.cpp,host\telemetry.cpp:<global>,,<global>,1
375602,NAMESPACE_BLOCK,<empty>,,host\telemetry.hpp,host\telemetry.hpp:<global>,,<global>,1
375843,NAMESPACE_BLOCK,<empty>,,host\tracing.cpp,host\tracing.cpp:<global>,,<global>,1
376320,NAMESPACE_BLOCK,<empty>,,host\tracing.hpp,host\tracing.hpp:<global>,,<global>,1
376359,NAMESPACE_BLOCK,<empty>,,host\ut_host\AliasTests.cpp,host\ut_host\AliasTests.cpp:<global>,,<global>,1
376965,NAMESPACE_BLOCK,<empty>,,host\ut_host\ApiRoutinesTests.cpp,host\ut_host\ApiRoutinesTests.cpp:<global>,,<global>,1
378205,NAMESPACE_BLOCK,<empty>,,host\ut_host\ClipboardTests.cpp,host\ut_host\ClipboardTests.cpp:<global>,,<global>,1
378547,NAMESPACE_BLOCK,<empty>,,host\ut_host\CodepointWidthDetectorTests.cpp,host\ut_host\CodepointWidthDetectorTests.cpp:<global>,,<global>,1
378738,NAMESPACE_BLOCK,<empty>,,host\ut_host\ConptyOutputTests.cpp,host\ut_host\ConptyOutputTests.cpp:<global>,,<global>,1
380070,NAMESPACE_BLOCK,<empty>,,host\ut_host\ConsoleArgumentsTests.cpp,host\ut_host\ConsoleArgumentsTests.cpp:<global>,,<global>,1
381688,NAMESPACE_BLOCK,<empty>,,host\ut_host\DbcsTests.cpp,host\ut_host\DbcsTests.cpp:<global>,,<global>,1
381749,NAMESPACE_BLOCK,<empty>,,host\ut_host\HistoryTests.cpp,host\ut_host\HistoryTests.cpp:<global>,,<global>,1
381989,NAMESPACE_BLOCK,<empty>,,host\ut_host\InitTests.cpp,host\ut_host\InitTests.cpp:<global>,,<global>,1
382087,NAMESPACE_BLOCK,<empty>,,host\ut_host\InputBufferTests.cpp,host\ut_host\InputBufferTests.cpp:<global>,,<global>,1
382722,NAMESPACE_BLOCK,<empty>,,host\ut_host\ObjectTests.cpp,host\ut_host\ObjectTests.cpp:<global>,,<global>,1
382808,NAMESPACE_BLOCK,<empty>,,host\ut_host\OutputCellIteratorTests.cpp,host\ut_host\OutputCellIteratorTests.cpp:<global>,,<global>,1
384900,NAMESPACE_BLOCK,<empty>,,host\ut_host\ScreenBufferTests.cpp,host\ut_host\ScreenBufferTests.cpp:<global>,,<global>,1
418239,NAMESPACE_BLOCK,<empty>,,host\ut_host\SearchTests.cpp,host\ut_host\SearchTests.cpp:<global>,,<global>,1
418493,NAMESPACE_BLOCK,<empty>,,host\ut_host\SelectionTests.cpp,host\ut_host\SelectionTests.cpp:<global>,,<global>,1
419384,NAMESPACE_BLOCK,<empty>,,host\ut_host\TextBufferIteratorTests.cpp,host\ut_host\TextBufferIteratorTests.cpp:<global>,,<global>,1
420725,NAMESPACE_BLOCK,<empty>,,host\ut_host\TextBufferTests.cpp,host\ut_host\TextBufferTests.cpp:<global>,,<global>,1
430352,NAMESPACE_BLOCK,<empty>,,host\ut_host\TitleTests.cpp,host\ut_host\TitleTests.cpp:<global>,,<global>,1
430513,NAMESPACE_BLOCK,<empty>,,host\ut_host\Utf8ToWideCharParserTests.cpp,host\ut_host\Utf8ToWideCharParserTests.cpp:<global>,,<global>,1
431186,NAMESPACE_BLOCK,<empty>,,host\ut_host\UtilsTests.cpp,host\ut_host\UtilsTests.cpp:<global>,,<global>,1
431374,NAMESPACE_BLOCK,<empty>,,host\ut_host\ViewportTests.cpp,host\ut_host\ViewportTests.cpp:<global>,,<global>,1
432486,NAMESPACE_BLOCK,<empty>,,host\ut_host\VtIoTests.cpp,host\ut_host\VtIoTests.cpp:<global>,,<global>,1
436906,NAMESPACE_BLOCK,<empty>,,host\ut_host\VtRendererTests.cpp,host\ut_host\VtRendererTests.cpp:<global>,,<global>,1
436909,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace Render
        {
            class VtRendererTest;
        };
    };
}",1,host\ut_host\VtRendererTests.cpp,Microsoft,19,Microsoft,1
436910,NAMESPACE_BLOCK,"namespace Console
    {
        namespace Render
        {
            class VtRendererTest;
        };
    }",5,host\ut_host\VtRendererTests.cpp,Microsoft.Console,21,Console,1
436911,NAMESPACE_BLOCK,"namespace Render
        {
            class VtRendererTest;
        }",9,host\ut_host\VtRendererTests.cpp,Microsoft.Console.Render,23,Render,1
440089,NAMESPACE_BLOCK,<empty>,,host\utf8ToWideCharParser.cpp,host\utf8ToWideCharParser.cpp:<global>,,<global>,1
440171,NAMESPACE_BLOCK,<empty>,,host\utf8ToWideCharParser.hpp,host\utf8ToWideCharParser.hpp:<global>,,<global>,1
440232,NAMESPACE_BLOCK,<empty>,,host\utils.cpp,host\utils.cpp:<global>,,<global>,1
440532,NAMESPACE_BLOCK,<empty>,,host\utils.hpp,host\utils.hpp:<global>,,<global>,1
440590,NAMESPACE_BLOCK,<empty>,,host\writeData.cpp,host\writeData.cpp:<global>,,<global>,1
440638,NAMESPACE_BLOCK,<empty>,,host\writeData.hpp,host\writeData.hpp:<global>,,<global>,1
440675,NAMESPACE_BLOCK,<empty>,,inc\CppCoreCheck\warnings.hpp,inc\CppCoreCheck\warnings.hpp:<global>,,<global>,1
440953,NAMESPACE_BLOCK,<empty>,,inc\DefaultSettings.hpp,inc\DefaultSettings.hpp:<global>,,<global>,1
441054,NAMESPACE_BLOCK,<empty>,,inc\HostAndPropsheetIncludes.hpp,inc\HostAndPropsheetIncludes.hpp:<global>,,<global>,1
441059,NAMESPACE_BLOCK,<empty>,,inc\HostSignals.hpp,inc\HostSignals.hpp:<global>,,<global>,1
441063,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    // These values match the enumeration values of `ControlType` for the `ConsoleControl` class
    // but are defined here similarly to not pollute other projects.
    // They don't *have* to be the same values, but matching them seemed to make sense.
    enum class HostSignals : uint8_t
    {
        NotifyApp = 1u,
        SetForeground = 5u,
        EndTask = 7u
    };

    struct HostSignalNotifyAppData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A PID
    };

    struct HostSignalSetForegroundData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A HANDLE, NOT A PID
        bool isForeground;
    };

    struct HostSignalEndTaskData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A PID
        uint32_t eventType;
        uint32_t ctrlFlags;
    };
}",1,inc\HostSignals.hpp,Microsoft,1,Microsoft,1
441064,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    // These values match the enumeration values of `ControlType` for the `ConsoleControl` class
    // but are defined here similarly to not pollute other projects.
    // They don't *have* to be the same values, but matching them seemed to make sense.
    enum class HostSignals : uint8_t
    {
        NotifyApp = 1u,
        SetForeground = 5u,
        EndTask = 7u
    };

    struct HostSignalNotifyAppData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A PID
    };

    struct HostSignalSetForegroundData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A HANDLE, NOT A PID
        bool isForeground;
    };

    struct HostSignalEndTaskData
    {
        uint32_t sizeInBytes;
        uint32_t processId; // THIS IS A PID
        uint32_t eventType;
        uint32_t ctrlFlags;
    };
}",1,inc\HostSignals.hpp,Microsoft.Console,1,Console,1
441205,NAMESPACE_BLOCK,<empty>,,inc\LibraryIncludes.hpp,inc\LibraryIncludes.hpp:<global>,,<global>,1
441262,NAMESPACE_BLOCK,<empty>,,inc\TestUtils.hpp,inc\TestUtils.hpp:<global>,,<global>,1
441266,NAMESPACE_BLOCK,"namespace TerminalCoreUnitTests
{
    class TestUtils;
}",1,inc\TestUtils.hpp,TerminalCoreUnitTests,17,TerminalCoreUnitTests,1
441761,NAMESPACE_BLOCK,<empty>,,inc\VtIoModes.hpp,inc\VtIoModes.hpp:<global>,,<global>,1
441791,NAMESPACE_BLOCK,<empty>,,inc\WilErrorReporting.hpp,inc\WilErrorReporting.hpp:<global>,,<global>,1
441795,NAMESPACE_BLOCK,"namespace Microsoft::Console::ErrorReporting
{
    __declspec(selectany) TraceLoggingHProvider FallbackProvider;
    __declspec(noinline) inline void WINAPI ReportFailureToFallbackProvider(bool alreadyReported, const wil::FailureInfo& failure) noexcept
    try
    {
        if (failure.hr == 0x80131515L)
        {
            // XAML requires that we reply with this HR for the accessibility code in XamlUiaTextRange to work.
            // Unfortunately, due to C++/WinRT, we have to _throw_ it. That results in us ending up here,
            // trying to report the error to telemetry. It's not an actual error, per se, so we don't
            // want to log it. It's also incredibly noisy, which results in bugs getting filed on us.
            // See https://github.com/microsoft/cppwinrt/issues/798 for more discussion about throwing HRESULTs.
            return;
        }

        if (!alreadyReported && FallbackProvider)
        {
#pragma warning(suppress : 26477) // Use 'nullptr' rath...",1,inc\WilErrorReporting.hpp,Microsoft,13,Microsoft,1
441796,NAMESPACE_BLOCK,"namespace Microsoft::Console::ErrorReporting
{
    __declspec(selectany) TraceLoggingHProvider FallbackProvider;
    __declspec(noinline) inline void WINAPI ReportFailureToFallbackProvider(bool alreadyReported, const wil::FailureInfo& failure) noexcept
    try
    {
        if (failure.hr == 0x80131515L)
        {
            // XAML requires that we reply with this HR for the accessibility code in XamlUiaTextRange to work.
            // Unfortunately, due to C++/WinRT, we have to _throw_ it. That results in us ending up here,
            // trying to report the error to telemetry. It's not an actual error, per se, so we don't
            // want to log it. It's also incredibly noisy, which results in bugs getting filed on us.
            // See https://github.com/microsoft/cppwinrt/issues/798 for more discussion about throwing HRESULTs.
            return;
        }

        if (!alreadyReported && FallbackProvider)
        {
#pragma warning(suppress : 26477) // Use 'nullptr' rath...",1,inc\WilErrorReporting.hpp,Microsoft.Console,13,Console,1
441797,NAMESPACE_BLOCK,"namespace Microsoft::Console::ErrorReporting
{
    __declspec(selectany) TraceLoggingHProvider FallbackProvider;
    __declspec(noinline) inline void WINAPI ReportFailureToFallbackProvider(bool alreadyReported, const wil::FailureInfo& failure) noexcept
    try
    {
        if (failure.hr == 0x80131515L)
        {
            // XAML requires that we reply with this HR for the accessibility code in XamlUiaTextRange to work.
            // Unfortunately, due to C++/WinRT, we have to _throw_ it. That results in us ending up here,
            // trying to report the error to telemetry. It's not an actual error, per se, so we don't
            // want to log it. It's also incredibly noisy, which results in bugs getting filed on us.
            // See https://github.com/microsoft/cppwinrt/issues/798 for more discussion about throwing HRESULTs.
            return;
        }

        if (!alreadyReported && FallbackProvider)
        {
#pragma warning(suppress : 26477) // Use 'nullptr' rath...",1,inc\WilErrorReporting.hpp,Microsoft.Console.ErrorReporting,13,ErrorReporting,1
441821,NAMESPACE_BLOCK,<empty>,,inc\conattrs.hpp,inc\conattrs.hpp:<global>,,<global>,1
441944,NAMESPACE_BLOCK,<empty>,,inc\conime.hpp,inc\conime.hpp:<global>,,<global>,1
441985,NAMESPACE_BLOCK,<empty>,,inc\conint.hpp,inc\conint.hpp:<global>,,<global>,1
441989,NAMESPACE_BLOCK,"namespace Microsoft::Console::Internal
{
    namespace ProcessPolicy
    {
        [[nodiscard]] HRESULT CheckAppModelPolicy(const HANDLE hToken,
                                                  bool& fIsWrongWayBlocked) noexcept;

        [[nodiscard]] HRESULT CheckIntegrityLevelPolicy(const HANDLE hOtherToken,
                                                        bool& fIsWrongWayBlocked) noexcept;

    }

    namespace Theming
    {
        [[nodiscard]] HRESULT TrySetDarkMode(HWND hwnd) noexcept;
    }
}",1,inc\conint.hpp,Microsoft,26,Microsoft,1
441990,NAMESPACE_BLOCK,"namespace Microsoft::Console::Internal
{
    namespace ProcessPolicy
    {
        [[nodiscard]] HRESULT CheckAppModelPolicy(const HANDLE hToken,
                                                  bool& fIsWrongWayBlocked) noexcept;

        [[nodiscard]] HRESULT CheckIntegrityLevelPolicy(const HANDLE hOtherToken,
                                                        bool& fIsWrongWayBlocked) noexcept;

    }

    namespace Theming
    {
        [[nodiscard]] HRESULT TrySetDarkMode(HWND hwnd) noexcept;
    }
}",1,inc\conint.hpp,Microsoft.Console,26,Console,1
441991,NAMESPACE_BLOCK,"namespace Microsoft::Console::Internal
{
    namespace ProcessPolicy
    {
        [[nodiscard]] HRESULT CheckAppModelPolicy(const HANDLE hToken,
                                                  bool& fIsWrongWayBlocked) noexcept;

        [[nodiscard]] HRESULT CheckIntegrityLevelPolicy(const HANDLE hOtherToken,
                                                        bool& fIsWrongWayBlocked) noexcept;

    }

    namespace Theming
    {
        [[nodiscard]] HRESULT TrySetDarkMode(HWND hwnd) noexcept;
    }
}",1,inc\conint.hpp,Microsoft.Console.Internal,26,Internal,1
441992,NAMESPACE_BLOCK,"namespace ProcessPolicy
    {
        [[nodiscard]] HRESULT CheckAppModelPolicy(const HANDLE hToken,
                                                  bool& fIsWrongWayBlocked) noexcept;

        [[nodiscard]] HRESULT CheckIntegrityLevelPolicy(const HANDLE hOtherToken,
                                                        bool& fIsWrongWayBlocked) noexcept;

    }",5,inc\conint.hpp,Microsoft.Console.Internal.ProcessPolicy,28,ProcessPolicy,1
442005,NAMESPACE_BLOCK,"namespace Theming
    {
        [[nodiscard]] HRESULT TrySetDarkMode(HWND hwnd) noexcept;
    }",5,inc\conint.hpp,Microsoft.Console.Internal.Theming,38,Theming,2
442014,NAMESPACE_BLOCK,<empty>,,inc\conpty-static.hpp,inc\conpty-static.hpp:<global>,,<global>,1
442039,NAMESPACE_BLOCK,<empty>,,inc\conpty.hpp,inc\conpty.hpp:<global>,,<global>,1
442333,NAMESPACE_BLOCK,<empty>,,inc\consoletaeftemplates.hpp,inc\consoletaeftemplates.hpp:<global>,,<global>,1
442337,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    // Compare two floats using a ULP (unit last place) tolerance of up to 4.
    // Allows you to compare two floats that are almost equal.
    // Think of: 0.200000000000000 vs. 0.200000000000001.
    template<typename T, typename U>
    bool CompareFloats(T a, T b) noexcept
    {
        if (std::isnan(a))
        {
            return std::isnan(b);
        }

        if (a == b)
        {
            return true;
        }

        const auto nDiff = static_cast<std::make_signed_t<U>>(til::bit_cast<U>(a) - til::bit_cast<U>(b));
        const auto uDiff = static_cast<U>(nDiff < 0 ? -nDiff : nDiff);
        return uDiff <= 4;
    }

    template<>
    struct VerifyCompareTraits<float, float>
    {
        static bool AreEqual(float a, float b) noexcept
        {
            return CompareFloats<float, uint32_t>(a, b);
        }
    };

    template<>
    struct VerifyCompareTraits<double, double>
    {
        static bool AreEqual(double a, double b)...",1,inc\consoletaeftemplates.hpp,WEX,46,WEX,1
442338,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    // Compare two floats using a ULP (unit last place) tolerance of up to 4.
    // Allows you to compare two floats that are almost equal.
    // Think of: 0.200000000000000 vs. 0.200000000000001.
    template<typename T, typename U>
    bool CompareFloats(T a, T b) noexcept
    {
        if (std::isnan(a))
        {
            return std::isnan(b);
        }

        if (a == b)
        {
            return true;
        }

        const auto nDiff = static_cast<std::make_signed_t<U>>(til::bit_cast<U>(a) - til::bit_cast<U>(b));
        const auto uDiff = static_cast<U>(nDiff < 0 ? -nDiff : nDiff);
        return uDiff <= 4;
    }

    template<>
    struct VerifyCompareTraits<float, float>
    {
        static bool AreEqual(float a, float b) noexcept
        {
            return CompareFloats<float, uint32_t>(a, b);
        }
    };

    template<>
    struct VerifyCompareTraits<double, double>
    {
        static bool AreEqual(double a, double b)...",1,inc\consoletaeftemplates.hpp,WEX.TestExecution,46,TestExecution,1
444173,NAMESPACE_BLOCK,<empty>,,inc\contsf.hpp,inc\contsf.hpp:<global>,,<global>,1
444209,NAMESPACE_BLOCK,<empty>,,inc\cpl_core.hpp,inc\cpl_core.hpp:<global>,,<global>,1
444284,NAMESPACE_BLOCK,<empty>,,inc\til.hpp,inc\til.hpp:<global>,,<global>,1
444288,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    template<typename T>
    void manage_vector(std::vector<T>& vector, typename std::vector<T>::size_type requestedSize, float shrinkThreshold)
    {
        const auto existingCapacity = vector.capacity();
        const auto requiredCapacity = requestedSize;

        // Check by integer first as float math is way more expensive.
        if (requiredCapacity < existingCapacity)
        {
            // Now check if it's even worth shrinking. We don't want to shrink by 1 at a time, so meet a threshold first.
            if (requiredCapacity <= gsl::narrow_cast<size_t>((static_cast<float>(existingCapacity) * shrinkThreshold)))
            {
                // There's no real way to force a shrink, so make a new one.
                vector = std::vector<T>{};
            }
        }

        // Reserve won't shrink on its own and won't grow if we have enough space.
        vector.reserve(requiredCapacity);
   ...",1,inc\til.hpp,til,55,til,1
444337,NAMESPACE_BLOCK,<empty>,,inc\til\at.hpp,inc\til\at.hpp:<global>,,<global>,1
444341,NAMESPACE_BLOCK,"namespace til
{
    // The at function declares that you've already sufficiently checked that your array access
    // is in range before retrieving an item inside it at an offset.
    // This is to save double/triple/quadruple testing in circumstances where you are already
    // pivoting on the length of a set and now want to pull elements out of it by offset
    // without checking again.
    // gsl::at will do the check again. As will .at(). And using [] will have a warning in audit.
    // This template is explicitly disabled if T is of type std::span, as it would interfere with
    // the overload below.
    template<typename T, typename I>
    constexpr auto at(T&& cont, const I i) noexcept -> decltype(auto)
    {
#pragma warning(suppress : 26481) // Don't use pointer arithmetic. Use span instead (bounds.1).
#pragma warning(suppress : 26482) // Suppress bounds.2 check for indexing with constant expressions
#pragma warning(suppress : 26446) // Suppress bounds.4 check for subsc...",1,inc\til\at.hpp,til,6,til,1
444353,NAMESPACE_BLOCK,<empty>,,inc\til\atomic.hpp,inc\til\atomic.hpp:<global>,,<global>,1
444357,NAMESPACE_BLOCK,"namespace til
{
    template<typename T>
    inline void atomic_wait(const std::atomic<T>& atomic, const T& current, DWORD waitMilliseconds = INFINITE) noexcept
    {
        static_assert(sizeof(atomic) == sizeof(current));
#pragma warning(suppress : 26492) // Don't use const_cast to cast away const or volatile
        WaitOnAddress(const_cast<std::atomic<T>*>(&atomic), const_cast<T*>(&current), sizeof(current), waitMilliseconds);
    }

    template<typename T>
    inline void atomic_notify_one(const std::atomic<T>& atomic) noexcept
    {
#pragma warning(suppress : 26492) // Don't use const_cast to cast away const or volatile
        WakeByAddressSingle(const_cast<std::atomic<T>*>(&atomic));
    }

    template<typename T>
    inline void atomic_notify_all(const std::atomic<T>& atomic) noexcept
    {
#pragma warning(suppress : 26492) // Don't use const_cast to cast away const or volatile
        WakeByAddressAll(const_cast<std::atomic<T>*>(&atomic));
    }
}",1,inc\til\atomic.hpp,til,6,til,1
444404,NAMESPACE_BLOCK,<empty>,,inc\til\bit.hpp,inc\til\bit.hpp:<global>,,<global>,1
444408,NAMESPACE_BLOCK,"namespace til
{
    // bit_cast is a backport of the STL's std::bit_cast to C++17.
    template<class To, class From, std::enable_if_t<std::conjunction_v<std::bool_constant<sizeof(To) == sizeof(From)>, std::is_trivially_copyable<To>, std::is_trivially_copyable<From>>, int> = 0>
    [[nodiscard]] constexpr To bit_cast(const From& _Val) noexcept
    {
        // TODO: Replace til::bit_cast and __builtin_bit_cast with std::bit_cast
        return __builtin_bit_cast(To, _Val);
    }

    // When you cast a signed integer to an unsigned one, the compiler will use ""sign extension""
    // so that -1 translates to all bits being set, no matter the size of the target type.
    // Sometimes you don't need or want that, which is when you can use this function.
    template<typename T>
    [[nodiscard]] constexpr auto as_unsigned(const T& v) noexcept
    {
        return bit_cast<std::make_unsigned_t<T>>(v);
    }
}",1,inc\til\bit.hpp,til,6,til,1
444430,NAMESPACE_BLOCK,<empty>,,inc\til\bitmap.hpp,inc\til\bitmap.hpp:<global>,,<global>,1
444434,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    namespace details
    {
        template<typename Allocator>
        class _bitmap_const_iterator
        {
        public:
            using iterator_category = std::input_iterator_tag;
            using value_type = const til::rect;
            using difference_type = ptrdiff_t;
            using pointer = const til::rect*;
            using reference = const til::rect&;

            _bitmap_const_iterator(const dynamic_bitset<unsigned long long, Allocator>& values, til::rect rc, ptrdiff_t pos) :
                _values(values),
                _rc(rc),
                _pos(pos),
                _end(rc.size().area())
            {
                _calculateArea();
            }

            _bitmap_const_iterator& operator++()
            {
                _pos = _nextPos;
                _calculateArea();
                return (*this);
            }

            _bitmap_const_iterator operator++(int...",1,inc\til\bitmap.hpp,til,12,til,1
444435,NAMESPACE_BLOCK,"namespace details
    {
        template<typename Allocator>
        class _bitmap_const_iterator
        {
        public:
            using iterator_category = std::input_iterator_tag;
            using value_type = const til::rect;
            using difference_type = ptrdiff_t;
            using pointer = const til::rect*;
            using reference = const til::rect&;

            _bitmap_const_iterator(const dynamic_bitset<unsigned long long, Allocator>& values, til::rect rc, ptrdiff_t pos) :
                _values(values),
                _rc(rc),
                _pos(pos),
                _end(rc.size().area())
            {
                _calculateArea();
            }

            _bitmap_const_iterator& operator++()
            {
                _pos = _nextPos;
                _calculateArea();
                return (*this);
            }

            _bitmap_const_iterator operator++(int)
            {
                const auto prev = *this;
                ++*this...",5,inc\til\bitmap.hpp,til.details,14,details,1
445413,NAMESPACE_BLOCK,"namespace pmr
    {
        using bitmap = ::til::details::bitmap<std::pmr::polymorphic_allocator<unsigned long long>>;
    }",5,inc\til\bitmap.hpp,til.pmr,554,pmr,3
445418,NAMESPACE_BLOCK,<empty>,,inc\til\bytes.hpp,inc\til\bytes.hpp:<global>,,<global>,1
445422,NAMESPACE_BLOCK,"namespace til
{
    template<ContiguousBytes Target>
    constexpr void bytes_advance(Target& target, size_t count)
    {
        if (count > target.size())
        {
            throw std::length_error{ ""insufficient space left"" };
        }

        target = { target.data() + count, target.size() - count };
    }

    template<TriviallyCopyable T, ContiguousBytes Target>
    constexpr bool bytes_can_put(const Target& target)
    {
        return target.size() >= sizeof(T);
    }

    template<TriviallyCopyable T, ContiguousBytes Target>
    constexpr void bytes_put(Target& target, const T& value)
    {
        using TargetType = typename Target::value_type;
        constexpr auto size = sizeof(value);

        if (size > target.size())
        {
            throw std::length_error{ ""insufficient space left"" };
        }

        std::copy_n(reinterpret_cast<const TargetType*>(&value), size, target.data());
        target = { target.data() + size, target.size() - size };
    }

   ...",1,inc\til\bytes.hpp,til,8,til,1
445552,NAMESPACE_BLOCK,<empty>,,inc\til\coalesce.hpp,inc\til\coalesce.hpp:<global>,,<global>,1
445556,NAMESPACE_BLOCK,"namespace til
{
    // Method Description:
    // - Base case provided to handle the last argument to coalesce_value<T...>()
    template<typename T>
    T coalesce_value(const T& base) noexcept
    {
        return base;
    }

    // Method Description:
    // - Base case provided to throw an assertion if you call coalesce_value(opt, opt, opt)
    template<typename T>
    T coalesce_value(const std::optional<T>& base)
    {
        // There's no particular reason to use `sizeof(base) == 0` specifically.
        // We just need this assertion to be dependent on the type T here,
        // in order to delay the assertion until template instantiation.
        static_assert(sizeof(base) == 0, ""coalesce_value must be passed a base non-optional value to be used if all optionals are empty"");
        return T{};
    }

    // Method Description:
    // - Returns the value from the first populated optional, or a base value if none were populated.
    template<typename T, typename... Ts>
  ...",1,inc\til\coalesce.hpp,til,6,til,1
445633,NAMESPACE_BLOCK,<empty>,,inc\til\color.hpp,inc\til\color.hpp:<global>,,<global>,1
445637,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    // color is a universal integral 8bpp RGBA (0-255) color type implicitly convertible to/from
    // a number of other color types.
#pragma warning(push)
    // we can't depend on GSL here, so we use static_cast for explicit narrowing
#pragma warning(disable : 26472) // Don't use a static_cast for arithmetic conversions. Use brace initialization, gsl::narrow_cast or gsl::narrow (type.1).
#pragma warning(disable : 26495) // Variable 'til::color::<unnamed-tag>::abgr' is uninitialized. Always initialize a member variable (type.6).
    struct color
    {
        // Clang (10) has no trouble optimizing the COLORREF conversion operator, below, to a
        // simple 32-bit load with mask (!) even though it's a series of bit shifts across
        // multiple struct members.
        // CL (19.24) doesn't make the same optimization decision, and it emits three 8-bit loads
        // and some shifting.
        // I...",1,inc\til\color.hpp,til,6,til,1
445959,NAMESPACE_BLOCK,<empty>,,inc\til\enumset.hpp,inc\til\enumset.hpp:<global>,,<global>,1
445963,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    // til::enumset stores a fixed size array of boolean elements, the positions
    // in the array being identified by values from a given enumerated type.
    // Position N corresponds to bit 1<<N in the UnderlyingType integer.
    //
    // If you only need 32 positions for your T, UnderlyingType can be set uint32_t.
    // It defaults to uintptr_t allowing you to set as many positions as a pointer has bits.
    // This class doesn't statically assert that your given position fits into UnderlyingType.
    template<typename T, typename UnderlyingType = uintptr_t>
    class enumset
    {
        static_assert(std::is_unsigned_v<UnderlyingType>);

    public:
        // Method Description:
        // - Constructs a new bitset with the given list of positions set to true.
        TIL_ENUMSET_VARARG
        constexpr enumset(Args... positions) noexcept :
            _data{ to_underlying(positions...) }
      ...",1,inc\til\enumset.hpp,til,12,til,1
446155,NAMESPACE_BLOCK,<empty>,,inc\til\env.hpp,inc\til\env.hpp:<global>,,<global>,1
446159,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    namespace details
    {

        namespace vars
        {
            inline constexpr wil::zwstring_view system_root{ L""SystemRoot"" };
            inline constexpr wil::zwstring_view system_drive{ L""SystemDrive"" };
            inline constexpr wil::zwstring_view all_users_profile{ L""ALLUSERSPROFILE"" };
            inline constexpr wil::zwstring_view public_var{ L""PUBLIC"" };
            inline constexpr wil::zwstring_view program_data{ L""ProgramData"" };
            inline constexpr wil::zwstring_view computer_name{ L""COMPUTERNAME"" };
            inline constexpr wil::zwstring_view user_name{ L""USERNAME"" };
            inline constexpr wil::zwstring_view user_domain{ L""USERDOMAIN"" };
            inline constexpr wil::zwstring_view user_dns_domain{ L""USERDNSDOMAIN"" };
            inline constexpr wil::zwstring_view home_drive{ L""HOMEDRIVE"" };
            inline constexpr wil::zwstring_view home_share{ L""HO...",1,inc\til\env.hpp,til,20,til,1
446160,NAMESPACE_BLOCK,"namespace details
    {

        namespace vars
        {
            inline constexpr wil::zwstring_view system_root{ L""SystemRoot"" };
            inline constexpr wil::zwstring_view system_drive{ L""SystemDrive"" };
            inline constexpr wil::zwstring_view all_users_profile{ L""ALLUSERSPROFILE"" };
            inline constexpr wil::zwstring_view public_var{ L""PUBLIC"" };
            inline constexpr wil::zwstring_view program_data{ L""ProgramData"" };
            inline constexpr wil::zwstring_view computer_name{ L""COMPUTERNAME"" };
            inline constexpr wil::zwstring_view user_name{ L""USERNAME"" };
            inline constexpr wil::zwstring_view user_domain{ L""USERDOMAIN"" };
            inline constexpr wil::zwstring_view user_dns_domain{ L""USERDNSDOMAIN"" };
            inline constexpr wil::zwstring_view home_drive{ L""HOMEDRIVE"" };
            inline constexpr wil::zwstring_view home_share{ L""HOMESHARE"" };
            inline constexpr wil::zwstring_view home_path{ L""HOMEPAT...",5,inc\til\env.hpp,til.details,22,details,1
446161,NAMESPACE_BLOCK,"namespace vars
        {
            inline constexpr wil::zwstring_view system_root{ L""SystemRoot"" };
            inline constexpr wil::zwstring_view system_drive{ L""SystemDrive"" };
            inline constexpr wil::zwstring_view all_users_profile{ L""ALLUSERSPROFILE"" };
            inline constexpr wil::zwstring_view public_var{ L""PUBLIC"" };
            inline constexpr wil::zwstring_view program_data{ L""ProgramData"" };
            inline constexpr wil::zwstring_view computer_name{ L""COMPUTERNAME"" };
            inline constexpr wil::zwstring_view user_name{ L""USERNAME"" };
            inline constexpr wil::zwstring_view user_domain{ L""USERDOMAIN"" };
            inline constexpr wil::zwstring_view user_dns_domain{ L""USERDNSDOMAIN"" };
            inline constexpr wil::zwstring_view home_drive{ L""HOMEDRIVE"" };
            inline constexpr wil::zwstring_view home_share{ L""HOMESHARE"" };
            inline constexpr wil::zwstring_view home_path{ L""HOMEPATH"" };
            inline constexp...",9,inc\til\env.hpp,til.details.vars,25,vars,1
446289,NAMESPACE_BLOCK,"namespace reg
            {
                inline constexpr wil::zwstring_view program_files_root{ LR""(Software\Microsoft\Windows\CurrentVersion)"" };
                inline constexpr wil::zwstring_view system_env_var_root{ LR""(SYSTEM\CurrentControlSet\Control\Session Manager\Environment)"" };
                inline constexpr wil::zwstring_view user_env_var_root{ LR""(Environment)"" };
                inline constexpr wil::zwstring_view user_volatile_env_var_root{ LR""(Volatile Environment)"" };
                inline constexpr wil::zwstring_view user_volatile_session_env_var_root_pattern{ LR""(Volatile Environment\{0:d})"" };
            }",13,inc\til\env.hpp,til.details.vars.reg,67,reg,49
446315,NAMESPACE_BLOCK,"namespace wil_env
        {
            /** Looks up a registry value from 'key' and fails if it is not found. */
            template<typename string_type, size_t initialBufferLength = 256>
            HRESULT RegQueryValueExW(HKEY key, PCWSTR valueName, string_type& result) WI_NOEXCEPT
            {
                return wil::AdaptFixedSizeToAllocatedResult<string_type, initialBufferLength>(result, [&](_Out_writes_(valueLength) PWSTR value, size_t valueLength, _Out_ size_t* valueLengthNeededWithNul) -> HRESULT {
                    auto length = gsl::narrow<DWORD>(valueLength * sizeof(wchar_t));
                    const auto status = ::RegQueryValueExW(key, valueName, nullptr, nullptr, reinterpret_cast<BYTE*>(value), &length);
                    // length will receive the number of bytes including trailing null byte. Convert to a number of wchar_t's.
                    // AdaptFixedSizeToAllocatedResult will then resize buffer to valueLengthNeededWithNull.
                    ...",9,inc\til\env.hpp,til.details.wil_env,77,wil_env,2
447406,NAMESPACE_BLOCK,<empty>,,inc\til\flat_set.hpp,inc\til\flat_set.hpp:<global>,,<global>,1
447410,NAMESPACE_BLOCK,"namespace til
{
    // A simple hash function for simple hash maps.
    // As demonstrated in https://doi.org/10.14778/2850583.2850585, a simple ""multiply and shift"" hash performs
    // very well with linear probing hash maps and I found this to be true as well in my own testing. This hash
    // function doesn't do the ""shift"" part, because linear_flat_set already does it by an appropriate amount.
    constexpr size_t flat_set_hash_integer(size_t v) noexcept
    {
        // These two multipliers are the same as used by the PCG family of random number generators.
        // The 32-Bit version is described in https://doi.org/10.1090/S0025-5718-99-00996-5, Table 5.
        // The 64-Bit version is the multiplier as used by Donald Knuth for MMIX and found by C. E. Haynes.
#ifdef _WIN64
        return v * UINT64_C(6364136223846793005);
#else
        return v * UINT32_C(747796405);
#endif
    }

    // A basic, hashmap with linear probing. A `LoadFactor` of 2 equals
    // a max. load ...",1,inc\til\flat_set.hpp,til,10,til,1
447806,NAMESPACE_BLOCK,<empty>,,inc\til\generational.hpp,inc\til\generational.hpp:<global>,,<global>,1
447810,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    struct generation_t
    {
        auto operator<=>(const generation_t&) const = default;

        constexpr void bump() noexcept
        {
            _value++;
        }

        uint32_t _value = 0;
    };

    // It can be costly, difficult, or often impossible to compare two
    // instances of a struct. This little helper can simplify this.
    //
    // The underlying idea is that changes in state occur much less often than
    // the amount of data that's being processed in between. As such, this
    // helper assumes that _any_ modification to the struct it wraps is a
    // state change. When you compare the modified instance with another
    // the comparison operator will then always return false. This makes
    // state changes potentially more costly, because more state might be
    // invalidated than was necessary, but on the other hand it makes both,
    // the code simpler and the fast-p...",1,inc\til\generational.hpp,til,6,til,1
447907,NAMESPACE_BLOCK,<empty>,,inc\til\hash.hpp,inc\til\hash.hpp:<global>,,<global>,1
447911,NAMESPACE_BLOCK,"namespace til
{
    template<typename T>
    struct hash_trait;

    struct hasher
    {
        constexpr hasher() = default;
        explicit constexpr hasher(size_t state) noexcept :
            _hash{ state } {}

        template<typename T>
        hasher& write(const T& v) noexcept
        {
            hash_trait<T>{}(*this, v);
            return *this;
        }

        template<typename T, typename = std::enable_if_t<std::has_unique_object_representations_v<T>>>
        hasher& write(const T* data, size_t count) noexcept
        {
            return write(static_cast<const void*>(data), sizeof(T) * count);
        }

        hasher& write(const void* data, size_t len) noexcept
        {
            _hash = _wyhash(data, len, _hash);
            return *this;
        }

        constexpr size_t finalize() const noexcept
        {
            return _hash;
        }

    private:
#if defined(TIL_HASH_32BIT)

        static uint32_t _wyr24(const uint8_t* p, uint32_t k) noexc...",1,inc\til\hash.hpp,til,26,til,1
448309,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T, bool enable>
        struct conditionally_enabled_hash_trait
        {
            void operator()(hasher& h, const T& v) const noexcept
            {
                h.write(static_cast<const void*>(&v), sizeof(T));
            }
        };

        template<typename T>
        struct conditionally_enabled_hash_trait<T, false>
        {
            conditionally_enabled_hash_trait() = delete;
            conditionally_enabled_hash_trait(const conditionally_enabled_hash_trait&) = delete;
            conditionally_enabled_hash_trait(conditionally_enabled_hash_trait&&) = delete;
            conditionally_enabled_hash_trait& operator=(const conditionally_enabled_hash_trait&) = delete;
            conditionally_enabled_hash_trait& operator=(conditionally_enabled_hash_trait&&) = delete;
        };
    }",5,inc\til\hash.hpp,til.details,209,details,3
448478,NAMESPACE_BLOCK,<empty>,,inc\til\latch.hpp,inc\til\latch.hpp:<global>,,<global>,1
448482,NAMESPACE_BLOCK,"namespace til
{
#ifdef __cpp_lib_latch
    using latch = std::latch;
#else
    class latch
    {
    public:
        [[nodiscard]] static constexpr ptrdiff_t max() noexcept
        {
            return std::numeric_limits<ptrdiff_t>::max();
        }

        constexpr explicit latch(const ptrdiff_t expected) noexcept :
            counter{ expected }
        {
            assert(expected >= 0);
        }

        latch(const latch&) = delete;
        latch& operator=(const latch&) = delete;

        void count_down(const ptrdiff_t n = 1) noexcept
        {
            assert(n >= 0);

            const auto old = counter.fetch_sub(n, std::memory_order_release);
            if (old == n)
            {
                WakeByAddressAll(&counter);
                return;
            }

            assert(old > n);
        }

        [[nodiscard]] bool try_wait() const noexcept
        {
            return counter.load(std::memory_order_acquire) == 0;
        }

        void wait() cons...",1,inc\til\latch.hpp,til,10,til,1
448646,NAMESPACE_BLOCK,<empty>,,inc\til\math.hpp,inc\til\math.hpp:<global>,,<global>,1
448650,NAMESPACE_BLOCK,"namespace til
{
    // The til::math namespace contains TIL math guidance casts;
    // they are intended to be used as the first argument to
    // floating-point universal converters elsewhere in the til namespace.
    namespace math
    {
        namespace details
        {
            // Just like gsl::narrow, but also checks for NAN.
            template<typename O, typename T>
            constexpr O narrow_float(T val)
            {
                const auto o = gsl::narrow_cast<O>(val);
                if (static_cast<T>(o) != val)
                {
                    throw gsl::narrowing_error{};
                }
                return o;
            }

            struct ceiling_t
            {
                template<typename O, typename T>
                static constexpr O cast(T val)
                {
                    if constexpr (std::is_floating_point_v<T>)
                    {
                        return narrow_float<O, T>(std::ceil(val));
              ...",1,inc\til\math.hpp,til,6,til,1
448651,NAMESPACE_BLOCK,"namespace math
    {
        namespace details
        {
            // Just like gsl::narrow, but also checks for NAN.
            template<typename O, typename T>
            constexpr O narrow_float(T val)
            {
                const auto o = gsl::narrow_cast<O>(val);
                if (static_cast<T>(o) != val)
                {
                    throw gsl::narrowing_error{};
                }
                return o;
            }

            struct ceiling_t
            {
                template<typename O, typename T>
                static constexpr O cast(T val)
                {
                    if constexpr (std::is_floating_point_v<T>)
                    {
                        return narrow_float<O, T>(std::ceil(val));
                    }
                    else
                    {
                        return gsl::narrow<O>(val);
                    }
                }
            };

            struct flooring_t
            {
              ...",5,inc\til\math.hpp,til.math,11,math,1
448652,NAMESPACE_BLOCK,"namespace details
        {
            // Just like gsl::narrow, but also checks for NAN.
            template<typename O, typename T>
            constexpr O narrow_float(T val)
            {
                const auto o = gsl::narrow_cast<O>(val);
                if (static_cast<T>(o) != val)
                {
                    throw gsl::narrowing_error{};
                }
                return o;
            }

            struct ceiling_t
            {
                template<typename O, typename T>
                static constexpr O cast(T val)
                {
                    if constexpr (std::is_floating_point_v<T>)
                    {
                        return narrow_float<O, T>(std::ceil(val));
                    }
                    else
                    {
                        return gsl::narrow<O>(val);
                    }
                }
            };

            struct flooring_t
            {
                template<typename O, typena...",9,inc\til\math.hpp,til.math.details,13,details,1
448807,NAMESPACE_BLOCK,<empty>,,inc\til\mutex.hpp,inc\til\mutex.hpp:<global>,,<global>,1
448811,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        template<typename T, typename Lock>
        class shared_mutex_guard
        {
        public:
#pragma warning(suppress : 26447) // The function is declared 'noexcept' but calls function 'shared_mutex>()' which may throw exceptions (f.6).)
            shared_mutex_guard(T& data, std::shared_mutex& mutex) noexcept :
                _data{ data },
                _lock{ mutex }
            {
            }

            shared_mutex_guard(const shared_mutex_guard&) = delete;
            shared_mutex_guard& operator=(const shared_mutex_guard&) = delete;

            shared_mutex_guard(shared_mutex_guard&&) = default;
            shared_mutex_guard& operator=(shared_mutex_guard&&) = default;

            [[nodiscard]] constexpr T* operator->() const noexcept
            {
                return &_data;
            }

            [[nodiscard]] constexpr T& operator*() const& noexcept
            {
                return _data;
           ...",1,inc\til\mutex.hpp,til,4,til,1
448812,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T, typename Lock>
        class shared_mutex_guard
        {
        public:
#pragma warning(suppress : 26447) // The function is declared 'noexcept' but calls function 'shared_mutex>()' which may throw exceptions (f.6).)
            shared_mutex_guard(T& data, std::shared_mutex& mutex) noexcept :
                _data{ data },
                _lock{ mutex }
            {
            }

            shared_mutex_guard(const shared_mutex_guard&) = delete;
            shared_mutex_guard& operator=(const shared_mutex_guard&) = delete;

            shared_mutex_guard(shared_mutex_guard&&) = default;
            shared_mutex_guard& operator=(shared_mutex_guard&&) = default;

            [[nodiscard]] constexpr T* operator->() const noexcept
            {
                return &_data;
            }

            [[nodiscard]] constexpr T& operator*() const& noexcept
            {
                return _data;
            }

            [[no...",5,inc\til\mutex.hpp,til.details,6,details,1
448897,NAMESPACE_BLOCK,<empty>,,inc\til\operators.hpp,inc\til\operators.hpp:<global>,,<global>,1
448901,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    // Operators go here when they involve two headers that can't/don't include each other.

#pragma region POINT VS SIZE
    // This is a convenience and will take X vs WIDTH and Y vs HEIGHT.
    constexpr point operator+(const point lhs, const size rhs)
    {
        return lhs + til::point{ rhs.width, rhs.height };
    }

    constexpr point operator-(const point lhs, const size rhs)
    {
        return lhs - til::point{ rhs.width, rhs.height };
    }

    constexpr point operator*(const point lhs, const size rhs)
    {
        return lhs * til::point{ rhs.width, rhs.height };
    }

    constexpr point operator/(const point lhs, const size rhs)
    {
        return lhs / til::point{ rhs.width, rhs.height };
    }
#pragma endregion

#pragma region SIZE VS POINT
    // This is a convenience and will take WIDTH vs X and HEIGHT vs Y.
    constexpr size operator+(const size lhs, const point rhs)
    {
      ...",1,inc\til\operators.hpp,til,6,til,1
449047,NAMESPACE_BLOCK,<empty>,,inc\til\pmr.hpp,inc\til\pmr.hpp:<global>,,<global>,1
449051,NAMESPACE_BLOCK,"namespace til::pmr
{
#ifdef __INSIDE_WINDOWS
    // I really, really didn't want to have to stick this function in here.
    // However, the default constructor for optional (really, ""optional construct base"")
    // insists on being able to default-construct its type. We have an instance in til
    // of an optional<vector<..., pmr allocator>> that forces _Aligned_get_default_resource
    // to get pulled in. This pragma mollifies the linker, and using this function in
    // get_default_resource below forces it to be included by the compiler.
    // I *believe* that if the VC++ Runtime is updated to include the PMR source,
    // this will safely no-op (since it's an ALTERNATENAME).
#if defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_ARM)
#pragma comment(linker, ""/ALTERNATENAME:_Aligned_get_default_resource=TIL_PMR_Aligned_get_default_resource"")
#else
#pragma comment(linker, ""/ALTERNATENAME:__Aligned_get_default_resource=_TIL_PMR_Aligned_get_default_resource"")
#endif
    exte...",1,inc\til\pmr.hpp,til,13,til,1
449052,NAMESPACE_BLOCK,"namespace til::pmr
{
#ifdef __INSIDE_WINDOWS
    // I really, really didn't want to have to stick this function in here.
    // However, the default constructor for optional (really, ""optional construct base"")
    // insists on being able to default-construct its type. We have an instance in til
    // of an optional<vector<..., pmr allocator>> that forces _Aligned_get_default_resource
    // to get pulled in. This pragma mollifies the linker, and using this function in
    // get_default_resource below forces it to be included by the compiler.
    // I *believe* that if the VC++ Runtime is updated to include the PMR source,
    // this will safely no-op (since it's an ALTERNATENAME).
#if defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_ARM)
#pragma comment(linker, ""/ALTERNATENAME:_Aligned_get_default_resource=TIL_PMR_Aligned_get_default_resource"")
#else
#pragma comment(linker, ""/ALTERNATENAME:__Aligned_get_default_resource=_TIL_PMR_Aligned_get_default_resource"")
#endif
    exte...",1,inc\til\pmr.hpp,til.pmr,13,pmr,1
449065,NAMESPACE_BLOCK,<empty>,,inc\til\point.hpp,inc\til\point.hpp:<global>,,<global>,1
449069,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    using CoordType = int32_t;
    inline constexpr CoordType CoordTypeMin = INT32_MIN;
    inline constexpr CoordType CoordTypeMax = INT32_MAX;

    namespace details
    {
        template<typename T, typename U = T>
        constexpr U extract(const ::base::CheckedNumeric<T>& num)
        {
            U val;
            if (!num.AssignIfValid(&val))
            {
                throw gsl::narrowing_error{};
            }
            return val;
        }
    }

    struct point
    {
        CoordType x = 0;
        CoordType y = 0;

        constexpr point() noexcept = default;

        constexpr point(CoordType x, CoordType y) noexcept :
            x{ x }, y{ y }
        {
        }

        // This template will convert to point from floating-point args;
        // a math type is required. If you _don't_ provide one, you're going to
        // get a compile-time error about ""cannot convert from init...",1,inc\til\point.hpp,til,6,til,1
449079,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T, typename U = T>
        constexpr U extract(const ::base::CheckedNumeric<T>& num)
        {
            U val;
            if (!num.AssignIfValid(&val))
            {
                throw gsl::narrowing_error{};
            }
            return val;
        }
    }",5,inc\til\point.hpp,til.details,12,details,6
449664,NAMESPACE_BLOCK,<empty>,,inc\til\rand.hpp,inc\til\rand.hpp:<global>,,<global>,1
449668,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        typedef BOOLEAN(APIENTRY* RtlGenRandom)(PVOID RandomBuffer, ULONG RandomBufferLength);

        struct RtlGenRandomLoader
        {
            RtlGenRandomLoader() noexcept :
                // The documentation states:
                //   This function has no associated import library. This function is available
                //   as a resource named SystemFunction036 in Advapi32.dll. You must use the
                //   LoadLibrary and GetProcAddress functions to dynamically link to Advapi32.dll.
                //
                // There's two downsides to using advapi32.dll however:
                // * The actual implementation resides in cryptbase.dll and...
                // * In older versions of Windows (7 and older) advapi32.dll didn't use forwarding to
                //   cryptbase, instead it was using LoadLibrary()/GetProcAddress() on every call.
                // * advapi32.dll doesn't exist on MinWin, cryptb...",1,inc\til\rand.hpp,til,6,til,1
449669,NAMESPACE_BLOCK,"namespace details
    {
        typedef BOOLEAN(APIENTRY* RtlGenRandom)(PVOID RandomBuffer, ULONG RandomBufferLength);

        struct RtlGenRandomLoader
        {
            RtlGenRandomLoader() noexcept :
                // The documentation states:
                //   This function has no associated import library. This function is available
                //   as a resource named SystemFunction036 in Advapi32.dll. You must use the
                //   LoadLibrary and GetProcAddress functions to dynamically link to Advapi32.dll.
                //
                // There's two downsides to using advapi32.dll however:
                // * The actual implementation resides in cryptbase.dll and...
                // * In older versions of Windows (7 and older) advapi32.dll didn't use forwarding to
                //   cryptbase, instead it was using LoadLibrary()/GetProcAddress() on every call.
                // * advapi32.dll doesn't exist on MinWin, cryptbase.dll however does...",5,inc\til\rand.hpp,til.details,8,details,1
449725,NAMESPACE_BLOCK,<empty>,,inc\til\rect.hpp,inc\til\rect.hpp:<global>,,<global>,1
449729,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    struct inclusive_rect
    {
        CoordType left = 0;
        CoordType top = 0;
        CoordType right = 0;
        CoordType bottom = 0;

        constexpr bool operator==(const inclusive_rect& rhs) const noexcept
        {
            return __builtin_memcmp(this, &rhs, sizeof(rhs)) == 0;
        }

        constexpr bool operator!=(const inclusive_rect& rhs) const noexcept
        {
            return __builtin_memcmp(this, &rhs, sizeof(rhs)) != 0;
        }

        explicit constexpr operator bool() const noexcept
        {
            return (left >= 0) & (top >= 0) &
                   (right >= left) & (bottom >= top);
        }
    };

    constexpr inclusive_rect wrap_small_rect(const SMALL_RECT& rect) noexcept
    {
        return { rect.Left, rect.Top, rect.Right, rect.Bottom };
    }

    constexpr SMALL_RECT unwrap_small_rect(const inclusive_rect& rect)
    {
        return {
          ...",1,inc\til\rect.hpp,til,13,til,1
449881,NAMESPACE_BLOCK,"namespace details
    {
        class _rectangle_const_iterator
        {
        public:
            constexpr _rectangle_const_iterator(point topLeft, point bottomRight) :
                _topLeft{ topLeft },
                _bottomRight{ bottomRight },
                _current{ topLeft }
            {
            }

            constexpr _rectangle_const_iterator(point topLeft, point bottomRight, point start) :
                _topLeft{ topLeft },
                _bottomRight{ bottomRight },
                _current{ start }
            {
            }

            _rectangle_const_iterator& operator++()
            {
                const auto nextX = details::extract(::base::CheckAdd(_current.x, 1));

                if (nextX >= _bottomRight.x)
                {
                    const auto nextY = details::extract(::base::CheckAdd(_current.y, 1));
                    // Note for the standard Left-to-Right, Top-to-Bottom walk,
                    // the end position is one c...",5,inc\til\rect.hpp,til.details,71,details,5
451194,NAMESPACE_BLOCK,<empty>,,inc\til\replace.hpp,inc\til\replace.hpp:<global>,,<global>,1
451198,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        template<typename T>
        struct view_type_oracle
        {
        };

        template<>
        struct view_type_oracle<std::string>
        {
            using type = std::string_view;
        };

        template<>
        struct view_type_oracle<std::wstring>
        {
            using type = std::wstring_view;
        };

    }

    // Method Description:
    // - This is a function for finding all occurrences of a given string
    //   `needle` in a larger string `haystack`, and replacing them with the
    //   string `replacement`.
    // - This find/replace is done in-place, leaving `haystack` modified as a result.
    // Arguments:
    // - haystack: The string to find and replace in
    // - needle: The string to search for
    // - replacement: The string to replace `needle` with
    // Return Value:
    // - <none>
    template<typename T>
    void replace_needle_in_haystack_inplace(T& haystack,
                  ...",1,inc\til\replace.hpp,til,6,til,1
451199,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T>
        struct view_type_oracle
        {
        };

        template<>
        struct view_type_oracle<std::string>
        {
            using type = std::string_view;
        };

        template<>
        struct view_type_oracle<std::wstring>
        {
            using type = std::wstring_view;
        };

    }",5,inc\til\replace.hpp,til.details,8,details,1
451264,NAMESPACE_BLOCK,<empty>,,inc\til\rle.hpp,inc\til\rle.hpp:<global>,,<global>,1
451268,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    namespace details
    {
        template<typename T, typename S, typename ParentIt>
        class rle_iterator
        {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = T;
            using pointer = T*;
            using reference = T&;
            using size_type = S;
            using difference_type = typename ParentIt::difference_type;

            // TODO GH#10135: Enable checked iterators for _ITERATOR_DEBUG_LEVEL != 0.
            explicit rle_iterator(ParentIt&& it) noexcept :
                _it{ std::forward<ParentIt>(it) },
                _pos{ 0 }
            {
            }

            [[nodiscard]] reference operator*() const noexcept
            {
                return _it->value;
            }

            [[nodiscard]] pointer operator->() const noexcept
            {
                return &operator*();
          ...",1,inc\til\rle.hpp,til,12,til,1
451269,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T, typename S, typename ParentIt>
        class rle_iterator
        {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = T;
            using pointer = T*;
            using reference = T&;
            using size_type = S;
            using difference_type = typename ParentIt::difference_type;

            // TODO GH#10135: Enable checked iterators for _ITERATOR_DEBUG_LEVEL != 0.
            explicit rle_iterator(ParentIt&& it) noexcept :
                _it{ std::forward<ParentIt>(it) },
                _pos{ 0 }
            {
            }

            [[nodiscard]] reference operator*() const noexcept
            {
                return _it->value;
            }

            [[nodiscard]] pointer operator->() const noexcept
            {
                return &operator*();
            }

            rle_iterator& operator++() noexcept
            {
             ...",5,inc\til\rle.hpp,til.details,14,details,1
452945,NAMESPACE_BLOCK,<empty>,,inc\til\size.hpp,inc\til\size.hpp:<global>,,<global>,1
452949,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    struct size
    {
        constexpr size() noexcept = default;

        constexpr size(CoordType width, CoordType height) noexcept :
            width{ width }, height{ height }
        {
        }

        // This template will convert to size from floating-point args;
        // a math type is required. If you _don't_ provide one, you're going to
        // get a compile-time error about ""cannot convert from initializer-list to til::size""
        template<typename TilMath, typename T>
        constexpr size(TilMath, const T width, const T height) :
            width{ TilMath::template cast<CoordType>(width) }, height{ TilMath::template cast<CoordType>(height) }
        {
        }

        constexpr bool operator==(const size rhs) const noexcept
        {
            // `__builtin_memcmp` isn't an official standard, but it's the
            // only way at the time of writing to get a constexpr `memcmp`...",1,inc\til\size.hpp,til,8,til,1
453425,NAMESPACE_BLOCK,<empty>,,inc\til\small_vector.hpp,inc\til\small_vector.hpp:<global>,,<global>,1
453429,NAMESPACE_BLOCK,"namespace til
{
    // This class was adopted from std::span<>::iterator.
    template<typename T>
    struct small_vector_const_iterator
    {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = T;
        using difference_type = std::ptrdiff_t;
        using pointer = const T*;
        using reference = const T&;

        small_vector_const_iterator() = default;

#if _ITERATOR_DEBUG_LEVEL == 0
        constexpr small_vector_const_iterator(pointer ptr) :
            _ptr{ ptr }
        {
        }
#else // _ITERATOR_DEBUG_LEVEL == 0
        constexpr small_vector_const_iterator(pointer ptr, pointer begin, pointer end) :
            _ptr{ ptr },
            _begin{ begin },
            _end{ end }
        {
        }
#endif // _ITERATOR_DEBUG_LEVEL == 0

        [[nodiscard]] constexpr reference operator*() const noexcept
        {
#if _ITERATOR_DEBUG_LEVEL >= 1
            _STL_...",1,inc\til\small_vector.hpp,til,22,til,1
455034,NAMESPACE_BLOCK,<empty>,,inc\til\some.hpp,inc\til\some.hpp:<global>,,<global>,1
455038,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    template<class T, size_t N>
    class some
    {
    private:
        std::array<T, N> _array;
        size_t _used;

#ifdef UNIT_TESTING
        friend class SomeTests;
#endif

    public:
        using value_type = T;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = T*;
        using const_pointer = const T*;
        using reference = T&;
        using const_reference = const T&;

        using iterator = typename decltype(_array)::iterator;
        using const_iterator = typename decltype(_array)::const_iterator;

        using reverse_iterator = typename decltype(_array)::reverse_iterator;
        using const_reverse_iterator = typename decltype(_array)::const_reverse_iterator;

        constexpr some() noexcept :
            _array{},
            _used{ 0 }
        {
        }

        constexpr some(std::initializer_list<T> init)
        {
       ...",1,inc\til\some.hpp,til,8,til,1
455451,NAMESPACE_BLOCK,<empty>,,inc\til\spsc.hpp,inc\til\spsc.hpp:<global>,,<global>,1
455455,NAMESPACE_BLOCK,"namespace til::spsc
{
    using size_type = uint32_t;

    namespace details
    {
        inline constexpr size_type position_mask = std::numeric_limits<size_type>::max() >> 2u; // 0b00111....
        inline constexpr size_type revolution_flag = 1u << (std::numeric_limits<size_type>::digits - 2u); // 0b01000....
        inline constexpr size_type drop_flag = 1u << (std::numeric_limits<size_type>::digits - 1u); // 0b10000....

        struct block_initially_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = false;
        };

        struct block_forever_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = true;
        };

        template<typename WaitPolicy>
        using enable_if_wait_policy_t = typename std::remove_reference_t<WaitPolicy>::_spsc_policy;

#if _TIL_SPSC_DETAIL_POSITION_IMPL_NATIVE
        using atomic_size_type = std::atomic<size_type>;
#else
        // at...",1,inc\til\spsc.hpp,til,21,til,1
455456,NAMESPACE_BLOCK,"namespace til::spsc
{
    using size_type = uint32_t;

    namespace details
    {
        inline constexpr size_type position_mask = std::numeric_limits<size_type>::max() >> 2u; // 0b00111....
        inline constexpr size_type revolution_flag = 1u << (std::numeric_limits<size_type>::digits - 2u); // 0b01000....
        inline constexpr size_type drop_flag = 1u << (std::numeric_limits<size_type>::digits - 1u); // 0b10000....

        struct block_initially_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = false;
        };

        struct block_forever_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = true;
        };

        template<typename WaitPolicy>
        using enable_if_wait_policy_t = typename std::remove_reference_t<WaitPolicy>::_spsc_policy;

#if _TIL_SPSC_DETAIL_POSITION_IMPL_NATIVE
        using atomic_size_type = std::atomic<size_type>;
#else
        // at...",1,inc\til\spsc.hpp,til.spsc,21,spsc,1
455458,NAMESPACE_BLOCK,"namespace details
    {
        inline constexpr size_type position_mask = std::numeric_limits<size_type>::max() >> 2u; // 0b00111....
        inline constexpr size_type revolution_flag = 1u << (std::numeric_limits<size_type>::digits - 2u); // 0b01000....
        inline constexpr size_type drop_flag = 1u << (std::numeric_limits<size_type>::digits - 1u); // 0b10000....

        struct block_initially_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = false;
        };

        struct block_forever_policy
        {
            using _spsc_policy = int;
            static constexpr bool _block_forever = true;
        };

        template<typename WaitPolicy>
        using enable_if_wait_policy_t = typename std::remove_reference_t<WaitPolicy>::_spsc_policy;

#if _TIL_SPSC_DETAIL_POSITION_IMPL_NATIVE
        using atomic_size_type = std::atomic<size_type>;
#else
        // atomic_size_type is a fallback if native std::atomic<size_typ...",5,inc\til\spsc.hpp,til.spsc.details,25,details,2
456646,NAMESPACE_BLOCK,<empty>,,inc\til\static_map.hpp,inc\til\static_map.hpp:<global>,,<global>,1
456650,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    namespace details
    {
        struct unsorted_input_t : public std::false_type
        {
        };

        struct presorted_input_t : public std::true_type
        {
        };
    }

    template<typename K, typename V, size_t N, typename SortedInput = details::unsorted_input_t>
    class static_map
    {
    public:
        using const_iterator = typename std::array<std::pair<K, V>, N>::const_iterator;

        template<typename... Args>
        constexpr explicit static_map(Args&&... args) noexcept :
            _array{ { std::forward<Args>(args)... } }
        {
            static_assert(sizeof...(Args) == N);
            if constexpr (!SortedInput::value)
            {
                std::sort(_array.begin(), _array.end());
            }
        }

        [[nodiscard]] constexpr const_iterator find(const auto& key) const noexcept
        {
            const auto iter = std::partition_point(_ar...",1,inc\til\static_map.hpp,til,17,til,1
456651,NAMESPACE_BLOCK,"namespace details
    {
        struct unsorted_input_t : public std::false_type
        {
        };

        struct presorted_input_t : public std::true_type
        {
        };
    }",5,inc\til\static_map.hpp,til.details,19,details,1
456853,NAMESPACE_BLOCK,<empty>,,inc\til\string.hpp,inc\til\string.hpp:<global>,,<global>,1
456856,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    _TIL_INLINEPREFIX std::wstring visualize_control_codes(std::wstring str) noexcept
    {
        for (auto& ch : str)
        {
            if (ch < 0x20)
            {
                ch += 0x2400;
            }
            else if (ch == 0x20)
            {
                ch = 0x2423; // replace space with ␣
            }
            else if (ch == 0x7f)
            {
                ch = 0x2421; // replace del with ␡
            }
        }
        return str;
    }

    _TIL_INLINEPREFIX std::wstring visualize_control_codes(std::wstring_view str)
    {
        return visualize_control_codes(std::wstring{ str });
    }

    namespace details
    {
        inline constexpr uint8_t __ = 0b00;
        inline constexpr uint8_t F_ = 0b10; // stripped in clean_filename
        inline constexpr uint8_t _P = 0b01; // stripped in clean_path
        inline constexpr uint8_t FP = 0b11; // stripped in clean_filen...",1,inc\til\string.hpp,til,6,til,1
456908,NAMESPACE_BLOCK,"namespace details
    {
        inline constexpr uint8_t __ = 0b00;
        inline constexpr uint8_t F_ = 0b10; // stripped in clean_filename
        inline constexpr uint8_t _P = 0b01; // stripped in clean_path
        inline constexpr uint8_t FP = 0b11; // stripped in clean_filename and clean_path
        inline constexpr std::array<uint8_t, 128> pathFilter{ {
            // clang-format off
            __ /* NUL */, __ /* SOH */, __ /* STX */, __ /* ETX */, __ /* EOT */, __ /* ENQ */, __ /* ACK */, __ /* BEL */, __ /* BS  */, __ /* HT  */, __ /* LF  */, __ /* VT  */, __ /* FF  */, __ /* CR  */, __ /* SO  */, __ /* SI  */,
            __ /* DLE */, __ /* DC1 */, __ /* DC2 */, __ /* DC3 */, __ /* DC4 */, __ /* NAK */, __ /* SYN */, __ /* ETB */, __ /* CAN */, __ /* EM  */, __ /* SUB */, __ /* ESC */, __ /* FS  */, __ /* GS  */, __ /* RS  */, __ /* US  */,
            __ /* SP  */, __ /* !   */, FP /* ""   */, __ /* #   */, __ /* $   */, __ /* %   */, __ /* &   */, __ /* '   */, __ /...",5,inc\til\string.hpp,til.details,33,details,5
457716,NAMESPACE_BLOCK,<empty>,,inc\til\throttled_func.hpp,inc\til\throttled_func.hpp:<global>,,<global>,1
457720,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        template<typename... Args>
        class throttled_func_storage
        {
        public:
            template<typename... MakeArgs>
            bool emplace(MakeArgs&&... args)
            {
                std::unique_lock guard{ _lock };
                const bool hadValue = _pendingRunArgs.has_value();
                _pendingRunArgs.emplace(std::forward<MakeArgs>(args)...);
                return hadValue;
            }

            template<typename F>
            void modify_pending(F f)
            {
                std::unique_lock guard{ _lock };
                if (_pendingRunArgs)
                {
                    std::apply(f, *_pendingRunArgs);
                }
            }

            std::tuple<Args...> take()
            {
                std::unique_lock guard{ _lock };
                auto pendingRunArgs = std::move(*_pendingRunArgs);
                _pendingRunArgs.reset();
                return pendingR...",1,inc\til\throttled_func.hpp,til,6,til,1
457721,NAMESPACE_BLOCK,"namespace details
    {
        template<typename... Args>
        class throttled_func_storage
        {
        public:
            template<typename... MakeArgs>
            bool emplace(MakeArgs&&... args)
            {
                std::unique_lock guard{ _lock };
                const bool hadValue = _pendingRunArgs.has_value();
                _pendingRunArgs.emplace(std::forward<MakeArgs>(args)...);
                return hadValue;
            }

            template<typename F>
            void modify_pending(F f)
            {
                std::unique_lock guard{ _lock };
                if (_pendingRunArgs)
                {
                    std::apply(f, *_pendingRunArgs);
                }
            }

            std::tuple<Args...> take()
            {
                std::unique_lock guard{ _lock };
                auto pendingRunArgs = std::move(*_pendingRunArgs);
                _pendingRunArgs.reset();
                return pendingRunArgs;
            ...",5,inc\til\throttled_func.hpp,til.details,8,details,1
458007,NAMESPACE_BLOCK,<empty>,,inc\til\ticket_lock.hpp,inc\til\ticket_lock.hpp:<global>,,<global>,1
458011,NAMESPACE_BLOCK,"namespace til
{
    // ticket_lock implements a classic fair lock.
    //
    // Compared to a SRWLOCK this implementation is significantly more unsafe to use:
    // Forgetting to call unlock or calling unlock more than once, will lead to deadlocks,
    // as _now_serving will remain out of sync with _next_ticket and prevent any further lockings.
    //
    // I recommend to use the following with this class:
    // * A low number of concurrent accesses (this lock doesn't scale well beyond 2 threads)
    // * alignas(std::hardware_destructive_interference_size) to prevent false sharing
    // * std::unique_lock or std::scoped_lock to prevent unbalanced lock/unlock calls
    struct ticket_lock
    {
        void lock() noexcept
        {
            const auto ticket = _next_ticket.fetch_add(1, std::memory_order_relaxed);

            for (;;)
            {
                const auto current = _now_serving.load(std::memory_order_acquire);
                if (current == ticket)
     ...",1,inc\til\ticket_lock.hpp,til,8,til,1
458314,NAMESPACE_BLOCK,<empty>,,inc\til\type_traits.hpp,inc\til\type_traits.hpp:<global>,,<global>,1
458318,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        template<typename T>
        struct is_contiguous_view : std::false_type
        {
        };
        template<typename U, std::size_t E>
        struct is_contiguous_view<std::span<U, E>> : std::true_type
        {
        };
        template<typename U, typename V>
        struct is_contiguous_view<std::basic_string_view<U, V>> : std::true_type
        {
        };

        template<typename T>
        struct is_byte : std::false_type
        {
        };
        template<>
        struct is_byte<char> : std::true_type
        {
        };
        template<>
        struct is_byte<std::byte> : std::true_type
        {
        };
    }

    template<typename T>
    concept Byte = details::is_byte<std::remove_cv_t<T>>::value;

    template<typename T>
    concept ContiguousView = details::is_contiguous_view<std::remove_cv_t<T>>::value;

    template<typename T>
    concept ContiguousBytes = ContiguousView<T> && Byte<typename T::val...",1,inc\til\type_traits.hpp,til,6,til,1
458319,NAMESPACE_BLOCK,"namespace details
    {
        template<typename T>
        struct is_contiguous_view : std::false_type
        {
        };
        template<typename U, std::size_t E>
        struct is_contiguous_view<std::span<U, E>> : std::true_type
        {
        };
        template<typename U, typename V>
        struct is_contiguous_view<std::basic_string_view<U, V>> : std::true_type
        {
        };

        template<typename T>
        struct is_byte : std::false_type
        {
        };
        template<>
        struct is_byte<char> : std::true_type
        {
        };
        template<>
        struct is_byte<std::byte> : std::true_type
        {
        };
    }",5,inc\til\type_traits.hpp,til.details,8,details,1
458358,NAMESPACE_BLOCK,<empty>,,inc\til\u8u16convert.hpp,inc\til\u8u16convert.hpp:<global>,,<global>,1
458362,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    // state structure for maintenance of UTF-8 partials
    struct u8state
    {
        char partials[4];
        uint8_t have{};
        uint8_t want{};

        constexpr void reset() noexcept
        {
            *this = {};
        }
    };

    // state structure for maintenance of UTF-16 partials
    struct u16state
    {
        wchar_t partials[2]{};

        constexpr void reset() noexcept
        {
            *this = {};
        }
    };

    // Routine Description:
    // - Takes a UTF-8 string and performs the conversion to UTF-16. NOTE: The function relies on getting complete UTF-8 characters at the string boundaries.
    // Arguments:
    // - in - UTF-8 string to be converted
    // - out - reference to the resulting UTF-16 string
    // Return Value:
    // - S_OK          - the conversion succeeded
    // - E_OUTOFMEMORY - the function failed to allocate memory for the resulting string
 ...",1,inc\til\u8u16convert.hpp,til,24,til,1
458497,NAMESPACE_BLOCK,<empty>,,inc\til\unicode.hpp,inc\til\unicode.hpp:<global>,,<global>,1
458501,NAMESPACE_BLOCK,"namespace til
{
    namespace details
    {
        inline constexpr wchar_t UNICODE_REPLACEMENT = 0xFFFD;
    }

    static constexpr bool is_surrogate(const wchar_t wch) noexcept
    {
        return (wch & 0xF800) == 0xD800;
    }

    static constexpr bool is_leading_surrogate(const wchar_t wch) noexcept
    {
        return (wch & 0xFC00) == 0xD800;
    }

    static constexpr bool is_trailing_surrogate(const wchar_t wch) noexcept
    {
        return (wch & 0xFC00) == 0xDC00;
    }

    // Verifies the beginning of the given UTF16 string and returns the first UTF16 sequence
    // or U+FFFD otherwise. It's not really useful and at the time of writing only a
    // single caller uses this. It's best to delete this if you read this comment.
    constexpr std::wstring_view utf16_next(std::wstring_view wstr) noexcept
    {
        auto it = wstr.begin();
        const auto end = wstr.end();
        auto ptr = &details::UNICODE_REPLACEMENT;
        size_t len = 1;

        if (it !...",1,inc\til\unicode.hpp,til,6,til,1
458502,NAMESPACE_BLOCK,"namespace details
    {
        inline constexpr wchar_t UNICODE_REPLACEMENT = 0xFFFD;
    }",5,inc\til\unicode.hpp,til.details,8,details,1
458862,NAMESPACE_BLOCK,<empty>,,inc\til\winrt.hpp,inc\til\winrt.hpp:<global>,,<global>,1
458866,NAMESPACE_BLOCK,"namespace til // Terminal Implementation Library. Also: ""Today I Learned""
{
    template<typename T>
    struct property
    {
        explicit constexpr property(auto&&... args) :
            _value{ std::forward<decltype(args)>(args)... } {}

        property& operator=(const property& other) = default;

        T operator()() const noexcept
        {
            return _value;
        }
        void operator()(auto&& arg)
        {
            _value = std::forward<decltype(arg)>(arg);
        }
        explicit operator bool() const noexcept
        {
#ifdef WINRT_Windows_Foundation_H
            if constexpr (std::is_same_v<T, winrt::hstring>)
            {
                return !_value.empty();
            }
            else
#endif
            {
                return _value;
            }
        }
        bool operator==(const property& other) const noexcept
        {
            return _value == other._value;
        }
        bool operator!=(const property& other) const n...",1,inc\til\winrt.hpp,til,6,til,1
458945,NAMESPACE_BLOCK,<empty>,,inc\unicode.hpp,inc\unicode.hpp:<global>,,<global>,1
459054,NAMESPACE_BLOCK,<empty>,,inc\winrtTaefTemplates.hpp,inc\winrtTaefTemplates.hpp:<global>,,<global>,1
459058,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    template<>
    class VerifyOutputTraits<winrt::hstring>
    {
    public:
        static WEX::Common::NoThrowString ToString(const winrt::hstring& hstr)
        {
            return WEX::Common::NoThrowString().Format(L""%s"", hstr.c_str());
        }
    };
}",1,inc\winrtTaefTemplates.hpp,WEX,39,WEX,1
459059,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    template<>
    class VerifyOutputTraits<winrt::hstring>
    {
    public:
        static WEX::Common::NoThrowString ToString(const winrt::hstring& hstr)
        {
            return WEX::Common::NoThrowString().Format(L""%s"", hstr.c_str());
        }
    };
}",1,inc\winrtTaefTemplates.hpp,WEX.TestExecution,39,TestExecution,1
459088,NAMESPACE_BLOCK,<empty>,,interactivity\base\ApiDetector.cpp,interactivity\base\ApiDetector.cpp:<global>,,<global>,1
459101,NAMESPACE_BLOCK,<empty>,,interactivity\base\ApiDetector.hpp,interactivity\base\ApiDetector.hpp:<global>,,<global>,1
459105,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class ApiLevel
    {
        Win32,
        OneCore
    };

    class ApiDetector final
    {
    public:
        [[nodiscard]] static NTSTATUS DetectNtUserWindow(_Out_ ApiLevel* level);

    private:
        [[nodiscard]] static NTSTATUS DetectApiSupport(_In_ LPCWSTR lpLibrary, _In_ LPCSTR lpApi, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR library, _Outptr_result_nullonfailure_ HMODULE* module);
        [[nodiscard]] static NTSTATUS TryLocateProcedure(_In_ HMODULE hModule, _In_ LPCSTR lpProcedure);
        static void SetLevelAndFreeIfNecessary(_In_ NTSTATUS status, _In_ HMODULE hModule, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                              _In_ DWORD dwLoaderFlags,
                                                              _Outptr_result_nullonfailure_ H...",1,interactivity\base\ApiDetector.hpp,Microsoft,8,Microsoft,1
459106,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class ApiLevel
    {
        Win32,
        OneCore
    };

    class ApiDetector final
    {
    public:
        [[nodiscard]] static NTSTATUS DetectNtUserWindow(_Out_ ApiLevel* level);

    private:
        [[nodiscard]] static NTSTATUS DetectApiSupport(_In_ LPCWSTR lpLibrary, _In_ LPCSTR lpApi, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR library, _Outptr_result_nullonfailure_ HMODULE* module);
        [[nodiscard]] static NTSTATUS TryLocateProcedure(_In_ HMODULE hModule, _In_ LPCSTR lpProcedure);
        static void SetLevelAndFreeIfNecessary(_In_ NTSTATUS status, _In_ HMODULE hModule, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                              _In_ DWORD dwLoaderFlags,
                                                              _Outptr_result_nullonfailure_ H...",1,interactivity\base\ApiDetector.hpp,Microsoft.Console,8,Console,1
459107,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class ApiLevel
    {
        Win32,
        OneCore
    };

    class ApiDetector final
    {
    public:
        [[nodiscard]] static NTSTATUS DetectNtUserWindow(_Out_ ApiLevel* level);

    private:
        [[nodiscard]] static NTSTATUS DetectApiSupport(_In_ LPCWSTR lpLibrary, _In_ LPCSTR lpApi, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR library, _Outptr_result_nullonfailure_ HMODULE* module);
        [[nodiscard]] static NTSTATUS TryLocateProcedure(_In_ HMODULE hModule, _In_ LPCSTR lpProcedure);
        static void SetLevelAndFreeIfNecessary(_In_ NTSTATUS status, _In_ HMODULE hModule, _Out_ ApiLevel* level);
        [[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                              _In_ DWORD dwLoaderFlags,
                                                              _Outptr_result_nullonfailure_ H...",1,interactivity\base\ApiDetector.hpp,Microsoft.Console.Interactivity,8,Interactivity,1
459123,NAMESPACE_BLOCK,<empty>,,interactivity\base\EventSynthesis.cpp,interactivity\base\EventSynthesis.cpp:<global>,,<global>,1
459630,NAMESPACE_BLOCK,<empty>,,interactivity\base\HostSignalInputThread.cpp,interactivity\base\HostSignalInputThread.cpp:<global>,,<global>,1
459946,NAMESPACE_BLOCK,<empty>,,interactivity\base\HostSignalInputThread.hpp,interactivity\base\HostSignalInputThread.hpp:<global>,,<global>,1
459950,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class HostSignalInputThread final
    {
    public:
        HostSignalInputThread(wil::unique_hfile&& hPipe);
        ~HostSignalInputThread();

        [[nodiscard]] HRESULT Start() noexcept;
        static DWORD WINAPI StaticThreadProc(LPVOID lpParameter);

        // Prevent copying and assignment.
        HostSignalInputThread(const HostSignalInputThread&) = delete;
        HostSignalInputThread& operator=(const HostSignalInputThread&) = delete;

    private:
        template<typename T>
        T _ReceiveTypedPacket();
        [[nodiscard]] HRESULT _InputThread();

        bool _GetData(std::span<std::byte> buffer);
        bool _AdvanceReader(DWORD byteCount);
        void _Shutdown();

        DWORD _dwThreadId;
        wil::unique_hfile _hFile;
        wil::unique_handle _hThread;
    };
}",1,interactivity\base\HostSignalInputThread.hpp,Microsoft,20,Microsoft,1
459951,NAMESPACE_BLOCK,"namespace Microsoft::Console
{
    class HostSignalInputThread final
    {
    public:
        HostSignalInputThread(wil::unique_hfile&& hPipe);
        ~HostSignalInputThread();

        [[nodiscard]] HRESULT Start() noexcept;
        static DWORD WINAPI StaticThreadProc(LPVOID lpParameter);

        // Prevent copying and assignment.
        HostSignalInputThread(const HostSignalInputThread&) = delete;
        HostSignalInputThread& operator=(const HostSignalInputThread&) = delete;

    private:
        template<typename T>
        T _ReceiveTypedPacket();
        [[nodiscard]] HRESULT _InputThread();

        bool _GetData(std::span<std::byte> buffer);
        bool _AdvanceReader(DWORD byteCount);
        void _Shutdown();

        DWORD _dwThreadId;
        wil::unique_hfile _hFile;
        wil::unique_handle _hThread;
    };
}",1,interactivity\base\HostSignalInputThread.hpp,Microsoft.Console,20,Console,1
460035,NAMESPACE_BLOCK,<empty>,,interactivity\base\InteractivityFactory.cpp,interactivity\base\InteractivityFactory.cpp:<global>,,<global>,1
460228,NAMESPACE_BLOCK,<empty>,,interactivity\base\InteractivityFactory.hpp,interactivity\base\InteractivityFactory.hpp:<global>,,<global>,1
460232,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class InteractivityFactory final : public IInteractivityFactory
    {
    public:
        [[nodiscard]] NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control);
        [[nodiscard]] NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread);

        [[nodiscard]] NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api);
        [[nodiscard]] NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics);
        [[nodiscard]] NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier);
        [[nodiscard]] NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider);

        [[nodiscard]] NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner);

        // Wndproc
        [[nodiscard]] static LRESULT CALLBACK s_PseudoWindowProc(_In_ HWND hwnd,
                      ...",1,interactivity\base\InteractivityFactory.hpp,Microsoft,17,Microsoft,1
460233,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class InteractivityFactory final : public IInteractivityFactory
    {
    public:
        [[nodiscard]] NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control);
        [[nodiscard]] NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread);

        [[nodiscard]] NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api);
        [[nodiscard]] NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics);
        [[nodiscard]] NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier);
        [[nodiscard]] NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider);

        [[nodiscard]] NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner);

        // Wndproc
        [[nodiscard]] static LRESULT CALLBACK s_PseudoWindowProc(_In_ HWND hwnd,
                      ...",1,interactivity\base\InteractivityFactory.hpp,Microsoft.Console,17,Console,1
460234,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class InteractivityFactory final : public IInteractivityFactory
    {
    public:
        [[nodiscard]] NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control);
        [[nodiscard]] NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread);

        [[nodiscard]] NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api);
        [[nodiscard]] NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics);
        [[nodiscard]] NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier);
        [[nodiscard]] NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider);

        [[nodiscard]] NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner);

        // Wndproc
        [[nodiscard]] static LRESULT CALLBACK s_PseudoWindowProc(_In_ HWND hwnd,
                      ...",1,interactivity\base\InteractivityFactory.hpp,Microsoft.Console.Interactivity,17,Interactivity,1
460274,NAMESPACE_BLOCK,<empty>,,interactivity\base\PseudoConsoleWindowAccessibilityProvider.cpp,interactivity\base\PseudoConsoleWindowAccessibilityProvider.cpp:<global>,,<global>,1
460298,NAMESPACE_BLOCK,<empty>,,interactivity\base\PseudoConsoleWindowAccessibilityProvider.hpp,interactivity\base\PseudoConsoleWindowAccessibilityProvider.hpp:<global>,,<global>,1
460302,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class PseudoConsoleWindowAccessibilityProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple>
    {
    public:
        PseudoConsoleWindowAccessibilityProvider() = default;
        ~PseudoConsoleWindowAccessibilityProvider() = default;
        HRESULT RuntimeClassInitialize(HWND pseudoConsoleHwnd) noexcept;

        PseudoConsoleWindowAccessibilityProvider(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider(PseudoConsoleWindowAccessibilityProvider&&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(PseudoConsoleWindowAccessibilityProvider&&) = delete;

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptio...",1,interactivity\base\PseudoConsoleWindowAccessibilityProvider.hpp,Microsoft,8,Microsoft,1
460303,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class PseudoConsoleWindowAccessibilityProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple>
    {
    public:
        PseudoConsoleWindowAccessibilityProvider() = default;
        ~PseudoConsoleWindowAccessibilityProvider() = default;
        HRESULT RuntimeClassInitialize(HWND pseudoConsoleHwnd) noexcept;

        PseudoConsoleWindowAccessibilityProvider(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider(PseudoConsoleWindowAccessibilityProvider&&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(PseudoConsoleWindowAccessibilityProvider&&) = delete;

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptio...",1,interactivity\base\PseudoConsoleWindowAccessibilityProvider.hpp,Microsoft.Console,8,Console,1
460304,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class PseudoConsoleWindowAccessibilityProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple>
    {
    public:
        PseudoConsoleWindowAccessibilityProvider() = default;
        ~PseudoConsoleWindowAccessibilityProvider() = default;
        HRESULT RuntimeClassInitialize(HWND pseudoConsoleHwnd) noexcept;

        PseudoConsoleWindowAccessibilityProvider(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider(PseudoConsoleWindowAccessibilityProvider&&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(const PseudoConsoleWindowAccessibilityProvider&) = delete;
        PseudoConsoleWindowAccessibilityProvider& operator=(PseudoConsoleWindowAccessibilityProvider&&) = delete;

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptio...",1,interactivity\base\PseudoConsoleWindowAccessibilityProvider.hpp,Microsoft.Console.Interactivity,8,Interactivity,1
460351,NAMESPACE_BLOCK,<empty>,,interactivity\base\RemoteConsoleControl.cpp,interactivity\base\RemoteConsoleControl.cpp:<global>,,<global>,1
460442,NAMESPACE_BLOCK,<empty>,,interactivity\base\RemoteConsoleControl.hpp,interactivity\base\RemoteConsoleControl.hpp:<global>,,<global>,1
460446,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class RemoteConsoleControl final : public IConsoleControl
    {
    public:
        RemoteConsoleControl(HANDLE signalPipe);

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId);

    private:
        wil::unique_handle _pipe;

        Win32::ConsoleControl _control;
    };
}",1,interactivity\base\RemoteConsoleControl.hpp,Microsoft,19,Microsoft,1
460447,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class RemoteConsoleControl final : public IConsoleControl
    {
    public:
        RemoteConsoleControl(HANDLE signalPipe);

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId);

    private:
        wil::unique_handle _pipe;

        Win32::ConsoleControl _control;
    };
}",1,interactivity\base\RemoteConsoleControl.hpp,Microsoft.Console,19,Console,1
460448,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class RemoteConsoleControl final : public IConsoleControl
    {
    public:
        RemoteConsoleControl(HANDLE signalPipe);

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId);

    private:
        wil::unique_handle _pipe;

        Win32::ConsoleControl _control;
    };
}",1,interactivity\base\RemoteConsoleControl.hpp,Microsoft.Console.Interactivity,19,Interactivity,1
460478,NAMESPACE_BLOCK,<empty>,,interactivity\base\ServiceLocator.cpp,interactivity\base\ServiceLocator.cpp:<global>,,<global>,1
460931,NAMESPACE_BLOCK,<empty>,,interactivity\base\VtApiRedirection.cpp,interactivity\base\VtApiRedirection.cpp:<global>,,<global>,1
460941,NAMESPACE_BLOCK,<empty>,,interactivity\base\precomp.cpp,interactivity\base\precomp.cpp:<global>,,<global>,1
460950,NAMESPACE_BLOCK,<empty>,,interactivity\base\precomp.hpp,interactivity\base\precomp.hpp:<global>,,<global>,1
460955,NAMESPACE_BLOCK,<empty>,,interactivity\inc\EventSynthesis.hpp,interactivity\inc\EventSynthesis.hpp:<global>,,<global>,1
460959,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    void CharToKeyEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
    void SynthesizeKeyboardEvents(wchar_t wch, short keyState, InputEventQueue& out);
    void SynthesizeNumpadEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
}",1,interactivity\inc\EventSynthesis.hpp,Microsoft,18,Microsoft,1
460960,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    void CharToKeyEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
    void SynthesizeKeyboardEvents(wchar_t wch, short keyState, InputEventQueue& out);
    void SynthesizeNumpadEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
}",1,interactivity\inc\EventSynthesis.hpp,Microsoft.Console,18,Console,1
460961,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    void CharToKeyEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
    void SynthesizeKeyboardEvents(wchar_t wch, short keyState, InputEventQueue& out);
    void SynthesizeNumpadEvents(wchar_t wch, unsigned int codepage, InputEventQueue& out);
}",1,interactivity\inc\EventSynthesis.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
460984,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IAccessibilityNotifier.hpp,interactivity\inc\IAccessibilityNotifier.hpp:<global>,,<global>,1
460988,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IAccessibilityNotifier
    {
    public:
        enum class ConsoleCaretEventFlags
        {
            CaretInvisible,
            CaretSelection,
            CaretVisible
        };

        virtual ~IAccessibilityNotifier() = default;

        virtual void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) = 0;
        virtual void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) = 0;
        virtual void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) = 0;
        virtual void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) = 0;
        virtual void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) = 0;
        virtual void NotifyConsoleLayoutEvent() = 0;
        virtual void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) = 0;
        virtual void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) = 0;
    };
}",1,interactivity\inc\IAccessibilityNotifier.hpp,Microsoft,18,Microsoft,1
460989,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IAccessibilityNotifier
    {
    public:
        enum class ConsoleCaretEventFlags
        {
            CaretInvisible,
            CaretSelection,
            CaretVisible
        };

        virtual ~IAccessibilityNotifier() = default;

        virtual void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) = 0;
        virtual void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) = 0;
        virtual void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) = 0;
        virtual void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) = 0;
        virtual void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) = 0;
        virtual void NotifyConsoleLayoutEvent() = 0;
        virtual void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) = 0;
        virtual void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) = 0;
    };
}",1,interactivity\inc\IAccessibilityNotifier.hpp,Microsoft.Console,18,Console,1
460990,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IAccessibilityNotifier
    {
    public:
        enum class ConsoleCaretEventFlags
        {
            CaretInvisible,
            CaretSelection,
            CaretVisible
        };

        virtual ~IAccessibilityNotifier() = default;

        virtual void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) = 0;
        virtual void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) = 0;
        virtual void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) = 0;
        virtual void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) = 0;
        virtual void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) = 0;
        virtual void NotifyConsoleLayoutEvent() = 0;
        virtual void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) = 0;
        virtual void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) = 0;
    };
}",1,interactivity\inc\IAccessibilityNotifier.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
461012,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IConsoleControl.hpp,interactivity\inc\IConsoleControl.hpp:<global>,,<global>,1
461016,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleControl
    {
    public:
        virtual ~IConsoleControl() = default;
        [[nodiscard]] virtual NTSTATUS NotifyConsoleApplication(DWORD dwProcessId) = 0;
        [[nodiscard]] virtual NTSTATUS SetForeground(HANDLE hProcess, BOOL fForeground) = 0;
        [[nodiscard]] virtual NTSTATUS EndTask(DWORD dwProcessId, DWORD dwEventType, ULONG ulCtrlFlags) = 0;
        [[nodiscard]] virtual NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) = 0;
    };
}",1,interactivity\inc\IConsoleControl.hpp,Microsoft,18,Microsoft,1
461017,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleControl
    {
    public:
        virtual ~IConsoleControl() = default;
        [[nodiscard]] virtual NTSTATUS NotifyConsoleApplication(DWORD dwProcessId) = 0;
        [[nodiscard]] virtual NTSTATUS SetForeground(HANDLE hProcess, BOOL fForeground) = 0;
        [[nodiscard]] virtual NTSTATUS EndTask(DWORD dwProcessId, DWORD dwEventType, ULONG ulCtrlFlags) = 0;
        [[nodiscard]] virtual NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) = 0;
    };
}",1,interactivity\inc\IConsoleControl.hpp,Microsoft.Console,18,Console,1
461018,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleControl
    {
    public:
        virtual ~IConsoleControl() = default;
        [[nodiscard]] virtual NTSTATUS NotifyConsoleApplication(DWORD dwProcessId) = 0;
        [[nodiscard]] virtual NTSTATUS SetForeground(HANDLE hProcess, BOOL fForeground) = 0;
        [[nodiscard]] virtual NTSTATUS EndTask(DWORD dwProcessId, DWORD dwEventType, ULONG ulCtrlFlags) = 0;
        [[nodiscard]] virtual NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) = 0;
    };
}",1,interactivity\inc\IConsoleControl.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
461050,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IConsoleInputThread.hpp,interactivity\inc\IConsoleInputThread.hpp:<global>,,<global>,1
461054,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleInputThread
    {
    public:
        virtual ~IConsoleInputThread() = default;
        virtual HANDLE Start() = 0;

        HANDLE GetHandle() noexcept { return _hThread; }
        DWORD GetThreadId() noexcept { return _dwThreadId; }

    protected:
        // Prevent accidental copies.
        IConsoleInputThread(const IConsoleInputThread&) = delete;
        IConsoleInputThread& operator=(const IConsoleInputThread&) = delete;

        // .ctor
        IConsoleInputThread() noexcept :
            _hThread(nullptr),
            _dwThreadId(gsl::narrow_cast<DWORD>(-1)) {}

        // Protected Variables
        HANDLE _hThread;
        DWORD _dwThreadId;
    };
}",1,interactivity\inc\IConsoleInputThread.hpp,Microsoft,18,Microsoft,1
461055,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleInputThread
    {
    public:
        virtual ~IConsoleInputThread() = default;
        virtual HANDLE Start() = 0;

        HANDLE GetHandle() noexcept { return _hThread; }
        DWORD GetThreadId() noexcept { return _dwThreadId; }

    protected:
        // Prevent accidental copies.
        IConsoleInputThread(const IConsoleInputThread&) = delete;
        IConsoleInputThread& operator=(const IConsoleInputThread&) = delete;

        // .ctor
        IConsoleInputThread() noexcept :
            _hThread(nullptr),
            _dwThreadId(gsl::narrow_cast<DWORD>(-1)) {}

        // Protected Variables
        HANDLE _hThread;
        DWORD _dwThreadId;
    };
}",1,interactivity\inc\IConsoleInputThread.hpp,Microsoft.Console,18,Console,1
461056,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IConsoleInputThread
    {
    public:
        virtual ~IConsoleInputThread() = default;
        virtual HANDLE Start() = 0;

        HANDLE GetHandle() noexcept { return _hThread; }
        DWORD GetThreadId() noexcept { return _dwThreadId; }

    protected:
        // Prevent accidental copies.
        IConsoleInputThread(const IConsoleInputThread&) = delete;
        IConsoleInputThread& operator=(const IConsoleInputThread&) = delete;

        // .ctor
        IConsoleInputThread() noexcept :
            _hThread(nullptr),
            _dwThreadId(gsl::narrow_cast<DWORD>(-1)) {}

        // Protected Variables
        HANDLE _hThread;
        DWORD _dwThreadId;
    };
}",1,interactivity\inc\IConsoleInputThread.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
461095,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IConsoleWindow.hpp,interactivity\inc\IConsoleWindow.hpp:<global>,,<global>,1
461100,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow
    {
    public:
        virtual ~IConsoleWindow() = default;

        virtual bool IsInFullscreen() const = 0;

        virtual void SetIsFullscreen(const bool fFullscreenEnabled) = 0;

        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

        virtual void CaptureMouse() = 0;
        virtual BOOL ReleaseMouse() = 0;

        virtual HWND GetWindowHandle() const = 0;

        // Pass null.
        virtual void SetOwner() = 0;

        virtual BOOL GetCursorPosition(_Out_ til::point* lpPoint) = 0;
        virtual BOOL GetClientRectangle(_Out_ til::rect* lpRect) = 0;
        virtual BOOL MapRect(_Inout_ til::rect* lpRect) = 0;
        virtual BOOL ConvertScreenToClient(_Inout_ til::point* lpPoint) = 0;

        virtual BOOL SendNotifyBeep() const = 0;

        virtual BOOL PostUpdateScrollBars() const = 0;

        virtual BOOL PostUpdateWindowSize() const = 0;

        virtual void UpdateWin...",1,interactivity\inc\IConsoleWindow.hpp,Microsoft,21,Microsoft,2
461101,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow
    {
    public:
        virtual ~IConsoleWindow() = default;

        virtual bool IsInFullscreen() const = 0;

        virtual void SetIsFullscreen(const bool fFullscreenEnabled) = 0;

        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

        virtual void CaptureMouse() = 0;
        virtual BOOL ReleaseMouse() = 0;

        virtual HWND GetWindowHandle() const = 0;

        // Pass null.
        virtual void SetOwner() = 0;

        virtual BOOL GetCursorPosition(_Out_ til::point* lpPoint) = 0;
        virtual BOOL GetClientRectangle(_Out_ til::rect* lpRect) = 0;
        virtual BOOL MapRect(_Inout_ til::rect* lpRect) = 0;
        virtual BOOL ConvertScreenToClient(_Inout_ til::point* lpPoint) = 0;

        virtual BOOL SendNotifyBeep() const = 0;

        virtual BOOL PostUpdateScrollBars() const = 0;

        virtual BOOL PostUpdateWindowSize() const = 0;

        virtual void UpdateWin...",1,interactivity\inc\IConsoleWindow.hpp,Microsoft.Console,21,Console,1
461102,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow
    {
    public:
        virtual ~IConsoleWindow() = default;

        virtual bool IsInFullscreen() const = 0;

        virtual void SetIsFullscreen(const bool fFullscreenEnabled) = 0;

        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

        virtual void CaptureMouse() = 0;
        virtual BOOL ReleaseMouse() = 0;

        virtual HWND GetWindowHandle() const = 0;

        // Pass null.
        virtual void SetOwner() = 0;

        virtual BOOL GetCursorPosition(_Out_ til::point* lpPoint) = 0;
        virtual BOOL GetClientRectangle(_Out_ til::rect* lpRect) = 0;
        virtual BOOL MapRect(_Inout_ til::rect* lpRect) = 0;
        virtual BOOL ConvertScreenToClient(_Inout_ til::point* lpPoint) = 0;

        virtual BOOL SendNotifyBeep() const = 0;

        virtual BOOL PostUpdateScrollBars() const = 0;

        virtual BOOL PostUpdateWindowSize() const = 0;

        virtual void UpdateWin...",1,interactivity\inc\IConsoleWindow.hpp,Microsoft.Console.Types,21,Types,1
461185,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IHighDpiApi.hpp,interactivity\inc\IHighDpiApi.hpp:<global>,,<global>,1
461189,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IHighDpiApi
    {
    public:
        virtual BOOL SetProcessDpiAwarenessContext() = 0;
        [[nodiscard]] virtual HRESULT SetProcessPerMonitorDpiAwareness() = 0;

        virtual ~IHighDpiApi() = default;
    };
}",1,interactivity\inc\IHighDpiApi.hpp,Microsoft,17,Microsoft,1
461190,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IHighDpiApi
    {
    public:
        virtual BOOL SetProcessDpiAwarenessContext() = 0;
        [[nodiscard]] virtual HRESULT SetProcessPerMonitorDpiAwareness() = 0;

        virtual ~IHighDpiApi() = default;
    };
}",1,interactivity\inc\IHighDpiApi.hpp,Microsoft.Console,17,Console,1
461191,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IHighDpiApi
    {
    public:
        virtual BOOL SetProcessDpiAwarenessContext() = 0;
        [[nodiscard]] virtual HRESULT SetProcessPerMonitorDpiAwareness() = 0;

        virtual ~IHighDpiApi() = default;
    };
}",1,interactivity\inc\IHighDpiApi.hpp,Microsoft.Console.Interactivity,17,Interactivity,1
461220,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IInteractivityFactory.hpp,interactivity\inc\IInteractivityFactory.hpp:<global>,,<global>,1
461224,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IInteractivityFactory
    {
    public:
        virtual ~IInteractivityFactory() = default;
        [[nodiscard]] virtual NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control) = 0;
        [[nodiscard]] virtual NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread) = 0;

        [[nodiscard]] virtual NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api) = 0;
        [[nodiscard]] virtual NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics) = 0;
        [[nodiscard]] virtual NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier) = 0;
        [[nodiscard]] virtual NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider) = 0;

        [[nodiscard]] virtual NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner) = 0;
    };
}",1,interactivity\inc\IInteractivityFactory.hpp,Microsoft,29,Microsoft,1
461225,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IInteractivityFactory
    {
    public:
        virtual ~IInteractivityFactory() = default;
        [[nodiscard]] virtual NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control) = 0;
        [[nodiscard]] virtual NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread) = 0;

        [[nodiscard]] virtual NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api) = 0;
        [[nodiscard]] virtual NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics) = 0;
        [[nodiscard]] virtual NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier) = 0;
        [[nodiscard]] virtual NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider) = 0;

        [[nodiscard]] virtual NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner) = 0;
    };
}",1,interactivity\inc\IInteractivityFactory.hpp,Microsoft.Console,29,Console,1
461226,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IInteractivityFactory
    {
    public:
        virtual ~IInteractivityFactory() = default;
        [[nodiscard]] virtual NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control) = 0;
        [[nodiscard]] virtual NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread) = 0;

        [[nodiscard]] virtual NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api) = 0;
        [[nodiscard]] virtual NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics) = 0;
        [[nodiscard]] virtual NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier) = 0;
        [[nodiscard]] virtual NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider) = 0;

        [[nodiscard]] virtual NTSTATUS CreatePseudoWindow(HWND& hwnd, const HWND owner) = 0;
    };
}",1,interactivity\inc\IInteractivityFactory.hpp,Microsoft.Console.Interactivity,29,Interactivity,1
461245,NAMESPACE_BLOCK,<empty>,,interactivity\inc\ISystemConfigurationProvider.hpp,interactivity\inc\ISystemConfigurationProvider.hpp:<global>,,<global>,1
461250,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    struct IconInfo
    {
        std::wstring path;
        int index = 0;
    };

    class ISystemConfigurationProvider
    {
    public:
        virtual ~ISystemConfigurationProvider() = default;

        virtual bool IsCaretBlinkingEnabled() = 0;

        virtual UINT GetCaretBlinkTime() = 0;
        virtual int GetNumberOfMouseButtons() = 0;
        virtual ULONG GetCursorWidth() = 0;
        virtual ULONG GetNumberOfWheelScrollLines() = 0;
        virtual ULONG GetNumberOfWheelScrollCharacters() = 0;

        virtual void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                         _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                         _Inout_ PDWORD pdwTitleLength,
                                         _In_ PCWSTR pwszCurrDir,
                                         _In_ PCWSTR pwszAppName,
                                         _Inout_opt_ IconInfo...",1,interactivity\inc\ISystemConfigurationProvider.hpp,Microsoft,20,Microsoft,2
461251,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    struct IconInfo
    {
        std::wstring path;
        int index = 0;
    };

    class ISystemConfigurationProvider
    {
    public:
        virtual ~ISystemConfigurationProvider() = default;

        virtual bool IsCaretBlinkingEnabled() = 0;

        virtual UINT GetCaretBlinkTime() = 0;
        virtual int GetNumberOfMouseButtons() = 0;
        virtual ULONG GetCursorWidth() = 0;
        virtual ULONG GetNumberOfWheelScrollLines() = 0;
        virtual ULONG GetNumberOfWheelScrollCharacters() = 0;

        virtual void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                         _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                         _Inout_ PDWORD pdwTitleLength,
                                         _In_ PCWSTR pwszCurrDir,
                                         _In_ PCWSTR pwszAppName,
                                         _Inout_opt_ IconInfo...",1,interactivity\inc\ISystemConfigurationProvider.hpp,Microsoft.Console,20,Console,1
461252,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    struct IconInfo
    {
        std::wstring path;
        int index = 0;
    };

    class ISystemConfigurationProvider
    {
    public:
        virtual ~ISystemConfigurationProvider() = default;

        virtual bool IsCaretBlinkingEnabled() = 0;

        virtual UINT GetCaretBlinkTime() = 0;
        virtual int GetNumberOfMouseButtons() = 0;
        virtual ULONG GetCursorWidth() = 0;
        virtual ULONG GetNumberOfWheelScrollLines() = 0;
        virtual ULONG GetNumberOfWheelScrollCharacters() = 0;

        virtual void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                         _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                         _Inout_ PDWORD pdwTitleLength,
                                         _In_ PCWSTR pwszCurrDir,
                                         _In_ PCWSTR pwszAppName,
                                         _Inout_opt_ IconInfo...",1,interactivity\inc\ISystemConfigurationProvider.hpp,Microsoft.Console.Interactivity,20,Interactivity,1
461294,NAMESPACE_BLOCK,<empty>,,interactivity\inc\IWindowMetrics.hpp,interactivity\inc\IWindowMetrics.hpp:<global>,,<global>,1
461298,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IWindowMetrics
    {
    public:
        virtual ~IWindowMetrics() = default;
        virtual til::rect GetMinClientRectInPixels() = 0;
        virtual til::rect GetMaxClientRectInPixels() = 0;
    };
}",1,interactivity\inc\IWindowMetrics.hpp,Microsoft,18,Microsoft,1
461299,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IWindowMetrics
    {
    public:
        virtual ~IWindowMetrics() = default;
        virtual til::rect GetMinClientRectInPixels() = 0;
        virtual til::rect GetMaxClientRectInPixels() = 0;
    };
}",1,interactivity\inc\IWindowMetrics.hpp,Microsoft.Console,18,Console,1
461300,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class IWindowMetrics
    {
    public:
        virtual ~IWindowMetrics() = default;
        virtual til::rect GetMinClientRectInPixels() = 0;
        virtual til::rect GetMaxClientRectInPixels() = 0;
    };
}",1,interactivity\inc\IWindowMetrics.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
461315,NAMESPACE_BLOCK,<empty>,,interactivity\inc\Module.hpp,interactivity\inc\Module.hpp:<global>,,<global>,1
461319,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class Module
    {
        AccessibilityNotifier,
        ConsoleControl,
        ConsoleInputThread,
        ConsoleWindowMetrics,
        HighDpiApi,
        SystemConfigurationProvider
    };
}",1,interactivity\inc\Module.hpp,Microsoft,18,Microsoft,1
461320,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class Module
    {
        AccessibilityNotifier,
        ConsoleControl,
        ConsoleInputThread,
        ConsoleWindowMetrics,
        HighDpiApi,
        SystemConfigurationProvider
    };
}",1,interactivity\inc\Module.hpp,Microsoft.Console,18,Console,1
461321,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    enum class Module
    {
        AccessibilityNotifier,
        ConsoleControl,
        ConsoleInputThread,
        ConsoleWindowMetrics,
        HighDpiApi,
        SystemConfigurationProvider
    };
}",1,interactivity\inc\Module.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
461338,NAMESPACE_BLOCK,<empty>,,interactivity\inc\ServiceLocator.hpp,interactivity\inc\ServiceLocator.hpp:<global>,,<global>,1
461342,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class ServiceLocator final
    {
    public:
        static void SetOneCoreTeardownFunction(void (*pfn)()) noexcept;

        [[noreturn]] static void RundownAndExit(const HRESULT hr);

        // N.B.: Location methods without corresponding creation methods
        //       automatically create the singleton object on demand.
        //       In case the on-demand creation fails, the return value
        //       is nullptr and a message is logged.

        [[nodiscard]] static HRESULT CreateAccessibilityNotifier();
        static IAccessibilityNotifier* LocateAccessibilityNotifier();

        [[nodiscard]] static NTSTATUS SetConsoleControlInstance(_In_ std::unique_ptr<IConsoleControl>&& control);
        static IConsoleControl* LocateConsoleControl();
        template<typename T>
        static T* LocateConsoleControl()
        {
            return static_cast<T*>(LocateConsoleControl());
        }

        [[nodiscard]] static NTS...",1,interactivity\inc\ServiceLocator.hpp,Microsoft,28,Microsoft,1
461343,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class ServiceLocator final
    {
    public:
        static void SetOneCoreTeardownFunction(void (*pfn)()) noexcept;

        [[noreturn]] static void RundownAndExit(const HRESULT hr);

        // N.B.: Location methods without corresponding creation methods
        //       automatically create the singleton object on demand.
        //       In case the on-demand creation fails, the return value
        //       is nullptr and a message is logged.

        [[nodiscard]] static HRESULT CreateAccessibilityNotifier();
        static IAccessibilityNotifier* LocateAccessibilityNotifier();

        [[nodiscard]] static NTSTATUS SetConsoleControlInstance(_In_ std::unique_ptr<IConsoleControl>&& control);
        static IConsoleControl* LocateConsoleControl();
        template<typename T>
        static T* LocateConsoleControl()
        {
            return static_cast<T*>(LocateConsoleControl());
        }

        [[nodiscard]] static NTS...",1,interactivity\inc\ServiceLocator.hpp,Microsoft.Console,28,Console,1
461344,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity
{
    class ServiceLocator final
    {
    public:
        static void SetOneCoreTeardownFunction(void (*pfn)()) noexcept;

        [[noreturn]] static void RundownAndExit(const HRESULT hr);

        // N.B.: Location methods without corresponding creation methods
        //       automatically create the singleton object on demand.
        //       In case the on-demand creation fails, the return value
        //       is nullptr and a message is logged.

        [[nodiscard]] static HRESULT CreateAccessibilityNotifier();
        static IAccessibilityNotifier* LocateAccessibilityNotifier();

        [[nodiscard]] static NTSTATUS SetConsoleControlInstance(_In_ std::unique_ptr<IConsoleControl>&& control);
        static IConsoleControl* LocateConsoleControl();
        template<typename T>
        static T* LocateConsoleControl()
        {
            return static_cast<T*>(LocateConsoleControl());
        }

        [[nodiscard]] static NTS...",1,interactivity\inc\ServiceLocator.hpp,Microsoft.Console.Interactivity,28,Interactivity,1
461473,NAMESPACE_BLOCK,<empty>,,interactivity\inc\VtApiRedirection.hpp,interactivity\inc\VtApiRedirection.hpp:<global>,,<global>,1
461485,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\AccessibilityNotifier.cpp,interactivity\onecore\AccessibilityNotifier.cpp:<global>,,<global>,1
461531,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\AccessibilityNotifier.hpp,interactivity\onecore\AccessibilityNotifier.hpp:<global>,,<global>,1
461535,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class AccessibilityNotifier : public IAccessibilityNotifier
    {
    public:
        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) noexcept override;
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) noexcept override;
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) noexcept override;
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) noexcept override;
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) noexcept override;
        void NotifyConsoleLayoutEvent() noexcept override;
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) noexcept override;
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) noexcept override;
    };
}",1,interactivity\onecore\AccessibilityNotifier.hpp,Microsoft,21,Microsoft,1
461536,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class AccessibilityNotifier : public IAccessibilityNotifier
    {
    public:
        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) noexcept override;
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) noexcept override;
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) noexcept override;
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) noexcept override;
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) noexcept override;
        void NotifyConsoleLayoutEvent() noexcept override;
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) noexcept override;
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) noexcept override;
    };
}",1,interactivity\onecore\AccessibilityNotifier.hpp,Microsoft.Console,21,Console,1
461537,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class AccessibilityNotifier : public IAccessibilityNotifier
    {
    public:
        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) noexcept override;
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) noexcept override;
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) noexcept override;
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) noexcept override;
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) noexcept override;
        void NotifyConsoleLayoutEvent() noexcept override;
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) noexcept override;
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) noexcept override;
    };
}",1,interactivity\onecore\AccessibilityNotifier.hpp,Microsoft.Console.Interactivity,21,Interactivity,1
461538,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class AccessibilityNotifier : public IAccessibilityNotifier
    {
    public:
        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) noexcept override;
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) noexcept override;
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) noexcept override;
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) noexcept override;
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) noexcept override;
        void NotifyConsoleLayoutEvent() noexcept override;
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) noexcept override;
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) noexcept override;
    };
}",1,interactivity\onecore\AccessibilityNotifier.hpp,Microsoft.Console.Interactivity.OneCore,21,OneCore,1
461560,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\BgfxEngine.cpp,interactivity\onecore\BgfxEngine.cpp:<global>,,<global>,1
461842,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\BgfxEngine.hpp,interactivity\onecore\BgfxEngine.hpp:<global>,,<global>,1
461846,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BgfxEngine final : public RenderEngineBase
    {
    public:
        BgfxEngine(PVOID SharedViewBase, LONG DisplayHeight, LONG DisplayWidth, LONG FontWidth, LONG FontHeight) noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodi...",1,interactivity\onecore\BgfxEngine.hpp,Microsoft,27,Microsoft,1
461847,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BgfxEngine final : public RenderEngineBase
    {
    public:
        BgfxEngine(PVOID SharedViewBase, LONG DisplayHeight, LONG DisplayWidth, LONG FontWidth, LONG FontHeight) noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodi...",1,interactivity\onecore\BgfxEngine.hpp,Microsoft.Console,27,Console,1
461848,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BgfxEngine final : public RenderEngineBase
    {
    public:
        BgfxEngine(PVOID SharedViewBase, LONG DisplayHeight, LONG DisplayWidth, LONG FontWidth, LONG FontHeight) noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodi...",1,interactivity\onecore\BgfxEngine.hpp,Microsoft.Console.Render,27,Render,1
462028,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConIoSrvComm.cpp,interactivity\onecore\ConIoSrvComm.cpp:<global>,,<global>,1
463092,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConIoSrvComm.hpp,interactivity\onecore\ConIoSrvComm.hpp:<global>,,<global>,1
463096,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConIoSrvComm final
    {
    public:
        ConIoSrvComm() noexcept;
        ~ConIoSrvComm();

        static ConIoSrvComm* GetConIoSrvComm();

        [[nodiscard]] NTSTATUS Connect();
        VOID ServiceInputPipe();

        [[nodiscard]] NTSTATUS RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const;
        [[nodiscard]] NTSTATUS RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const;
        [[nodiscard]] NTSTATUS RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const;
        [[nodiscard]] NTSTATUS RequestUpdateDisplay(_In_ til::CoordType RowIndex) const;

        [[nodiscard]] NTSTATUS RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue);
        [[nodiscard]] NTSTATUS RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue);
        [[nodiscard]] NTSTATUS RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* ...",1,interactivity\onecore\ConIoSrvComm.hpp,Microsoft,26,Microsoft,1
463097,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConIoSrvComm final
    {
    public:
        ConIoSrvComm() noexcept;
        ~ConIoSrvComm();

        static ConIoSrvComm* GetConIoSrvComm();

        [[nodiscard]] NTSTATUS Connect();
        VOID ServiceInputPipe();

        [[nodiscard]] NTSTATUS RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const;
        [[nodiscard]] NTSTATUS RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const;
        [[nodiscard]] NTSTATUS RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const;
        [[nodiscard]] NTSTATUS RequestUpdateDisplay(_In_ til::CoordType RowIndex) const;

        [[nodiscard]] NTSTATUS RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue);
        [[nodiscard]] NTSTATUS RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue);
        [[nodiscard]] NTSTATUS RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* ...",1,interactivity\onecore\ConIoSrvComm.hpp,Microsoft.Console,26,Console,1
463098,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConIoSrvComm final
    {
    public:
        ConIoSrvComm() noexcept;
        ~ConIoSrvComm();

        static ConIoSrvComm* GetConIoSrvComm();

        [[nodiscard]] NTSTATUS Connect();
        VOID ServiceInputPipe();

        [[nodiscard]] NTSTATUS RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const;
        [[nodiscard]] NTSTATUS RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const;
        [[nodiscard]] NTSTATUS RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const;
        [[nodiscard]] NTSTATUS RequestUpdateDisplay(_In_ til::CoordType RowIndex) const;

        [[nodiscard]] NTSTATUS RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue);
        [[nodiscard]] NTSTATUS RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue);
        [[nodiscard]] NTSTATUS RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* ...",1,interactivity\onecore\ConIoSrvComm.hpp,Microsoft.Console.Interactivity,26,Interactivity,1
463099,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConIoSrvComm final
    {
    public:
        ConIoSrvComm() noexcept;
        ~ConIoSrvComm();

        static ConIoSrvComm* GetConIoSrvComm();

        [[nodiscard]] NTSTATUS Connect();
        VOID ServiceInputPipe();

        [[nodiscard]] NTSTATUS RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const;
        [[nodiscard]] NTSTATUS RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const;
        [[nodiscard]] NTSTATUS RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const;
        [[nodiscard]] NTSTATUS RequestUpdateDisplay(_In_ til::CoordType RowIndex) const;

        [[nodiscard]] NTSTATUS RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue);
        [[nodiscard]] NTSTATUS RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue);
        [[nodiscard]] NTSTATUS RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* ...",1,interactivity\onecore\ConIoSrvComm.hpp,Microsoft.Console.Interactivity.OneCore,26,OneCore,1
463208,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleControl.cpp,interactivity\onecore\ConsoleControl.cpp:<global>,,<global>,1
463240,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleControl.hpp,interactivity\onecore\ConsoleControl.hpp:<global>,,<global>,1
463244,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleControl : public IConsoleControl
    {
    public:
        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId) noexcept override;
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground) noexcept override;
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags) override;
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;
    };
}",1,interactivity\onecore\ConsoleControl.hpp,Microsoft,21,Microsoft,1
463245,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleControl : public IConsoleControl
    {
    public:
        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId) noexcept override;
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground) noexcept override;
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags) override;
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;
    };
}",1,interactivity\onecore\ConsoleControl.hpp,Microsoft.Console,21,Console,1
463246,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleControl : public IConsoleControl
    {
    public:
        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId) noexcept override;
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground) noexcept override;
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags) override;
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;
    };
}",1,interactivity\onecore\ConsoleControl.hpp,Microsoft.Console.Interactivity,21,Interactivity,1
463247,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleControl : public IConsoleControl
    {
    public:
        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId) noexcept override;
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground) noexcept override;
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags) override;
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;
    };
}",1,interactivity\onecore\ConsoleControl.hpp,Microsoft.Console.Interactivity.OneCore,21,OneCore,1
463274,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleInputThread.cpp,interactivity\onecore\ConsoleInputThread.cpp:<global>,,<global>,1
463474,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleInputThread.hpp,interactivity\onecore\ConsoleInputThread.hpp:<global>,,<global>,1
463478,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleInputThread : public IConsoleInputThread
    {
    public:
        HANDLE Start() noexcept override;
    };
}",1,interactivity\onecore\ConsoleInputThread.hpp,Microsoft,22,Microsoft,1
463479,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleInputThread : public IConsoleInputThread
    {
    public:
        HANDLE Start() noexcept override;
    };
}",1,interactivity\onecore\ConsoleInputThread.hpp,Microsoft.Console,22,Console,1
463480,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleInputThread : public IConsoleInputThread
    {
    public:
        HANDLE Start() noexcept override;
    };
}",1,interactivity\onecore\ConsoleInputThread.hpp,Microsoft.Console.Interactivity,22,Interactivity,1
463481,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleInputThread : public IConsoleInputThread
    {
    public:
        HANDLE Start() noexcept override;
    };
}",1,interactivity\onecore\ConsoleInputThread.hpp,Microsoft.Console.Interactivity.OneCore,22,OneCore,1
463496,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleWindow.cpp,interactivity\onecore\ConsoleWindow.cpp:<global>,,<global>,1
463699,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\ConsoleWindow.hpp,interactivity\onecore\ConsoleWindow.hpp:<global>,,<global>,1
463703,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleWindow : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        // Inherited via IConsoleWindow
        bool IsInFullscreen() const noexcept override;
        void SetIsFullscreen(const bool fFullscreenEnabled) noexcept override;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

        void CaptureMouse() noexcept override;
        BOOL ReleaseMouse() noexcept override;

        HWND GetWindowHandle() const noexcept override;

        void SetOwner() noexcept override;

        BOOL GetCursorPosition(til::point* lpPoint) noexcept override;
        BOOL GetClientRectangle(til::rect* lpRect) noexcept override;
        BOOL MapRect(_Inout_ til::rect* lpRect) noexcept override;
        BOOL ConvertScreenToClient(til::point* lpPoint) noexcept override;

        BOOL SendNotifyBeep() const noexcept override;

        BOOL PostUpdateScrollBars() const noexcept override;
 ...",1,interactivity\onecore\ConsoleWindow.hpp,Microsoft,21,Microsoft,1
463704,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleWindow : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        // Inherited via IConsoleWindow
        bool IsInFullscreen() const noexcept override;
        void SetIsFullscreen(const bool fFullscreenEnabled) noexcept override;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

        void CaptureMouse() noexcept override;
        BOOL ReleaseMouse() noexcept override;

        HWND GetWindowHandle() const noexcept override;

        void SetOwner() noexcept override;

        BOOL GetCursorPosition(til::point* lpPoint) noexcept override;
        BOOL GetClientRectangle(til::rect* lpRect) noexcept override;
        BOOL MapRect(_Inout_ til::rect* lpRect) noexcept override;
        BOOL ConvertScreenToClient(til::point* lpPoint) noexcept override;

        BOOL SendNotifyBeep() const noexcept override;

        BOOL PostUpdateScrollBars() const noexcept override;
 ...",1,interactivity\onecore\ConsoleWindow.hpp,Microsoft.Console,21,Console,1
463705,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleWindow : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        // Inherited via IConsoleWindow
        bool IsInFullscreen() const noexcept override;
        void SetIsFullscreen(const bool fFullscreenEnabled) noexcept override;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

        void CaptureMouse() noexcept override;
        BOOL ReleaseMouse() noexcept override;

        HWND GetWindowHandle() const noexcept override;

        void SetOwner() noexcept override;

        BOOL GetCursorPosition(til::point* lpPoint) noexcept override;
        BOOL GetClientRectangle(til::rect* lpRect) noexcept override;
        BOOL MapRect(_Inout_ til::rect* lpRect) noexcept override;
        BOOL ConvertScreenToClient(til::point* lpPoint) noexcept override;

        BOOL SendNotifyBeep() const noexcept override;

        BOOL PostUpdateScrollBars() const noexcept override;
 ...",1,interactivity\onecore\ConsoleWindow.hpp,Microsoft.Console.Interactivity,21,Interactivity,1
463706,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class ConsoleWindow : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        // Inherited via IConsoleWindow
        bool IsInFullscreen() const noexcept override;
        void SetIsFullscreen(const bool fFullscreenEnabled) noexcept override;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

        void CaptureMouse() noexcept override;
        BOOL ReleaseMouse() noexcept override;

        HWND GetWindowHandle() const noexcept override;

        void SetOwner() noexcept override;

        BOOL GetCursorPosition(til::point* lpPoint) noexcept override;
        BOOL GetClientRectangle(til::rect* lpRect) noexcept override;
        BOOL MapRect(_Inout_ til::rect* lpRect) noexcept override;
        BOOL ConvertScreenToClient(til::point* lpPoint) noexcept override;

        BOOL SendNotifyBeep() const noexcept override;

        BOOL PostUpdateScrollBars() const noexcept override;
 ...",1,interactivity\onecore\ConsoleWindow.hpp,Microsoft.Console.Interactivity.OneCore,21,OneCore,1
463801,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\SystemConfigurationProvider.cpp,interactivity\onecore\SystemConfigurationProvider.cpp:<global>,,<global>,1
463853,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\SystemConfigurationProvider.hpp,interactivity\onecore\SystemConfigurationProvider.hpp:<global>,,<global>,1
463858,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class SystemConfigurationProvider : public ISystemConfigurationProvider
    {
    public:
        bool IsCaretBlinkingEnabled() noexcept override;

        UINT GetCaretBlinkTime() noexcept override;
        int GetNumberOfMouseButtons() noexcept override;
        ULONG GetCursorWidth() noexcept override;
        ULONG GetNumberOfWheelScrollLines() noexcept override;
        ULONG GetNumberOfWheelScrollCharacters() noexcept override;

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo) override;

    private:
        static constexpr UINT s_DefaultCaretBlinkTime = 530; // millisecon...",1,interactivity\onecore\SystemConfigurationProvider.hpp,Microsoft,23,Microsoft,2
463859,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class SystemConfigurationProvider : public ISystemConfigurationProvider
    {
    public:
        bool IsCaretBlinkingEnabled() noexcept override;

        UINT GetCaretBlinkTime() noexcept override;
        int GetNumberOfMouseButtons() noexcept override;
        ULONG GetCursorWidth() noexcept override;
        ULONG GetNumberOfWheelScrollLines() noexcept override;
        ULONG GetNumberOfWheelScrollCharacters() noexcept override;

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo) override;

    private:
        static constexpr UINT s_DefaultCaretBlinkTime = 530; // millisecon...",1,interactivity\onecore\SystemConfigurationProvider.hpp,Microsoft.Console,23,Console,1
463860,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class SystemConfigurationProvider : public ISystemConfigurationProvider
    {
    public:
        bool IsCaretBlinkingEnabled() noexcept override;

        UINT GetCaretBlinkTime() noexcept override;
        int GetNumberOfMouseButtons() noexcept override;
        ULONG GetCursorWidth() noexcept override;
        ULONG GetNumberOfWheelScrollLines() noexcept override;
        ULONG GetNumberOfWheelScrollCharacters() noexcept override;

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo) override;

    private:
        static constexpr UINT s_DefaultCaretBlinkTime = 530; // millisecon...",1,interactivity\onecore\SystemConfigurationProvider.hpp,Microsoft.Console.Interactivity,23,Interactivity,1
463861,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class SystemConfigurationProvider : public ISystemConfigurationProvider
    {
    public:
        bool IsCaretBlinkingEnabled() noexcept override;

        UINT GetCaretBlinkTime() noexcept override;
        int GetNumberOfMouseButtons() noexcept override;
        ULONG GetCursorWidth() noexcept override;
        ULONG GetNumberOfWheelScrollLines() noexcept override;
        ULONG GetNumberOfWheelScrollCharacters() noexcept override;

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo) override;

    private:
        static constexpr UINT s_DefaultCaretBlinkTime = 530; // millisecon...",1,interactivity\onecore\SystemConfigurationProvider.hpp,Microsoft.Console.Interactivity.OneCore,23,OneCore,1
463928,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\WindowMetrics.cpp,interactivity\onecore\WindowMetrics.cpp:<global>,,<global>,1
464138,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\WindowMetrics.hpp,interactivity\onecore\WindowMetrics.hpp:<global>,,<global>,1
464142,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class WindowMetrics : public IWindowMetrics
    {
    public:
        til::rect GetMinClientRectInPixels() override;
        til::rect GetMaxClientRectInPixels() override;
    };
}",1,interactivity\onecore\WindowMetrics.hpp,Microsoft,21,Microsoft,1
464143,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class WindowMetrics : public IWindowMetrics
    {
    public:
        til::rect GetMinClientRectInPixels() override;
        til::rect GetMaxClientRectInPixels() override;
    };
}",1,interactivity\onecore\WindowMetrics.hpp,Microsoft.Console,21,Console,1
464144,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class WindowMetrics : public IWindowMetrics
    {
    public:
        til::rect GetMinClientRectInPixels() override;
        til::rect GetMaxClientRectInPixels() override;
    };
}",1,interactivity\onecore\WindowMetrics.hpp,Microsoft.Console.Interactivity,21,Interactivity,1
464145,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::OneCore
{
    class WindowMetrics : public IWindowMetrics
    {
    public:
        til::rect GetMinClientRectInPixels() override;
        til::rect GetMaxClientRectInPixels() override;
    };
}",1,interactivity\onecore\WindowMetrics.hpp,Microsoft.Console.Interactivity.OneCore,21,OneCore,1
464158,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\precomp.cpp,interactivity\onecore\precomp.cpp:<global>,,<global>,1
464179,NAMESPACE_BLOCK,<empty>,,interactivity\onecore\precomp.hpp,interactivity\onecore\precomp.hpp:<global>,,<global>,1
464192,NAMESPACE_BLOCK,<empty>,,interactivity\win32\AccessibilityNotifier.cpp,interactivity\win32\AccessibilityNotifier.cpp:<global>,,<global>,1
464230,NAMESPACE_BLOCK,<empty>,,interactivity\win32\AccessibilityNotifier.hpp,interactivity\win32\AccessibilityNotifier.hpp:<global>,,<global>,1
464234,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class AccessibilityNotifier final : public IAccessibilityNotifier
    {
    public:
        ~AccessibilityNotifier() = default;

        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle);
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position);
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y);
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute);
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY);
        void NotifyConsoleLayoutEvent();
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId);
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId);
    };
}",1,interactivity\win32\AccessibilityNotifier.hpp,Microsoft,23,Microsoft,1
464235,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class AccessibilityNotifier final : public IAccessibilityNotifier
    {
    public:
        ~AccessibilityNotifier() = default;

        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle);
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position);
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y);
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute);
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY);
        void NotifyConsoleLayoutEvent();
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId);
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId);
    };
}",1,interactivity\win32\AccessibilityNotifier.hpp,Microsoft.Console,23,Console,1
464236,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class AccessibilityNotifier final : public IAccessibilityNotifier
    {
    public:
        ~AccessibilityNotifier() = default;

        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle);
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position);
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y);
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute);
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY);
        void NotifyConsoleLayoutEvent();
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId);
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId);
    };
}",1,interactivity\win32\AccessibilityNotifier.hpp,Microsoft.Console.Interactivity,23,Interactivity,1
464237,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class AccessibilityNotifier final : public IAccessibilityNotifier
    {
    public:
        ~AccessibilityNotifier() = default;

        void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle);
        void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position);
        void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y);
        void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute);
        void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY);
        void NotifyConsoleLayoutEvent();
        void NotifyConsoleStartApplicationEvent(_In_ DWORD processId);
        void NotifyConsoleEndApplicationEvent(_In_ DWORD processId);
    };
}",1,interactivity\win32\AccessibilityNotifier.hpp,Microsoft.Console.Interactivity.Win32,23,Win32,1
464291,NAMESPACE_BLOCK,<empty>,,interactivity\win32\Clipboard.cpp,interactivity\win32\Clipboard.cpp:<global>,,<global>,1
464713,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ConsoleControl.cpp,interactivity\win32\ConsoleControl.cpp:<global>,,<global>,1
464782,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ConsoleControl.hpp,interactivity\win32\ConsoleControl.hpp:<global>,,<global>,1
464786,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleControl final : public IConsoleControl
    {
    public:
        enum ControlType
        {
            ConsoleSetVDMCursorBounds,
            ConsoleNotifyConsoleApplication,
            ConsoleFullscreenSwitch,
            ConsoleSetCaretInfo,
            ConsoleSetReserveKeys,
            ConsoleSetForeground,
            ConsoleSetWindowOwner,
            ConsoleEndTask,
        };

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;

        // Public Members
        [[nodiscard]] NTSTATUS Control(_In_ ConsoleControl::ControlType ConsoleCom...",1,interactivity\win32\ConsoleControl.hpp,Microsoft,30,Microsoft,1
464787,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleControl final : public IConsoleControl
    {
    public:
        enum ControlType
        {
            ConsoleSetVDMCursorBounds,
            ConsoleNotifyConsoleApplication,
            ConsoleFullscreenSwitch,
            ConsoleSetCaretInfo,
            ConsoleSetReserveKeys,
            ConsoleSetForeground,
            ConsoleSetWindowOwner,
            ConsoleEndTask,
        };

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;

        // Public Members
        [[nodiscard]] NTSTATUS Control(_In_ ConsoleControl::ControlType ConsoleCom...",1,interactivity\win32\ConsoleControl.hpp,Microsoft.Console,30,Console,1
464788,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleControl final : public IConsoleControl
    {
    public:
        enum ControlType
        {
            ConsoleSetVDMCursorBounds,
            ConsoleNotifyConsoleApplication,
            ConsoleFullscreenSwitch,
            ConsoleSetCaretInfo,
            ConsoleSetReserveKeys,
            ConsoleSetForeground,
            ConsoleSetWindowOwner,
            ConsoleEndTask,
        };

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;

        // Public Members
        [[nodiscard]] NTSTATUS Control(_In_ ConsoleControl::ControlType ConsoleCom...",1,interactivity\win32\ConsoleControl.hpp,Microsoft.Console.Interactivity,30,Interactivity,1
464789,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleControl final : public IConsoleControl
    {
    public:
        enum ControlType
        {
            ConsoleSetVDMCursorBounds,
            ConsoleNotifyConsoleApplication,
            ConsoleFullscreenSwitch,
            ConsoleSetCaretInfo,
            ConsoleSetReserveKeys,
            ConsoleSetForeground,
            ConsoleSetWindowOwner,
            ConsoleEndTask,
        };

        // IConsoleControl Members
        [[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);
        [[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);
        [[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);
        [[nodiscard]] NTSTATUS SetWindowOwner(HWND hwnd, DWORD processId, DWORD threadId) noexcept override;

        // Public Members
        [[nodiscard]] NTSTATUS Control(_In_ ConsoleControl::ControlType ConsoleCom...",1,interactivity\win32\ConsoleControl.hpp,Microsoft.Console.Interactivity.Win32,30,Win32,1
464829,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ConsoleInputThread.cpp,interactivity\win32\ConsoleInputThread.cpp:<global>,,<global>,1
464877,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ConsoleInputThread.hpp,interactivity\win32\ConsoleInputThread.hpp:<global>,,<global>,1
464881,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleInputThread final : public IConsoleInputThread
    {
    public:
        ~ConsoleInputThread() = default;
        HANDLE Start();
    };
}",1,interactivity\win32\ConsoleInputThread.hpp,Microsoft,19,Microsoft,1
464882,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleInputThread final : public IConsoleInputThread
    {
    public:
        ~ConsoleInputThread() = default;
        HANDLE Start();
    };
}",1,interactivity\win32\ConsoleInputThread.hpp,Microsoft.Console,19,Console,1
464883,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleInputThread final : public IConsoleInputThread
    {
    public:
        ~ConsoleInputThread() = default;
        HANDLE Start();
    };
}",1,interactivity\win32\ConsoleInputThread.hpp,Microsoft.Console.Interactivity,19,Interactivity,1
464884,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class ConsoleInputThread final : public IConsoleInputThread
    {
    public:
        ~ConsoleInputThread() = default;
        HANDLE Start();
    };
}",1,interactivity\win32\ConsoleInputThread.hpp,Microsoft.Console.Interactivity.Win32,19,Win32,1
464895,NAMESPACE_BLOCK,<empty>,,interactivity\win32\CustomWindowMessages.hpp,interactivity\win32\CustomWindowMessages.hpp:<global>,,<global>,1
464908,NAMESPACE_BLOCK,<empty>,,interactivity\win32\SystemConfigurationProvider.cpp,interactivity\win32\SystemConfigurationProvider.cpp:<global>,,<global>,1
464990,NAMESPACE_BLOCK,<empty>,,interactivity\win32\SystemConfigurationProvider.hpp,interactivity\win32\SystemConfigurationProvider.hpp:<global>,,<global>,1
464994,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class SystemConfigurationProvider final : public ISystemConfigurationProvider
    {
    public:
        ~SystemConfigurationProvider() = default;

        bool IsCaretBlinkingEnabled();

        UINT GetCaretBlinkTime();
        int GetNumberOfMouseButtons();
        ULONG GetCursorWidth() override;
        ULONG GetNumberOfWheelScrollLines();
        ULONG GetNumberOfWheelScrollCharacters();

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo);

    private:
        static const ULONG s_DefaultCursorWidth = 1;
    };
}",1,interactivity\win32\SystemConfigurationProvider.hpp,Microsoft,21,Microsoft,1
464995,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class SystemConfigurationProvider final : public ISystemConfigurationProvider
    {
    public:
        ~SystemConfigurationProvider() = default;

        bool IsCaretBlinkingEnabled();

        UINT GetCaretBlinkTime();
        int GetNumberOfMouseButtons();
        ULONG GetCursorWidth() override;
        ULONG GetNumberOfWheelScrollLines();
        ULONG GetNumberOfWheelScrollCharacters();

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo);

    private:
        static const ULONG s_DefaultCursorWidth = 1;
    };
}",1,interactivity\win32\SystemConfigurationProvider.hpp,Microsoft.Console,21,Console,1
464996,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class SystemConfigurationProvider final : public ISystemConfigurationProvider
    {
    public:
        ~SystemConfigurationProvider() = default;

        bool IsCaretBlinkingEnabled();

        UINT GetCaretBlinkTime();
        int GetNumberOfMouseButtons();
        ULONG GetCursorWidth() override;
        ULONG GetNumberOfWheelScrollLines();
        ULONG GetNumberOfWheelScrollCharacters();

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo);

    private:
        static const ULONG s_DefaultCursorWidth = 1;
    };
}",1,interactivity\win32\SystemConfigurationProvider.hpp,Microsoft.Console.Interactivity,21,Interactivity,1
464997,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class SystemConfigurationProvider final : public ISystemConfigurationProvider
    {
    public:
        ~SystemConfigurationProvider() = default;

        bool IsCaretBlinkingEnabled();

        UINT GetCaretBlinkTime();
        int GetNumberOfMouseButtons();
        ULONG GetCursorWidth() override;
        ULONG GetNumberOfWheelScrollLines();
        ULONG GetNumberOfWheelScrollCharacters();

        void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo);

    private:
        static const ULONG s_DefaultCursorWidth = 1;
    };
}",1,interactivity\win32\SystemConfigurationProvider.hpp,Microsoft.Console.Interactivity.Win32,21,Win32,1
465043,NAMESPACE_BLOCK,<empty>,,interactivity\win32\WindowIme.cpp,interactivity\win32\WindowIme.cpp:<global>,,<global>,1
465224,NAMESPACE_BLOCK,<empty>,,interactivity\win32\WindowMetrics.cpp,interactivity\win32\WindowMetrics.cpp:<global>,,<global>,1
465283,NAMESPACE_BLOCK,<empty>,,interactivity\win32\WindowMetrics.hpp,interactivity\win32\WindowMetrics.hpp:<global>,,<global>,1
465287,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowMetrics final : public IWindowMetrics
    {
    public:
        // IWindowMetrics Members
        ~WindowMetrics() = default;
        til::rect GetMinClientRectInPixels();
        til::rect GetMaxClientRectInPixels();

        // Public Members
        til::rect GetMaxWindowRectInPixels();
        til::rect GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested);

        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle);
        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle,
                                const int iDpi);

        void ConvertClientRectToWindowRect(_I...",1,interactivity\win32\WindowMetrics.hpp,Microsoft,17,Microsoft,1
465288,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowMetrics final : public IWindowMetrics
    {
    public:
        // IWindowMetrics Members
        ~WindowMetrics() = default;
        til::rect GetMinClientRectInPixels();
        til::rect GetMaxClientRectInPixels();

        // Public Members
        til::rect GetMaxWindowRectInPixels();
        til::rect GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested);

        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle);
        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle,
                                const int iDpi);

        void ConvertClientRectToWindowRect(_I...",1,interactivity\win32\WindowMetrics.hpp,Microsoft.Console,17,Console,1
465289,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowMetrics final : public IWindowMetrics
    {
    public:
        // IWindowMetrics Members
        ~WindowMetrics() = default;
        til::rect GetMinClientRectInPixels();
        til::rect GetMaxClientRectInPixels();

        // Public Members
        til::rect GetMaxWindowRectInPixels();
        til::rect GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested);

        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle);
        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle,
                                const int iDpi);

        void ConvertClientRectToWindowRect(_I...",1,interactivity\win32\WindowMetrics.hpp,Microsoft.Console.Interactivity,17,Interactivity,1
465290,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowMetrics final : public IWindowMetrics
    {
    public:
        // IWindowMetrics Members
        ~WindowMetrics() = default;
        til::rect GetMinClientRectInPixels();
        til::rect GetMaxClientRectInPixels();

        // Public Members
        til::rect GetMaxWindowRectInPixels();
        til::rect GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested);

        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle);
        BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle,
                                const int iDpi);

        void ConvertClientRectToWindowRect(_I...",1,interactivity\win32\WindowMetrics.hpp,Microsoft.Console.Interactivity.Win32,17,Win32,1
465323,NAMESPACE_BLOCK,<empty>,,interactivity\win32\clipboard.hpp,interactivity\win32\clipboard.hpp:<global>,,<global>,1
465327,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Clipboard
    {
    public:
        static Clipboard& Instance();

        void Copy(_In_ const bool fAlsoCopyFormatting = false);
        void StringPaste(_In_reads_(cchData) PCWCHAR pwchData,
                         const size_t cchData);
        void Paste();

    private:
        using unique_close_clipboard_call = wil::unique_call<decltype(::CloseClipboard), &::CloseClipboard>;
        static unique_close_clipboard_call _openClipboard(HWND hwnd);
        static void _copyToClipboard(UINT format, const void* src, size_t bytes);
        static void _copyToClipboardRegisteredFormat(const wchar_t* format, const void* src, size_t bytes);

        InputEventQueue TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                        const size_t cchData,
                                        const bool bracketedPaste = false);

        void StoreSelectionToClipboard(_In_ const bool fAls...",1,interactivity\win32\clipboard.hpp,Microsoft,25,Microsoft,1
465328,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Clipboard
    {
    public:
        static Clipboard& Instance();

        void Copy(_In_ const bool fAlsoCopyFormatting = false);
        void StringPaste(_In_reads_(cchData) PCWCHAR pwchData,
                         const size_t cchData);
        void Paste();

    private:
        using unique_close_clipboard_call = wil::unique_call<decltype(::CloseClipboard), &::CloseClipboard>;
        static unique_close_clipboard_call _openClipboard(HWND hwnd);
        static void _copyToClipboard(UINT format, const void* src, size_t bytes);
        static void _copyToClipboardRegisteredFormat(const wchar_t* format, const void* src, size_t bytes);

        InputEventQueue TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                        const size_t cchData,
                                        const bool bracketedPaste = false);

        void StoreSelectionToClipboard(_In_ const bool fAls...",1,interactivity\win32\clipboard.hpp,Microsoft.Console,25,Console,1
465329,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Clipboard
    {
    public:
        static Clipboard& Instance();

        void Copy(_In_ const bool fAlsoCopyFormatting = false);
        void StringPaste(_In_reads_(cchData) PCWCHAR pwchData,
                         const size_t cchData);
        void Paste();

    private:
        using unique_close_clipboard_call = wil::unique_call<decltype(::CloseClipboard), &::CloseClipboard>;
        static unique_close_clipboard_call _openClipboard(HWND hwnd);
        static void _copyToClipboard(UINT format, const void* src, size_t bytes);
        static void _copyToClipboardRegisteredFormat(const wchar_t* format, const void* src, size_t bytes);

        InputEventQueue TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                        const size_t cchData,
                                        const bool bracketedPaste = false);

        void StoreSelectionToClipboard(_In_ const bool fAls...",1,interactivity\win32\clipboard.hpp,Microsoft.Console.Interactivity,25,Interactivity,1
465330,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Clipboard
    {
    public:
        static Clipboard& Instance();

        void Copy(_In_ const bool fAlsoCopyFormatting = false);
        void StringPaste(_In_reads_(cchData) PCWCHAR pwchData,
                         const size_t cchData);
        void Paste();

    private:
        using unique_close_clipboard_call = wil::unique_call<decltype(::CloseClipboard), &::CloseClipboard>;
        static unique_close_clipboard_call _openClipboard(HWND hwnd);
        static void _copyToClipboard(UINT format, const void* src, size_t bytes);
        static void _copyToClipboardRegisteredFormat(const wchar_t* format, const void* src, size_t bytes);

        InputEventQueue TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                        const size_t cchData,
                                        const bool bracketedPaste = false);

        void StoreSelectionToClipboard(_In_ const bool fAls...",1,interactivity\win32\clipboard.hpp,Microsoft.Console.Interactivity.Win32,25,Win32,1
465371,NAMESPACE_BLOCK,<empty>,,interactivity\win32\consoleKeyInfo.cpp,interactivity\win32\consoleKeyInfo.cpp:<global>,,<global>,1
465426,NAMESPACE_BLOCK,<empty>,,interactivity\win32\consoleKeyInfo.hpp,interactivity\win32\consoleKeyInfo.hpp:<global>,,<global>,1
465461,NAMESPACE_BLOCK,<empty>,,interactivity\win32\find.cpp,interactivity\win32\find.cpp:<global>,,<global>,1
465725,NAMESPACE_BLOCK,<empty>,,interactivity\win32\find.hpp,interactivity\win32\find.hpp:<global>,,<global>,1
465742,NAMESPACE_BLOCK,<empty>,,interactivity\win32\icon.cpp,interactivity\win32\icon.cpp:<global>,,<global>,1
465951,NAMESPACE_BLOCK,<empty>,,interactivity\win32\icon.hpp,interactivity\win32\icon.hpp:<global>,,<global>,1
465955,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Icon sealed
    {
    public:
        static Icon& Instance();

        [[nodiscard]] HRESULT GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon);
        [[nodiscard]] HRESULT SetIcons(const HICON hIcon, const HICON hSmIcon);

        [[nodiscard]] HRESULT LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex);

        [[nodiscard]] HRESULT ApplyWindowMessageWorkaround(const HWND hwnd);

    protected:
        Icon();
        ~Icon();
        Icon(const Icon&) = delete;
        void operator=(const Icon&) = delete;

    private:
        [[nodiscard]] HRESULT _Initialize();

        void _DestroyNonDefaultIcons();

        // Helper methods
        [[nodiscard]] HRESULT _GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon);...",1,interactivity\win32\icon.hpp,Microsoft,18,Microsoft,1
465956,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Icon sealed
    {
    public:
        static Icon& Instance();

        [[nodiscard]] HRESULT GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon);
        [[nodiscard]] HRESULT SetIcons(const HICON hIcon, const HICON hSmIcon);

        [[nodiscard]] HRESULT LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex);

        [[nodiscard]] HRESULT ApplyWindowMessageWorkaround(const HWND hwnd);

    protected:
        Icon();
        ~Icon();
        Icon(const Icon&) = delete;
        void operator=(const Icon&) = delete;

    private:
        [[nodiscard]] HRESULT _Initialize();

        void _DestroyNonDefaultIcons();

        // Helper methods
        [[nodiscard]] HRESULT _GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon);...",1,interactivity\win32\icon.hpp,Microsoft.Console,18,Console,1
465957,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Icon sealed
    {
    public:
        static Icon& Instance();

        [[nodiscard]] HRESULT GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon);
        [[nodiscard]] HRESULT SetIcons(const HICON hIcon, const HICON hSmIcon);

        [[nodiscard]] HRESULT LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex);

        [[nodiscard]] HRESULT ApplyWindowMessageWorkaround(const HWND hwnd);

    protected:
        Icon();
        ~Icon();
        Icon(const Icon&) = delete;
        void operator=(const Icon&) = delete;

    private:
        [[nodiscard]] HRESULT _Initialize();

        void _DestroyNonDefaultIcons();

        // Helper methods
        [[nodiscard]] HRESULT _GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon);...",1,interactivity\win32\icon.hpp,Microsoft.Console.Interactivity,18,Interactivity,1
465958,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Icon sealed
    {
    public:
        static Icon& Instance();

        [[nodiscard]] HRESULT GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon);
        [[nodiscard]] HRESULT SetIcons(const HICON hIcon, const HICON hSmIcon);

        [[nodiscard]] HRESULT LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex);

        [[nodiscard]] HRESULT ApplyWindowMessageWorkaround(const HWND hwnd);

    protected:
        Icon();
        ~Icon();
        Icon(const Icon&) = delete;
        void operator=(const Icon&) = delete;

    private:
        [[nodiscard]] HRESULT _Initialize();

        void _DestroyNonDefaultIcons();

        // Helper methods
        [[nodiscard]] HRESULT _GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon);...",1,interactivity\win32\icon.hpp,Microsoft.Console.Interactivity.Win32,18,Win32,1
465987,NAMESPACE_BLOCK,<empty>,,interactivity\win32\menu.cpp,interactivity\win32\menu.cpp:<global>,,<global>,1
467885,NAMESPACE_BLOCK,<empty>,,interactivity\win32\menu.hpp,interactivity\win32\menu.hpp:<global>,,<global>,1
467889,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Menu sealed
    {
    public:
        Menu(_In_ HMENU hMenu,
             _In_ HMENU hHeirMenu);
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ HWND hWnd);
        static Menu* Instance();
        ~Menu();

        void Initialize();

        static void s_ShowPropertiesDialog(const HWND hwnd, const BOOL Defaults);
        [[nodiscard]] static HRESULT s_GetConsoleState(_Out_ CONSOLE_STATE_INFO* const pStateInfo);

        static HMENU s_GetMenuHandle();
        static HMENU s_GetHeirMenuHandle();

    private:
        static void s_PropertiesUpdate(_In_ PCONSOLE_STATE_INFO pStateInfo);

        static Menu* s_Instance;

        HMENU _hMenu; // handle to system menu
        HMENU _hHeirMenu; // handle to menu we append to system menu
    };
}",1,interactivity\win32\menu.hpp,Microsoft,23,Microsoft,1
467890,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Menu sealed
    {
    public:
        Menu(_In_ HMENU hMenu,
             _In_ HMENU hHeirMenu);
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ HWND hWnd);
        static Menu* Instance();
        ~Menu();

        void Initialize();

        static void s_ShowPropertiesDialog(const HWND hwnd, const BOOL Defaults);
        [[nodiscard]] static HRESULT s_GetConsoleState(_Out_ CONSOLE_STATE_INFO* const pStateInfo);

        static HMENU s_GetMenuHandle();
        static HMENU s_GetHeirMenuHandle();

    private:
        static void s_PropertiesUpdate(_In_ PCONSOLE_STATE_INFO pStateInfo);

        static Menu* s_Instance;

        HMENU _hMenu; // handle to system menu
        HMENU _hHeirMenu; // handle to menu we append to system menu
    };
}",1,interactivity\win32\menu.hpp,Microsoft.Console,23,Console,1
467891,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Menu sealed
    {
    public:
        Menu(_In_ HMENU hMenu,
             _In_ HMENU hHeirMenu);
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ HWND hWnd);
        static Menu* Instance();
        ~Menu();

        void Initialize();

        static void s_ShowPropertiesDialog(const HWND hwnd, const BOOL Defaults);
        [[nodiscard]] static HRESULT s_GetConsoleState(_Out_ CONSOLE_STATE_INFO* const pStateInfo);

        static HMENU s_GetMenuHandle();
        static HMENU s_GetHeirMenuHandle();

    private:
        static void s_PropertiesUpdate(_In_ PCONSOLE_STATE_INFO pStateInfo);

        static Menu* s_Instance;

        HMENU _hMenu; // handle to system menu
        HMENU _hHeirMenu; // handle to menu we append to system menu
    };
}",1,interactivity\win32\menu.hpp,Microsoft.Console.Interactivity,23,Interactivity,1
467892,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class Menu sealed
    {
    public:
        Menu(_In_ HMENU hMenu,
             _In_ HMENU hHeirMenu);
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ HWND hWnd);
        static Menu* Instance();
        ~Menu();

        void Initialize();

        static void s_ShowPropertiesDialog(const HWND hwnd, const BOOL Defaults);
        [[nodiscard]] static HRESULT s_GetConsoleState(_Out_ CONSOLE_STATE_INFO* const pStateInfo);

        static HMENU s_GetMenuHandle();
        static HMENU s_GetHeirMenuHandle();

    private:
        static void s_PropertiesUpdate(_In_ PCONSOLE_STATE_INFO pStateInfo);

        static Menu* s_Instance;

        HMENU _hMenu; // handle to system menu
        HMENU _hHeirMenu; // handle to menu we append to system menu
    };
}",1,interactivity\win32\menu.hpp,Microsoft.Console.Interactivity.Win32,23,Win32,1
467897,NAMESPACE_BLOCK,<empty>,,interactivity\win32\precomp.cpp,interactivity\win32\precomp.cpp:<global>,,<global>,1
467904,NAMESPACE_BLOCK,<empty>,,interactivity\win32\precomp.hpp,interactivity\win32\precomp.hpp:<global>,,<global>,1
467909,NAMESPACE_BLOCK,<empty>,,interactivity\win32\resource.hpp,interactivity\win32\resource.hpp:<global>,,<global>,1
467920,NAMESPACE_BLOCK,<empty>,,interactivity\win32\screenInfoUiaProvider.cpp,interactivity\win32\screenInfoUiaProvider.cpp:<global>,,<global>,1
467961,NAMESPACE_BLOCK,<empty>,,interactivity\win32\screenInfoUiaProvider.hpp,interactivity\win32\screenInfoUiaProvider.hpp:<global>,,<global>,1
467965,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class ScreenInfoUiaProvider final : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        ScreenInfoUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ WindowUiaProvider* const pUiaParent);

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;
        IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;

        HWND GetWindowHandle() const;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

    protected:
        HRESULT GetSelectionRange(_In...",1,interactivity\win32\screenInfoUiaProvider.hpp,Microsoft,28,Microsoft,1
467966,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class ScreenInfoUiaProvider final : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        ScreenInfoUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ WindowUiaProvider* const pUiaParent);

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;
        IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;

        HWND GetWindowHandle() const;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

    protected:
        HRESULT GetSelectionRange(_In...",1,interactivity\win32\screenInfoUiaProvider.hpp,Microsoft.Console,28,Console,1
467967,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class ScreenInfoUiaProvider final : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        ScreenInfoUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ WindowUiaProvider* const pUiaParent);

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;
        IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;

        HWND GetWindowHandle() const;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

    protected:
        HRESULT GetSelectionRange(_In...",1,interactivity\win32\screenInfoUiaProvider.hpp,Microsoft.Console.Interactivity,28,Interactivity,1
467968,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class ScreenInfoUiaProvider final : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        ScreenInfoUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ WindowUiaProvider* const pUiaParent);

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;
        IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;

        HWND GetWindowHandle() const;
        void ChangeViewport(const til::inclusive_rect& NewWindow) override;

    protected:
        HRESULT GetSelectionRange(_In...",1,interactivity\win32\screenInfoUiaProvider.hpp,Microsoft.Console.Interactivity.Win32,28,Win32,1
468003,NAMESPACE_BLOCK,<empty>,,interactivity\win32\uiaTextRange.cpp,interactivity\win32\uiaTextRange.cpp:<global>,,<global>,1
468065,NAMESPACE_BLOCK,<empty>,,interactivity\win32\uiaTextRange.hpp,interactivity\win32\uiaTextRange.hpp:<global>,,<global>,1
468069,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class UiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        UiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData*...",1,interactivity\win32\uiaTextRange.hpp,Microsoft,22,Microsoft,1
468070,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class UiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        UiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData*...",1,interactivity\win32\uiaTextRange.hpp,Microsoft.Console,22,Console,1
468071,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class UiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        UiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData*...",1,interactivity\win32\uiaTextRange.hpp,Microsoft.Console.Interactivity,22,Interactivity,1
468072,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class UiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        UiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Render::IRenderData*...",1,interactivity\win32\uiaTextRange.hpp,Microsoft.Console.Interactivity.Win32,22,Win32,1
468104,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ut_interactivity_win32\GeneratedUiaTextRangeMovementTests.g.cpp,interactivity\win32\ut_interactivity_win32\GeneratedUiaTextRangeMovementTests.g.cpp:<global>,,<global>,1
475074,NAMESPACE_BLOCK,<empty>,,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp:<global>,,<global>,1
475247,NAMESPACE_BLOCK,"namespace
{
#pragma region TAEF hookup for the test case array above
    struct ArrayIndexTaefAdapterRow : public Microsoft::WRL::RuntimeClass<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom | Microsoft::WRL::InhibitFtmBase>, IDataRow>
    {
        HRESULT RuntimeClassInitialize(const size_t index)
        {
            _index = index;
            return S_OK;
        }

        STDMETHODIMP GetTestData(BSTR /*pszName*/, SAFEARRAY** ppData) override
        {
            const auto indexString{ wil::str_printf<std::wstring>(L""%zu"", _index) };
            auto safeArray{ SafeArrayCreateVector(VT_BSTR, 0, 1) };
            LONG index{ 0 };
            auto indexBstr{ wil::make_bstr(indexString.c_str()) };
            (void)SafeArrayPutElement(safeArray, &index, indexBstr.release());
            *ppData = safeArray;
            return S_OK;
        }

        STDMETHODIMP GetMetadataNames(SAFEARRAY** ppMetadataNames) override
        {
            *ppMetadataNames = nullp...",1,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp,anonymous_namespace_0,112,,3
477077,NAMESPACE_BLOCK,<empty>,,interactivity\win32\window.cpp,interactivity\win32\window.cpp:<global>,,<global>,1
479092,NAMESPACE_BLOCK,<empty>,,interactivity\win32\window.hpp,interactivity\win32\window.hpp:<global>,,<global>,1
479096,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    class AtlasEngine;
}",1,interactivity\win32\window.hpp,Microsoft,19,Microsoft,1
479097,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    class AtlasEngine;
}",1,interactivity\win32\window.hpp,Microsoft.Console,19,Console,1
479098,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    class AtlasEngine;
}",1,interactivity\win32\window.hpp,Microsoft.Console.Render,19,Render,1
479099,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    class AtlasEngine;
}",1,interactivity\win32\window.hpp,Microsoft.Console.Render.Atlas,19,Atlas,1
479101,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
    class DxEngine;
    class GdiEngine;
}",1,interactivity\win32\window.hpp,Microsoft,24,Microsoft,2
479102,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
    class DxEngine;
    class GdiEngine;
}",1,interactivity\win32\window.hpp,Microsoft.Console,24,Console,1
479103,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
    class DxEngine;
    class GdiEngine;
}",1,interactivity\win32\window.hpp,Microsoft.Console.Render,24,Render,1
479107,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class Window final : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ Settings* const pSettings,
                                                     _In_ SCREEN_INFORMATION* const pScreen);

        [[nodiscard]] NTSTATUS ActivateAndShow(const WORD wShowWindow);

        ~Window();

        til::rect GetWindowRect() const noexcept;
        HWND GetWindowHandle() const;
        SCREEN_INFORMATION& GetScreenInfo();
        const SCREEN_INFORMATION& GetScreenInfo() const;

        BYTE GetWindowOpacity() const;
        void SetWindowOpacity(const BYTE bOpacity);
        void ApplyWindowOpacity() const;
        void ChangeWindowOpacity(const short sOpacityDelta);

        bool IsInMaximized() const;

        bool IsInFullscreen() const;
        void SetIsFullscreen(const bool fFullscreenEnabled);
        void ToggleFullscreen...",1,interactivity\win32\window.hpp,Microsoft,31,Microsoft,3
479108,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class Window final : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ Settings* const pSettings,
                                                     _In_ SCREEN_INFORMATION* const pScreen);

        [[nodiscard]] NTSTATUS ActivateAndShow(const WORD wShowWindow);

        ~Window();

        til::rect GetWindowRect() const noexcept;
        HWND GetWindowHandle() const;
        SCREEN_INFORMATION& GetScreenInfo();
        const SCREEN_INFORMATION& GetScreenInfo() const;

        BYTE GetWindowOpacity() const;
        void SetWindowOpacity(const BYTE bOpacity);
        void ApplyWindowOpacity() const;
        void ChangeWindowOpacity(const short sOpacityDelta);

        bool IsInMaximized() const;

        bool IsInFullscreen() const;
        void SetIsFullscreen(const bool fFullscreenEnabled);
        void ToggleFullscreen...",1,interactivity\win32\window.hpp,Microsoft.Console,31,Console,1
479109,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class Window final : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ Settings* const pSettings,
                                                     _In_ SCREEN_INFORMATION* const pScreen);

        [[nodiscard]] NTSTATUS ActivateAndShow(const WORD wShowWindow);

        ~Window();

        til::rect GetWindowRect() const noexcept;
        HWND GetWindowHandle() const;
        SCREEN_INFORMATION& GetScreenInfo();
        const SCREEN_INFORMATION& GetScreenInfo() const;

        BYTE GetWindowOpacity() const;
        void SetWindowOpacity(const BYTE bOpacity);
        void ApplyWindowOpacity() const;
        void ChangeWindowOpacity(const short sOpacityDelta);

        bool IsInMaximized() const;

        bool IsInFullscreen() const;
        void SetIsFullscreen(const bool fFullscreenEnabled);
        void ToggleFullscreen...",1,interactivity\win32\window.hpp,Microsoft.Console.Interactivity,31,Interactivity,1
479110,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider;

    class Window final : public Microsoft::Console::Types::IConsoleWindow
    {
    public:
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ Settings* const pSettings,
                                                     _In_ SCREEN_INFORMATION* const pScreen);

        [[nodiscard]] NTSTATUS ActivateAndShow(const WORD wShowWindow);

        ~Window();

        til::rect GetWindowRect() const noexcept;
        HWND GetWindowHandle() const;
        SCREEN_INFORMATION& GetScreenInfo();
        const SCREEN_INFORMATION& GetScreenInfo() const;

        BYTE GetWindowOpacity() const;
        void SetWindowOpacity(const BYTE bOpacity);
        void ApplyWindowOpacity() const;
        void ChangeWindowOpacity(const short sOpacityDelta);

        bool IsInMaximized() const;

        bool IsInFullscreen() const;
        void SetIsFullscreen(const bool fFullscreenEnabled);
        void ToggleFullscreen...",1,interactivity\win32\window.hpp,Microsoft.Console.Interactivity.Win32,31,Win32,1
479369,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowUiaProvider.cpp,interactivity\win32\windowUiaProvider.cpp:<global>,,<global>,1
479452,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowUiaProvider.hpp,interactivity\win32\windowUiaProvider.hpp:<global>,,<global>,1
479456,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow;
}",1,interactivity\win32\windowUiaProvider.hpp,Microsoft,29,Microsoft,1
479457,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow;
}",1,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console,29,Console,1
479458,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IConsoleWindow;
}",1,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console.Types,29,Types,1
479460,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, IRawElementProviderFragmentRoot>
    {
    public:
        WindowUiaProvider() = default;
        ~WindowUiaProvider() = default;
        HRESULT RuntimeClassInitialize(Microsoft::Console::Types::IConsoleWindow* baseWindow) noexcept;

        WindowUiaProvider(const WindowUiaProvider&) = delete;
        WindowUiaProvider(WindowUiaProvider&&) = delete;
        WindowUiaProvider& operator=(const WindowUiaProvider&) = delete;
        WindowUiaProvider& operator=(WindowUiaProvider&&) = delete;

    public:
        [[nodiscard]] virtual HRESULT Signal(_In_ EVENTID id);
        [[nodiscard]] virtual HRESULT SetTextAreaFocus();

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) overr...",1,interactivity\win32\windowUiaProvider.hpp,Microsoft,34,Microsoft,2
479461,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, IRawElementProviderFragmentRoot>
    {
    public:
        WindowUiaProvider() = default;
        ~WindowUiaProvider() = default;
        HRESULT RuntimeClassInitialize(Microsoft::Console::Types::IConsoleWindow* baseWindow) noexcept;

        WindowUiaProvider(const WindowUiaProvider&) = delete;
        WindowUiaProvider(WindowUiaProvider&&) = delete;
        WindowUiaProvider& operator=(const WindowUiaProvider&) = delete;
        WindowUiaProvider& operator=(WindowUiaProvider&&) = delete;

    public:
        [[nodiscard]] virtual HRESULT Signal(_In_ EVENTID id);
        [[nodiscard]] virtual HRESULT SetTextAreaFocus();

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) overr...",1,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console,34,Console,1
479462,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, IRawElementProviderFragmentRoot>
    {
    public:
        WindowUiaProvider() = default;
        ~WindowUiaProvider() = default;
        HRESULT RuntimeClassInitialize(Microsoft::Console::Types::IConsoleWindow* baseWindow) noexcept;

        WindowUiaProvider(const WindowUiaProvider&) = delete;
        WindowUiaProvider(WindowUiaProvider&&) = delete;
        WindowUiaProvider& operator=(const WindowUiaProvider&) = delete;
        WindowUiaProvider& operator=(WindowUiaProvider&&) = delete;

    public:
        [[nodiscard]] virtual HRESULT Signal(_In_ EVENTID id);
        [[nodiscard]] virtual HRESULT SetTextAreaFocus();

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) overr...",1,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console.Interactivity,34,Interactivity,1
479463,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowUiaProvider final :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, IRawElementProviderFragmentRoot>
    {
    public:
        WindowUiaProvider() = default;
        ~WindowUiaProvider() = default;
        HRESULT RuntimeClassInitialize(Microsoft::Console::Types::IConsoleWindow* baseWindow) noexcept;

        WindowUiaProvider(const WindowUiaProvider&) = delete;
        WindowUiaProvider(WindowUiaProvider&&) = delete;
        WindowUiaProvider& operator=(const WindowUiaProvider&) = delete;
        WindowUiaProvider& operator=(WindowUiaProvider&&) = delete;

    public:
        [[nodiscard]] virtual HRESULT Signal(_In_ EVENTID id);
        [[nodiscard]] virtual HRESULT SetTextAreaFocus();

        // IRawElementProviderSimple methods
        IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) overr...",1,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console.Interactivity.Win32,34,Win32,1
479550,NAMESPACE_BLOCK,"namespace WindowUiaProviderTracing
    {
        enum class ApiCall
        {
            Create,
            Signal,
            AddRef,
            Release,
            QueryInterface,
            GetProviderOptions,
            GetPatternProvider,
            GetPropertyValue,
            GetHostRawElementProvider,
            Navigate,
            GetRuntimeId,
            GetBoundingRectangle,
            GetEmbeddedFragmentRoots,
            SetFocus,
            GetFragmentRoot,
            ElementProviderFromPoint,
            GetFocus
        };

        struct IApiMsg
        {
        };

        struct ApiMessageSignal : public IApiMsg
        {
            EVENTID Signal;
        };

        struct ApiMsgNavigate : public IApiMsg
        {
            NavigateDirection Direction;
        };
    }",5,interactivity\win32\windowUiaProvider.hpp,Microsoft.Console.Interactivity.Win32.WindowUiaProviderTracing,104,WindowUiaProviderTracing,2
479579,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowdpiapi.cpp,interactivity\win32\windowdpiapi.cpp:<global>,,<global>,1
479719,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowdpiapi.hpp,interactivity\win32\windowdpiapi.hpp:<global>,,<global>,1
479747,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowDpiApi final : public IHighDpiApi
    {
    public:
        // IHighDpi Interface
        BOOL SetProcessDpiAwarenessContext();
        [[nodiscard]] HRESULT SetProcessPerMonitorDpiAwareness();

        // Module-internal Functions
        BOOL SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext);
        BOOL AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                      const DWORD dwStyle,
                                      const BOOL bMenu,
                                      const DWORD dwExStyle,
                                      const UINT dpi);

        int GetDpiForWindow(const HWND hwnd);
        int GetSystemMetricsForDpi(const int nIndex,
                                   const UINT dpi);

#ifdef CON_DPIAPI_INDIRECT
        WindowDpiApi();
#endif
        ~WindowDpiApi();

    private:
        HMODULE _hUser32;
    };
}",1,interactivity\win32\windowdpiapi.hpp,Microsoft,46,Microsoft,4
479748,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowDpiApi final : public IHighDpiApi
    {
    public:
        // IHighDpi Interface
        BOOL SetProcessDpiAwarenessContext();
        [[nodiscard]] HRESULT SetProcessPerMonitorDpiAwareness();

        // Module-internal Functions
        BOOL SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext);
        BOOL AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                      const DWORD dwStyle,
                                      const BOOL bMenu,
                                      const DWORD dwExStyle,
                                      const UINT dpi);

        int GetDpiForWindow(const HWND hwnd);
        int GetSystemMetricsForDpi(const int nIndex,
                                   const UINT dpi);

#ifdef CON_DPIAPI_INDIRECT
        WindowDpiApi();
#endif
        ~WindowDpiApi();

    private:
        HMODULE _hUser32;
    };
}",1,interactivity\win32\windowdpiapi.hpp,Microsoft.Console,46,Console,1
479749,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowDpiApi final : public IHighDpiApi
    {
    public:
        // IHighDpi Interface
        BOOL SetProcessDpiAwarenessContext();
        [[nodiscard]] HRESULT SetProcessPerMonitorDpiAwareness();

        // Module-internal Functions
        BOOL SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext);
        BOOL AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                      const DWORD dwStyle,
                                      const BOOL bMenu,
                                      const DWORD dwExStyle,
                                      const UINT dpi);

        int GetDpiForWindow(const HWND hwnd);
        int GetSystemMetricsForDpi(const int nIndex,
                                   const UINT dpi);

#ifdef CON_DPIAPI_INDIRECT
        WindowDpiApi();
#endif
        ~WindowDpiApi();

    private:
        HMODULE _hUser32;
    };
}",1,interactivity\win32\windowdpiapi.hpp,Microsoft.Console.Interactivity,46,Interactivity,1
479750,NAMESPACE_BLOCK,"namespace Microsoft::Console::Interactivity::Win32
{
    class WindowDpiApi final : public IHighDpiApi
    {
    public:
        // IHighDpi Interface
        BOOL SetProcessDpiAwarenessContext();
        [[nodiscard]] HRESULT SetProcessPerMonitorDpiAwareness();

        // Module-internal Functions
        BOOL SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext);
        BOOL AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                      const DWORD dwStyle,
                                      const BOOL bMenu,
                                      const DWORD dwExStyle,
                                      const UINT dpi);

        int GetDpiForWindow(const HWND hwnd);
        int GetSystemMetricsForDpi(const int nIndex,
                                   const UINT dpi);

#ifdef CON_DPIAPI_INDIRECT
        WindowDpiApi();
#endif
        ~WindowDpiApi();

    private:
        HMODULE _hUser32;
    };
}",1,interactivity\win32\windowdpiapi.hpp,Microsoft.Console.Interactivity.Win32,46,Win32,1
479785,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowime.hpp,interactivity\win32\windowime.hpp:<global>,,<global>,1
479826,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowio.cpp,interactivity\win32\windowio.cpp:<global>,,<global>,1
481059,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowio.hpp,interactivity\win32\windowio.hpp:<global>,,<global>,1
481131,NAMESPACE_BLOCK,<empty>,,interactivity\win32\windowproc.cpp,interactivity\win32\windowproc.cpp:<global>,,<global>,1
481474,NAMESPACE_BLOCK,<empty>,,internal\precomp.cpp,internal\precomp.cpp:<global>,,<global>,1
481483,NAMESPACE_BLOCK,<empty>,,internal\precomp.hpp,internal\precomp.hpp:<global>,,<global>,1
481492,NAMESPACE_BLOCK,<empty>,,internal\stubs.cpp,internal\stubs.cpp:<global>,,<global>,1
481530,NAMESPACE_BLOCK,<empty>,,propsheet\ColorControl.cpp,propsheet\ColorControl.cpp:<global>,,<global>,1
481650,NAMESPACE_BLOCK,<empty>,,propsheet\ColorControl.hpp,propsheet\ColorControl.hpp:<global>,,<global>,1
481669,NAMESPACE_BLOCK,<empty>,,propsheet\ColorsPage.cpp,propsheet\ColorsPage.cpp:<global>,,<global>,1
482650,NAMESPACE_BLOCK,<empty>,,propsheet\ColorsPage.hpp,propsheet\ColorsPage.hpp:<global>,,<global>,1
482675,NAMESPACE_BLOCK,<empty>,,propsheet\LayoutPage.cpp,propsheet\LayoutPage.cpp:<global>,,<global>,1
483324,NAMESPACE_BLOCK,<empty>,,propsheet\LayoutPage.hpp,propsheet\LayoutPage.hpp:<global>,,<global>,1
483341,NAMESPACE_BLOCK,<empty>,,propsheet\OptionsPage.cpp,propsheet\OptionsPage.cpp:<global>,,<global>,1
484213,NAMESPACE_BLOCK,<empty>,,propsheet\OptionsPage.hpp,propsheet\OptionsPage.hpp:<global>,,<global>,1
484247,NAMESPACE_BLOCK,<empty>,,propsheet\PropSheetHandler.cpp,propsheet\PropSheetHandler.cpp:<global>,,<global>,1
484296,NAMESPACE_BLOCK,<empty>,,propsheet\TerminalPropsheetPage.cpp,propsheet\TerminalPropsheetPage.cpp:<global>,,<global>,1
485762,NAMESPACE_BLOCK,<empty>,,propsheet\TerminalPropsheetPage.hpp,propsheet\TerminalPropsheetPage.hpp:<global>,,<global>,1
485780,NAMESPACE_BLOCK,<empty>,,propsheet\console.cpp,propsheet\console.cpp:<global>,,<global>,1
487050,NAMESPACE_BLOCK,<empty>,,propsheet\console.hpp,propsheet\console.hpp:<global>,,<global>,1
487236,NAMESPACE_BLOCK,<empty>,,propsheet\dbcs.cpp,propsheet\dbcs.cpp:<global>,,<global>,1
487554,NAMESPACE_BLOCK,<empty>,,propsheet\dialogs.hpp,propsheet\dialogs.hpp:<global>,,<global>,1
487563,NAMESPACE_BLOCK,<empty>,,propsheet\dll.cpp,propsheet\dll.cpp:<global>,,<global>,1
487590,NAMESPACE_BLOCK,<empty>,,propsheet\font.hpp,propsheet\font.hpp:<global>,,<global>,1
487641,NAMESPACE_BLOCK,<empty>,,propsheet\fontdlg.cpp,propsheet\fontdlg.cpp:<global>,,<global>,1
489245,NAMESPACE_BLOCK,<empty>,,propsheet\fontdlg.hpp,propsheet\fontdlg.hpp:<global>,,<global>,1
489252,NAMESPACE_BLOCK,<empty>,,propsheet\globals.cpp,propsheet\globals.cpp:<global>,,<global>,1
489358,NAMESPACE_BLOCK,<empty>,,propsheet\globals.hpp,propsheet\globals.hpp:<global>,,<global>,1
489405,NAMESPACE_BLOCK,<empty>,,propsheet\init.cpp,propsheet\init.cpp:<global>,,<global>,1
489618,NAMESPACE_BLOCK,<empty>,,propsheet\menu.hpp,propsheet\menu.hpp:<global>,,<global>,1
489629,NAMESPACE_BLOCK,<empty>,,propsheet\misc.cpp,propsheet\misc.cpp:<global>,,<global>,1
491129,NAMESPACE_BLOCK,<empty>,,propsheet\precomp.cpp,propsheet\precomp.cpp:<global>,,<global>,1
491176,NAMESPACE_BLOCK,<empty>,,propsheet\precomp.hpp,propsheet\precomp.hpp:<global>,,<global>,1
491183,NAMESPACE_BLOCK,<empty>,,propsheet\preview.cpp,propsheet\preview.cpp:<global>,,<global>,1
492561,NAMESPACE_BLOCK,<empty>,,propsheet\registry.cpp,propsheet\registry.cpp:<global>,,<global>,1
493336,NAMESPACE_BLOCK,<empty>,,propsheet\util.cpp,propsheet\util.cpp:<global>,,<global>,1
493448,NAMESPACE_BLOCK,<empty>,,propslib\DelegationConfig.cpp,propslib\DelegationConfig.cpp:<global>,,<global>,1
494082,NAMESPACE_BLOCK,<empty>,,propslib\DelegationConfig.hpp,propslib\DelegationConfig.hpp:<global>,,<global>,1
494420,NAMESPACE_BLOCK,<empty>,,propslib\RegistrySerialization.cpp,propslib\RegistrySerialization.cpp:<global>,,<global>,1
494899,NAMESPACE_BLOCK,<empty>,,propslib\RegistrySerialization.hpp,propslib\RegistrySerialization.hpp:<global>,,<global>,1
494955,NAMESPACE_BLOCK,<empty>,,propslib\ShortcutSerialization.cpp,propslib\ShortcutSerialization.cpp:<global>,,<global>,1
494976,NAMESPACE_BLOCK,<empty>,,propslib\ShortcutSerialization.hpp,propslib\ShortcutSerialization.hpp:<global>,,<global>,1
495004,NAMESPACE_BLOCK,<empty>,,propslib\TrueTypeFontList.cpp,propslib\TrueTypeFontList.cpp:<global>,,<global>,1
495231,NAMESPACE_BLOCK,<empty>,,propslib\TrueTypeFontList.hpp,propslib\TrueTypeFontList.hpp:<global>,,<global>,1
495254,NAMESPACE_BLOCK,<empty>,,propslib\conpropsp.hpp,propslib\conpropsp.hpp:<global>,,<global>,1
495261,NAMESPACE_BLOCK,<empty>,,propslib\precomp.cpp,propslib\precomp.cpp:<global>,,<global>,1
495290,NAMESPACE_BLOCK,<empty>,,propslib\precomp.hpp,propslib\precomp.hpp:<global>,,<global>,1
495307,NAMESPACE_BLOCK,<empty>,,renderer\atlas\AtlasEngine.api.cpp,renderer\atlas\AtlasEngine.api.cpp:<global>,,<global>,1
497744,NAMESPACE_BLOCK,<empty>,,renderer\atlas\AtlasEngine.cpp,renderer\atlas\AtlasEngine.cpp:<global>,,<global>,1
500038,NAMESPACE_BLOCK,<empty>,,renderer\atlas\AtlasEngine.hpp,renderer\atlas\AtlasEngine.hpp:<global>,,<global>,1
500042,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSinkResult;

    class AtlasEngine final : public IRenderEngine
    {
    public:
        explicit AtlasEngine();

        AtlasEngine(const AtlasEngine&) = delete;
        AtlasEngine& operator=(const AtlasEngine&) = delete;

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] bool RequiresContinuousRedraw() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT I...",1,renderer\atlas\AtlasEngine.hpp,Microsoft,12,Microsoft,1
500043,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSinkResult;

    class AtlasEngine final : public IRenderEngine
    {
    public:
        explicit AtlasEngine();

        AtlasEngine(const AtlasEngine&) = delete;
        AtlasEngine& operator=(const AtlasEngine&) = delete;

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] bool RequiresContinuousRedraw() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT I...",1,renderer\atlas\AtlasEngine.hpp,Microsoft.Console,12,Console,1
500044,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSinkResult;

    class AtlasEngine final : public IRenderEngine
    {
    public:
        explicit AtlasEngine();

        AtlasEngine(const AtlasEngine&) = delete;
        AtlasEngine& operator=(const AtlasEngine&) = delete;

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] bool RequiresContinuousRedraw() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT I...",1,renderer\atlas\AtlasEngine.hpp,Microsoft.Console.Render,12,Render,1
500045,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSinkResult;

    class AtlasEngine final : public IRenderEngine
    {
    public:
        explicit AtlasEngine();

        AtlasEngine(const AtlasEngine&) = delete;
        AtlasEngine& operator=(const AtlasEngine&) = delete;

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] bool RequiresContinuousRedraw() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT I...",1,renderer\atlas\AtlasEngine.hpp,Microsoft.Console.Render.Atlas,12,Atlas,1
500535,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
}",1,renderer\atlas\AtlasEngine.hpp,Microsoft,171,Microsoft,2
500536,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
}",1,renderer\atlas\AtlasEngine.hpp,Microsoft.Console,171,Console,1
500537,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    using AtlasEngine = Atlas::AtlasEngine;
}",1,renderer\atlas\AtlasEngine.hpp,Microsoft.Console.Render,171,Render,1
500548,NAMESPACE_BLOCK,<empty>,,renderer\atlas\AtlasEngine.r.cpp,renderer\atlas\AtlasEngine.r.cpp:<global>,,<global>,1
501891,NAMESPACE_BLOCK,<empty>,,renderer\atlas\Backend.cpp,renderer\atlas\Backend.cpp:<global>,,<global>,1
502215,NAMESPACE_BLOCK,<empty>,,renderer\atlas\Backend.hpp,renderer\atlas\Backend.hpp:<global>,,<global>,1
502219,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    // If set to 1, this will cause the entire viewport to be invalidated at all times.
    // Helpful for benchmarking our text shaping code based on DirectWrite.
#define ATLAS_DEBUG_DISABLE_PARTIAL_INVALIDATION 0

    // Redraw at display refresh rate at all times. This helps with shader debugging.
#define ATLAS_DEBUG_CONTINUOUS_REDRAW 0

    // Disables the use of DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT.
    // This helps with benchmarking the application as it'll run beyond display refresh rate.
#define ATLAS_DEBUG_DISABLE_FRAME_LATENCY_WAITABLE_OBJECT 0

    // Forces the use of Direct2D for text rendering (= BackendD2D).
#define ATLAS_DEBUG_FORCE_D2D_MODE 0

    // Adds an artificial delay before every render pass. In milliseconds.
#define ATLAS_DEBUG_RENDER_DELAY 0

    // Shows the dirty rects as given to IDXGISwapChain2::Present1() during each frame.
#define ATLAS_DEBUG_SHOW_DIRTY 0

    // Dumps the contents of the s...",1,renderer\atlas\Backend.hpp,Microsoft,8,Microsoft,1
502220,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    // If set to 1, this will cause the entire viewport to be invalidated at all times.
    // Helpful for benchmarking our text shaping code based on DirectWrite.
#define ATLAS_DEBUG_DISABLE_PARTIAL_INVALIDATION 0

    // Redraw at display refresh rate at all times. This helps with shader debugging.
#define ATLAS_DEBUG_CONTINUOUS_REDRAW 0

    // Disables the use of DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT.
    // This helps with benchmarking the application as it'll run beyond display refresh rate.
#define ATLAS_DEBUG_DISABLE_FRAME_LATENCY_WAITABLE_OBJECT 0

    // Forces the use of Direct2D for text rendering (= BackendD2D).
#define ATLAS_DEBUG_FORCE_D2D_MODE 0

    // Adds an artificial delay before every render pass. In milliseconds.
#define ATLAS_DEBUG_RENDER_DELAY 0

    // Shows the dirty rects as given to IDXGISwapChain2::Present1() during each frame.
#define ATLAS_DEBUG_SHOW_DIRTY 0

    // Dumps the contents of the s...",1,renderer\atlas\Backend.hpp,Microsoft.Console,8,Console,1
502221,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    // If set to 1, this will cause the entire viewport to be invalidated at all times.
    // Helpful for benchmarking our text shaping code based on DirectWrite.
#define ATLAS_DEBUG_DISABLE_PARTIAL_INVALIDATION 0

    // Redraw at display refresh rate at all times. This helps with shader debugging.
#define ATLAS_DEBUG_CONTINUOUS_REDRAW 0

    // Disables the use of DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT.
    // This helps with benchmarking the application as it'll run beyond display refresh rate.
#define ATLAS_DEBUG_DISABLE_FRAME_LATENCY_WAITABLE_OBJECT 0

    // Forces the use of Direct2D for text rendering (= BackendD2D).
#define ATLAS_DEBUG_FORCE_D2D_MODE 0

    // Adds an artificial delay before every render pass. In milliseconds.
#define ATLAS_DEBUG_RENDER_DELAY 0

    // Shows the dirty rects as given to IDXGISwapChain2::Present1() during each frame.
#define ATLAS_DEBUG_SHOW_DIRTY 0

    // Dumps the contents of the s...",1,renderer\atlas\Backend.hpp,Microsoft.Console.Render,8,Render,1
502222,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    // If set to 1, this will cause the entire viewport to be invalidated at all times.
    // Helpful for benchmarking our text shaping code based on DirectWrite.
#define ATLAS_DEBUG_DISABLE_PARTIAL_INVALIDATION 0

    // Redraw at display refresh rate at all times. This helps with shader debugging.
#define ATLAS_DEBUG_CONTINUOUS_REDRAW 0

    // Disables the use of DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT.
    // This helps with benchmarking the application as it'll run beyond display refresh rate.
#define ATLAS_DEBUG_DISABLE_FRAME_LATENCY_WAITABLE_OBJECT 0

    // Forces the use of Direct2D for text rendering (= BackendD2D).
#define ATLAS_DEBUG_FORCE_D2D_MODE 0

    // Adds an artificial delay before every render pass. In milliseconds.
#define ATLAS_DEBUG_RENDER_DELAY 0

    // Shows the dirty rects as given to IDXGISwapChain2::Present1() during each frame.
#define ATLAS_DEBUG_SHOW_DIRTY 0

    // Dumps the contents of the s...",1,renderer\atlas\Backend.hpp,Microsoft.Console.Render.Atlas,8,Atlas,1
502678,NAMESPACE_BLOCK,<empty>,,renderer\atlas\BackendD2D.cpp,renderer\atlas\BackendD2D.cpp:<global>,,<global>,1
504908,NAMESPACE_BLOCK,<empty>,,renderer\atlas\BackendD2D.hpp,renderer\atlas\BackendD2D.hpp:<global>,,<global>,1
504912,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD2D : IBackend
    {
        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

    private:
        ATLAS_ATTR_COLD void _handleSettingsUpdate(const RenderingPayload& p);
        void _drawBackground(const RenderingPayload& p) noexcept;
        void _drawText(RenderingPayload& p);
        ATLAS_ATTR_COLD f32 _drawTextPrepareLineRendition(const RenderingPayload& p, const ShapedRow* row, f32 baselineY) const noexcept;
        ATLAS_ATTR_COLD void _drawTextResetLineRendition(const ShapedRow* row) const noexcept;
        ATLAS_ATTR_COLD f32r _getGlyphRunDesignBounds(const DWRITE_GLYPH_RUN& glyphRun, f32 baselineX, f32 baselineY);
        ATLAS_ATTR_COLD void _drawGridlineRow(const RenderingPayload& p, const ShapedRow* row, u16 y);
        void _drawCursorPart1(const RenderingPayload& p);
        void _drawCursorPart...",1,renderer\atlas\BackendD2D.hpp,Microsoft,10,Microsoft,1
504913,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD2D : IBackend
    {
        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

    private:
        ATLAS_ATTR_COLD void _handleSettingsUpdate(const RenderingPayload& p);
        void _drawBackground(const RenderingPayload& p) noexcept;
        void _drawText(RenderingPayload& p);
        ATLAS_ATTR_COLD f32 _drawTextPrepareLineRendition(const RenderingPayload& p, const ShapedRow* row, f32 baselineY) const noexcept;
        ATLAS_ATTR_COLD void _drawTextResetLineRendition(const ShapedRow* row) const noexcept;
        ATLAS_ATTR_COLD f32r _getGlyphRunDesignBounds(const DWRITE_GLYPH_RUN& glyphRun, f32 baselineX, f32 baselineY);
        ATLAS_ATTR_COLD void _drawGridlineRow(const RenderingPayload& p, const ShapedRow* row, u16 y);
        void _drawCursorPart1(const RenderingPayload& p);
        void _drawCursorPart...",1,renderer\atlas\BackendD2D.hpp,Microsoft.Console,10,Console,1
504914,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD2D : IBackend
    {
        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

    private:
        ATLAS_ATTR_COLD void _handleSettingsUpdate(const RenderingPayload& p);
        void _drawBackground(const RenderingPayload& p) noexcept;
        void _drawText(RenderingPayload& p);
        ATLAS_ATTR_COLD f32 _drawTextPrepareLineRendition(const RenderingPayload& p, const ShapedRow* row, f32 baselineY) const noexcept;
        ATLAS_ATTR_COLD void _drawTextResetLineRendition(const ShapedRow* row) const noexcept;
        ATLAS_ATTR_COLD f32r _getGlyphRunDesignBounds(const DWRITE_GLYPH_RUN& glyphRun, f32 baselineX, f32 baselineY);
        ATLAS_ATTR_COLD void _drawGridlineRow(const RenderingPayload& p, const ShapedRow* row, u16 y);
        void _drawCursorPart1(const RenderingPayload& p);
        void _drawCursorPart...",1,renderer\atlas\BackendD2D.hpp,Microsoft.Console.Render,10,Render,1
504915,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD2D : IBackend
    {
        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

    private:
        ATLAS_ATTR_COLD void _handleSettingsUpdate(const RenderingPayload& p);
        void _drawBackground(const RenderingPayload& p) noexcept;
        void _drawText(RenderingPayload& p);
        ATLAS_ATTR_COLD f32 _drawTextPrepareLineRendition(const RenderingPayload& p, const ShapedRow* row, f32 baselineY) const noexcept;
        ATLAS_ATTR_COLD void _drawTextResetLineRendition(const ShapedRow* row) const noexcept;
        ATLAS_ATTR_COLD f32r _getGlyphRunDesignBounds(const DWRITE_GLYPH_RUN& glyphRun, f32 baselineX, f32 baselineY);
        ATLAS_ATTR_COLD void _drawGridlineRow(const RenderingPayload& p, const ShapedRow* row, u16 y);
        void _drawCursorPart1(const RenderingPayload& p);
        void _drawCursorPart...",1,renderer\atlas\BackendD2D.hpp,Microsoft.Console.Render.Atlas,10,Atlas,1
505292,NAMESPACE_BLOCK,<empty>,,renderer\atlas\BackendD3D.cpp,renderer\atlas\BackendD3D.cpp:<global>,,<global>,1
510959,NAMESPACE_BLOCK,<empty>,,renderer\atlas\BackendD3D.hpp,renderer\atlas\BackendD3D.hpp:<global>,,<global>,1
510963,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD3D : IBackend
    {
        BackendD3D(const RenderingPayload& p);

        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

        // NOTE: D3D constant buffers sizes must be a multiple of 16 bytes.
        struct alignas(16) VSConstBuffer
        {
            // WARNING: Modify this carefully after understanding how HLSL struct packing works. The gist is:
            // * Minimum alignment is 4 bytes
            // * Members cannot straddle 16 byte boundaries
            //   This means a structure like {u32; u32; u32; u32x2} would require
            //   padding so that it is {u32; u32; u32; <4 byte padding>; u32x2}.
            // * bool will probably not work the way you want it to,
            //   because HLSL uses 32-bit bools and C++ doesn't.
            alignas(sizeof(f32x2)) f32x2 positionScale;
...",1,renderer\atlas\BackendD3D.hpp,Microsoft,12,Microsoft,1
510964,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD3D : IBackend
    {
        BackendD3D(const RenderingPayload& p);

        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

        // NOTE: D3D constant buffers sizes must be a multiple of 16 bytes.
        struct alignas(16) VSConstBuffer
        {
            // WARNING: Modify this carefully after understanding how HLSL struct packing works. The gist is:
            // * Minimum alignment is 4 bytes
            // * Members cannot straddle 16 byte boundaries
            //   This means a structure like {u32; u32; u32; u32x2} would require
            //   padding so that it is {u32; u32; u32; <4 byte padding>; u32x2}.
            // * bool will probably not work the way you want it to,
            //   because HLSL uses 32-bit bools and C++ doesn't.
            alignas(sizeof(f32x2)) f32x2 positionScale;
...",1,renderer\atlas\BackendD3D.hpp,Microsoft.Console,12,Console,1
510965,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD3D : IBackend
    {
        BackendD3D(const RenderingPayload& p);

        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

        // NOTE: D3D constant buffers sizes must be a multiple of 16 bytes.
        struct alignas(16) VSConstBuffer
        {
            // WARNING: Modify this carefully after understanding how HLSL struct packing works. The gist is:
            // * Minimum alignment is 4 bytes
            // * Members cannot straddle 16 byte boundaries
            //   This means a structure like {u32; u32; u32; u32x2} would require
            //   padding so that it is {u32; u32; u32; <4 byte padding>; u32x2}.
            // * bool will probably not work the way you want it to,
            //   because HLSL uses 32-bit bools and C++ doesn't.
            alignas(sizeof(f32x2)) f32x2 positionScale;
...",1,renderer\atlas\BackendD3D.hpp,Microsoft.Console.Render,12,Render,1
510966,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct BackendD3D : IBackend
    {
        BackendD3D(const RenderingPayload& p);

        void ReleaseResources() noexcept override;
        void Render(RenderingPayload& payload) override;
        bool RequiresContinuousRedraw() noexcept override;

        // NOTE: D3D constant buffers sizes must be a multiple of 16 bytes.
        struct alignas(16) VSConstBuffer
        {
            // WARNING: Modify this carefully after understanding how HLSL struct packing works. The gist is:
            // * Minimum alignment is 4 bytes
            // * Members cannot straddle 16 byte boundaries
            //   This means a structure like {u32; u32; u32; u32x2} would require
            //   padding so that it is {u32; u32; u32; <4 byte padding>; u32x2}.
            // * bool will probably not work the way you want it to,
            //   because HLSL uses 32-bit bools and C++ doesn't.
            alignas(sizeof(f32x2)) f32x2 positionScale;
...",1,renderer\atlas\BackendD3D.hpp,Microsoft.Console.Render.Atlas,12,Atlas,1
511556,NAMESPACE_BLOCK,<empty>,,renderer\atlas\DWriteTextAnalysis.cpp,renderer\atlas\DWriteTextAnalysis.cpp:<global>,,<global>,1
511807,NAMESPACE_BLOCK,<empty>,,renderer\atlas\DWriteTextAnalysis.hpp,renderer\atlas\DWriteTextAnalysis.hpp:<global>,,<global>,1
511811,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSource final : IDWriteTextAnalysisSource
    {
        TextAnalysisSource(const wchar_t* locale, const wchar_t* text, const UINT32 textLength) noexcept;
#ifndef NDEBUG
        ~TextAnalysisSource();
#endif

        ULONG __stdcall AddRef() noexcept override;
        ULONG __stdcall Release() noexcept override;
        HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) noexcept override;
        HRESULT __stdcall GetTextAtPosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        HRESULT __stdcall GetTextBeforePosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        DWRITE_READING_DIRECTION __stdcall GetParagraphReadingDirection() noexcept override;
        HRESULT __stdcall GetLocaleName(UINT32 textPosition, UINT32* textLength, const WCHAR** localeName) noexcept override;
        HRESULT __stdcall GetNumberSub...",1,renderer\atlas\DWriteTextAnalysis.hpp,Microsoft,8,Microsoft,1
511812,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSource final : IDWriteTextAnalysisSource
    {
        TextAnalysisSource(const wchar_t* locale, const wchar_t* text, const UINT32 textLength) noexcept;
#ifndef NDEBUG
        ~TextAnalysisSource();
#endif

        ULONG __stdcall AddRef() noexcept override;
        ULONG __stdcall Release() noexcept override;
        HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) noexcept override;
        HRESULT __stdcall GetTextAtPosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        HRESULT __stdcall GetTextBeforePosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        DWRITE_READING_DIRECTION __stdcall GetParagraphReadingDirection() noexcept override;
        HRESULT __stdcall GetLocaleName(UINT32 textPosition, UINT32* textLength, const WCHAR** localeName) noexcept override;
        HRESULT __stdcall GetNumberSub...",1,renderer\atlas\DWriteTextAnalysis.hpp,Microsoft.Console,8,Console,1
511813,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSource final : IDWriteTextAnalysisSource
    {
        TextAnalysisSource(const wchar_t* locale, const wchar_t* text, const UINT32 textLength) noexcept;
#ifndef NDEBUG
        ~TextAnalysisSource();
#endif

        ULONG __stdcall AddRef() noexcept override;
        ULONG __stdcall Release() noexcept override;
        HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) noexcept override;
        HRESULT __stdcall GetTextAtPosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        HRESULT __stdcall GetTextBeforePosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        DWRITE_READING_DIRECTION __stdcall GetParagraphReadingDirection() noexcept override;
        HRESULT __stdcall GetLocaleName(UINT32 textPosition, UINT32* textLength, const WCHAR** localeName) noexcept override;
        HRESULT __stdcall GetNumberSub...",1,renderer\atlas\DWriteTextAnalysis.hpp,Microsoft.Console.Render,8,Render,1
511814,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
    struct TextAnalysisSource final : IDWriteTextAnalysisSource
    {
        TextAnalysisSource(const wchar_t* locale, const wchar_t* text, const UINT32 textLength) noexcept;
#ifndef NDEBUG
        ~TextAnalysisSource();
#endif

        ULONG __stdcall AddRef() noexcept override;
        ULONG __stdcall Release() noexcept override;
        HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) noexcept override;
        HRESULT __stdcall GetTextAtPosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        HRESULT __stdcall GetTextBeforePosition(UINT32 textPosition, const WCHAR** textString, UINT32* textLength) noexcept override;
        DWRITE_READING_DIRECTION __stdcall GetParagraphReadingDirection() noexcept override;
        HRESULT __stdcall GetLocaleName(UINT32 textPosition, UINT32* textLength, const WCHAR** localeName) noexcept override;
        HRESULT __stdcall GetNumberSub...",1,renderer\atlas\DWriteTextAnalysis.hpp,Microsoft.Console.Render.Atlas,8,Atlas,1
511947,NAMESPACE_BLOCK,<empty>,,renderer\atlas\colorbrewer.hpp,renderer\atlas\colorbrewer.hpp:<global>,,<global>,1
511951,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas::colorbrewer
{
    // The following list of colors is only used as a debug aid and not part of the final product.
    // They're licensed under:
    //
    //   Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
    //
    //   Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
    //
    //   Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License.
    //   You may obtain a copy of the License at
    //
    //   http://www.apache.org/licenses/LICENSE-2.0
    //
    //   Unless required by applicable law or agreed to in writing, software distributed
    //   under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
    //   CONDITIONS OF ANY KIND, either express or implied. See the License for the
    //   specific language governing permissions and limitations under the License.
...",1,renderer\atlas\colorbrewer.hpp,Microsoft,6,Microsoft,1
511952,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas::colorbrewer
{
    // The following list of colors is only used as a debug aid and not part of the final product.
    // They're licensed under:
    //
    //   Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
    //
    //   Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
    //
    //   Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License.
    //   You may obtain a copy of the License at
    //
    //   http://www.apache.org/licenses/LICENSE-2.0
    //
    //   Unless required by applicable law or agreed to in writing, software distributed
    //   under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
    //   CONDITIONS OF ANY KIND, either express or implied. See the License for the
    //   specific language governing permissions and limitations under the License.
...",1,renderer\atlas\colorbrewer.hpp,Microsoft.Console,6,Console,1
511953,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas::colorbrewer
{
    // The following list of colors is only used as a debug aid and not part of the final product.
    // They're licensed under:
    //
    //   Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
    //
    //   Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
    //
    //   Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License.
    //   You may obtain a copy of the License at
    //
    //   http://www.apache.org/licenses/LICENSE-2.0
    //
    //   Unless required by applicable law or agreed to in writing, software distributed
    //   under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
    //   CONDITIONS OF ANY KIND, either express or implied. See the License for the
    //   specific language governing permissions and limitations under the License.
...",1,renderer\atlas\colorbrewer.hpp,Microsoft.Console.Render,6,Render,1
511954,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas::colorbrewer
{
    // The following list of colors is only used as a debug aid and not part of the final product.
    // They're licensed under:
    //
    //   Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
    //
    //   Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
    //
    //   Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License.
    //   You may obtain a copy of the License at
    //
    //   http://www.apache.org/licenses/LICENSE-2.0
    //
    //   Unless required by applicable law or agreed to in writing, software distributed
    //   under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
    //   CONDITIONS OF ANY KIND, either express or implied. See the License for the
    //   specific language governing permissions and limitations under the License.
...",1,renderer\atlas\colorbrewer.hpp,Microsoft.Console.Render.Atlas,6,Atlas,1
511955,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas::colorbrewer
{
    // The following list of colors is only used as a debug aid and not part of the final product.
    // They're licensed under:
    //
    //   Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
    //
    //   Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
    //
    //   Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License.
    //   You may obtain a copy of the License at
    //
    //   http://www.apache.org/licenses/LICENSE-2.0
    //
    //   Unless required by applicable law or agreed to in writing, software distributed
    //   under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
    //   CONDITIONS OF ANY KIND, either express or implied. See the License for the
    //   specific language governing permissions and limitations under the License.
...",1,renderer\atlas\colorbrewer.hpp,Microsoft.Console.Render.Atlas.colorbrewer,6,colorbrewer,1
511974,NAMESPACE_BLOCK,<empty>,,renderer\atlas\common.hpp,renderer\atlas\common.hpp:<global>,,<global>,1
511978,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
#define ATLAS_FLAG_OPS(type, underlying)                                                       \
    constexpr type operator~(type v) noexcept                                                  \
    {                                                                                          \
        return static_cast<type>(~static_cast<underlying>(v));                                 \
    }                                                                                          \
    constexpr type operator|(type lhs, type rhs) noexcept                                      \
    {                                                                                          \
        return static_cast<type>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs)); \
    }                                                                                          \
    constexpr type operator&(type lhs, type rhs) noexcept                     ...",1,renderer\atlas\common.hpp,Microsoft,10,Microsoft,1
511979,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
#define ATLAS_FLAG_OPS(type, underlying)                                                       \
    constexpr type operator~(type v) noexcept                                                  \
    {                                                                                          \
        return static_cast<type>(~static_cast<underlying>(v));                                 \
    }                                                                                          \
    constexpr type operator|(type lhs, type rhs) noexcept                                      \
    {                                                                                          \
        return static_cast<type>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs)); \
    }                                                                                          \
    constexpr type operator&(type lhs, type rhs) noexcept                     ...",1,renderer\atlas\common.hpp,Microsoft.Console,10,Console,1
511980,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
#define ATLAS_FLAG_OPS(type, underlying)                                                       \
    constexpr type operator~(type v) noexcept                                                  \
    {                                                                                          \
        return static_cast<type>(~static_cast<underlying>(v));                                 \
    }                                                                                          \
    constexpr type operator|(type lhs, type rhs) noexcept                                      \
    {                                                                                          \
        return static_cast<type>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs)); \
    }                                                                                          \
    constexpr type operator&(type lhs, type rhs) noexcept                     ...",1,renderer\atlas\common.hpp,Microsoft.Console.Render,10,Render,1
511981,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::Atlas
{
#define ATLAS_FLAG_OPS(type, underlying)                                                       \
    constexpr type operator~(type v) noexcept                                                  \
    {                                                                                          \
        return static_cast<type>(~static_cast<underlying>(v));                                 \
    }                                                                                          \
    constexpr type operator|(type lhs, type rhs) noexcept                                      \
    {                                                                                          \
        return static_cast<type>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs)); \
    }                                                                                          \
    constexpr type operator&(type lhs, type rhs) noexcept                     ...",1,renderer\atlas\common.hpp,Microsoft.Console.Render.Atlas,10,Atlas,1
513001,NAMESPACE_BLOCK,<empty>,,renderer\atlas\dwrite.cpp,renderer\atlas\dwrite.cpp:<global>,,<global>,1
513532,NAMESPACE_BLOCK,<empty>,,renderer\atlas\dwrite.hpp,renderer\atlas\dwrite.hpp:<global>,,<global>,1
513565,NAMESPACE_BLOCK,<empty>,,renderer\atlas\pch.cpp,renderer\atlas\pch.cpp:<global>,,<global>,1
513630,NAMESPACE_BLOCK,<empty>,,renderer\atlas\pch.hpp,renderer\atlas\pch.hpp:<global>,,<global>,1
513639,NAMESPACE_BLOCK,<empty>,,renderer\atlas\stb_rect_pack.cpp,renderer\atlas\stb_rect_pack.cpp:<global>,,<global>,1
513646,NAMESPACE_BLOCK,<empty>,,renderer\atlas\wic.hpp,renderer\atlas\wic.hpp:<global>,,<global>,1
513946,NAMESPACE_BLOCK,<empty>,,renderer\base\CSSLengthPercentage.cpp,renderer\base\CSSLengthPercentage.cpp:<global>,,<global>,1
514108,NAMESPACE_BLOCK,<empty>,,renderer\base\FontCache.hpp,renderer\base\FontCache.hpp:<global>,,<global>,1
514112,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::FontCache
{
    namespace details
    {
        inline wil::com_ptr<IDWriteFontCollection> getFontCollection()
        {
            wil::com_ptr<IDWriteFactory> factory;
            THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

            wil::com_ptr<IDWriteFontCollection> systemFontCollection;
            THROW_IF_FAILED(factory->GetSystemFontCollection(systemFontCollection.addressof(), FALSE));

            if constexpr (Feature_NearbyFontLoading::IsEnabled())
            {
                // IDWriteFactory5 is supported since Windows 10, build 15021.
                const auto factory5 = factory.try_query<IDWriteFactory5>();
                if (!factory5)
                {
                    return systemFontCollection;
                }

                std::vector<wil::com_ptr<IDWriteFontFile>> nearbyFontFiles;

                const std::filesy...",1,renderer\base\FontCache.hpp,Microsoft,8,Microsoft,1
514113,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::FontCache
{
    namespace details
    {
        inline wil::com_ptr<IDWriteFontCollection> getFontCollection()
        {
            wil::com_ptr<IDWriteFactory> factory;
            THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

            wil::com_ptr<IDWriteFontCollection> systemFontCollection;
            THROW_IF_FAILED(factory->GetSystemFontCollection(systemFontCollection.addressof(), FALSE));

            if constexpr (Feature_NearbyFontLoading::IsEnabled())
            {
                // IDWriteFactory5 is supported since Windows 10, build 15021.
                const auto factory5 = factory.try_query<IDWriteFactory5>();
                if (!factory5)
                {
                    return systemFontCollection;
                }

                std::vector<wil::com_ptr<IDWriteFontFile>> nearbyFontFiles;

                const std::filesy...",1,renderer\base\FontCache.hpp,Microsoft.Console,8,Console,1
514114,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::FontCache
{
    namespace details
    {
        inline wil::com_ptr<IDWriteFontCollection> getFontCollection()
        {
            wil::com_ptr<IDWriteFactory> factory;
            THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

            wil::com_ptr<IDWriteFontCollection> systemFontCollection;
            THROW_IF_FAILED(factory->GetSystemFontCollection(systemFontCollection.addressof(), FALSE));

            if constexpr (Feature_NearbyFontLoading::IsEnabled())
            {
                // IDWriteFactory5 is supported since Windows 10, build 15021.
                const auto factory5 = factory.try_query<IDWriteFactory5>();
                if (!factory5)
                {
                    return systemFontCollection;
                }

                std::vector<wil::com_ptr<IDWriteFontFile>> nearbyFontFiles;

                const std::filesy...",1,renderer\base\FontCache.hpp,Microsoft.Console.Render,8,Render,1
514115,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render::FontCache
{
    namespace details
    {
        inline wil::com_ptr<IDWriteFontCollection> getFontCollection()
        {
            wil::com_ptr<IDWriteFactory> factory;
            THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

            wil::com_ptr<IDWriteFontCollection> systemFontCollection;
            THROW_IF_FAILED(factory->GetSystemFontCollection(systemFontCollection.addressof(), FALSE));

            if constexpr (Feature_NearbyFontLoading::IsEnabled())
            {
                // IDWriteFactory5 is supported since Windows 10, build 15021.
                const auto factory5 = factory.try_query<IDWriteFactory5>();
                if (!factory5)
                {
                    return systemFontCollection;
                }

                std::vector<wil::com_ptr<IDWriteFontFile>> nearbyFontFiles;

                const std::filesy...",1,renderer\base\FontCache.hpp,Microsoft.Console.Render.FontCache,8,FontCache,1
514116,NAMESPACE_BLOCK,"namespace details
    {
        inline wil::com_ptr<IDWriteFontCollection> getFontCollection()
        {
            wil::com_ptr<IDWriteFactory> factory;
            THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

            wil::com_ptr<IDWriteFontCollection> systemFontCollection;
            THROW_IF_FAILED(factory->GetSystemFontCollection(systemFontCollection.addressof(), FALSE));

            if constexpr (Feature_NearbyFontLoading::IsEnabled())
            {
                // IDWriteFactory5 is supported since Windows 10, build 15021.
                const auto factory5 = factory.try_query<IDWriteFactory5>();
                if (!factory5)
                {
                    return systemFontCollection;
                }

                std::vector<wil::com_ptr<IDWriteFontFile>> nearbyFontFiles;

                const std::filesystem::path module{ wil::GetModuleFileNameW<std::wstrin...",5,renderer\base\FontCache.hpp,Microsoft.Console.Render.FontCache.details,10,details,1
514409,NAMESPACE_BLOCK,<empty>,,renderer\base\FontInfoBase.cpp,renderer\base\FontInfoBase.cpp:<global>,,<global>,1
514616,NAMESPACE_BLOCK,<empty>,,renderer\base\FontInfoDesired.cpp,renderer\base\FontInfoDesired.cpp:<global>,,<global>,1
514778,NAMESPACE_BLOCK,<empty>,,renderer\base\FontResource.cpp,renderer\base\FontResource.cpp:<global>,,<global>,1
514781,NAMESPACE_BLOCK,"namespace
{
    // The structures below are based on the Windows 3.0 font file format, which
    // was documented in Microsoft Knowledge Base article Q65123. Although no
    // longer hosted by Microsoft, it can still be found at the following URL:
    // https://web.archive.org/web/20140820153410/http://support.microsoft.com/kb/65123

    // For now we're only using fixed pitch single color fonts, but the rest
    // of the flags are included here for completeness.
    static constexpr DWORD DFF_FIXED = 0x0001;
    static constexpr DWORD DFF_PROPORTIONAL = 0x0002;
    static constexpr DWORD DFF_1COLOR = 0x0010;
    static constexpr DWORD DFF_16COLOR = 0x0020;
    static constexpr DWORD DFF_256COLOR = 0x0040;
    static constexpr DWORD DFF_RGBCOLOR = 0x0080;

    // DRCS soft fonts only require 96 characters at most.
    static constexpr size_t CHAR_COUNT = 96;

#pragma pack(push, 1)
    struct GLYPHENTRY
    {
        WORD geWidth;
        DWORD geOffset;
    };

    struct FONTIN...",1,renderer\base\FontResource.cpp,anonymous_namespace_0,9,,1
515468,NAMESPACE_BLOCK,<empty>,,renderer\base\RenderEngineBase.cpp,renderer\base\RenderEngineBase.cpp:<global>,,<global>,1
515577,NAMESPACE_BLOCK,<empty>,,renderer\base\RenderSettings.cpp,renderer\base\RenderSettings.cpp:<global>,,<global>,1
516093,NAMESPACE_BLOCK,<empty>,,renderer\base\fontinfo.cpp,renderer\base\fontinfo.cpp:<global>,,<global>,1
516230,NAMESPACE_BLOCK,<empty>,,renderer\base\precomp.cpp,renderer\base\precomp.cpp:<global>,,<global>,1
516245,NAMESPACE_BLOCK,<empty>,,renderer\base\precomp.hpp,renderer\base\precomp.hpp:<global>,,<global>,1
516254,NAMESPACE_BLOCK,<empty>,,renderer\base\renderer.cpp,renderer\base\renderer.cpp:<global>,,<global>,1
517758,NAMESPACE_BLOCK,<empty>,,renderer\base\renderer.hpp,renderer\base\renderer.hpp:<global>,,<global>,1
517762,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer
    {
    public:
        Renderer(const RenderSettings& renderSettings,
                 IRenderData* pData,
                 _In_reads_(cEngines) IRenderEngine** const pEngine,
                 const size_t cEngines,
                 std::unique_ptr<RenderThread> thread);

        ~Renderer();

        [[nodiscard]] HRESULT PaintFrame();

        void NotifyPaintFrame() noexcept;
        void TriggerSystemRedraw(const til::rect* const prcDirtyClient);
        void TriggerRedraw(const Microsoft::Console::Types::Viewport& region);
        void TriggerRedraw(const til::point* const pcoord);
        void TriggerRedrawCursor(const til::point* const pcoord);
        void TriggerRedrawAll(const bool backgroundChanged = false, const bool frameChanged = false);
        void TriggerTeardown() noexcept;

        void TriggerSelection();
        void TriggerScroll();
        void TriggerScroll(const til::point* const pcoordDelta);

   ...",1,renderer\base\renderer.hpp,Microsoft,34,Microsoft,1
517763,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer
    {
    public:
        Renderer(const RenderSettings& renderSettings,
                 IRenderData* pData,
                 _In_reads_(cEngines) IRenderEngine** const pEngine,
                 const size_t cEngines,
                 std::unique_ptr<RenderThread> thread);

        ~Renderer();

        [[nodiscard]] HRESULT PaintFrame();

        void NotifyPaintFrame() noexcept;
        void TriggerSystemRedraw(const til::rect* const prcDirtyClient);
        void TriggerRedraw(const Microsoft::Console::Types::Viewport& region);
        void TriggerRedraw(const til::point* const pcoord);
        void TriggerRedrawCursor(const til::point* const pcoord);
        void TriggerRedrawAll(const bool backgroundChanged = false, const bool frameChanged = false);
        void TriggerTeardown() noexcept;

        void TriggerSelection();
        void TriggerScroll();
        void TriggerScroll(const til::point* const pcoordDelta);

   ...",1,renderer\base\renderer.hpp,Microsoft.Console,34,Console,1
517764,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer
    {
    public:
        Renderer(const RenderSettings& renderSettings,
                 IRenderData* pData,
                 _In_reads_(cEngines) IRenderEngine** const pEngine,
                 const size_t cEngines,
                 std::unique_ptr<RenderThread> thread);

        ~Renderer();

        [[nodiscard]] HRESULT PaintFrame();

        void NotifyPaintFrame() noexcept;
        void TriggerSystemRedraw(const til::rect* const prcDirtyClient);
        void TriggerRedraw(const Microsoft::Console::Types::Viewport& region);
        void TriggerRedraw(const til::point* const pcoord);
        void TriggerRedrawCursor(const til::point* const pcoord);
        void TriggerRedrawAll(const bool backgroundChanged = false, const bool frameChanged = false);
        void TriggerTeardown() noexcept;

        void TriggerSelection();
        void TriggerScroll();
        void TriggerScroll(const til::point* const pcoordDelta);

   ...",1,renderer\base\renderer.hpp,Microsoft.Console.Render,34,Render,1
518005,NAMESPACE_BLOCK,<empty>,,renderer\base\thread.cpp,renderer\base\thread.cpp:<global>,,<global>,1
518310,NAMESPACE_BLOCK,<empty>,,renderer\base\thread.hpp,renderer\base\thread.hpp:<global>,,<global>,1
518314,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;

    class RenderThread
    {
    public:
        RenderThread();
        ~RenderThread();

        [[nodiscard]] HRESULT Initialize(Renderer* const pRendererParent) noexcept;

        void NotifyPaint() noexcept;
        void EnablePainting() noexcept;
        void DisablePainting() noexcept;
        void WaitForPaintCompletionAndDisable(const DWORD dwTimeoutMs) noexcept;

    private:
        static DWORD WINAPI s_ThreadProc(_In_ LPVOID lpParameter);
        DWORD WINAPI _ThreadProc();

        HANDLE _hThread;
        HANDLE _hEvent;

        HANDLE _hPaintEnabledEvent;
        HANDLE _hPaintCompletedEvent;

        Renderer* _pRenderer; // Non-ownership pointer

        bool _fKeepRunning;
        std::atomic<bool> _fNextFrameRequested;
        std::atomic<bool> _fWaiting;
    };
}",1,renderer\base\thread.hpp,Microsoft,17,Microsoft,1
518315,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;

    class RenderThread
    {
    public:
        RenderThread();
        ~RenderThread();

        [[nodiscard]] HRESULT Initialize(Renderer* const pRendererParent) noexcept;

        void NotifyPaint() noexcept;
        void EnablePainting() noexcept;
        void DisablePainting() noexcept;
        void WaitForPaintCompletionAndDisable(const DWORD dwTimeoutMs) noexcept;

    private:
        static DWORD WINAPI s_ThreadProc(_In_ LPVOID lpParameter);
        DWORD WINAPI _ThreadProc();

        HANDLE _hThread;
        HANDLE _hEvent;

        HANDLE _hPaintEnabledEvent;
        HANDLE _hPaintCompletedEvent;

        Renderer* _pRenderer; // Non-ownership pointer

        bool _fKeepRunning;
        std::atomic<bool> _fNextFrameRequested;
        std::atomic<bool> _fWaiting;
    };
}",1,renderer\base\thread.hpp,Microsoft.Console,17,Console,1
518316,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Renderer;

    class RenderThread
    {
    public:
        RenderThread();
        ~RenderThread();

        [[nodiscard]] HRESULT Initialize(Renderer* const pRendererParent) noexcept;

        void NotifyPaint() noexcept;
        void EnablePainting() noexcept;
        void DisablePainting() noexcept;
        void WaitForPaintCompletionAndDisable(const DWORD dwTimeoutMs) noexcept;

    private:
        static DWORD WINAPI s_ThreadProc(_In_ LPVOID lpParameter);
        DWORD WINAPI _ThreadProc();

        HANDLE _hThread;
        HANDLE _hEvent;

        HANDLE _hPaintEnabledEvent;
        HANDLE _hPaintCompletedEvent;

        Renderer* _pRenderer; // Non-ownership pointer

        bool _fKeepRunning;
        std::atomic<bool> _fNextFrameRequested;
        std::atomic<bool> _fWaiting;
    };
}",1,renderer\base\thread.hpp,Microsoft.Console.Render,17,Render,1
518368,NAMESPACE_BLOCK,<empty>,,renderer\dx\BoxDrawingEffect.cpp,renderer\dx\BoxDrawingEffect.cpp:<global>,,<global>,1
518416,NAMESPACE_BLOCK,<empty>,,renderer\dx\BoxDrawingEffect.hpp,renderer\dx\BoxDrawingEffect.hpp:<global>,,<global>,1
518420,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BoxDrawingEffect : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IBoxDrawingEffect>
    {
    public:
        BoxDrawingEffect() noexcept;
        HRESULT RuntimeClassInitialize(float verticalScale, float verticalTranslate, float horizontalScale, float horizontalTranslate) noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetScale(BoxScale* scale) noexcept override;

    protected:
    private:
        BoxScale _scale;
#ifdef UNIT_TESTING
    public:
        friend class BoxDrawingEffectTests;
#endif
    };
}",1,renderer\dx\BoxDrawingEffect.hpp,Microsoft,12,Microsoft,1
518421,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BoxDrawingEffect : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IBoxDrawingEffect>
    {
    public:
        BoxDrawingEffect() noexcept;
        HRESULT RuntimeClassInitialize(float verticalScale, float verticalTranslate, float horizontalScale, float horizontalTranslate) noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetScale(BoxScale* scale) noexcept override;

    protected:
    private:
        BoxScale _scale;
#ifdef UNIT_TESTING
    public:
        friend class BoxDrawingEffectTests;
#endif
    };
}",1,renderer\dx\BoxDrawingEffect.hpp,Microsoft.Console,12,Console,1
518422,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class BoxDrawingEffect : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IBoxDrawingEffect>
    {
    public:
        BoxDrawingEffect() noexcept;
        HRESULT RuntimeClassInitialize(float verticalScale, float verticalTranslate, float horizontalScale, float horizontalTranslate) noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetScale(BoxScale* scale) noexcept override;

    protected:
    private:
        BoxScale _scale;
#ifdef UNIT_TESTING
    public:
        friend class BoxDrawingEffectTests;
#endif
    };
}",1,renderer\dx\BoxDrawingEffect.hpp,Microsoft.Console.Render,12,Render,1
518480,NAMESPACE_BLOCK,<empty>,,renderer\dx\CustomTextLayout.cpp,renderer\dx\CustomTextLayout.cpp:<global>,,<global>,1
518954,NAMESPACE_BLOCK,<empty>,,renderer\dx\CustomTextLayout.hpp,renderer\dx\CustomTextLayout.hpp:<global>,,<global>,1
518958,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class CustomTextLayout : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IDWriteTextAnalysisSource, IDWriteTextAnalysisSink>
    {
    public:
        // Based on the Windows 7 SDK sample at https://github.com/pauldotknopf/WindowsSDK7-Samples/tree/master/multimedia/DirectWrite/CustomLayout

        CustomTextLayout(const gsl::not_null<DxFontRenderData*> fontRenderData);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE AppendClusters(const std::span<const ::Microsoft::Console::Render::Cluster> clusters);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE Reset() noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetColumns(_Out_ UINT32* columns);

        // IDWriteTextLayout methods (but we don't actually want to implement them all, so just this one matching the existing interface)
        [[nodiscard]] HRESULT STDMETHODCALLTYPE Draw(_In_opt_ v...",1,renderer\dx\CustomTextLayout.hpp,Microsoft,17,Microsoft,1
518959,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class CustomTextLayout : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IDWriteTextAnalysisSource, IDWriteTextAnalysisSink>
    {
    public:
        // Based on the Windows 7 SDK sample at https://github.com/pauldotknopf/WindowsSDK7-Samples/tree/master/multimedia/DirectWrite/CustomLayout

        CustomTextLayout(const gsl::not_null<DxFontRenderData*> fontRenderData);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE AppendClusters(const std::span<const ::Microsoft::Console::Render::Cluster> clusters);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE Reset() noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetColumns(_Out_ UINT32* columns);

        // IDWriteTextLayout methods (but we don't actually want to implement them all, so just this one matching the existing interface)
        [[nodiscard]] HRESULT STDMETHODCALLTYPE Draw(_In_opt_ v...",1,renderer\dx\CustomTextLayout.hpp,Microsoft.Console,17,Console,1
518960,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class CustomTextLayout : public ::Microsoft::WRL::RuntimeClass<::Microsoft::WRL::RuntimeClassFlags<::Microsoft::WRL::ClassicCom | ::Microsoft::WRL::InhibitFtmBase>, IDWriteTextAnalysisSource, IDWriteTextAnalysisSink>
    {
    public:
        // Based on the Windows 7 SDK sample at https://github.com/pauldotknopf/WindowsSDK7-Samples/tree/master/multimedia/DirectWrite/CustomLayout

        CustomTextLayout(const gsl::not_null<DxFontRenderData*> fontRenderData);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE AppendClusters(const std::span<const ::Microsoft::Console::Render::Cluster> clusters);

        [[nodiscard]] HRESULT STDMETHODCALLTYPE Reset() noexcept;

        [[nodiscard]] HRESULT STDMETHODCALLTYPE GetColumns(_Out_ UINT32* columns);

        // IDWriteTextLayout methods (but we don't actually want to implement them all, so just this one matching the existing interface)
        [[nodiscard]] HRESULT STDMETHODCALLTYPE Draw(_In_opt_ v...",1,renderer\dx\CustomTextLayout.hpp,Microsoft.Console.Render,17,Render,1
519128,NAMESPACE_BLOCK,<empty>,,renderer\dx\CustomTextRenderer.cpp,renderer\dx\CustomTextRenderer.cpp:<global>,,<global>,1
519312,NAMESPACE_BLOCK,<empty>,,renderer\dx\CustomTextRenderer.hpp,renderer\dx\CustomTextRenderer.hpp:<global>,,<global>,1
519316,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext
    {
        DrawingContext(ID2D1RenderTarget* renderTarget,
                       ID2D1SolidColorBrush* foregroundBrush,
                       ID2D1SolidColorBrush* backgroundBrush,
                       bool forceGrayscaleAA,
                       IDWriteFactory* dwriteFactory,
                       const DWRITE_LINE_SPACING spacing,
                       const D2D_SIZE_F cellSize,
                       const D2D_SIZE_F targetSize,
                       const std::optional<CursorOptions>& cursorInfo,
                       const D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE) noexcept :
            renderTarget(renderTarget),
            foregroundBrush(foregroundBrush),
            backgroundBrush(backgroundBrush),
            useBoldFont(false),
            useItalicFont(false),
            forceGrayscaleAA(forceGrayscaleAA),
            dwriteFactory(dwriteFactory),
            spacing(spaci...",1,renderer\dx\CustomTextRenderer.hpp,Microsoft,10,Microsoft,1
519317,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext
    {
        DrawingContext(ID2D1RenderTarget* renderTarget,
                       ID2D1SolidColorBrush* foregroundBrush,
                       ID2D1SolidColorBrush* backgroundBrush,
                       bool forceGrayscaleAA,
                       IDWriteFactory* dwriteFactory,
                       const DWRITE_LINE_SPACING spacing,
                       const D2D_SIZE_F cellSize,
                       const D2D_SIZE_F targetSize,
                       const std::optional<CursorOptions>& cursorInfo,
                       const D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE) noexcept :
            renderTarget(renderTarget),
            foregroundBrush(foregroundBrush),
            backgroundBrush(backgroundBrush),
            useBoldFont(false),
            useItalicFont(false),
            forceGrayscaleAA(forceGrayscaleAA),
            dwriteFactory(dwriteFactory),
            spacing(spaci...",1,renderer\dx\CustomTextRenderer.hpp,Microsoft.Console,10,Console,1
519318,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext
    {
        DrawingContext(ID2D1RenderTarget* renderTarget,
                       ID2D1SolidColorBrush* foregroundBrush,
                       ID2D1SolidColorBrush* backgroundBrush,
                       bool forceGrayscaleAA,
                       IDWriteFactory* dwriteFactory,
                       const DWRITE_LINE_SPACING spacing,
                       const D2D_SIZE_F cellSize,
                       const D2D_SIZE_F targetSize,
                       const std::optional<CursorOptions>& cursorInfo,
                       const D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE) noexcept :
            renderTarget(renderTarget),
            foregroundBrush(foregroundBrush),
            backgroundBrush(backgroundBrush),
            useBoldFont(false),
            useItalicFont(false),
            forceGrayscaleAA(forceGrayscaleAA),
            dwriteFactory(dwriteFactory),
            spacing(spaci...",1,renderer\dx\CustomTextRenderer.hpp,Microsoft.Console.Render,10,Render,1
519407,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxFontInfo.cpp,renderer\dx\DxFontInfo.cpp:<global>,,<global>,1
519924,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxFontInfo.hpp,renderer\dx\DxFontInfo.hpp:<global>,,<global>,1
519928,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxFontInfo
    {
    public:
        DxFontInfo(IDWriteFactory1* dwriteFactory);

        DxFontInfo(
            IDWriteFactory1* dwriteFactory,
            std::wstring_view familyName,
            DWRITE_FONT_WEIGHT weight,
            DWRITE_FONT_STYLE style,
            DWRITE_FONT_STRETCH stretch);

        bool operator==(const DxFontInfo& other) const noexcept;

        std::wstring_view GetFamilyName() const noexcept;
        void SetFamilyName(const std::wstring_view familyName);

        DWRITE_FONT_WEIGHT GetWeight() const noexcept;
        void SetWeight(const DWRITE_FONT_WEIGHT weight) noexcept;

        DWRITE_FONT_STYLE GetStyle() const noexcept;
        void SetStyle(const DWRITE_FONT_STYLE style) noexcept;

        DWRITE_FONT_STRETCH GetStretch() const noexcept;
        void SetStretch(const DWRITE_FONT_STRETCH stretch) noexcept;

        bool GetFallback() const noexcept;
        IDWriteFontCollection* GetFontColle...",1,renderer\dx\DxFontInfo.hpp,Microsoft,11,Microsoft,1
519929,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxFontInfo
    {
    public:
        DxFontInfo(IDWriteFactory1* dwriteFactory);

        DxFontInfo(
            IDWriteFactory1* dwriteFactory,
            std::wstring_view familyName,
            DWRITE_FONT_WEIGHT weight,
            DWRITE_FONT_STYLE style,
            DWRITE_FONT_STRETCH stretch);

        bool operator==(const DxFontInfo& other) const noexcept;

        std::wstring_view GetFamilyName() const noexcept;
        void SetFamilyName(const std::wstring_view familyName);

        DWRITE_FONT_WEIGHT GetWeight() const noexcept;
        void SetWeight(const DWRITE_FONT_WEIGHT weight) noexcept;

        DWRITE_FONT_STYLE GetStyle() const noexcept;
        void SetStyle(const DWRITE_FONT_STYLE style) noexcept;

        DWRITE_FONT_STRETCH GetStretch() const noexcept;
        void SetStretch(const DWRITE_FONT_STRETCH stretch) noexcept;

        bool GetFallback() const noexcept;
        IDWriteFontCollection* GetFontColle...",1,renderer\dx\DxFontInfo.hpp,Microsoft.Console,11,Console,1
519930,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxFontInfo
    {
    public:
        DxFontInfo(IDWriteFactory1* dwriteFactory);

        DxFontInfo(
            IDWriteFactory1* dwriteFactory,
            std::wstring_view familyName,
            DWRITE_FONT_WEIGHT weight,
            DWRITE_FONT_STYLE style,
            DWRITE_FONT_STRETCH stretch);

        bool operator==(const DxFontInfo& other) const noexcept;

        std::wstring_view GetFamilyName() const noexcept;
        void SetFamilyName(const std::wstring_view familyName);

        DWRITE_FONT_WEIGHT GetWeight() const noexcept;
        void SetWeight(const DWRITE_FONT_WEIGHT weight) noexcept;

        DWRITE_FONT_STYLE GetStyle() const noexcept;
        void SetStyle(const DWRITE_FONT_STYLE style) noexcept;

        DWRITE_FONT_STRETCH GetStretch() const noexcept;
        void SetStretch(const DWRITE_FONT_STRETCH stretch) noexcept;

        bool GetFallback() const noexcept;
        IDWriteFontCollection* GetFontColle...",1,renderer\dx\DxFontInfo.hpp,Microsoft.Console.Render,11,Render,1
520032,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxFontRenderData.cpp,renderer\dx\DxFontRenderData.cpp:<global>,,<global>,1
521649,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxFontRenderData.hpp,renderer\dx\DxFontRenderData.hpp:<global>,,<global>,1
521653,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    enum class AxisTagPresence : BYTE
    {
        None = 0x00,
        Weight = 0x01,
        Width = 0x02,
        Italic = 0x04,
        Slant = 0x08,
    };
    DEFINE_ENUM_FLAG_OPERATORS(AxisTagPresence);

    class DxFontRenderData
    {
    public:
        struct LineMetrics
        {
            float gridlineWidth;
            float underlineOffset;
            float underlineOffset2;
            float underlineWidth;
            float strikethroughOffset;
            float strikethroughWidth;
        };

        DxFontRenderData(::Microsoft::WRL::ComPtr<IDWriteFactory1> dwriteFactory);

        // DirectWrite text analyzer from the factory
        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteTextAnalyzer1> Analyzer();

        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteFontFallback> SystemFontFallback();

        // A locale that can be used on construction of assorted DX objects that want to know one.
        [[nodiscard]] std::wstr...",1,renderer\dx\DxFontRenderData.hpp,Microsoft,17,Microsoft,1
521654,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    enum class AxisTagPresence : BYTE
    {
        None = 0x00,
        Weight = 0x01,
        Width = 0x02,
        Italic = 0x04,
        Slant = 0x08,
    };
    DEFINE_ENUM_FLAG_OPERATORS(AxisTagPresence);

    class DxFontRenderData
    {
    public:
        struct LineMetrics
        {
            float gridlineWidth;
            float underlineOffset;
            float underlineOffset2;
            float underlineWidth;
            float strikethroughOffset;
            float strikethroughWidth;
        };

        DxFontRenderData(::Microsoft::WRL::ComPtr<IDWriteFactory1> dwriteFactory);

        // DirectWrite text analyzer from the factory
        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteTextAnalyzer1> Analyzer();

        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteFontFallback> SystemFontFallback();

        // A locale that can be used on construction of assorted DX objects that want to know one.
        [[nodiscard]] std::wstr...",1,renderer\dx\DxFontRenderData.hpp,Microsoft.Console,17,Console,1
521655,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    enum class AxisTagPresence : BYTE
    {
        None = 0x00,
        Weight = 0x01,
        Width = 0x02,
        Italic = 0x04,
        Slant = 0x08,
    };
    DEFINE_ENUM_FLAG_OPERATORS(AxisTagPresence);

    class DxFontRenderData
    {
    public:
        struct LineMetrics
        {
            float gridlineWidth;
            float underlineOffset;
            float underlineOffset2;
            float underlineWidth;
            float strikethroughOffset;
            float strikethroughWidth;
        };

        DxFontRenderData(::Microsoft::WRL::ComPtr<IDWriteFactory1> dwriteFactory);

        // DirectWrite text analyzer from the factory
        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteTextAnalyzer1> Analyzer();

        [[nodiscard]] Microsoft::WRL::ComPtr<IDWriteFontFallback> SystemFontFallback();

        // A locale that can be used on construction of assorted DX objects that want to know one.
        [[nodiscard]] std::wstr...",1,renderer\dx\DxFontRenderData.hpp,Microsoft.Console.Render,17,Render,1
521909,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxRenderer.cpp,renderer\dx\DxRenderer.cpp:<global>,,<global>,1
521982,NAMESPACE_BLOCK,"namespace
{
    bool operator==(const D2D1::Matrix3x2F& lhs, const D2D1::Matrix3x2F& rhs) noexcept
    {
        return ::memcmp(&lhs.m[0][0], &rhs.m[0][0], sizeof(lhs.m)) == 0;
    };
}",1,renderer\dx\DxRenderer.cpp,anonymous_namespace_0,52,,9
523585,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxRenderer.hpp,renderer\dx\DxRenderer.hpp:<global>,,<global>,1
523590,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxEngine final : public RenderEngineBase
    {
    public:
        DxEngine();
        ~DxEngine();
        DxEngine(const DxEngine&) = default;
        DxEngine(DxEngine&&) = default;
        DxEngine& operator=(const DxEngine&) = default;
        DxEngine& operator=(DxEngine&&) = default;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept override;

        [[nodiscard]] HRESULT SetWindowSize(const til::size pixels) noexcept override;

        void SetCallback(std::function<void(const HANDLE)> pfn) noexcept override;
        void SetWarningCallback(std::function<void(const HRESULT)> pfn) noexcept override;

        boo...",1,renderer\dx\DxRenderer.hpp,Microsoft,38,Microsoft,2
523591,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxEngine final : public RenderEngineBase
    {
    public:
        DxEngine();
        ~DxEngine();
        DxEngine(const DxEngine&) = default;
        DxEngine(DxEngine&&) = default;
        DxEngine& operator=(const DxEngine&) = default;
        DxEngine& operator=(DxEngine&&) = default;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept override;

        [[nodiscard]] HRESULT SetWindowSize(const til::size pixels) noexcept override;

        void SetCallback(std::function<void(const HANDLE)> pfn) noexcept override;
        void SetWarningCallback(std::function<void(const HRESULT)> pfn) noexcept override;

        boo...",1,renderer\dx\DxRenderer.hpp,Microsoft.Console,38,Console,1
523592,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class DxEngine final : public RenderEngineBase
    {
    public:
        DxEngine();
        ~DxEngine();
        DxEngine(const DxEngine&) = default;
        DxEngine(DxEngine&&) = default;
        DxEngine& operator=(const DxEngine&) = default;
        DxEngine& operator=(DxEngine&&) = default;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept override;

        [[nodiscard]] HRESULT SetWindowSize(const til::size pixels) noexcept override;

        void SetCallback(std::function<void(const HANDLE)> pfn) noexcept override;
        void SetWarningCallback(std::function<void(const HRESULT)> pfn) noexcept override;

        boo...",1,renderer\dx\DxRenderer.hpp,Microsoft.Console.Render,38,Render,1
524076,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxSoftFont.cpp,renderer\dx\DxSoftFont.cpp:<global>,,<global>,1
524949,NAMESPACE_BLOCK,<empty>,,renderer\dx\DxSoftFont.hpp,renderer\dx\DxSoftFont.hpp:<global>,,<global>,1
524953,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext;

    class DxSoftFont
    {
    public:
        void SetFont(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        HRESULT SetTargetSize(const til::size targetSize);
        HRESULT SetAntialiasing(const bool antialiased);
        HRESULT SetColor(const D2D1_COLOR_F& color);
        HRESULT Draw(const DrawingContext& drawingContext,
                     const std::span<const Cluster> clusters,
                     const float originX,
                     const float originY);
        void Reset();

    private:
        static constexpr auto ANTIALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC;
        static constexpr auto ALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR;

        HRESULT _createResources(gsl::not_null<ID2D1Devi...",1,renderer\dx\DxSoftFont.hpp,Microsoft,13,Microsoft,1
524954,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext;

    class DxSoftFont
    {
    public:
        void SetFont(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        HRESULT SetTargetSize(const til::size targetSize);
        HRESULT SetAntialiasing(const bool antialiased);
        HRESULT SetColor(const D2D1_COLOR_F& color);
        HRESULT Draw(const DrawingContext& drawingContext,
                     const std::span<const Cluster> clusters,
                     const float originX,
                     const float originY);
        void Reset();

    private:
        static constexpr auto ANTIALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC;
        static constexpr auto ALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR;

        HRESULT _createResources(gsl::not_null<ID2D1Devi...",1,renderer\dx\DxSoftFont.hpp,Microsoft.Console,13,Console,1
524955,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct DrawingContext;

    class DxSoftFont
    {
    public:
        void SetFont(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        HRESULT SetTargetSize(const til::size targetSize);
        HRESULT SetAntialiasing(const bool antialiased);
        HRESULT SetColor(const D2D1_COLOR_F& color);
        HRESULT Draw(const DrawingContext& drawingContext,
                     const std::span<const Cluster> clusters,
                     const float originX,
                     const float originY);
        void Reset();

    private:
        static constexpr auto ANTIALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC;
        static constexpr auto ALIASED_INTERPOLATION = D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR;

        HRESULT _createResources(gsl::not_null<ID2D1Devi...",1,renderer\dx\DxSoftFont.hpp,Microsoft.Console.Render,13,Render,1
525048,NAMESPACE_BLOCK,<empty>,,renderer\dx\ScreenPixelShader.hpp,renderer\dx\ScreenPixelShader.hpp:<global>,,<global>,1
525058,NAMESPACE_BLOCK,<empty>,,renderer\dx\ScreenVertexShader.hpp,renderer\dx\ScreenVertexShader.hpp:<global>,,<global>,1
525069,NAMESPACE_BLOCK,<empty>,,renderer\dx\precomp.cpp,renderer\dx\precomp.cpp:<global>,,<global>,1
525120,NAMESPACE_BLOCK,<empty>,,renderer\dx\precomp.hpp,renderer\dx\precomp.hpp:<global>,,<global>,1
525133,NAMESPACE_BLOCK,<empty>,,renderer\dx\ut_dx\CustomTextLayoutTests.cpp,renderer\dx\ut_dx\CustomTextLayoutTests.cpp:<global>,,<global>,1
525336,NAMESPACE_BLOCK,<empty>,,renderer\gdi\gdirenderer.hpp,renderer\gdi\gdirenderer.hpp:<global>,,<global>,1
525340,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class GdiEngine final : public RenderEngineBase
    {
    public:
        GdiEngine();
        ~GdiEngine() override;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept;

        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* const pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT...",1,renderer\gdi\gdirenderer.hpp,Microsoft,20,Microsoft,1
525341,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class GdiEngine final : public RenderEngineBase
    {
    public:
        GdiEngine();
        ~GdiEngine() override;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept;

        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* const pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT...",1,renderer\gdi\gdirenderer.hpp,Microsoft.Console,20,Console,1
525342,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class GdiEngine final : public RenderEngineBase
    {
    public:
        GdiEngine();
        ~GdiEngine() override;

        [[nodiscard]] HRESULT SetHwnd(const HWND hwnd) noexcept;

        [[nodiscard]] HRESULT InvalidateSelection(const std::vector<til::rect>& rectangles) noexcept override;
        [[nodiscard]] HRESULT InvalidateScroll(const til::point* const pcoordDelta) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateAll() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT...",1,renderer\gdi\gdirenderer.hpp,Microsoft.Console.Render,20,Render,1
525701,NAMESPACE_BLOCK,<empty>,,renderer\gdi\invalidate.cpp,renderer\gdi\invalidate.cpp:<global>,,<global>,1
525980,NAMESPACE_BLOCK,<empty>,,renderer\gdi\math.cpp,renderer\gdi\math.cpp:<global>,,<global>,1
526110,NAMESPACE_BLOCK,<empty>,,renderer\gdi\paint.cpp,renderer\gdi\paint.cpp:<global>,,<global>,1
527499,NAMESPACE_BLOCK,<empty>,,renderer\gdi\precomp.cpp,renderer\gdi\precomp.cpp:<global>,,<global>,1
527518,NAMESPACE_BLOCK,<empty>,,renderer\gdi\precomp.hpp,renderer\gdi\precomp.hpp:<global>,,<global>,1
527533,NAMESPACE_BLOCK,<empty>,,renderer\gdi\state.cpp,renderer\gdi\state.cpp:<global>,,<global>,1
528125,NAMESPACE_BLOCK,<empty>,,renderer\gdi\tool\main.cpp,renderer\gdi\tool\main.cpp:<global>,,<global>,1
528180,NAMESPACE_BLOCK,<empty>,,renderer\inc\CSSLengthPercentage.hpp,renderer\inc\CSSLengthPercentage.hpp:<global>,,<global>,1
528220,NAMESPACE_BLOCK,<empty>,,renderer\inc\Cluster.hpp,renderer\inc\Cluster.hpp:<global>,,<global>,1
528224,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Cluster
    {
    public:
        constexpr Cluster() noexcept = default;
        constexpr Cluster(const std::wstring_view text, const til::CoordType columns) noexcept :
            _text{ text },
            _columns{ columns }
        {
        }

        // Provides the embedded text as a single character
        // This might replace the string with the replacement character if it doesn't fit as one wchar_t.
        constexpr wchar_t GetTextAsSingle() const noexcept
        {
            if (_text.size() == 1)
            {
                return til::at(_text, 0);
            }
            else
            {
                return UNICODE_REPLACEMENT;
            }
        }

        // Provides the string of wchar_ts for this cluster.
        constexpr std::wstring_view GetText() const noexcept
        {
            return _text;
        }

        // Gets the number of columns in the grid that this character should consume
   ...",1,renderer\inc\Cluster.hpp,Microsoft,21,Microsoft,1
528225,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Cluster
    {
    public:
        constexpr Cluster() noexcept = default;
        constexpr Cluster(const std::wstring_view text, const til::CoordType columns) noexcept :
            _text{ text },
            _columns{ columns }
        {
        }

        // Provides the embedded text as a single character
        // This might replace the string with the replacement character if it doesn't fit as one wchar_t.
        constexpr wchar_t GetTextAsSingle() const noexcept
        {
            if (_text.size() == 1)
            {
                return til::at(_text, 0);
            }
            else
            {
                return UNICODE_REPLACEMENT;
            }
        }

        // Provides the string of wchar_ts for this cluster.
        constexpr std::wstring_view GetText() const noexcept
        {
            return _text;
        }

        // Gets the number of columns in the grid that this character should consume
   ...",1,renderer\inc\Cluster.hpp,Microsoft.Console,21,Console,1
528226,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Cluster
    {
    public:
        constexpr Cluster() noexcept = default;
        constexpr Cluster(const std::wstring_view text, const til::CoordType columns) noexcept :
            _text{ text },
            _columns{ columns }
        {
        }

        // Provides the embedded text as a single character
        // This might replace the string with the replacement character if it doesn't fit as one wchar_t.
        constexpr wchar_t GetTextAsSingle() const noexcept
        {
            if (_text.size() == 1)
            {
                return til::at(_text, 0);
            }
            else
            {
                return UNICODE_REPLACEMENT;
            }
        }

        // Provides the string of wchar_ts for this cluster.
        constexpr std::wstring_view GetText() const noexcept
        {
            return _text;
        }

        // Gets the number of columns in the grid that this character should consume
   ...",1,renderer\inc\Cluster.hpp,Microsoft.Console.Render,21,Render,1
528287,NAMESPACE_BLOCK,<empty>,,renderer\inc\CursorOptions.hpp,renderer\inc\CursorOptions.hpp:<global>,,<global>,1
528291,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct CursorOptions
    {
        // Character cell in the grid to draw at
        // This is relative to the top of the viewport, not the buffer
        til::point coordCursor;

        // Left offset of the viewport, which may alter the horizontal position
        til::CoordType viewportLeft;

        // Line rendition of the current row, which can affect the cursor width
        LineRendition lineRendition;

        // For an underscore type _ cursor, how tall it should be as a % of cell height
        ULONG ulCursorHeightPercent;

        // For a vertical bar type | cursor, how many pixels wide it should be per ease of access preferences
        ULONG cursorPixelWidth;

        // Whether to draw the cursor 2 cells wide (+X from the coordinate given)
        bool fIsDoubleWidth;

        // Chooses a special cursor type like a full box, a vertical bar, etc.
        CursorType cursorType;

        // Specifies to use the color below in...",1,renderer\inc\CursorOptions.hpp,Microsoft,20,Microsoft,1
528292,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct CursorOptions
    {
        // Character cell in the grid to draw at
        // This is relative to the top of the viewport, not the buffer
        til::point coordCursor;

        // Left offset of the viewport, which may alter the horizontal position
        til::CoordType viewportLeft;

        // Line rendition of the current row, which can affect the cursor width
        LineRendition lineRendition;

        // For an underscore type _ cursor, how tall it should be as a % of cell height
        ULONG ulCursorHeightPercent;

        // For a vertical bar type | cursor, how many pixels wide it should be per ease of access preferences
        ULONG cursorPixelWidth;

        // Whether to draw the cursor 2 cells wide (+X from the coordinate given)
        bool fIsDoubleWidth;

        // Chooses a special cursor type like a full box, a vertical bar, etc.
        CursorType cursorType;

        // Specifies to use the color below in...",1,renderer\inc\CursorOptions.hpp,Microsoft.Console,20,Console,1
528293,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct CursorOptions
    {
        // Character cell in the grid to draw at
        // This is relative to the top of the viewport, not the buffer
        til::point coordCursor;

        // Left offset of the viewport, which may alter the horizontal position
        til::CoordType viewportLeft;

        // Line rendition of the current row, which can affect the cursor width
        LineRendition lineRendition;

        // For an underscore type _ cursor, how tall it should be as a % of cell height
        ULONG ulCursorHeightPercent;

        // For a vertical bar type | cursor, how many pixels wide it should be per ease of access preferences
        ULONG cursorPixelWidth;

        // Whether to draw the cursor 2 cells wide (+X from the coordinate given)
        bool fIsDoubleWidth;

        // Chooses a special cursor type like a full box, a vertical bar, etc.
        CursorType cursorType;

        // Specifies to use the color below in...",1,renderer\inc\CursorOptions.hpp,Microsoft.Console.Render,20,Render,1
528308,NAMESPACE_BLOCK,<empty>,,renderer\inc\DummyRenderer.hpp,renderer\inc\DummyRenderer.hpp:<global>,,<global>,1
528322,NAMESPACE_BLOCK,<empty>,,renderer\inc\FontInfo.hpp,renderer\inc\FontInfo.hpp:<global>,,<global>,1
528383,NAMESPACE_BLOCK,<empty>,,renderer\inc\FontInfoBase.hpp,renderer\inc\FontInfoBase.hpp:<global>,,<global>,1
528471,NAMESPACE_BLOCK,<empty>,,renderer\inc\FontInfoDesired.hpp,renderer\inc\FontInfoDesired.hpp:<global>,,<global>,1
528526,NAMESPACE_BLOCK,<empty>,,renderer\inc\FontResource.hpp,renderer\inc\FontResource.hpp:<global>,,<global>,1
528530,NAMESPACE_BLOCK,"namespace wil
{
    typedef unique_any<HANDLE, decltype(&::RemoveFontMemResourceEx), ::RemoveFontMemResourceEx> unique_hfontresource;
}",1,renderer\inc\FontResource.hpp,wil,14,wil,1
528532,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class FontResource
    {
    public:
        FontResource(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        FontResource() = default;
        ~FontResource() = default;
        FontResource& operator=(FontResource&&) = default;
        void SetTargetSize(const til::size targetSize);
        operator HFONT();

    private:
        void _regenerateFont();
        void _resizeBitPattern(std::span<byte> targetBuffer);

        std::vector<uint16_t> _bitPattern;
        til::size _sourceSize;
        til::size _targetSize;
        size_t _centeringHint{ 0 };
        wil::unique_hfontresource _resourceHandle;
        wil::unique_hfont _fontHandle;
    };
}",1,renderer\inc\FontResource.hpp,Microsoft,19,Microsoft,2
528533,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class FontResource
    {
    public:
        FontResource(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        FontResource() = default;
        ~FontResource() = default;
        FontResource& operator=(FontResource&&) = default;
        void SetTargetSize(const til::size targetSize);
        operator HFONT();

    private:
        void _regenerateFont();
        void _resizeBitPattern(std::span<byte> targetBuffer);

        std::vector<uint16_t> _bitPattern;
        til::size _sourceSize;
        til::size _targetSize;
        size_t _centeringHint{ 0 };
        wil::unique_hfontresource _resourceHandle;
        wil::unique_hfont _fontHandle;
    };
}",1,renderer\inc\FontResource.hpp,Microsoft.Console,19,Console,1
528534,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class FontResource
    {
    public:
        FontResource(const std::span<const uint16_t> bitPattern,
                     const til::size sourceSize,
                     const til::size targetSize,
                     const size_t centeringHint);
        FontResource() = default;
        ~FontResource() = default;
        FontResource& operator=(FontResource&&) = default;
        void SetTargetSize(const til::size targetSize);
        operator HFONT();

    private:
        void _regenerateFont();
        void _resizeBitPattern(std::span<byte> targetBuffer);

        std::vector<uint16_t> _bitPattern;
        til::size _sourceSize;
        til::size _targetSize;
        size_t _centeringHint{ 0 };
        wil::unique_hfontresource _resourceHandle;
        wil::unique_hfont _fontHandle;
    };
}",1,renderer\inc\FontResource.hpp,Microsoft.Console.Render,19,Render,1
528590,NAMESPACE_BLOCK,<empty>,,renderer\inc\IFontDefaultList.hpp,renderer\inc\IFontDefaultList.hpp:<global>,,<global>,1
528594,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class IFontDefaultList
    {
    public:
        [[nodiscard]] virtual HRESULT RetrieveDefaultFontNameForCodepage(const unsigned int codepage,
                                                                         std::wstring& outFaceName) = 0;
    };
}",1,renderer\inc\IFontDefaultList.hpp,Microsoft,16,Microsoft,1
528595,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class IFontDefaultList
    {
    public:
        [[nodiscard]] virtual HRESULT RetrieveDefaultFontNameForCodepage(const unsigned int codepage,
                                                                         std::wstring& outFaceName) = 0;
    };
}",1,renderer\inc\IFontDefaultList.hpp,Microsoft.Console,16,Console,1
528596,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class IFontDefaultList
    {
    public:
        [[nodiscard]] virtual HRESULT RetrieveDefaultFontNameForCodepage(const unsigned int codepage,
                                                                         std::wstring& outFaceName) = 0;
    };
}",1,renderer\inc\IFontDefaultList.hpp,Microsoft.Console.Render,16,Render,1
528609,NAMESPACE_BLOCK,<empty>,,renderer\inc\IRenderData.hpp,renderer\inc\IRenderData.hpp:<global>,,<global>,1
528614,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderOverlay final
    {
        // This is where the data is stored
        const TextBuffer& buffer;

        // This is where the top left of the stored buffer should be overlaid on the screen
        // (relative to the current visible viewport)
        const til::point origin;

        // This is the area of the buffer that is actually used for overlay.
        // Anything outside of this is considered empty by the overlay and shouldn't be used
        // for painting purposes.
        const Microsoft::Console::Types::Viewport region;
    };

    class IRenderData
    {
    public:
        virtual ~IRenderData() = default;

        // This block used to be IBaseData.
        virtual Microsoft::Console::Types::Viewport GetViewport() noexcept = 0;
        virtual til::point GetTextBufferEndPosition() const noexcept = 0;
        virtual const TextBuffer& GetTextBuffer() const noexcept = 0;
        virtual const FontInfo& GetFontIn...",1,renderer\inc\IRenderData.hpp,Microsoft,22,Microsoft,2
528615,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderOverlay final
    {
        // This is where the data is stored
        const TextBuffer& buffer;

        // This is where the top left of the stored buffer should be overlaid on the screen
        // (relative to the current visible viewport)
        const til::point origin;

        // This is the area of the buffer that is actually used for overlay.
        // Anything outside of this is considered empty by the overlay and shouldn't be used
        // for painting purposes.
        const Microsoft::Console::Types::Viewport region;
    };

    class IRenderData
    {
    public:
        virtual ~IRenderData() = default;

        // This block used to be IBaseData.
        virtual Microsoft::Console::Types::Viewport GetViewport() noexcept = 0;
        virtual til::point GetTextBufferEndPosition() const noexcept = 0;
        virtual const TextBuffer& GetTextBuffer() const noexcept = 0;
        virtual const FontInfo& GetFontIn...",1,renderer\inc\IRenderData.hpp,Microsoft.Console,22,Console,1
528616,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderOverlay final
    {
        // This is where the data is stored
        const TextBuffer& buffer;

        // This is where the top left of the stored buffer should be overlaid on the screen
        // (relative to the current visible viewport)
        const til::point origin;

        // This is the area of the buffer that is actually used for overlay.
        // Anything outside of this is considered empty by the overlay and shouldn't be used
        // for painting purposes.
        const Microsoft::Console::Types::Viewport region;
    };

    class IRenderData
    {
    public:
        virtual ~IRenderData() = default;

        // This block used to be IBaseData.
        virtual Microsoft::Console::Types::Viewport GetViewport() noexcept = 0;
        virtual til::point GetTextBufferEndPosition() const noexcept = 0;
        virtual const TextBuffer& GetTextBuffer() const noexcept = 0;
        virtual const FontInfo& GetFontIn...",1,renderer\inc\IRenderData.hpp,Microsoft.Console.Render,22,Render,1
528759,NAMESPACE_BLOCK,<empty>,,renderer\inc\IRenderEngine.hpp,renderer\inc\IRenderEngine.hpp:<global>,,<global>,1
528763,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderFrameInfo
    {
        std::optional<CursorOptions> cursorInfo;
    };

    enum class GridLines
    {
        None,
        Top,
        Bottom,
        Left,
        Right,
        Underline,
        DoubleUnderline,
        CurlyUnderline,
        DottedUnderline,
        DashedUnderline,
        Strikethrough,
        HyperlinkUnderline
    };
    using GridLineSet = til::enumset<GridLines>;

    class __declspec(novtable) IRenderEngine
    {
    public:
#pragma warning(suppress : 26432) // If you define or delete any default operation in the type '...', define or delete them all (c.21).
        virtual ~IRenderEngine() = default;

        [[nodiscard]] virtual HRESULT StartPaint() noexcept = 0;
        [[nodiscard]] virtual HRESULT EndPaint() noexcept = 0;
        [[nodiscard]] virtual bool RequiresContinuousRedraw() noexcept = 0;
        virtual void WaitUntilCanRender() noexcept = 0;
        [[nodiscard]] virtual HRESUL...",1,renderer\inc\IRenderEngine.hpp,Microsoft,28,Microsoft,1
528764,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderFrameInfo
    {
        std::optional<CursorOptions> cursorInfo;
    };

    enum class GridLines
    {
        None,
        Top,
        Bottom,
        Left,
        Right,
        Underline,
        DoubleUnderline,
        CurlyUnderline,
        DottedUnderline,
        DashedUnderline,
        Strikethrough,
        HyperlinkUnderline
    };
    using GridLineSet = til::enumset<GridLines>;

    class __declspec(novtable) IRenderEngine
    {
    public:
#pragma warning(suppress : 26432) // If you define or delete any default operation in the type '...', define or delete them all (c.21).
        virtual ~IRenderEngine() = default;

        [[nodiscard]] virtual HRESULT StartPaint() noexcept = 0;
        [[nodiscard]] virtual HRESULT EndPaint() noexcept = 0;
        [[nodiscard]] virtual bool RequiresContinuousRedraw() noexcept = 0;
        virtual void WaitUntilCanRender() noexcept = 0;
        [[nodiscard]] virtual HRESUL...",1,renderer\inc\IRenderEngine.hpp,Microsoft.Console,28,Console,1
528765,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    struct RenderFrameInfo
    {
        std::optional<CursorOptions> cursorInfo;
    };

    enum class GridLines
    {
        None,
        Top,
        Bottom,
        Left,
        Right,
        Underline,
        DoubleUnderline,
        CurlyUnderline,
        DottedUnderline,
        DashedUnderline,
        Strikethrough,
        HyperlinkUnderline
    };
    using GridLineSet = til::enumset<GridLines>;

    class __declspec(novtable) IRenderEngine
    {
    public:
#pragma warning(suppress : 26432) // If you define or delete any default operation in the type '...', define or delete them all (c.21).
        virtual ~IRenderEngine() = default;

        [[nodiscard]] virtual HRESULT StartPaint() noexcept = 0;
        [[nodiscard]] virtual HRESULT EndPaint() noexcept = 0;
        [[nodiscard]] virtual bool RequiresContinuousRedraw() noexcept = 0;
        virtual void WaitUntilCanRender() noexcept = 0;
        [[nodiscard]] virtual HRESUL...",1,renderer\inc\IRenderEngine.hpp,Microsoft.Console.Render,28,Render,1
529064,NAMESPACE_BLOCK,<empty>,,renderer\inc\RenderEngineBase.hpp,renderer\inc\RenderEngineBase.hpp:<global>,,<global>,1
529068,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderEngineBase : public IRenderEngine
    {
    public:
        [[nodiscard]] HRESULT InvalidateTitle(const std::wstring_view proposedTitle) noexcept override;

        [[nodiscard]] HRESULT UpdateTitle(const std::wstring_view newTitle) noexcept override;

        [[nodiscard]] HRESULT NotifyNewText(const std::wstring_view newText) noexcept override;

        [[nodiscard]] HRESULT UpdateSoftFont(const std::span<const uint16_t> bitPattern,
                                             const til::size cellSize,
                                             const size_t centeringHint) noexcept override;

        [[nodiscard]] HRESULT PrepareRenderInfo(const RenderFrameInfo& info) noexcept override;

        [[nodiscard]] HRESULT ResetLineTransform() noexcept override;
        [[nodiscard]] HRESULT PrepareLineTransform(const LineRendition lineRendition,
                                                   const til::CoordType targetRow,
   ...",1,renderer\inc\RenderEngineBase.hpp,Microsoft,22,Microsoft,1
529069,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderEngineBase : public IRenderEngine
    {
    public:
        [[nodiscard]] HRESULT InvalidateTitle(const std::wstring_view proposedTitle) noexcept override;

        [[nodiscard]] HRESULT UpdateTitle(const std::wstring_view newTitle) noexcept override;

        [[nodiscard]] HRESULT NotifyNewText(const std::wstring_view newText) noexcept override;

        [[nodiscard]] HRESULT UpdateSoftFont(const std::span<const uint16_t> bitPattern,
                                             const til::size cellSize,
                                             const size_t centeringHint) noexcept override;

        [[nodiscard]] HRESULT PrepareRenderInfo(const RenderFrameInfo& info) noexcept override;

        [[nodiscard]] HRESULT ResetLineTransform() noexcept override;
        [[nodiscard]] HRESULT PrepareLineTransform(const LineRendition lineRendition,
                                                   const til::CoordType targetRow,
   ...",1,renderer\inc\RenderEngineBase.hpp,Microsoft.Console,22,Console,1
529070,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderEngineBase : public IRenderEngine
    {
    public:
        [[nodiscard]] HRESULT InvalidateTitle(const std::wstring_view proposedTitle) noexcept override;

        [[nodiscard]] HRESULT UpdateTitle(const std::wstring_view newTitle) noexcept override;

        [[nodiscard]] HRESULT NotifyNewText(const std::wstring_view newText) noexcept override;

        [[nodiscard]] HRESULT UpdateSoftFont(const std::span<const uint16_t> bitPattern,
                                             const til::size cellSize,
                                             const size_t centeringHint) noexcept override;

        [[nodiscard]] HRESULT PrepareRenderInfo(const RenderFrameInfo& info) noexcept override;

        [[nodiscard]] HRESULT ResetLineTransform() noexcept override;
        [[nodiscard]] HRESULT PrepareLineTransform(const LineRendition lineRendition,
                                                   const til::CoordType targetRow,
   ...",1,renderer\inc\RenderEngineBase.hpp,Microsoft.Console.Render,22,Render,1
529136,NAMESPACE_BLOCK,<empty>,,renderer\inc\RenderSettings.hpp,renderer\inc\RenderSettings.hpp:<global>,,<global>,1
529140,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderSettings
    {
    public:
        enum class Mode : size_t
        {
            BlinkAllowed,
            IndexedDistinguishableColors,
            AlwaysDistinguishableColors,
            IntenseIsBold,
            IntenseIsBright,
            ScreenReversed
        };

        RenderSettings() noexcept;
        void SetRenderMode(const Mode mode, const bool enabled) noexcept;
        bool GetRenderMode(const Mode mode) const noexcept;
        const std::array<COLORREF, TextColor::TABLE_SIZE>& GetColorTable() const noexcept;
        void ResetColorTable() noexcept;
        void SetColorTableEntry(const size_t tableIndex, const COLORREF color);
        COLORREF GetColorTableEntry(const size_t tableIndex) const;
        void SetColorAlias(const ColorAlias alias, const size_t tableIndex, const COLORREF color);
        COLORREF GetColorAlias(const ColorAlias alias) const;
        void SetColorAliasIndex(const ColorAlias alias, co...",1,renderer\inc\RenderSettings.hpp,Microsoft,16,Microsoft,1
529141,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderSettings
    {
    public:
        enum class Mode : size_t
        {
            BlinkAllowed,
            IndexedDistinguishableColors,
            AlwaysDistinguishableColors,
            IntenseIsBold,
            IntenseIsBright,
            ScreenReversed
        };

        RenderSettings() noexcept;
        void SetRenderMode(const Mode mode, const bool enabled) noexcept;
        bool GetRenderMode(const Mode mode) const noexcept;
        const std::array<COLORREF, TextColor::TABLE_SIZE>& GetColorTable() const noexcept;
        void ResetColorTable() noexcept;
        void SetColorTableEntry(const size_t tableIndex, const COLORREF color);
        COLORREF GetColorTableEntry(const size_t tableIndex) const;
        void SetColorAlias(const ColorAlias alias, const size_t tableIndex, const COLORREF color);
        COLORREF GetColorAlias(const ColorAlias alias) const;
        void SetColorAliasIndex(const ColorAlias alias, co...",1,renderer\inc\RenderSettings.hpp,Microsoft.Console,16,Console,1
529142,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class RenderSettings
    {
    public:
        enum class Mode : size_t
        {
            BlinkAllowed,
            IndexedDistinguishableColors,
            AlwaysDistinguishableColors,
            IntenseIsBold,
            IntenseIsBright,
            ScreenReversed
        };

        RenderSettings() noexcept;
        void SetRenderMode(const Mode mode, const bool enabled) noexcept;
        bool GetRenderMode(const Mode mode) const noexcept;
        const std::array<COLORREF, TextColor::TABLE_SIZE>& GetColorTable() const noexcept;
        void ResetColorTable() noexcept;
        void SetColorTableEntry(const size_t tableIndex, const COLORREF color);
        COLORREF GetColorTableEntry(const size_t tableIndex) const;
        void SetColorAlias(const ColorAlias alias, const size_t tableIndex, const COLORREF color);
        COLORREF GetColorAlias(const ColorAlias alias) const;
        void SetColorAliasIndex(const ColorAlias alias, co...",1,renderer\inc\RenderSettings.hpp,Microsoft.Console.Render,16,Render,1
529261,NAMESPACE_BLOCK,<empty>,,renderer\uia\UiaRenderer.cpp,renderer\uia\UiaRenderer.cpp:<global>,,<global>,1
529575,NAMESPACE_BLOCK,<empty>,,renderer\uia\UiaRenderer.hpp,renderer\uia\UiaRenderer.hpp:<global>,,<global>,1
529579,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class UiaEngine final : public RenderEngineBase
    {
    public:
        UiaEngine(Microsoft::Console::Types::IUiaEventDispatcher* dispatcher);

        // Only one UiaEngine may present information at a time.
        // This ensures that an automation client isn't overwhelmed
        // by events when there are multiple TermControls
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noex...",1,renderer\uia\UiaRenderer.hpp,Microsoft,23,Microsoft,1
529580,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class UiaEngine final : public RenderEngineBase
    {
    public:
        UiaEngine(Microsoft::Console::Types::IUiaEventDispatcher* dispatcher);

        // Only one UiaEngine may present information at a time.
        // This ensures that an automation client isn't overwhelmed
        // by events when there are multiple TermControls
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noex...",1,renderer\uia\UiaRenderer.hpp,Microsoft.Console,23,Console,1
529581,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class UiaEngine final : public RenderEngineBase
    {
    public:
        UiaEngine(Microsoft::Console::Types::IUiaEventDispatcher* dispatcher);

        // Only one UiaEngine may present information at a time.
        // This ensures that an automation client isn't overwhelmed
        // by events when there are multiple TermControls
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        void WaitUntilCanRender() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;
        [[nodiscard]] HRESULT ScrollFrame() noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noex...",1,renderer\uia\UiaRenderer.hpp,Microsoft.Console.Render,23,Render,1
529728,NAMESPACE_BLOCK,<empty>,,renderer\uia\precomp.cpp,renderer\uia\precomp.cpp:<global>,,<global>,1
529737,NAMESPACE_BLOCK,<empty>,,renderer\uia\precomp.hpp,renderer\uia\precomp.hpp:<global>,,<global>,1
529750,NAMESPACE_BLOCK,<empty>,,renderer\vt\VtSequences.cpp,renderer\vt\VtSequences.cpp:<global>,,<global>,1
530310,NAMESPACE_BLOCK,<empty>,,renderer\vt\Xterm256Engine.cpp,renderer\vt\Xterm256Engine.cpp:<global>,,<global>,1
530713,NAMESPACE_BLOCK,<empty>,,renderer\vt\Xterm256Engine.hpp,renderer\vt\Xterm256Engine.hpp:<global>,,<global>,1
530718,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Xterm256Engine : public XtermEngine
    {
    public:
        Xterm256Engine(_In_ wil::unique_hfile hPipe,
                       const Microsoft::Console::Types::Viewport initialViewport);

        virtual ~Xterm256Engine() override = default;

        [[nodiscard]] HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                   const RenderSettings& renderSettings,
                                                   const gsl::not_null<IRenderData*> pData,
                                                   const bool usingSoftFont,
                                                   const bool isSettingDefaultBrushes) noexcept override;

        [[nodiscard]] HRESULT ManuallyClearScrollback() noexcept override;

        friend class ::VtApiRoutines;

    private:
        [[nodiscard]] HRESULT _UpdateExtendedAttrs(const TextAttribute& textAttributes) noexcept;
        [[nodiscard]] H...",1,renderer\vt\Xterm256Engine.hpp,Microsoft,23,Microsoft,2
530719,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Xterm256Engine : public XtermEngine
    {
    public:
        Xterm256Engine(_In_ wil::unique_hfile hPipe,
                       const Microsoft::Console::Types::Viewport initialViewport);

        virtual ~Xterm256Engine() override = default;

        [[nodiscard]] HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                   const RenderSettings& renderSettings,
                                                   const gsl::not_null<IRenderData*> pData,
                                                   const bool usingSoftFont,
                                                   const bool isSettingDefaultBrushes) noexcept override;

        [[nodiscard]] HRESULT ManuallyClearScrollback() noexcept override;

        friend class ::VtApiRoutines;

    private:
        [[nodiscard]] HRESULT _UpdateExtendedAttrs(const TextAttribute& textAttributes) noexcept;
        [[nodiscard]] H...",1,renderer\vt\Xterm256Engine.hpp,Microsoft.Console,23,Console,1
530720,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class Xterm256Engine : public XtermEngine
    {
    public:
        Xterm256Engine(_In_ wil::unique_hfile hPipe,
                       const Microsoft::Console::Types::Viewport initialViewport);

        virtual ~Xterm256Engine() override = default;

        [[nodiscard]] HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                   const RenderSettings& renderSettings,
                                                   const gsl::not_null<IRenderData*> pData,
                                                   const bool usingSoftFont,
                                                   const bool isSettingDefaultBrushes) noexcept override;

        [[nodiscard]] HRESULT ManuallyClearScrollback() noexcept override;

        friend class ::VtApiRoutines;

    private:
        [[nodiscard]] HRESULT _UpdateExtendedAttrs(const TextAttribute& textAttributes) noexcept;
        [[nodiscard]] H...",1,renderer\vt\Xterm256Engine.hpp,Microsoft.Console.Render,23,Render,1
530761,NAMESPACE_BLOCK,<empty>,,renderer\vt\XtermEngine.cpp,renderer\vt\XtermEngine.cpp:<global>,,<global>,1
531413,NAMESPACE_BLOCK,<empty>,,renderer\vt\XtermEngine.hpp,renderer\vt\XtermEngine.hpp:<global>,,<global>,1
531417,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class XtermEngine : public VtEngine
    {
    public:
        XtermEngine(_In_ wil::unique_hfile hPipe,
                    const Microsoft::Console::Types::Viewport initialViewport,
                    const bool fUseAsciiOnly);

        virtual ~XtermEngine() override = default;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;

        [[nodiscard]] HRESULT PaintCursor(const CursorOptions& options) noexcept override;

        [[nodiscard]] virtual HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                           const RenderSettings& renderSettings,
                                                           const gsl::not_null<IRenderData*> pData,
                                                           const bool usingSoftFont,
                                                           const bool isSettin...",1,renderer\vt\XtermEngine.hpp,Microsoft,25,Microsoft,1
531418,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class XtermEngine : public VtEngine
    {
    public:
        XtermEngine(_In_ wil::unique_hfile hPipe,
                    const Microsoft::Console::Types::Viewport initialViewport,
                    const bool fUseAsciiOnly);

        virtual ~XtermEngine() override = default;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;

        [[nodiscard]] HRESULT PaintCursor(const CursorOptions& options) noexcept override;

        [[nodiscard]] virtual HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                           const RenderSettings& renderSettings,
                                                           const gsl::not_null<IRenderData*> pData,
                                                           const bool usingSoftFont,
                                                           const bool isSettin...",1,renderer\vt\XtermEngine.hpp,Microsoft.Console,25,Console,1
531419,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class XtermEngine : public VtEngine
    {
    public:
        XtermEngine(_In_ wil::unique_hfile hPipe,
                    const Microsoft::Console::Types::Viewport initialViewport,
                    const bool fUseAsciiOnly);

        virtual ~XtermEngine() override = default;

        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;

        [[nodiscard]] HRESULT PaintCursor(const CursorOptions& options) noexcept override;

        [[nodiscard]] virtual HRESULT UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                           const RenderSettings& renderSettings,
                                                           const gsl::not_null<IRenderData*> pData,
                                                           const bool usingSoftFont,
                                                           const bool isSettin...",1,renderer\vt\XtermEngine.hpp,Microsoft.Console.Render,25,Render,1
531507,NAMESPACE_BLOCK,<empty>,,renderer\vt\invalidate.cpp,renderer\vt\invalidate.cpp:<global>,,<global>,1
531562,NAMESPACE_BLOCK,<empty>,,renderer\vt\math.cpp,renderer\vt\math.cpp:<global>,,<global>,1
531651,NAMESPACE_BLOCK,<empty>,,renderer\vt\paint.cpp,renderer\vt\paint.cpp:<global>,,<global>,1
532766,NAMESPACE_BLOCK,<empty>,,renderer\vt\precomp.cpp,renderer\vt\precomp.cpp:<global>,,<global>,1
532783,NAMESPACE_BLOCK,<empty>,,renderer\vt\precomp.hpp,renderer\vt\precomp.hpp:<global>,,<global>,1
532800,NAMESPACE_BLOCK,<empty>,,renderer\vt\state.cpp,renderer\vt\state.cpp:<global>,,<global>,1
533257,NAMESPACE_BLOCK,<empty>,,renderer\vt\tracing.cpp,renderer\vt\tracing.cpp:<global>,,<global>,1
533941,NAMESPACE_BLOCK,<empty>,,renderer\vt\tracing.hpp,renderer\vt\tracing.hpp:<global>,,<global>,1
533946,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class RenderTracing final
    {
    public:
        RenderTracing();
        ~RenderTracing();
        void TraceStringFill(const size_t n, const char c) const;
        void TraceString(const std::string_view& str) const;
        void TraceInvalidate(const til::rect& view) const;
        void TraceLastText(const til::point lastText) const;
        void TraceScrollFrame(const til::point scrollDelta) const;
        void TraceMoveCursor(const til::point lastText, const til::point cursor) const;
        void TraceSetWrapped(const til::CoordType wrappedRow) const;
        void TraceClearWrapped() const;
        void TraceWrapped() const;
        void TracePaintCursor(const til::point coordCursor) const;
        void TraceInvalidateAll(const til::rect& view) const;
        void TraceTriggerCircling(const bool newFrame) const;
        void TraceInvalidateScroll(const til::point scroll) const;
        void TraceStartPaint(const bool quickR...",1,renderer\vt\tracing.hpp,Microsoft,22,Microsoft,2
533947,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class RenderTracing final
    {
    public:
        RenderTracing();
        ~RenderTracing();
        void TraceStringFill(const size_t n, const char c) const;
        void TraceString(const std::string_view& str) const;
        void TraceInvalidate(const til::rect& view) const;
        void TraceLastText(const til::point lastText) const;
        void TraceScrollFrame(const til::point scrollDelta) const;
        void TraceMoveCursor(const til::point lastText, const til::point cursor) const;
        void TraceSetWrapped(const til::CoordType wrappedRow) const;
        void TraceClearWrapped() const;
        void TraceWrapped() const;
        void TracePaintCursor(const til::point coordCursor) const;
        void TraceInvalidateAll(const til::rect& view) const;
        void TraceTriggerCircling(const bool newFrame) const;
        void TraceInvalidateScroll(const til::point scroll) const;
        void TraceStartPaint(const bool quickR...",1,renderer\vt\tracing.hpp,Microsoft.Console,22,Console,1
533948,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class RenderTracing final
    {
    public:
        RenderTracing();
        ~RenderTracing();
        void TraceStringFill(const size_t n, const char c) const;
        void TraceString(const std::string_view& str) const;
        void TraceInvalidate(const til::rect& view) const;
        void TraceLastText(const til::point lastText) const;
        void TraceScrollFrame(const til::point scrollDelta) const;
        void TraceMoveCursor(const til::point lastText, const til::point cursor) const;
        void TraceSetWrapped(const til::CoordType wrappedRow) const;
        void TraceClearWrapped() const;
        void TraceWrapped() const;
        void TracePaintCursor(const til::point coordCursor) const;
        void TraceInvalidateAll(const til::rect& view) const;
        void TraceTriggerCircling(const bool newFrame) const;
        void TraceInvalidateScroll(const til::point scroll) const;
        void TraceStartPaint(const bool quickR...",1,renderer\vt\tracing.hpp,Microsoft.Console.VirtualTerminal,22,VirtualTerminal,1
534048,NAMESPACE_BLOCK,<empty>,,renderer\vt\vtrenderer.hpp,renderer\vt\vtrenderer.hpp:<global>,,<global>,1
534052,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo;
}",1,renderer\vt\vtrenderer.hpp,Microsoft,33,Microsoft,1
534053,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo;
}",1,renderer\vt\vtrenderer.hpp,Microsoft.Console,33,Console,1
534054,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class VtIo;
}",1,renderer\vt\vtrenderer.hpp,Microsoft.Console.VirtualTerminal,33,VirtualTerminal,1
534056,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine : public RenderEngineBase
    {
    public:
        // See _PaintUtf8BufferLine for explanation of this value.
        static const size_t ERASE_CHARACTER_STRING_LENGTH = 8;
        static const til::point INVALID_COORDS;

        VtEngine(_In_ wil::unique_hfile hPipe,
                 const Microsoft::Console::Types::Viewport initialViewport);

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[n...",1,renderer\vt\vtrenderer.hpp,Microsoft,38,Microsoft,2
534057,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine : public RenderEngineBase
    {
    public:
        // See _PaintUtf8BufferLine for explanation of this value.
        static const size_t ERASE_CHARACTER_STRING_LENGTH = 8;
        static const til::point INVALID_COORDS;

        VtEngine(_In_ wil::unique_hfile hPipe,
                 const Microsoft::Console::Types::Viewport initialViewport);

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[n...",1,renderer\vt\vtrenderer.hpp,Microsoft.Console,38,Console,1
534058,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine : public RenderEngineBase
    {
    public:
        // See _PaintUtf8BufferLine for explanation of this value.
        static const size_t ERASE_CHARACTER_STRING_LENGTH = 8;
        static const til::point INVALID_COORDS;

        VtEngine(_In_ wil::unique_hfile hPipe,
                 const Microsoft::Console::Types::Viewport initialViewport);

        // IRenderEngine
        [[nodiscard]] HRESULT StartPaint() noexcept override;
        [[nodiscard]] HRESULT EndPaint() noexcept override;
        [[nodiscard]] HRESULT Present() noexcept override;
        [[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;
        [[nodiscard]] HRESULT Invalidate(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* prcDirtyClient) noexcept override;
        [[n...",1,renderer\vt\vtrenderer.hpp,Microsoft.Console.Render,38,Render,1
534586,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\WddmConRenderer.cpp,renderer\wddmcon\WddmConRenderer.cpp:<global>,,<global>,1
535199,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\WddmConRenderer.hpp,renderer\wddmcon\WddmConRenderer.hpp:<global>,,<global>,1
535203,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class WddmConEngine final : public RenderEngineBase
    {
    public:
        WddmConEngine() noexcept;
        ~WddmConEngine() override;

        [[nodiscard]] HRESULT Initialize();
        bool IsInitialized() noexcept;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        til::rect GetDisplaySize() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelect...",1,renderer\wddmcon\WddmConRenderer.hpp,Microsoft,8,Microsoft,1
535204,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class WddmConEngine final : public RenderEngineBase
    {
    public:
        WddmConEngine() noexcept;
        ~WddmConEngine() override;

        [[nodiscard]] HRESULT Initialize();
        bool IsInitialized() noexcept;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        til::rect GetDisplaySize() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelect...",1,renderer\wddmcon\WddmConRenderer.hpp,Microsoft.Console,8,Console,1
535205,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class WddmConEngine final : public RenderEngineBase
    {
    public:
        WddmConEngine() noexcept;
        ~WddmConEngine() override;

        [[nodiscard]] HRESULT Initialize();
        bool IsInitialized() noexcept;

        // Used to release device resources so that another instance of
        // conhost can render to the screen (i.e. only one DirectX
        // application may control the screen at a time.)
        [[nodiscard]] HRESULT Enable() noexcept override;
        [[nodiscard]] HRESULT Disable() noexcept;

        til::rect GetDisplaySize() noexcept;

        // IRenderEngine Members
        [[nodiscard]] HRESULT Invalidate(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateCursor(const til::rect* const psrRegion) noexcept override;
        [[nodiscard]] HRESULT InvalidateSystem(const til::rect* const prcDirtyClient) noexcept override;
        [[nodiscard]] HRESULT InvalidateSelect...",1,renderer\wddmcon\WddmConRenderer.hpp,Microsoft.Console.Render,8,Render,1
535364,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\main.hpp,renderer\wddmcon\main.hpp:<global>,,<global>,1
535394,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\oss_shim.hpp,renderer\wddmcon\oss_shim.hpp:<global>,,<global>,1
535403,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\precomp.cpp,renderer\wddmcon\precomp.cpp:<global>,,<global>,1
535436,NAMESPACE_BLOCK,<empty>,,renderer\wddmcon\precomp.hpp,renderer\wddmcon\precomp.hpp:<global>,,<global>,1
535457,NAMESPACE_BLOCK,<empty>,,server\ApiDispatchers.cpp,server\ApiDispatchers.cpp:<global>,,<global>,1
535552,NAMESPACE_BLOCK,<empty>,,server\ApiDispatchers.hpp,server\ApiDispatchers.hpp:<global>,,<global>,1
535556,NAMESPACE_BLOCK,"namespace ApiDispatchers
{
    [[nodiscard]] HRESULT ServerDeprecatedApi(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);

#pragma region L1
    [[nodiscard]] HRESULT ServerGetConsoleCP(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerGetConsoleMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerSetConsoleMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerGetNumberOfInputEvents(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerGetConsoleInput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerReadConsole(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[nodiscard]] HRESULT ServerWriteConsole(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);
    [[...",1,server\ApiDispatchers.hpp,ApiDispatchers,24,ApiDispatchers,1
535626,NAMESPACE_BLOCK,<empty>,,server\ApiDispatchersInternal.cpp,server\ApiDispatchersInternal.cpp:<global>,,<global>,1
535643,NAMESPACE_BLOCK,<empty>,,server\ApiMessage.cpp,server\ApiMessage.cpp:<global>,,<global>,1
535931,NAMESPACE_BLOCK,<empty>,,server\ApiMessage.hpp,server\ApiMessage.hpp:<global>,,<global>,1
536022,NAMESPACE_BLOCK,<empty>,,server\ApiMessageState.cpp,server\ApiMessageState.cpp:<global>,,<global>,1
536027,NAMESPACE_BLOCK,<empty>,,server\ApiMessageState.hpp,server\ApiMessageState.hpp:<global>,,<global>,1
536050,NAMESPACE_BLOCK,<empty>,,server\ApiSorter.cpp,server\ApiSorter.cpp:<global>,,<global>,1
536633,NAMESPACE_BLOCK,<empty>,,server\ApiSorter.hpp,server\ApiSorter.hpp:<global>,,<global>,1
536645,NAMESPACE_BLOCK,<empty>,,server\ConDrvDeviceComm.cpp,server\ConDrvDeviceComm.cpp:<global>,,<global>,1
536695,NAMESPACE_BLOCK,<empty>,,server\ConDrvDeviceComm.hpp,server\ConDrvDeviceComm.hpp:<global>,,<global>,1
536732,NAMESPACE_BLOCK,<empty>,,server\ConsoleShimPolicy.cpp,server\ConsoleShimPolicy.cpp:<global>,,<global>,1
536761,NAMESPACE_BLOCK,<empty>,,server\ConsoleShimPolicy.hpp,server\ConsoleShimPolicy.hpp:<global>,,<global>,1
536805,NAMESPACE_BLOCK,<empty>,,server\DeviceComm.hpp,server\DeviceComm.hpp:<global>,,<global>,1
536841,NAMESPACE_BLOCK,<empty>,,server\DeviceHandle.cpp,server\DeviceHandle.cpp:<global>,,<global>,1
536849,NAMESPACE_BLOCK,<empty>,,server\DeviceHandle.hpp,server\DeviceHandle.hpp:<global>,,<global>,1
536853,NAMESPACE_BLOCK,"namespace DeviceHandle
{
    [[nodiscard]] NTSTATUS
    CreateServerHandle(
        _Out_ PHANDLE Handle,
        _In_ BOOLEAN Inheritable);

    [[nodiscard]] NTSTATUS
    CreateClientHandle(
        _Out_ PHANDLE Handle,
        _In_ HANDLE ServerHandle,
        _In_ PCWSTR Name,
        _In_ BOOLEAN Inheritable);

    [[nodiscard]] NTSTATUS
    _CreateHandle(
        _Out_ PHANDLE Handle,
        _In_ PCWSTR DeviceName,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ HANDLE Parent,
        _In_ BOOLEAN Inheritable,
        _In_ ULONG OpenOptions);
}",1,server\DeviceHandle.hpp,DeviceHandle,18,DeviceHandle,1
536868,NAMESPACE_BLOCK,<empty>,,server\Entrypoints.cpp,server\Entrypoints.cpp:<global>,,<global>,1
536884,NAMESPACE_BLOCK,<empty>,,server\Entrypoints.hpp,server\Entrypoints.hpp:<global>,,<global>,1
536889,NAMESPACE_BLOCK,"namespace Entrypoints
{
    [[nodiscard]] HRESULT StartConsoleForServerHandle(const HANDLE ServerHandle, const ConsoleArguments* const args);
    [[nodiscard]] HRESULT StartConsoleForCmdLine(_In_ PCWSTR pwszCmdLine, const ConsoleArguments* const args);
}",1,server\Entrypoints.hpp,Entrypoints,21,Entrypoints,2
536908,NAMESPACE_BLOCK,<empty>,,server\IApiRoutines.hpp,server\IApiRoutines.hpp:<global>,,<global>,1
537458,NAMESPACE_BLOCK,<empty>,,server\IWaitRoutine.hpp,server\IWaitRoutine.hpp:<global>,,<global>,1
537546,NAMESPACE_BLOCK,<empty>,,server\IoDispatchers.cpp,server\IoDispatchers.cpp:<global>,,<global>,1
537970,NAMESPACE_BLOCK,<empty>,,server\IoDispatchers.hpp,server\IoDispatchers.hpp:<global>,,<global>,1
537997,NAMESPACE_BLOCK,<empty>,,server\IoSorter.cpp,server\IoSorter.cpp:<global>,,<global>,1
538005,NAMESPACE_BLOCK,<empty>,,server\IoSorter.hpp,server\IoSorter.hpp:<global>,,<global>,1
538012,NAMESPACE_BLOCK,<empty>,,server\IoThread.hpp,server\IoThread.hpp:<global>,,<global>,1
538033,NAMESPACE_BLOCK,<empty>,,server\ObjectHandle.cpp,server\ObjectHandle.cpp:<global>,,<global>,1
538266,NAMESPACE_BLOCK,<empty>,,server\ObjectHandle.hpp,server\ObjectHandle.hpp:<global>,,<global>,1
538387,NAMESPACE_BLOCK,<empty>,,server\ObjectHeader.cpp,server\ObjectHeader.cpp:<global>,,<global>,1
538432,NAMESPACE_BLOCK,<empty>,,server\ObjectHeader.hpp,server\ObjectHeader.hpp:<global>,,<global>,1
538477,NAMESPACE_BLOCK,<empty>,,server\ProcessHandle.cpp,server\ProcessHandle.cpp:<global>,,<global>,1
538630,NAMESPACE_BLOCK,<empty>,,server\ProcessHandle.hpp,server\ProcessHandle.hpp:<global>,,<global>,1
538709,NAMESPACE_BLOCK,<empty>,,server\ProcessList.cpp,server\ProcessList.cpp:<global>,,<global>,1
538881,NAMESPACE_BLOCK,<empty>,,server\ProcessList.hpp,server\ProcessList.hpp:<global>,,<global>,1
538937,NAMESPACE_BLOCK,<empty>,,server\ProcessPolicy.cpp,server\ProcessPolicy.cpp:<global>,,<global>,1
539040,NAMESPACE_BLOCK,<empty>,,server\ProcessPolicy.hpp,server\ProcessPolicy.hpp:<global>,,<global>,1
539085,NAMESPACE_BLOCK,<empty>,,server\WaitBlock.cpp,server\WaitBlock.cpp:<global>,,<global>,1
539473,NAMESPACE_BLOCK,<empty>,,server\WaitBlock.hpp,server\WaitBlock.hpp:<global>,,<global>,1
539507,NAMESPACE_BLOCK,<empty>,,server\WaitQueue.cpp,server\WaitQueue.cpp:<global>,,<global>,1
539616,NAMESPACE_BLOCK,<empty>,,server\WaitQueue.hpp,server\WaitQueue.hpp:<global>,,<global>,1
539645,NAMESPACE_BLOCK,<empty>,,server\WaitTerminationReason.hpp,server\WaitTerminationReason.hpp:<global>,,<global>,1
539680,NAMESPACE_BLOCK,<empty>,,server\WinNTControl.cpp,server\WinNTControl.cpp:<global>,,<global>,1
539697,NAMESPACE_BLOCK,<empty>,,server\WinNTControl.hpp,server\WinNTControl.hpp:<global>,,<global>,1
539727,NAMESPACE_BLOCK,<empty>,,server\precomp.cpp,server\precomp.cpp:<global>,,<global>,1
539756,NAMESPACE_BLOCK,<empty>,,server\precomp.hpp,server\precomp.hpp:<global>,,<global>,1
539770,NAMESPACE_BLOCK,<empty>,,server\winbasep.hpp,server\winbasep.hpp:<global>,,<global>,1
539775,NAMESPACE_BLOCK,<empty>,,terminal\adapter\DispatchTypes.hpp,terminal\adapter\DispatchTypes.hpp:<global>,,<global>,1
539779,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    using VTInt = int32_t;

    union VTID
    {
    public:
        VTID() = default;

        template<size_t Length>
        constexpr VTID(const char (&s)[Length]) :
            _value{ _FromString(s) }
        {
        }

        constexpr VTID(const uint64_t value) :
            _value{ value & 0x00FFFFFFFFFFFFFF }
        {
        }

        constexpr operator uint64_t() const
        {
            return _value;
        }

        constexpr const std::string_view ToString() const
        {
            return &_string[0];
        }

        constexpr char operator[](const size_t offset) const
        {
            return SubSequence(offset)._value & 0xFF;
        }

        constexpr VTID SubSequence(const size_t offset) const
        {
            return _value >> (CHAR_BIT * offset);
        }

    private:
        template<size_t Length>
        static constexpr uint64_t _FromString(const char (&s)[Length])
        {
      ...",1,terminal\adapter\DispatchTypes.hpp,Microsoft,6,Microsoft,1
539780,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    using VTInt = int32_t;

    union VTID
    {
    public:
        VTID() = default;

        template<size_t Length>
        constexpr VTID(const char (&s)[Length]) :
            _value{ _FromString(s) }
        {
        }

        constexpr VTID(const uint64_t value) :
            _value{ value & 0x00FFFFFFFFFFFFFF }
        {
        }

        constexpr operator uint64_t() const
        {
            return _value;
        }

        constexpr const std::string_view ToString() const
        {
            return &_string[0];
        }

        constexpr char operator[](const size_t offset) const
        {
            return SubSequence(offset)._value & 0xFF;
        }

        constexpr VTID SubSequence(const size_t offset) const
        {
            return _value >> (CHAR_BIT * offset);
        }

    private:
        template<size_t Length>
        static constexpr uint64_t _FromString(const char (&s)[Length])
        {
      ...",1,terminal\adapter\DispatchTypes.hpp,Microsoft.Console,6,Console,1
539781,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    using VTInt = int32_t;

    union VTID
    {
    public:
        VTID() = default;

        template<size_t Length>
        constexpr VTID(const char (&s)[Length]) :
            _value{ _FromString(s) }
        {
        }

        constexpr VTID(const uint64_t value) :
            _value{ value & 0x00FFFFFFFFFFFFFF }
        {
        }

        constexpr operator uint64_t() const
        {
            return _value;
        }

        constexpr const std::string_view ToString() const
        {
            return &_string[0];
        }

        constexpr char operator[](const size_t offset) const
        {
            return SubSequence(offset)._value & 0xFF;
        }

        constexpr VTID SubSequence(const size_t offset) const
        {
            return _value >> (CHAR_BIT * offset);
        }

    private:
        template<size_t Length>
        static constexpr uint64_t _FromString(const char (&s)[Length])
        {
      ...",1,terminal\adapter\DispatchTypes.hpp,Microsoft.Console.VirtualTerminal,6,VirtualTerminal,1
540385,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal::DispatchTypes
{
    enum class ColorItem : VTInt
    {
        NormalText = 1,
        WindowFrame = 2,
    };

    enum class ColorModel : VTInt
    {
        HLS = 1,
        RGB = 2,
    };

    enum class EraseType : VTInt
    {
        ToEnd = 0,
        FromBeginning = 1,
        All = 2,
        Scrollback = 3
    };

    enum class ChangeExtent : VTInt
    {
        Default = 0,
        Stream = 1,
        Rectangle = 2
    };

    enum class TaskbarState : VTInt
    {
        Clear = 0,
        Set = 1,
        Error = 2,
        Indeterminate = 3,
        Paused = 4
    };

    enum GraphicsOptions : VTInt
    {
        Off = 0,
        Intense = 1,
        // The 2 and 5 entries here are for BOTH the extended graphics options,
        // as well as the Faint/Blink options.
        RGBColorOrFaint = 2, // 2 is also Faint, decreased intensity (ISO 6429).
        Italics = 3,
        Underline = 4, // same for extended underline...",1,terminal\adapter\DispatchTypes.hpp,Microsoft,355,Microsoft,2
540386,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal::DispatchTypes
{
    enum class ColorItem : VTInt
    {
        NormalText = 1,
        WindowFrame = 2,
    };

    enum class ColorModel : VTInt
    {
        HLS = 1,
        RGB = 2,
    };

    enum class EraseType : VTInt
    {
        ToEnd = 0,
        FromBeginning = 1,
        All = 2,
        Scrollback = 3
    };

    enum class ChangeExtent : VTInt
    {
        Default = 0,
        Stream = 1,
        Rectangle = 2
    };

    enum class TaskbarState : VTInt
    {
        Clear = 0,
        Set = 1,
        Error = 2,
        Indeterminate = 3,
        Paused = 4
    };

    enum GraphicsOptions : VTInt
    {
        Off = 0,
        Intense = 1,
        // The 2 and 5 entries here are for BOTH the extended graphics options,
        // as well as the Faint/Blink options.
        RGBColorOrFaint = 2, // 2 is also Faint, decreased intensity (ISO 6429).
        Italics = 3,
        Underline = 4, // same for extended underline...",1,terminal\adapter\DispatchTypes.hpp,Microsoft.Console,355,Console,1
540387,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal::DispatchTypes
{
    enum class ColorItem : VTInt
    {
        NormalText = 1,
        WindowFrame = 2,
    };

    enum class ColorModel : VTInt
    {
        HLS = 1,
        RGB = 2,
    };

    enum class EraseType : VTInt
    {
        ToEnd = 0,
        FromBeginning = 1,
        All = 2,
        Scrollback = 3
    };

    enum class ChangeExtent : VTInt
    {
        Default = 0,
        Stream = 1,
        Rectangle = 2
    };

    enum class TaskbarState : VTInt
    {
        Clear = 0,
        Set = 1,
        Error = 2,
        Indeterminate = 3,
        Paused = 4
    };

    enum GraphicsOptions : VTInt
    {
        Off = 0,
        Intense = 1,
        // The 2 and 5 entries here are for BOTH the extended graphics options,
        // as well as the Faint/Blink options.
        RGBColorOrFaint = 2, // 2 is also Faint, decreased intensity (ISO 6429).
        Italics = 3,
        Underline = 4, // same for extended underline...",1,terminal\adapter\DispatchTypes.hpp,Microsoft.Console.VirtualTerminal,355,VirtualTerminal,1
540388,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal::DispatchTypes
{
    enum class ColorItem : VTInt
    {
        NormalText = 1,
        WindowFrame = 2,
    };

    enum class ColorModel : VTInt
    {
        HLS = 1,
        RGB = 2,
    };

    enum class EraseType : VTInt
    {
        ToEnd = 0,
        FromBeginning = 1,
        All = 2,
        Scrollback = 3
    };

    enum class ChangeExtent : VTInt
    {
        Default = 0,
        Stream = 1,
        Rectangle = 2
    };

    enum class TaskbarState : VTInt
    {
        Clear = 0,
        Set = 1,
        Error = 2,
        Indeterminate = 3,
        Paused = 4
    };

    enum GraphicsOptions : VTInt
    {
        Off = 0,
        Intense = 1,
        // The 2 and 5 entries here are for BOTH the extended graphics options,
        // as well as the Faint/Blink options.
        RGBColorOrFaint = 2, // 2 is also Faint, decreased intensity (ISO 6429).
        Italics = 3,
        Underline = 4, // same for extended underline...",1,terminal\adapter\DispatchTypes.hpp,Microsoft.Console.VirtualTerminal.DispatchTypes,355,DispatchTypes,1
541338,NAMESPACE_BLOCK,<empty>,,terminal\adapter\FontBuffer.cpp,terminal\adapter\FontBuffer.cpp:<global>,,<global>,1
542631,NAMESPACE_BLOCK,<empty>,,terminal\adapter\FontBuffer.hpp,terminal\adapter\FontBuffer.hpp:<global>,,<global>,1
542635,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class FontBuffer
    {
    public:
        FontBuffer() noexcept;
        ~FontBuffer() = default;
        bool SetEraseControl(const DispatchTypes::DrcsEraseControl eraseControl) noexcept;
        bool SetAttributes(const DispatchTypes::DrcsCellMatrix cellMatrix,
                           const VTParameter cellHeight,
                           const DispatchTypes::DrcsFontSet fontSet,
                           const DispatchTypes::DrcsFontUsage fontUsage) noexcept;
        bool SetStartChar(const VTParameter startChar,
                          const DispatchTypes::DrcsCharsetSize charsetSize) noexcept;
        void AddSixelData(const wchar_t ch);
        bool FinalizeSixelData();

        std::span<const uint16_t> GetBitPattern() const noexcept;
        til::size GetCellSize() const noexcept;
        size_t GetTextCenteringHint() const noexcept;
        VTID GetDesignation() const noexcept;

    private:
        static constex...",1,terminal\adapter\FontBuffer.hpp,Microsoft,16,Microsoft,1
542636,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class FontBuffer
    {
    public:
        FontBuffer() noexcept;
        ~FontBuffer() = default;
        bool SetEraseControl(const DispatchTypes::DrcsEraseControl eraseControl) noexcept;
        bool SetAttributes(const DispatchTypes::DrcsCellMatrix cellMatrix,
                           const VTParameter cellHeight,
                           const DispatchTypes::DrcsFontSet fontSet,
                           const DispatchTypes::DrcsFontUsage fontUsage) noexcept;
        bool SetStartChar(const VTParameter startChar,
                          const DispatchTypes::DrcsCharsetSize charsetSize) noexcept;
        void AddSixelData(const wchar_t ch);
        bool FinalizeSixelData();

        std::span<const uint16_t> GetBitPattern() const noexcept;
        til::size GetCellSize() const noexcept;
        size_t GetTextCenteringHint() const noexcept;
        VTID GetDesignation() const noexcept;

    private:
        static constex...",1,terminal\adapter\FontBuffer.hpp,Microsoft.Console,16,Console,1
542637,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class FontBuffer
    {
    public:
        FontBuffer() noexcept;
        ~FontBuffer() = default;
        bool SetEraseControl(const DispatchTypes::DrcsEraseControl eraseControl) noexcept;
        bool SetAttributes(const DispatchTypes::DrcsCellMatrix cellMatrix,
                           const VTParameter cellHeight,
                           const DispatchTypes::DrcsFontSet fontSet,
                           const DispatchTypes::DrcsFontUsage fontUsage) noexcept;
        bool SetStartChar(const VTParameter startChar,
                          const DispatchTypes::DrcsCharsetSize charsetSize) noexcept;
        void AddSixelData(const wchar_t ch);
        bool FinalizeSixelData();

        std::span<const uint16_t> GetBitPattern() const noexcept;
        til::size GetCellSize() const noexcept;
        size_t GetTextCenteringHint() const noexcept;
        VTID GetDesignation() const noexcept;

    private:
        static constex...",1,terminal\adapter\FontBuffer.hpp,Microsoft.Console.VirtualTerminal,16,VirtualTerminal,1
542798,NAMESPACE_BLOCK,<empty>,,terminal\adapter\IInteractDispatch.hpp,terminal\adapter\IInteractDispatch.hpp:<global>,,<global>,1
542802,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IInteractDispatch
    {
    public:
#pragma warning(push)
#pragma warning(disable : 26432) // suppress rule of 5 violation on interface because tampering with this is fraught with peril
        virtual ~IInteractDispatch() = default;
#pragma warning(pop)

        virtual bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) = 0;

        virtual bool WriteCtrlKey(const INPUT_RECORD& event) = 0;

        virtual bool WriteString(const std::wstring_view string) = 0;

        virtual bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                        const VTParameter parameter1,
                                        const VTParameter parameter2) = 0;

        virtual bool MoveCursor(const VTInt row,
                                const VTInt col) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual bool FocusChanged(const bool focused) const =...",1,terminal\adapter\IInteractDispatch.hpp,Microsoft,21,Microsoft,1
542803,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IInteractDispatch
    {
    public:
#pragma warning(push)
#pragma warning(disable : 26432) // suppress rule of 5 violation on interface because tampering with this is fraught with peril
        virtual ~IInteractDispatch() = default;
#pragma warning(pop)

        virtual bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) = 0;

        virtual bool WriteCtrlKey(const INPUT_RECORD& event) = 0;

        virtual bool WriteString(const std::wstring_view string) = 0;

        virtual bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                        const VTParameter parameter1,
                                        const VTParameter parameter2) = 0;

        virtual bool MoveCursor(const VTInt row,
                                const VTInt col) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual bool FocusChanged(const bool focused) const =...",1,terminal\adapter\IInteractDispatch.hpp,Microsoft.Console,21,Console,1
542804,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IInteractDispatch
    {
    public:
#pragma warning(push)
#pragma warning(disable : 26432) // suppress rule of 5 violation on interface because tampering with this is fraught with peril
        virtual ~IInteractDispatch() = default;
#pragma warning(pop)

        virtual bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) = 0;

        virtual bool WriteCtrlKey(const INPUT_RECORD& event) = 0;

        virtual bool WriteString(const std::wstring_view string) = 0;

        virtual bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                        const VTParameter parameter1,
                                        const VTParameter parameter2) = 0;

        virtual bool MoveCursor(const VTInt row,
                                const VTInt col) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual bool FocusChanged(const bool focused) const =...",1,terminal\adapter\IInteractDispatch.hpp,Microsoft.Console.VirtualTerminal,21,VirtualTerminal,1
542852,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ITermDispatch.hpp,terminal\adapter\ITermDispatch.hpp:<global>,,<global>,1
542856,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITermDispatch;
}",1,terminal\adapter\ITermDispatch.hpp,Microsoft,18,Microsoft,1
542857,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITermDispatch;
}",1,terminal\adapter\ITermDispatch.hpp,Microsoft.Console,18,Console,1
542858,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITermDispatch;
}",1,terminal\adapter\ITermDispatch.hpp,Microsoft.Console.VirtualTerminal,18,VirtualTerminal,1
543408,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ITerminalApi.hpp,terminal\adapter\ITerminalApi.hpp:<global>,,<global>,1
543412,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITerminalApi
    {
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        virtual ~ITerminalApi() = default;
        ITerminalApi() = default;
        ITerminalApi(const ITerminalApi&) = delete;
        ITerminalApi(ITerminalApi&&) = delete;
        ITerminalApi& operator=(const ITerminalApi&) = delete;
        ITerminalApi& operator=(ITerminalApi&&) = delete;

        virtual void ReturnResponse(const std::wstring_view response) = 0;

        virtual StateMachine& GetStateMachine() = 0;
        virtual TextBuffer& GetTextBuffer() = 0;
        virtual til::rect GetViewport() const = 0;
        virtual void SetViewportPosition(const til::point position) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual void SetTextAttributes(const TextAttribute& attrs) = 0;

        enum class Mode : size_t
        {
            AutoWrap,
            LineFeed,
            Bracket...",1,terminal\adapter\ITerminalApi.hpp,Microsoft,26,Microsoft,1
543413,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITerminalApi
    {
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        virtual ~ITerminalApi() = default;
        ITerminalApi() = default;
        ITerminalApi(const ITerminalApi&) = delete;
        ITerminalApi(ITerminalApi&&) = delete;
        ITerminalApi& operator=(const ITerminalApi&) = delete;
        ITerminalApi& operator=(ITerminalApi&&) = delete;

        virtual void ReturnResponse(const std::wstring_view response) = 0;

        virtual StateMachine& GetStateMachine() = 0;
        virtual TextBuffer& GetTextBuffer() = 0;
        virtual til::rect GetViewport() const = 0;
        virtual void SetViewportPosition(const til::point position) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual void SetTextAttributes(const TextAttribute& attrs) = 0;

        enum class Mode : size_t
        {
            AutoWrap,
            LineFeed,
            Bracket...",1,terminal\adapter\ITerminalApi.hpp,Microsoft.Console,26,Console,1
543414,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ITerminalApi
    {
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        virtual ~ITerminalApi() = default;
        ITerminalApi() = default;
        ITerminalApi(const ITerminalApi&) = delete;
        ITerminalApi(ITerminalApi&&) = delete;
        ITerminalApi& operator=(const ITerminalApi&) = delete;
        ITerminalApi& operator=(ITerminalApi&&) = delete;

        virtual void ReturnResponse(const std::wstring_view response) = 0;

        virtual StateMachine& GetStateMachine() = 0;
        virtual TextBuffer& GetTextBuffer() = 0;
        virtual til::rect GetViewport() const = 0;
        virtual void SetViewportPosition(const til::point position) = 0;

        virtual bool IsVtInputEnabled() const = 0;

        virtual void SetTextAttributes(const TextAttribute& attrs) = 0;

        enum class Mode : size_t
        {
            AutoWrap,
            LineFeed,
            Bracket...",1,terminal\adapter\ITerminalApi.hpp,Microsoft.Console.VirtualTerminal,26,VirtualTerminal,1
543607,NAMESPACE_BLOCK,<empty>,,terminal\adapter\InteractDispatch.cpp,terminal\adapter\InteractDispatch.cpp:<global>,,<global>,1
544008,NAMESPACE_BLOCK,<empty>,,terminal\adapter\InteractDispatch.hpp,terminal\adapter\InteractDispatch.hpp:<global>,,<global>,1
544012,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class InteractDispatch : public IInteractDispatch
    {
    public:
        InteractDispatch();

        bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) override;
        bool WriteCtrlKey(const INPUT_RECORD& event) override;
        bool WriteString(const std::wstring_view string) override;
        bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                const VTParameter parameter1,
                                const VTParameter parameter2) override; // DTTERM_WindowManipulation
        bool MoveCursor(const VTInt row, const VTInt col) override;

        bool IsVtInputEnabled() const override;

        bool FocusChanged(const bool focused) const override;

    private:
        ConhostInternalGetSet _api;
    };
}",1,terminal\adapter\InteractDispatch.hpp,Microsoft,21,Microsoft,1
544013,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class InteractDispatch : public IInteractDispatch
    {
    public:
        InteractDispatch();

        bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) override;
        bool WriteCtrlKey(const INPUT_RECORD& event) override;
        bool WriteString(const std::wstring_view string) override;
        bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                const VTParameter parameter1,
                                const VTParameter parameter2) override; // DTTERM_WindowManipulation
        bool MoveCursor(const VTInt row, const VTInt col) override;

        bool IsVtInputEnabled() const override;

        bool FocusChanged(const bool focused) const override;

    private:
        ConhostInternalGetSet _api;
    };
}",1,terminal\adapter\InteractDispatch.hpp,Microsoft.Console,21,Console,1
544014,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class InteractDispatch : public IInteractDispatch
    {
    public:
        InteractDispatch();

        bool WriteInput(const std::span<const INPUT_RECORD>& inputEvents) override;
        bool WriteCtrlKey(const INPUT_RECORD& event) override;
        bool WriteString(const std::wstring_view string) override;
        bool WindowManipulation(const DispatchTypes::WindowManipulationType function,
                                const VTParameter parameter1,
                                const VTParameter parameter2) override; // DTTERM_WindowManipulation
        bool MoveCursor(const VTInt row, const VTInt col) override;

        bool IsVtInputEnabled() const override;

        bool FocusChanged(const bool focused) const override;

    private:
        ConhostInternalGetSet _api;
    };
}",1,terminal\adapter\InteractDispatch.hpp,Microsoft.Console.VirtualTerminal,21,VirtualTerminal,1
544082,NAMESPACE_BLOCK,<empty>,,terminal\adapter\MacroBuffer.cpp,terminal\adapter\MacroBuffer.cpp:<global>,,<global>,1
544672,NAMESPACE_BLOCK,<empty>,,terminal\adapter\MacroBuffer.hpp,terminal\adapter\MacroBuffer.hpp:<global>,,<global>,1
544676,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class StateMachine;

    class MacroBuffer
    {
    public:
        // The original DEC terminals only supported 6K of memory, which is
        // probably a bit low for modern usage. But we also don't want to make
        // this value too large, otherwise it could be used in a denial-of-
        // service attack. So for now this is probably a sufficient limit, but
        // we may need to increase it in the future if we intend to support
        // macros containing sixel sequences.
        static constexpr size_t MAX_SPACE = 0x40000;

        MacroBuffer() = default;
        ~MacroBuffer() = default;

        size_t GetSpaceAvailable() const noexcept;
        uint16_t CalculateChecksum() const noexcept;
        void InvokeMacro(const size_t macroId, StateMachine& stateMachine);
        void ClearMacrosIfInUse();
        bool InitParser(const size_t macroId, const DispatchTypes::MacroDeleteControl deleteControl, const Dispatch...",1,terminal\adapter\MacroBuffer.hpp,Microsoft,24,Microsoft,1
544677,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class StateMachine;

    class MacroBuffer
    {
    public:
        // The original DEC terminals only supported 6K of memory, which is
        // probably a bit low for modern usage. But we also don't want to make
        // this value too large, otherwise it could be used in a denial-of-
        // service attack. So for now this is probably a sufficient limit, but
        // we may need to increase it in the future if we intend to support
        // macros containing sixel sequences.
        static constexpr size_t MAX_SPACE = 0x40000;

        MacroBuffer() = default;
        ~MacroBuffer() = default;

        size_t GetSpaceAvailable() const noexcept;
        uint16_t CalculateChecksum() const noexcept;
        void InvokeMacro(const size_t macroId, StateMachine& stateMachine);
        void ClearMacrosIfInUse();
        bool InitParser(const size_t macroId, const DispatchTypes::MacroDeleteControl deleteControl, const Dispatch...",1,terminal\adapter\MacroBuffer.hpp,Microsoft.Console,24,Console,1
544678,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class StateMachine;

    class MacroBuffer
    {
    public:
        // The original DEC terminals only supported 6K of memory, which is
        // probably a bit low for modern usage. But we also don't want to make
        // this value too large, otherwise it could be used in a denial-of-
        // service attack. So for now this is probably a sufficient limit, but
        // we may need to increase it in the future if we intend to support
        // macros containing sixel sequences.
        static constexpr size_t MAX_SPACE = 0x40000;

        MacroBuffer() = default;
        ~MacroBuffer() = default;

        size_t GetSpaceAvailable() const noexcept;
        uint16_t CalculateChecksum() const noexcept;
        void InvokeMacro(const size_t macroId, StateMachine& stateMachine);
        void ClearMacrosIfInUse();
        bool InitParser(const size_t macroId, const DispatchTypes::MacroDeleteControl deleteControl, const Dispatch...",1,terminal\adapter\MacroBuffer.hpp,Microsoft.Console.VirtualTerminal,24,VirtualTerminal,1
546225,NAMESPACE_BLOCK,<empty>,,terminal\adapter\adaptDispatch.cpp,terminal\adapter\adaptDispatch.cpp:<global>,,<global>,1
557353,NAMESPACE_BLOCK,<empty>,,terminal\adapter\adaptDispatch.hpp,terminal\adapter\adaptDispatch.hpp:<global>,,<global>,1
557357,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch : public ITermDispatch
    {
        using Renderer = Microsoft::Console::Render::Renderer;
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        AdaptDispatch(ITerminalApi& api, Renderer& renderer, RenderSettings& renderSettings, TerminalInput& terminalInput);

        void Print(const wchar_t wchPrintable) override;
        void PrintString(const std::wstring_view string) override;

        bool CursorUp(const VTInt distance) override; // CUU
        bool CursorDown(const VTInt distance) override; // CUD
        bool CursorForward(const VTInt distance) override; // CUF
        bool CursorBackward(const VTInt distance) override; // CUB, BS
        bool CursorNextLine(const VTInt distance) override; // CNL
        bool CursorPrevLine(const VTInt distance) override; // CPL
        bool CursorHorizontalPositionAbsolute(const VTInt column) override; // HPA, CHA
        bool...",1,terminal\adapter\adaptDispatch.hpp,Microsoft,30,Microsoft,1
557358,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch : public ITermDispatch
    {
        using Renderer = Microsoft::Console::Render::Renderer;
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        AdaptDispatch(ITerminalApi& api, Renderer& renderer, RenderSettings& renderSettings, TerminalInput& terminalInput);

        void Print(const wchar_t wchPrintable) override;
        void PrintString(const std::wstring_view string) override;

        bool CursorUp(const VTInt distance) override; // CUU
        bool CursorDown(const VTInt distance) override; // CUD
        bool CursorForward(const VTInt distance) override; // CUF
        bool CursorBackward(const VTInt distance) override; // CUB, BS
        bool CursorNextLine(const VTInt distance) override; // CNL
        bool CursorPrevLine(const VTInt distance) override; // CPL
        bool CursorHorizontalPositionAbsolute(const VTInt column) override; // HPA, CHA
        bool...",1,terminal\adapter\adaptDispatch.hpp,Microsoft.Console,30,Console,1
557359,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class AdaptDispatch : public ITermDispatch
    {
        using Renderer = Microsoft::Console::Render::Renderer;
        using RenderSettings = Microsoft::Console::Render::RenderSettings;

    public:
        AdaptDispatch(ITerminalApi& api, Renderer& renderer, RenderSettings& renderSettings, TerminalInput& terminalInput);

        void Print(const wchar_t wchPrintable) override;
        void PrintString(const std::wstring_view string) override;

        bool CursorUp(const VTInt distance) override; // CUU
        bool CursorDown(const VTInt distance) override; // CUD
        bool CursorForward(const VTInt distance) override; // CUF
        bool CursorBackward(const VTInt distance) override; // CUB, BS
        bool CursorNextLine(const VTInt distance) override; // CNL
        bool CursorPrevLine(const VTInt distance) override; // CPL
        bool CursorHorizontalPositionAbsolute(const VTInt column) override; // HPA, CHA
        bool...",1,terminal\adapter\adaptDispatch.hpp,Microsoft.Console.VirtualTerminal,30,VirtualTerminal,1
558338,NAMESPACE_BLOCK,<empty>,,terminal\adapter\adaptDispatchGraphics.cpp,terminal\adapter\adaptDispatchGraphics.cpp:<global>,,<global>,1
559520,NAMESPACE_BLOCK,<empty>,,terminal\adapter\charsets.hpp,terminal\adapter\charsets.hpp:<global>,,<global>,1
559524,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    template<wchar_t BaseChar, size_t Size>
    class CharSet
    {
    public:
        constexpr CharSet(const std::initializer_list<std::pair<wchar_t, wchar_t>> replacements)
        {
            for (auto i = L'\0'; i < _translationTable.size(); i++)
                _translationTable.at(i) = BaseChar + i;
            for (auto replacement : replacements)
                _translationTable.at(replacement.first - BaseChar) = replacement.second;
        }
        constexpr operator const std::wstring_view() const
        {
            return { _translationTable.data(), _translationTable.size() };
        }
        constexpr bool operator==(const std::wstring_view rhs) const
        {
            return _translationTable.data() == rhs.data();
        }

    private:
        std::array<wchar_t, Size> _translationTable = {};
    };

    template<wchar_t BaseChar, size_t Size>
    constexpr bool operator==(const std::wstring_view lhs, cons...",1,terminal\adapter\charsets.hpp,Microsoft,14,Microsoft,1
559525,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    template<wchar_t BaseChar, size_t Size>
    class CharSet
    {
    public:
        constexpr CharSet(const std::initializer_list<std::pair<wchar_t, wchar_t>> replacements)
        {
            for (auto i = L'\0'; i < _translationTable.size(); i++)
                _translationTable.at(i) = BaseChar + i;
            for (auto replacement : replacements)
                _translationTable.at(replacement.first - BaseChar) = replacement.second;
        }
        constexpr operator const std::wstring_view() const
        {
            return { _translationTable.data(), _translationTable.size() };
        }
        constexpr bool operator==(const std::wstring_view rhs) const
        {
            return _translationTable.data() == rhs.data();
        }

    private:
        std::array<wchar_t, Size> _translationTable = {};
    };

    template<wchar_t BaseChar, size_t Size>
    constexpr bool operator==(const std::wstring_view lhs, cons...",1,terminal\adapter\charsets.hpp,Microsoft.Console,14,Console,1
559526,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    template<wchar_t BaseChar, size_t Size>
    class CharSet
    {
    public:
        constexpr CharSet(const std::initializer_list<std::pair<wchar_t, wchar_t>> replacements)
        {
            for (auto i = L'\0'; i < _translationTable.size(); i++)
                _translationTable.at(i) = BaseChar + i;
            for (auto replacement : replacements)
                _translationTable.at(replacement.first - BaseChar) = replacement.second;
        }
        constexpr operator const std::wstring_view() const
        {
            return { _translationTable.data(), _translationTable.size() };
        }
        constexpr bool operator==(const std::wstring_view rhs) const
        {
            return _translationTable.data() == rhs.data();
        }

    private:
        std::array<wchar_t, Size> _translationTable = {};
    };

    template<wchar_t BaseChar, size_t Size>
    constexpr bool operator==(const std::wstring_view lhs, cons...",1,terminal\adapter\charsets.hpp,Microsoft.Console.VirtualTerminal,14,VirtualTerminal,1
562380,NAMESPACE_BLOCK,<empty>,,terminal\adapter\precomp.cpp,terminal\adapter\precomp.cpp:<global>,,<global>,1
562399,NAMESPACE_BLOCK,<empty>,,terminal\adapter\precomp.hpp,terminal\adapter\precomp.hpp:<global>,,<global>,1
562408,NAMESPACE_BLOCK,<empty>,,terminal\adapter\telemetry.cpp,terminal\adapter\telemetry.cpp:<global>,,<global>,1
562421,NAMESPACE_BLOCK,<empty>,,terminal\adapter\telemetry.hpp,terminal\adapter\telemetry.hpp:<global>,,<global>,1
562429,NAMESPACE_BLOCK,<empty>,,terminal\adapter\termDispatch.hpp,terminal\adapter\termDispatch.hpp:<global>,,<global>,1
562433,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TermDispatch;
}",1,terminal\adapter\termDispatch.hpp,Microsoft,15,Microsoft,1
562434,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TermDispatch;
}",1,terminal\adapter\termDispatch.hpp,Microsoft.Console,15,Console,1
562435,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TermDispatch;
}",1,terminal\adapter\termDispatch.hpp,Microsoft.Console.VirtualTerminal,15,VirtualTerminal,1
563162,NAMESPACE_BLOCK,<empty>,,terminal\adapter\terminalOutput.cpp,terminal\adapter\terminalOutput.cpp:<global>,,<global>,1
563964,NAMESPACE_BLOCK,<empty>,,terminal\adapter\terminalOutput.hpp,terminal\adapter\terminalOutput.hpp:<global>,,<global>,1
563968,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalOutput sealed
    {
    public:
        TerminalOutput() noexcept;

        wchar_t TranslateKey(const wchar_t wch) const noexcept;
        bool Designate94Charset(const size_t gsetNumber, const VTID charset);
        bool Designate96Charset(const size_t gsetNumber, const VTID charset);
        void SetDrcs94Designation(const VTID charset);
        void SetDrcs96Designation(const VTID charset);
        VTID GetCharsetId(const size_t gsetNumber) const;
        size_t GetCharsetSize(const size_t gsetNumber) const;
        bool LockingShift(const size_t gsetNumber);
        bool LockingShiftRight(const size_t gsetNumber);
        bool SingleShift(const size_t gsetNumber) noexcept;
        size_t GetLeftSetNumber() const noexcept;
        size_t GetRightSetNumber() const noexcept;
        bool IsSingleShiftPending(const size_t gsetNumber) const noexcept;
        bool NeedToTranslate() const noexcept;
        void EnableGr...",1,terminal\adapter\terminalOutput.hpp,Microsoft,21,Microsoft,1
563969,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalOutput sealed
    {
    public:
        TerminalOutput() noexcept;

        wchar_t TranslateKey(const wchar_t wch) const noexcept;
        bool Designate94Charset(const size_t gsetNumber, const VTID charset);
        bool Designate96Charset(const size_t gsetNumber, const VTID charset);
        void SetDrcs94Designation(const VTID charset);
        void SetDrcs96Designation(const VTID charset);
        VTID GetCharsetId(const size_t gsetNumber) const;
        size_t GetCharsetSize(const size_t gsetNumber) const;
        bool LockingShift(const size_t gsetNumber);
        bool LockingShiftRight(const size_t gsetNumber);
        bool SingleShift(const size_t gsetNumber) noexcept;
        size_t GetLeftSetNumber() const noexcept;
        size_t GetRightSetNumber() const noexcept;
        bool IsSingleShiftPending(const size_t gsetNumber) const noexcept;
        bool NeedToTranslate() const noexcept;
        void EnableGr...",1,terminal\adapter\terminalOutput.hpp,Microsoft.Console,21,Console,1
563970,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalOutput sealed
    {
    public:
        TerminalOutput() noexcept;

        wchar_t TranslateKey(const wchar_t wch) const noexcept;
        bool Designate94Charset(const size_t gsetNumber, const VTID charset);
        bool Designate96Charset(const size_t gsetNumber, const VTID charset);
        void SetDrcs94Designation(const VTID charset);
        void SetDrcs96Designation(const VTID charset);
        VTID GetCharsetId(const size_t gsetNumber) const;
        size_t GetCharsetSize(const size_t gsetNumber) const;
        bool LockingShift(const size_t gsetNumber);
        bool LockingShiftRight(const size_t gsetNumber);
        bool SingleShift(const size_t gsetNumber) noexcept;
        size_t GetLeftSetNumber() const noexcept;
        size_t GetRightSetNumber() const noexcept;
        bool IsSingleShiftPending(const size_t gsetNumber) const noexcept;
        bool NeedToTranslate() const noexcept;
        void EnableGr...",1,terminal\adapter\terminalOutput.hpp,Microsoft.Console.VirtualTerminal,21,VirtualTerminal,1
563977,NAMESPACE_BLOCK,<empty>,,terminal\adapter\tracing.cpp,terminal\adapter\tracing.cpp:<global>,,<global>,1
563984,NAMESPACE_BLOCK,<empty>,,terminal\adapter\tracing.hpp,terminal\adapter\tracing.hpp:<global>,,<global>,1
563995,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ut_adapter\MouseInputTest.cpp,terminal\adapter\ut_adapter\MouseInputTest.cpp:<global>,,<global>,1
563999,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class MouseInputTest;
        };
    };
}",1,terminal\adapter\ut_adapter\MouseInputTest.cpp,Microsoft,13,Microsoft,1
564000,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class MouseInputTest;
        };
    }",5,terminal\adapter\ut_adapter\MouseInputTest.cpp,Microsoft.Console,15,Console,1
564001,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class MouseInputTest;
        }",9,terminal\adapter\ut_adapter\MouseInputTest.cpp,Microsoft.Console.VirtualTerminal,17,VirtualTerminal,1
564514,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ut_adapter\WexHelpers.hpp,terminal\adapter\ut_adapter\WexHelpers.hpp:<global>,,<global>,1
564518,NAMESPACE_BLOCK,"namespace WEX
{
    namespace TestExecution
    {
        template<>
        class VerifyOutputTraits<til::inclusive_rect>
        {
        public:
            static WEX::Common::NoThrowString ToString(const til::inclusive_rect& sr)
            {
                return WEX::Common::NoThrowString().Format(L""(L:%d, R:%d, T:%d, B:%d)"", sr.left, sr.right, sr.top, sr.bottom);
            }
        };

        template<>
        class VerifyCompareTraits<til::inclusive_rect, til::inclusive_rect>
        {
        public:
            static bool AreEqual(const til::inclusive_rect& expected, const til::inclusive_rect& actual)
            {
                return expected.left == actual.left &&
                       expected.right == actual.right &&
                       expected.top == actual.top &&
                       expected.bottom == actual.bottom;
            }

            static bool AreSame(const til::inclusive_rect& expected, const til::inclusive_rect& actual)
            {
...",1,terminal\adapter\ut_adapter\WexHelpers.hpp,WEX,4,WEX,1
564519,NAMESPACE_BLOCK,"namespace TestExecution
    {
        template<>
        class VerifyOutputTraits<til::inclusive_rect>
        {
        public:
            static WEX::Common::NoThrowString ToString(const til::inclusive_rect& sr)
            {
                return WEX::Common::NoThrowString().Format(L""(L:%d, R:%d, T:%d, B:%d)"", sr.left, sr.right, sr.top, sr.bottom);
            }
        };

        template<>
        class VerifyCompareTraits<til::inclusive_rect, til::inclusive_rect>
        {
        public:
            static bool AreEqual(const til::inclusive_rect& expected, const til::inclusive_rect& actual)
            {
                return expected.left == actual.left &&
                       expected.right == actual.right &&
                       expected.top == actual.top &&
                       expected.bottom == actual.bottom;
            }

            static bool AreSame(const til::inclusive_rect& expected, const til::inclusive_rect& actual)
            {
                retu...",5,terminal\adapter\ut_adapter\WexHelpers.hpp,WEX.TestExecution,6,TestExecution,1
566536,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ut_adapter\adapterTest.cpp,terminal\adapter\ut_adapter\adapterTest.cpp:<global>,,<global>,1
566539,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class AdapterTest;
            class ConAdapterTestGetSet;
        };
    };
}",1,terminal\adapter\ut_adapter\adapterTest.cpp,Microsoft,16,Microsoft,1
566540,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class AdapterTest;
            class ConAdapterTestGetSet;
        };
    }",5,terminal\adapter\ut_adapter\adapterTest.cpp,Microsoft.Console,18,Console,1
566541,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class AdapterTest;
            class ConAdapterTestGetSet;
        }",9,terminal\adapter\ut_adapter\adapterTest.cpp,Microsoft.Console.VirtualTerminal,20,VirtualTerminal,1
569781,NAMESPACE_BLOCK,<empty>,,terminal\adapter\ut_adapter\inputTest.cpp,terminal\adapter\ut_adapter\inputTest.cpp:<global>,,<global>,1
569785,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class InputTest;
        };
    };
}",1,terminal\adapter\ut_adapter\inputTest.cpp,Microsoft,14,Microsoft,1
569786,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class InputTest;
        };
    }",5,terminal\adapter\ut_adapter\inputTest.cpp,Microsoft.Console,16,Console,1
569787,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class InputTest;
        }",9,terminal\adapter\ut_adapter\inputTest.cpp,Microsoft.Console.VirtualTerminal,18,VirtualTerminal,1
572382,NAMESPACE_BLOCK,<empty>,,terminal\input\mouseInput.cpp,terminal\input\mouseInput.cpp:<global>,,<global>,1
573332,NAMESPACE_BLOCK,<empty>,,terminal\input\mouseInputState.cpp,terminal\input\mouseInputState.cpp:<global>,,<global>,1
573357,NAMESPACE_BLOCK,<empty>,,terminal\input\precomp.cpp,terminal\input\precomp.cpp:<global>,,<global>,1
573366,NAMESPACE_BLOCK,<empty>,,terminal\input\precomp.hpp,terminal\input\precomp.hpp:<global>,,<global>,1
573383,NAMESPACE_BLOCK,<empty>,,terminal\input\terminalInput.cpp,terminal\input\terminalInput.cpp:<global>,,<global>,1
575144,NAMESPACE_BLOCK,<empty>,,terminal\input\terminalInput.hpp,terminal\input\terminalInput.hpp:<global>,,<global>,1
575148,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalInput final
    {
    public:
        using StringType = std::wstring;
        using OutputType = std::optional<StringType>;

        struct MouseButtonState
        {
            bool isLeftButtonDown;
            bool isMiddleButtonDown;
            bool isRightButtonDown;
        };

        [[nodiscard]] static OutputType MakeUnhandled() noexcept;
        [[nodiscard]] static OutputType MakeOutput(const std::wstring_view& str);
        [[nodiscard]] OutputType HandleKey(const INPUT_RECORD& pInEvent);
        [[nodiscard]] OutputType HandleFocus(bool focused) const;
        [[nodiscard]] OutputType HandleMouse(til::point position, unsigned int button, short modifierKeyState, short delta, MouseButtonState state);

        enum class Mode : size_t
        {
            LineFeed,
            Ansi,
            AutoRepeat,
            Keypad,
            CursorKey,
            BackarrowKey,
            Win32,

         ...",1,terminal\input\terminalInput.hpp,Microsoft,6,Microsoft,1
575149,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalInput final
    {
    public:
        using StringType = std::wstring;
        using OutputType = std::optional<StringType>;

        struct MouseButtonState
        {
            bool isLeftButtonDown;
            bool isMiddleButtonDown;
            bool isRightButtonDown;
        };

        [[nodiscard]] static OutputType MakeUnhandled() noexcept;
        [[nodiscard]] static OutputType MakeOutput(const std::wstring_view& str);
        [[nodiscard]] OutputType HandleKey(const INPUT_RECORD& pInEvent);
        [[nodiscard]] OutputType HandleFocus(bool focused) const;
        [[nodiscard]] OutputType HandleMouse(til::point position, unsigned int button, short modifierKeyState, short delta, MouseButtonState state);

        enum class Mode : size_t
        {
            LineFeed,
            Ansi,
            AutoRepeat,
            Keypad,
            CursorKey,
            BackarrowKey,
            Win32,

         ...",1,terminal\input\terminalInput.hpp,Microsoft.Console,6,Console,1
575150,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class TerminalInput final
    {
    public:
        using StringType = std::wstring;
        using OutputType = std::optional<StringType>;

        struct MouseButtonState
        {
            bool isLeftButtonDown;
            bool isMiddleButtonDown;
            bool isRightButtonDown;
        };

        [[nodiscard]] static OutputType MakeUnhandled() noexcept;
        [[nodiscard]] static OutputType MakeOutput(const std::wstring_view& str);
        [[nodiscard]] OutputType HandleKey(const INPUT_RECORD& pInEvent);
        [[nodiscard]] OutputType HandleFocus(bool focused) const;
        [[nodiscard]] OutputType HandleMouse(til::point position, unsigned int button, short modifierKeyState, short delta, MouseButtonState state);

        enum class Mode : size_t
        {
            LineFeed,
            Ansi,
            AutoRepeat,
            Keypad,
            CursorKey,
            BackarrowKey,
            Win32,

         ...",1,terminal\input\terminalInput.hpp,Microsoft.Console.VirtualTerminal,6,VirtualTerminal,1
575350,NAMESPACE_BLOCK,<empty>,,terminal\parser\IStateMachineEngine.hpp,terminal\parser\IStateMachineEngine.hpp:<global>,,<global>,1
575354,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IStateMachineEngine
    {
    public:
        using StringHandler = std::function<bool(const wchar_t)>;

        virtual ~IStateMachineEngine() = 0;
        IStateMachineEngine(const IStateMachineEngine&) = default;
        IStateMachineEngine(IStateMachineEngine&&) = default;
        IStateMachineEngine& operator=(const IStateMachineEngine&) = default;
        IStateMachineEngine& operator=(IStateMachineEngine&&) = default;

        virtual bool EncounteredWin32InputModeSequence() const noexcept = 0;

        virtual bool ActionExecute(const wchar_t wch) = 0;
        virtual bool ActionExecuteFromEscape(const wchar_t wch) = 0;
        virtual bool ActionPrint(const wchar_t wch) = 0;
        virtual bool ActionPrintString(const std::wstring_view string) = 0;

        virtual bool ActionPassThroughString(const std::wstring_view string) = 0;

        virtual bool ActionEscDispatch(const VTID id) = 0;
        virtual bool Action...",1,terminal\parser\IStateMachineEngine.hpp,Microsoft,18,Microsoft,1
575355,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IStateMachineEngine
    {
    public:
        using StringHandler = std::function<bool(const wchar_t)>;

        virtual ~IStateMachineEngine() = 0;
        IStateMachineEngine(const IStateMachineEngine&) = default;
        IStateMachineEngine(IStateMachineEngine&&) = default;
        IStateMachineEngine& operator=(const IStateMachineEngine&) = default;
        IStateMachineEngine& operator=(IStateMachineEngine&&) = default;

        virtual bool EncounteredWin32InputModeSequence() const noexcept = 0;

        virtual bool ActionExecute(const wchar_t wch) = 0;
        virtual bool ActionExecuteFromEscape(const wchar_t wch) = 0;
        virtual bool ActionPrint(const wchar_t wch) = 0;
        virtual bool ActionPrintString(const std::wstring_view string) = 0;

        virtual bool ActionPassThroughString(const std::wstring_view string) = 0;

        virtual bool ActionEscDispatch(const VTID id) = 0;
        virtual bool Action...",1,terminal\parser\IStateMachineEngine.hpp,Microsoft.Console,18,Console,1
575356,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class IStateMachineEngine
    {
    public:
        using StringHandler = std::function<bool(const wchar_t)>;

        virtual ~IStateMachineEngine() = 0;
        IStateMachineEngine(const IStateMachineEngine&) = default;
        IStateMachineEngine(IStateMachineEngine&&) = default;
        IStateMachineEngine& operator=(const IStateMachineEngine&) = default;
        IStateMachineEngine& operator=(IStateMachineEngine&&) = default;

        virtual bool EncounteredWin32InputModeSequence() const noexcept = 0;

        virtual bool ActionExecute(const wchar_t wch) = 0;
        virtual bool ActionExecuteFromEscape(const wchar_t wch) = 0;
        virtual bool ActionPrint(const wchar_t wch) = 0;
        virtual bool ActionPrintString(const std::wstring_view string) = 0;

        virtual bool ActionPassThroughString(const std::wstring_view string) = 0;

        virtual bool ActionEscDispatch(const VTID id) = 0;
        virtual bool Action...",1,terminal\parser\IStateMachineEngine.hpp,Microsoft.Console.VirtualTerminal,18,VirtualTerminal,1
575477,NAMESPACE_BLOCK,<empty>,,terminal\parser\InputStateMachineEngine.cpp,terminal\parser\InputStateMachineEngine.cpp:<global>,,<global>,1
577726,NAMESPACE_BLOCK,<empty>,,terminal\parser\InputStateMachineEngine.hpp,terminal\parser\InputStateMachineEngine.hpp:<global>,,<global>,1
577730,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The values used by VkKeyScan to encode modifiers in the high order byte
    constexpr short KEYSCAN_SHIFT = 1;
    constexpr short KEYSCAN_CTRL = 2;
    constexpr short KEYSCAN_ALT = 4;

    // The values with which VT encodes modifier values.
    constexpr short VT_SHIFT = 1;
    constexpr short VT_ALT = 2;
    constexpr short VT_CTRL = 4;

    // The assumed values for SGR Mouse Scroll Wheel deltas
    constexpr DWORD SCROLL_DELTA_BACKWARD = 0xFF800000;
    constexpr DWORD SCROLL_DELTA_FORWARD = 0x00800000;

    constexpr size_t WRAPPED_SEQUENCE_MAX_LENGTH = 8;

    // For reference, the equivalent INPUT_RECORD values are:
    // RIGHT_ALT_PRESSED   0x0001
    // LEFT_ALT_PRESSED    0x0002
    // RIGHT_CTRL_PRESSED  0x0004
    // LEFT_CTRL_PRESSED   0x0008
    // SHIFT_PRESSED       0x0010
    // NUMLOCK_ON          0x0020
    // SCROLLLOCK_ON       0x0040
    // CAPSLOCK_ON         0x0080
    // ENHANCED_KEY        0x0100

  ...",1,terminal\parser\InputStateMachineEngine.hpp,Microsoft,23,Microsoft,1
577731,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The values used by VkKeyScan to encode modifiers in the high order byte
    constexpr short KEYSCAN_SHIFT = 1;
    constexpr short KEYSCAN_CTRL = 2;
    constexpr short KEYSCAN_ALT = 4;

    // The values with which VT encodes modifier values.
    constexpr short VT_SHIFT = 1;
    constexpr short VT_ALT = 2;
    constexpr short VT_CTRL = 4;

    // The assumed values for SGR Mouse Scroll Wheel deltas
    constexpr DWORD SCROLL_DELTA_BACKWARD = 0xFF800000;
    constexpr DWORD SCROLL_DELTA_FORWARD = 0x00800000;

    constexpr size_t WRAPPED_SEQUENCE_MAX_LENGTH = 8;

    // For reference, the equivalent INPUT_RECORD values are:
    // RIGHT_ALT_PRESSED   0x0001
    // LEFT_ALT_PRESSED    0x0002
    // RIGHT_CTRL_PRESSED  0x0004
    // LEFT_CTRL_PRESSED   0x0008
    // SHIFT_PRESSED       0x0010
    // NUMLOCK_ON          0x0020
    // SCROLLLOCK_ON       0x0040
    // CAPSLOCK_ON         0x0080
    // ENHANCED_KEY        0x0100

  ...",1,terminal\parser\InputStateMachineEngine.hpp,Microsoft.Console,23,Console,1
577732,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The values used by VkKeyScan to encode modifiers in the high order byte
    constexpr short KEYSCAN_SHIFT = 1;
    constexpr short KEYSCAN_CTRL = 2;
    constexpr short KEYSCAN_ALT = 4;

    // The values with which VT encodes modifier values.
    constexpr short VT_SHIFT = 1;
    constexpr short VT_ALT = 2;
    constexpr short VT_CTRL = 4;

    // The assumed values for SGR Mouse Scroll Wheel deltas
    constexpr DWORD SCROLL_DELTA_BACKWARD = 0xFF800000;
    constexpr DWORD SCROLL_DELTA_FORWARD = 0x00800000;

    constexpr size_t WRAPPED_SEQUENCE_MAX_LENGTH = 8;

    // For reference, the equivalent INPUT_RECORD values are:
    // RIGHT_ALT_PRESSED   0x0001
    // LEFT_ALT_PRESSED    0x0002
    // RIGHT_CTRL_PRESSED  0x0004
    // LEFT_CTRL_PRESSED   0x0008
    // SHIFT_PRESSED       0x0010
    // NUMLOCK_ON          0x0020
    // SCROLLLOCK_ON       0x0040
    // CAPSLOCK_ON         0x0080
    // ENHANCED_KEY        0x0100

  ...",1,terminal\parser\InputStateMachineEngine.hpp,Microsoft.Console.VirtualTerminal,23,VirtualTerminal,1
578409,NAMESPACE_BLOCK,<empty>,,terminal\parser\OutputStateMachineEngine.cpp,terminal\parser\OutputStateMachineEngine.cpp:<global>,,<global>,1
581776,NAMESPACE_BLOCK,<empty>,,terminal\parser\OutputStateMachineEngine.hpp,terminal\parser\OutputStateMachineEngine.hpp:<global>,,<global>,1
581780,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft,18,Microsoft,1
581781,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft.Console,18,Console,1
581782,NAMESPACE_BLOCK,"namespace Microsoft::Console::Render
{
    class VtEngine;
}",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft.Console.Render,18,Render,1
581784,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class OutputStateMachineEngine : public IStateMachineEngine
    {
    public:
        static constexpr size_t MAX_URL_LENGTH = 2 * 1048576; // 2MB, like iTerm2

        OutputStateMachineEngine(std::unique_ptr<ITermDispatch> pDispatch);

        bool EncounteredWin32InputModeSequence() const noexcept override;

        bool ActionExecute(const wchar_t wch) override;
        bool ActionExecuteFromEscape(const wchar_t wch) override;

        bool ActionPrint(const wchar_t wch) override;

        bool ActionPrintString(const std::wstring_view string) override;

        bool ActionPassThroughString(const std::wstring_view string) override;

        bool ActionEscDispatch(const VTID id) override;

        bool ActionVt52EscDispatch(const VTID id, const VTParameters parameters) override;

        bool ActionCsiDispatch(const VTID id, const VTParameters parameters) override;

        StringHandler ActionDcsDispatch(const VTID id, const VT...",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft,23,Microsoft,2
581785,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class OutputStateMachineEngine : public IStateMachineEngine
    {
    public:
        static constexpr size_t MAX_URL_LENGTH = 2 * 1048576; // 2MB, like iTerm2

        OutputStateMachineEngine(std::unique_ptr<ITermDispatch> pDispatch);

        bool EncounteredWin32InputModeSequence() const noexcept override;

        bool ActionExecute(const wchar_t wch) override;
        bool ActionExecuteFromEscape(const wchar_t wch) override;

        bool ActionPrint(const wchar_t wch) override;

        bool ActionPrintString(const std::wstring_view string) override;

        bool ActionPassThroughString(const std::wstring_view string) override;

        bool ActionEscDispatch(const VTID id) override;

        bool ActionVt52EscDispatch(const VTID id, const VTParameters parameters) override;

        bool ActionCsiDispatch(const VTID id, const VTParameters parameters) override;

        StringHandler ActionDcsDispatch(const VTID id, const VT...",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft.Console,23,Console,1
581786,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class OutputStateMachineEngine : public IStateMachineEngine
    {
    public:
        static constexpr size_t MAX_URL_LENGTH = 2 * 1048576; // 2MB, like iTerm2

        OutputStateMachineEngine(std::unique_ptr<ITermDispatch> pDispatch);

        bool EncounteredWin32InputModeSequence() const noexcept override;

        bool ActionExecute(const wchar_t wch) override;
        bool ActionExecuteFromEscape(const wchar_t wch) override;

        bool ActionPrint(const wchar_t wch) override;

        bool ActionPrintString(const std::wstring_view string) override;

        bool ActionPassThroughString(const std::wstring_view string) override;

        bool ActionEscDispatch(const VTID id) override;

        bool ActionVt52EscDispatch(const VTID id, const VTParameters parameters) override;

        bool ActionCsiDispatch(const VTID id, const VTParameters parameters) override;

        StringHandler ActionDcsDispatch(const VTID id, const VT...",1,terminal\parser\OutputStateMachineEngine.hpp,Microsoft.Console.VirtualTerminal,23,VirtualTerminal,1
582602,NAMESPACE_BLOCK,<empty>,,terminal\parser\ascii.hpp,terminal\parser\ascii.hpp:<global>,,<global>,1
582606,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    enum AsciiChars : wchar_t
    {
        NUL = 0x0, // Null
        SOH = 0x1, // Start of Heading
        STX = 0x2, // Start of Text
        ETX = 0x3, // End of Text
        EOT = 0x4, // End of Transmission
        ENQ = 0x5, // Enquiry
        ACK = 0x6, // Acknowledge
        BEL = 0x7, // Bell
        BS = 0x8, // Backspace
        TAB = 0x9, // Horizontal Tab
        LF = 0xA, // Line Feed (new line)
        VT = 0xB, // Vertical Tab
        FF = 0xC, // Form Feed (new page)
        CR = 0xD, // Carriage Return
        SO = 0xE, // Shift Out
        SI = 0xF, // Shift In
        DLE = 0x10, // Data Link Escape
        DC1 = 0x11, // Device Control 1
        DC2 = 0x12, // Device Control 2
        DC3 = 0x13, // Device Control 3
        DC4 = 0x14, // Device Control 4
        NAK = 0x15, // Negative Acknowledge
        SYN = 0x16, // Synchronous Idle
        ETB = 0x17, // End of Transmission Block
        CAN = 0x18, // Canc...",1,terminal\parser\ascii.hpp,Microsoft,6,Microsoft,1
582607,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    enum AsciiChars : wchar_t
    {
        NUL = 0x0, // Null
        SOH = 0x1, // Start of Heading
        STX = 0x2, // Start of Text
        ETX = 0x3, // End of Text
        EOT = 0x4, // End of Transmission
        ENQ = 0x5, // Enquiry
        ACK = 0x6, // Acknowledge
        BEL = 0x7, // Bell
        BS = 0x8, // Backspace
        TAB = 0x9, // Horizontal Tab
        LF = 0xA, // Line Feed (new line)
        VT = 0xB, // Vertical Tab
        FF = 0xC, // Form Feed (new page)
        CR = 0xD, // Carriage Return
        SO = 0xE, // Shift Out
        SI = 0xF, // Shift In
        DLE = 0x10, // Data Link Escape
        DC1 = 0x11, // Device Control 1
        DC2 = 0x12, // Device Control 2
        DC3 = 0x13, // Device Control 3
        DC4 = 0x14, // Device Control 4
        NAK = 0x15, // Negative Acknowledge
        SYN = 0x16, // Synchronous Idle
        ETB = 0x17, // End of Transmission Block
        CAN = 0x18, // Canc...",1,terminal\parser\ascii.hpp,Microsoft.Console,6,Console,1
582608,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    enum AsciiChars : wchar_t
    {
        NUL = 0x0, // Null
        SOH = 0x1, // Start of Heading
        STX = 0x2, // Start of Text
        ETX = 0x3, // End of Text
        EOT = 0x4, // End of Transmission
        ENQ = 0x5, // Enquiry
        ACK = 0x6, // Acknowledge
        BEL = 0x7, // Bell
        BS = 0x8, // Backspace
        TAB = 0x9, // Horizontal Tab
        LF = 0xA, // Line Feed (new line)
        VT = 0xB, // Vertical Tab
        FF = 0xC, // Form Feed (new page)
        CR = 0xD, // Carriage Return
        SO = 0xE, // Shift Out
        SI = 0xF, // Shift In
        DLE = 0x10, // Data Link Escape
        DC1 = 0x11, // Device Control 1
        DC2 = 0x12, // Device Control 2
        DC3 = 0x13, // Device Control 3
        DC4 = 0x14, // Device Control 4
        NAK = 0x15, // Negative Acknowledge
        SYN = 0x16, // Synchronous Idle
        ETB = 0x17, // End of Transmission Block
        CAN = 0x18, // Canc...",1,terminal\parser\ascii.hpp,Microsoft.Console.VirtualTerminal,6,VirtualTerminal,1
582789,NAMESPACE_BLOCK,<empty>,,terminal\parser\base64.cpp,terminal\parser\base64.cpp:<global>,,<global>,1
583205,NAMESPACE_BLOCK,<empty>,,terminal\parser\base64.hpp,terminal\parser\base64.hpp:<global>,,<global>,1
583209,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class Base64
    {
    public:
        static HRESULT Decode(const std::wstring_view& src, std::wstring& dst) noexcept;
    };
}",1,terminal\parser\base64.hpp,Microsoft,14,Microsoft,1
583210,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class Base64
    {
    public:
        static HRESULT Decode(const std::wstring_view& src, std::wstring& dst) noexcept;
    };
}",1,terminal\parser\base64.hpp,Microsoft.Console,14,Console,1
583211,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class Base64
    {
    public:
        static HRESULT Decode(const std::wstring_view& src, std::wstring& dst) noexcept;
    };
}",1,terminal\parser\base64.hpp,Microsoft.Console.VirtualTerminal,14,VirtualTerminal,1
584488,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>,,<global>,1
585780,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\fuzzing_directed.hpp,terminal\parser\ft_fuzzer\fuzzing_directed.hpp:<global>,,<global>,1
585784,NAMESPACE_BLOCK,"namespace variadic
{
    template<int... Is>
    struct index
    {
    };

    template<int N, int... Is>
    struct gen_seq : gen_seq<N - 1, N - 1, Is...>
    {
    };

    template<int... Is>
    struct gen_seq<0, Is...> : index<Is...>
    {
    };
}",1,terminal\parser\ft_fuzzer\fuzzing_directed.hpp,variadic,34,variadic,1
585788,NAMESPACE_BLOCK,"namespace fuzz
{
    // Fuzz traits change inherent behavior of the CFuzzType class
    // (and associated derived classes).  This is a bit-flag such that
    // multiple traits can be applied as needed.
    enum _FuzzTraits : unsigned int
    {
        // Default behavior is to not throw exceptions
        TRAIT_DEFAULT = 0x0,

        // In the event that the fuzz map percentages add up to more than
        // 100% during constructor initialization, an exception of type
        // CFuzzRangeException is thrown.
        TRAIT_THROW_ON_INIT_FAILURE = 0x1,

        // For classes that could realloc a buffer in order to grow or
        // shrink the size of the fuzzed result, this results in having
        // two different buffers that need to be freed.  To make the calling
        // code work correctly, we can use the flag below to transfer the
        // allocation ownership such that the calling code frees the correct
        // buffer and our fuzz classes frees the other buffer.
...",1,terminal\parser\ft_fuzzer\fuzzing_directed.hpp,fuzz,52,fuzz,2
586577,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\fuzzing_logic.hpp,terminal\parser\ft_fuzzer\fuzzing_logic.hpp:<global>,,<global>,1
586582,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\memallocator.hpp,terminal\parser\ft_fuzzer\memallocator.hpp:<global>,,<global>,1
586586,NAMESPACE_BLOCK,"namespace fuzz
{
    struct CFuzzCRTAllocator
    {
        _Ret_maybenull_ _Post_writable_byte_size_(nBytes) static void* Reallocate(
            _In_ void* p,
            _In_ size_t nBytes) throw()
        {
            return realloc(p, nBytes);
        }

        _Ret_maybenull_ _Post_writable_byte_size_(nBytes) static void* Allocate(_In_ size_t nBytes) throw()
        {
            return malloc(nBytes);
        }

        static void Free(_In_ void* p) throw()
        {
            free(p);
        }
    };
}",1,terminal\parser\ft_fuzzer\memallocator.hpp,fuzz,9,fuzz,1
586601,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\stdafx.cpp,terminal\parser\ft_fuzzer\stdafx.cpp:<global>,,<global>,1
586614,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\stdafx.hpp,terminal\parser\ft_fuzzer\stdafx.hpp:<global>,,<global>,1
586619,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzer\string_helper.hpp,terminal\parser\ft_fuzzer\string_helper.hpp:<global>,,<global>,1
586631,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzwrapper\echoDispatch.cpp,terminal\parser\ft_fuzzwrapper\echoDispatch.cpp:<global>,,<global>,1
586665,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzwrapper\echoDispatch.hpp,terminal\parser\ft_fuzzwrapper\echoDispatch.hpp:<global>,,<global>,1
586669,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class EchoDispatch : public TermDispatch
            {
            public:
                void Print(const wchar_t wchPrintable) override;
                void PrintString(const std::wstring_view string) override;
            };
        }
    }
}",1,terminal\parser\ft_fuzzwrapper\echoDispatch.hpp,Microsoft,6,Microsoft,1
586670,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class EchoDispatch : public TermDispatch
            {
            public:
                void Print(const wchar_t wchPrintable) override;
                void PrintString(const std::wstring_view string) override;
            };
        }
    }",5,terminal\parser\ft_fuzzwrapper\echoDispatch.hpp,Microsoft.Console,8,Console,1
586671,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class EchoDispatch : public TermDispatch
            {
            public:
                void Print(const wchar_t wchPrintable) override;
                void PrintString(const std::wstring_view string) override;
            };
        }",9,terminal\parser\ft_fuzzwrapper\echoDispatch.hpp,Microsoft.Console.VirtualTerminal,10,VirtualTerminal,1
586692,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzwrapper\main.cpp,terminal\parser\ft_fuzzwrapper\main.cpp:<global>,,<global>,1
586893,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzwrapper\precomp.cpp,terminal\parser\ft_fuzzwrapper\precomp.cpp:<global>,,<global>,1
586906,NAMESPACE_BLOCK,<empty>,,terminal\parser\ft_fuzzwrapper\precomp.hpp,terminal\parser\ft_fuzzwrapper\precomp.hpp:<global>,,<global>,1
586913,NAMESPACE_BLOCK,<empty>,,terminal\parser\precomp.cpp,terminal\parser\precomp.cpp:<global>,,<global>,1
586930,NAMESPACE_BLOCK,<empty>,,terminal\parser\precomp.hpp,terminal\parser\precomp.hpp:<global>,,<global>,1
587139,NAMESPACE_BLOCK,<empty>,,terminal\parser\stateMachine.cpp,terminal\parser\stateMachine.cpp:<global>,,<global>,1
589807,NAMESPACE_BLOCK,<empty>,,terminal\parser\stateMachine.hpp,terminal\parser\stateMachine.hpp:<global>,,<global>,1
589811,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The DEC STD 070 reference recommends supporting up to at least 16384
    // for parameter values. 65535 is what XTerm and VTE support.
    // GH#12977: We must use 65535 to properly parse win32-input-mode
    // sequences, which transmit the UTF-16 character value as a parameter.
    constexpr VTInt MAX_PARAMETER_VALUE = 65535;

    // The DEC STD 070 reference requires that a minimum of 16 parameter values
    // are supported, but most modern terminal emulators will allow around twice
    // that number.
    constexpr size_t MAX_PARAMETER_COUNT = 32;

    // Sub parameter limit for each parameter.
    constexpr size_t MAX_SUBPARAMETER_COUNT = 6;
    // we limit ourself to 256 sub parameters because we use bytes to store
    // the their indexes.
    static_assert(MAX_PARAMETER_COUNT * MAX_SUBPARAMETER_COUNT <= 256);

    class StateMachine final
    {
#ifdef UNIT_TESTING
        friend class OutputEngineTest;
        friend cl...",1,terminal\parser\stateMachine.hpp,Microsoft,21,Microsoft,1
589812,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The DEC STD 070 reference recommends supporting up to at least 16384
    // for parameter values. 65535 is what XTerm and VTE support.
    // GH#12977: We must use 65535 to properly parse win32-input-mode
    // sequences, which transmit the UTF-16 character value as a parameter.
    constexpr VTInt MAX_PARAMETER_VALUE = 65535;

    // The DEC STD 070 reference requires that a minimum of 16 parameter values
    // are supported, but most modern terminal emulators will allow around twice
    // that number.
    constexpr size_t MAX_PARAMETER_COUNT = 32;

    // Sub parameter limit for each parameter.
    constexpr size_t MAX_SUBPARAMETER_COUNT = 6;
    // we limit ourself to 256 sub parameters because we use bytes to store
    // the their indexes.
    static_assert(MAX_PARAMETER_COUNT * MAX_SUBPARAMETER_COUNT <= 256);

    class StateMachine final
    {
#ifdef UNIT_TESTING
        friend class OutputEngineTest;
        friend cl...",1,terminal\parser\stateMachine.hpp,Microsoft.Console,21,Console,1
589813,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    // The DEC STD 070 reference recommends supporting up to at least 16384
    // for parameter values. 65535 is what XTerm and VTE support.
    // GH#12977: We must use 65535 to properly parse win32-input-mode
    // sequences, which transmit the UTF-16 character value as a parameter.
    constexpr VTInt MAX_PARAMETER_VALUE = 65535;

    // The DEC STD 070 reference requires that a minimum of 16 parameter values
    // are supported, but most modern terminal emulators will allow around twice
    // that number.
    constexpr size_t MAX_PARAMETER_COUNT = 32;

    // Sub parameter limit for each parameter.
    constexpr size_t MAX_SUBPARAMETER_COUNT = 6;
    // we limit ourself to 256 sub parameters because we use bytes to store
    // the their indexes.
    static_assert(MAX_PARAMETER_COUNT * MAX_SUBPARAMETER_COUNT <= 256);

    class StateMachine final
    {
#ifdef UNIT_TESTING
        friend class OutputEngineTest;
        friend cl...",1,terminal\parser\stateMachine.hpp,Microsoft.Console.VirtualTerminal,21,VirtualTerminal,1
590267,NAMESPACE_BLOCK,<empty>,,terminal\parser\tracing.cpp,terminal\parser\tracing.cpp:<global>,,<global>,1
590508,NAMESPACE_BLOCK,<empty>,,terminal\parser\tracing.hpp,terminal\parser\tracing.hpp:<global>,,<global>,1
590513,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ParserTracing sealed
    {
    public:
        // NOTE: This code uses
        //   (_In_z_ const wchar_t* name)
        // as arguments instead of the more modern std::wstring_view
        // for performance reasons.
        //
        // Passing structures larger than the register size is very expensive
        // due to Microsoft's x64 calling convention. We could reduce the
        // overhead by passing the string-view by reference, but this forces us
        // to allocate the parameters as static string-views on the data
        // segment of our binary. I've found that passing them as classic
        // C-strings is more ergonomic instead and fits the need for
        // high performance in this particular code.

        void TraceStateChange(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnAction(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnExecute(const wchar_t wch) const noexcept;
...",1,terminal\parser\tracing.hpp,Microsoft,23,Microsoft,2
590514,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ParserTracing sealed
    {
    public:
        // NOTE: This code uses
        //   (_In_z_ const wchar_t* name)
        // as arguments instead of the more modern std::wstring_view
        // for performance reasons.
        //
        // Passing structures larger than the register size is very expensive
        // due to Microsoft's x64 calling convention. We could reduce the
        // overhead by passing the string-view by reference, but this forces us
        // to allocate the parameters as static string-views on the data
        // segment of our binary. I've found that passing them as classic
        // C-strings is more ergonomic instead and fits the need for
        // high performance in this particular code.

        void TraceStateChange(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnAction(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnExecute(const wchar_t wch) const noexcept;
...",1,terminal\parser\tracing.hpp,Microsoft.Console,23,Console,1
590515,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class ParserTracing sealed
    {
    public:
        // NOTE: This code uses
        //   (_In_z_ const wchar_t* name)
        // as arguments instead of the more modern std::wstring_view
        // for performance reasons.
        //
        // Passing structures larger than the register size is very expensive
        // due to Microsoft's x64 calling convention. We could reduce the
        // overhead by passing the string-view by reference, but this forces us
        // to allocate the parameters as static string-views on the data
        // segment of our binary. I've found that passing them as classic
        // C-strings is more ergonomic instead and fits the need for
        // high performance in this particular code.

        void TraceStateChange(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnAction(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnExecute(const wchar_t wch) const noexcept;
...",1,terminal\parser\tracing.hpp,Microsoft.Console.VirtualTerminal,23,VirtualTerminal,1
590528,NAMESPACE_BLOCK,<empty>,,terminal\parser\ut_parser\Base64Test.cpp,terminal\parser\ut_parser\Base64Test.cpp:<global>,,<global>,1
590532,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class Base64Test;
        };
    };
}",1,terminal\parser\ut_parser\Base64Test.cpp,Microsoft,16,Microsoft,1
590533,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class Base64Test;
        };
    }",5,terminal\parser\ut_parser\Base64Test.cpp,Microsoft.Console,18,Console,1
590534,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class Base64Test;
        }",9,terminal\parser\ut_parser\Base64Test.cpp,Microsoft.Console.VirtualTerminal,20,VirtualTerminal,1
590622,NAMESPACE_BLOCK,<empty>,,terminal\parser\ut_parser\InputEngineTest.cpp,terminal\parser\ut_parser\InputEngineTest.cpp:<global>,,<global>,1
590625,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class InputEngineTest;
            class TestInteractDispatch;
        };
    };
}",1,terminal\parser\ut_parser\InputEngineTest.cpp,Microsoft,27,Microsoft,1
590626,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class InputEngineTest;
            class TestInteractDispatch;
        };
    }",5,terminal\parser\ut_parser\InputEngineTest.cpp,Microsoft.Console,29,Console,1
590627,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class InputEngineTest;
            class TestInteractDispatch;
        }",9,terminal\parser\ut_parser\InputEngineTest.cpp,Microsoft.Console.VirtualTerminal,31,VirtualTerminal,1
596917,NAMESPACE_BLOCK,<empty>,,terminal\parser\ut_parser\OutputEngineTest.cpp,terminal\parser\ut_parser\OutputEngineTest.cpp:<global>,,<global>,1
596921,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class OutputEngineTest;
        }
    }
}",1,terminal\parser\ut_parser\OutputEngineTest.cpp,Microsoft,19,Microsoft,1
596922,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class OutputEngineTest;
        }
    }",5,terminal\parser\ut_parser\OutputEngineTest.cpp,Microsoft.Console,21,Console,1
596923,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class OutputEngineTest;
        }",9,terminal\parser\ut_parser\OutputEngineTest.cpp,Microsoft.Console.VirtualTerminal,23,VirtualTerminal,1
600871,NAMESPACE_BLOCK,<empty>,,terminal\parser\ut_parser\StateMachineTest.cpp,terminal\parser\ut_parser\StateMachineTest.cpp:<global>,,<global>,1
600875,NAMESPACE_BLOCK,"namespace Microsoft
{
    namespace Console
    {
        namespace VirtualTerminal
        {
            class StateMachineTest;
            class TestStateMachineEngine;
        };
    };
}",1,terminal\parser\ut_parser\StateMachineTest.cpp,Microsoft,14,Microsoft,1
600876,NAMESPACE_BLOCK,"namespace Console
    {
        namespace VirtualTerminal
        {
            class StateMachineTest;
            class TestStateMachineEngine;
        };
    }",5,terminal\parser\ut_parser\StateMachineTest.cpp,Microsoft.Console,16,Console,1
600877,NAMESPACE_BLOCK,"namespace VirtualTerminal
        {
            class StateMachineTest;
            class TestStateMachineEngine;
        }",9,terminal\parser\ut_parser\StateMachineTest.cpp,Microsoft.Console.VirtualTerminal,18,VirtualTerminal,1
601916,NAMESPACE_BLOCK,<empty>,,til\precomp.cpp,til\precomp.cpp:<global>,,<global>,1
601931,NAMESPACE_BLOCK,<empty>,,til\precomp.hpp,til\precomp.hpp:<global>,,<global>,1
601935,NAMESPACE_BLOCK,"namespace winrt {
    namespace Windows {
        namespace Foundation {
            struct Rect
            {
                FLOAT X;
                FLOAT Y;
                FLOAT Width;
                FLOAT Height;
            };

            struct Point
            {
                FLOAT X;
                FLOAT Y;
            };

            struct Size
            {
                FLOAT Width;
                FLOAT Height;
            };
        } /* Foundation */
    } /* Windows */
}",1,til\precomp.hpp,winrt,42,winrt,1
601936,NAMESPACE_BLOCK,"namespace Windows {
        namespace Foundation {
            struct Rect
            {
                FLOAT X;
                FLOAT Y;
                FLOAT Width;
                FLOAT Height;
            };

            struct Point
            {
                FLOAT X;
                FLOAT Y;
            };

            struct Size
            {
                FLOAT Width;
                FLOAT Height;
            };
        } /* Foundation */
    }",5,til\precomp.hpp,winrt.Windows,43,Windows,1
601937,NAMESPACE_BLOCK,"namespace Foundation {
            struct Rect
            {
                FLOAT X;
                FLOAT Y;
                FLOAT Width;
                FLOAT Height;
            };

            struct Point
            {
                FLOAT X;
                FLOAT Y;
            };

            struct Size
            {
                FLOAT Width;
                FLOAT Height;
            };
        }",9,til\precomp.hpp,winrt.Windows.Foundation,44,Foundation,1
601954,NAMESPACE_BLOCK,<empty>,,til\ut_til\BaseTests.cpp,til\ut_til\BaseTests.cpp:<global>,,<global>,1
601979,NAMESPACE_BLOCK,<empty>,,til\ut_til\BitmapTests.cpp,til\ut_til\BitmapTests.cpp:<global>,,<global>,1
602605,NAMESPACE_BLOCK,<empty>,,til\ut_til\CoalesceTests.cpp,til\ut_til\CoalesceTests.cpp:<global>,,<global>,1
602899,NAMESPACE_BLOCK,<empty>,,til\ut_til\ColorTests.cpp,til\ut_til\ColorTests.cpp:<global>,,<global>,1
603069,NAMESPACE_BLOCK,<empty>,,til\ut_til\EnumSetTests.cpp,til\ut_til\EnumSetTests.cpp:<global>,,<global>,1
603288,NAMESPACE_BLOCK,<empty>,,til\ut_til\EnvTests.cpp,til\ut_til\EnvTests.cpp:<global>,,<global>,1
603456,NAMESPACE_BLOCK,<empty>,,til\ut_til\FlatSetTests.cpp,til\ut_til\FlatSetTests.cpp:<global>,,<global>,1
603535,NAMESPACE_BLOCK,<empty>,,til\ut_til\GenerationalTests.cpp,til\ut_til\GenerationalTests.cpp:<global>,,<global>,1
603566,NAMESPACE_BLOCK,<empty>,,til\ut_til\HashTests.cpp,til\ut_til\HashTests.cpp:<global>,,<global>,1
603631,NAMESPACE_BLOCK,<empty>,,til\ut_til\MathTests.cpp,til\ut_til\MathTests.cpp:<global>,,<global>,1
603708,NAMESPACE_BLOCK,<empty>,,til\ut_til\OperatorTests.cpp,til\ut_til\OperatorTests.cpp:<global>,,<global>,1
603904,NAMESPACE_BLOCK,<empty>,,til\ut_til\PointTests.cpp,til\ut_til\PointTests.cpp:<global>,,<global>,1
604135,NAMESPACE_BLOCK,<empty>,,til\ut_til\RectangleTests.cpp,til\ut_til\RectangleTests.cpp:<global>,,<global>,1
605269,NAMESPACE_BLOCK,<empty>,,til\ut_til\ReplaceTests.cpp,til\ut_til\ReplaceTests.cpp:<global>,,<global>,1
605626,NAMESPACE_BLOCK,<empty>,,til\ut_til\RunLengthEncodingTests.cpp,til\ut_til\RunLengthEncodingTests.cpp:<global>,,<global>,1
605630,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    template<typename T, typename S, typename Container>
    class VerifyCompareTraits<::std::string_view, ::til::basic_rle<T, S, Container>>
    {
        using rle_vector = ::til::basic_rle<T, S, Container>;
        using value_type = typename rle_vector::value_type;

    public:
        static bool AreEqual(const ::std::string_view& expected, const rle_vector& actual) noexcept
        {
            auto it = expected.data();
            const auto end = it + expected.size();
            size_t expected_size = 0;

            for (const auto& run : actual.runs())
            {
                const auto actual_value = run.value;
                const auto length = run.length;

                if (length == 0)
                {
                    return false;
                }

                for (size_t i = 0; i < length; ++it)
                {
                    if (it == end)
                    {
                        return false;
        ...",1,til\ut_til\RunLengthEncodingTests.cpp,WEX,14,WEX,1
605631,NAMESPACE_BLOCK,"namespace WEX::TestExecution
{
    template<typename T, typename S, typename Container>
    class VerifyCompareTraits<::std::string_view, ::til::basic_rle<T, S, Container>>
    {
        using rle_vector = ::til::basic_rle<T, S, Container>;
        using value_type = typename rle_vector::value_type;

    public:
        static bool AreEqual(const ::std::string_view& expected, const rle_vector& actual) noexcept
        {
            auto it = expected.data();
            const auto end = it + expected.size();
            size_t expected_size = 0;

            for (const auto& run : actual.runs())
            {
                const auto actual_value = run.value;
                const auto length = run.length;

                if (length == 0)
                {
                    return false;
                }

                for (size_t i = 0; i < length; ++it)
                {
                    if (it == end)
                    {
                        return false;
        ...",1,til\ut_til\RunLengthEncodingTests.cpp,WEX.TestExecution,14,TestExecution,1
606225,NAMESPACE_BLOCK,<empty>,,til\ut_til\SPSCTests.cpp,til\ut_til\SPSCTests.cpp:<global>,,<global>,1
606832,NAMESPACE_BLOCK,<empty>,,til\ut_til\SizeTests.cpp,til\ut_til\SizeTests.cpp:<global>,,<global>,1
607075,NAMESPACE_BLOCK,<empty>,,til\ut_til\SmallVectorTests.cpp,til\ut_til\SmallVectorTests.cpp:<global>,,<global>,1
607319,NAMESPACE_BLOCK,<empty>,,til\ut_til\SomeTests.cpp,til\ut_til\SomeTests.cpp:<global>,,<global>,1
607669,NAMESPACE_BLOCK,<empty>,,til\ut_til\StaticMapTests.cpp,til\ut_til\StaticMapTests.cpp:<global>,,<global>,1
607788,NAMESPACE_BLOCK,<empty>,,til\ut_til\UnicodeTests.cpp,til\ut_til\UnicodeTests.cpp:<global>,,<global>,1
607928,NAMESPACE_BLOCK,<empty>,,til\ut_til\mutex.cpp,til\ut_til\mutex.cpp:<global>,,<global>,1
607939,NAMESPACE_BLOCK,<empty>,,til\ut_til\string.cpp,til\ut_til\string.cpp:<global>,,<global>,1
608075,NAMESPACE_BLOCK,<empty>,,til\ut_til\throttled_func.cpp,til\ut_til\throttled_func.cpp:<global>,,<global>,1
608088,NAMESPACE_BLOCK,<empty>,,til\ut_til\u8u16convertTests.cpp,til\ut_til\u8u16convertTests.cpp:<global>,,<global>,1
608557,NAMESPACE_BLOCK,<empty>,,tools\ConsoleMonitor\main.cpp,tools\ConsoleMonitor\main.cpp:<global>,,<global>,1
609225,NAMESPACE_BLOCK,<empty>,,tools\ConsoleMonitor\pch.cpp,tools\ConsoleMonitor\pch.cpp:<global>,,<global>,1
609236,NAMESPACE_BLOCK,<empty>,,tools\ConsoleMonitor\pch.hpp,tools\ConsoleMonitor\pch.hpp:<global>,,<global>,1
609247,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\AppState.cpp,tools\MonarchPeasantSample\AppState.cpp:<global>,,<global>,1
609495,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\AppState.hpp,tools\MonarchPeasantSample\AppState.hpp:<global>,,<global>,1
609580,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\MonarchMain.cpp,tools\MonarchPeasantSample\MonarchMain.cpp:<global>,,<global>,1
609672,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\PeasantMain.cpp,tools\MonarchPeasantSample\PeasantMain.cpp:<global>,,<global>,1
609930,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\SampleMonarch.cpp,tools\MonarchPeasantSample\SampleMonarch.cpp:<global>,,<global>,1
609934,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Monarch::Monarch()
    {
        printf(""Instantiated a Monarch\n"");
    }

    Monarch::~Monarch()
    {
        printf(""~Monarch()\n"");
    }

    uint64_t Monarch::GetPID()
    {
        return GetCurrentProcessId();
    }

    uint64_t Monarch::AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant)
    {
        // This whole algorithm is terrible. There's gotta be a better way
        // of finding the first opening in a non-consecutive map of int->object
        auto providedID = peasant.GetID();

        if (providedID == 0)
        {
            peasant.AssignID(_nextPeasantID++);
            printf(""Assigned the peasant the ID %lld\n"", peasant.GetID());
        }
        else
        {
            printf(""Peasant already had an ID, %lld\n"", peasant.GetID());
            _nextPeasantID = providedID >= _nextPeasantID ? providedID + 1 : _nextPeasantID;
        }
        auto newPeasantsId = peasant.GetID();
       ...",1,tools\MonarchPeasantSample\SampleMonarch.cpp,winrt,11,winrt,1
609935,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Monarch::Monarch()
    {
        printf(""Instantiated a Monarch\n"");
    }

    Monarch::~Monarch()
    {
        printf(""~Monarch()\n"");
    }

    uint64_t Monarch::GetPID()
    {
        return GetCurrentProcessId();
    }

    uint64_t Monarch::AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant)
    {
        // This whole algorithm is terrible. There's gotta be a better way
        // of finding the first opening in a non-consecutive map of int->object
        auto providedID = peasant.GetID();

        if (providedID == 0)
        {
            peasant.AssignID(_nextPeasantID++);
            printf(""Assigned the peasant the ID %lld\n"", peasant.GetID());
        }
        else
        {
            printf(""Peasant already had an ID, %lld\n"", peasant.GetID());
            _nextPeasantID = providedID >= _nextPeasantID ? providedID + 1 : _nextPeasantID;
        }
        auto newPeasantsId = peasant.GetID();
       ...",1,tools\MonarchPeasantSample\SampleMonarch.cpp,winrt.MonarchPeasantSample,11,MonarchPeasantSample,1
609936,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Monarch::Monarch()
    {
        printf(""Instantiated a Monarch\n"");
    }

    Monarch::~Monarch()
    {
        printf(""~Monarch()\n"");
    }

    uint64_t Monarch::GetPID()
    {
        return GetCurrentProcessId();
    }

    uint64_t Monarch::AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant)
    {
        // This whole algorithm is terrible. There's gotta be a better way
        // of finding the first opening in a non-consecutive map of int->object
        auto providedID = peasant.GetID();

        if (providedID == 0)
        {
            peasant.AssignID(_nextPeasantID++);
            printf(""Assigned the peasant the ID %lld\n"", peasant.GetID());
        }
        else
        {
            printf(""Peasant already had an ID, %lld\n"", peasant.GetID());
            _nextPeasantID = providedID >= _nextPeasantID ? providedID + 1 : _nextPeasantID;
        }
        auto newPeasantsId = peasant.GetID();
       ...",1,tools\MonarchPeasantSample\SampleMonarch.cpp,winrt.MonarchPeasantSample.implementation,11,implementation,1
610334,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\SampleMonarch.hpp,tools\MonarchPeasantSample\SampleMonarch.hpp:<global>,,<global>,1
610367,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Monarch : public MonarchT<Monarch>
    {
        Monarch();
        ~Monarch();

        uint64_t GetPID();

        uint64_t AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant);

        void SetSelfID(const uint64_t selfID);

        bool ProposeCommandline(array_view<const winrt::hstring> args, winrt::hstring cwd);
        void ToggleWindowingBehavior();

    private:
        uint64_t _nextPeasantID{ 1 };
        uint64_t _thisPeasantID{ 0 };
        uint64_t _mostRecentPeasant{ 0 };
        WindowingBehavior _windowingBehavior{ WindowingBehavior::UseNew };
        std::unordered_map<uint64_t, winrt::MonarchPeasantSample::IPeasant> _peasants;

        winrt::MonarchPeasantSample::IPeasant _getPeasant(uint64_t peasantID);
        void _setMostRecentPeasant(const uint64_t peasantID);

        void _peasantWindowActivated(const winrt::Windows::Foundation::IInspectable& sender,
                                  ...",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt,20,winrt,4
610368,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Monarch : public MonarchT<Monarch>
    {
        Monarch();
        ~Monarch();

        uint64_t GetPID();

        uint64_t AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant);

        void SetSelfID(const uint64_t selfID);

        bool ProposeCommandline(array_view<const winrt::hstring> args, winrt::hstring cwd);
        void ToggleWindowingBehavior();

    private:
        uint64_t _nextPeasantID{ 1 };
        uint64_t _thisPeasantID{ 0 };
        uint64_t _mostRecentPeasant{ 0 };
        WindowingBehavior _windowingBehavior{ WindowingBehavior::UseNew };
        std::unordered_map<uint64_t, winrt::MonarchPeasantSample::IPeasant> _peasants;

        winrt::MonarchPeasantSample::IPeasant _getPeasant(uint64_t peasantID);
        void _setMostRecentPeasant(const uint64_t peasantID);

        void _peasantWindowActivated(const winrt::Windows::Foundation::IInspectable& sender,
                                  ...",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt.MonarchPeasantSample,20,MonarchPeasantSample,1
610369,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Monarch : public MonarchT<Monarch>
    {
        Monarch();
        ~Monarch();

        uint64_t GetPID();

        uint64_t AddPeasant(winrt::MonarchPeasantSample::IPeasant peasant);

        void SetSelfID(const uint64_t selfID);

        bool ProposeCommandline(array_view<const winrt::hstring> args, winrt::hstring cwd);
        void ToggleWindowingBehavior();

    private:
        uint64_t _nextPeasantID{ 1 };
        uint64_t _thisPeasantID{ 0 };
        uint64_t _mostRecentPeasant{ 0 };
        WindowingBehavior _windowingBehavior{ WindowingBehavior::UseNew };
        std::unordered_map<uint64_t, winrt::MonarchPeasantSample::IPeasant> _peasants;

        winrt::MonarchPeasantSample::IPeasant _getPeasant(uint64_t peasantID);
        void _setMostRecentPeasant(const uint64_t peasantID);

        void _peasantWindowActivated(const winrt::Windows::Foundation::IInspectable& sender,
                                  ...",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt.MonarchPeasantSample.implementation,20,implementation,1
610446,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Monarch);
}",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt,51,winrt,5
610447,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Monarch);
}",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt.MonarchPeasantSample,51,MonarchPeasantSample,1
610448,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Monarch);
}",1,tools\MonarchPeasantSample\SampleMonarch.hpp,winrt.MonarchPeasantSample.factory_implementation,51,factory_implementation,1
610459,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\SamplePeasant.cpp,tools\MonarchPeasantSample\SamplePeasant.cpp:<global>,,<global>,1
610463,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Peasant::Peasant()
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }
    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return GetCurrentProcessId();
    }

    bool Peasant::ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory)
    {
        auto argsProcessed = 0;
        std::wstring fullCmdline;
        for (const auto& arg : args)
        {
            fullCmdline += argsProcessed++ == 0 ? L""sample.exe"" : arg;
            fullCmdline += L"" "";
        }
        wprintf(L""\x1b[32mExecuted Commandline\x1b[m: \"""");
        wprintf(fullCmdline.c_str());
        wprintf(L""\""\n"");
        return true;
    }

    void Peasant::raiseActivatedEvent()
    {
        _WindowActivatedHandlers(*this, nullptr);
    }

}",1,tools\MonarchPeasantSample\SamplePeasant.cpp,winrt,11,winrt,1
610464,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Peasant::Peasant()
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }
    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return GetCurrentProcessId();
    }

    bool Peasant::ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory)
    {
        auto argsProcessed = 0;
        std::wstring fullCmdline;
        for (const auto& arg : args)
        {
            fullCmdline += argsProcessed++ == 0 ? L""sample.exe"" : arg;
            fullCmdline += L"" "";
        }
        wprintf(L""\x1b[32mExecuted Commandline\x1b[m: \"""");
        wprintf(fullCmdline.c_str());
        wprintf(L""\""\n"");
        return true;
    }

    void Peasant::raiseActivatedEvent()
    {
        _WindowActivatedHandlers(*this, nullptr);
    }

}",1,tools\MonarchPeasantSample\SamplePeasant.cpp,winrt.MonarchPeasantSample,11,MonarchPeasantSample,1
610465,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    Peasant::Peasant()
    {
    }

    void Peasant::AssignID(uint64_t id)
    {
        _id = id;
    }
    uint64_t Peasant::GetID()
    {
        return _id;
    }

    uint64_t Peasant::GetPID()
    {
        return GetCurrentProcessId();
    }

    bool Peasant::ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory)
    {
        auto argsProcessed = 0;
        std::wstring fullCmdline;
        for (const auto& arg : args)
        {
            fullCmdline += argsProcessed++ == 0 ? L""sample.exe"" : arg;
            fullCmdline += L"" "";
        }
        wprintf(L""\x1b[32mExecuted Commandline\x1b[m: \"""");
        wprintf(fullCmdline.c_str());
        wprintf(L""\""\n"");
        return true;
    }

    void Peasant::raiseActivatedEvent()
    {
        _WindowActivatedHandlers(*this, nullptr);
    }

}",1,tools\MonarchPeasantSample\SamplePeasant.cpp,winrt.MonarchPeasantSample.implementation,11,implementation,1
610539,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\SamplePeasant.hpp,tools\MonarchPeasantSample\SamplePeasant.hpp:<global>,,<global>,1
610543,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint64_t GetID();
        uint64_t GetPID();

        bool ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory);

        void raiseActivatedEvent();

        TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        uint64_t _id{ 0 };
    };
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt,5,winrt,1
610544,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint64_t GetID();
        uint64_t GetPID();

        bool ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory);

        void raiseActivatedEvent();

        TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        uint64_t _id{ 0 };
    };
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt.MonarchPeasantSample,5,MonarchPeasantSample,1
610545,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::implementation
{
    struct Peasant : public PeasantT<Peasant>
    {
        Peasant();

        void AssignID(uint64_t id);
        uint64_t GetID();
        uint64_t GetPID();

        bool ExecuteCommandline(winrt::array_view<const winrt::hstring> args, winrt::hstring currentDirectory);

        void raiseActivatedEvent();

        TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);

    private:
        uint64_t _id{ 0 };
    };
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt.MonarchPeasantSample.implementation,5,implementation,1
610584,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Peasant);
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt,26,winrt,2
610585,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Peasant);
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt.MonarchPeasantSample,26,MonarchPeasantSample,1
610586,NAMESPACE_BLOCK,"namespace winrt::MonarchPeasantSample::factory_implementation
{
    BASIC_FACTORY(Peasant);
}",1,tools\MonarchPeasantSample\SamplePeasant.hpp,winrt.MonarchPeasantSample.factory_implementation,26,factory_implementation,1
610605,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\main.cpp,tools\MonarchPeasantSample\main.cpp:<global>,,<global>,1
610882,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\pch.cpp,tools\MonarchPeasantSample\pch.cpp:<global>,,<global>,1
610903,NAMESPACE_BLOCK,<empty>,,tools\MonarchPeasantSample\pch.hpp,tools\MonarchPeasantSample\pch.hpp:<global>,,<global>,1
610936,NAMESPACE_BLOCK,<empty>,,tools\RenderingTests\main.cpp,tools\RenderingTests\main.cpp:<global>,,<global>,1
610939,NAMESPACE_BLOCK,"namespace colorbrewer
{
    inline constexpr uint32_t pastel1[]{
        0xfbb4ae,
        0xb3cde3,
        0xccebc5,
        0xdecbe4,
        0xfed9a6,
        0xffffcc,
        0xe5d8bd,
        0xfddaec,
        0xf2f2f2,
    };
}",1,tools\RenderingTests\main.cpp,colorbrewer,27,colorbrewer,1
610953,NAMESPACE_BLOCK,"namespace
{
    namespace detail
    {

        template<typename F>
        class scope_guard
        {
        public:
            scope_guard(F f) noexcept :
                func(std::move(f))
            {
            }

            ~scope_guard()
            {
                func();
            }

            scope_guard(const scope_guard&) = delete;
            scope_guard(scope_guard&& rhs) = delete;
            scope_guard& operator=(const scope_guard&) = delete;
            scope_guard& operator=(scope_guard&&) = delete;

        private:
            F func;
        };

        enum class scope_guard_helper
        {
        };

        template<typename F>
        scope_guard<F> operator+(scope_guard_helper /*unused*/, F&& fn)
        {
            return scope_guard<F>(std::forward<F>(fn));
        }

    } // namespace detail

// The extra indirection is necessary to prevent __LINE__ to be treated literally.
#define _DEFER_CONCAT_IMPL(a, b) a##b
#define _DEFER_CONCAT(a,...",1,tools\RenderingTests\main.cpp,anonymous_namespace_0,43,,2
610954,NAMESPACE_BLOCK,"namespace detail
    {

        template<typename F>
        class scope_guard
        {
        public:
            scope_guard(F f) noexcept :
                func(std::move(f))
            {
            }

            ~scope_guard()
            {
                func();
            }

            scope_guard(const scope_guard&) = delete;
            scope_guard(scope_guard&& rhs) = delete;
            scope_guard& operator=(const scope_guard&) = delete;
            scope_guard& operator=(scope_guard&&) = delete;

        private:
            F func;
        };

        enum class scope_guard_helper
        {
        };

        template<typename F>
        scope_guard<F> operator+(scope_guard_helper /*unused*/, F&& fn)
        {
            return scope_guard<F>(std::forward<F>(fn));
        }

    }",5,tools\RenderingTests\main.cpp,anonymous_namespace_1.detail,45,detail,1
611161,NAMESPACE_BLOCK,<empty>,,tools\U8U16Test\U8U16Test.cpp,tools\U8U16Test\U8U16Test.cpp:<global>,,<global>,1
613736,NAMESPACE_BLOCK,<empty>,,tools\U8U16Test\U8U16Test.hpp,tools\U8U16Test\U8U16Test.hpp:<global>,,<global>,1
613951,NAMESPACE_BLOCK,<empty>,,tools\U8U16Test\main.cpp,tools\U8U16Test\main.cpp:<global>,,<global>,1
616538,NAMESPACE_BLOCK,<empty>,,tools\benchcat\crt.cpp,tools\benchcat\crt.cpp:<global>,,<global>,1
616555,NAMESPACE_BLOCK,<empty>,,tools\benchcat\main.cpp,tools\benchcat\main.cpp:<global>,,<global>,1
616559,NAMESPACE_BLOCK,"namespace pcg_engines
{
    /*
     * PCG Random Number Generation for C++
     *
     * Copyright 2014-2017 Melissa O'Neill <oneill@pcg-random.org>,
     *                     and the PCG Project contributors.
     *
     * SPDX-License-Identifier: (Apache-2.0 OR MIT)
     *
     * Licensed under the Apache License, Version 2.0 (provided in
     * LICENSE-APACHE.txt and at http://www.apache.org/licenses/LICENSE-2.0)
     * or under the MIT license (provided in LICENSE-MIT.txt and at
     * http://opensource.org/licenses/MIT), at your option. This file may not
     * be copied, modified, or distributed except according to those terms.
     *
     * Distributed on an ""AS IS"" BASIS, WITHOUT WARRANTY OF ANY KIND, either
     * express or implied.  See your chosen license for details.
     *
     * For additional information about the PCG random number generation scheme,
     * visit http://www.pcg-random.org/.
     */

    class oneseq_dxsm_64_32
    {
        using xtype = uint32_t;
 ...",1,tools\benchcat\main.cpp,pcg_engines,19,pcg_engines,1
618305,NAMESPACE_BLOCK,<empty>,,tools\buffersize\main.cpp,tools\buffersize\main.cpp:<global>,,<global>,1
618689,NAMESPACE_BLOCK,<empty>,,tools\closetest\closetest.cpp,tools\closetest\closetest.cpp:<global>,,<global>,1
620503,NAMESPACE_BLOCK,<empty>,,tools\echokey\main.cpp,tools\echokey\main.cpp:<global>,,<global>,1
621586,NAMESPACE_BLOCK,<empty>,,tools\fontlist\main.cpp,tools\fontlist\main.cpp:<global>,,<global>,1
621742,NAMESPACE_BLOCK,<empty>,,tools\integrity\exeuwp\consoleuwp.cpp,tools\integrity\exeuwp\consoleuwp.cpp:<global>,,<global>,1
621752,NAMESPACE_BLOCK,<empty>,,tools\integrity\exewin32\main.cpp,tools\integrity\exewin32\main.cpp:<global>,,<global>,1
621780,NAMESPACE_BLOCK,<empty>,,tools\integrity\lib\util.cpp,tools\integrity\lib\util.cpp:<global>,,<global>,1
621947,NAMESPACE_BLOCK,<empty>,,tools\integrity\lib\util.hpp,tools\integrity\lib\util.hpp:<global>,,<global>,1
621958,NAMESPACE_BLOCK,<empty>,,tools\lnkd\main.cpp,tools\lnkd\main.cpp:<global>,,<global>,1
622060,NAMESPACE_BLOCK,<empty>,,tools\lnkd\precomp.hpp,tools\lnkd\precomp.hpp:<global>,,<global>,1
622067,NAMESPACE_BLOCK,<empty>,,tools\nihilist\main.cpp,tools\nihilist\main.cpp:<global>,,<global>,1
622090,NAMESPACE_BLOCK,<empty>,,tools\pixels\main.cpp,tools\pixels\main.cpp:<global>,,<global>,1
623265,NAMESPACE_BLOCK,<empty>,,tools\pixels\precomp.hpp,tools\pixels\precomp.hpp:<global>,,<global>,1
623272,NAMESPACE_BLOCK,<empty>,,tools\scratch\main.cpp,tools\scratch\main.cpp:<global>,,<global>,1
623307,NAMESPACE_BLOCK,<empty>,,tools\vtpipeterm\VtConsole.cpp,tools\vtpipeterm\VtConsole.cpp:<global>,,<global>,1
624014,NAMESPACE_BLOCK,<empty>,,tools\vtpipeterm\VtConsole.hpp,tools\vtpipeterm\VtConsole.hpp:<global>,,<global>,1
624216,NAMESPACE_BLOCK,<empty>,,tools\vtpipeterm\main.cpp,tools\vtpipeterm\main.cpp:<global>,,<global>,1
625662,NAMESPACE_BLOCK,<empty>,,tsf\ConsoleTSF.cpp,tsf\ConsoleTSF.cpp:<global>,,<global>,1
626809,NAMESPACE_BLOCK,<empty>,,tsf\ConsoleTSF.hpp,tsf\ConsoleTSF.hpp:<global>,,<global>,1
627197,NAMESPACE_BLOCK,<empty>,,tsf\TfCatUtil.cpp,tsf\TfCatUtil.cpp:<global>,,<global>,1
627238,NAMESPACE_BLOCK,<empty>,,tsf\TfCatUtil.hpp,tsf\TfCatUtil.hpp:<global>,,<global>,1
627280,NAMESPACE_BLOCK,<empty>,,tsf\TfConvArea.cpp,tsf\TfConvArea.cpp:<global>,,<global>,1
627496,NAMESPACE_BLOCK,<empty>,,tsf\TfConvArea.hpp,tsf\TfConvArea.hpp:<global>,,<global>,1
627524,NAMESPACE_BLOCK,<empty>,,tsf\TfCtxtComp.hpp,tsf\TfCtxtComp.hpp:<global>,,<global>,1
627556,NAMESPACE_BLOCK,<empty>,,tsf\TfDispAttr.cpp,tsf\TfDispAttr.cpp:<global>,,<global>,1
627774,NAMESPACE_BLOCK,<empty>,,tsf\TfDispAttr.hpp,tsf\TfDispAttr.hpp:<global>,,<global>,1
627835,NAMESPACE_BLOCK,<empty>,,tsf\TfEditSession.cpp,tsf\TfEditSession.cpp:<global>,,<global>,1
629851,NAMESPACE_BLOCK,<empty>,,tsf\TfEditSession.hpp,tsf\TfEditSession.hpp:<global>,,<global>,1
630096,NAMESPACE_BLOCK,<empty>,,tsf\TfTxtevCb.cpp,tsf\TfTxtevCb.cpp:<global>,,<global>,1
630433,NAMESPACE_BLOCK,<empty>,,tsf\contsf.cpp,tsf\contsf.cpp:<global>,,<global>,1
630527,NAMESPACE_BLOCK,<empty>,,tsf\globals.hpp,tsf\globals.hpp:<global>,,<global>,1
630534,NAMESPACE_BLOCK,<empty>,,tsf\precomp.cpp,tsf\precomp.cpp:<global>,,<global>,1
630573,NAMESPACE_BLOCK,<empty>,,tsf\precomp.hpp,tsf\precomp.hpp:<global>,,<global>,1
630582,NAMESPACE_BLOCK,<empty>,,types\CodepointWidthDetector.cpp,types\CodepointWidthDetector.cpp:<global>,,<global>,1
630586,NAMESPACE_BLOCK,"namespace
{
    // used to store range data in CodepointWidthDetector's internal map
    struct UnicodeRange final
    {
        char32_t lowerBound;
        char32_t upperBound : 31;
        char32_t isAmbiguous : 1;
    };

    static bool operator<(const UnicodeRange& range, const unsigned int searchTerm) noexcept
    {
        return range.upperBound < searchTerm;
    }

    // Generated by Generate-CodepointWidthsFromUCD.ps1 -Pack:True -Full: -NoOverrides:False
    // on 2022-11-15 19:54:23Z from Unicode 15.0.0.
    // 321149 (0x4E67D) codepoints covered.
    // 240 (0xF0) codepoints overridden.
    // Override path: .\src\types\unicode_width_overrides.xml
    static constexpr std::array<UnicodeRange, 297> s_wideAndAmbiguousTable{
        UnicodeRange{ 0xa1, 0xa1, 1 },
        UnicodeRange{ 0xa4, 0xa4, 1 },
        UnicodeRange{ 0xa7, 0xa8, 1 },
        UnicodeRange{ 0xaa, 0xaa, 1 },
        UnicodeRange{ 0xad, 0xae, 1 },
        UnicodeRange{ 0xb0, 0xb4, 1 },
        UnicodeRa...",1,types\CodepointWidthDetector.cpp,anonymous_namespace_0,7,,1
632318,NAMESPACE_BLOCK,<empty>,,types\ColorFix.cpp,types\ColorFix.cpp:<global>,,<global>,1
632644,NAMESPACE_BLOCK,"namespace oklab
{
    struct Lab
    {
        float l;
        float a;
        float b;
    };

    struct RGB
    {
        float r;
        float g;
        float b;
    };

    __forceinline Lab linear_srgb_to_oklab(const RGB& c) noexcept
    {
        const auto l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
        const auto m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
        const auto s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;

        const auto l_ = cbrtf_est(l);
        const auto m_ = cbrtf_est(m);
        const auto s_ = cbrtf_est(s);

        return {
            0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
            1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
            0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_,
        };
    }

    __forceinline RGB oklab_to_linear_srgb(const Lab& c) noexcept
    {
        const auto l_ = c.l + 0.396337...",1,types\ColorFix.cpp,oklab,88,oklab,6
633107,NAMESPACE_BLOCK,<empty>,,types\GlyphWidth.cpp,types\GlyphWidth.cpp:<global>,,<global>,1
633164,NAMESPACE_BLOCK,<empty>,,types\IControlAccessibilityInfo.hpp,types\IControlAccessibilityInfo.hpp:<global>,,<global>,1
633168,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IControlAccessibilityInfo
    {
    public:
        virtual ~IControlAccessibilityInfo() = 0;

        virtual til::size GetFontSize() const noexcept = 0;
        virtual til::rect GetBounds() const noexcept = 0;
        virtual til::rect GetPadding() const noexcept = 0;
        virtual double GetScaleFactor() const noexcept = 0;
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;
        virtual HRESULT GetHostUiaProvider(IRawElementProviderSimple** provider) = 0;

    protected:
        IControlAccessibilityInfo() = default;
        IControlAccessibilityInfo(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo(IControlAccessibilityInfo&&) = default;
        IControlAccessibilityInfo& operator=(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo& operator=(IControlAccessibilityInfo&&) = default;
    };

    inline IControlAccessibilityInfo::~IControlAccess...",1,types\IControlAccessibilityInfo.hpp,Microsoft,20,Microsoft,1
633169,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IControlAccessibilityInfo
    {
    public:
        virtual ~IControlAccessibilityInfo() = 0;

        virtual til::size GetFontSize() const noexcept = 0;
        virtual til::rect GetBounds() const noexcept = 0;
        virtual til::rect GetPadding() const noexcept = 0;
        virtual double GetScaleFactor() const noexcept = 0;
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;
        virtual HRESULT GetHostUiaProvider(IRawElementProviderSimple** provider) = 0;

    protected:
        IControlAccessibilityInfo() = default;
        IControlAccessibilityInfo(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo(IControlAccessibilityInfo&&) = default;
        IControlAccessibilityInfo& operator=(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo& operator=(IControlAccessibilityInfo&&) = default;
    };

    inline IControlAccessibilityInfo::~IControlAccess...",1,types\IControlAccessibilityInfo.hpp,Microsoft.Console,20,Console,1
633170,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IControlAccessibilityInfo
    {
    public:
        virtual ~IControlAccessibilityInfo() = 0;

        virtual til::size GetFontSize() const noexcept = 0;
        virtual til::rect GetBounds() const noexcept = 0;
        virtual til::rect GetPadding() const noexcept = 0;
        virtual double GetScaleFactor() const noexcept = 0;
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;
        virtual HRESULT GetHostUiaProvider(IRawElementProviderSimple** provider) = 0;

    protected:
        IControlAccessibilityInfo() = default;
        IControlAccessibilityInfo(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo(IControlAccessibilityInfo&&) = default;
        IControlAccessibilityInfo& operator=(const IControlAccessibilityInfo&) = default;
        IControlAccessibilityInfo& operator=(IControlAccessibilityInfo&&) = default;
    };

    inline IControlAccessibilityInfo::~IControlAccess...",1,types\IControlAccessibilityInfo.hpp,Microsoft.Console.Types,20,Types,1
633231,NAMESPACE_BLOCK,<empty>,,types\IUiaEventDispatcher.hpp,types\IUiaEventDispatcher.hpp:<global>,,<global>,1
633235,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IUiaEventDispatcher
    {
    public:
        virtual ~IUiaEventDispatcher() = default;
        virtual void SignalSelectionChanged() = 0;
        virtual void SignalTextChanged() = 0;
        virtual void SignalCursorChanged() = 0;
        virtual void NotifyNewOutput(std::wstring_view newOutput) = 0;
    };
}",1,types\IUiaEventDispatcher.hpp,Microsoft,18,Microsoft,1
633236,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IUiaEventDispatcher
    {
    public:
        virtual ~IUiaEventDispatcher() = default;
        virtual void SignalSelectionChanged() = 0;
        virtual void SignalTextChanged() = 0;
        virtual void SignalCursorChanged() = 0;
        virtual void NotifyNewOutput(std::wstring_view newOutput) = 0;
    };
}",1,types\IUiaEventDispatcher.hpp,Microsoft.Console,18,Console,1
633237,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class IUiaEventDispatcher
    {
    public:
        virtual ~IUiaEventDispatcher() = default;
        virtual void SignalSelectionChanged() = 0;
        virtual void SignalTextChanged() = 0;
        virtual void SignalCursorChanged() = 0;
        virtual void NotifyNewOutput(std::wstring_view newOutput) = 0;
    };
}",1,types\IUiaEventDispatcher.hpp,Microsoft.Console.Types,18,Types,1
633261,NAMESPACE_BLOCK,<empty>,,types\IUiaTraceable.hpp,types\IUiaTraceable.hpp:<global>,,<global>,1
633265,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    using IdType = unsigned long long;
    constexpr IdType InvalidId = 0;

    class IUiaTraceable
    {
    public:
        IdType GetId() const noexcept
        {
            return _id;
        }

        // Routine Description:
        // - assigns an ID to the IUiaTraceable object if it doesn't have one
        // Arguments:
        // - id - the id value that we are trying to assign
        // Return Value:
        // - true if the assignment was successful, false otherwise (it already has an id).
        bool AssignId(IdType id) noexcept
        {
            if (_id == InvalidId)
            {
                _id = id;
                return true;
            }
            else
            {
                return false;
            }
        }

    private:
        // used to debug objects passed back and forth
        // between the provider and the client
        IdType _id{};
    };
}",1,types\IUiaTraceable.hpp,Microsoft,17,Microsoft,1
633266,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    using IdType = unsigned long long;
    constexpr IdType InvalidId = 0;

    class IUiaTraceable
    {
    public:
        IdType GetId() const noexcept
        {
            return _id;
        }

        // Routine Description:
        // - assigns an ID to the IUiaTraceable object if it doesn't have one
        // Arguments:
        // - id - the id value that we are trying to assign
        // Return Value:
        // - true if the assignment was successful, false otherwise (it already has an id).
        bool AssignId(IdType id) noexcept
        {
            if (_id == InvalidId)
            {
                _id = id;
                return true;
            }
            else
            {
                return false;
            }
        }

    private:
        // used to debug objects passed back and forth
        // between the provider and the client
        IdType _id{};
    };
}",1,types\IUiaTraceable.hpp,Microsoft.Console,17,Console,1
633267,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    using IdType = unsigned long long;
    constexpr IdType InvalidId = 0;

    class IUiaTraceable
    {
    public:
        IdType GetId() const noexcept
        {
            return _id;
        }

        // Routine Description:
        // - assigns an ID to the IUiaTraceable object if it doesn't have one
        // Arguments:
        // - id - the id value that we are trying to assign
        // Return Value:
        // - true if the assignment was successful, false otherwise (it already has an id).
        bool AssignId(IdType id) noexcept
        {
            if (_id == InvalidId)
            {
                _id = id;
                return true;
            }
            else
            {
                return false;
            }
        }

    private:
        // used to debug objects passed back and forth
        // between the provider and the client
        IdType _id{};
    };
}",1,types\IUiaTraceable.hpp,Microsoft.Console.Types,17,Types,1
633314,NAMESPACE_BLOCK,<empty>,,types\ScreenInfoUiaProviderBase.cpp,types\ScreenInfoUiaProviderBase.cpp:<global>,,<global>,1
633463,NAMESPACE_BLOCK,<empty>,,types\ScreenInfoUiaProviderBase.hpp,types\ScreenInfoUiaProviderBase.hpp:<global>,,<global>,1
633467,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    class ScreenInfoUiaProviderBase :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, ITextProvider>,
        public IUiaTraceable
    {
    public:
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ std::wstring_view wordDelimiters = UiaTextRangeBase::DefaultWordDelimiter) noexcept;

        ScreenInfoUiaProviderBase(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase(ScreenInfoUiaProviderBase&&) = delete;
        ScreenInfoUiaProviderBase& operator=(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase& operator=(ScreenInfoUiaProviderBase&&) = delete;
        ~ScreenInfoUiaProviderBase() = default;

        [[nodiscard]] HRESULT Signal(_In_ EVENTID id);
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

      ...",1,types\ScreenInfoUiaProviderBase.hpp,Microsoft,33,Microsoft,1
633468,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    class ScreenInfoUiaProviderBase :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, ITextProvider>,
        public IUiaTraceable
    {
    public:
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ std::wstring_view wordDelimiters = UiaTextRangeBase::DefaultWordDelimiter) noexcept;

        ScreenInfoUiaProviderBase(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase(ScreenInfoUiaProviderBase&&) = delete;
        ScreenInfoUiaProviderBase& operator=(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase& operator=(ScreenInfoUiaProviderBase&&) = delete;
        ~ScreenInfoUiaProviderBase() = default;

        [[nodiscard]] HRESULT Signal(_In_ EVENTID id);
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

      ...",1,types\ScreenInfoUiaProviderBase.hpp,Microsoft.Console,33,Console,1
633469,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    class ScreenInfoUiaProviderBase :
        public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, IRawElementProviderSimple, IRawElementProviderFragment, ITextProvider>,
        public IUiaTraceable
    {
    public:
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ std::wstring_view wordDelimiters = UiaTextRangeBase::DefaultWordDelimiter) noexcept;

        ScreenInfoUiaProviderBase(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase(ScreenInfoUiaProviderBase&&) = delete;
        ScreenInfoUiaProviderBase& operator=(const ScreenInfoUiaProviderBase&) = delete;
        ScreenInfoUiaProviderBase& operator=(ScreenInfoUiaProviderBase&&) = delete;
        ~ScreenInfoUiaProviderBase() = default;

        [[nodiscard]] HRESULT Signal(_In_ EVENTID id);
        virtual void ChangeViewport(const til::inclusive_rect& NewWindow) = 0;

      ...",1,types\ScreenInfoUiaProviderBase.hpp,Microsoft.Console.Types,33,Types,1
633573,NAMESPACE_BLOCK,<empty>,,types\TermControlUiaProvider.cpp,types\TermControlUiaProvider.cpp:<global>,,<global>,1
633634,NAMESPACE_BLOCK,<empty>,,types\TermControlUiaProvider.hpp,types\TermControlUiaProvider.hpp:<global>,,<global>,1
633638,NAMESPACE_BLOCK,"namespace Microsoft::Terminal
{
    class TermControlUiaProvider : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        TermControlUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* const renderData,
                                       _In_ ::Microsoft::Console::Types::IControlAccessibilityInfo* controlInfo) noexcept;

        // IRawElementProviderSimple methods
        IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) noexcept override;

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) noexcept override;
        IFACEMETHODIMP get_HostRawElementProvider(IRawElementProviderSimple** ppProvider) noexcept override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ Ui...",1,types\TermControlUiaProvider.hpp,Microsoft,26,Microsoft,1
633639,NAMESPACE_BLOCK,"namespace Microsoft::Terminal
{
    class TermControlUiaProvider : public Microsoft::Console::Types::ScreenInfoUiaProviderBase
    {
    public:
        TermControlUiaProvider() = default;
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* const renderData,
                                       _In_ ::Microsoft::Console::Types::IControlAccessibilityInfo* controlInfo) noexcept;

        // IRawElementProviderSimple methods
        IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) noexcept override;

        // IRawElementProviderFragment methods
        IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) noexcept override;
        IFACEMETHODIMP get_HostRawElementProvider(IRawElementProviderSimple** ppProvider) noexcept override;
        IFACEMETHODIMP get_BoundingRectangle(_Out_ Ui...",1,types\TermControlUiaProvider.hpp,Microsoft.Terminal,26,Terminal,1
633750,NAMESPACE_BLOCK,<empty>,,types\TermControlUiaTextRange.cpp,types\TermControlUiaTextRange.cpp:<global>,,<global>,1
633923,NAMESPACE_BLOCK,<empty>,,types\TermControlUiaTextRange.hpp,types\TermControlUiaTextRange.hpp:<global>,,<global>,1
633927,NAMESPACE_BLOCK,"namespace Microsoft::Terminal
{
    class TermControlUiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        TermControlUiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Consol...",1,types\TermControlUiaTextRange.hpp,Microsoft,22,Microsoft,1
633928,NAMESPACE_BLOCK,"namespace Microsoft::Terminal
{
    class TermControlUiaTextRange final : public Microsoft::Console::Types::UiaTextRangeBase
    {
    public:
        TermControlUiaTextRange() = default;

        // degenerate range
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // degenerate range at cursor position
        HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;

        // specific endpoint range
        HRESULT RuntimeClassInitialize(_In_ Consol...",1,types\TermControlUiaTextRange.hpp,Microsoft.Terminal,22,Terminal,1
633963,NAMESPACE_BLOCK,<empty>,,types\ThemeUtils.cpp,types\ThemeUtils.cpp:<global>,,<global>,1
633967,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    // Routine Description:
    // - Attempts to enable/disable the dark mode on the frame of a window.
    // Arguments:
    // - hwnd: handle to the window to change
    // - enabled: whether to enable or not the dark mode on the window's frame
    // Return Value:
    // - S_OK or suitable HRESULT from DWM engines.
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND /* hwnd */, bool /* enabled */) noexcept
    {
        // TODO:GH #3425 implement the new DWM API and change
        //  src/interactivity/win32/windowtheme.cpp to use it.
        return S_OK;
    }
}",1,types\ThemeUtils.cpp,Microsoft,4,Microsoft,1
633968,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    // Routine Description:
    // - Attempts to enable/disable the dark mode on the frame of a window.
    // Arguments:
    // - hwnd: handle to the window to change
    // - enabled: whether to enable or not the dark mode on the window's frame
    // Return Value:
    // - S_OK or suitable HRESULT from DWM engines.
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND /* hwnd */, bool /* enabled */) noexcept
    {
        // TODO:GH #3425 implement the new DWM API and change
        //  src/interactivity/win32/windowtheme.cpp to use it.
        return S_OK;
    }
}",1,types\ThemeUtils.cpp,Microsoft.Console,4,Console,1
633969,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    // Routine Description:
    // - Attempts to enable/disable the dark mode on the frame of a window.
    // Arguments:
    // - hwnd: handle to the window to change
    // - enabled: whether to enable or not the dark mode on the window's frame
    // Return Value:
    // - S_OK or suitable HRESULT from DWM engines.
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND /* hwnd */, bool /* enabled */) noexcept
    {
        // TODO:GH #3425 implement the new DWM API and change
        //  src/interactivity/win32/windowtheme.cpp to use it.
        return S_OK;
    }
}",1,types\ThemeUtils.cpp,Microsoft.Console.ThemeUtils,4,ThemeUtils,1
633985,NAMESPACE_BLOCK,<empty>,,types\UiaTextRangeBase.cpp,types\UiaTextRangeBase.cpp:<global>,,<global>,1
635128,NAMESPACE_BLOCK,<empty>,,types\UiaTextRangeBase.hpp,types\UiaTextRangeBase.hpp:<global>,,<global>,1
635132,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTextRangeBase : public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, ITextRangeProvider>, public IUiaTraceable
    {
    protected:
        // indicates which direction a movement operation
        // is going
        enum class MovementDirection
        {
            Forward,
            Backward
        };

    public:
        // The default word delimiter for UiaTextRanges
        static constexpr std::wstring_view DefaultWordDelimiter{ &UNICODE_SPACE, 1 };

        // degenerate range
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;

        // degenerate range at cursor position
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* p...",1,types\UiaTextRangeBase.hpp,Microsoft,31,Microsoft,1
635133,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTextRangeBase : public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, ITextRangeProvider>, public IUiaTraceable
    {
    protected:
        // indicates which direction a movement operation
        // is going
        enum class MovementDirection
        {
            Forward,
            Backward
        };

    public:
        // The default word delimiter for UiaTextRanges
        static constexpr std::wstring_view DefaultWordDelimiter{ &UNICODE_SPACE, 1 };

        // degenerate range
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;

        // degenerate range at cursor position
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* p...",1,types\UiaTextRangeBase.hpp,Microsoft.Console,31,Console,1
635134,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTextRangeBase : public WRL::RuntimeClass<WRL::RuntimeClassFlags<WRL::ClassicCom | WRL::InhibitFtmBase>, ITextRangeProvider>, public IUiaTraceable
    {
    protected:
        // indicates which direction a movement operation
        // is going
        enum class MovementDirection
        {
            Forward,
            Backward
        };

    public:
        // The default word delimiter for UiaTextRanges
        static constexpr std::wstring_view DefaultWordDelimiter{ &UNICODE_SPACE, 1 };

        // degenerate range
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;

        // degenerate range at cursor position
        virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* p...",1,types\UiaTextRangeBase.hpp,Microsoft.Console.Types,31,Types,1
635458,NAMESPACE_BLOCK,<empty>,,types\UiaTracing.cpp,types\UiaTracing.cpp:<global>,,<global>,1
637142,NAMESPACE_BLOCK,<empty>,,types\UiaTracing.hpp,types\UiaTracing.hpp:<global>,,<global>,1
637147,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTracing final
    {
    public:
        enum class AttributeType
        {
            Standard,
            Mixed,
            Unsupported,
            Error
        };

        class TextRange final
        {
        public:
            static void Constructor(UiaTextRangeBase& result) noexcept;
            static void Clone(const UiaTextRangeBase& base, UiaTextRangeBase& result) noexcept;
            static void Compare(const UiaTextRangeBase& base, const UiaTextRangeBase& other, bool result) noexcept;
            static void CompareEndpoints(const UiaTextRangeBase& base, const TextPatternRangeEndpoint endpoint, const UiaTextRangeBase& other, TextPatternRangeEndpoint otherEndpoint, int result) noexcept;
            static void ExpandToEnclosingUnit(TextUnit unit, const UiaTextRangeBase& result) noexcept;
            static void FindAttribute(const UiaTextRangeBase& base, TEXTATTRIBUTEID attributeId, VARIANT val, BOOL searchBackwa...",1,types\UiaTracing.hpp,Microsoft,27,Microsoft,2
637148,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTracing final
    {
    public:
        enum class AttributeType
        {
            Standard,
            Mixed,
            Unsupported,
            Error
        };

        class TextRange final
        {
        public:
            static void Constructor(UiaTextRangeBase& result) noexcept;
            static void Clone(const UiaTextRangeBase& base, UiaTextRangeBase& result) noexcept;
            static void Compare(const UiaTextRangeBase& base, const UiaTextRangeBase& other, bool result) noexcept;
            static void CompareEndpoints(const UiaTextRangeBase& base, const TextPatternRangeEndpoint endpoint, const UiaTextRangeBase& other, TextPatternRangeEndpoint otherEndpoint, int result) noexcept;
            static void ExpandToEnclosingUnit(TextUnit unit, const UiaTextRangeBase& result) noexcept;
            static void FindAttribute(const UiaTextRangeBase& base, TEXTATTRIBUTEID attributeId, VARIANT val, BOOL searchBackwa...",1,types\UiaTracing.hpp,Microsoft.Console,27,Console,1
637149,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class UiaTracing final
    {
    public:
        enum class AttributeType
        {
            Standard,
            Mixed,
            Unsupported,
            Error
        };

        class TextRange final
        {
        public:
            static void Constructor(UiaTextRangeBase& result) noexcept;
            static void Clone(const UiaTextRangeBase& base, UiaTextRangeBase& result) noexcept;
            static void Compare(const UiaTextRangeBase& base, const UiaTextRangeBase& other, bool result) noexcept;
            static void CompareEndpoints(const UiaTextRangeBase& base, const TextPatternRangeEndpoint endpoint, const UiaTextRangeBase& other, TextPatternRangeEndpoint otherEndpoint, int result) noexcept;
            static void ExpandToEnclosingUnit(TextUnit unit, const UiaTextRangeBase& result) noexcept;
            static void FindAttribute(const UiaTextRangeBase& base, TEXTATTRIBUTEID attributeId, VARIANT val, BOOL searchBackwa...",1,types\UiaTracing.hpp,Microsoft.Console.Types,27,Types,1
637463,NAMESPACE_BLOCK,<empty>,,types\colorTable.cpp,types\colorTable.cpp:<global>,,<global>,1
638989,NAMESPACE_BLOCK,<empty>,,types\convert.cpp,types\convert.cpp:<global>,,<global>,1
639266,NAMESPACE_BLOCK,<empty>,,types\inc\CodepointWidthDetector.hpp,types\inc\CodepointWidthDetector.hpp:<global>,,<global>,1
639306,NAMESPACE_BLOCK,<empty>,,types\inc\ColorFix.hpp,types\inc\ColorFix.hpp:<global>,,<global>,1
639310,NAMESPACE_BLOCK,"namespace ColorFix
{
    COLORREF GetPerceivableColor(COLORREF color, COLORREF reference, float minSquaredDistance) noexcept;
}",1,types\inc\ColorFix.hpp,ColorFix,10,ColorFix,1
639325,NAMESPACE_BLOCK,<empty>,,types\inc\GlyphWidth.hpp,types\inc\GlyphWidth.hpp:<global>,,<global>,1
639351,NAMESPACE_BLOCK,<empty>,,types\inc\IInputEvent.hpp,types\inc\IInputEvent.hpp:<global>,,<global>,1
639559,NAMESPACE_BLOCK,<empty>,,types\inc\ThemeUtils.hpp,types\inc\ThemeUtils.hpp:<global>,,<global>,1
639563,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND hwnd, bool enabled) noexcept;
}",1,types\inc\ThemeUtils.hpp,Microsoft,5,Microsoft,1
639564,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND hwnd, bool enabled) noexcept;
}",1,types\inc\ThemeUtils.hpp,Microsoft.Console,5,Console,1
639565,NAMESPACE_BLOCK,"namespace Microsoft::Console::ThemeUtils
{
    [[nodiscard]] HRESULT SetWindowFrameDarkMode(HWND hwnd, bool enabled) noexcept;
}",1,types\inc\ThemeUtils.hpp,Microsoft.Console.ThemeUtils,5,ThemeUtils,1
639573,NAMESPACE_BLOCK,<empty>,,types\inc\User32Utils.hpp,types\inc\User32Utils.hpp:<global>,,<global>,1
639606,NAMESPACE_BLOCK,<empty>,,types\inc\colorTable.hpp,types\inc\colorTable.hpp:<global>,,<global>,1
639610,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    void InitializeColorTable(const std::span<COLORREF> table);
    std::span<const til::color> CampbellColorTable() noexcept;

    std::optional<til::color> ColorFromXOrgAppColorName(const std::wstring_view wstr) noexcept;
}",1,types\inc\colorTable.hpp,Microsoft,13,Microsoft,1
639611,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    void InitializeColorTable(const std::span<COLORREF> table);
    std::span<const til::color> CampbellColorTable() noexcept;

    std::optional<til::color> ColorFromXOrgAppColorName(const std::wstring_view wstr) noexcept;
}",1,types\inc\colorTable.hpp,Microsoft.Console,13,Console,1
639612,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    void InitializeColorTable(const std::span<COLORREF> table);
    std::span<const til::color> CampbellColorTable() noexcept;

    std::optional<til::color> ColorFromXOrgAppColorName(const std::wstring_view wstr) noexcept;
}",1,types\inc\colorTable.hpp,Microsoft.Console.Utils,13,Utils,1
639632,NAMESPACE_BLOCK,<empty>,,types\inc\convert.hpp,types\inc\convert.hpp:<global>,,<global>,1
639677,NAMESPACE_BLOCK,<empty>,,types\inc\sgrStack.hpp,types\inc\sgrStack.hpp:<global>,,<global>,1
639681,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class SgrStack
    {
    public:
        SgrStack() noexcept;

        // Method Description:
        // - Saves the specified text attributes onto an internal stack.
        // Arguments:
        // - currentAttributes - The attributes to save onto the stack.
        // - options - If none supplied, the full attributes are saved. Else only the
        //   specified parts of currentAttributes are saved.
        // Return Value:
        // - <none>
        void Push(const TextAttribute& currentAttributes,
                  const VTParameters options) noexcept;

        // Method Description:
        // - Restores text attributes by removing from the top of the internal stack,
        //   combining them with the supplied currentAttributes, if appropriate.
        // Arguments:
        // - currentAttributes - The current text attributes. If only a portion of
        //   attributes were saved on the internal stack, then those attri...",1,types\inc\sgrStack.hpp,Microsoft,20,Microsoft,1
639682,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class SgrStack
    {
    public:
        SgrStack() noexcept;

        // Method Description:
        // - Saves the specified text attributes onto an internal stack.
        // Arguments:
        // - currentAttributes - The attributes to save onto the stack.
        // - options - If none supplied, the full attributes are saved. Else only the
        //   specified parts of currentAttributes are saved.
        // Return Value:
        // - <none>
        void Push(const TextAttribute& currentAttributes,
                  const VTParameters options) noexcept;

        // Method Description:
        // - Restores text attributes by removing from the top of the internal stack,
        //   combining them with the supplied currentAttributes, if appropriate.
        // Arguments:
        // - currentAttributes - The current text attributes. If only a portion of
        //   attributes were saved on the internal stack, then those attri...",1,types\inc\sgrStack.hpp,Microsoft.Console,20,Console,1
639683,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    class SgrStack
    {
    public:
        SgrStack() noexcept;

        // Method Description:
        // - Saves the specified text attributes onto an internal stack.
        // Arguments:
        // - currentAttributes - The attributes to save onto the stack.
        // - options - If none supplied, the full attributes are saved. Else only the
        //   specified parts of currentAttributes are saved.
        // Return Value:
        // - <none>
        void Push(const TextAttribute& currentAttributes,
                  const VTParameters options) noexcept;

        // Method Description:
        // - Restores text attributes by removing from the top of the internal stack,
        //   combining them with the supplied currentAttributes, if appropriate.
        // Arguments:
        // - currentAttributes - The current text attributes. If only a portion of
        //   attributes were saved on the internal stack, then those attri...",1,types\inc\sgrStack.hpp,Microsoft.Console.VirtualTerminal,20,VirtualTerminal,1
639723,NAMESPACE_BLOCK,<empty>,,types\inc\utils.hpp,types\inc\utils.hpp:<global>,,<global>,1
639727,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    // Function Description:
    // - Returns -1, 0 or +1 to indicate the sign of the passed-in value.
    template<typename T>
    constexpr int Sign(T val) noexcept
    {
        return (T{ 0 } < val) - (val < T{ 0 });
    }

    bool IsValidHandle(const HANDLE handle) noexcept;

    // Function Description:
    // - Clamps a long in between `min` and `SHRT_MAX`
    // Arguments:
    // - value: the value to clamp
    // - min: the minimum value to clamp to
    // Return Value:
    // - The clamped value as a short.
    constexpr short ClampToShortMax(const long value, const short min) noexcept
    {
        return static_cast<short>(std::clamp(value,
                                             static_cast<long>(min),
                                             static_cast<long>(SHRT_MAX)));
    }

    std::wstring GuidToString(const GUID guid);
    GUID GuidFromString(_Null_terminated_ const wchar_t* str);
    GUID CreateGuid();

    std::s...",1,types\inc\utils.hpp,Microsoft,16,Microsoft,1
639728,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    // Function Description:
    // - Returns -1, 0 or +1 to indicate the sign of the passed-in value.
    template<typename T>
    constexpr int Sign(T val) noexcept
    {
        return (T{ 0 } < val) - (val < T{ 0 });
    }

    bool IsValidHandle(const HANDLE handle) noexcept;

    // Function Description:
    // - Clamps a long in between `min` and `SHRT_MAX`
    // Arguments:
    // - value: the value to clamp
    // - min: the minimum value to clamp to
    // Return Value:
    // - The clamped value as a short.
    constexpr short ClampToShortMax(const long value, const short min) noexcept
    {
        return static_cast<short>(std::clamp(value,
                                             static_cast<long>(min),
                                             static_cast<long>(SHRT_MAX)));
    }

    std::wstring GuidToString(const GUID guid);
    GUID GuidFromString(_Null_terminated_ const wchar_t* str);
    GUID CreateGuid();

    std::s...",1,types\inc\utils.hpp,Microsoft.Console,16,Console,1
639729,NAMESPACE_BLOCK,"namespace Microsoft::Console::Utils
{
    // Function Description:
    // - Returns -1, 0 or +1 to indicate the sign of the passed-in value.
    template<typename T>
    constexpr int Sign(T val) noexcept
    {
        return (T{ 0 } < val) - (val < T{ 0 });
    }

    bool IsValidHandle(const HANDLE handle) noexcept;

    // Function Description:
    // - Clamps a long in between `min` and `SHRT_MAX`
    // Arguments:
    // - value: the value to clamp
    // - min: the minimum value to clamp to
    // Return Value:
    // - The clamped value as a short.
    constexpr short ClampToShortMax(const long value, const short min) noexcept
    {
        return static_cast<short>(std::clamp(value,
                                             static_cast<long>(min),
                                             static_cast<long>(SHRT_MAX)));
    }

    std::wstring GuidToString(const GUID guid);
    GUID GuidFromString(_Null_terminated_ const wchar_t* str);
    GUID CreateGuid();

    std::s...",1,types\inc\utils.hpp,Microsoft.Console.Utils,16,Utils,1
639994,NAMESPACE_BLOCK,<empty>,,types\inc\viewport.hpp,types\inc\viewport.hpp:<global>,,<global>,1
639998,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    using SomeViewports = til::some<Viewport, 4>;

    class Viewport final
    {
    public:
        Viewport() = default;

        static Viewport Empty() noexcept;

        static Viewport FromInclusive(const til::inclusive_rect& sr) noexcept;
        static Viewport FromExclusive(const til::rect& sr) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::CoordType width,
                                       const til::CoordType height) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::size dimensions) noexcept;

        static Viewport FromDimensions(const til::size dimensions) noexcept;

        static Viewport FromCoord(const til::point origin) noexcept;

        til::CoordType Left() const noexcept;
        til::CoordType RightInclusive() const noexcept;
        til::CoordT...",1,types\inc\viewport.hpp,Microsoft,16,Microsoft,1
639999,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    using SomeViewports = til::some<Viewport, 4>;

    class Viewport final
    {
    public:
        Viewport() = default;

        static Viewport Empty() noexcept;

        static Viewport FromInclusive(const til::inclusive_rect& sr) noexcept;
        static Viewport FromExclusive(const til::rect& sr) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::CoordType width,
                                       const til::CoordType height) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::size dimensions) noexcept;

        static Viewport FromDimensions(const til::size dimensions) noexcept;

        static Viewport FromCoord(const til::point origin) noexcept;

        til::CoordType Left() const noexcept;
        til::CoordType RightInclusive() const noexcept;
        til::CoordT...",1,types\inc\viewport.hpp,Microsoft.Console,16,Console,1
640000,NAMESPACE_BLOCK,"namespace Microsoft::Console::Types
{
    class Viewport;

    using SomeViewports = til::some<Viewport, 4>;

    class Viewport final
    {
    public:
        Viewport() = default;

        static Viewport Empty() noexcept;

        static Viewport FromInclusive(const til::inclusive_rect& sr) noexcept;
        static Viewport FromExclusive(const til::rect& sr) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::CoordType width,
                                       const til::CoordType height) noexcept;

        static Viewport FromDimensions(const til::point origin,
                                       const til::size dimensions) noexcept;

        static Viewport FromDimensions(const til::size dimensions) noexcept;

        static Viewport FromCoord(const til::point origin) noexcept;

        til::CoordType Left() const noexcept;
        til::CoordType RightInclusive() const noexcept;
        til::CoordT...",1,types\inc\viewport.hpp,Microsoft.Console.Types,16,Types,1
640288,NAMESPACE_BLOCK,<empty>,,types\precomp.cpp,types\precomp.cpp:<global>,,<global>,1
640321,NAMESPACE_BLOCK,<empty>,,types\precomp.hpp,types\precomp.hpp:<global>,,<global>,1
640330,NAMESPACE_BLOCK,<empty>,,types\sgrStack.cpp,types\sgrStack.cpp:<global>,,<global>,1
640334,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    SgrStack::SgrStack() noexcept :
        _nextPushIndex{ 0 },
        _numSavedAttrs{ 0 }
    {
    }

    void SgrStack::Push(const TextAttribute& currentAttributes,
                        const VTParameters options) noexcept
    {
        AttrBitset validParts;

        if (options.empty())
        {
            // We save all current attributes.
            validParts.set(SgrSaveRestoreStackOptions::All);
        }
        else
        {
            // Each option is encoded as a bit in validParts. All options (that fit) are
            // encoded; options that aren't supported are ignored when read back (popped).
            // So if you try to save only unsupported aspects of the current text
            // attributes, you'll do what is effectively an ""empty"" push (the subsequent
            // pop will not change the current attributes), which is the correct behavior.

            for (size_t i = 0; i < options.size(); i++)
 ...",1,types\sgrStack.cpp,Microsoft,9,Microsoft,1
640335,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    SgrStack::SgrStack() noexcept :
        _nextPushIndex{ 0 },
        _numSavedAttrs{ 0 }
    {
    }

    void SgrStack::Push(const TextAttribute& currentAttributes,
                        const VTParameters options) noexcept
    {
        AttrBitset validParts;

        if (options.empty())
        {
            // We save all current attributes.
            validParts.set(SgrSaveRestoreStackOptions::All);
        }
        else
        {
            // Each option is encoded as a bit in validParts. All options (that fit) are
            // encoded; options that aren't supported are ignored when read back (popped).
            // So if you try to save only unsupported aspects of the current text
            // attributes, you'll do what is effectively an ""empty"" push (the subsequent
            // pop will not change the current attributes), which is the correct behavior.

            for (size_t i = 0; i < options.size(); i++)
 ...",1,types\sgrStack.cpp,Microsoft.Console,9,Console,1
640336,NAMESPACE_BLOCK,"namespace Microsoft::Console::VirtualTerminal
{
    SgrStack::SgrStack() noexcept :
        _nextPushIndex{ 0 },
        _numSavedAttrs{ 0 }
    {
    }

    void SgrStack::Push(const TextAttribute& currentAttributes,
                        const VTParameters options) noexcept
    {
        AttrBitset validParts;

        if (options.empty())
        {
            // We save all current attributes.
            validParts.set(SgrSaveRestoreStackOptions::All);
        }
        else
        {
            // Each option is encoded as a bit in validParts. All options (that fit) are
            // encoded; options that aren't supported are ignored when read back (popped).
            // So if you try to save only unsupported aspects of the current text
            // attributes, you'll do what is effectively an ""empty"" push (the subsequent
            // pop will not change the current attributes), which is the correct behavior.

            for (size_t i = 0; i < options.size(); i++)
 ...",1,types\sgrStack.cpp,Microsoft.Console.VirtualTerminal,9,VirtualTerminal,1
640845,NAMESPACE_BLOCK,<empty>,,types\ut_types\UtilsTests.cpp,types\ut_types\UtilsTests.cpp:<global>,,<global>,1
642344,NAMESPACE_BLOCK,<empty>,,types\ut_types\UuidTests.cpp,types\ut_types\UuidTests.cpp:<global>,,<global>,1
642636,NAMESPACE_BLOCK,<empty>,,types\utils.cpp,types\utils.cpp:<global>,,<global>,1
644651,NAMESPACE_BLOCK,<empty>,,types\viewport.cpp,types\viewport.cpp:<global>,,<global>,1
645895,NAMESPACE_BLOCK,<empty>,,winconpty\device.hpp,winconpty\device.hpp:<global>,,<global>,1
645997,NAMESPACE_BLOCK,<empty>,,winconpty\ft_pty\ConPtyTests.cpp,winconpty\ft_pty\ConPtyTests.cpp:<global>,,<global>,1
647072,NAMESPACE_BLOCK,<empty>,,winconpty\ft_pty\precomp.cpp,winconpty\ft_pty\precomp.cpp:<global>,,<global>,1
647083,NAMESPACE_BLOCK,<empty>,,winconpty\ft_pty\precomp.hpp,winconpty\ft_pty\precomp.hpp:<global>,,<global>,1
647090,NAMESPACE_BLOCK,<empty>,,winconpty\precomp.cpp,winconpty\precomp.cpp:<global>,,<global>,1
647109,NAMESPACE_BLOCK,<empty>,,winconpty\precomp.hpp,winconpty\precomp.hpp:<global>,,<global>,1
647260,NAMESPACE_BLOCK,<empty>,,winconpty\winconpty.cpp,winconpty\winconpty.cpp:<global>,,<global>,1
647338,NAMESPACE_BLOCK,<empty>,,winconpty\winconpty.hpp,winconpty\winconpty.hpp:<global>,,<global>,1
654538,NAMESPACE_BLOCK,<empty>,,<includes>,<includes>:<global>,,<global>,1
