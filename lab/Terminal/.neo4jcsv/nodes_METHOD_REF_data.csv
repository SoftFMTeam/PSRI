13523,METHOD_REF,2,,"[&](bool includeCurrent) {
                    if (col >= startOffset)
                    {
                        const auto unescapedText = ConvertToA(CP_UTF8, std::wstring_view(rows.text.at(row)).substr(startOffset, col - startOffset + includeCurrent));
                        for (const auto c : unescapedText)
                        {
                            switch (c)
                            {
                            case '<':
                                htmlBuilder << ""&lt;"";
                                break;
                            case '>':
                                htmlBuilder << ""&gt;"";
                                break;
                            case '&':
                                htmlBuilder << ""&amp;"";
                                break;
                            default:
                                htmlBuilder << c;
                            }
                        }

                        startOffset = col;
...",52,,2196,TextBuffer.GenHTML.<lambda>0,2,,buffer\out\textBuffer.cpp:<global>
13922,METHOD_REF,2,,"[&](const COLORREF color) -> size_t {
            // Exclude the 0 index for the default color, and start with 1.

            const auto [it, inserted] = colorMap.emplace(color, colorMap.size() + 1);
            if (inserted)
            {
                colorTableBuilder << ""\\red"" << static_cast<int>(GetRValue(color))
                                  << ""\\green"" << static_cast<int>(GetGValue(color))
                                  << ""\\blue"" << static_cast<int>(GetBValue(color))
                                  << "";"";
            }
            return it->second;
        }",41,,2363,TextBuffer.GenRTF.<lambda>1,2,,buffer\out\textBuffer.cpp:<global>
14018,METHOD_REF,2,,"[&](bool includeCurrent) {
                    if (col >= startOffset)
                    {
                        const auto text = std::wstring_view{ rows.text.at(row) }.substr(startOffset, col - startOffset + includeCurrent);
                        _AppendRTFText(contentBuilder, text);

                        startOffset = col;
                    }
                }",52,,2406,TextBuffer.GenRTF.<lambda>2,2,,buffer\out\textBuffer.cpp:<global>
15231,METHOD_REF,2,,"[&start, &end](const ScrollMark& m) {
        return (m.start >= start && m.start <= end) ||
               (m.end >= start && m.end <= end);
    }",20,,2889,TextBuffer.ClearMarksInRange.<lambda>3,2,,buffer\out\textBuffer.cpp:<global>
15346,METHOD_REF,2,,"[height](const auto& m) {
        return (m.start.y < 0) || (m.start.y >= height);
    }",27,,2952,TextBuffer._trimMarksOutsideBuffer.<lambda>4,3,,buffer\out\textBuffer.cpp:<global>
21069,METHOD_REF,2,,"[&](PWSTR value, size_t valueLength, gsl::not_null<size_t*> valueLengthNeededWithNull) noexcept -> HRESULT {
            UINT32 length = gsl::narrow_cast<UINT32>(valueLength);
            const LONG rc = GetCurrentApplicationUserModelId(&length, value);
            switch (rc)
            {
            case ERROR_SUCCESS:
                *valueLengthNeededWithNull = length;
                return S_OK;

            case ERROR_INSUFFICIENT_BUFFER:
                *valueLengthNeededWithNull = length;
                return S_FALSE; // trigger allocation loop

            case APPMODEL_ERROR_NO_APPLICATION:
                return E_FAIL; // we are not running as a store app

            default:
                return E_UNEXPECTED;
            }
        }",25,,48,wWinMain.<lambda>0,3,,cascadia\ElevateShim\elevate-shim.cpp:<global>
28822,METHOD_REF,2,,"[this](const auto json) {
            const auto settings{ winrt::make_self<implementation::CascadiaSettings>(json) };
            const auto copy{ settings->Copy() };
            const auto copyImpl{ winrt::get_self<implementation::CascadiaSettings>(copy) };

            // if we don't have profiles.defaults, it should still be in the tree
            VERIFY_IS_NOT_NULL(settings->ProfileDefaults());
            VERIFY_IS_NOT_NULL(copyImpl->ProfileDefaults());

            VERIFY_ARE_EQUAL(settings->ActiveProfiles().Size(), 1u);
            VERIFY_ARE_EQUAL(settings->ActiveProfiles().Size(), copyImpl->ActiveProfiles().Size());

            // so we should only have one parent, instead of two
            const auto srcProfile{ winrt::get_self<implementation::Profile>(settings->ActiveProfiles().GetAt(0)) };
            const auto copyProfile{ winrt::get_self<implementation::Profile>(copyImpl->ActiveProfiles().GetAt(0)) };
            VERIFY_ARE_EQUAL(srcProfile->Parents().size(), 1u);...",30,,1888,SettingsModelLocalTests.DeserializationTests.TestCloneInheritanceTree.<lambda>0,2,,cascadia\LocalTests_SettingsModel\DeserializationTests.cpp:<global>
31998,METHOD_REF,2,,"[](const KeyChord& expected, const KeyChord& actual) {
            if (expected)
            {
                VERIFY_IS_NOT_NULL(actual);
                VERIFY_ARE_EQUAL(expected.Modifiers(), actual.Modifiers());
                VERIFY_ARE_EQUAL(expected.Vkey(), actual.Vkey());
            }
            else
            {
                VERIFY_IS_NULL(actual);
            }
        }",39,,705,SettingsModelLocalTests.KeyBindingsTests.TestGetKeyBindingForAction.<lambda>0,2,,cascadia\LocalTests_SettingsModel\KeyBindingsTests.cpp:<global>
34850,METHOD_REF,2,,"[](const auto& path) {
            std::ofstream file{ path };
        }",39,,133,TerminalSettingsTests.NormalizeCommandLine.<lambda>0,2,,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp:<global>
34957,METHOD_REF,1,,"[&]() {
            std::error_code ec;
            remove_all(dir1, ec);
            remove_all(dir2, ec);
        }",46,,162,TerminalSettingsTests.NormalizeCommandLine.<lambda>1,2,,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp:<global>
37494,METHOD_REF,2,,"[&](const auto& profile, const auto& schemes, const auto& Theme) {
            auto terminalSettings{ winrt::make_self<implementation::TerminalSettings>() };
            terminalSettings->_ApplyProfileSettings(profile);
            terminalSettings->_ApplyAppearanceSettings(profile.DefaultAppearance(), schemes, Theme);
            return terminalSettings;
        }",39,,782,TerminalSettingsTests.TestLayerProfileOnColorScheme.<lambda>2,2,,cascadia\LocalTests_SettingsModel\TerminalSettingsTests.cpp:<global>
49434,METHOD_REF,2,,"[](auto&& args) {
            auto result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseNew);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());

            result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseExisting);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());

            result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseAnyExisting);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());
        }",27,,2052,TerminalAppLocalTests.CommandlineTest.TestFindTargetWindowHelp.<lambda>0,2,,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp:<global>
49481,METHOD_REF,2,,"[](auto&& args) {
            auto result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseNew);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());

            result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseExisting);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());

            result = appImpl::AppLogic::_doFindTargetWindow({ args }, WindowingMode::UseAnyExisting);
            VERIFY_ARE_EQUAL(WindowingBehaviorUseNew, result.WindowId());
            VERIFY_ARE_EQUAL(L"""", result.WindowName());
        }",27,,2079,TerminalAppLocalTests.CommandlineTest.TestFindTargetWindowVersion.<lambda>1,2,,cascadia\LocalTests_TerminalApp\CommandlineTest.cpp:<global>
49507,METHOD_REF,1,,[&]() -> bool { function(); return true; },70,,88,RunOnUIThread..<lambda>1,2,,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp:<global>
49647,METHOD_REF,2,,"[&invokeResult, &function]() {
                                      invokeResult = WEX::SafeInvoke([&]() -> bool { function(); return true; });
                                  }",35,,87,RunOnUIThread.<lambda>0,3,,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp:<global>
49652,METHOD_REF,1,,"[&completedEvent](auto&&, auto&&) {
        completedEvent.Set();
        return S_OK;
    }",27,,91,RunOnUIThread.<lambda>2,2,,cascadia\LocalTests_TerminalApp\CppWinrtTailored.hpp:<global>
50936,METHOD_REF,1,,"[]() {
            const auto paletteItem{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""AAAAAABBBBBBCCC"") };
            {
                Log::Comment(L""Testing command name segmentation with no filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                auto segments = filteredCommand->_computeHighlightedName().Segments();
                VERIFY_ARE_EQUAL(segments.Size(), 1u);
                VERIFY_ARE_EQUAL(segments.GetAt(0).TextSegment(), L""AAAAAABBBBBBCCC"");
                VERIFY_IS_FALSE(segments.GetAt(0).IsHighlighted());
            }
            {
                Log::Comment(L""Testing command name segmentation with empty filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                filteredCommand->_Filter = L"""";
                auto segments = filteredComma...",37,,33,TerminalAppLocalTests.FilteredCommandTests.VerifyHighlighting.<lambda>0,1,,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp:<global>
50947,METHOD_REF,1,,"[]() {
            const auto paletteItem{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""AAAAAABBBBBBCCC"") };
            {
                Log::Comment(L""Testing weight of command with no filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                filteredCommand->_HighlightedName = filteredCommand->_computeHighlightedName();
                auto weight = filteredCommand->_computeWeight();
                VERIFY_ARE_EQUAL(weight, 0);
            }
            {
                Log::Comment(L""Testing weight of command with empty filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                filteredCommand->_Filter = L"""";
                filteredCommand->_HighlightedName = filteredCommand->_computeHighlightedName();
                auto weight = filteredCommand->_computeW...",37,,114,TerminalAppLocalTests.FilteredCommandTests.VerifyWeight.<lambda>1,1,,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp:<global>
50958,METHOD_REF,1,,"[]() {
            const auto paletteItem{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""AAAAAABBBBBBCCC"") };
            const auto paletteItem2{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""BBBBBCCC"") };
            {
                Log::Comment(L""Testing comparison of commands with no filter"");
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                const auto filteredCommand2 = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem2);

                VERIFY_ARE_EQUAL(filteredCommand->Weight(), filteredCommand2->Weight());
                VERIFY_IS_TRUE(winrt::TerminalApp::implementation::FilteredCommand::Compare(*filteredCommand, *filteredCommand2));
            }
            {
                Log::Comment(L""Testing comparison of commands with empty filter"");
                const auto filteredCommand = win...",37,,170,TerminalAppLocalTests.FilteredCommandTests.VerifyCompare.<lambda>2,1,,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp:<global>
50969,METHOD_REF,1,,"[]() {
            const auto paletteItem{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""a"") };
            const auto paletteItem2{ winrt::make<winrt::TerminalApp::implementation::CommandLinePaletteItem>(L""B"") };
            {
                const auto filteredCommand = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem);
                const auto filteredCommand2 = winrt::make_self<winrt::TerminalApp::implementation::FilteredCommand>(paletteItem2);

                VERIFY_ARE_EQUAL(filteredCommand->Weight(), filteredCommand2->Weight());
                VERIFY_IS_TRUE(winrt::TerminalApp::implementation::FilteredCommand::Compare(*filteredCommand, *filteredCommand2));
            }
        }",37,,218,TerminalAppLocalTests.FilteredCommandTests.VerifyCompareIgnoreCase.<lambda>3,1,,cascadia\LocalTests_TerminalApp\FilteredCommandTests.cpp:<global>
57015,METHOD_REF,1,,"[]() {
                // There's something causing us to crash north of
                // TSFInputControl::NotifyEnter, or LayoutRequested. It's very
                // unclear what that issue is. Since these tests don't run in
                // CI, simply log a message so that the dev running these tests
                // knows it's expected.
                Log::Comment(L""This test often crashes on cleanup, even when it succeeds. If it succeeded, then crashes, that's okay."");
            }",41,,549,TabTests.TryDuplicateBadPane..<lambda>19,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59541,METHOD_REF,1,,"[]() {
            VERIFY_IS_TRUE(true, L""Congrats! We're running on the UI thread!"");

            auto v = winrt::Windows::ApplicationModel::Core::CoreApplication::GetCurrentView();
            VERIFY_IS_NOT_NULL(v, L""Ensure we have a current view"");
            // Verify we can create a some XAML objects
            // Just creating all of them is enough to know that everything is working.
            winrt::Windows::UI::Xaml::Controls::UserControl controlRoot;
            VERIFY_IS_NOT_NULL(controlRoot, L""Try making a UserControl"");
            winrt::Windows::UI::Xaml::Controls::Grid root;
            VERIFY_IS_NOT_NULL(root, L""Try making a Grid"");
            winrt::Windows::UI::Xaml::Controls::SwapChainPanel swapChainPanel;
            VERIFY_IS_NOT_NULL(swapChainPanel, L""Try making a SwapChainPanel"");
            winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar scrollBar;
            VERIFY_IS_NOT_NULL(scrollBar, L""Try making a ScrollBar"");
        }",37,,155,TabTests.TryCreateXamlObjects.<lambda>0,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59567,METHOD_REF,1,,"[&mmcc]() {
            mmcc = winrt::make_self<winrt::TerminalApp::implementation::MinMaxCloseControl>();
            VERIFY_IS_NOT_NULL(mmcc);
        }",37,,179,TabTests.CreateSimpleTerminalXamlType.<lambda>1,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59593,METHOD_REF,1,,"[&tabRowControl]() {
            tabRowControl = winrt::make_self<winrt::TerminalApp::implementation::TabRowControl>();
            VERIFY_IS_NOT_NULL(tabRowControl);
        }",37,,190,TabTests.CreateTerminalMuxXamlType.<lambda>2,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59639,METHOD_REF,1,,"[&page, props, contentManager]() {
            page = winrt::make_self<winrt::TerminalApp::implementation::TerminalPage>(props, contentManager);
            VERIFY_IS_NOT_NULL(page);
        }",37,,207,TabTests.CreateTerminalPage.<lambda>3,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59683,METHOD_REF,1,,"[&projectedPage, &page, initialSettings, props, contentManager]() {
            projectedPage = winrt::TerminalApp::TerminalPage(props, contentManager);
            page.copy_from(winrt::get_self<winrt::TerminalApp::implementation::TerminalPage>(projectedPage));
            page->_settings = initialSettings;
        }",37,,257,TabTests._initializeTerminalPage.<lambda>4,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59704,METHOD_REF,1,,"[&waitForInitEvent](auto&&, auto&&) {
            waitForInitEvent.Set();
        }",27,,272,TabTests._initializeTerminalPage.<lambda>5,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59713,METHOD_REF,1,,"[&page]() {
            VERIFY_IS_NOT_NULL(page);
            VERIFY_IS_NOT_NULL(page->_settings);
            page->Create();
            Log::Comment(L""Create()'d the page successfully"");

            // Build a NewTab action, to make sure we start with one. The real
            // Terminal will always get one from AppCommandlineArgs.
            NewTerminalArgs newTerminalArgs{};
            NewTabArgs args{ newTerminalArgs };
            ActionAndArgs newTabAction{ ShortcutAction::NewTab, args };
            // push the arg onto the front
            page->_startupActions.Append(newTabAction);
            Log::Comment(L""Added a single newTab action"");

            auto app = ::winrt::Windows::UI::Xaml::Application::Current();

            winrt::TerminalApp::TerminalPage pp = *page;
            winrt::Windows::UI::Xaml::Window::Current().Content(pp);
            winrt::Windows::UI::Xaml::Window::Current().Activate();
        }",32,,278,TabTests._initializeTerminalPage.<lambda>6,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59734,METHOD_REF,1,,"[&page]() {
            // In the real app, this isn't a problem, but doesn't happen
            // reliably in the unit tests.
            Log::Comment(L""Ensure we set the first tab as the selected one."");
            auto tab = page->_tabs.GetAt(0);
            auto tabImpl = page->_GetTerminalTabImpl(tab);
            page->_tabView.SelectedItem(tabImpl->TabViewItem());
            page->_UpdatedSelectedTab(tab);
        }",32,,305,TabTests._initializeTerminalPage.<lambda>7,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59776,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
        }",37,,354,TabTests.TryInitializePage.<lambda>8,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59866,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
        }",37,,419,TabTests.TryDuplicateBadTab.<lambda>9,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59877,METHOD_REF,1,,"[&page]() {
            page->_DuplicateFocusedTab();
            VERIFY_ARE_EQUAL(2u, page->_tabs.Size());
        }",32,,425,TabTests.TryDuplicateBadTab.<lambda>10,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59892,METHOD_REF,1,,"[&page, settings1]() {
            page->_settings = settings1;
        }",32,,434,TabTests.TryDuplicateBadTab.<lambda>11,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59903,METHOD_REF,1,,"[&page]() {
            page->_DuplicateFocusedTab();
            VERIFY_ARE_EQUAL(3u, page->_tabs.Size(), L""We should successfully duplicate a tab hosting a deleted profile."");
        }",32,,440,TabTests.TryDuplicateBadTab.<lambda>12,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59993,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
        }",37,,506,TabTests.TryDuplicateBadPane.<lambda>13,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
59999,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(1, tab->GetLeafPaneCount());
        }",32,,511,TabTests.TryDuplicateBadPane.<lambda>14,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60014,METHOD_REF,1,,"[&page]() {
            page->_SplitPane(nullptr, SplitDirection::Automatic, 0.5f, page->_MakePane(nullptr, page->_GetFocusedTab(), nullptr));

            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, tab->GetLeafPaneCount());
        }",32,,519,TabTests.TryDuplicateBadPane.<lambda>15,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60029,METHOD_REF,1,,"[&page, settings1]() {
            page->_settings = settings1;
        }",32,,531,TabTests.TryDuplicateBadPane.<lambda>16,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60044,METHOD_REF,1,,"[&page]() {
            page->_SplitPane(nullptr, SplitDirection::Automatic, 0.5f, page->_MakePane(nullptr, page->_GetFocusedTab(), nullptr));

            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(3,
                             tab->GetLeafPaneCount(),
                             L""We should successfully duplicate a pane hosting a deleted profile."");
        }",32,,537,TabTests.TryDuplicateBadPane.<lambda>17,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60054,METHOD_REF,1,,"[] {
            auto result = RunOnUIThread([]() {
                // There's something causing us to crash north of
                // TSFInputControl::NotifyEnter, or LayoutRequested. It's very
                // unclear what that issue is. Since these tests don't run in
                // CI, simply log a message so that the dev running these tests
                // knows it's expected.
                Log::Comment(L""This test often crashes on cleanup, even when it succeeds. If it succeeded, then crashes, that's okay."");
            });
            VERIFY_SUCCEEDED(result);
        }",40,,548,TabTests.TryDuplicateBadPane.<lambda>18,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60118,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
        }",37,,688,TabTests._commonSetup.<lambda>20,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60147,METHOD_REF,1,,"[&page]() {
            SplitPaneArgs args{ SplitType::Duplicate };
            ActionEventArgs eventArgs{ args };
            page->_HandleSplitPane(nullptr, eventArgs);
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));

            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",37,,705,TabTests.TryZoomPane.<lambda>21,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60158,METHOD_REF,1,,"[&page]() {
            ActionEventArgs eventArgs{};
            page->_HandleTogglePaneZoom(nullptr, eventArgs);
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_TRUE(firstTab->IsZoomed());
        }",32,,717,TabTests.TryZoomPane.<lambda>22,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60169,METHOD_REF,1,,"[&page]() {
            ActionEventArgs eventArgs{};
            page->_HandleTogglePaneZoom(nullptr, eventArgs);
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",32,,727,TabTests.TryZoomPane.<lambda>23,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60188,METHOD_REF,1,,"[&page]() {
            // Set up action
            SplitPaneArgs args{ SplitType::Duplicate };
            ActionEventArgs eventArgs{ args };
            page->_HandleSplitPane(nullptr, eventArgs);
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));

            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",37,,742,TabTests.MoveFocusFromZoomedPane.<lambda>24,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60199,METHOD_REF,1,,"[&page]() {
            // Set up action
            ActionEventArgs eventArgs{};

            page->_HandleTogglePaneZoom(nullptr, eventArgs);

            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_TRUE(firstTab->IsZoomed());
        }",32,,755,TabTests.MoveFocusFromZoomedPane.<lambda>25,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60210,METHOD_REF,1,,"[&page]() {
            // Set up action
            MoveFocusArgs args{ FocusDirection::Left };
            ActionEventArgs eventArgs{ args };

            page->_HandleMoveFocus(nullptr, eventArgs);

            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_TRUE(firstTab->IsZoomed());
        }",32,,768,TabTests.MoveFocusFromZoomedPane.<lambda>26,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60229,METHOD_REF,1,,"[&page]() {
            // Set up action
            SplitPaneArgs args{ SplitType::Duplicate };
            ActionEventArgs eventArgs{ args };
            page->_HandleSplitPane(nullptr, eventArgs);
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));

            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",37,,787,TabTests.CloseZoomedPane.<lambda>27,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60240,METHOD_REF,1,,"[&page]() {
            // Set up action
            ActionEventArgs eventArgs{};

            page->_HandleTogglePaneZoom(nullptr, eventArgs);

            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(2, firstTab->GetLeafPaneCount());
            VERIFY_IS_TRUE(firstTab->IsZoomed());
        }",32,,800,TabTests.CloseZoomedPane.<lambda>28,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60251,METHOD_REF,1,,"[&page]() {
            // Set up action
            ActionEventArgs eventArgs{};

            page->_HandleClosePane(nullptr, eventArgs);

            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",32,,813,TabTests.CloseZoomedPane.<lambda>29,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60264,METHOD_REF,1,,"[&page]() {
            auto firstTab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(1, firstTab->GetLeafPaneCount());
            VERIFY_IS_FALSE(firstTab->IsZoomed());
        }",32,,829,TabTests.CloseZoomedPane.<lambda>30,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60292,METHOD_REF,1,,"[&]() {
            VERIFY_ARE_EQUAL(1u, page->_tabs.Size());
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            firstId = tab->_activePane->Id().value();
            // We start with 1 tab, split vertically to get
            // -------------------
            // |   1    |   2    |
            // |        |        |
            // -------------------
            page->_SplitPane(nullptr, SplitDirection::Right, 0.5f, page->_MakePane(nullptr, page->_GetFocusedTab(), nullptr));
            secondId = tab->_activePane->Id().value();
        }",24,,851,TabTests.SwapPanes.<lambda>31,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60296,METHOD_REF,1,,"[&]() {
            // After this the `2` pane is focused, go back to `1` being focused
            page->_MoveFocus(FocusDirection::Left);
        }",24,,864,TabTests.SwapPanes.<lambda>32,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60300,METHOD_REF,1,,"[&]() {
            // Split again to make the 3rd tab
            // -------------------
            // |   1    |        |
            // |        |        |
            // ---------|   2    |
            // |   3    |        |
            // |        |        |
            // -------------------
            page->_SplitPane(nullptr, SplitDirection::Down, 0.5f, page->_MakePane(nullptr, page->_GetFocusedTab(), nullptr));
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            // Split again to make the 3rd tab
            thirdId = tab->_activePane->Id().value();
        }",24,,869,TabTests.SwapPanes.<lambda>33,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60304,METHOD_REF,1,,"[&]() {
            // After this the `3` pane is focused, go back to `2` being focused
            page->_MoveFocus(FocusDirection::Right);
        }",24,,884,TabTests.SwapPanes.<lambda>34,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60308,METHOD_REF,1,,"[&]() {
            // Split to create the final pane
            // -------------------
            // |   1    |   2    |
            // |        |        |
            // -------------------
            // |   3    |   4    |
            // |        |        |
            // -------------------
            page->_SplitPane(nullptr, SplitDirection::Down, 0.5f, page->_MakePane(nullptr, page->_GetFocusedTab(), nullptr));
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            fourthId = tab->_activePane->Id().value();
        }",24,,889,TabTests.SwapPanes.<lambda>35,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60312,METHOD_REF,1,,"[&]() {
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(4, tab->GetLeafPaneCount());
            // just to be complete, make sure we actually have 4 different ids
            VERIFY_ARE_NOT_EQUAL(firstId, fourthId);
            VERIFY_ARE_NOT_EQUAL(secondId, fourthId);
            VERIFY_ARE_NOT_EQUAL(thirdId, fourthId);
            VERIFY_ARE_NOT_EQUAL(firstId, thirdId);
            VERIFY_ARE_NOT_EQUAL(secondId, thirdId);
            VERIFY_ARE_NOT_EQUAL(firstId, secondId);
        }",24,,904,TabTests.SwapPanes.<lambda>36,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60321,METHOD_REF,1,,"[&]() {
            // Set up action
            SwapPaneArgs args{ FocusDirection::Left };
            ActionEventArgs eventArgs{ args };

            page->_HandleSwapPane(nullptr, eventArgs);
        }",24,,928,TabTests.SwapPanes.<lambda>37,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60325,METHOD_REF,1,,"[&]() {
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(4, tab->GetLeafPaneCount());
            // Our currently focused pane should be `4`
            VERIFY_ARE_EQUAL(fourthId, tab->_activePane->Id().value());

            // Inspect the tree to make sure we swapped
            VERIFY_ARE_EQUAL(fourthId, tab->_rootPane->_firstChild->_secondChild->Id().value());
            VERIFY_ARE_EQUAL(thirdId, tab->_rootPane->_secondChild->_secondChild->Id().value());
        }",24,,938,TabTests.SwapPanes.<lambda>38,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60334,METHOD_REF,1,,"[&]() {
            // Set up action
            SwapPaneArgs args{ FocusDirection::Up };
            ActionEventArgs eventArgs{ args };

            page->_HandleSwapPane(nullptr, eventArgs);
        }",24,,959,TabTests.SwapPanes.<lambda>39,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60338,METHOD_REF,1,,"[&]() {
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(4, tab->GetLeafPaneCount());
            // Our currently focused pane should be `4`
            VERIFY_ARE_EQUAL(fourthId, tab->_activePane->Id().value());

            // Inspect the tree to make sure we swapped
            VERIFY_ARE_EQUAL(fourthId, tab->_rootPane->_firstChild->_firstChild->Id().value());
            VERIFY_ARE_EQUAL(firstId, tab->_rootPane->_firstChild->_secondChild->Id().value());
        }",24,,969,TabTests.SwapPanes.<lambda>40,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60347,METHOD_REF,1,,"[&]() {
            // Set up action
            SwapPaneArgs args{ FocusDirection::Right };
            ActionEventArgs eventArgs{ args };

            page->_HandleSwapPane(nullptr, eventArgs);
        }",24,,990,TabTests.SwapPanes.<lambda>41,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60351,METHOD_REF,1,,"[&]() {
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(4, tab->GetLeafPaneCount());
            // Our currently focused pane should be `4`
            VERIFY_ARE_EQUAL(fourthId, tab->_activePane->Id().value());

            // Inspect the tree to make sure we swapped
            VERIFY_ARE_EQUAL(fourthId, tab->_rootPane->_secondChild->_firstChild->Id().value());
            VERIFY_ARE_EQUAL(secondId, tab->_rootPane->_firstChild->_firstChild->Id().value());
        }",24,,1000,TabTests.SwapPanes.<lambda>42,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60360,METHOD_REF,1,,"[&]() {
            // Set up action
            SwapPaneArgs args{ FocusDirection::Down };
            ActionEventArgs eventArgs{ args };

            page->_HandleSwapPane(nullptr, eventArgs);
        }",24,,1021,TabTests.SwapPanes.<lambda>43,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60364,METHOD_REF,1,,"[&]() {
            auto tab = page->_GetTerminalTabImpl(page->_tabs.GetAt(0));
            VERIFY_ARE_EQUAL(4, tab->GetLeafPaneCount());
            // Our currently focused pane should be `4`
            VERIFY_ARE_EQUAL(fourthId, tab->_activePane->Id().value());

            // Inspect the tree to make sure we swapped
            VERIFY_ARE_EQUAL(fourthId, tab->_rootPane->_secondChild->_secondChild->Id().value());
            VERIFY_ARE_EQUAL(thirdId, tab->_rootPane->_secondChild->_firstChild->Id().value());
        }",24,,1031,TabTests.SwapPanes.<lambda>44,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60378,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 1 };
            page->_OpenNewTab(newTerminalArgs);
        }",24,,1052,TabTests.NextMRUTab.<lambda>45,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60393,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 2 };
            page->_OpenNewTab(newTerminalArgs);
        }",24,,1059,TabTests.NextMRUTab.<lambda>46,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60408,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 3 };
            page->_OpenNewTab(newTerminalArgs);
        }",24,,1066,TabTests.NextMRUTab.<lambda>47,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60418,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(3u, focusedIndex, L""Verify the fourth tab is the focused one"");
        }",24,,1072,TabTests.NextMRUTab.<lambda>48,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60425,METHOD_REF,1,,"[&page]() {
            page->_SelectTab(1);
        }",24,,1078,TabTests.NextMRUTab.<lambda>49,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60427,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(1u, focusedIndex, L""Verify the second tab is the focused one"");
        }",24,,1082,TabTests.NextMRUTab.<lambda>50,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60434,METHOD_REF,1,,"[&page]() {
            page->_settings.GlobalSettings().TabSwitcherMode(TabSwitcherMode::MostRecentlyUsed);
        }",24,,1088,TabTests.NextMRUTab.<lambda>51,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60441,METHOD_REF,1,,"[&page]() {
            page->_SelectNextTab(true, nullptr);
        }",24,,1093,TabTests.NextMRUTab.<lambda>52,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60450,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Hide the command palette, to confirm the selection"");
            // If you don't do this, the palette will just stay open, and the
            // next time we call _HandleNextTab, we'll continue traversing the
            // MRU list, instead of just hoping one entry.
            page->LoadCommandPalette().Visibility(Visibility::Collapsed);
        }",24,,1100,TabTests.NextMRUTab.<lambda>53,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60452,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(3u, focusedIndex, L""Verify the fourth tab is the focused one"");
        }",24,,1108,TabTests.NextMRUTab.<lambda>54,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60459,METHOD_REF,1,,"[&page]() {
            page->_SelectNextTab(true, nullptr);
        }",24,,1114,TabTests.NextMRUTab.<lambda>55,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60468,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Hide the command palette, to confirm the selection"");
            // If you don't do this, the palette will just stay open, and the
            // next time we call _HandleNextTab, we'll continue traversing the
            // MRU list, instead of just hoping one entry.
            page->LoadCommandPalette().Visibility(Visibility::Collapsed);
        }",24,,1121,TabTests.NextMRUTab.<lambda>56,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60470,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(1u, focusedIndex, L""Verify the second tab is the focused one"");
        }",24,,1129,TabTests.NextMRUTab.<lambda>57,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60494,METHOD_REF,1,,"[&page]() {
            page->_SelectNextTab(true, nullptr);
        }",24,,1138,TabTests.NextMRUTab.<lambda>58,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60496,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(2u, focusedIndex, L""Verify the third tab is the focused one"");
        }",24,,1141,TabTests.NextMRUTab.<lambda>59,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60520,METHOD_REF,1,,"[&page]() {
            page->_SelectNextTab(true, nullptr);
        }",24,,1150,TabTests.NextMRUTab.<lambda>60,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60522,METHOD_REF,1,,"[&page]() {
            auto focusedIndex = page->_GetFocusedTabIndex().value_or(-1);
            VERIFY_ARE_EQUAL(3u, focusedIndex, L""Verify the fourth tab is the focused one"");
        }",24,,1153,TabTests.NextMRUTab.<lambda>61,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60536,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 1 };
            page->_OpenNewTab(newTerminalArgs);
            page->_OpenNewTab(newTerminalArgs);
            page->_OpenNewTab(newTerminalArgs);
        }",23,,1167,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>62,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60551,METHOD_REF,1,,"[&page]() {
            page->_GetTerminalTabImpl(page->_tabs.GetAt(0))->Title(L""a"");
        }",24,,1176,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>63,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60553,METHOD_REF,1,,"[&page]() {
            page->_GetTerminalTabImpl(page->_tabs.GetAt(1))->Title(L""b"");
        }",24,,1179,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>64,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60555,METHOD_REF,1,,"[&page]() {
            page->_GetTerminalTabImpl(page->_tabs.GetAt(2))->Title(L""c"");
        }",24,,1182,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>65,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60557,METHOD_REF,1,,"[&page]() {
            page->_GetTerminalTabImpl(page->_tabs.GetAt(3))->Title(L""d"");
        }",24,,1185,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>66,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60559,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Sanity check the titles of our tabs are what we set them to."");

            VERIFY_ARE_EQUAL(L""a"", page->_tabs.GetAt(0).Title());
            VERIFY_ARE_EQUAL(L""b"", page->_tabs.GetAt(1).Title());
            VERIFY_ARE_EQUAL(L""c"", page->_tabs.GetAt(2).Title());
            VERIFY_ARE_EQUAL(L""d"", page->_tabs.GetAt(3).Title());

            VERIFY_ARE_EQUAL(L""d"", page->_mruTabs.GetAt(0).Title());
            VERIFY_ARE_EQUAL(L""c"", page->_mruTabs.GetAt(1).Title());
            VERIFY_ARE_EQUAL(L""b"", page->_mruTabs.GetAt(2).Title());
            VERIFY_ARE_EQUAL(L""a"", page->_mruTabs.GetAt(3).Title());
        }",24,,1189,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>67,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60566,METHOD_REF,1,,"[&page]() {
            page->_settings.GlobalSettings().TabSwitcherMode(TabSwitcherMode::MostRecentlyUsed);
        }",24,,1204,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>68,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60573,METHOD_REF,1,,"[&page]() {
            page->_UpdatedSelectedTab(page->_tabs.GetAt(0));
            page->_UpdatedSelectedTab(page->_tabs.GetAt(1));
            page->_UpdatedSelectedTab(page->_tabs.GetAt(2));
            page->_UpdatedSelectedTab(page->_tabs.GetAt(3));
        }",23,,1209,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>69,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60636,METHOD_REF,1,,"[&page]() {
            page->_SelectNextTab(true, nullptr);
            // In the course of a single tick, the Command Palette will:
            // * open
            // * select the proper tab from the mru's list
            // * raise an event for _filteredActionsView().SelectionChanged to
            //   immediately preview the new tab
            // * raise a _SwitchToTabRequestedHandlers event
            // * then dismiss itself, because we can't fake holing down an
            //   anchor key in the tests
        }",23,,1223,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>70,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60638,METHOD_REF,1,,"[&page]() {
            VERIFY_ARE_EQUAL(L""c"", page->_mruTabs.GetAt(0).Title());
            VERIFY_ARE_EQUAL(L""d"", page->_mruTabs.GetAt(1).Title());
            VERIFY_ARE_EQUAL(L""b"", page->_mruTabs.GetAt(2).Title());
            VERIFY_ARE_EQUAL(L""a"", page->_mruTabs.GetAt(3).Title());
        }",24,,1235,TabTests.VerifyCommandPaletteTabSwitcherOrder.<lambda>71,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60691,METHOD_REF,1,,"[&page, this](auto&&, const winrt::TerminalApp::RenameWindowRequestedArgs args) {
            // In the real terminal, this would bounce up to the monarch and
            // come back down. Instead, immediately call back and set the name.
            //
            // This replicates how TerminalWindow works
            _windowProperties->WindowName(args.ProposedName());
        }",37,,1259,TabTests.TestWindowRenameSuccessful.<lambda>72,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60699,METHOD_REF,1,,"[&page, &windowNameChanged](auto&&, const winrt::WUX::Data::PropertyChangedEventArgs& args) mutable {
            if (args.PropertyName() == L""WindowNameForDisplay"")
            {
                windowNameChanged = true;
            }
        }",44,,1268,TabTests.TestWindowRenameSuccessful.<lambda>73,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60701,METHOD_REF,1,,"[&page]() {
            page->_RequestWindowRename(winrt::hstring{ L""Foo"" });
        }",24,,1275,TabTests.TestWindowRenameSuccessful.<lambda>74,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60703,METHOD_REF,1,,"[&]() {
            VERIFY_ARE_EQUAL(L""Foo"", page->WindowProperties().WindowName());
            VERIFY_IS_TRUE(windowNameChanged,
                           L""The window name should have changed, and we should have raised a notification that WindowNameForDisplay changed"");
        }",24,,1278,TabTests.TestWindowRenameSuccessful.<lambda>75,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60723,METHOD_REF,1,,"[&page](auto&&, auto&&) {
            // In the real terminal, this would bounce up to the monarch and
            // come back down. Instead, immediately call back to tell the terminal it failed.
            page->RenameFailed();
        }",37,,1291,TabTests.TestWindowRenameFailure.<lambda>76,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60731,METHOD_REF,1,,"[&page, &windowNameChanged](auto&&, const winrt::WUX::Data::PropertyChangedEventArgs& args) mutable {
            if (args.PropertyName() == L""WindowNameForDisplay"")
            {
                windowNameChanged = true;
            }
        }",31,,1299,TabTests.TestWindowRenameFailure.<lambda>77,2,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60733,METHOD_REF,1,,"[&page]() {
            page->_RequestWindowRename(winrt::hstring{ L""Foo"" });
        }",24,,1306,TabTests.TestWindowRenameFailure.<lambda>78,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60735,METHOD_REF,1,,"[&]() {
            VERIFY_IS_FALSE(windowNameChanged,
                            L""The window name should not have changed, we should have rejected the change."");
        }",24,,1309,TabTests.TestWindowRenameFailure.<lambda>79,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60751,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            VERIFY_ARE_EQUAL(til::color{ 0xff0c0c0c }, controlSettings.DefaultBackground());
        }",24,,1322,TabTests.TestPreviewCommitScheme.<lambda>80,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60753,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate previewing the SetColorScheme action"");
            SetColorSchemeArgs args{ L""Vintage"" };
            ActionAndArgs actionAndArgs{ ShortcutAction::SetColorScheme, args };
            page->_PreviewAction(actionAndArgs);
        }",24,,1332,TabTests.TestPreviewCommitScheme.<lambda>81,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60755,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed to the preview"");
            VERIFY_ARE_EQUAL(til::color{ 0xff000000 }, controlSettings.DefaultBackground());

            // And we should have stored a function to revert the change.
            VERIFY_ARE_EQUAL(1u, page->_restorePreviewFuncs.size());
        }",24,,1339,TabTests.TestPreviewCommitScheme.<lambda>82,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60757,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate committing the SetColorScheme action"");

            SetColorSchemeArgs args{ L""Vintage"" };
            page->_EndPreview();
            page->_HandleSetColorScheme(nullptr, ActionEventArgs{ args });
        }",24,,1353,TabTests.TestPreviewCommitScheme.<lambda>83,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60759,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed"");
            VERIFY_ARE_EQUAL(til::color{ 0xff000000 }, controlSettings.DefaultBackground());

            // After preview there should be no more restore functions to execute.
            VERIFY_ARE_EQUAL(0u, page->_restorePreviewFuncs.size());
        }",24,,1361,TabTests.TestPreviewCommitScheme.<lambda>84,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60782,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            VERIFY_ARE_EQUAL(til::color{ 0xff0c0c0c }, controlSettings.DefaultBackground());
        }",24,,1390,TabTests.TestPreviewDismissScheme.<lambda>85,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60784,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate previewing the SetColorScheme action"");
            SetColorSchemeArgs args{ L""Vintage"" };
            ActionAndArgs actionAndArgs{ ShortcutAction::SetColorScheme, args };
            page->_PreviewAction(actionAndArgs);
        }",24,,1400,TabTests.TestPreviewDismissScheme.<lambda>86,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60786,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed to the preview"");
            VERIFY_ARE_EQUAL(til::color{ 0xff000000 }, controlSettings.DefaultBackground());
        }",24,,1407,TabTests.TestPreviewDismissScheme.<lambda>87,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60788,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate dismissing the SetColorScheme action"");
            page->_EndPreview();
        }",24,,1418,TabTests.TestPreviewDismissScheme.<lambda>88,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60790,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be the same as it originally was"");
            VERIFY_ARE_EQUAL(til::color{ 0xff0c0c0c }, controlSettings.DefaultBackground());
        }",24,,1423,TabTests.TestPreviewDismissScheme.<lambda>89,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60818,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            VERIFY_ARE_EQUAL(til::color{ 0xff0c0c0c }, controlSettings.DefaultBackground());
        }",24,,1446,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>90,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60820,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate previewing the SetColorScheme action"");
            SetColorSchemeArgs args{ L""Vintage"" };
            page->_PreviewColorScheme(args);
        }",24,,1456,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>91,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60822,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed to the preview"");
            VERIFY_ARE_EQUAL(til::color{ 0xff000000 }, controlSettings.DefaultBackground());
        }",24,,1462,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>92,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60824,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Now, preview another scheme"");
            SetColorSchemeArgs args{ L""One Half Light"" };
            page->_PreviewColorScheme(args);
        }",24,,1473,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>93,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60826,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed to the preview"");
            VERIFY_ARE_EQUAL(til::color{ 0xffFAFAFA }, controlSettings.DefaultBackground());
        }",24,,1479,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>94,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60828,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Emulate committing the SetColorScheme action"");

            SetColorSchemeArgs args{ L""One Half Light"" };
            page->_EndPreview();
            page->_HandleSetColorScheme(nullptr, ActionEventArgs{ args });
        }",24,,1490,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>95,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60830,METHOD_REF,1,,"[&page]() {
            const auto& activeControl{ page->_GetActiveControl() };
            VERIFY_IS_NOT_NULL(activeControl);

            const auto& controlSettings = activeControl.Settings();
            VERIFY_IS_NOT_NULL(controlSettings);

            Log::Comment(L""Color should be changed"");
            VERIFY_ARE_EQUAL(til::color{ 0xffFAFAFA }, controlSettings.DefaultBackground());
        }",24,,1498,TabTests.TestPreviewSchemeWhilePreviewing.<lambda>96,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60858,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 1 };
            page->_OpenNewTab(newTerminalArgs);
        }",24,,1520,TabTests.TestClampSwitchToTab.<lambda>97,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60873,METHOD_REF,1,,"[&page]() {
            NewTerminalArgs newTerminalArgs{ 2 };
            page->_OpenNewTab(newTerminalArgs);
        }",24,,1527,TabTests.TestClampSwitchToTab.<lambda>98,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60883,METHOD_REF,1,,"[&page]() {
            auto focusedTabIndexOpt{ page->_GetFocusedTabIndex() };
            VERIFY_IS_TRUE(focusedTabIndexOpt.has_value());
            VERIFY_ARE_EQUAL(2u, focusedTabIndexOpt.value());
        }",24,,1533,TabTests.TestClampSwitchToTab.<lambda>99,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60885,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Switch to the first tab"");
            page->_SelectTab(0);
        }",24,,1539,TabTests.TestClampSwitchToTab.<lambda>100,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60887,METHOD_REF,1,,"[&page]() {
            auto focusedTabIndexOpt{ page->_GetFocusedTabIndex() };

            VERIFY_IS_TRUE(focusedTabIndexOpt.has_value());
            VERIFY_ARE_EQUAL(0u, focusedTabIndexOpt.value());
        }",24,,1544,TabTests.TestClampSwitchToTab.<lambda>101,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60889,METHOD_REF,1,,"[&page]() {
            Log::Comment(L""Switch to the tab 6, which is greater than number of tabs. This should switch to the third tab"");
            page->_SelectTab(6);
        }",24,,1551,TabTests.TestClampSwitchToTab.<lambda>102,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
60891,METHOD_REF,1,,"[&page]() {
            auto focusedTabIndexOpt{ page->_GetFocusedTabIndex() };
            VERIFY_IS_TRUE(focusedTabIndexOpt.has_value());
            VERIFY_ARE_EQUAL(2u, focusedTabIndexOpt.value());
        }",24,,1556,TabTests.TestClampSwitchToTab.<lambda>103,1,,cascadia\LocalTests_TerminalApp\TabTests.cpp:<global>
61678,METHOD_REF,1,,"[this](auto&&, auto&&) { _ShowNotificationIconRequestedHandlers(*this, nullptr); }",51,,98,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.AddPeasant.<lambda>0,2,,cascadia\Remoting\Monarch.cpp:<global>
61683,METHOD_REF,1,,"[this](auto&&, auto&&) { _HideNotificationIconRequestedHandlers(*this, nullptr); }",51,,99,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.AddPeasant.<lambda>1,2,,cascadia\Remoting\Monarch.cpp:<global>
61777,METHOD_REF,2,,"[&](const auto& id, const auto& p) {
            // We want to tell our peasant to quit last, so that we don't try
            // to perform a bunch of elections on quit.
            if (id != _ourPeasantId)
            {
                p.Quit();
            }
        }",31,,153,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._handleQuitAll.<lambda>2,2,,cascadia\Remoting\Monarch.cpp:<global>
61781,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_handleQuitAll_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not close""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,161,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._handleQuitAll.<lambda>3,2,,cascadia\Remoting\Monarch.cpp:<global>
61970,METHOD_REF,2,,"[&](const auto& id, const auto& p) {
            auto otherName = p.WindowName();
            if (otherName == name)
            {
                result = id;
                return false;
            }
            return true;
        }",31,,312,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._lookupPeasantIdForName.<lambda>4,2,,cascadia\Remoting\Monarch.cpp:<global>
61974,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_lookupPeasantIdForName_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not get the name of""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,322,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._lookupPeasantIdForName.<lambda>5,2,,cascadia\Remoting\Monarch.cpp:<global>
62076,METHOD_REF,3,,"[&](const auto& p) {
            const auto id = p.PeasantID();
            // remove the element if it was found in the list to erase.
            if (peasantIds.count(id) == 1)
            {
                TraceLoggingWrite(g_hRemotingProvider,
                                  ""Monarch_RemovedPeasantFromDesktop"",
                                  TraceLoggingUInt64(id, ""peasantID"", ""The ID of the peasant""),
                                  TraceLoggingGuid(p.DesktopID(), ""desktopGuid"", ""The GUID of the previous desktop the window was on""),
                                  TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                                  TraceLoggingKeyword(TIL_KEYWORD_TRACE));
                return true;
            }
            return false;
        }",83,,403,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._clearOldMruEntries.<lambda>6,4,,cascadia\Remoting\Monarch.cpp:<global>
62142,METHOD_REF,4,,"[](const auto& first, const auto& second) { return first.ActivatedTime() > second.ActivatedTime(); }",50,,452,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._doHandleActivatePeasant.<lambda>7,5,,cascadia\Remoting\Monarch.cpp:<global>
62778,METHOD_REF,2,,"[&](const auto& /*id*/, const auto& p) {
            p.DisplayWindowId();
        }",31,,818,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._identifyWindows.<lambda>8,2,,cascadia\Remoting\Monarch.cpp:<global>
62782,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_identifyWindows_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not identify""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,821,winrt.Microsoft.Terminal.Remoting.implementation.Monarch._identifyWindows.<lambda>9,2,,cascadia\Remoting\Monarch.cpp:<global>
63076,METHOD_REF,2,,"[&](const auto& id, const auto& p) -> void {
            names.push_back({ id, p.WindowName(), p.ActiveTabTitle() });
        }",27,,979,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.GetPeasantInfos.<lambda>10,2,,cascadia\Remoting\Monarch.cpp:<global>
63080,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_identifyWindows_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not identify""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,983,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.GetPeasantInfos.<lambda>11,2,,cascadia\Remoting\Monarch.cpp:<global>
63109,METHOD_REF,2,,"[&](const auto& /*id*/, const auto& p) {
            if (p.WindowName() == QuakeWindowName)
            {
                result = true;
            }
            // continue if we didn't get a positive result
            return !result;
        }",27,,999,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.DoesQuakeWindowExist.<lambda>12,2,,cascadia\Remoting\Monarch.cpp:<global>
63113,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_DoesQuakeWindowExist_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not ask for its name""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,1008,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.DoesQuakeWindowExist.<lambda>13,2,,cascadia\Remoting\Monarch.cpp:<global>
63126,METHOD_REF,2,,"[&](const auto& /*id*/, const auto& p) {
            SummonWindowBehavior args{};
            args.ToggleVisibility(false);
            p.Summon(args);
        }",27,,1022,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.SummonAllWindows.<lambda>14,2,,cascadia\Remoting\Monarch.cpp:<global>
63130,METHOD_REF,2,,"[&](const auto& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_SummonAll_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not summon""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",30,,1028,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.SummonAllWindows.<lambda>15,2,,cascadia\Remoting\Monarch.cpp:<global>
63150,METHOD_REF,2,,"[&](const auto& /*id*/, const auto& p) {
            vec.emplace_back(p.GetWindowLayout());
        }",25,,1048,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.GetAllWindowLayouts.<lambda>16,2,,cascadia\Remoting\Monarch.cpp:<global>
63154,METHOD_REF,2,,"[](auto&& id) {
            TraceLoggingWrite(g_hRemotingProvider,
                              ""Monarch_GetAllWindowLayouts_Failed"",
                              TraceLoggingInt64(id, ""peasantID"", ""The ID of the peasant which we could not get a window layout from""),
                              TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                              TraceLoggingKeyword(TIL_KEYWORD_TRACE));
        }",24,,1051,winrt.Microsoft.Terminal.Remoting.implementation.Monarch.GetAllWindowLayouts.<lambda>17,2,,cascadia\Remoting\Monarch.cpp:<global>
64829,METHOD_REF,0,,"[]() {
                // {5456C4DB-557D-4A22-B043-B1577418E4AF}
                static constexpr GUID processRootHashedGuidBase = { 0x5456c4db, 0x557d, 0x4a22, { 0xb0, 0x43, 0xb1, 0x57, 0x74, 0x18, 0xe4, 0xaf } };

                // Make a temporary monarch CLSID based on the unpackaged install root
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.remove_filename();

                return Utils::CreateV5Uuid(processRootHashedGuidBase, std::as_bytes(std::span{ modulePath.native() }));
            }",49,,37,anonymous_namespace_2.MonarchCLSID.<lambda>0,1,,cascadia\Remoting\WindowManager.cpp:<global>
66600,METHOD_REF,1,,"[=]() {
                        // On dismiss, restore the original scheme.
                        control.ColorScheme(originalScheme);
                    }",55,,112,winrt.TerminalApp.implementation.TerminalPage._PreviewColorScheme..<lambda>2,2,,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>
66648,METHOD_REF,1,,"[=]() {
                    // On dismiss:
                    // Don't adjust relatively, just set outright.
                    control.AdjustOpacity(originalOpacity, false);
                }",51,,134,winrt.TerminalApp.implementation.TerminalPage._PreviewAdjustOpacity..<lambda>4,2,,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>
66713,METHOD_REF,1,,"[this]() {
            _restorePreviewFuncs.clear();
        }",46,,73,winrt.TerminalApp.implementation.TerminalPage._RunRestorePreviews.<lambda>0,2,,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>
66752,METHOD_REF,1,,"[&](const auto& control) {
                // Stash a copy of the current scheme.
                auto originalScheme{ control.ColorScheme() };

                // Apply the new scheme.
                control.ColorScheme(scheme.ToCoreScheme());

                if (backup)
                {
                    // Each control will emplace a revert into the
                    // _restorePreviewFuncs for itself.
                    _restorePreviewFuncs.emplace_back([=]() {
                        // On dismiss, restore the original scheme.
                        control.ColorScheme(originalScheme);
                    });
                }
            }",36,,101,winrt.TerminalApp.implementation.TerminalPage._PreviewColorScheme.<lambda>1,1,,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>
66764,METHOD_REF,1,,"[&](const auto& control) {
            // Stash a copy of the original opacity.
            auto originalOpacity{ control.BackgroundOpacity() };

            // Apply the new opacity
            control.AdjustOpacity(args.Opacity() / 100.0, args.Relative());

            if (backup)
            {
                _restorePreviewFuncs.emplace_back([=]() {
                    // On dismiss:
                    // Don't adjust relatively, just set outright.
                    control.AdjustOpacity(originalOpacity, false);
                });
            }
        }",32,,125,winrt.TerminalApp.implementation.TerminalPage._PreviewAdjustOpacity.<lambda>3,1,,cascadia\TerminalApp\ActionPreviewHandlers.cpp:<global>
67946,METHOD_REF,1,,"[&](auto&& p) {
                    const auto id = p->Id();
                    if (id.has_value() && id != activePaneId && !p->ContainsReadOnly())
                    {
                        unfocusedPaneIds.push_back(id.value());
                    }
                }",54,,205,winrt.TerminalApp.implementation.TerminalPage._HandleCloseOtherPanes.<lambda>0,2,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68340,METHOD_REF,1,,"[&realArgs](auto& control) {
                control.ScrollToMark(realArgs.Direction());
            }",36,,364,winrt.TerminalApp.implementation.TerminalPage._HandleScrollToMark.<lambda>1,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68366,METHOD_REF,1,,"[realArgs](auto& control) {
                Control::ScrollMark mark;
                if (realArgs.Color())
                {
                    mark.Color.Color = realArgs.Color().Value();
                    mark.Color.HasValue = true;
                }
                else
                {
                    mark.Color.HasValue = false;
                }
                control.AddMark(mark);
            }",36,,375,winrt.TerminalApp.implementation.TerminalPage._HandleAddMark.<lambda>2,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68379,METHOD_REF,1,,"[](auto& control) {
            control.ClearMark();
        }",32,,394,winrt.TerminalApp.implementation.TerminalPage._HandleClearMark.<lambda>3,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68392,METHOD_REF,1,,"[](auto& control) {
            control.ClearAllMarks();
        }",32,,402,winrt.TerminalApp.implementation.TerminalPage._HandleClearAllMarks.<lambda>4,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68812,METHOD_REF,1,,"[&](auto& control) {
                control.AdjustFontSize(realArgs.Delta());
            }",53,,546,winrt.TerminalApp.implementation.TerminalPage._HandleAdjustFontSize.<lambda>5,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68854,METHOD_REF,1,,"[](auto& control) {
            control.ResetFontSize();
        }",49,,567,winrt.TerminalApp.implementation.TerminalPage._HandleResetFontSize.<lambda>6,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
68870,METHOD_REF,1,,"[](auto& control) {
            control.ToggleShaderEffects();
        }",49,,576,winrt.TerminalApp.implementation.TerminalPage._HandleToggleShaderEffects.<lambda>7,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
69106,METHOD_REF,1,,"[&](auto& control) {
                    control.ColorScheme(scheme.ToCoreScheme());
                }",57,,654,winrt.TerminalApp.implementation.TerminalPage._HandleSetColorScheme.<lambda>8,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
69936,METHOD_REF,2,,"[weakThis = get_weak()](auto&&, auto&&) {
            if (auto self{ weakThis.get() })
            {
                auto& count{ self->_renamerLayoutCount };

                // Don't just always increment this, we don't want to deal with overflow situations
                if (count < 2)
                {
                    count++;
                }

                if (count >= 2)
                {
                    self->_renamerLayoutUpdatedRevoker.revoke();
                    self->WindowRenamerTextBox().Focus(FocusState::Programmatic);
                }
            }
        }",97,,1025,winrt.TerminalApp.implementation.TerminalPage._HandleOpenWindowRenamer.<lambda>9,3,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
70287,METHOD_REF,1,,"[&](auto& control) {
                    control.ClearBuffer(realArgs.Clear());
                }",57,,1188,winrt.TerminalApp.implementation.TerminalPage._HandleClearBuffer.<lambda>10,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
70358,METHOD_REF,1,,"[&](auto& control) {
                    control.AdjustOpacity(realArgs.Opacity() / 100.0, realArgs.Relative());
                }",57,,1220,winrt.TerminalApp.implementation.TerminalPage._HandleAdjustOpacity.<lambda>11,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
70414,METHOD_REF,1,,"[&](auto& control) {
                    control.SelectCommand(realArgs.Direction() == Settings::Model::SelectOutputDirection::Previous);
                }",57,,1245,winrt.TerminalApp.implementation.TerminalPage._HandleSelectCommand.<lambda>12,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
70446,METHOD_REF,1,,"[&](auto& control) {
                    control.SelectOutput(realArgs.Direction() == Settings::Model::SelectOutputDirection::Previous);
                }",57,,1259,winrt.TerminalApp.implementation.TerminalPage._HandleSelectOutput.<lambda>13,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
70725,METHOD_REF,1,,"[&](auto& control) {
                    control.ColorSelection(realArgs.Foreground(), realArgs.Background(), realArgs.MatchMode());
                }",57,,1371,winrt.TerminalApp.implementation.TerminalPage._HandleColorSelection.<lambda>14,1,,cascadia\TerminalApp\AppActionHandlers.cpp:<global>
71023,METHOD_REF,1,,"[&, this]() {
            // Build the NewTab action from the values we've parsed on the commandline.
            ActionAndArgs newTabAction{};
            newTabAction.Action(ShortcutAction::NewTab);
            // _getNewTerminalArgs MUST be called before parsing any other options,
            // as it might clear those options while finding the commandline
            NewTabArgs args{ _getNewTerminalArgs(subcommand) };
            newTabAction.Args(args);
            _startupActions.push_back(newTabAction);
        }",41,,233,AppCommandlineArgs._buildNewTabParser..<lambda>8,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71204,METHOD_REF,1,,"[&, this]() {
            // Build the SplitPane action from the values we've parsed on the commandline.
            ActionAndArgs splitPaneActionAndArgs{};
            splitPaneActionAndArgs.Action(ShortcutAction::SplitPane);

            // _getNewTerminalArgs MUST be called before parsing any other options,
            // as it might clear those options while finding the commandline
            auto terminalArgs{ _getNewTerminalArgs(subcommand) };
            auto style{ SplitDirection::Automatic };
            // Make sure to use the `Option`s here to check if they were set -
            // _getNewTerminalArgs might reset them while parsing a commandline
            if ((*subcommand._horizontalOption || *subcommand._verticalOption))
            {
                if (_splitHorizontal)
                {
                    style = SplitDirection::Down;
                }
                else if (_splitVertical)
                {
                    style = SplitDirection::Right;
  ...",41,,283,AppCommandlineArgs._buildSplitPaneParser..<lambda>10,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71262,METHOD_REF,1,,"[&, this]() {
            // Build the action from the values we've parsed on the commandline.
            ActionAndArgs movePaneAction{};

            if (_movePaneTabIndex >= 0)
            {
                movePaneAction.Action(ShortcutAction::MovePane);
                MovePaneArgs args{ static_cast<unsigned int>(_movePaneTabIndex), L"""" };
                movePaneAction.Args(args);
                _startupActions.push_back(movePaneAction);
            }
        }",30,,336,AppCommandlineArgs._buildMovePaneParser..<lambda>12,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71405,METHOD_REF,1,,"[&, this]() {
            // Build the action from the values we've parsed on the commandline.
            ActionAndArgs focusTabAction{};

            if (_focusTabIndex >= 0)
            {
                focusTabAction.Action(ShortcutAction::SwitchToTab);
                SwitchToTabArgs args{ static_cast<unsigned int>(_focusTabIndex) };
                focusTabAction.Args(args);
                _startupActions.push_back(focusTabAction);
            }
            else if (_focusNextTab || _focusPrevTab)
            {
                focusTabAction.Action(_focusNextTab ? ShortcutAction::NextTab : ShortcutAction::PrevTab);
                // GH#10070 - make sure to not use the MRU order when switching
                // tabs on the commandline. That wouldn't make any sense!
                focusTabAction.Args(_focusNextTab ?
                                        static_cast<IActionArgs>(NextTabArgs(TabSwitcherMode::Disabled)) :
                                        static_cast<I...",30,,383,AppCommandlineArgs._buildFocusTabParser..<lambda>14,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71485,METHOD_REF,1,,"[&, this]() {
            if (_moveFocusDirection != FocusDirection::None)
            {
                MoveFocusArgs args{ _moveFocusDirection };

                ActionAndArgs actionAndArgs{};
                actionAndArgs.Action(ShortcutAction::MoveFocus);
                actionAndArgs.Args(args);

                _startupActions.push_back(std::move(actionAndArgs));
            }
        }",30,,445,AppCommandlineArgs._buildMoveFocusParser..<lambda>16,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71566,METHOD_REF,1,,"[&, this]() {
            if (_swapPaneDirection != FocusDirection::None)
            {
                SwapPaneArgs args{ _swapPaneDirection };

                ActionAndArgs actionAndArgs{};
                actionAndArgs.Action(ShortcutAction::SwapPane);
                actionAndArgs.Args(args);

                _startupActions.push_back(std::move(actionAndArgs));
            }
        }",30,,484,AppCommandlineArgs._buildSwapPaneParser..<lambda>18,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71637,METHOD_REF,1,,"[&, this]() {
            // Build the action from the values we've parsed on the commandline.
            if (_focusPaneTarget >= 0)
            {
                ActionAndArgs focusPaneAction{};
                focusPaneAction.Action(ShortcutAction::FocusPane);
                FocusPaneArgs args{ static_cast<uint32_t>(_focusPaneTarget) };
                focusPaneAction.Args(args);
                _startupActions.push_back(focusPaneAction);
            }
        }",30,,523,AppCommandlineArgs._buildFocusPaneParser..<lambda>20,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71688,METHOD_REF,1,,[this]() { _currentCommandline = nullptr; },41,,44,AppCommandlineArgs.ParseCommand.<lambda>0,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71865,METHOD_REF,2,,"[this](int64_t /*count*/) {
        // Set our message to display the application name and the current version.
        _exitMessage = fmt::format(""{0}\n{1}"",
                                   til::u16u8(CascadiaSettings::ApplicationDisplayName()),
                                   til::u16u8(CascadiaSettings::ApplicationVersion()));
        // Theoretically, we don't need to exit now, since this isn't really
        // an error case. However, in practice, it feels weird to have `wt
        // -v` open a new tab, and makes enough sense that `wt -v ;
        // split-pane` (or whatever) just displays the version and exits.
        _shouldExitEarly = true;
    }",28,,149,AppCommandlineArgs._buildParser.<lambda>1,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71877,METHOD_REF,2,,"[this](int64_t /*count*/) {
        _launchMode = (_launchMode.has_value() && _launchMode.value() == LaunchMode::FocusMode) ?
                          LaunchMode::MaximizedFocusMode :
                          LaunchMode::MaximizedMode;
    }",30,,167,AppCommandlineArgs._buildParser.<lambda>2,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71881,METHOD_REF,2,,"[this](int64_t /*count*/) {
        _launchMode = LaunchMode::FullscreenMode;
    }",31,,172,AppCommandlineArgs._buildParser.<lambda>3,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71885,METHOD_REF,2,,"[this](int64_t /*count*/) {
        _launchMode = (_launchMode.has_value() && _launchMode.value() == LaunchMode::MaximizedMode) ?
                          LaunchMode::MaximizedFocusMode :
                          LaunchMode::FocusMode;
    }",26,,175,AppCommandlineArgs._buildParser.<lambda>4,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71932,METHOD_REF,2,,"[this](std::string string) {
        _position = LaunchPositionFromString(string);
    }",29,,187,AppCommandlineArgs._buildParser.<lambda>5,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
71950,METHOD_REF,2,,"[this](std::string string) {
        _size = SizeFromString(string);
    }",25,,191,AppCommandlineArgs._buildParser.<lambda>6,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72017,METHOD_REF,2,,"[this](auto& subcommand) {
        _addNewTerminalArgs(subcommand);

        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        // command was parsed.
        subcommand.subcommand->callback([&, this]() {
            // Build the NewTab action from the values we've parsed on the commandline.
            ActionAndArgs newTabAction{};
            newTabAction.Action(ShortcutAction::NewTab);
            // _getNewTerminalArgs MUST be called before parsing any other options,
            // as it might clear those options while finding the commandline
            NewTabArgs args{ _getNewTerminalArgs(subcommand) };
            newTabAction.Args(args);
            _startupActions.push_back(newTabAction);
        });
    }",28,,226,AppCommandlineArgs._buildNewTabParser.<lambda>7,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72051,METHOD_REF,2,,"[this](auto& subcommand) {
        _addNewTerminalArgs(subcommand);
        subcommand._horizontalOption = subcommand.subcommand->add_flag(""-H,--horizontal"",
                                                                       _splitHorizontal,
                                                                       RS_A(L""CmdSplitPaneHorizontalArgDesc""));
        subcommand._verticalOption = subcommand.subcommand->add_flag(""-V,--vertical"",
                                                                     _splitVertical,
                                                                     RS_A(L""CmdSplitPaneVerticalArgDesc""));
        subcommand._verticalOption->excludes(subcommand._horizontalOption);
        auto* sizeOpt = subcommand.subcommand->add_option(""-s,--size"",
                                                          _splitPaneSize,
                                                          RS_A(L""CmdSplitPaneSizeArgDesc""));

        subcommand._duplicateOption = subcom...",28,,261,AppCommandlineArgs._buildSplitPaneParser.<lambda>9,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72081,METHOD_REF,2,,"[this](auto* subcommand) {
        subcommand->add_option(""-t,--tab"",
                               _movePaneTabIndex,
                               RS_A(L""CmdMovePaneTabArgDesc""));

        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        // command was parsed.
        subcommand->callback([&, this]() {
            // Build the action from the values we've parsed on the commandline.
            ActionAndArgs movePaneAction{};

            if (_movePaneTabIndex >= 0)
            {
                movePaneAction.Action(ShortcutAction::MovePane);
                MovePaneArgs args{ static_cast<unsigned int>(_movePaneTabIndex), L"""" };
                movePaneAction.Args(args);
                _startupActions.push_back(movePaneAction);
            }
        });
    }",28,,327,AppCommandlineArgs._buildMovePaneParser.<lambda>11,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72111,METHOD_REF,2,,"[this](auto* subcommand) {
        auto* indexOpt = subcommand->add_option(""-t,--target"",
                                                _focusTabIndex,
                                                RS_A(L""CmdFocusTabTargetArgDesc""));
        auto* nextOpt = subcommand->add_flag(""-n,--next"",
                                             _focusNextTab,
                                             RS_A(L""CmdFocusTabNextArgDesc""));
        auto* prevOpt = subcommand->add_flag(""-p,--previous"",
                                             _focusPrevTab,
                                             RS_A(L""CmdFocusTabPrevArgDesc""));
        nextOpt->excludes(prevOpt);
        indexOpt->excludes(prevOpt);
        indexOpt->excludes(nextOpt);

        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        /...",28,,365,AppCommandlineArgs._buildFocusTabParser.<lambda>13,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72184,METHOD_REF,2,,"[this](auto* subcommand) {
        auto* directionOpt = subcommand->add_option(""direction"",
                                                    _moveFocusDirection,
                                                    RS_A(L""CmdMoveFocusDirectionArgDesc""));

        directionOpt->transform(CLI::CheckedTransformer(focusDirectionMap, CLI::ignore_case));
        directionOpt->required();
        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        // command was parsed.
        subcommand->callback([&, this]() {
            if (_moveFocusDirection != FocusDirection::None)
            {
                MoveFocusArgs args{ _moveFocusDirection };

                ActionAndArgs actionAndArgs{};
                actionAndArgs.Action(ShortcutAction::MoveFocus);
                actionAndArgs.Args(args);

     ...",28,,434,AppCommandlineArgs._buildMoveFocusParser.<lambda>15,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72205,METHOD_REF,2,,"[this](auto* subcommand) {
        auto* directionOpt = subcommand->add_option(""direction"",
                                                    _swapPaneDirection,
                                                    RS_A(L""CmdSwapPaneDirectionArgDesc""));

        directionOpt->transform(CLI::CheckedTransformer(focusDirectionMap, CLI::ignore_case));
        directionOpt->required();
        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        // command was parsed.
        subcommand->callback([&, this]() {
            if (_swapPaneDirection != FocusDirection::None)
            {
                SwapPaneArgs args{ _swapPaneDirection };

                ActionAndArgs actionAndArgs{};
                actionAndArgs.Action(ShortcutAction::SwapPane);
                actionAndArgs.Args(args);

           ...",28,,473,AppCommandlineArgs._buildSwapPaneParser.<lambda>17,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
72233,METHOD_REF,2,,"[this](auto* subcommand) {
        auto* targetOpt = subcommand->add_option(""-t,--target"",
                                                 _focusPaneTarget,
                                                 RS_A(L""CmdFocusPaneTargetArgDesc""));
        targetOpt->required();
        targetOpt->check(CLI::NonNegativeNumber);
        // When ParseCommand is called, if this subcommand was provided, this
        // callback function will be triggered on the same thread. We can be sure
        // that `this` will still be safe - this function just lets us know this
        // command was parsed.
        subcommand->callback([&, this]() {
            // Build the action from the values we've parsed on the commandline.
            if (_focusPaneTarget >= 0)
            {
                ActionAndArgs focusPaneAction{};
                focusPaneAction.Action(ShortcutAction::FocusPane);
                FocusPaneArgs args{ static_cast<uint32_t>(_focusPaneTarget) };
                focusPaneAct...",28,,513,AppCommandlineArgs._buildFocusPaneParser.<lambda>19,2,,cascadia\TerminalApp\AppCommandlineArgs.cpp:<global>
73956,METHOD_REF,3,,"[weakSelf = get_weak()]() {
            if (auto self{ weakSelf.get() })
            {
                self->ReloadSettings();
            }
        }",165,,143,winrt.TerminalApp.implementation.AppLogic.AppLogic.<lambda>0,4,,cascadia\TerminalApp\AppLogic.cpp:<global>
73965,METHOD_REF,2,,"[this]() {
            _reloadSettings->Run();
        }",78,,150,"[this]() {
            _reloadSettings->Run();
        }.<lambda>1",2,,cascadia\TerminalApp\AppLogic.cpp:<global>
74287,METHOD_REF,4,,"[this, settingsBasename = settingsPath.filename()](wil::FolderChangeEvent, PCWSTR fileModified) {
                // DO NOT create a static reference to ApplicationState::SharedInstance here.
                //
                // ApplicationState::SharedInstance already caches its own
                // static ref. If _we_ keep a static ref to the member in
                // AppState, then our reference will keep ApplicationState alive
                // after the `ActionToStringMap` gets cleaned up. Then, when we
                // try to persist the actions in the window state, we won't be
                // able to. We'll try to look up the action and the map just
                // won't exist. We'll explode, even though the Terminal is
                // tearing down anyways. So we'll just die, but still invoke
                // WinDBG's post-mortem debugger, who won't be able to attach to
                // the process that's already exiting.
                //
             ...",13,,308,winrt.TerminalApp.implementation.AppLogic._RegisterSettingsChange.<lambda>2,5,,cascadia\TerminalApp\AppLogic.cpp:<global>
74445,METHOD_REF,2,,"[](const FILETIME& f) {
                ULARGE_INTEGER i;
                i.LowPart = f.dwLowDateTime;
                i.HighPart = f.dwHighDateTime;
                return i.QuadPart;
            }",47,,480,winrt.TerminalApp.implementation.AppLogic.NotifyRootInitialized.<lambda>3,2,,cascadia\TerminalApp\AppLogic.cpp:<global>
74449,METHOD_REF,2,,"[](uint64_t v) {
                return v * 1e-7f;
            }",47,,486,winrt.TerminalApp.implementation.AppLogic.NotifyRootInitialized.<lambda>4,2,,cascadia\TerminalApp\AppLogic.cpp:<global>
76657,METHOD_REF,2,,"[this](auto&&, auto&&) {
            if (Visibility() == Visibility::Visible)
            {
                // Force immediate binding update so we can select an item
                Bindings->Update();

                if (_currentMode == CommandPaletteMode::TabSwitchMode)
                {
                    _searchBox().Visibility(Visibility::Collapsed);
                    _filteredActionsView().SelectedIndex(_switcherStartIdx);
                    _filteredActionsView().ScrollIntoView(_filteredActionsView().SelectedItem());
                    _filteredActionsView().Focus(FocusState::Keyboard);

                    // Do this right after becoming visible so we can quickly catch scenarios where
                    // modifiers aren't held down (e.g. command palette invocation).
                    _anchorKeyUpHandler();
                }
                else
                {
                    _filteredActionsView().SelectedIndex(0);
                    _searchBox().Focus(Foc...",74,,44,winrt.TerminalApp.implementation.CommandPalette.CommandPalette.<lambda>0,2,,cascadia\TerminalApp\CommandPalette.cpp:<global>
76667,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            if (_currentMode == CommandPaletteMode::TabSwitchMode)
            {
                _filteredActionsView().Focus(FocusState::Keyboard);
            }
            _sizeChangedRevoker.revoke();
        }",86,,87,winrt.TerminalApp.implementation.CommandPalette.CommandPalette.<lambda>1,3,,cascadia\TerminalApp\CommandPalette.cpp:<global>
77963,METHOD_REF,3,,"[&](const auto& filteredCommand) {
            return filteredCommand.Item().Name() == previousAction.Item().Name();
        }",98,,594,winrt.TerminalApp.implementation.CommandPalette._moveBackButtonClicked.<lambda>2,4,,cascadia\TerminalApp\CommandPalette.cpp:<global>
80620,METHOD_REF,2,,"[this](auto&& /*s*/, auto&& /*e*/) {
            _StateChangedHandlers(*this, nullptr);
        }",83,,63,winrt.Microsoft.TerminalApp.implementation.DebugTapConnection.DebugTapConnection.<lambda>0,3,,cascadia\TerminalApp\DebugTapConnection.cpp:<global>
81111,METHOD_REF,2,,"[weakThis{ get_weak() }](auto& /*sender*/, auto& e) {
            auto filteredCommand{ weakThis.get() };
            if (filteredCommand && e.PropertyName() == L""Name"")
            {
                filteredCommand->HighlightedName(filteredCommand->_computeHighlightedName());
                filteredCommand->Weight(filteredCommand->_computeWeight());
            }
        }",73,,32,winrt.TerminalApp.implementation.FilteredCommand.FilteredCommand.<lambda>0,3,,cascadia\TerminalApp\FilteredCommand.cpp:<global>
82620,METHOD_REF,3,,"[weakThis = get_weak()](Controls::Button button) {
                // If we provide a button, then open the tooltip on that button.
                // We can ""dismiss"" this throttled func by calling it with null,
                // which will cause us to do nothing at the end of the timeout
                // instead.
                if (button)
                {
                    if (auto tt{ Controls::ToolTipService::GetToolTip(button) })
                    {
                        if (auto tooltip{ tt.try_as<Controls::ToolTip>() })
                        {
                            tooltip.IsOpen(true);
                        }
                    }
                }
            }",13,,49,"dispatcher,
            toolTipInterval,
            [weakThis = get_weak()](Controls.Button button) {
                // If we provide a button, then open the tooltip on that button.
                // We can ""dismiss"" this throttled func by calling it with null,
                // which will cause us to do nothing at the end of the timeout
                // instead.
                if (button)
                {
                    if (auto tt{ Controls.ToolTipService.GetToolTip(button) })
                    {
                        if (auto tooltip{ tt.try_as<Controls.ToolTip>() })
                        {
                            tooltip.IsOpen(true);
                        }
                    }
                }
            }.<lambda>0",3,,cascadia\TerminalApp\MinMaxCloseControl.cpp:<global>
82660,METHOD_REF,0,,"[this]() {
            const auto res = Resources();
            const auto windowedHeightKey = winrt::box_value(L""CaptionButtonHeightWindowed"");
            const auto maximizedHeightKey = winrt::box_value(L""CaptionButtonHeightMaximized"");

            auto windowedHeight = 0.0;
            auto maximizedHeight = 0.0;
            if (res.HasKey(windowedHeightKey))
            {
                const auto valFromResources = res.Lookup(windowedHeightKey);
                windowedHeight = winrt::unbox_value_or<double>(valFromResources, 0.0);
            }
            if (res.HasKey(maximizedHeightKey))
            {
                const auto valFromResources = res.Lookup(maximizedHeightKey);
                maximizedHeight = winrt::unbox_value_or<double>(valFromResources, 0.0);
            }
            return std::tuple<double, double>{ windowedHeight, maximizedHeight };
        }",31,,95,winrt.TerminalApp.implementation.MinMaxCloseControl.SetWindowVisualState.<lambda>1,1,,cascadia\TerminalApp\MinMaxCloseControl.cpp:<global>
84202,METHOD_REF,1,,"[childGrid, control, root = _secondChild->_root](auto&&, auto&&) {
                childGrid.Width(NAN);
                childGrid.HorizontalAlignment(HorizontalAlignment::Stretch);
                if (control)
                {
                    control.Width(NAN);
                    control.HorizontalAlignment(HorizontalAlignment::Stretch);
                }
                root.Background(nullptr);
            }",33,,2239,Pane._SetupEntranceAnimation..<lambda>24,2,,cascadia\TerminalApp\Pane.cpp:<global>
84239,METHOD_REF,1,,"[childGrid, control, root = _secondChild->_root](auto&&, auto&&) {
                childGrid.Height(NAN);
                childGrid.VerticalAlignment(VerticalAlignment::Stretch);
                if (control)
                {
                    control.Height(NAN);
                    control.VerticalAlignment(VerticalAlignment::Stretch);
                }
                root.Background(nullptr);
            }",33,,2264,Pane._SetupEntranceAnimation..<lambda>25,2,,cascadia\TerminalApp\Pane.cpp:<global>
84557,METHOD_REF,1,,"[this](auto&, auto& e) {
        _FocusFirstChild();
        e.Handled(true);
    }",25,,54,Pane.Pane.<lambda>0,2,,cascadia\TerminalApp\Pane.cpp:<global>
84562,METHOD_REF,1,,"[this](auto&, auto& e) {
        _FocusFirstChild();
        e.Handled(true);
    }",26,,58,Pane.Pane.<lambda>1,2,,cascadia\TerminalApp\Pane.cpp:<global>
84618,METHOD_REF,1,,"[this](auto&, auto& e) {
        _FocusFirstChild();
        e.Handled(true);
    }",25,,95,Pane.Pane.<lambda>2,2,,cascadia\TerminalApp\Pane.cpp:<global>
84623,METHOD_REF,1,,"[this](auto&, auto& e) {
        _FocusFirstChild();
        e.Handled(true);
    }",26,,99,Pane.Pane.<lambda>3,2,,cascadia\TerminalApp\Pane.cpp:<global>
84887,METHOD_REF,2,,"[&](auto newPane) {
        ActionAndArgs actionAndArgs;
        actionAndArgs.Action(ShortcutAction::SplitPane);
        const auto terminalArgs{ newPane->GetTerminalArgsForPane(asContent) };
        // When creating a pane the split size is the size of the new pane
        // and not position.
        const auto splitDirection = _splitState == SplitState::Horizontal ? SplitDirection::Down : SplitDirection::Right;
        const auto splitSize = (asContent && _IsLeaf() ? .5 : 1. - _desiredSplitPosition);
        SplitPaneArgs args{ SplitType::Manual, splitDirection, splitSize, terminalArgs };
        actionAndArgs.Args(args);

        return actionAndArgs;
    }",27,,223,<lambda>4,2,,cascadia\TerminalApp\Pane.cpp:<global>
84892,METHOD_REF,2,,"[](auto direction) {
        MoveFocusArgs args{ direction };

        ActionAndArgs actionAndArgs{};
        actionAndArgs.Action(ShortcutAction::MoveFocus);
        actionAndArgs.Args(args);

        return actionAndArgs;
    }",27,,247,<lambda>5,2,,cascadia\TerminalApp\Pane.cpp:<global>
85257,METHOD_REF,1,,[](const auto& p) { return p->_IsLeaf(); },36,,501,Pane.NavigateDirection.<lambda>6,1,,cascadia\TerminalApp\Pane.cpp:<global>
85382,METHOD_REF,1,,"[&](auto pane) {
        // If we are a parent pane we don't want to move to one of our children
        if (foundTarget && targetPane->_HasChild(pane))
        {
            return false;
        }
        // In case the target pane is the last pane in the tree, keep a reference
        // to the first leaf so we can wrap around.
        if (firstLeaf == nullptr && pane->_IsLeaf())
        {
            firstLeaf = pane;
        }

        // If we've found the target pane already, get the next leaf pane.
        if (foundTarget && pane->_IsLeaf())
        {
            nextPane = pane;
            return true;
        }

        // Test if we're the target pane so we know to return the next pane.
        if (pane == targetPane)
        {
            foundTarget = true;
        }

        return false;
    }",31,,558,Pane.NextPane.<lambda>7,1,,cascadia\TerminalApp\Pane.cpp:<global>
85411,METHOD_REF,1,,"[&](auto pane) {
        if (pane == targetPane)
        {
            foundTarget = true;
            // If we were not the first leaf, then return the previous leaf.
            // Otherwise keep walking the tree to get the last pane.
            if (lastLeaf != nullptr)
            {
                return true;
            }
        }

        if (pane->_IsLeaf())
        {
            lastLeaf = pane;
        }

        return false;
    }",14,,620,Pane.PreviousPane.<lambda>8,1,,cascadia\TerminalApp\Pane.cpp:<global>
85425,METHOD_REF,1,,"[&](const auto& p) {
        return p->_firstChild == pane || p->_secondChild == pane;
    }",22,,658,Pane._FindParentOfPane.<lambda>9,1,,cascadia\TerminalApp\Pane.cpp:<global>
85490,METHOD_REF,2,,"[](auto& parent, auto oldChild, auto newChild) {
            // Revoke the old handlers
            if (parent->_firstChild == oldChild)
            {
                parent->_firstChild->Closed(parent->_firstClosedToken);
                parent->_firstChild = newChild;
            }
            else if (parent->_secondChild == oldChild)
            {
                parent->_secondChild->Closed(parent->_secondClosedToken);
                parent->_secondChild = newChild;
            }
            // Clear now to ensure that we can add the child's grid to us later
            parent->_root.Children().Clear();
            parent->_borderFirst.Child(nullptr);
            parent->_borderSecond.Child(nullptr);
        }",29,,705,Pane.SwapPanes.<lambda>10,2,,cascadia\TerminalApp\Pane.cpp:<global>
85494,METHOD_REF,2,,"[](auto& parent) {
            // just always revoke the old helpers since we are making new ones.
            parent->_firstChild->Closed(parent->_firstClosedToken);
            parent->_secondChild->Closed(parent->_secondClosedToken);
            parent->_SetupChildCloseHandlers();
            parent->_root.Children().Clear();
            parent->_borderFirst.Child(nullptr);
            parent->_borderSecond.Child(nullptr);
            parent->_borderFirst.Child(parent->_firstChild->GetRootElement());
            parent->_borderSecond.Child(parent->_secondChild->GetRootElement());

            parent->_root.Children().Append(parent->_borderFirst);
            parent->_root.Children().Append(parent->_borderSecond);

            // reset split definitions to clear any set row/column
            parent->_root.ColumnDefinitions().Clear();
            parent->_root.RowDefinitions().Clear();
            parent->_CreateRowColDefinitions();
        }",29,,725,Pane.SwapPanes.<lambda>11,2,,cascadia\TerminalApp\Pane.cpp:<global>
85624,METHOD_REF,2,,"[](float left, float right) {
        return abs(left - right) < 1e-4F;
    }",23,,816,Pane._IsAdjacent.<lambda>12,2,,cascadia\TerminalApp\Pane.cpp:<global>
85628,METHOD_REF,2,,"[](PanePoint offset) {
        return offset.x + offset.scaleX;
    }",20,,820,Pane._IsAdjacent.<lambda>13,2,,cascadia\TerminalApp\Pane.cpp:<global>
85632,METHOD_REF,2,,"[](PanePoint offset) {
        return offset.y + offset.scaleY;
    }",20,,824,Pane._IsAdjacent.<lambda>14,2,,cascadia\TerminalApp\Pane.cpp:<global>
86535,METHOD_REF,1,,[](const auto& p) { return p->_lastActive; },22,,1295,Pane.GetActivePane.<lambda>15,1,,cascadia\TerminalApp\Pane.cpp:<global>
86833,METHOD_REF,1,,"[](auto pane) {
            pane->_DetachedHandlers(pane);
        }",28,,1584,Pane.DetachPane.<lambda>16,2,,cascadia\TerminalApp\Pane.cpp:<global>
86963,METHOD_REF,1,,"[](auto p) {
                if (p->_IsLeaf())
                {
                    p->_removeControlEvents();
                }
            }",35,,1664,Pane._CloseChild.<lambda>17,2,,cascadia\TerminalApp\Pane.cpp:<global>
87162,METHOD_REF,1,,"[](auto p) {
                if (p->_IsLeaf())
                {
                    p->_removeControlEvents();
                }
            }",35,,1751,Pane._CloseChild.<lambda>18,2,,cascadia\TerminalApp\Pane.cpp:<global>
87366,METHOD_REF,1,,"[](auto p) {
                if (p->_IsLeaf())
                {
                    return true;
                }
                p->_parentChildPath = p->_firstChild;
                return false;
            }",35,,1812,Pane._CloseChild.<lambda>19,2,,cascadia\TerminalApp\Pane.cpp:<global>
87842,METHOD_REF,1,,"[weakThis, closeFirst](auto&&, auto&&) {
        if (auto pane{ weakThis.lock() })
        {
            // We don't need to manually undo any of the above trickiness.
            // We're going to re-parent the child's content into us anyways
            pane->_CloseChild(closeFirst, false);
        }
    }",25,,1948,Pane._CloseChildRoutine.<lambda>20,2,,cascadia\TerminalApp\Pane.cpp:<global>
87853,METHOD_REF,1,,"[this](auto&& /*s*/, auto&& /*e*/) {
        _CloseChildRoutine(true);
    }",45,,1966,Pane._SetupChildCloseHandlers.<lambda>21,2,,cascadia\TerminalApp\Pane.cpp:<global>
87860,METHOD_REF,1,,"[this](auto&& /*s*/, auto&& /*e*/) {
        _CloseChildRoutine(false);
    }",47,,1970,Pane._SetupChildCloseHandlers.<lambda>22,2,,cascadia\TerminalApp\Pane.cpp:<global>
88373,METHOD_REF,2,,"[&](const auto& size, const bool isFirstChild) {
        auto child = isFirstChild ? _firstChild : _secondChild;
        auto childGrid = child->_root;
        // If we are splitting a parent pane this may be null
        auto control = child->_control;
        // Build up our animation:
        // * it'll take as long as our duration (200ms)
        // * it'll change the value of our property from 0 to secondSize
        // * it'll animate that value using a quadratic function (like f(t) = t^2)
        // * IMPORTANT! We'll manually tell the animation that ""yes we know what
        //   we're doing, we want an animation here.""
        Media::Animation::DoubleAnimation animation{};
        animation.Duration(AnimationDuration);
        if (isFirstChild)
        {
            // If we're animating the first pane, the size should decrease, from
            // the full size down to the given size.
            animation.From(totalSize);
            animation.To(size);
        }
        ...",27,,2172,Pane._SetupEntranceAnimation.<lambda>23,2,,cascadia\TerminalApp\Pane.cpp:<global>
89212,METHOD_REF,1,,"[=](auto p) {
        p->_parentChildPath.reset();
        if (p->_id == id)
        {
            // Make sure to use _FocusFirstChild here - that'll properly update the
            // focus if we're in startup.
            p->_FocusFirstChild();
            return true;
        }
        return false;
    }",21,,2674,Pane.FocusPane.<lambda>26,1,,cascadia\TerminalApp\Pane.cpp:<global>
89219,METHOD_REF,1,,"[&](auto p) {
        if (p == pane)
        {
            p->_Focus();
            return true;
        }
        // clear the parent child path if we are not the pane being focused.
        p->_parentChildPath.reset();
        return false;
    }",21,,2697,Pane.FocusPane.<lambda>27,1,,cascadia\TerminalApp\Pane.cpp:<global>
89233,METHOD_REF,1,,"[&](const auto& p) {
        return p->_firstChild == child || p->_secondChild == child;
    }",21,,2722,Pane._HasChild.<lambda>28,1,,cascadia\TerminalApp\Pane.cpp:<global>
89240,METHOD_REF,1,,[=](const auto& p) { return p->_IsLeaf() && p->_id == id; },22,,2735,Pane.FindPane.<lambda>29,1,,cascadia\TerminalApp\Pane.cpp:<global>
90175,METHOD_REF,1,,"[&](const auto& pane) {
        if (pane->_IsLeaf() && pane->_control != sourceControl && !pane->_control.ReadOnly())
        {
            pane->_control.RawWriteKeyEvent(vkey, scanCode, modifiers, keyDown);
        }
    }",14,,3207,Pane.BroadcastKey.<lambda>30,1,,cascadia\TerminalApp\Pane.cpp:<global>
90181,METHOD_REF,1,,"[&](const auto& pane) {
        if (pane->_IsLeaf() && pane->_control != sourceControl && !pane->_control.ReadOnly())
        {
            pane->_control.RawWriteChar(character, scanCode, modifiers);
        }
    }",14,,3220,Pane.BroadcastChar.<lambda>31,1,,cascadia\TerminalApp\Pane.cpp:<global>
90187,METHOD_REF,1,,"[&](const auto& pane) {
        if (pane->_IsLeaf() && pane->_control != sourceControl && !pane->_control.ReadOnly())
        {
            pane->_control.RawWriteString(text);
        }
    }",14,,3231,Pane.BroadcastString.<lambda>32,1,,cascadia\TerminalApp\Pane.cpp:<global>
90633,METHOD_REF,1,,"[f](const auto& pane) -> std::shared_ptr<Pane> {
            if (f(pane))
            {
                return pane;
            }
            return nullptr;
        }",25,,202,Pane._FindPane.<lambda>0,1,,Pane
92874,METHOD_REF,2,,"[this](auto&&, auto&&) {
            if (Visibility() == Visibility::Visible)
            {
                // Force immediate binding update so we can select an item
                Bindings->Update();
                UpdateLayout(); // THIS ONE IN PARTICULAR SEEMS LOAD BEARING.
                // Without the UpdateLayout call, our ListView won't have a
                // chance to instantiate ListViewItem's. If we don't have those,
                // then our call to `SelectedItem()` below is going to return
                // null. If it does that, then we won't be able to focus
                // ourselves when we're opened.

                // Select the correct element in the list, depending on which
                // direction we were opened in.
                //
                // Make sure to use _scrollToIndex, to move the scrollbar too!
                if (_direction == TerminalApp::SuggestionsDirection::TopDown)
                {
                    _scrollToIndex(0);
...",74,,40,winrt.TerminalApp.implementation.SuggestionsControl.SuggestionsControl.<lambda>0,2,,cascadia\TerminalApp\SuggestionsControl.cpp:<global>
92884,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            // When we're in BottomUp mode, we need to adjust our own position
            // so that our bottom is aligned with our origin. This will ensure
            // that as the menu changes in size (as we filter results), the menu
            // stays ""attached"" to the cursor.
            if (Visibility() == Visibility::Visible && _direction == TerminalApp::SuggestionsDirection::BottomUp)
            {
                auto m = this->Margin();
                m.Top = (_anchor.Y - ActualHeight());
                this->Margin(m);
            }
        }",86,,99,winrt.TerminalApp.implementation.SuggestionsControl.SuggestionsControl.<lambda>1,3,,cascadia\TerminalApp\SuggestionsControl.cpp:<global>
93895,METHOD_REF,3,,"[&](const auto& filteredCommand) {
            return filteredCommand.Item().Name() == previousAction.Item().Name();
        }",98,,552,winrt.TerminalApp.implementation.SuggestionsControl._moveBackButtonClicked.<lambda>2,4,,cascadia\TerminalApp\SuggestionsControl.cpp:<global>
95617,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        }",34,,53,winrt.TerminalApp.implementation.TabBase._CreateContextMenu.<lambda>0,2,,cascadia\TerminalApp\TabBase.cpp:<global>
95638,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_CloseTabsAfter();
            }
        }",39,,75,winrt.TerminalApp.implementation.TabBase._AppendCloseMenuItems.<lambda>1,2,,cascadia\TerminalApp\TabBase.cpp:<global>
95673,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_CloseOtherTabs();
            }
        }",39,,88,winrt.TerminalApp.implementation.TabBase._AppendCloseMenuItems.<lambda>2,2,,cascadia\TerminalApp\TabBase.cpp:<global>
95722,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_CloseRequestedHandlers(nullptr, nullptr);
            }
        }",32,,106,winrt.TerminalApp.implementation.TabBase._AppendCloseMenuItems.<lambda>3,2,,cascadia\TerminalApp\TabBase.cpp:<global>
96101,METHOD_REF,1,,"[weakThis{ get_weak() }](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        }",30,,260,winrt.TerminalApp.implementation.TabBase._MakeTabViewItem.<lambda>4,2,,cascadia\TerminalApp\TabBase.cpp:<global>
97353,METHOD_REF,1,,"[&](auto&&, auto&& e) {
            _receivedKeyDown = true;

            // GH#9632 - mark navigation buttons as handled.
            // This should prevent the tab view to use this key for navigation between tabs
            if (e.OriginalKey() == Windows::System::VirtualKey::Down ||
                e.OriginalKey() == Windows::System::VirtualKey::Up ||
                e.OriginalKey() == Windows::System::VirtualKey::Left ||
                e.OriginalKey() == Windows::System::VirtualKey::Right)
            {
                e.Handled(true);
            }
        }",40,,21,winrt.TerminalApp.implementation.TabHeaderControl.TabHeaderControl.<lambda>0,2,,cascadia\TerminalApp\TabHeaderControl.cpp:<global>
97358,METHOD_REF,1,,"[&](auto&&, const Windows::UI::Xaml::Input::KeyRoutedEventArgs& e) {
            if (_receivedKeyDown)
            {
                if (e.OriginalKey() == Windows::System::VirtualKey::Enter)
                {
                    // User is done making changes, close the rename box
                    _CloseRenameBox();
                }
                else if (e.OriginalKey() == Windows::System::VirtualKey::Escape)
                {
                    // User wants to discard the changes they made,
                    // set _renameCancelled to true and close the rename box
                    _renameCancelled = true;
                    _CloseRenameBox();
                }
            }
        }",38,,39,winrt.TerminalApp.implementation.TabHeaderControl.TabHeaderControl.<lambda>1,2,,cascadia\TerminalApp\TabHeaderControl.cpp:<global>
97965,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }]() {
            auto page{ weakThis.get() };
            auto tab{ weakTab.get() };

            if (page && tab)
            {
                // Possibly update the icon of the tab.
                page->_UpdateTabIcon(*tab);

                page->_updateThemeColors();

                // Update the taskbar progress as well. We'll raise our own
                // SetTaskbarProgress event here, to get tell the hosting
                // application to re-query this value from us.
                page->_SetTaskbarProgressHandlers(*page, nullptr);

                auto profile = tab->GetFocusedProfile();
                page->_UpdateBackground(profile);
            }
        }",39,,137,winrt.TerminalApp.implementation.TerminalPage._InitializeTab.<lambda>0,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
97970,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }]() {
            auto page{ weakThis.get() };
            auto tab{ weakTab.get() };

            if (page && tab)
            {
                page->_RaiseVisualBellHandlers(nullptr, nullptr);
            }
        }",40,,161,winrt.TerminalApp.implementation.TerminalPage._InitializeTab.<lambda>1,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
98061,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }](auto&& /*s*/, auto&& /*e*/) {
            auto page{ weakThis.get() };
            auto tab{ weakTab.get() };

            if (page && tab)
            {
                page->_HandleCloseTabRequested(*tab);
            }
        }",36,,188,winrt.TerminalApp.implementation.TerminalPage._InitializeTab.<lambda>2,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
98066,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }](auto&& /*s*/, auto&& /*e*/) {
            const auto page = weakThis.get();
            const auto tab = weakTab.get();

            if (page && tab)
            {
                page->_RemoveTab(*tab);
            }
        }",28,,199,winrt.TerminalApp.implementation.TerminalPage._InitializeTab.<lambda>3,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
98071,METHOD_REF,1,,"[weakThis{ get_weak() }]() {
            if (const auto page{ weakThis.get() })
            {
                page->_FocusCurrentTab(false);
            }
        }",47,,211,winrt.TerminalApp.implementation.TerminalPage._InitializeTab.<lambda>4,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
98396,METHOD_REF,1,,[&]() noexcept { _removing = false; },46,,453,winrt.TerminalApp.implementation.TerminalPage._RemoveTab.<lambda>5,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
98968,METHOD_REF,1,,"[](auto p) {
                if (const auto control{ p->GetTerminalControl() })
                {
                    if (control.ReadOnly())
                    {
                        control.ToggleReadOnly();
                    }
                }
            }",28,,744,winrt.TerminalApp.implementation.TerminalPage._PaneConfirmCloseReadOnly.<lambda>6,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
99160,METHOD_REF,1,,"[ids{ std::move(paneIds) }, weakThis{ get_weak() }, weakTab]() {
                        if (auto strongThis{ weakThis.get() })
                        {
                            strongThis->_ClosePanes(weakTab, std::move(ids));
                        }
                    }",42,,829,winrt.TerminalApp.implementation.TerminalPage._ClosePanes.<lambda>7,2,,cascadia\TerminalApp\TabManagement.cpp:<global>
99973,METHOD_REF,2,,"[weakThis{ get_weak() }](auto& sender, auto& e) {
            auto item{ weakThis.get() };
            auto senderTab{ sender.try_as<winrt::TerminalApp::TabBase>() };

            if (item && senderTab)
            {
                auto changedProperty = e.PropertyName();
                if (changedProperty == L""Title"")
                {
                    item->Name(senderTab.Title());
                }
                else if (changedProperty == L""Icon"")
                {
                    item->Icon(senderTab.Icon());
                }
            }
        }",70,,28,winrt.TerminalApp.implementation.TabPaletteItem.TabPaletteItem.<lambda>0,3,,cascadia\TerminalApp\TabPaletteItem.cpp:<global>
100003,METHOD_REF,2,,"[weakThis{ get_weak() }](auto& /*sender*/, auto& /*e*/) {
                // Sometimes nested bindings do not get updated,
                // thus let's notify property changed on TabStatus when one of its properties changes
                auto item{ weakThis.get() };
                item->_PropertyChangedHandlers(*item, Windows::UI::Xaml::Data::PropertyChangedEventArgs{ L""TabStatus"" });
            }",83,,51,winrt.TerminalApp.implementation.TabPaletteItem.TabPaletteItem.<lambda>1,3,,cascadia\TerminalApp\TabPaletteItem.cpp:<global>
101098,METHOD_REF,-1,,"[weak, actionAndArgs](auto&&, auto&&) {
                if (auto page{ weak.get() })
                {
                    page->_actionDispatch->DoAction(actionAndArgs);
                }
            }",20,,4892,winrt.TerminalApp.implementation.TerminalPage._PopulateContextMenu..<lambda>27,1,,cascadia\TerminalApp\TerminalPage.cpp:<global>
101297,METHOD_REF,1,,"[&](auto&& pane) {
                        if (const auto& term{ pane->GetTerminalControl() })
                        {
                            term.OwningHwnd(reinterpret_cast<uint64_t>(hwnd));
                        }
                    }",58,,90,winrt.TerminalApp.implementation.TerminalPage.Initialize.<lambda>0,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
101622,METHOD_REF,1,,"[weakThis{ get_weak() }](auto&&, auto&&) {
            if (auto page{ weakThis.get() })
            {
                page->_OpenNewTerminalViaDropdown(NewTerminalArgs());
            }
        }",29,,236,winrt.TerminalApp.implementation.TerminalPage.Create.<lambda>1,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
102073,METHOD_REF,1,,"[&originalVirtualCwd, this]() {
            // ignore errors, we'll just power on through. We'd rather do
            // something rather than fail silently if the directory doesn't
            // actually exist.
            _WindowProperties.VirtualWorkingDirectory(originalVirtualCwd);
        }",43,,573,winrt.TerminalApp.implementation.TerminalPage.ProcessStartupActions.<lambda>2,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
102088,METHOD_REF,1,,"[&originalVirtualEnv, this]() {
            _WindowProperties.VirtualEnvVars(originalVirtualEnv);
        }",43,,582,winrt.TerminalApp.implementation.TerminalPage.ProcessStartupActions.<lambda>3,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
102217,METHOD_REF,2,,"[weak = get_weak()]() {
                if (auto self{ weak.get() })
                {
                    self->_InitializedHandlers(*self, nullptr);
                }
            }",64,,689,winrt.TerminalApp.implementation.TerminalPage._CompleteInitialization.<lambda>4,3,,cascadia\TerminalApp\TerminalPage.cpp:<global>
102638,METHOD_REF,1,,"[this](auto&&, auto&&) {
            _FocusCurrentTab(true);
        }",30,,878,winrt.TerminalApp.implementation.TerminalPage._CreateNewTabFlyout.<lambda>5,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
102643,METHOD_REF,1,,"[this](auto&&, auto&&) {
            if (!_commandPaletteIs(Visibility::Visible))
            {
                _FocusCurrentTab(true);
            }
        }",30,,882,winrt.TerminalApp.implementation.TerminalPage._CreateNewTabFlyout.<lambda>6,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
103207,METHOD_REF,1,,"[profileIndex, weakThis{ get_weak() }](auto&&, auto&&) {
            if (auto page{ weakThis.get() })
            {
                NewTerminalArgs newTerminalArgs{ profileIndex };
                page->_OpenNewTerminalViaDropdown(newTerminalArgs);
            }
        }",31,,1073,winrt.TerminalApp.implementation.TerminalPage._CreateNewTabFlyoutProfile.<lambda>7,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
103225,METHOD_REF,1,,"[profileMenuItem](auto&&, auto&&) {
            WUX::Controls::Primitives::FlyoutBase::ShowAttachedFlyout(profileMenuItem);
        }",42,,1086,winrt.TerminalApp.implementation.TerminalPage._CreateNewTabFlyoutProfile.<lambda>8,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105548,METHOD_REF,1,,"[weakThis = get_weak()](auto& /*sender*/, auto& e) {
            if (auto page{ weakThis.get() })
            {
                if (e.PropertyName() == L""BackgroundBrush"")
                {
                    page->_updateThemeColors();
                }
            }
        }",30,,1664,winrt.TerminalApp.implementation.TerminalPage._RegisterTerminalEvents.<lambda>9,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105591,METHOD_REF,1,,"[weak = get_weak(), weakTerm](auto&& sender, auto&& /*args*/) {
            if (const auto& page{ weak.get() })
            {
                page->_PopulateContextMenu(weakTerm.get(), sender.try_as<MUX::Controls::CommandBarFlyout>(), false);
            }
        }",36,,1682,winrt.TerminalApp.implementation.TerminalPage._RegisterTerminalEvents.<lambda>10,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105599,METHOD_REF,1,,"[weak = get_weak(), weakTerm](auto&& sender, auto&& /*args*/) {
            if (const auto& page{ weak.get() })
            {
                page->_PopulateContextMenu(weakTerm.get(), sender.try_as<MUX::Controls::CommandBarFlyout>(), true);
            }
        }",45,,1688,winrt.TerminalApp.implementation.TerminalPage._RegisterTerminalEvents.<lambda>11,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105620,METHOD_REF,1,,"[weakTab, weakThis](auto&&, const WUX::Data::PropertyChangedEventArgs& args) {
            auto page{ weakThis.get() };
            auto tab{ weakTab.get() };
            if (page && tab)
            {
                if (args.PropertyName() == L""Title"")
                {
                    page->_UpdateTitle(*tab);
                }
                else if (args.PropertyName() == L""Content"")
                {
                    if (*tab == page->_GetFocusedTab())
                    {
                        page->_tabContent.Children().Clear();
                        page->_tabContent.Children().Append(tab->Content());

                        tab->Focus(FocusState::Programmatic);
                    }
                }
            }
        }",36,,1710,winrt.TerminalApp.implementation.TerminalPage._RegisterTabEvents.<lambda>12,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105812,METHOD_REF,2,,"[this](auto&&, auto&&) {
            if (_commandPaletteIs(Visibility::Collapsed))
            {
                _FocusActiveControl(nullptr, nullptr);
            }
        }",76,,1840,winrt.TerminalApp.implementation.TerminalPage._loadCommandPaletteSlowPath.<lambda>13,3,,cascadia\TerminalApp\TerminalPage.cpp:<global>
105908,METHOD_REF,2,,"[this](auto&&, auto&&) {
            if (SuggestionsElement().Visibility() == Visibility::Collapsed)
            {
                _FocusActiveControl(nullptr, nullptr);
            }
        }",76,,1873,winrt.TerminalApp.implementation.TerminalPage._loadSuggestionsElementSlowPath.<lambda>14,3,,cascadia\TerminalApp\TerminalPage.cpp:<global>
106631,METHOD_REF,1,,"[&](auto p) {
            if (const auto& control{ p->GetTerminalControl() })
            {
                _manager.Detach(control);
            }
        }",24,,2148,winrt.TerminalApp.implementation.TerminalPage._DetachPaneFromWindow.<lambda>15,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
107866,METHOD_REF,1,,"[](auto&& pane) {
                    if (auto control = pane->GetTerminalControl())
                    {
                        control.PasteTextFromClipboard();
                    }
                }",46,,2951,winrt.TerminalApp.implementation.TerminalPage._PasteText.<lambda>16,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
107902,METHOD_REF,2,,"[](const auto& filePath) {
                HINSTANCE res = ShellExecute(nullptr, nullptr, filePath.c_str(), nullptr, nullptr, SW_SHOW);
                if (static_cast<int>(reinterpret_cast<uintptr_t>(res)) <= 32)
                {
                    ShellExecute(nullptr, nullptr, L""notepad"", filePath.c_str(), nullptr, SW_SHOW);
                }
            }",29,,2987,winrt.TerminalApp.implementation.TerminalPage._LaunchSettings.<lambda>17,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
108620,METHOD_REF,1,,"[&](auto&& pane) {
                    if (const auto profile{ pane->GetProfile() })
                    {
                        const auto found{ profileGuidSettingsMap.find(profile.Guid()) };
                        // GH#2455: If there are any panes with controls that had been
                        // initialized with a Profile that no longer exists in our list of
                        // profiles, we'll leave it unmodified. The profile doesn't exist
                        // anymore, so we can't possibly update its settings.
                        if (found != profileGuidSettingsMap.cend())
                        {
                            auto& pair{ found->second };
                            if (!pair.second)
                            {
                                pair.second = TerminalSettings::CreateWithProfile(_settings, pair.first, *_bindings);
                            }
                            pane->UpdateSettings(pair.second, pair.first);
     ...",54,,3292,winrt.TerminalApp.implementation.TerminalPage._RefreshUIForSettingsReload.<lambda>18,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
109018,METHOD_REF,1,,"[&](auto&& pane) {
                    if (auto control = pane->GetTerminalControl())
                    {
                        control.WindowVisibilityChanged(showOrHide);
                    }
                }",54,,3509,winrt.TerminalApp.implementation.TerminalPage.WindowVisibilityChanged.<lambda>19,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
109622,METHOD_REF,2,,"[&]() {
                finalVal = _OnNewConnection(connection);
                latch.count_down();
            }",67,,3815,winrt.TerminalApp.implementation.TerminalPage._OnNewConnection.<lambda>20,3,,cascadia\TerminalApp\TerminalPage.cpp:<global>
109710,METHOD_REF,1,,"[weakThis{ get_weak() }](auto&& /*s*/, winrt::Microsoft::Terminal::Settings::Model::SettingsTarget e) {
                if (auto page{ weakThis.get() })
                {
                    page->_LaunchSettings(e);
                }
            }",26,,3897,winrt.TerminalApp.implementation.TerminalPage.OpenSettingsUI.<lambda>21,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
109793,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }](auto&& /*s*/, auto&& /*e*/) {
                auto page{ weakThis.get() };
                auto tab{ weakTab.get() };

                if (page && tab)
                {
                    page->_HandleCloseTabRequested(*tab);
                }
            }",40,,3926,winrt.TerminalApp.implementation.TerminalPage.OpenSettingsUI.<lambda>22,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
109798,METHOD_REF,1,,"[weakTab, weakThis{ get_weak() }](auto&& /*s*/, auto&& /*e*/) {
                const auto page = weakThis.get();
                const auto tab = weakTab.get();

                if (page && tab)
                {
                    page->_RemoveTab(*tab);
                }
            }",32,,3937,winrt.TerminalApp.implementation.TerminalPage.OpenSettingsUI.<lambda>23,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
110985,METHOD_REF,3,,[&](const auto& m) { return m == message; },60,,4590,winrt.TerminalApp.implementation.TerminalPage._DismissMessage.<lambda>24,4,,cascadia\TerminalApp\TerminalPage.cpp:<global>
111547,METHOD_REF,1,,"[activated](const auto& p) {
                    if (const auto& control{ p->GetTerminalControl() })
                    {
                        control.CursorVisibility(activated ?
                                                     Microsoft::Terminal::Control::CursorDisplayState::Shown :
                                                     Microsoft::Terminal::Control::CursorDisplayState::Default);
                    }
                }",46,,4782,winrt.TerminalApp.implementation.TerminalPage.WindowActivated.<lambda>25,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
111714,METHOD_REF,2,,"[weak](const ActionAndArgs& actionAndArgs) {
            return [weak, actionAndArgs](auto&&, auto&&) {
                if (auto page{ weak.get() })
                {
                    page->_actionDispatch->DoAction(actionAndArgs);
                }
            };
        }",29,,4891,winrt.TerminalApp.implementation.TerminalPage._PopulateContextMenu.<lambda>26,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
111718,METHOD_REF,2,,"[&menu, &makeCallback](const winrt::hstring& label,
                                               const winrt::hstring& icon,
                                               const auto& action) {
            AppBarButton button{};

            if (!icon.empty())
            {
                auto iconElement = IconPathConverter::IconWUX(icon);
                Automation::AutomationProperties::SetAccessibilityView(iconElement, Automation::Peers::AccessibilityView::Raw);
                button.Icon(iconElement);
            }

            button.Label(label);
            button.Click(makeCallback(action));
            menu.SecondaryCommands().Append(button);
        }",25,,4900,winrt.TerminalApp.implementation.TerminalPage._PopulateContextMenu.<lambda>28,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
112493,METHOD_REF,1,,"[profileIndex, weakThis{ get_weak() }](auto&&, auto&&) {
            if (auto page{ weakThis.get() })
            {
                NewTerminalArgs args{ profileIndex };
                args.Elevate(true);
                page->_OpenNewTerminalViaDropdown(args);
            }
        }",30,,5210,winrt.TerminalApp.implementation.TerminalPage._CreateRunAsAdminFlyout.<lambda>29,2,,cascadia\TerminalApp\TerminalPage.cpp:<global>
113276,METHOD_REF,1,,"[&](auto p) {
                        if (const auto& control{ p->GetTerminalControl() })
                        {
                            f(control);
                        }
                    }",42,,369,winrt.TerminalApp.implementation.TerminalPage._ApplyToActiveControls.<lambda>0,2,,winrt.TerminalApp.implementation.TerminalPage
115928,METHOD_REF,1,,"[&](std::shared_ptr<Pane> pane) {
            // update the IDs on each pane
            if (pane->_IsLeaf())
            {
                pane->Id(_nextPaneId);
                _nextPaneId++;
            }
            // Try to find the pane marked active (if it exists)
            if (pane->_lastActive)
            {
                _activePane = pane;
            }
        }",29,,43,winrt.TerminalApp.implementation.TerminalTab.TerminalTab.<lambda>0,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
115982,METHOD_REF,1,,"[=](auto&& /*s*/, auto&& /*e*/) {
            _ClosedHandlers(nullptr, nullptr);
        }",46,,82,winrt.TerminalApp.implementation.TerminalTab._Setup.<lambda>1,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
115999,METHOD_REF,1,,"[weakThis = get_weak()](auto&& title) {
            if (auto tab{ weakThis.get() })
            {
                tab->SetTabText(title);
            }
        }",45,,94,winrt.TerminalApp.implementation.TerminalTab._Setup.<lambda>2,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116004,METHOD_REF,1,,"[weakThis = get_weak()](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_RequestFocusActiveControlHandlers();
            }
        }",36,,103,winrt.TerminalApp.implementation.TerminalTab._Setup.<lambda>3,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116035,METHOD_REF,1,,"[weakThis = get_weak()](auto&& /*s*/, auto&& /*e*/) {
            if (auto tab{ weakThis.get() })
            {
                tab->ActivateTabRenamer();
            }
        }",36,,137,winrt.TerminalApp.implementation.TerminalTab._MakeTabViewItem.<lambda>4,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116085,METHOD_REF,1,,"[&](std::shared_ptr<Pane> pane) {
            // Attach event handlers to each new pane
            _AttachEventHandlersToPane(pane);
            if (auto control = pane->GetTerminalControl())
            {
                _AttachEventHandlersToControl(pane->Id().value(), control);
            }
        }",29,,200,winrt.TerminalApp.implementation.TerminalTab.Initialize.<lambda>5,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116708,METHOD_REF,1,,"[&](auto p) {
            _AttachEventHandlersToPane(p);
            if (p->_IsLeaf())
            {
                p->Id(_nextPaneId);
                _AttachEventHandlersToControl(p->Id().value(), p->_control);
                _nextPaneId++;
            }
            return false;
        }",24,,511,winrt.TerminalApp.implementation.TerminalTab.SplitPane.<lambda>6,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116820,METHOD_REF,1,,"[](auto pane) {
            pane->_DetachedHandlers(pane);
        }",21,,598,winrt.TerminalApp.implementation.TerminalTab.DetachRoot.<lambda>7,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116853,METHOD_REF,1,,"[&](auto p) {
            _AttachEventHandlersToPane(p);
            if (p->_IsLeaf())
            {
                p->Id(_nextPaneId);
                _AttachEventHandlersToControl(p->Id().value(), p->_control);
                _nextPaneId++;
            }
        }",24,,624,winrt.TerminalApp.implementation.TerminalTab.AttachPane.<lambda>8,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116936,METHOD_REF,1,,"[weakThis](auto newTabColor) {
            if (auto tab{ weakThis.get() })
            {
                tab->SetRuntimeTabColor(newTabColor);
            }
        }",61,,673,winrt.TerminalApp.implementation.TerminalTab.AttachColorPicker.<lambda>9,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116943,METHOD_REF,1,,"[weakThis]() {
            if (auto tab{ weakThis.get() })
            {
                tab->ResetRuntimeTabColor();
            }
        }",59,,680,winrt.TerminalApp.implementation.TerminalTab.AttachColorPicker.<lambda>10,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
116950,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                tab->_tabColorPickup.ColorSelected(tab->_colorSelectedToken);
                tab->_tabColorPickup.ColorCleared(tab->_colorClearedToken);
                tab->_tabColorPickup.Closed(tab->_pickerClosedToken);
                tab->_tabColorPickup = nullptr;
            }
        }",53,,687,winrt.TerminalApp.implementation.TerminalTab.AttachColorPicker.<lambda>11,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117399,METHOD_REF,1,,"[dispatcher, weakThis](auto&&, auto&&) -> winrt::fire_and_forget {
            // The lambda lives in the `std::function`-style container owned by `control`. That is, when the
            // `control` gets destroyed the lambda struct also gets destroyed. In other words, we need to
            // copy `weakThis` onto the stack, because that's the only thing that gets captured in coroutines.
            // See: https://devblogs.microsoft.com/oldnewthing/20211103-00/?p=105870
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (auto tab{ weakThisCopy.get() })
            {
                // The title of the control changed, but not necessarily the title of the tab.
                // Set the tab's text to the active panes' text.
                tab->UpdateTitle();
            }
        }",50,,929,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>12,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117408,METHOD_REF,1,,"[dispatcher, weakThis](auto&&, auto&&) -> winrt::fire_and_forget {
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (auto tab{ weakThisCopy.get() })
            {
                // The control's tabColor changed, but it is not necessarily the
                // active control in this tab. We'll just recalculate the
                // current color anyways.
                tab->_RecalculateAndApplyTabColor();
            }
        }",53,,944,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>13,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117417,METHOD_REF,1,,"[dispatcher, weakThis](auto&&, auto&&) -> winrt::fire_and_forget {
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (auto tab{ weakThisCopy.get() })
            {
                tab->_UpdateProgressState();
            }
        }",58,,956,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>14,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117426,METHOD_REF,1,,"[dispatcher, weakThis](auto&&, auto&&) -> winrt::fire_and_forget {
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (auto tab{ weakThisCopy.get() })
            {
                tab->_UpdateConnectionClosedState();
            }
        }",60,,965,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>15,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117435,METHOD_REF,1,,"[dispatcher, weakThis](auto&&, auto&&) -> winrt::fire_and_forget {
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (auto tab{ weakThisCopy.get() })
            {
                tab->_RecalculateAndApplyReadOnly();
            }
        }",56,,974,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>16,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117444,METHOD_REF,1,,"[dispatcher, weakThis](auto sender, auto) -> winrt::fire_and_forget {
            const auto weakThisCopy = weakThis;
            co_await wil::resume_foreground(dispatcher);
            if (const auto tab{ weakThisCopy.get() })
            {
                if (tab->_focused())
                {
                    if (const auto termControl{ sender.try_as<winrt::Microsoft::Terminal::Control::TermControl>() })
                    {
                        termControl.Focus(FocusState::Pointer);
                    }
                }
            }
        }",63,,983,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToControl.<lambda>17,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117625,METHOD_REF,1,,"[&](const auto& p) {
                return p->IsConnectionClosed();
            }",55,,1094,winrt.TerminalApp.implementation.TerminalTab._UpdateConnectionClosedState.<lambda>18,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117783,METHOD_REF,1,,"[weakThis](std::shared_ptr<Pane> sender, WUX::FocusState focus) {
            // Do nothing if the Tab's lifetime is expired or pane isn't new.
            auto tab{ weakThis.get() };

            if (tab)
            {
                if (sender != tab->_activePane)
                {
                    auto senderIsChild = tab->_activePane->_HasChild(sender);

                    // Only move focus if we the program moved focus, or the
                    // user moved with their mouse. This is a problem because a
                    // pane isn't a control itself, and if we have the parent
                    // focused we are fine if the terminal control is focused,
                    // but we don't want to update the active pane.
                    if (!senderIsChild ||
                        (focus == WUX::FocusState::Programmatic && tab->_changingActivePane) ||
                        focus == WUX::FocusState::Pointer)
                    {
                        tab->_U...",45,,1175,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToPane.<lambda>19,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117790,METHOD_REF,1,,"[weakThis](std::shared_ptr<Pane> /*sender*/) {
            // Do nothing if the Tab's lifetime is expired or pane isn't new.
            auto tab{ weakThis.get() };

            if (tab)
            {
                // update this tab's focus state
                tab->_focusState = WUX::FocusState::Unfocused;
            }
        }",47,,1207,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToPane.<lambda>20,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117797,METHOD_REF,1,,"[weakThis, weakPane](auto&& /*s*/, auto&& /*e*/) {
            if (auto tab{ weakThis.get() })
            {
                if (tab->_zoomedPane)
                {
                    tab->Content(tab->_rootPane->GetRootElement());
                    tab->ExitZoom();
                }

                if (auto pane = weakPane.lock())
                {
                    // When a parent pane is selected, but one of its children
                    // close out under it we still need to update title/focus information
                    // but the GotFocus handler will rightly see that the _activePane
                    // did not actually change. Triggering
                    if (pane != tab->_activePane && !tab->_activePane->_IsLeaf())
                    {
                        tab->_UpdateActivePane(tab->_activePane);
                    }

                    for (auto i = tab->_mruPanes.begin(); i != tab->_mruPanes.end(); ++i)
                    {
                      ...",41,,1221,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToPane.<lambda>21,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117804,METHOD_REF,1,,"[weakThis](auto&& /*s*/, auto&& visual) {
            if (auto tab{ weakThis.get() })
            {
                if (visual)
                {
                    // If visual is set, we need to bubble this event all the way to app host to flash the taskbar
                    // In this part of the chain we bubble it from the hosting tab to the page
                    tab->_TabRaiseVisualBellHandlers();
                }

                // Show the bell indicator in the tab header
                tab->ShowBellIndicator(true);

                // If this tab is focused, activate the bell indicator timer, which will
                // remove the bell indicator once it fires
                // (otherwise, the indicator is removed when the tab gets focus)
                if (tab->_focusState != WUX::FocusState::Unfocused)
                {
                    tab->ActivateBellIndicatorTimer();
                }
            }
        }",46,,1254,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToPane.<lambda>22,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
117818,METHOD_REF,1,,"[weakThis, weakPane, gotFocusToken, lostFocusToken, closedToken, bellToken, detachedToken](std::shared_ptr<Pane> /*sender*/) {
            // Make sure we do this at most once
            if (auto pane{ weakPane.lock() })
            {
                pane->Detached(*detachedToken);
                pane->GotFocus(gotFocusToken);
                pane->LostFocus(lostFocusToken);
                pane->Closed(closedToken);
                pane->PaneRaiseBell(bellToken);

                if (auto tab{ weakThis.get() })
                {
                    if (auto control = pane->GetTerminalControl())
                    {
                        tab->_DetachEventHandlersFromControl(pane->Id().value(), control);
                    }

                    for (auto i = tab->_mruPanes.begin(); i != tab->_mruPanes.end(); ++i)
                    {
                        if (*i == pane->Id())
                        {
                            tab->_mruPanes.erase(i);
                   ...",41,,1282,winrt.TerminalApp.implementation.TerminalTab._AttachEventHandlersToPane.<lambda>23,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118314,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
                if (auto tab{ weakThis.get() })
                {
                    tab->_RestartActivePaneConnection();
                }
            }",45,,1462,winrt.TerminalApp.implementation.TerminalTab._CreateContextMenu.<lambda>24,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118428,METHOD_REF,1,,"[weakThis](auto&&, auto&&) {
            if (auto tab{ weakThis.get() })
            {
                // GH#10112 - if we're opening the tab renamer, don't
                // immediately toss focus to the control. We don't want to steal
                // focus from the tab renamer.
                if (!tab->_headerControl.InRename() && !tab->GetActiveTerminalControl().SearchBoxEditInFocus())
                {
                    tab->_RequestFocusActiveControlHandlers();
                }
            }
        }",34,,1492,winrt.TerminalApp.implementation.TerminalTab._CreateContextMenu.<lambda>25,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118799,METHOD_REF,1,,"[&](const auto& p) {
            if (const auto& control{ p->GetTerminalControl() })
            {
                hasReadOnly |= control.ReadOnly();
                allReadOnly &= control.ReadOnly();
            }
        }",31,,1708,winrt.TerminalApp.implementation.TerminalTab.TogglePaneReadOnly.<lambda>26,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118804,METHOD_REF,1,,"[&](const auto& p) {
            if (const auto& control{ p->GetTerminalControl() })
            {
                // If all controls have the same read only state then just toggle
                if (allReadOnly || !hasReadOnly)
                {
                    control.ToggleReadOnly();
                }
                // otherwise set to all read only.
                else if (!control.ReadOnly())
                {
                    control.ToggleReadOnly();
                }
            }
        }",31,,1715,winrt.TerminalApp.implementation.TerminalTab.TogglePaneReadOnly.<lambda>27,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118819,METHOD_REF,1,,"[&](const auto& p) {
            if (const auto& control{ p->GetTerminalControl() })
            {
                hasReadOnly |= control.ReadOnly();
                allReadOnly &= control.ReadOnly();
            }
        }",31,,1740,winrt.TerminalApp.implementation.TerminalTab.SetPaneReadOnly.<lambda>28,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118824,METHOD_REF,1,,"[&](const auto& p) {
            if (const auto& control{ p->GetTerminalControl() })
            {
                // If all controls have the same read only state then just disable
                if (allReadOnly || !hasReadOnly)
                {
                    control.SetReadOnly(readOnlyState);
                }
                // otherwise set to all read only.
                else if (!control.ReadOnly())
                {
                    control.SetReadOnly(readOnlyState);
                }
            }
        }",31,,1747,winrt.TerminalApp.implementation.TerminalTab.SetPaneReadOnly.<lambda>29,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118941,METHOD_REF,1,,"[&](const auto& p) {
            const auto paneId = p->Id();
            if (!paneId.has_value())
            {
                return;
            }
            if (const auto& control{ p->GetTerminalControl() })
            {
                auto it = _controlEvents.find(*paneId);
                if (it != _controlEvents.end())
                {
                    auto& events = it->second;

                    // Always clear out old ones, just in case.
                    events.KeySent.revoke();
                    events.CharSent.revoke();
                    events.StringSent.revoke();

                    if (newIsBroadcasting)
                    {
                        _addBroadcastHandlers(control, events);
                    }
                }
            }
        }",29,,1823,winrt.TerminalApp.implementation.TerminalTab.ToggleBroadcastInput.<lambda>30,2,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118963,METHOD_REF,2,,"[weakThis](auto&& sender, auto&& e) {
            if (const auto tab{ weakThis.get() })
            {
                if (tab->_tabStatus.IsInputBroadcastActive())
                {
                    tab->_rootPane->BroadcastKey(sender.try_as<TermControl>(),
                                                 e.VKey(),
                                                 e.ScanCode(),
                                                 e.Modifiers(),
                                                 e.KeyDown());
                }
            }
        }",66,,1854,winrt.TerminalApp.implementation.TerminalTab._addBroadcastHandlers.<lambda>31,3,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118975,METHOD_REF,2,,"[weakThis](auto&& sender, auto&& e) {
            if (const auto tab{ weakThis.get() })
            {
                if (tab->_tabStatus.IsInputBroadcastActive())
                {
                    tab->_rootPane->BroadcastChar(sender.try_as<TermControl>(),
                                                  e.Character(),
                                                  e.ScanCode(),
                                                  e.Modifiers());
                }
            }
        }",68,,1868,winrt.TerminalApp.implementation.TerminalTab._addBroadcastHandlers.<lambda>32,3,,cascadia\TerminalApp\TerminalTab.cpp:<global>
118987,METHOD_REF,2,,"[weakThis](auto&& sender, auto&& e) {
            if (const auto tab{ weakThis.get() })
            {
                if (tab->_tabStatus.IsInputBroadcastActive())
                {
                    tab->_rootPane->BroadcastString(sender.try_as<TermControl>(),
                                                    e.Text());
                }
            }
        }",72,,1881,winrt.TerminalApp.implementation.TerminalTab._addBroadcastHandlers.<lambda>33,3,,cascadia\TerminalApp\TerminalTab.cpp:<global>
120280,METHOD_REF,1,,"[this](const Windows::Foundation::IInspectable& sender, const RoutedEventArgs&) {
            auto theme{ _settings.GlobalSettings().CurrentTheme() };
            auto requestedTheme{ theme.RequestedTheme() };
            auto element{ sender.try_as<winrt::Windows::UI::Xaml::FrameworkElement>() };
            while (element)
            {
                element.RequestedTheme(requestedTheme);
                element = element.Parent().try_as<winrt::Windows::UI::Xaml::FrameworkElement>();
            }
        }",29,,351,winrt.TerminalApp.implementation.TerminalWindow.ShowDialog.<lambda>0,1,,cascadia\TerminalApp\TerminalWindow.cpp:<global>
122932,METHOD_REF,2,,"[weakThis = get_weak(), bgProperty](auto& /*sender*/, auto& e) {
            if (auto self{ weakThis.get() })
            {
                if (e == bgProperty)
                {
                    self->_backgroundChanged(self->Background());
                }
            }
        }",53,,36,winrt.TerminalApp.implementation.TitlebarControl.TitlebarControl.<lambda>0,2,,cascadia\TerminalApp\TitlebarControl.cpp:<global>
123485,METHOD_REF,1,,"[weakThis](auto&&...) {
        if (auto self{ weakThis.lock() })
        {
            self->_timer.Stop();
            self->_tip.IsOpen(false);
        }
    }",17,,32,Toast.Open.<lambda>0,2,,cascadia\TerminalApp\Toast.cpp:<global>
124029,METHOD_REF,1,,"[&]() {
            const auto size = GetConsoleScreenSize(outputHandle);

            connection.Resize(size.height, size.width);
        }",45,,34,RunConnectionToCompletion..<lambda>2,2,,cascadia\TerminalAzBridge\main.cpp:<global>
124171,METHOD_REF,1,,"[outputHandle](const winrt::hstring& output) {
        WriteConsoleW(outputHandle, output.data(), output.size(), nullptr, nullptr);
    }",31,,25,RunConnectionToCompletion.<lambda>0,2,,cascadia\TerminalAzBridge\main.cpp:<global>
124178,METHOD_REF,1,,"[connection, outputHandle, inputHandle] {
        ConsoleInputReader reader{ inputHandle };
        reader.SetWindowSizeChangedCallback([&]() {
            const auto size = GetConsoleScreenSize(outputHandle);

            connection.Resize(size.height, size.width);
        });

        while (true)
        {
            auto input = reader.Read();
            if (input)
            {
                connection.WriteInput(*input);
            }
        }
    }",17,,32,RunConnectionToCompletion.<lambda>1,2,,cascadia\TerminalAzBridge\main.cpp:<global>
124191,METHOD_REF,1,,"[&](auto&& /*s*/, auto&& /*e*/) {
        std::unique_lock<std::mutex> lg{ stateMutex };
        state = connection.State();
        stateChangeVar.notify_all();
    }",29,,54,RunConnectionToCompletion.<lambda>3,2,,cascadia\TerminalAzBridge\main.cpp:<global>
124212,METHOD_REF,2,,"[&]() {
        if (!state.has_value())
        {
            return false;
        }
        return state.value() == ConnectionState::Closed || state.value() == ConnectionState::Failed;
    }",29,,63,RunConnectionToCompletion.<lambda>4,3,,cascadia\TerminalAzBridge\main.cpp:<global>
124292,METHOD_REF,1,,"[&]() {
        SetConsoleMode(conIn, inputMode);
        SetConsoleMode(conOut, outputMode);
        SetConsoleCP(codepage);
        SetConsoleOutputCP(outputCodepage);
    }",48,,90,wmain.<lambda>5,2,,cascadia\TerminalAzBridge\main.cpp:<global>
124818,METHOD_REF,3,,"[](LPVOID lpParameter) noexcept {
                const auto pInstance = static_cast<AzureConnection*>(lpParameter);
                if (pInstance)
                {
                    return pInstance->_OutputThread();
                }
                return gsl::narrow<DWORD>(E_INVALIDARG);
            }",13,,127,winrt.Microsoft.Terminal.TerminalConnection.implementation.AzureConnection.Start.<lambda>0,3,,cascadia\TerminalConnection\AzureConnection.cpp:<global>
124870,METHOD_REF,2,,"[this, mode]() {
            return _currentInputMode != mode || _isStateAtOrBeyond(ConnectionState::Closing);
        }",37,,159,winrt.Microsoft.Terminal.TerminalConnection.implementation.AzureConnection._ReadUserInput.<lambda>1,3,,cascadia\TerminalConnection\AzureConnection.cpp:<global>
126673,METHOD_REF,4,,_crackTenant,95,,927,winrt.Microsoft.Terminal.TerminalConnection.implementation._crackTenant,5,,Tenant
128502,METHOD_REF,3,,"[](LPVOID lpParameter) noexcept {
                const auto pInstance = static_cast<ConptyConnection*>(lpParameter);
                if (pInstance)
                {
                    return pInstance->_OutputThread();
                }
                return gsl::narrow_cast<DWORD>(E_INVALIDARG);
            }",13,,409,winrt.Microsoft.Terminal.TerminalConnection.implementation.ConptyConnection.Start.<lambda>0,3,,cascadia\TerminalConnection\ConptyConnection.cpp:<global>
130386,METHOD_REF,1,,"[this](std::wstring_view wstr) {
            _sendInputToConnection(wstr);
        }",42,,95,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ControlCore.<lambda>0,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
130579,METHOD_REF,2,,"[=](auto&& menuJson, auto&& replaceLength) { _terminalCompletionsChanged(menuJson, replaceLength); }",38,,126,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ControlCore.<lambda>1,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
130639,METHOD_REF,1,,[this]() { _rendererBackgroundColorChanged(); },58,,146,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ControlCore.<lambda>2,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
130644,METHOD_REF,1,,[this]() { _rendererTabColorChanged(); },53,,147,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ControlCore.<lambda>3,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
130649,METHOD_REF,1,,"[this]() { _RendererEnteredErrorStateHandlers(nullptr, nullptr); }",61,,148,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ControlCore.<lambda>4,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
130719,METHOD_REF,3,,"[weakThis = get_weak()]() {
                if (auto core{ weakThis.get() }; !core->_IsClosing())
                {
                    core->_CursorPositionChangedHandlers(*core, nullptr);
                }
            }",13,,187,winrt.Microsoft.Terminal.Control.implementation.ControlCore._setupDispatcherAndCallbacks.<lambda>5,4,,cascadia\TerminalControl\ControlCore.cpp:<global>
130729,METHOD_REF,2,,"[weakTerminal = std::weak_ptr{ _terminal }]() {
                if (const auto t = weakTerminal.lock())
                {
                    const auto lock = t->LockForWriting();
                    t->UpdatePatternsUnderLock();
                }
            }",13,,198,winrt.Microsoft.Terminal.Control.implementation.ControlCore._setupDispatcherAndCallbacks.<lambda>6,3,,cascadia\TerminalControl\ControlCore.cpp:<global>
130748,METHOD_REF,3,,"[weakThis = get_weak()](const auto& update) {
                if (auto core{ weakThis.get() }; !core->_IsClosing())
                {
                    core->_ScrollPositionChangedHandlers(*core, update);
                }
            }",13,,209,"_dispatcher,
            ScrollBarUpdateInterval,
            [weakThis = get_weak()](const auto& update) {
                if (auto core{ weakThis.get() }; !core->_IsClosing())
                {
                    core->_ScrollPositionChangedHandlers(*core, update);
                }
            }.<lambda>7",3,,cascadia\TerminalControl\ControlCore.cpp:<global>
130872,METHOD_REF,2,,"[this](auto&& /*s*/, auto&& /*v*/) {
                _ConnectionStateChangedHandlers(*this, nullptr);
            }",93,,279,winrt.Microsoft.Terminal.Control.implementation.ControlCore.Connection.<lambda>8,3,,cascadia\TerminalControl\ControlCore.cpp:<global>
131172,METHOD_REF,1,,"[this](HANDLE handle) {
                _renderEngineSwapChainChanged(handle);
            }",40,,393,winrt.Microsoft.Terminal.Control.implementation.ControlCore.Initialize.<lambda>9,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
131411,METHOD_REF,1,,"[weakSelf = get_weak()](auto&&, auto&&) {
                if (const auto self = weakSelf.get())
                {
                    self->_midiAudio.EndSkip();
                }
            }",38,,524,winrt.Microsoft.Terminal.Control.implementation.ControlCore._handleControlC.<lambda>10,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
134814,METHOD_REF,2,,"[&](TerminalInput::OutputType&& out) {
                        if (out)
                        {
                            buffer.append(std::move(*out));
                        }
                    }",41,,1948,winrt.Microsoft.Terminal.Control.implementation.ControlCore.LeftClickOnTerminal.<lambda>11,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
136978,METHOD_REF,2,,[](const ::ScrollMark& m) -> bool { return !m.HasCommand(); },13,,2680,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ContextMenuSelectCommand.<lambda>12,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
136979,METHOD_REF,3,,"[](const ::ScrollMark& m) { return til::point_span{ m.end, *m.commandEnd }; }",13,,2681,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ContextMenuSelectCommand.<lambda>13,3,,cascadia\TerminalControl\ControlCore.cpp:<global>
136986,METHOD_REF,2,,[](const ::ScrollMark& m) -> bool { return !m.HasOutput(); },13,,2687,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ContextMenuSelectOutput.<lambda>14,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
136987,METHOD_REF,3,,"[](const ::ScrollMark& m) { return til::point_span{ *m.commandEnd, *m.outputEnd }; }",13,,2688,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ContextMenuSelectOutput.<lambda>15,3,,cascadia\TerminalControl\ControlCore.cpp:<global>
137062,METHOD_REF,2,,[](const ::ScrollMark& m) -> bool { return !m.HasCommand(); },31,,2733,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ShouldShowSelectCommand.<lambda>16,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
137070,METHOD_REF,2,,[](const ::ScrollMark& m) -> bool { return !m.HasOutput(); },31,,2742,winrt.Microsoft.Terminal.Control.implementation.ControlCore.ShouldShowSelectOutput.<lambda>17,2,,cascadia\TerminalControl\ControlCore.cpp:<global>
138739,METHOD_REF,1,,"[weakThis = get_weak()](auto&&, auto&&) {
            if (auto self{ weakThis.get() })
            {
                self->_AttachedHandlers(*self, nullptr);
            }
        }",25,,53,winrt.Microsoft.Terminal.Control.implementation.ControlInteractivity.ControlInteractivity.<lambda>0,2,,cascadia\TerminalControl\ControlInteractivity.cpp:<global>
138955,METHOD_REF,1,,"[core = _core](const winrt::hstring& wstr) {
                core->PasteText(wstr);
            }",13,,228,"[core = _core](const winrt.hstring& wstr) {
                core->PasteText(wstr);
            },
            _core->BracketedPasteEnabled().<lambda>1",1,,cascadia\TerminalControl\ControlInteractivity.cpp:<global>
142739,METHOD_REF,1,,[=](std::wstring_view input) noexcept { _WriteTextToConnection(input); },38,,229,HwndTerminal.Initialize.<lambda>0,2,,cascadia\TerminalControl\HwndTerminal.cpp:<global>
143665,METHOD_REF,3,,"[](wchar_t c) {
                        return (c < UNICODE_SPACE && c != UNICODE_NEWLINE) || c == 0x7F /*DEL*/;
                    }",72,,35,Sanitize.<lambda>0,4,,cascadia\TerminalControl\HwndTerminalAutomationPeer.cpp:<global>
145121,METHOD_REF,2,,"[this](auto&&, auto&&) {
            // Once the control is visible again we trigger SearchChanged event.
            // We do this since we probably have a value from the previous search,
            // and in such case logically the search changes from ""nothing"" to this value.
            // A good example for SearchChanged event consumer is Terminal Control.
            // Once the Search Box is open we want the Terminal Control
            // to immediately perform the search with the value appearing in the box.
            if (Visibility() == Visibility::Visible)
            {
                _SearchChangedHandlers(TextBox().Text(), _GoForward(), _CaseSensitive());
            }
        }",80,,22,winrt.Microsoft.Terminal.Control.implementation.SearchBoxControl.SearchBoxControl.<lambda>0,3,,cascadia\TerminalControl\SearchBoxControl.cpp:<global>
147481,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            // This event fires every time the layout changes, but it is always the last one to fire
            // in any layout change chain. That gives us great flexibility in finding the right point
            // at which to initialize our renderer (and our terminal).
            // Any earlier than the last layout update and we may not know the terminal's starting size.
            if (_InitializeTerminal(InitializeReason::Create))
            {
                // Only let this succeed once.
                _layoutUpdatedRevoker.revoke();
            }
        }",84,,109,winrt.Microsoft.Terminal.Control.implementation.TermControl.TermControl.<lambda>0,3,,cascadia\TerminalControl\TermControl.cpp:<global>
147507,METHOD_REF,3,,"[weakThis = get_weak()]() {
                if (auto control{ weakThis.get() }; !control->_IsClosing())
                {
                    control->_WarningBellHandlers(*control, nullptr);
                }
            }",13,,131,"dispatcher,
            TerminalWarningBellInterval,
            [weakThis = get_weak()]() {
                if (auto control{ weakThis.get() }; !control->_IsClosing())
                {
                    control->_WarningBellHandlers(*control, nullptr);
                }
            }.<lambda>1",3,,cascadia\TerminalControl\TermControl.cpp:<global>
147522,METHOD_REF,3,,"[weakThis = get_weak()](const auto& update) {
                if (auto control{ weakThis.get() }; !control->_IsClosing())
                {
                    control->_throttledUpdateScrollbar(update);
                }
            }",13,,141,"dispatcher,
            ScrollBarUpdateInterval,
            [weakThis = get_weak()](const auto& update) {
                if (auto control{ weakThis.get() }; !control->_IsClosing())
                {
                    control->_throttledUpdateScrollbar(update);
                }
            }.<lambda>2",3,,cascadia\TerminalControl\TermControl.cpp:<global>
147682,METHOD_REF,1,,"[weakThis = get_weak()](auto&&, auto&&) {
            if (auto control{ weakThis.get() }; !control->_IsClosing())
            {
                const auto& menu{ control->ContextMenu() };
                menu.PrimaryCommands().Clear();
                menu.SecondaryCommands().Clear();
                for (const auto& e : control->_originalPrimaryElements)
                {
                    menu.PrimaryCommands().Append(e);
                }
                for (const auto& e : control->_originalSecondaryElements)
                {
                    menu.SecondaryCommands().Append(e);
                }
            }
        }",30,,185,winrt.Microsoft.Terminal.Control.implementation.TermControl.TermControl.<lambda>3,2,,cascadia\TerminalControl\TermControl.cpp:<global>
147687,METHOD_REF,1,,"[weakThis = get_weak()](auto&&, auto&&) {
            if (auto control{ weakThis.get() }; !control->_IsClosing())
            {
                const auto& menu{ control->SelectionContextMenu() };
                menu.PrimaryCommands().Clear();
                menu.SecondaryCommands().Clear();
                for (const auto& e : control->_originalSelectedPrimaryElements)
                {
                    menu.PrimaryCommands().Append(e);
                }
                for (const auto& e : control->_originalSelectedSecondaryElements)
                {
                    menu.SecondaryCommands().Append(e);
                }
            }
        }",39,,201,winrt.Microsoft.Terminal.Control.implementation.TermControl.TermControl.<lambda>4,2,,cascadia\TerminalControl\TermControl.cpp:<global>
147740,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            // Replace the normal initialize routine with one that will allow up
            // to complete initialization even though the Core was already
            // initialized.
            if (_InitializeTerminal(InitializeReason::Reattach))
            {
                // Only let this succeed once.
                _layoutUpdatedRevoker.revoke();
            }
        }",69,,244,winrt.Microsoft.Terminal.Control.implementation.TermControl._initializeForAttach.<lambda>5,3,,cascadia\TerminalControl\TermControl.cpp:<global>
148040,METHOD_REF,2,,"[&](til::CoordType row) [[msvc::forceinline]] {
                const auto y = std::clamp<long>(lrintf(row * offsetScale), 0, maxOffsetY);
                return drawableDataStart + stride * y;
            }",33,,350,winrt.Microsoft.Terminal.Control.implementation.TermControl._throttledUpdateScrollbar.<lambda>6,2,,cascadia\TerminalControl\TermControl.cpp:<global>
148044,METHOD_REF,2,,"[&](uint8_t* beg, til::color color) [[msvc::forceinline]] {
                const auto end = beg + pipHeight * stride;
                for (; beg < end; beg += stride)
                {
                    // a til::color does NOT have the same RGBA format as the bitmap.
#pragma warning(suppress : 26490) // Don't use reinterpret_cast (type.1).
                    const DWORD c = 0xff << 24 | color.r << 16 | color.g << 8 | color.b;
                    std::fill_n(reinterpret_cast<DWORD*>(beg), pipWidth, c);
                }
            }",34,,355,winrt.Microsoft.Terminal.Control.implementation.TermControl._throttledUpdateScrollbar.<lambda>7,2,,cascadia\TerminalControl\TermControl.cpp:<global>
151159,METHOD_REF,1,,"[](auto& update) {
            update.newValue.reset();
        }",41,,1804,winrt.Microsoft.Terminal.Control.implementation.TermControl._ScrollbarChangeHandler.<lambda>8,2,,cascadia\TerminalControl\TermControl.cpp:<global>
153750,METHOD_REF,2,,"[&](bool targetEnd) {
                    const auto flipMarker{ targetEnd ? markerData.EndAtRightBoundary : markerData.StartAtLeftBoundary };
                    const auto& marker{ targetEnd ? SelectionEndMarker() : SelectionStartMarker() };

                    // Ensure the marker is oriented properly
                    // (i.e. if start is at the beginning of the buffer, it should be flipped)
                    //
                    // Note - This RenderTransform might not be a
                    // ScaleTransform, if we haven't had a _coreFontSizeChanged
                    // handled yet, because that's the first place we set the
                    // RenderTransform
                    if (const auto& transform{ marker.RenderTransform().try_as<Windows::UI::Xaml::Media::ScaleTransform>() })
                    {
                        transform.ScaleX(std::abs(transform.ScaleX()) * (flipMarker ? -1.0 : 1.0));
                        marker.RenderTransform(transform);
  ...",38,,3287,TermControl._updateSelectionMarkers.<lambda>9,2,,cascadia\TerminalControl\TermControl.cpp:<global>
153951,METHOD_REF,2,,"[args, dpiScale{ SwapChainPanel().CompositionScaleX() }](const Windows::UI::Xaml::Shapes::Path& shape) {
            // The selection markers were designed to be 5x14 in size,
            // so use those dimensions below for the scaling
            const auto scaleX = args.Width() / 5.0 / dpiScale;
            const auto scaleY = args.Height() / 14.0 / dpiScale;

            Windows::UI::Xaml::Media::ScaleTransform transform;
            transform.ScaleX(scaleX);
            transform.ScaleY(scaleY);
            shape.RenderTransform(transform);

            // now hide the shape
            shape.Visibility(Visibility::Collapsed);
        }",28,,3374,TermControl._coreFontSizeChanged.<lambda>10,2,,cascadia\TerminalControl\TermControl.cpp:<global>
156831,METHOD_REF,3,,"[](wchar_t c) {
                        return (c < UNICODE_SPACE && c != UNICODE_NEWLINE) || c == 0x7F /*DEL*/;
                    }",72,,42,Sanitize.<lambda>0,4,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
156875,METHOD_REF,1,,"[this](auto&&, auto&&) { SignalSelectionChanged(); }",49,,82,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.TermControlAutomationPeer.<lambda>1,2,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
156880,METHOD_REF,1,,"[this](auto&&, auto&&) { SignalTextChanged(); }",44,,83,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.TermControlAutomationPeer.<lambda>2,2,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
156885,METHOD_REF,1,,"[this](auto&&, auto&&) { SignalCursorChanged(); }",46,,84,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.TermControlAutomationPeer.<lambda>3,2,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
156890,METHOD_REF,1,,"[this](auto&&, hstring newOutput) { NotifyNewOutput(newOutput); }",42,,85,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.TermControlAutomationPeer.<lambda>4,2,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
156985,METHOD_REF,2,,"[weakThis{ get_weak() }]() {
            if (auto strongThis{ weakThis.get() })
            {
                if (auto control{ strongThis->_termControl.get() })
                {
                    // The event that is raised when the text selection is modified.
                    strongThis->RaiseAutomationEvent(AutomationEvents::TextPatternOnTextSelectionChanged);
                }
            }
        }",80,,141,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.SignalSelectionChanged.<lambda>5,3,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
157019,METHOD_REF,2,,"[weakThis{ get_weak() }]() {
            if (auto strongThis{ weakThis.get() })
            {
                if (auto control{ strongThis->_termControl.get() })
                {
                    // The event that is raised when textual content is modified.
                    strongThis->RaiseAutomationEvent(AutomationEvents::TextPatternOnTextChanged);
                }
            }
        }",80,,167,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.SignalTextChanged.<lambda>6,3,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
157053,METHOD_REF,2,,"[weakThis{ get_weak() }]() {
            if (auto strongThis{ weakThis.get() })
            {
                if (auto control{ strongThis->_termControl.get() })
                {
                    // The event that is raised when the text was changed in an edit control.
                    // Do NOT fire a TextEditTextChanged. Generally, an app on the other side
                    //    will expect more information. Though you can dispatch that event
                    //    on its own, it may result in a nullptr exception on the other side
                    //    because no additional information was provided. Crashing the screen
                    //    reader.
                    strongThis->RaiseAutomationEvent(AutomationEvents::TextPatternOnTextSelectionChanged);
                }
            }
        }",80,,193,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.SignalCursorChanged.<lambda>7,3,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
157145,METHOD_REF,2,,"[weakThis{ get_weak() }, sanitizedCopy{ hstring{ sanitized } }]() {
            if (auto strongThis{ weakThis.get() })
            {
                if (auto control{ strongThis->_termControl.get() })
                {
                    try
                    {
                        strongThis->RaiseNotificationEvent(AutomationNotificationKind::ActionCompleted,
                                                           AutomationNotificationProcessing::All,
                                                           sanitizedCopy,
                                                           L""TerminalTextOutput"");
                    }
                    CATCH_LOG();
                }
            }
        }",80,,255,winrt.Microsoft.Terminal.Control.implementation.TermControlAutomationPeer.NotifyNewOutput.<lambda>8,3,,cascadia\TerminalControl\TermControlAutomationPeer.cpp:<global>
160286,METHOD_REF,1,,"[&](const PointTree::interval& interval) {
        const til::point startCoord{ interval.start.x, interval.start.y + vis };
        const til::point endCoord{ interval.stop.x, interval.stop.y + vis };
        _InvalidateFromCoords(startCoord, endCoord);
    }",36,,763,Terminal._InvalidatePatternTree.<lambda>0,2,,cascadia\TerminalCore\Terminal.cpp:<global>
161815,METHOD_REF,3,,"[](const auto& it, const auto& smallest) {
                return it.second.generation < smallest.second.generation;
            }",73,,1372,URegularExpressionInterner.Intern.<lambda>1,4,,URegularExpressionInterner
162220,METHOD_REF,2,,"[this](const til::point coordStart, const til::point coordEnd, const TextAttribute& attr) {
        auto& textBuffer = _activeBuffer();
        const auto spanLength = textBuffer.SpanLength(coordStart, coordEnd);
        textBuffer.Write(OutputCellIterator(attr, spanLength), coordStart);
    }",33,,1554,Terminal.ColorSelection.<lambda>2,2,,cascadia\TerminalCore\Terminal.cpp:<global>
165159,METHOD_REF,2,,"[&searchArea](const til::point pt) noexcept {
        auto copy = pt;
        searchArea.ConvertToOrigin(&copy);
        return copy;
    }",32,,419,Terminal.SelectHyperlink.<lambda>0,2,,cascadia\TerminalCore\TerminalSelection.cpp:<global>
165163,METHOD_REF,2,,"[&](std::vector<interval_tree::Interval<til::point, size_t>>& list) noexcept {
        const auto selectionStartInSearchArea = convertToSearchArea(_selection->start);

        std::optional<std::pair<til::point, til::point>> resultFromList;
        if (!list.empty())
        {
            if (dir == SearchDirection::Forward)
            {
                // pattern tree includes the currently selected range when going forward,
                // so we need to check if we're pointing to that one before returning it.
                auto range = list.front();
                if (_selectionIsTargetingUrl && range.start == selectionStartInSearchArea)
                {
                    if (list.size() > 1)
                    {
                        // if we're pointing to the currently selected URL,
                        // pick the next one.
                        range = til::at(list, 1);
                        resultFromList = { range.start, range.stop };
                   ...",34,,426,Terminal.SelectHyperlink.<lambda>1,2,,cascadia\TerminalCore\TerminalSelection.cpp:<global>
166426,METHOD_REF,2,,"[&](const auto& attr) {
        return _renderSettings.GetAttributeColors(attr);
    }",37,,844,Terminal.RetrieveSelectedTextFromBuffer.<lambda>2,2,,cascadia\TerminalCore\TerminalSelection.cpp:<global>
167258,METHOD_REF,1,,"[this](auto&&, const PropertyChangedEventArgs& args) {
            const auto viewModelProperty{ args.PropertyName() };
            if (viewModelProperty == L""CurrentKeys"")
            {
                _KeyChordText = KeyChordSerialization::ToString(_CurrentKeys);
                _NotifyChanges(L""KeyChordText"");
            }
            else if (viewModelProperty == L""IsContainerFocused"" ||
                     viewModelProperty == L""IsEditButtonFocused"" ||
                     viewModelProperty == L""IsHovered"" ||
                     viewModelProperty == L""IsAutomationPeerAttached"" ||
                     viewModelProperty == L""IsInEditMode"")
            {
                _NotifyChanges(L""ShowEditButton"");
            }
            else if (viewModelProperty == L""CurrentAction"")
            {
                _NotifyChanges(L""Name"");
            }
        }",25,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.KeyBindingViewModel.KeyBindingViewModel.<lambda>0,1,,cascadia\TerminalSettingsEditor\Actions.cpp:<global>
167886,METHOD_REF,2,,"[=]() {
            // If the key chord was changed,
            // update the settings model and view model appropriately
            // NOTE: we still need to update the view model if we're working with a newly added action
            if (isNewAction || args.OldKeys().Modifiers() != args.NewKeys().Modifiers() || args.OldKeys().Vkey() != args.NewKeys().Vkey())
            {
                if (!isNewAction)
                {
                    // update settings model
                    _State.Settings().ActionMap().RebindKeys(args.OldKeys(), args.NewKeys());
                }

                // update view model
                auto senderVMImpl{ get_self<KeyBindingViewModel>(senderVM) };
                senderVMImpl->CurrentKeys(args.NewKeys());
            }

            // If the action was changed,
            // update the settings model and view model appropriately
            // NOTE: no need to check for ""isNewAction"" here. <empty_string> != <action name> already.
    ...",44,,253,winrt.Microsoft.Terminal.Settings.Editor.implementation.Actions._ViewModelModifyKeyBindingHandler.<lambda>1,2,,cascadia\TerminalSettingsEditor\Actions.cpp:<global>
168032,METHOD_REF,1,,"[=](auto&, auto&) {
                    // remove conflicting key binding from list view
                    const auto containerIndex{ _GetContainerIndexByKeyChord(args.NewKeys()) };
                    _KeyBindingList.RemoveAt(*containerIndex);

                    // remove flyout
                    senderVM.AcceptChangesFlyout().Hide();
                    senderVM.AcceptChangesFlyout(nullptr);

                    // update settings model and view model
                    applyChangesToSettingsModel();
                    senderVM.ToggleEditMode();
                }",33,,311,winrt.Microsoft.Terminal.Settings.Editor.implementation.Actions._ViewModelModifyKeyBindingHandler.<lambda>2,2,,cascadia\TerminalSettingsEditor\Actions.cpp:<global>
169260,METHOD_REF,1,,"[this](auto&&, const PropertyChangedEventArgs& args) {
            const auto viewModelProperty{ args.PropertyName() };
            if (viewModelProperty == L""BackgroundImagePath"")
            {
                // notify listener that all background image related values might have changed
                //
                // We need to do this so if someone manually types ""desktopWallpaper""
                // into the path TextBox, we properly update the checkbox and stored
                // _lastBgImagePath. Without this, then we'll permanently hide the text
                // box, prevent it from ever being changed again.
                _NotifyChanges(L""UseDesktopBGImage"", L""BackgroundImageSettingsVisible"");
            }
        }",25,,51,winrt.Microsoft.Terminal.Settings.Editor.implementation.AppearanceViewModel.AppearanceViewModel.<lambda>0,1,,cascadia\TerminalSettingsEditor\Appearances.cpp:<global>
169613,METHOD_REF,2,,CursorShapeList,9,,231,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.CursorShapeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169691,METHOD_REF,1,,CursorShapeList,9,,231,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.CursorShapeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169706,METHOD_REF,1,,CursorShapeList,9,,231,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.CursorShapeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169710,METHOD_REF,1,,CursorShapeList,9,,231,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.CursorShapeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169736,METHOD_REF,1,,CursorShapeList,9,,231,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.CursorShapeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169763,METHOD_REF,2,,AdjustIndistinguishableColorsList,9,,232,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.AdjustIndistinguishableColorsList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169841,METHOD_REF,1,,AdjustIndistinguishableColorsList,9,,232,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.AdjustIndistinguishableColorsList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169856,METHOD_REF,1,,AdjustIndistinguishableColorsList,9,,232,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.AdjustIndistinguishableColorsList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169860,METHOD_REF,1,,AdjustIndistinguishableColorsList,9,,232,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.AdjustIndistinguishableColorsList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169886,METHOD_REF,1,,AdjustIndistinguishableColorsList,9,,232,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.AdjustIndistinguishableColorsList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169913,METHOD_REF,2,,BackgroundImageStretchModeList,9,,233,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.BackgroundImageStretchModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
169993,METHOD_REF,1,,BackgroundImageStretchModeList,9,,233,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.BackgroundImageStretchModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170008,METHOD_REF,1,,BackgroundImageStretchModeList,9,,233,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.BackgroundImageStretchModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170012,METHOD_REF,1,,BackgroundImageStretchModeList,9,,233,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.BackgroundImageStretchModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170038,METHOD_REF,1,,BackgroundImageStretchModeList,9,,233,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.BackgroundImageStretchModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170385,METHOD_REF,2,,IntenseTextStyleList,9,,274,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.IntenseTextStyleList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170465,METHOD_REF,1,,IntenseTextStyleList,9,,274,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.IntenseTextStyleList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170480,METHOD_REF,1,,IntenseTextStyleList,9,,274,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.IntenseTextStyleList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170484,METHOD_REF,1,,IntenseTextStyleList,9,,274,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.IntenseTextStyleList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170510,METHOD_REF,1,,IntenseTextStyleList,9,,274,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances.IntenseTextStyleList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
170713,METHOD_REF,2,,"[=](auto&&, const PropertyChangedEventArgs& args) {
                const auto settingName{ args.PropertyName() };
                if (settingName == L""CursorShape"")
                {
                    _PropertyChangedHandlers(*this, PropertyChangedEventArgs{ L""CurrentCursorShape"" });
                    _PropertyChangedHandlers(*this, PropertyChangedEventArgs{ L""IsVintageCursor"" });
                }
                else if (settingName == L""DarkColorSchemeName"" || settingName == L""LightColorSchemeName"")
                {
                    _PropertyChangedHandlers(*this, PropertyChangedEventArgs{ L""CurrentColorScheme"" });
                }
                else if (settingName == L""BackgroundImageStretchMode"")
                {
                    _PropertyChangedHandlers(*this, PropertyChangedEventArgs{ L""CurrentBackgroundImageStretchMode"" });
                }
                else if (settingName == L""BackgroundImageAlignment"")
                {
                    _UpdateBIAl...",89,,351,winrt.Microsoft.Terminal.Settings.Editor.implementation.Appearances._UpdateWithNewViewModel.<lambda>1,3,,cascadia\TerminalSettingsEditor\Appearances.cpp:<global>
173453,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            ColorSchemeListView().Focus(FocusState::Programmatic);
        }",67,,41,winrt.Microsoft.Terminal.Settings.Editor.implementation.ColorSchemes.OnNavigatedTo.<lambda>0,2,,cascadia\TerminalSettingsEditor\ColorSchemes.cpp:<global>
175353,METHOD_REF,2,,NewTabPositionList,9,,54,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.NewTabPositionList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175423,METHOD_REF,1,,NewTabPositionList,9,,54,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.NewTabPositionList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175438,METHOD_REF,1,,NewTabPositionList,9,,54,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.NewTabPositionList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175442,METHOD_REF,1,,NewTabPositionList,9,,54,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.NewTabPositionList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175467,METHOD_REF,1,,NewTabPositionList,9,,54,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.NewTabPositionList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175494,METHOD_REF,2,,TabWidthModeList,9,,55,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.TabWidthModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175574,METHOD_REF,1,,TabWidthModeList,9,,55,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.TabWidthModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175589,METHOD_REF,1,,TabWidthModeList,9,,55,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.TabWidthModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175593,METHOD_REF,1,,TabWidthModeList,9,,55,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.TabWidthModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175619,METHOD_REF,1,,TabWidthModeList,9,,55,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.TabWidthModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
175738,METHOD_REF,3,,"[](const winrt::hstring& tag) -> bool {
                    return til::starts_with(tag, L""qps-"");
                }",52,,147,winrt.Microsoft.Terminal.Settings.Editor.implementation.GlobalAppearanceViewModel.LanguageList.<lambda>0,4,,cascadia\TerminalSettingsEditor\GlobalAppearanceViewModel.cpp:<global>
176655,METHOD_REF,2,,TabSwitcherModeList,9,,18,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.TabSwitcherModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176725,METHOD_REF,1,,TabSwitcherModeList,9,,18,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.TabSwitcherModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176740,METHOD_REF,1,,TabSwitcherModeList,9,,18,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.TabSwitcherModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176744,METHOD_REF,1,,TabSwitcherModeList,9,,18,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.TabSwitcherModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176769,METHOD_REF,1,,TabSwitcherModeList,9,,18,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.TabSwitcherModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176796,METHOD_REF,2,,CopyFormatList,9,,19,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.CopyFormatList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176874,METHOD_REF,1,,CopyFormatList,9,,19,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.CopyFormatList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176889,METHOD_REF,1,,CopyFormatList,9,,19,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.CopyFormatList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176893,METHOD_REF,1,,CopyFormatList,9,,19,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.CopyFormatList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
176919,METHOD_REF,1,,CopyFormatList,9,,19,winrt.Microsoft.Terminal.Settings.Editor.implementation.InteractionViewModel.CopyFormatList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178038,METHOD_REF,2,,FirstWindowPreferenceList,9,,22,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.FirstWindowPreferenceList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178108,METHOD_REF,1,,FirstWindowPreferenceList,9,,22,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.FirstWindowPreferenceList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178123,METHOD_REF,1,,FirstWindowPreferenceList,9,,22,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.FirstWindowPreferenceList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178127,METHOD_REF,1,,FirstWindowPreferenceList,9,,22,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.FirstWindowPreferenceList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178152,METHOD_REF,1,,FirstWindowPreferenceList,9,,22,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.FirstWindowPreferenceList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178339,METHOD_REF,2,,WindowingBehaviorList,9,,29,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.WindowingBehaviorList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178409,METHOD_REF,1,,WindowingBehaviorList,9,,29,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.WindowingBehaviorList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178424,METHOD_REF,1,,WindowingBehaviorList,9,,29,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.WindowingBehaviorList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178428,METHOD_REF,1,,WindowingBehaviorList,9,,29,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.WindowingBehaviorList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178453,METHOD_REF,1,,WindowingBehaviorList,9,,29,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.WindowingBehaviorList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
178456,METHOD_REF,1,,"[this](auto&&, const PropertyChangedEventArgs& args) {
            const auto viewModelProperty{ args.PropertyName() };
            if (viewModelProperty == L""CenterOnLaunch"")
            {
                _NotifyChanges(L""LaunchParametersCurrentValue"");
            }
        }",25,,34,winrt.Microsoft.Terminal.Settings.Editor.implementation.LaunchViewModel.LaunchViewModel.<lambda>0,1,,cascadia\TerminalSettingsEditor\LaunchViewModel.cpp:<global>
179927,METHOD_REF,2,,"[=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentScheme = _colorSchemesPageVM.CurrentScheme();
                if (_colorSchemesPageVM.CurrentPage() == ColorSchemesSubPage::EditColorScheme && currentScheme)
                {
                    contentFrame().Navigate(xaml_typename<Editor::EditColorScheme>(), currentScheme);
                    const auto crumb = winrt::make<Breadcrumb>(box_value(colorSchemesTag), currentScheme.Name(), BreadcrumbSubPage::ColorSchemes_Edit);
                    _breadcrumbs.Append(crumb);
                }
                else if (_colorSchemesPageVM.CurrentPage() == ColorSchemesSubPage::Base)
                {
                    _Navigate(winrt::hstring{ colorSchemesTag }, BreadcrumbSubPage::None);
                }
            }
            else if (settingName == L""CurrentSchemeName"")
       ...",108,,63,winrt.Microsoft.Terminal.Settings.Editor.implementation.MainPage.MainPage.<lambda>0,3,,cascadia\TerminalSettingsEditor\MainPage.cpp:<global>
180455,METHOD_REF,2,,"[=](auto&&, const PropertyChangedEventArgs& args) {
            const auto settingName{ args.PropertyName() };
            if (settingName == L""CurrentPage"")
            {
                const auto currentPage = profile.CurrentPage();
                if (currentPage == ProfileSubPage::Base)
                {
                    contentFrame().Navigate(xaml_typename<Editor::Profiles_Base>(), winrt::make<implementation::NavigateToProfileArgs>(profile, *this));
                    _breadcrumbs.Clear();
                    const auto crumb = winrt::make<Breadcrumb>(breadcrumbTag, breadcrumbText, BreadcrumbSubPage::None);
                    _breadcrumbs.Append(crumb);
                }
                else if (currentPage == ProfileSubPage::Appearance)
                {
                    contentFrame().Navigate(xaml_typename<Editor::Profiles_Appearance>(), winrt::make<implementation::NavigateToProfileArgs>(profile, *this));
                    const auto crumb = winrt::make<Breadcrum...",87,,318,winrt.Microsoft.Terminal.Settings.Editor.implementation.MainPage._SetupProfileEventHandling.<lambda>1,3,,cascadia\TerminalSettingsEditor\MainPage.cpp:<global>
181435,METHOD_REF,1,,"[weakMenuItem](const auto&, const WUX::Data::PropertyChangedEventArgs& args) {
            if (auto menuItem{ weakMenuItem.get() })
            {
                const auto& tag{ menuItem.Tag().as<Editor::ProfileViewModel>() };
                if (args.PropertyName() == L""Icon"")
                {
                    menuItem.Icon(IconPathConverter::IconWUX(tag.Icon()));
                }
                else if (args.PropertyName() == L""Name"")
                {
                    menuItem.Content(box_value(tag.Name()));
                }
            }
        }",33,,602,winrt.Microsoft.Terminal.Settings.Editor.implementation.MainPage._CreateProfileNavViewItem.<lambda>2,2,,cascadia\TerminalSettingsEditor\MainPage.cpp:<global>
182291,METHOD_REF,2,,AntiAliasingModeList,9,,36,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.AntiAliasingModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182369,METHOD_REF,1,,AntiAliasingModeList,9,,36,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.AntiAliasingModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182384,METHOD_REF,1,,AntiAliasingModeList,9,,36,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.AntiAliasingModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182388,METHOD_REF,1,,AntiAliasingModeList,9,,36,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.AntiAliasingModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182414,METHOD_REF,1,,AntiAliasingModeList,9,,36,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.AntiAliasingModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182441,METHOD_REF,2,,CloseOnExitModeList,9,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.CloseOnExitModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182521,METHOD_REF,1,,CloseOnExitModeList,9,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.CloseOnExitModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182536,METHOD_REF,1,,CloseOnExitModeList,9,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.CloseOnExitModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182540,METHOD_REF,1,,CloseOnExitModeList,9,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.CloseOnExitModeList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182566,METHOD_REF,1,,CloseOnExitModeList,9,,37,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.CloseOnExitModeList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182593,METHOD_REF,2,,ScrollStateList,9,,38,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ScrollStateList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182671,METHOD_REF,1,,ScrollStateList,9,,38,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ScrollStateList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182686,METHOD_REF,1,,ScrollStateList,9,,38,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ScrollStateList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182690,METHOD_REF,1,,ScrollStateList,9,,38,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ScrollStateList,1,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182716,METHOD_REF,1,,ScrollStateList,9,,38,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ScrollStateList,2,,IObservableVector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>
182719,METHOD_REF,1,,"[this](auto&&, const PropertyChangedEventArgs& args) {
            const auto viewModelProperty{ args.PropertyName() };
            if (viewModelProperty == L""IsBaseLayer"")
            {
                // we _always_ want to show the background image settings in base layer
                _NotifyChanges(L""BackgroundImageSettingsVisible"");
            }
            else if (viewModelProperty == L""StartingDirectory"")
            {
                // notify listener that all starting directory related values might have changed
                // NOTE: this is similar to what is done with BackgroundImagePath above
                _NotifyChanges(L""UseParentProcessDirectory"", L""UseCustomStartingDirectory"");
            }
            else if (viewModelProperty == L""AntialiasingMode"")
            {
                _NotifyChanges(L""CurrentAntiAliasingMode"");
            }
            else if (viewModelProperty == L""CloseOnExit"")
            {
                _NotifyChanges(L""CurrentCloseOnE...",25,,43,winrt.Microsoft.Terminal.Settings.Editor.implementation.ProfileViewModel.ProfileViewModel.<lambda>0,1,,cascadia\TerminalSettingsEditor\ProfileViewModel.cpp:<global>
186286,METHOD_REF,2,,"[this](auto /*s*/, auto /*e*/) {
            // This event fires every time the layout changes, but it is always the last one to fire
            // in any layout change chain. That gives us great flexibility in finding the right point
            // at which to initialize our renderer (and our terminal).
            // Any earlier than the last layout update and we may not know the terminal's starting size.

            // Only let this succeed once.
            _layoutUpdatedRevoker.revoke();

            if (_Profile.FocusDeleteButton())
            {
                DeleteButton().Focus(FocusState::Programmatic);
                _Profile.FocusDeleteButton(false);
                ProfilesBase_ScrollView().ChangeView(nullptr, ProfilesBase_ScrollView().ScrollableHeight(), nullptr);
            }
        }",67,,42,winrt.Microsoft.Terminal.Settings.Editor.implementation.Profiles_Base.OnNavigatedTo.<lambda>0,2,,cascadia\TerminalSettingsEditor\Profiles_Base.cpp:<global>
186389,METHOD_REF,2,,"[](auto&& dialog) {
            THROW_IF_FAILED(dialog->SetClientGuid(clientGuidExecutables));
            try
            {
                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };
                dialog->SetDefaultFolder(folderShellItem.get());
            }
            CATCH_LOG(); // non-fatal
            THROW_IF_FAILED(dialog->SetFileTypes(ARRAYSIZE(supportedFileTypes), supportedFileTypes));
            THROW_IF_FAILED(dialog->SetFileTypeIndex(1)); // the array is 1-indexed
            THROW_IF_FAILED(dialog->SetDefaultExtension(L""exe;cmd;bat""));
        }",57,,91,winrt.Microsoft.Terminal.Settings.Editor.implementation.Profiles_Base.Commandline_Click.<lambda>1,2,,cascadia\TerminalSettingsEditor\Profiles_Base.cpp:<global>
186468,METHOD_REF,2,,"[](auto&& dialog) {
            static constexpr winrt::guid clientGuidFolderPicker{ 0xAADAA433, 0xB04D, 0x4BAE, { 0xB1, 0xEA, 0x1E, 0x6C, 0xD1, 0xCD, 0xA6, 0x8B } };
            THROW_IF_FAILED(dialog->SetClientGuid(clientGuidFolderPicker));
            try
            {
                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };
                dialog->SetDefaultFolder(folderShellItem.get());
            }
            CATCH_LOG(); // non-fatal

            DWORD flags{};
            THROW_IF_FAILED(dialog->GetOptions(&flags));
            THROW_IF_FAILED(dialog->SetOptions(flags | FOS_PICKFOLDERS)); // folders only
        }",59,,126,winrt.Microsoft.Terminal.Settings.Editor.implementation.Profiles_Base.StartingDirectory_Click.<lambda>2,2,,cascadia\TerminalSettingsEditor\Profiles_Base.cpp:<global>
187122,METHOD_REF,1,,"[=](auto&&, auto&&) {
                    _ClearSettingValueHandlers(*this, nullptr);

                    // move the focus to the child control
                    if (const auto& content{ Content() })
                    {
                        if (const auto& control{ content.try_as<Controls::Control>() })
                        {
                            control.Focus(FocusState::Programmatic);
                            return;
                        }
                        else if (const auto& panel{ content.try_as<Controls::Panel>() })
                        {
                            for (const auto& panelChild : panel.Children())
                            {
                                if (const auto& panelControl{ panelChild.try_as<Controls::Control>() })
                                {
                                    panelControl.Focus(FocusState::Programmatic);
                                    return;
                                }
       ...",30,,102,winrt.Microsoft.Terminal.Settings.Editor.implementation.SettingContainer.OnApplyTemplate.<lambda>0,2,,cascadia\TerminalSettingsEditor\SettingContainer.cpp:<global>
190814,METHOD_REF,0,,"[]() {
            return std::unordered_map<ShortcutAction, winrt::hstring>{
                { ShortcutAction::AdjustFontSize, RS_(L""AdjustFontSizeCommandKey"") },
                { ShortcutAction::CloseOtherPanes, RS_(L""CloseOtherPanesCommandKey"") },
                { ShortcutAction::CloseOtherTabs, MustGenerate },
                { ShortcutAction::ClosePane, RS_(L""ClosePaneCommandKey"") },
                { ShortcutAction::CloseTab, MustGenerate },
                { ShortcutAction::CloseTabsAfter, MustGenerate },
                { ShortcutAction::CloseWindow, RS_(L""CloseWindowCommandKey"") },
                { ShortcutAction::CopyText, RS_(L""CopyTextCommandKey"") },
                { ShortcutAction::DuplicateTab, RS_(L""DuplicateTabCommandKey"") },
                { ShortcutAction::ExecuteCommandline, RS_(L""ExecuteCommandlineCommandKey"") },
                { ShortcutAction::Find, RS_(L""FindCommandKey"") },
                { ShortcutAction::Invalid, MustGenerate },
                { Shor...",50,,345,winrt.Microsoft.Terminal.Settings.Model.implementation.ActionAndArgs.GenerateName.<lambda>0,1,,cascadia\TerminalSettingsModel\ActionAndArgs.cpp:<global>
205990,METHOD_REF,4,,"[](std::pair<InternalActionID, Model::Command> actionPair) {
            return actionPair.second;
        }",111,,270,winrt.Microsoft.Terminal.Settings.Model.implementation.ActionMap._GetCumulativeActions.<lambda>0,5,,cascadia\TerminalSettingsModel\ActionMap.cpp:<global>
206008,METHOD_REF,4,,"[](std::pair<InternalActionID, Model::Command> actionPair) {
            return actionPair.second;
        }",101,,273,winrt.Microsoft.Terminal.Settings.Model.implementation.ActionMap._GetCumulativeActions.<lambda>1,5,,cascadia\TerminalSettingsModel\ActionMap.cpp:<global>
207260,METHOD_REF,3,,_compareSchemeNames,19,,910,winrt.Microsoft.Terminal.Settings.Model.implementation._compareSchemeNames,4,,bool
207345,METHOD_REF,2,,"[&](const Model::Command& command) -> Model::Command {
            winrt::com_ptr<implementation::Command> cmdImpl;
            cmdImpl.copy_from(winrt::get_self<implementation::Command>(command));

            const auto inArgs{ command.ActionAndArgs().Args().try_as<Model::SendInputArgs>() };

            auto args = winrt::make_self<SendInputArgs>(
                winrt::hstring{ fmt::format(FMT_COMPILE(L""{:\x7f^{}}{}""),
                                            L"""",
                                            numBackspaces,
                                            (std::wstring_view)(inArgs ? inArgs.Input() : L"""")) });
            Model::ActionAndArgs actionAndArgs{ ShortcutAction::SendInput, *args };

            auto copy = cmdImpl->Copy();
            copy->ActionAndArgs(actionAndArgs);

            return *copy;
        }",34,,943,winrt.Microsoft.Terminal.Settings.Model.implementation._filterToSendInput.<lambda>2,2,,cascadia\TerminalSettingsModel\ActionMap.cpp:<global>
207816,METHOD_REF,2,,"[&actionList](const Model::Command& cmd) {
            const auto cmdImpl{ winrt::get_self<implementation::Command>(cmd) };
            const auto& cmdJsonArray{ cmdImpl->ToJson() };
            for (const auto& cmdJson : cmdJsonArray)
            {
                actionList.append(cmdJson);
            }
        }",23,,70,winrt.Microsoft.Terminal.Settings.Model.implementation.ActionMap.ToJson.<lambda>0,2,,cascadia\TerminalSettingsModel\ActionMapSerialization.cpp:<global>
212427,METHOD_REF,3,,"[](const auto& lhs, const auto& rhs) {
            return lhs.first.size() > rhs.first.size();
        }",80,,677,CascadiaSettings._getProfileForCommandLine..<lambda>3,4,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
212493,METHOD_REF,1,,"[&]() {
            latch.count_down();
        }",46,,1187,CascadiaSettings._refreshDefaultTerminals..<lambda>7,2,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
212955,METHOD_REF,3,,[&](auto&& profile) { return profile.Name() == newName; },66,,219,CascadiaSettings.CreateNewProfile.<lambda>0,4,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
213068,METHOD_REF,3,,[&](auto&& profile) { return profile.Name() == newName; },66,,264,CascadiaSettings.DuplicateProfile.<lambda>1,4,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
214707,METHOD_REF,2,,"[this]() {
        _commandLinesCache.reserve(_allProfiles.Size());

        for (const auto& profile : _allProfiles)
        {
            if (profile.ConnectionType() != winrt::guid{})
            {
                continue;
            }

            const auto cmd = profile.Commandline();
            if (cmd.empty())
            {
                continue;
            }

            try
            {
                _commandLinesCache.emplace_back(NormalizeCommandLine(cmd.c_str()), profile);
            }
            CATCH_LOG()
        }

        // We're trying to find the command line with the longest common prefix below.
        // Given the commandLine ""foo.exe -bar -baz"" and these two user profiles:
        // * ""foo.exe""
        // * ""foo.exe -bar""
        // we want to choose the second one. By sorting the _commandLinesCache in a descending order
        // by command line length, we can return from this function the moment we found a matching
        // profile as there...",44,,647,CascadiaSettings._getProfileForCommandLine.<lambda>2,3,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
214738,METHOD_REF,4,,"[&](const auto& lhs, const auto& rhs) {
            return lhs.first.size() > rhs.size();
        }",77,,689,CascadiaSettings._getProfileForCommandLine.<lambda>4,5,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
215452,METHOD_REF,0,,"[] {
        wil::unique_hkey key;
        const auto lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                           L""SOFTWARE\\Microsoft\\SystemSettings\\SettingId\\SystemSettings_Developer_Mode_Setting_DefaultTerminalApp"",
                                           0,
                                           KEY_READ,
                                           &key);
        return static_cast<bool>(key) && ERROR_SUCCESS == lResult;
    }",40,,1116,CascadiaSettings.IsDefaultTerminalAvailable.<lambda>5,1,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
215508,METHOD_REF,0,,"[&]() -> winrt::fire_and_forget {
        const auto cleanup = wil::scope_exit([&]() {
            latch.count_down();
        });
        co_await winrt::resume_background();
        result = DefaultTerminal::Available();
    }",19,,1186,CascadiaSettings._refreshDefaultTerminals.<lambda>6,1,,cascadia\TerminalSettingsModel\CascadiaSettings.cpp:<global>
216209,METHOD_REF,1,,"[&]() {
            latch.count_down();
        }",46,,88,extractValueFromTaskWithoutMainThreadAwait..<lambda>1,2,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>
216479,METHOD_REF,0,,"[&]() -> winrt::fire_and_forget {
        const auto cleanup = wil::scope_exit([&]() {
            latch.count_down();
        });
        co_await winrt::resume_background();
        finalVal.emplace(co_await task);
    }",20,,87,extractValueFromTaskWithoutMainThreadAwait.<lambda>0,1,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>
216723,METHOD_REF,2,,"[&](const std::filesystem::path& path, const winrt::hstring& source) {
        for (const auto& fragmentExt : std::filesystem::directory_iterator{ path })
        {
            if (fragmentExt.path().extension() == jsonExtension)
            {
                try
                {
                    const auto content = ReadUTF8File(fragmentExt.path());
                    _parseFragment(source, content, fragmentSettings);
                }
                CATCH_LOG();
            }
        }
    }",45,,232,SettingsLoader.FindFragmentsAndMergeIntoUserSettings.<lambda>2,2,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>
218218,METHOD_REF,2,,"[&]() {
            auto totalSendInput = 0;
            const auto& allActions = GlobalSettings().ActionMap().AvailableActions();
            for (const auto&& [name, actionAndArgs] : allActions)
            {
                if (actionAndArgs.Action() == ShortcutAction::SendInput)
                {
                    totalSendInput++;
                }
            }
            return totalSendInput;
        }",33,,983,CascadiaSettings._researchOnLoad.<lambda>3,2,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>
218396,METHOD_REF,3,,[&](const auto& parent) { return parent->Source() == source; },62,,1072,CascadiaSettings.CascadiaSettings.<lambda>4,4,,cascadia\TerminalSettingsModel\CascadiaSettingsSerialization.cpp:<global>
220577,METHOD_REF,3,,"[&keys](const Control::KeyChord& iterKey) {
                               return keys.Modifiers() == iterKey.Modifiers() && keys.Vkey() == iterKey.Vkey();
                           }",85,,160,winrt.Microsoft.Terminal.Settings.Model.implementation.Command.EraseKey.<lambda>0,4,,cascadia\TerminalSettingsModel\Command.cpp:<global>
221348,METHOD_REF,2,,"[&](const auto& newJsonString) -> bool {
            // - Now, re-parse the modified value.
            Json::Value newJsonValue;
            const auto actualDataStart = newJsonString.data();
            const auto actualDataEnd = newJsonString.data() + newJsonString.size();
            if (!reader->parse(actualDataStart, actualDataEnd, &newJsonValue, &errs))
            {
                // If we encounter a re-parsing error, just stop processing the rest of the commands.
                return false;
            }

            // Pass the new json back though FromJson, to get the new expanded value.
            // FromJson requires that we pass in a vector to hang on to the
            // warnings, but ultimately, we don't care about warnings during
            // expansion.
            std::vector<SettingsLoadWarnings> unused;
            if (auto newCmd{ Command::FromJson(newJsonValue, unused) })
            {
                newCommands.push_back(*newCmd);
            }
      ...",28,,566,winrt.Microsoft.Terminal.Settings.Model.implementation.Command._expandCommand.<lambda>1,2,,cascadia\TerminalSettingsModel\Command.cpp:<global>
221533,METHOD_REF,2,,"[&](const auto& element) {
            winrt::hstring completionText;
            winrt::hstring listText;
            JsonUtils::GetValueForKey(element, ""CompletionText"", completionText);
            JsonUtils::GetValueForKey(element, ""ListItemText"", listText);

            auto args = winrt::make_self<SendInputArgs>(
                winrt::hstring{ fmt::format(FMT_COMPILE(L""{:\x7f^{}}{}""),
                                            L"""",
                                            replaceLength,
                                            static_cast<std::wstring_view>(completionText)) });

            Model::ActionAndArgs actionAndArgs{ ShortcutAction::SendInput, *args };

            auto c = winrt::make_self<Command>();
            c->_name = listText;
            c->_ActionAndArgs = actionAndArgs;

            // Try to assign a sensible icon based on the result type. These are
            // roughly chosen to align with the icons in
            // https://github.com/PowerShel...",35,,664,winrt.Microsoft.Terminal.Settings.Model.implementation.Command.ParsePowerShellMenuComplete.<lambda>2,2,,cascadia\TerminalSettingsModel\Command.cpp:<global>
223001,METHOD_REF,0,,"DEFINE_ENUM_MAP(winrt::Windows::UI::Xaml::ElementTheme, ElementTheme)",5,,33,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.ElementTheme.<lambda>0,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223012,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::NewTabPosition, NewTabPosition)",5,,34,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.NewTabPosition.<lambda>1,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223023,METHOD_REF,0,,"DEFINE_ENUM_MAP(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode, TabViewWidthMode)",5,,35,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.TabViewWidthMode.<lambda>2,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223034,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::FirstWindowPreference, FirstWindowPreference)",5,,36,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.FirstWindowPreference.<lambda>3,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223045,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::LaunchMode, LaunchMode)",5,,37,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.LaunchMode.<lambda>4,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223056,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::TabSwitcherMode, TabSwitcherMode)",5,,38,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.TabSwitcherMode.<lambda>5,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223067,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Control::CopyFormat, CopyFormat)",5,,39,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.CopyFormat.<lambda>6,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223078,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::WindowingMode, WindowingMode)",5,,40,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.WindowingMode.<lambda>7,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223089,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Core::MatchMode, MatchMode)",5,,41,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.MatchMode.<lambda>8,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223100,METHOD_REF,0,,"DEFINE_ENUM_MAP(Model::CloseOnExitMode, CloseOnExitMode)",5,,44,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.CloseOnExitMode.<lambda>9,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223111,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Control::ScrollbarState, ScrollbarState)",5,,45,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.ScrollbarState.<lambda>10,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223122,METHOD_REF,0,,"DEFINE_ENUM_MAP(Windows::UI::Xaml::Media::Stretch, BackgroundImageStretchMode)",5,,46,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.BackgroundImageStretchMode.<lambda>11,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223133,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Control::TextAntialiasingMode, TextAntialiasingMode)",5,,47,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.TextAntialiasingMode.<lambda>12,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223144,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Core::CursorStyle, CursorStyle)",5,,48,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.CursorStyle.<lambda>13,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223155,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Settings::Model::IntenseStyle, IntenseTextStyle)",5,,49,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.IntenseTextStyle.<lambda>14,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223166,METHOD_REF,0,,"DEFINE_ENUM_MAP(Microsoft::Terminal::Core::AdjustTextMode, AdjustIndistinguishableColors)",5,,50,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.AdjustIndistinguishableColors.<lambda>15,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223177,METHOD_REF,0,,"[]() {
            auto map = single_threaded_map<winrt::hstring, uint16_t>();
            for (auto [enumStr, enumVal] : JsonUtils::ConversionTrait<Windows::UI::Text::FontWeight>::mappings)
            {
                map.Insert(winrt::to_hstring(enumStr), enumVal);
            }
            return map;
        }",31,,56,winrt.Microsoft.Terminal.Settings.Model.implementation.EnumMappings.FontWeight.<lambda>16,1,,cascadia\TerminalSettingsModel\EnumMappings.cpp:<global>
223473,METHOD_REF,0,,"[]() {
            std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
            modulePath.replace_filename(PortableModeMarkerFile);
            return std::filesystem::exists(modulePath);
        }",36,,27,winrt.Microsoft.Terminal.Settings.Model.IsPortableMode.<lambda>0,1,,cascadia\TerminalSettingsModel\FileUtils.cpp:<global>
223484,METHOD_REF,0,,"[]() {
            if (!IsPackaged() && IsPortableMode())
            {
                std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
                modulePath.replace_filename(PortableModeSettingsFolder);
                std::filesystem::create_directories(modulePath);
                return modulePath;
            }

            wil::unique_cotaskmem_string localAppDataFolder;
            // KF_FLAG_FORCE_APP_DATA_REDIRECTION, when engaged, causes SHGet... to return
            // the new AppModel paths (Packages/xxx/RoamingState, etc.) for standard path requests.
            // Using this flag allows us to avoid Windows.Storage.ApplicationData completely.
            THROW_IF_FAILED(SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_FORCE_APP_DATA_REDIRECTION, nullptr, &localAppDataFolder));

            std::filesystem::path parentDirectoryForSettingsFile{ localAppDataFolder.get() };

            if (!IsPackaged())
 ...",40,,37,winrt.Microsoft.Terminal.Settings.Model.GetBaseSettingsPath.<lambda>1,1,,cascadia\TerminalSettingsModel\FileUtils.cpp:<global>
223495,METHOD_REF,0,,"[]() {
            wil::unique_cotaskmem_string localAppDataFolder;
            // We're using KF_FLAG_NO_PACKAGE_REDIRECTION to ensure that we always get the
            // user's actual local AppData directory.
            THROW_IF_FAILED(SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_NO_PACKAGE_REDIRECTION, nullptr, &localAppDataFolder));

            // Returns a path like C:\Users\<username>\AppData\Local
            std::filesystem::path parentDirectoryForSettingsFile{ localAppDataFolder.get() };

            //Appending \Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState to the settings path
            parentDirectoryForSettingsFile /= ReleaseSettingsFolder;

            if (!IsPackaged())
            {
                parentDirectoryForSettingsFile /= UnpackagedSettingsFolderName;
            }

            return parentDirectoryForSettingsFile;
        }",57,,71,winrt.Microsoft.Terminal.Settings.Model.GetReleaseSettingsPath.<lambda>2,1,,cascadia\TerminalSettingsModel\FileUtils.cpp:<global>
235541,METHOD_REF,3,,[trait](const auto& json) mutable -> bool { return trait.CanConvert(json); },77,,389,"json.isArray() && std.all_of(json.begin(), json.end(), [trait](const auto& json) mutable -> bool { return trait.CanConvert(json); }).<lambda>0",4,,Microsoft.Terminal.Settings.Model.JsonUtils.ConversionTrait<std.vector<T>>
235642,METHOD_REF,3,,[trait](const auto& json) mutable -> bool { return trait.CanConvert(json); },76,,430,Microsoft.Terminal.Settings.Model.JsonUtils.ConversionTrait<std.unordered_set<T>>.CanConvert.<lambda>1,4,,Microsoft.Terminal.Settings.Model.JsonUtils.ConversionTrait<std.unordered_set<T>>
236311,METHOD_REF,4,,[](auto&& p) { return p.first; },105,,981,Microsoft.Terminal.Settings.Model.JsonUtils.EnumMapper.TypeDescription.<lambda>2,5,,Microsoft.Terminal.Settings.Model.JsonUtils.EnumMapper
238320,METHOD_REF,2,,[&initialPosition](int32_t left) { initialPosition.X = left; },9,,68,LaunchPositionFromString.<lambda>0,2,,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp:<global>
238321,METHOD_REF,3,,[&initialPosition](int32_t right) { initialPosition.Y = right; },9,,69,LaunchPositionFromString.<lambda>1,3,,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp:<global>
238334,METHOD_REF,2,,[&size](int32_t left) { size.width = left; },9,,79,SizeFromString.<lambda>2,2,,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp:<global>
238335,METHOD_REF,3,,[&size](int32_t right) { size.height = right; },9,,80,SizeFromString.<lambda>3,3,,cascadia\TerminalSettingsModel\ModelSerializationHelpers.hpp:<global>
246749,METHOD_REF,4,,"[](auto&& color) {
                return static_cast<winrt::Microsoft::Terminal::Core::Color>(til::color{ color });
            }",78,,399,winrt.Microsoft.Terminal.Settings.Model.implementation.TerminalSettings.ApplyColorScheme.<lambda>0,5,,cascadia\TerminalSettingsModel\TerminalSettings.cpp:<global>
246842,METHOD_REF,4,,"[](auto&& color) {
                return static_cast<winrt::Microsoft::Terminal::Core::Color>(til::color{ color });
            }",90,,427,winrt.Microsoft.Terminal.Settings.Model.implementation.TerminalSettings.ColorTable.<lambda>1,5,,cascadia\TerminalSettingsModel\TerminalSettings.cpp:<global>
256465,METHOD_REF,2,,"[](const winrt::Windows::UI::Color& clr) -> bool {
        return (((5 * clr.G) + (2 * clr.R) + clr.B) > (8 * 128));
    }",32,,370,Theme.IsSystemInDarkTheme.<lambda>0,2,,cascadia\TerminalSettingsModel\Theme.cpp:<global>
257274,METHOD_REF,3,,"[](const VsSetupInstance& a, const VsSetupInstance& b) {
        const auto aVersion = a.GetComparableVersion();
        const auto bVersion = b.GetComparableVersion();

        if (aVersion == bVersion)
        {
            return a.GetComparableInstallDate() > b.GetComparableInstallDate();
        }

        return aVersion > bVersion;
    }",51,,30,VsSetupConfiguration.QueryInstances.<lambda>0,4,,cascadia\TerminalSettingsModel\VsSetupConfiguration.cpp:<global>
258422,METHOD_REF,2,,"[&](PWSTR value, size_t valueLength, size_t* valueLengthNeededWithNull) -> HRESULT {
            auto length = gsl::narrow<DWORD>(valueLength * sizeof(wchar_t));
            const auto status = RegQueryValueExW(distroKey.get(), RegKeyDistroName, 0, nullptr, reinterpret_cast<BYTE*>(value), &length);
            // length will receive the number of bytes including trailing null byte. Convert to a number of wchar_t's.
            // AdaptFixedSizeToAllocatedResult will then resize buffer to valueLengthNeededWithNull.
            // We're rounding up to prevent infinite loops if the data isn't a REG_SZ and length isn't divisible by 2.
            *valueLengthNeededWithNull = (length + sizeof(wchar_t) - 1) / sizeof(wchar_t);
            return status == ERROR_MORE_DATA ? S_OK : HRESULT_FROM_WIN32(status);
        }",87,,192,getWslNames.<lambda>0,3,,cascadia\TerminalSettingsModel\WslDistroGenerator.cpp:<global>
258972,METHOD_REF,2,,"[&](auto&&, Control::TransparencyChangedEventArgs args) mutable {
            VERIFY_ARE_EQUAL(expectedOpacity, args.Opacity());
            VERIFY_ARE_EQUAL(expectedOpacity, core->Opacity());
            // The Settings object's opacity shouldn't be changed
            VERIFY_ARE_EQUAL(0.5, settings->Opacity());

            if (expectedOpacity < 1.0)
            {
                VERIFY_IS_TRUE(settings->UseAcrylic());
                VERIFY_IS_TRUE(core->_settings->UseAcrylic());
            }

            // GH#603: Adjusting opacity shouldn't change whether or not we
            // requested acrylic.

            auto expectedUseAcrylic = expectedOpacity < 1.0;
            VERIFY_IS_TRUE(core->_settings->UseAcrylic());
            VERIFY_ARE_EQUAL(expectedUseAcrylic, core->UseAcrylic());
        }",32,,141,ControlCoreTests.TestAdjustAcrylic.<lambda>0,2,,cascadia\UnitTests_Control\ControlCoreTests.cpp:<global>
260176,METHOD_REF,1,,"[&](auto&& /*sender*/, auto&& /*args*/) {
            VERIFY_IS_TRUE(expectedSelectionUpdate);
            expectedSelectionUpdate = false;
            gotSelectionUpdate = true;
        }",38,,529,ControlCoreTests.TestSimpleClickSelection.<lambda>1,2,,cascadia\UnitTests_Control\ControlCoreTests.cpp:<global>
260651,METHOD_REF,1,,"[&](const hstring& hstr) {
                VERIFY_IS_GREATER_THAN(expectedOutput.size(), 0u);
                const auto expected = expectedOutput.front();
                expectedOutput.pop_front();
                Log::Comment(fmt::format(L""Received: \""{}\"""", TerminalCoreUnitTests::TestUtils::ReplaceEscapes(hstr.c_str())).c_str());
                Log::Comment(fmt::format(L""Expected: \""{}\"""", TerminalCoreUnitTests::TestUtils::ReplaceEscapes(expected)).c_str());
                VERIFY_ARE_EQUAL(expected, hstr);
            }",34,,107,ControlUnitTests._addInputCallback.<lambda>0,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
260661,METHOD_REF,1,,"[&]() {
                VERIFY_ARE_EQUAL(0u, expectedOutput.size(), L""Validate we drained all the expected output"");
            }",46,,116,ControlUnitTests._addInputCallback.<lambda>1,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
260719,METHOD_REF,2,,"[&](auto&&, Control::TransparencyChangedEventArgs args) mutable {
            VERIFY_ARE_EQUAL(expectedOpacity, args.Opacity());
            VERIFY_ARE_EQUAL(expectedOpacity, core->Opacity());
            // The Settings object's opacity shouldn't be changed
            VERIFY_ARE_EQUAL(0.5, settings->Opacity());

            auto expectedUseAcrylic = expectedOpacity < 1.0 &&
                                      (useAcrylic);
            VERIFY_ARE_EQUAL(useAcrylic, settings->UseAcrylic());
            VERIFY_ARE_EQUAL(expectedUseAcrylic, core->UseAcrylic());
        }",32,,144,ControlInteractivityTests.TestAdjustAcrylic.<lambda>2,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
260855,METHOD_REF,2,,"[&](auto&&, const Control::ScrollPositionChangedArgs& args) mutable {
            VERIFY_ARE_EQUAL(expectedTop, args.ViewTop());
            VERIFY_ARE_EQUAL(expectedViewHeight, args.ViewHeight());
            VERIFY_ARE_EQUAL(expectedBufferHeight, args.BufferSize());
        }",37,,215,ControlInteractivityTests.TestScrollWithMouse.<lambda>3,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
262513,METHOD_REF,2,,"[&](auto&&, const Control::ScrollPositionChangedArgs& args) mutable {
            VERIFY_ARE_EQUAL(expectedTop, args.ViewTop());
            VERIFY_ARE_EQUAL(expectedViewHeight, args.ViewHeight());
            VERIFY_ARE_EQUAL(expectedBufferHeight, args.BufferSize());
        }",37,,684,ControlInteractivityTests.PointerClickOutsideActiveRegion.<lambda>4,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
263774,METHOD_REF,1,,"[&]() { term.Write(L""\x1b[?1049h""); }",45,,1027,ControlInteractivityTests.AltBufferClampMouse.<lambda>5,2,,cascadia\UnitTests_Control\ControlInteractivityTests.cpp:<global>
266567,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p1"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""arg[1]"", cmdlineArgs.Commandline().at(1));
        }",41,,464,RemotingTests.ProposeCommandlineGivenWindow.<lambda>0,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
266824,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p1"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""arg[1]"", cmdlineArgs.Commandline().at(1));
        }",41,,519,RemotingTests.ProposeCommandlineCurrentWindow.<lambda>1,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
266940,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p2"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""this is for p2"", cmdlineArgs.Commandline().at(1));
        }",41,,548,RemotingTests.ProposeCommandlineCurrentWindow.<lambda>2,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
267301,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& /*cmdlineArgs*/) {
            Log::Comment(L""Commandline dispatched to p1"");
            VERIFY_IS_TRUE(false, L""This should not happen, this peasant should be dead."");
        }",41,,626,RemotingTests.ProposeCommandlineDeadWindow.<lambda>3,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
267333,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p2"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""this is for p2"", cmdlineArgs.Commandline().at(1));
        }",41,,635,RemotingTests.ProposeCommandlineDeadWindow.<lambda>4,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
270605,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p1"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""arg[1]"", cmdlineArgs.Commandline().at(1));
        }",41,,1341,RemotingTests.ProposeCommandlineForNamedDeadWindow.<lambda>5,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
270610,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& cmdlineArgs) {
            Log::Comment(L""Commandline dispatched to p2"");
            VERIFY_IS_GREATER_THAN(cmdlineArgs.Commandline().size(), 1u);
            VERIFY_ARE_EQUAL(L""this is for p2"", cmdlineArgs.Commandline().at(1));
        }",41,,1346,RemotingTests.ProposeCommandlineForNamedDeadWindow.<lambda>6,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271426,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,1540,RemotingTests.TestSummonMostRecentWindow.<lambda>7,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271431,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,1544,RemotingTests.TestSummonMostRecentWindow.<lambda>8,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271679,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,1619,RemotingTests.TestSummonNamedWindow.<lambda>9,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271684,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,1623,RemotingTests.TestSummonNamedWindow.<lambda>10,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271889,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,1681,RemotingTests.TestSummonNamedDeadWindow.<lambda>11,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
271894,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,1685,RemotingTests.TestSummonNamedDeadWindow.<lambda>12,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272122,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,1749,RemotingTests.TestSummonMostRecentDeadWindow.<lambda>13,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272127,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,1753,RemotingTests.TestSummonMostRecentDeadWindow.<lambda>14,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272472,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,1847,RemotingTests.TestSummonOnCurrent.<lambda>15,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272477,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,1851,RemotingTests.TestSummonOnCurrent.<lambda>16,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272482,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p3 summoned"");
            VERIFY_IS_TRUE(p3ExpectedToBeSummoned);
        }",29,,1855,RemotingTests.TestSummonOnCurrent.<lambda>17,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272599,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""firstCallback: Checking if window is on desktop 1"");

            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant3PID)
            {
                *result = true;
            }
            else if (hwnd == peasant2PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,1889,RemotingTests.TestSummonOnCurrent.<lambda>18,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272702,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""secondCallback: Checking if window is on desktop 2"");
            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant3PID)
            {
                *result = false;
            }
            else if (hwnd == peasant2PID)
            {
                *result = true;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",31,,1937,RemotingTests.TestSummonOnCurrent.<lambda>19,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272776,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""thirdCallback: Checking if window is on desktop 2. (windows 2 and 3 are)"");
            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID)
            {
                *result = false;
            }
            else if (hwnd == peasant2PID || hwnd == peasant3PID)
            {
                *result = true;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,1974,RemotingTests.TestSummonOnCurrent.<lambda>20,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272824,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""fourthCallback: Checking if window is on desktop 1. (window 1 is)"");
            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID)
            {
                *result = true;
            }
            else if (hwnd == peasant2PID || hwnd == peasant3PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",31,,2004,RemotingTests.TestSummonOnCurrent.<lambda>21,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
272872,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""fifthCallback: Checking if window is on desktop 3. (none are)"");
            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant2PID || hwnd == peasant3PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,2034,RemotingTests.TestSummonOnCurrent.<lambda>22,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273090,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,2098,RemotingTests.TestSummonOnCurrentWithName.<lambda>23,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273095,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,2102,RemotingTests.TestSummonOnCurrentWithName.<lambda>24,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273100,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p3 summoned"");
            VERIFY_IS_TRUE(p3ExpectedToBeSummoned);
        }",29,,2106,RemotingTests.TestSummonOnCurrentWithName.<lambda>25,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273217,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""firstCallback: Checking if window is on desktop 1"");

            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant3PID)
            {
                *result = true;
            }
            else if (hwnd == peasant2PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,2140,RemotingTests.TestSummonOnCurrentWithName.<lambda>26,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273542,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,2239,RemotingTests.TestSummonOnCurrentDeadWindow.<lambda>27,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273547,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,2243,RemotingTests.TestSummonOnCurrentDeadWindow.<lambda>28,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273552,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p3 summoned"");
            VERIFY_IS_TRUE(p3ExpectedToBeSummoned);
        }",29,,2247,RemotingTests.TestSummonOnCurrentDeadWindow.<lambda>29,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273669,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""firstCallback: Checking if window is on desktop 1"");

            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant3PID)
            {
                *result = true;
            }
            else if (hwnd == peasant2PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,2281,RemotingTests.TestSummonOnCurrentDeadWindow.<lambda>30,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273877,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,2354,RemotingTests.TestSummonMostRecentIsQuake.<lambda>31,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273882,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,2358,RemotingTests.TestSummonMostRecentIsQuake.<lambda>32,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273893,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& /*cmdlineArgs*/) {
            Log::Comment(L""Commandline dispatched to p1"");
            VERIFY_IS_TRUE(p1ExpectedCommandline);
        }",41,,2365,RemotingTests.TestSummonMostRecentIsQuake.<lambda>33,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
273898,METHOD_REF,1,,"[&](auto&&, const Remoting::CommandlineArgs& /*cmdlineArgs*/) {
            Log::Comment(L""Commandline dispatched to p2"");
            VERIFY_IS_TRUE(p2ExpectedCommandline);
        }",41,,2369,RemotingTests.TestSummonMostRecentIsQuake.<lambda>34,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
274343,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p1 summoned"");
            VERIFY_IS_TRUE(p1ExpectedToBeSummoned);
        }",29,,2482,RemotingTests.TestSummonAfterWindowClose.<lambda>35,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
274348,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p2 summoned"");
            VERIFY_IS_TRUE(p2ExpectedToBeSummoned);
        }",29,,2486,RemotingTests.TestSummonAfterWindowClose.<lambda>36,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
274353,METHOD_REF,1,,"[&](auto&&, auto&&) {
            Log::Comment(L""p3 summoned"");
            VERIFY_IS_TRUE(p3ExpectedToBeSummoned);
        }",29,,2490,RemotingTests.TestSummonAfterWindowClose.<lambda>37,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
274470,METHOD_REF,2,,"[&](HWND h, BOOL* result) -> HRESULT {
            Log::Comment(L""firstCallback: Checking if window is on desktop 1"");

            const auto hwnd = reinterpret_cast<uint64_t>(h);
            if (hwnd == peasant1PID || hwnd == peasant3PID)
            {
                *result = true;
            }
            else if (hwnd == peasant2PID)
            {
                *result = false;
            }
            else
            {
                VERIFY_IS_TRUE(false, L""IsWindowOnCurrentVirtualDesktop called with unexpected value"");
            }
            return S_OK;
        }",30,,2524,RemotingTests.TestSummonAfterWindowClose.<lambda>38,2,,cascadia\UnitTests_Remoting\RemotingTests.cpp:<global>
279628,METHOD_REF,2,,"[](TextBuffer& tb) {
        TestUtils::VerifyExpectedString(tb, L""AAA"", { 0, 0 });
        TestUtils::VerifyExpectedString(tb, L""BBB"", { 0, 1 });
    }",23,,390,ConptyRoundtripTests.WriteTwoLinesUsesNewline.<lambda>0,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
279739,METHOD_REF,2,,"[](TextBuffer& tb) {
        TestUtils::VerifyExpectedString(tb, L""AAA"", { 0, 0 });
        TestUtils::VerifyExpectedString(tb, L""BBB"", { 0, 1 });
        TestUtils::VerifyExpectedString(tb, L""   "", { 0, 2 });
        TestUtils::VerifyExpectedString(tb, L""CCC"", { 0, 3 });
    }",23,,425,ConptyRoundtripTests.WriteAFewSimpleLines.<lambda>1,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
279902,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor wrapped to the second line
        VERIFY_ARE_EQUAL(charsToWrite % initialTermView.Width(), cursor.GetPosition().x);
        VERIFY_ARE_EQUAL(1, cursor.GetPosition().y);

        // Verify that we marked the 0th row as _wrapped_
        const auto& row0 = tb.GetRowByOffset(0);
        VERIFY_IS_TRUE(row0.WasWrapForced());

        const auto& row1 = tb.GetRowByOffset(1);
        VERIFY_IS_FALSE(row1.WasWrapForced());

        TestUtils::VerifyExpectedString(tb, TestUtils::Test100CharsString, { 0, 0 });
    }",25,,478,ConptyRoundtripTests.TestWrappingALongString.<lambda>2,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280018,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor wrapped to the second line
        VERIFY_ARE_EQUAL(2, cursor.GetPosition().y);
        VERIFY_ARE_EQUAL(20, cursor.GetPosition().x);

        // Verify that we marked the 0th row as _wrapped_
        const auto& row0 = tb.GetRowByOffset(0);
        VERIFY_IS_TRUE(row0.WasWrapForced());

        const auto& row1 = tb.GetRowByOffset(1);
        VERIFY_IS_FALSE(row1.WasWrapForced());

        TestUtils::VerifyExpectedString(tb, TestUtils::Test100CharsString, { 0, 0 });
        TestUtils::VerifyExpectedString(tb, L""          1234567890"", { 0, 2 });
    }",25,,522,ConptyRoundtripTests.TestAdvancedWrapping.<lambda>3,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280159,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor wrapped to the second line
        VERIFY_ARE_EQUAL(1, cursor.GetPosition().y);
        VERIFY_ARE_EQUAL(10, cursor.GetPosition().x);

        // Verify that we marked the 0th row as _not wrapped_
        const auto& row0 = tb.GetRowByOffset(0);
        VERIFY_IS_FALSE(row0.WasWrapForced());

        const auto& row1 = tb.GetRowByOffset(1);
        VERIFY_IS_FALSE(row1.WasWrapForced());

        TestUtils::VerifyExpectedString(tb, LR""(!""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnop)"", { 0, 0 });
        TestUtils::VerifyExpectedString(tb, L""1234567890"", { 0, 1 });
    }",25,,594,ConptyRoundtripTests.TestExactWrappingWithoutSpaces.<lambda>4,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280300,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor wrapped to the second line
        VERIFY_ARE_EQUAL(1, cursor.GetPosition().y);
        VERIFY_ARE_EQUAL(20, cursor.GetPosition().x);

        // Verify that we marked the 0th row as _not wrapped_
        const auto& row0 = tb.GetRowByOffset(0);
        VERIFY_IS_FALSE(row0.WasWrapForced());

        const auto& row1 = tb.GetRowByOffset(1);
        VERIFY_IS_FALSE(row1.WasWrapForced());

        TestUtils::VerifyExpectedString(tb, LR""(!""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnop)"", { 0, 0 });
        TestUtils::VerifyExpectedString(tb, L""          1234567890"", { 0, 1 });
    }",25,,656,ConptyRoundtripTests.TestExactWrappingWithSpaces.<lambda>5,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280401,METHOD_REF,2,,"[](TextBuffer& tb) {
        auto iter = tb.GetCellDataAt({ 0, 0 });
        TestUtils::VerifySpanOfText(L""A"", iter, 0, TerminalViewWidth);
        TestUtils::VerifySpanOfText(L"" "", iter, 0, TerminalViewWidth);
    }",24,,705,ConptyRoundtripTests.MoveCursorAtEOL.<lambda>6,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280448,METHOD_REF,2,,"[](TextBuffer& tb) {
        auto iter = tb.GetCellDataAt({ 0, 0 });
        // There should be 79 'A's, followed by a space, and the following line should be blank.
        TestUtils::VerifySpanOfText(L""A"", iter, 0, TerminalViewWidth - 1);
        TestUtils::VerifySpanOfText(L"" "", iter, 0, 1);
        TestUtils::VerifySpanOfText(L"" "", iter, 0, TerminalViewWidth);

        auto& cursor = tb.GetCursor();
        VERIFY_ARE_EQUAL(TerminalViewWidth - 1, cursor.GetPosition().x);
        VERIFY_ARE_EQUAL(0, cursor.GetPosition().y);
    }",24,,729,ConptyRoundtripTests.MoveCursorAtEOL.<lambda>7,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280741,METHOD_REF,2,,"[&expectedTerminalViewBottom, &printedRows, this, &initialTerminalBufferHeight](TextBuffer& termTb, const int resizeDy = 0) {
        // Some number of lines of text were lost from the scrollback. The
        // number of lines lost will be determined by whichever of the initial
        // or current buffer is smaller.
        const auto numLostRows = std::max(0,
                                          printedRows - std::min(term->GetTextBuffer().GetSize().Height(), initialTerminalBufferHeight) + 1);

        const auto rowsWithText = std::min(printedRows, expectedTerminalViewBottom) - 1 + std::min(resizeDy, 0);

        for (til::CoordType row = 0; row < rowsWithText; row++)
        {
            SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);
            auto iter = termTb.GetCellDataAt({ 0, row });
            const wchar_t expectedChar = static_cast<wchar_t>((row + numLostRows) % 93) + 33;

            auto expectedString = std::wstring(1, expectedChar);

    ...",27,,816,ConptyRoundtripTests.TestResizeHeight.<lambda>8,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
280745,METHOD_REF,2,,"[&si, &initialHostView, &printedRows](TextBuffer& hostTb, const int resizeDy = 0) {
        const auto hostView = si.GetViewport();

        // In the host, there are two regions we're interested in:

        // 1. the first section of the buffer with the output in it. Before
        //    we're resized, this will be filled with one character on each row.
        // 2. The second area below the first that's empty (filled with spaces).
        //    Initially, this is only one row.
        // After we resize, different things will happen.
        // * If we decrease the height of the buffer, the characters in the
        //   buffer will all move _up_ the same number of rows. We'll want to
        //   only check the first initialView+dy rows for characters.
        // * If we increase the height, rows will be added at the bottom. We'll
        //   want to check the initial viewport height for the original
        //   characters, but then we'll want to look for more blank rows at t...",27,,841,ConptyRoundtripTests.TestResizeHeight.<lambda>9,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
281456,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const bool afterClear = false) {
        const auto width = viewport.width();

        // ""~"" rows
        for (til::CoordType row = 0; row < viewport.bottom; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));
            VERIFY_IS_FALSE(tb.GetRowByOffset(row).WasWrapForced());
            auto iter = tb.GetCellDataAt({ 0, row });
            if (afterClear && row >= viewport.top)
            {
                TestUtils::VerifySpanOfText(L"" "", iter, 0, width);
            }
            else
            {
                TestUtils::VerifySpanOfText(L""~"", iter, 0, 1);
                TestUtils::VerifySpanOfText(L"" "", iter, 0, width - 1);
            }
        }
    }",25,,1096,ConptyRoundtripTests.PassthroughClearAll.<lambda>10,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
282019,METHOD_REF,2,,"[](const TextBuffer& tb) {
        // Buffer contents should look like the following: (80 wide)
        // (w) means we hard wrapped the line
        // (b) means the line is _not_ wrapped (it's broken, the default state.)
        // cursor is on the '_'
        //
        // |AAAAAAAA...AAAA| (w)
        // |AAAAA_  ...    | (b) (There are 20 'A's on this line.)
        // |        ...    | (b)

        VERIFY_IS_TRUE(tb.GetRowByOffset(0).WasWrapForced());
        VERIFY_IS_FALSE(tb.GetRowByOffset(1).WasWrapForced());
        auto iter0 = tb.GetCellDataAt({ 0, 0 });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, TerminalViewWidth);
        auto iter1 = tb.GetCellDataAt({ 0, 1 });
        TestUtils::VerifySpanOfText(L""A"", iter1, 0, 20);
        auto iter2 = tb.GetCellDataAt({ 20, 1 });
        TestUtils::VerifySpanOfText(L"" "", iter2, 0, TerminalViewWidth - 20);
    }",25,,1272,ConptyRoundtripTests.OutputWrappedLinesAtTopOfBuffer.<lambda>11,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
282256,METHOD_REF,2,,"[](const TextBuffer& tb, const til::CoordType wrappedRow) {
        // Buffer contents should look like the following: (80 wide)
        // (w) means we hard wrapped the line
        // (b) means the line is _not_ wrapped (it's broken, the default state.)
        // cursor is on the '_'
        //
        // |X              | (b)
        // |X              | (b)
        // ...
        // |X              | (b)
        // |AAAAAAAA...AAAA| (w)
        // |AAAAA_  ...    | (b) (There are 20 'A's on this line.)

        VERIFY_IS_TRUE(tb.GetRowByOffset(wrappedRow).WasWrapForced());
        VERIFY_IS_FALSE(tb.GetRowByOffset(wrappedRow + 1).WasWrapForced());

        auto iter0 = tb.GetCellDataAt({ 0, wrappedRow });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, TerminalViewWidth);
        auto iter1 = tb.GetCellDataAt({ 0, wrappedRow + 1 });
        TestUtils::VerifySpanOfText(L""A"", iter1, 0, 20);
        auto iter2 = tb.GetCellDataAt({ 20, wrappedRow + 1 });
        TestUtils::Veri...",25,,1400,ConptyRoundtripTests.OutputWrappedLinesAtBottomOfBuffer.<lambda>12,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
282530,METHOD_REF,2,,"[](const TextBuffer& tb, const til::rect& viewport) {
        const auto wrappedRow = viewport.bottom - 2;
        const auto start = viewport.top;
        for (auto i = start; i < wrappedRow; i++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", i));
            TestUtils::VerifyExpectedString(tb, i == start + 13 ? L""Y"" : L""X"", { 0, i });
        }

        VERIFY_IS_TRUE(tb.GetRowByOffset(wrappedRow).WasWrapForced());
        VERIFY_IS_FALSE(tb.GetRowByOffset(wrappedRow + 1).WasWrapForced());

        auto iter0 = tb.GetCellDataAt({ 0, wrappedRow });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, TerminalViewWidth);

        auto iter1 = tb.GetCellDataAt({ 0, wrappedRow + 1 });
        TestUtils::VerifySpanOfText(L""A"", iter1, 0, 20);
        auto iter2 = tb.GetCellDataAt({ 20, wrappedRow + 1 });
        TestUtils::VerifySpanOfText(L"" "", iter2, 0, TerminalViewWidth - 20);
    }",25,,1505,ConptyRoundtripTests.ScrollWithChangesInMiddle.<lambda>13,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
282734,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor is waiting in the bottom right corner
        VERIFY_ARE_EQUAL(initialTermView.Height() - 1, cursor.GetPosition().y);
        VERIFY_ARE_EQUAL(initialTermView.Width() - 1, cursor.GetPosition().x);

        // For all rows except the last one, verify that we have a run of four letters.
        for (auto i = 0; i < rowsToWrite; ++i)
        {
            const std::wstring expectedString(4, static_cast<wchar_t>(L'A' + i));
            const til::point expectedPos{ 0, i };
            TestUtils::VerifyExpectedString(tb, expectedString, expectedPos);
        }

        // For the last row, verify we have an entire row of asterisks for the mode line.
        const std::wstring expectedModeLine(initialTermView.Width() - 1, L'*');
        const til::point expectedPos{ 0, rowsToWrite };
        TestUtils::VerifyExpectedString(tb, expectedModeLine, expectedPos);
    }",25,,1589,ConptyRoundtripTests.ScrollWithMargins.<lambda>14,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
282965,METHOD_REF,2,,"[&](const TextBuffer& tb, const auto panOffset) {
        auto& cursor = tb.GetCursor();
        // Verify the cursor is waiting on the freshly revealed line (1 above mode line)
        // and in the left most column.
        const auto bottomLine = initialTermView.BottomInclusive() + panOffset;
        VERIFY_ARE_EQUAL(bottomLine - 1, cursor.GetPosition().y);
        VERIFY_ARE_EQUAL(0, cursor.GetPosition().x);

        // For all rows except the last two, verify that we have a run of four letters.
        for (auto i = 0; i < rowsToWrite - 1; ++i)
        {
            // Start with B this time because the A line got scrolled off the top.
            const std::wstring expectedString(4, static_cast<wchar_t>(L'B' + i));
            const til::point expectedPos{ 0, panOffset + i };
            TestUtils::VerifyExpectedString(tb, expectedString, expectedPos);
        }

        // For the second to last row, verify that it is blank.
        {
            const std::wstring expectedBl...",30,,1704,ConptyRoundtripTests.ScrollWithMargins.<lambda>15,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
283151,METHOD_REF,2,,"[](const TextBuffer& tb) {
        // Simple verification: Make sure the cursor is in the correct place,
        // and that it's visible. We don't care so much about the buffer
        // contents in this test.
        const til::point expectedCursor{ 8, 3 };
        VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        VERIFY_IS_TRUE(tb.GetCursor().IsVisible());
    }",25,,1797,ConptyRoundtripTests.DontWrapMoveCursorInSingleFrame.<lambda>16,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
283338,METHOD_REF,2,,"[&cursorOnNextLine, &useLongSpaces, &printTextAfterSpaces](const TextBuffer& tb,
                                                                                   const til::rect viewport) {
        // We _would_ expect the Terminal's cursor to be on { 8, 0 }, but this
        // is currently broken due to #381/#4676. So we'll use the viewport
        // provided to find the actual Y position of the cursor.
        const auto viewTop = viewport.origin().y;
        const auto cursorRow = viewTop + (cursorOnNextLine ? 1 : 0);
        const auto cursorCol = (cursorOnNextLine ? 5 :
                                                   (10 + (useLongSpaces ? 5 : 0) + (printTextAfterSpaces ? 5 : 0)));
        const til::point expectedCursor{ cursorCol, cursorRow };

        VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        VERIFY_IS_TRUE(tb.GetCursor().IsVisible());
        auto iter = TestUtils::VerifyExpectedString(tb, L""AAAAA"", { 0, viewTop });
        TestUtils::Ve...",25,,1890,ConptyRoundtripTests.ClearHostTrickeryTest.<lambda>17,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
283353,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,1925,ConptyRoundtripTests.ClearHostTrickeryTest.<lambda>18,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
283591,METHOD_REF,2,,"[](const TextBuffer& tb,
                           const til::rect viewport) {
        const auto lastRow = viewport.bottom - 1;
        const til::point expectedCursor{ 0, lastRow - 1 };
        VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        VERIFY_IS_TRUE(tb.GetCursor().IsVisible());

        TestUtils::VerifyExpectedString(tb, L""AAAAAAAAAA          DDDDDDDDDD"", { 0, lastRow - 2 });
        TestUtils::VerifyExpectedString(tb, L""BBBBBBBBBB"", { 0, lastRow - 1 });
        TestUtils::VerifyExpectedString(tb, L""FFFFFFFFFE"", { 0, lastRow });
    }",25,,1998,ConptyRoundtripTests.OverstrikeAtBottomOfBuffer.<lambda>19,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
283827,METHOD_REF,2,,"[](const TextBuffer& tb,
                           const til::rect viewport) {
        const auto lastRow = viewport.bottom - 1;
        const til::point expectedCursor{ 1, lastRow };
        VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        VERIFY_IS_TRUE(tb.GetCursor().IsVisible());

        TestUtils::VerifyExpectedString(tb, L""EEEEEEEEEE"", { 0, lastRow - 4 });
        TestUtils::VerifyExpectedString(tb, L""AAAAAAAAAA"", { 0, lastRow - 3 });
        TestUtils::VerifyExpectedString(tb, L""          "", { 0, lastRow - 2 });
        TestUtils::VerifyExpectedString(tb, L""XBBBBBBBBB"", { 0, lastRow - 1 });
        TestUtils::VerifyExpectedString(tb, L""YCCCCCCCCC"", { 0, lastRow });
    }",25,,2076,ConptyRoundtripTests.MarginsWithStatusLine.<lambda>20,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284112,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        // Buffer contents should look like the following: (80 wide)
        // (w) means we hard wrapped the line
        // (b) means the line is _not_ wrapped (it's broken, the default state.)
        //
        // |AAAA...AA  | (w)
        // | B_ ...    | (b) (cursor is on the '_')
        // |    ...    | (b)

        VERIFY_IS_TRUE(tb.GetRowByOffset(0).WasWrapForced());
        VERIFY_IS_FALSE(tb.GetRowByOffset(1).WasWrapForced());

        // First row
        auto iter0 = tb.GetCellDataAt({ 0, 0 });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, firstTextLength);
        TestUtils::VerifySpanOfText(L"" "", iter0, 0, 2);

        // Second row
        auto iter1 = tb.GetCellDataAt({ 0, 1 });
        TestUtils::VerifySpanOfText(L"" "", iter1, 0, 1);
        auto iter2 = tb.GetCellDataAt({ 1, 1 });
        TestUtils::VerifySpanOfText(L""B"", iter2, 0, secondTextLength);
    }",25,,2175,ConptyRoundtripTests.OutputWrappedLineWithSpace.<lambda>21,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284404,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport) {
        // Buffer contents should look like the following: (80 wide)
        // (w) means we hard wrapped the line
        // (b) means the line is _not_ wrapped (it's broken, the default state.)
        //
        // |AAAA...AA  | (w)
        // | B_ ...    | (b) (cursor is on the '_')
        // |    ...    | (b)

        const auto wrappedRow = viewport.bottom - 2;
        VERIFY_IS_TRUE(tb.GetRowByOffset(wrappedRow).WasWrapForced());
        VERIFY_IS_FALSE(tb.GetRowByOffset(wrappedRow + 1).WasWrapForced());

        // First row
        auto iter0 = tb.GetCellDataAt({ 0, wrappedRow });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, firstTextLength);
        TestUtils::VerifySpanOfText(L"" "", iter0, 0, 2);

        // Second row
        auto iter1 = tb.GetCellDataAt({ 0, wrappedRow + 1 });
        TestUtils::VerifySpanOfText(L"" "", iter1, 0, 1);
        auto iter2 = tb.GetCellDataAt({ 1, wrappedRow + 1 });
        TestUti...",25,,2324,ConptyRoundtripTests.OutputWrappedLineWithSpaceAtBottomOfBuffer.<lambda>22,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284537,METHOD_REF,2,,"[&](const TextBuffer& tb,
                            const til::rect viewport) {
        const auto lastRow = viewport.bottom - 1;
        const til::point expectedCursor{ 5, lastRow };
        VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        VERIFY_IS_TRUE(tb.GetCursor().IsVisible());

        for (auto y = viewport.top; y < lastRow; y++)
        {
            // We're using CUP to move onto the status line _always_, so the
            // second-last row will always be marked as wrapped.
            const auto rowWrapped = (!expectHardBreak) || (y == lastRow - 1);
            VERIFY_ARE_EQUAL(rowWrapped, tb.GetRowByOffset(y).WasWrapForced());
            TestUtils::VerifyExpectedString(tb, L""~    "", { 0, y });
        }

        TestUtils::VerifyExpectedString(tb, L""AAAAA"", { 0, lastRow });
    }",25,,2392,ConptyRoundtripTests.BreakLinesOnCursorMovement.<lambda>23,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284555,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2417,ConptyRoundtripTests.BreakLinesOnCursorMovement.<lambda>24,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284588,METHOD_REF,1,,"[&] { hostSm.ProcessString(L""\x1b[?1049l""); }",42,,2427,ConptyRoundtripTests.BreakLinesOnCursorMovement.<lambda>25,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
284944,METHOD_REF,2,,"[&](const TextBuffer& tb, til::CoordType bottomRow) {
        // Buffer contents should look like the following: (80 wide)
        // (w) means we hard wrapped the line
        // (b) means the line is _not_ wrapped (it's broken, the default state.)
        // cursor is on the '_'
        //
        // | ^ ^ ^ ^ ^ ^ ^ | ( ) (entire buffer above us; contents do not matter)
        // |               | ( ) (entire buffer above us; contents do not matter)
        // |AAAAAAAA...AAA | (w) (79 'A's, one space)
        // |B_      ...    | (b) (There's only one 'B' on this line)

        til::point cursorPos{ tb.GetCursor().GetPosition() };
        // The cursor should be on the second char of the last line
        VERIFY_ARE_EQUAL(til::point(1, bottomRow), cursorPos);

        const auto& secondToLastRow = tb.GetRowByOffset(bottomRow - 1);
        const auto& lastRow = tb.GetRowByOffset(bottomRow);
        VERIFY_IS_TRUE(secondToLastRow.WasWrapForced());
        VERIFY_IS_FALSE(lastRow.W...",25,,2548,ConptyRoundtripTests.TestCursorInDeferredEOLPositionOnNewLineWithSpaces.<lambda>26,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
285053,METHOD_REF,2,,"[&sm, &si]() {
        const auto hostView = si.GetViewport();
        const auto width = hostView.Width();

        // Write:
        // * AAA to the first line
        // * BBB to the second line
        // * a bunch of lines with a ""~"" followed by spaces (just the way vim.exe likes to render)
        // * A status line with a bunch of ""X""s and _a single space in the last cell_.
        sm.ProcessString(L""AAA"");
        sm.ProcessString(L""\r\n"");
        sm.ProcessString(L""BBB"");
        sm.ProcessString(L""\r\n"");

        for (auto i = 2; i < hostView.BottomInclusive(); i++)
        {
            // IMPORTANT! The way vim writes these blank lines is as '~' followed by
            // enough spaces to fill the line.
            std::wstring line{ L""~"" };
            line += std::wstring(width - 1, L' ');
            sm.ProcessString(line);
        }
        sm.ProcessString(std::wstring(width - 1, L'X'));
        sm.ProcessString(L"" "");

        // Move the cursor back home, as if ...",20,,2606,ConptyRoundtripTests.ResizeRepaintVimExeBuffer.<lambda>27,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
285058,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport) {
        const auto firstRow = viewport.top;
        const auto width = viewport.width();

        // First row
        VERIFY_IS_FALSE(tb.GetRowByOffset(firstRow).WasWrapForced());
        auto iter0 = tb.GetCellDataAt({ 0, firstRow });
        TestUtils::VerifySpanOfText(L""A"", iter0, 0, 3);
        TestUtils::VerifySpanOfText(L"" "", iter0, 0, width - 3);

        // Second row
        VERIFY_IS_FALSE(tb.GetRowByOffset(firstRow + 1).WasWrapForced());
        auto iter1 = tb.GetCellDataAt({ 0, firstRow + 1 });
        TestUtils::VerifySpanOfText(L""B"", iter1, 0, 3);
        TestUtils::VerifySpanOfText(L"" "", iter1, 0, width - 3);

        // ""~"" rows
        for (auto row = firstRow + 2; row < viewport.bottom - 1; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));
            VERIFY_IS_TRUE(tb.GetRowByOffset(row).WasWrapForced());
            auto iter = tb.GetCellDataAt({ 0, row });
        ...",25,,2638,ConptyRoundtripTests.ResizeRepaintVimExeBuffer.<lambda>28,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
285303,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const bool afterClear = false) {
        const auto width = viewport.width();

        // ""~"" rows
        for (til::CoordType row = 0; row < viewport.bottom; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));
            VERIFY_IS_FALSE(tb.GetRowByOffset(row).WasWrapForced());
            auto iter = tb.GetCellDataAt({ 0, row });
            if (afterClear)
            {
                TestUtils::VerifySpanOfText(L"" "", iter, 0, width);
            }
            else
            {
                TestUtils::VerifySpanOfText(L""~"", iter, 0, 1);
                TestUtils::VerifySpanOfText(L"" "", iter, 0, width - 1);
            }
        }
    }",25,,2748,ConptyRoundtripTests.ClsAndClearHostClearsScrollbackTest.<lambda>29,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
285956,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const bool isTerminal, const bool afterResize) {
        const auto width = viewport.width();

        // Conhost and Terminal attributes are potentially different.
        const auto greenAttrs = isTerminal ? terminalGreenAttrs : conhostGreenAttrs;

        for (til::CoordType row = 0; row < tb.GetSize().Height(); row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d..."", row));

            VERIFY_IS_FALSE(tb.GetRowByOffset(row).WasWrapForced());

            const auto hasChar = row < 3;
            const auto actualDefaultAttrs = isTerminal ? TextAttribute() : defaultAttrs;

            if (hasChar)
            {
                auto iter = TestUtils::VerifyLineContains(tb, { 0, row }, L'#', greenAttrs, 1u);
                TestUtils::VerifyLineContains(iter, L' ', greenAttrs, 1u);
                TestUtils::VerifyLineContains(iter, L'#', TextAttribute(), 1u);
                // After the resize, t...",25,,2983,ConptyRoundtripTests.ResizeInitializeBufferWithDefaultAttrs.<lambda>30,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
286279,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport) {
        const auto width = viewport.width();
        const auto isTerminal = viewport.top != 0;

        // Conhost and Terminal attributes are potentially different.
        const auto blueAttrs = isTerminal ? terminalBlueAttrs : conhostBlueAttrs;

        for (til::CoordType row = 0; row < viewport.bottom - 2; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));
            VERIFY_IS_FALSE(tb.GetRowByOffset(row).WasWrapForced());

            const auto isBlank = (row % 2) == 0;
            const auto rowCircled = row > (viewport.bottom - 1 - circledRows);
            // When the buffer circles, new lines will be initialized using the
            // current text attributes. Those will be the default-on-default
            // attributes. All of the Terminal's buffer will use
            // default-on-default.
            const auto actualDefaultAttrs = rowCircled || isTerminal ? TextAttrib...",25,,3121,ConptyRoundtripTests.NewLinesAtBottomWithBackground.<lambda>31,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
286476,METHOD_REF,2,,"[&](const std::wstring_view str) {
        if (writingMethod == PrintWithPrintString)
        {
            sm.ProcessString(str);
        }
        else if (writingMethod == PrintWithWriteCharsLegacy)
        {
            WriteCharsLegacy(si, str, nullptr);
        }
    }",18,,3239,ConptyRoundtripTests.WrapNewLineAtBottom.<lambda>32,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
286571,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport) {
        const auto width = viewport.width();
        const auto isTerminal = viewport.top != 0;

        for (til::CoordType row = 0; row < viewport.bottom; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));

            // The first line wrapped, the second didn't, so on and so forth
            const auto isWrapped = (row % 2) == 0;
            const auto rowCircled = row >= (viewport.bottom - circledRows);

            const auto actualNonSpacesAttrs = defaultAttrs;
            const auto actualSpacesAttrs = rowCircled || isTerminal ? defaultAttrs : conhostDefaultAttrs;

            VERIFY_ARE_EQUAL(isWrapped, tb.GetRowByOffset(row).WasWrapForced());
            if (isWrapped)
            {
                TestUtils::VerifyExpectedString(tb, std::wstring(charsInFirstLine, L'~'), { 0, row });
            }
            else
            {
                auto iter = TestUtils::VerifyExpec...",25,,3302,ConptyRoundtripTests.WrapNewLineAtBottom.<lambda>33,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
286760,METHOD_REF,2,,"[&](const std::wstring_view str) {
        if (writingMethod == PrintWithPrintString)
        {
            sm.ProcessString(str);
        }
        else if (writingMethod == PrintWithWriteCharsLegacy)
        {
            WriteCharsLegacy(si, str, nullptr);
        }
    }",18,,3397,ConptyRoundtripTests.WrapNewLineAtBottomLikeMSYS.<lambda>34,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
286970,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport) {
        const auto width = viewport.width();
        const auto isTerminal = viewport.top != 0;
        auto lastRow = viewport.bottom - 1;
        for (til::CoordType row = 0; row < lastRow; row++)
        {
            Log::Comment(NoThrowString().Format(L""Checking row %d"", row));

            // The first line wrapped, the second didn't, so on and so forth.
            // However, because conpty's buffer is only as tall as the viewport,
            // we're going to lose lines off the top of the buffer. Most
            // importantly, because we'll have the ""prompt"" line in the conpty
            // buffer, then the top line of the conpty will _not_ be wrapped,
            // when the 0th line of the terminal buffer _is_.
            const auto isWrapped = (row % 2) == (isTerminal ? 0 : 1);
            const auto rowCircled = row >= (viewport.bottom - circledRows);

            const auto actualNonSpacesAttrs = defaultAttrs;...",25,,3504,ConptyRoundtripTests.WrapNewLineAtBottomLikeMSYS.<lambda>35,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287126,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const bool after) {
        const auto width = viewport.width();

        auto iter1 = tb.GetCellDataAt({ 0, 0 });
        TestUtils::VerifySpanOfText(L""A"", iter1, 0, 50);
        TestUtils::VerifySpanOfText(L"" "", iter1, 0, 1);
        if (after)
        {
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, 50);

            auto iter2 = tb.GetCellDataAt({ 0, 1 });
            TestUtils::VerifySpanOfText(L"" "", iter2, 0, width);
        }
        else
        {
            TestUtils::VerifySpanOfText(L""B"", iter1, 0, 50);

            auto iter2 = tb.GetCellDataAt({ 0, 1 });
            TestUtils::VerifySpanOfText(L""B"", iter2, 0, 50 - (width - 51));
            TestUtils::VerifySpanOfText(L"" "", iter2, 0, width);
        }
    }",25,,3580,ConptyRoundtripTests.DeleteWrappedWord.<lambda>36,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287430,METHOD_REF,2,,"[](TextBuffer& tb) {
        // Check that all the linked cells still have the same ID
        auto& row = tb.GetRowByOffset(0);
        auto id = row.GetAttrByColumn(0).GetHyperlinkId();
        for (uint16_t i = 1; i < 4; ++i)
        {
            VERIFY_ARE_EQUAL(id, row.GetAttrByColumn(i).GetHyperlinkId());
        }
    }",23,,3694,ConptyRoundtripTests.HyperlinkIdConsistency.<lambda>37,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287551,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const bool before) {
        const auto width = viewport.width();
        const auto numCharsOnSecondLine = 50 - (width - 51);
        auto iter1 = tb.GetCellDataAt({ 0, 0 });
        if (before)
        {
            TestUtils::VerifySpanOfText(L""A"", iter1, 0, 50);
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, 1);
            TestUtils::VerifySpanOfText(L""B"", iter1, 0, 50);
            til::point expectedCursor{ numCharsOnSecondLine, 1 };
            VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        }
        else
        {
            TestUtils::VerifySpanOfText(L""B"", iter1, 0, numCharsOnSecondLine);
            til::point expectedCursor{ numCharsOnSecondLine, 0 };
            VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
        }
    }",25,,3741,ConptyRoundtripTests.ClearBufferSignal.<lambda>38,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287754,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const Frame frame) {
        const auto width = viewport.width();
        auto iter0 = tb.GetCellDataAt({ 0, 0 });
        auto iter1 = tb.GetCellDataAt({ 0, 1 });
        switch (frame)
        {
        case Frame::InMainBufferBefore:
        case Frame::InMainBufferAfter:
        {
            TestUtils::VerifySpanOfText(L""A"", iter0, 0, 50);
            TestUtils::VerifySpanOfText(L"" "", iter0, 0, static_cast<size_t>(width - 50));

            TestUtils::VerifySpanOfText(L""B"", iter1, 0, 50);
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, static_cast<size_t>(width - 50));
            til::point expectedCursor{ 50, 1 };
            VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
            break;
        }
        case Frame::InAltBufferBefore:
        {
            TestUtils::VerifySpanOfText(L"" "", iter0, 0, width);
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, width);

            til::point e...",25,,3835,ConptyRoundtripTests.SimpleAltBufferTest.<lambda>39,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287826,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,3888,ConptyRoundtripTests.SimpleAltBufferTest.<lambda>40,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
287839,METHOD_REF,1,,"[&] { sm.ProcessString(L""\x1b[?1049l""); }",43,,3891,ConptyRoundtripTests.SimpleAltBufferTest.<lambda>41,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288180,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& viewport, const Frame frame) {
        const auto width = viewport.width();
        auto iter0 = tb.GetCellDataAt({ 0, 0 });
        auto iter1 = tb.GetCellDataAt({ 0, 1 });
        switch (frame)
        {
        case Frame::InMainBufferBefore:
        {
            TestUtils::VerifySpanOfText(L""A"", iter0, 0, 50);
            TestUtils::VerifySpanOfText(L"" "", iter0, 0, static_cast<size_t>(width - 50));

            TestUtils::VerifySpanOfText(L""B"", iter1, 0, 50);
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, static_cast<size_t>(width - 50));
            til::point expectedCursor{ 50, 1 };
            VERIFY_ARE_EQUAL(expectedCursor, tb.GetCursor().GetPosition());
            break;
        }
        case Frame::InAltBufferBefore:
        {
            TestUtils::VerifySpanOfText(L"" "", iter0, 0, width);
            TestUtils::VerifySpanOfText(L"" "", iter1, 0, width);

            til::point expectedCursor{ 50, 1 };
            VER...",25,,3989,ConptyRoundtripTests.AltBufferToAltBufferTest.<lambda>42,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288243,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,4049,ConptyRoundtripTests.AltBufferToAltBufferTest.<lambda>43,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288256,METHOD_REF,1,,"[&] { sm.ProcessString(L""\x1b[?1049l""); }",43,,4052,ConptyRoundtripTests.AltBufferToAltBufferTest.<lambda>44,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288640,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        // If this test fails on character 8, then it's because we didn't emit the space, we just moved ahead.
        auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, whiteOnGreen, 9u);
        TestUtils::VerifyLineContains(iter0, OutputCellIterator{ greenOnBlack, 2u });
        TestUtils::VerifyLineContains(iter0, OutputCellIterator{ whiteOnBlack, 4u });
        TestUtils::VerifyLineContains(iter0, OutputCellIterator{ blackOnDefault, 2u });
    }",25,,4153,ConptyRoundtripTests.TestPowerLineFirstFrame.<lambda>45,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288728,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,4189,ConptyRoundtripTests.AltBufferResizeCrash.<lambda>46,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288740,METHOD_REF,1,,"[&] { sm.ProcessString(L""\x1b[?1049l""); }",43,,4196,ConptyRoundtripTests.AltBufferResizeCrash.<lambda>47,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288892,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,4239,ConptyRoundtripTests.TestNoExtendedAttrsOptimization.<lambda>48,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
288908,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L' ', reverseAttrs, 9u);
        TestUtils::VerifyExpectedString(L""test"", iter0);
        TestUtils::VerifyLineContains(iter0, L' ', reverseAttrs, 9u);

        TestUtils::VerifyLineContains(tb, { 0, 1 }, L' ', reverseAttrs, static_cast<uint32_t>(TerminalViewWidth));
    }",25,,4248,ConptyRoundtripTests.TestNoExtendedAttrsOptimization.<lambda>49,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
289036,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,4286,ConptyRoundtripTests.TestNoBackgroundAttrsOptimization.<lambda>50,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
289054,METHOD_REF,2,,"[&](const TextBuffer& tb) {
        auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L' ', bgAttrs, 9u);
        TestUtils::VerifyExpectedString(L""test"", iter0);
        TestUtils::VerifyLineContains(iter0, L' ', bgAttrs, 9u);

        TestUtils::VerifyLineContains(tb, { 0, 1 }, L' ', bgAttrs, static_cast<uint32_t>(TerminalViewWidth));
    }",25,,4295,ConptyRoundtripTests.TestNoBackgroundAttrsOptimization.<lambda>51,2,,cascadia\UnitTests_TerminalCore\ConptyRoundtripTests.cpp:<global>
290672,METHOD_REF,2,,"[&](til::CoordType scrollback, const til::inclusive_rect& expected) {
                Terminal term{ Terminal::TestDummyMarker{} };
                DummyRenderer renderer{ &term };
                term.Create({ 10, 10 }, scrollback, renderer);

                // NOTE: SetSelectionEnd(til::point) is called within SetSelectionAnchor(til::point)
                term.SetSelectionAnchor(maxCoord);
                ValidateSingleRowSelection(term, expected);
            }",49,,115,TerminalCoreUnitTests.<lambda>0,2,,cascadia\UnitTests_TerminalCore\SelectionTest.cpp:<global>
290676,METHOD_REF,2,,"[&](til::CoordType scrollback, const til::inclusive_rect& expected) {
                Terminal term{ Terminal::TestDummyMarker{} };
                DummyRenderer renderer{ &term };
                term.Create({ 10, 10 }, scrollback, renderer);

                term.MultiClickSelection(maxCoord, Terminal::SelectionExpansion::Word);
                ValidateSingleRowSelection(term, expected);
            }",49,,128,TerminalCoreUnitTests.<lambda>1,2,,cascadia\UnitTests_TerminalCore\SelectionTest.cpp:<global>
290680,METHOD_REF,2,,"[&](til::CoordType scrollback, const til::inclusive_rect& expected) {
                Terminal term{ Terminal::TestDummyMarker{} };
                DummyRenderer renderer{ &term };
                term.Create({ 10, 10 }, scrollback, renderer);

                term.MultiClickSelection(maxCoord, Terminal::SelectionExpansion::Line);
                ValidateSingleRowSelection(term, expected);
            }",49,,140,TerminalCoreUnitTests.<lambda>2,2,,cascadia\UnitTests_TerminalCore\SelectionTest.cpp:<global>
291571,METHOD_REF,3,,"[](LPVOID data) -> DWORD {
            const auto& baton = *reinterpret_cast<Baton*>(data);
            Log::Comment(L""Writing data."");
            baton.pTerm->_stateMachine->ProcessString(baton.text);
            Log::Comment(L""Setting event."");
            SetEvent(baton.done);
            return 0;
        }",9,,97,TerminalApiTest.PrintStringOfSurrogatePairs.<lambda>0,3,,cascadia\UnitTests_TerminalCore\TerminalApiTest.cpp:<global>
295116,METHOD_REF,2,,"[&expectedCallbacks, &callbackWasCalled]() mutable {
        Log::Comment(L""Callback triggered"");
        callbackWasCalled = true;
        expectedCallbacks--;
        VERIFY_IS_GREATER_THAN_OR_EQUAL(expectedCallbacks, 0);
    }",15,,610,TerminalBufferTests.TestCursorNotifications.<lambda>0,2,,cascadia\UnitTests_TerminalCore\TerminalBufferTests.cpp:<global>
295599,METHOD_REF,2,,"[&](const int& v) -> void {
        VERIFY_ARE_EQUAL(42, v);
        handledOne = true;
    }",20,,216,TilWinRtHelpersTests.TestEvent.<lambda>0,2,,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp:<global>
295604,METHOD_REF,1,,[&](int) { handledTwo = true; },13,,223,TilWinRtHelpersTests.TestEvent.<lambda>1,1,,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp:<global>
295629,METHOD_REF,2,,"[&](const winrt::hstring sender, const int& v) -> void {
        VERIFY_ARE_EQUAL(L""sure"", sender);
        VERIFY_ARE_EQUAL(42, v);
        handledOne = true;
    }",20,,234,TilWinRtHelpersTests.TestTypedEvent.<lambda>2,2,,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp:<global>
295634,METHOD_REF,1,,"[&](winrt::hstring, int) { handledTwo = true; }",13,,242,TilWinRtHelpersTests.TestTypedEvent.<lambda>3,1,,cascadia\UnitTests_TerminalCore\TilWinRtHelpersTests.cpp:<global>
295830,METHOD_REF,2,,"[](auto&& dialog) {
        THROW_IF_FAILED(dialog->SetClientGuid(clientGuidImagePicker));
        try
        {
            auto pictureFolderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_PicturesLibrary, KF_FLAG_DEFAULT, nullptr) };
            dialog->SetDefaultFolder(pictureFolderShellItem.get());
        }
        CATCH_LOG(); // non-fatal

#pragma warning(suppress : 26485) // so we can pass in the supportedImageFileTypes without the analyzer complaining
        THROW_IF_FAILED(dialog->SetFileTypes(ARRAYSIZE(supportedImageFileTypes), supportedImageFileTypes));
        THROW_IF_FAILED(dialog->SetFileTypeIndex(1)); // the array is 1-indexed
        THROW_IF_FAILED(dialog->SetDefaultExtension(L""jpg;jpeg;png;bmp;gif;tiff;ico""));
    }",39,,19,OpenImagePicker.<lambda>0,2,,cascadia\WinRTUtils\Utils.cpp:<global>
296212,METHOD_REF,2,,"[weakSelf = this->weak_from_this()]() {
                if (auto self{ weakSelf.lock() })
                {
                    try
                    {
                        self->_func();
                    }
                    CATCH_LOG();

                    SetThreadpoolTimerEx(self->_timer.get(), &self->_delay, 0, 0);
                }
            }",93,,84,ThrottledFunc._leading_edge.<lambda>0,3,,ThrottledFunc
296250,METHOD_REF,2,,"[weakSelf = this->weak_from_this()]() {
                if (auto self{ weakSelf.lock() })
                {
                    try
                    {
                        std::apply(self->_func, self->_storage.take());
                    }
                    CATCH_LOG();
                }
            }",93,,111,ThrottledFunc._trailing_edge.<lambda>1,3,,ThrottledFunc
296261,METHOD_REF,1,,_timer_callback,68,,126,ThrottledFunc._timer_callback,1,,void
296513,METHOD_REF,0,,"[]() -> bool {
        try
        {
            const auto package = winrt::Windows::ApplicationModel::Package::Current();
            return true;
        }
        catch (...)
        {
            return false;
        }
    }",36,,9,IsPackaged.<lambda>0,1,,cascadia\WinRTUtils\inc\WtExeUtils.hpp:<global>
296525,METHOD_REF,0,,"[]() -> bool {
        if (IsPackaged())
        {
            try
            {
                const auto package = winrt::Windows::ApplicationModel::Package::Current();
                const auto id = package.Id();
                const auto name = id.FullName();
                return til::starts_with(name, L""WindowsTerminalDev"");
            }
            CATCH_LOG();
        }

        return true;
    }",36,,36,IsDevBuild.<lambda>1,1,,cascadia\WinRTUtils\inc\WtExeUtils.hpp:<global>
296537,METHOD_REF,0,,"[]() -> std::wstring {
        // First, check a packaged location for the exe. If we've got a package
        // family name, that means we're one of the packaged Dev build, packaged
        // Release build, or packaged Preview build.
        //
        // If we're the preview or release build, there's no way of knowing if the
        // `wt.exe` on the %PATH% is us or not. Fortunately, _our_ execution alias
        // is located in ""%LOCALAPPDATA%\Microsoft\WindowsApps\<our package family
        // name>"", _always_, so we can use that to look up the exe easier.
        if (IsPackaged())
        {
            try
            {
                const auto package = winrt::Windows::ApplicationModel::Package::Current();
                const auto id = package.Id();
                const auto pfn = id.FamilyName();
                if (!pfn.empty())
                {
                    const std::filesystem::path windowsAppsPath{ wil::ExpandEnvironmentStringsW<std::wstring>(LocalAppDa...",33,,67,GetWtExePath.<lambda>2,1,,cascadia\WinRTUtils\inc\WtExeUtils.hpp:<global>
297611,METHOD_REF,1,,"[this]() {
        _CloseRequested(nullptr, nullptr);
    }",83,,319,AppHost.Initialize.<lambda>0,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
297637,METHOD_REF,1,,[this]() { _windowLogic.TitlebarClicked(); },69,,328,AppHost.Initialize.<lambda>1,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
297646,METHOD_REF,1,,[this](bool showOrHide) { _windowLogic.WindowVisibilityChanged(showOrHide); },81,,330,AppHost.Initialize.<lambda>2,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
297805,METHOD_REF,1,,"[this](bool newMaximize) {
        if (_windowLogic)
        {
            _windowLogic.Maximized(newMaximize);
        }
    }",65,,343,AppHost.Initialize.<lambda>3,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
297814,METHOD_REF,1,,"[this]() {
        // Raised when the OS is beginning an update of the app. We will quit,
        // to save our state, before the OS manually kills us.
        Remoting::WindowManager::RequestQuitAll(_peasant);
    }",87,,350,AppHost.Initialize.<lambda>4,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
298084,METHOD_REF,1,,"[this](auto&&,
                                                                              const Remoting::GetWindowLayoutArgs& args) {
        // The peasants are running on separate threads, so they'll need to
        // swap what context they are in to the ui thread to get the actual layout.
        args.WindowLayoutJsonAsync(_GetWindowLayoutAsync());
    }",72,,394,AppHost.Initialize.<lambda>5,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
298147,METHOD_REF,3,,"[this](const bool show) {
            _window->ShowWindowChanged(show);
        }",9,,424,AppHost.Initialize.<lambda>6,4,,cascadia\WindowsTerminal\AppHost.cpp:<global>
298554,METHOD_REF,3,,"[](HMONITOR, HDC, LPRECT, LPARAM lParam) -> BOOL {
            auto intersectWithMonitor = reinterpret_cast<bool*>(lParam);
            *intersectWithMonitor = true;
            // Continue the enumeration
            return FALSE;
        }",38,,652,AppHost._initialResizeAndRepositionWindow.<lambda>7,3,,cascadia\WindowsTerminal\AppHost.cpp:<global>
299657,METHOD_REF,2,,"[](const float a, const float b, const float c) -> til::color {
        return til::color{
            base::saturated_cast<uint8_t>(255.f * std::clamp(a, 0.f, 1.f)),
            base::saturated_cast<uint8_t>(255.f * std::clamp(b, 0.f, 1.f)),
            base::saturated_cast<uint8_t>(255.f * std::clamp(c, 0.f, 1.f))
        };
    }",44,,1205,AppHost._updateFrameColor.<lambda>8,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
299661,METHOD_REF,2,,"[&](const float H) -> til::color {
        float R = abs(H * 6 - 3) - 1;
        float G = 2 - abs(H * 6 - 2);
        float B = 2 - abs(H * 6 - 4);
        return saturateAndToColor(R, G, B);
    }",34,,1215,AppHost._updateFrameColor.<lambda>9,2,,cascadia\WindowsTerminal\AppHost.cpp:<global>
299897,METHOD_REF,2,,[handler]() { handler(); },47,,1310,AppHost._SystemMenuChangeRequested.<lambda>10,3,,cascadia\WindowsTerminal\AppHost.cpp:<global>
304117,METHOD_REF,1,,"[windowThreadProcessId, currentThreadId]() {
                LOG_IF_WIN32_BOOL_FALSE(AttachThreadInput(windowThreadProcessId, currentThreadId, false));
            }",49,,1559,IslandWindow._globalActivateWindow.<lambda>0,2,,cascadia\WindowsTerminal\IslandWindow.cpp:<global>
304596,METHOD_REF,2,,"[&](UINT item, bool enabled) {
        mii.fState = enabled ? MF_ENABLED : MF_DISABLED;
        SetMenuItemInfo(systemMenu, item, FALSE, &mii);
    }",21,,1844,IslandWindow.OpenSystemMenu.<lambda>1,2,,cascadia\WindowsTerminal\IslandWindow.cpp:<global>
304816,METHOD_REF,3,,"[&itemLabel](const std::pair<UINT, SystemMenuItemInfo>& elem) {
        return elem.second.label == itemLabel;
    }",78,,1907,IslandWindow.RemoveFromSystemMenu.<lambda>2,4,,cascadia\WindowsTerminal\IslandWindow.cpp:<global>
305620,METHOD_REF,0,,"[]() {
        WNDCLASSEX wcEx{};
        wcEx.cbSize = sizeof(wcEx);
        wcEx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wcEx.lpszClassName = dragBarClassName;
        wcEx.hbrBackground = reinterpret_cast<HBRUSH>(GetStockObject(BLACK_BRUSH));
        wcEx.hCursor = LoadCursor(nullptr, IDC_ARROW);
        wcEx.lpfnWndProc = &NonClientIslandWindow::_StaticInputSinkWndProc;
        wcEx.hInstance = wil::GetModuleInstanceHandle();
        wcEx.cbWndExtra = sizeof(NonClientIslandWindow*);
        return RegisterClassEx(&wcEx);
    }",37,,73,NonClientIslandWindow.MakeWindow.<lambda>0,1,,cascadia\WindowsTerminal\NonClientIslandWindow.cpp:<global>
306218,METHOD_REF,2,,"[this](auto&&, auto&&) { _OnMaximizeChange(); }",70,,389,NonClientIslandWindow.Initialize.<lambda>1,3,,cascadia\WindowsTerminal\NonClientIslandWindow.cpp:<global>
306683,METHOD_REF,2,,"[&monInfo](const UINT edge) -> bool {
                APPBARDATA data{ 0 };
                data.cbSize = sizeof(data);
                data.uEdge = edge;
                data.rc = monInfo.rcMonitor;
                auto hTaskbar = (HWND)SHAppBarMessage(ABM_GETAUTOHIDEBAREX, &data);
                return hTaskbar != nullptr;
            }",39,,688,NonClientIslandWindow._OnNcCalcSize.<lambda>2,2,,cascadia\WindowsTerminal\NonClientIslandWindow.cpp:<global>
308950,METHOD_REF,1,,"[this](const winrt::Windows::Foundation::IInspectable& /*sender*/,
                                              const winrt::Microsoft::Terminal::Remoting::FindTargetWindowArgs& findWindowArgs) {
        {
            const auto targetWindow = _app.Logic().FindTargetWindow(findWindowArgs.Args().Commandline());
            findWindowArgs.ResultTargetWindow(targetWindow.WindowId());
            findWindowArgs.ResultTargetWindowName(targetWindow.WindowName());
        }
    }",40,,27,WindowEmperor.WindowEmperor.<lambda>0,2,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309331,METHOD_REF,1,,"[weakThis, window]() {
        try
        {
            window->CreateHost();

            if (auto self{ weakThis.lock() })
            {
                self->_windowStartedHandlerPostXAML(window);
            }
            while (window->KeepWarm())
            {
                // Now that the window is ready to go, we can add it to our list of windows,
                // because we know it will be well behaved.
                //
                // Be sure to only modify the list of windows under lock.

                if (auto self{ weakThis.lock() })
                {
                    auto lockedWindows{ self->_windows.lock() };
                    lockedWindows->push_back(window);
                }
                auto removeWindow = wil::scope_exit([&]() {
                    if (auto self{ weakThis.lock() })
                    {
                        self->_removeWindow(window->PeasantID());
                    }
                });

                auto decrementWi...",19,,184,WindowEmperor._createNewWindowThread.<lambda>1,1,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309389,METHOD_REF,2,,"[&](const auto& w) {
        return w->PeasantID() == senderID;
    }",35,,288,WindowEmperor._removeWindow.<lambda>2,3,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309436,METHOD_REF,1,,"[this](auto&&, const Remoting::WindowRequestedArgs& args) {
        _createNewWindowThread(args);
    }",31,,322,WindowEmperor._becomeMonarch.<lambda>3,2,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309446,METHOD_REF,1,,"[this](auto&&, const TerminalApp::SettingsLoadEventArgs& args) {
        if (SUCCEEDED(args.Result()))
        {
            _setupGlobalHotkeys();
            _checkWindowsForNotificationIcon();
        }
    }",34,,332,WindowEmperor._becomeMonarch.<lambda>4,2,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309518,METHOD_REF,1,,[this]() { _saveWindowLayoutsRepeat(); },86,,355,WindowEmperor._becomeMonarch.<lambda>5,2,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
309855,METHOD_REF,0,,"[]() { return RegisterWindowMessageW(L""TaskbarCreated""); }",43,,516,WindowEmperor._messageHandler.<lambda>6,1,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
310513,METHOD_REF,1,,[this](auto& args) { _manager.SummonWindow(args); },46,,773,WindowEmperor._createNotificationIcon.<lambda>7,2,,cascadia\WindowsTerminal\WindowEmperor.cpp:<global>
310849,METHOD_REF,1,,[this]() { _UpdateSettingsRequestedHandlers(); },68,,34,WindowThread.CreateHost.<lambda>0,2,,cascadia\WindowsTerminal\WindowThread.cpp:<global>
310961,METHOD_REF,1,,[this]() { _UpdateSettingsRequestedHandlers(); },76,,114,WindowThread.KeepWarm.<lambda>1,2,,cascadia\WindowsTerminal\WindowThread.cpp:<global>
313806,METHOD_REF,2,,"[](const DeserializationError& k) {
            return k.key.has_value();
        }",36,,536,TerminalAppUnitTests.JsonUtilsTests.NestedExceptionDuringKeyParse.<lambda>0,2,,cascadia\ut_app\JsonUtilsTests.cpp:<global>
316529,METHOD_REF,1,,[&] { UnlockConsole(); },35,,192,PtySignalInputThread._DoClearBuffer.<lambda>0,2,,host\PtySignalInputThread.cpp:<global>
316566,METHOD_REF,1,,[&] { UnlockConsole(); },35,,210,PtySignalInputThread._DoShowHide.<lambda>1,2,,host\PtySignalInputThread.cpp:<global>
316595,METHOD_REF,1,,[&] { UnlockConsole(); },35,,242,PtySignalInputThread._DoSetWindowParent.<lambda>2,2,,host\PtySignalInputThread.cpp:<global>
319616,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,337,VtIo.SetWindowVisibility.<lambda>0,2,,host\VtIo.cpp:<global>
319757,METHOD_REF,1,,[] { UnlockConsole(); },41,,453,VtIo.SendCloseEvent.<lambda>1,2,,host\VtIo.cpp:<global>
320106,METHOD_REF,1,,[&] { UnlockConsole(); },35,,82,ApiRoutines.WriteConsoleOutputAttributeImpl.<lambda>0,2,,host\_output.cpp:<global>
320179,METHOD_REF,1,,[&] { UnlockConsole(); },35,,122,ApiRoutines.WriteConsoleOutputCharacterWImpl.<lambda>1,2,,host\_output.cpp:<global>
320264,METHOD_REF,1,,[&] { UnlockConsole(); },35,,207,ApiRoutines.FillConsoleOutputAttributeImpl.<lambda>2,2,,host\_output.cpp:<global>
320320,METHOD_REF,1,,[&] { UnlockConsole(); },35,,267,ApiRoutines.FillConsoleOutputCharacterWImpl.<lambda>3,2,,host\_output.cpp:<global>
320703,METHOD_REF,3,,[](const auto& wch) { return !IS_GLYPH_CHAR(wch); },60,,188,WriteCharsLegacy.<lambda>0,4,,host\_stream.cpp:<global>
321159,METHOD_REF,1,,[&] { UnlockConsole(); },35,,92,ApiRoutines.AddConsoleAliasWImpl.<lambda>0,2,,host\alias.cpp:<global>
321362,METHOD_REF,1,,[&] { UnlockConsole(); },35,,276,ApiRoutines.GetConsoleAliasWImpl.<lambda>1,2,,host\alias.cpp:<global>
321414,METHOD_REF,1,,[&] { UnlockConsole(); },35,,383,ApiRoutines.GetConsoleAliasesLengthAImpl.<lambda>2,2,,host\alias.cpp:<global>
321430,METHOD_REF,1,,[&] { UnlockConsole(); },35,,407,ApiRoutines.GetConsoleAliasesLengthWImpl.<lambda>3,2,,host\alias.cpp:<global>
321750,METHOD_REF,1,,[&] { UnlockConsole(); },35,,598,ApiRoutines.GetConsoleAliasesWImpl.<lambda>4,2,,host\alias.cpp:<global>
321834,METHOD_REF,1,,[&] { UnlockConsole(); },35,,658,ApiRoutines.GetConsoleAliasExesLengthAImpl.<lambda>5,2,,host\alias.cpp:<global>
321855,METHOD_REF,1,,[&] { UnlockConsole(); },35,,672,ApiRoutines.GetConsoleAliasExesLengthWImpl.<lambda>6,2,,host\alias.cpp:<global>
322030,METHOD_REF,1,,[&] { UnlockConsole(); },35,,811,ApiRoutines.GetConsoleAliasExesWImpl.<lambda>7,2,,host\alias.cpp:<global>
325170,METHOD_REF,3,,"[](auto ch) {
                         return ch < UNICODE_SPACE || (ch > UNICODE_DEL && ch < UNICODE_NBSP);
                     }",67,,228,CONSOLE_INFORMATION.SetTitle.<lambda>0,4,,host\consoleInformation.cpp:<global>
325741,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,93,ImeStartComposition.<lambda>0,2,,host\convarea.cpp:<global>
325775,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,109,ImeEndComposition.<lambda>1,2,,host\convarea.cpp:<global>
326305,METHOD_REF,1,,[&] { UnlockConsole(); },35,,250,ApiRoutines.WriteConsoleInputWImpl.<lambda>0,2,,host\directio.cpp:<global>
326478,METHOD_REF,1,,[&] { UnlockConsole(); },35,,562,ApiRoutines.ReadConsoleOutputAImpl.<lambda>1,2,,host\directio.cpp:<global>
326496,METHOD_REF,1,,[&] { UnlockConsole(); },35,,584,ApiRoutines.ReadConsoleOutputWImpl.<lambda>2,2,,host\directio.cpp:<global>
326523,METHOD_REF,1,,[&] { UnlockConsole(); },35,,708,ApiRoutines.WriteConsoleOutputAImpl.<lambda>3,2,,host\directio.cpp:<global>
326541,METHOD_REF,1,,[&] { UnlockConsole(); },35,,729,ApiRoutines.WriteConsoleOutputWImpl.<lambda>4,2,,host\directio.cpp:<global>
326562,METHOD_REF,1,,[&] { UnlockConsole(); },35,,758,ApiRoutines.ReadConsoleOutputAttributeImpl.<lambda>5,2,,host\directio.cpp:<global>
326583,METHOD_REF,1,,[&] { UnlockConsole(); },35,,779,ApiRoutines.ReadConsoleOutputCharacterAImpl.<lambda>6,2,,host\directio.cpp:<global>
326604,METHOD_REF,1,,[&] { UnlockConsole(); },35,,808,ApiRoutines.ReadConsoleOutputCharacterWImpl.<lambda>7,2,,host\directio.cpp:<global>
327179,METHOD_REF,1,,[&]() { gci.UnlockConsole(); },30,,134,LLVMFuzzerTestOneInput.<lambda>0,2,,host\ft_fuzzer\fuzzmain.cpp:<global>
327389,METHOD_REF,1,,"[&] {
            if (nullptr != szSource)
            {
                delete[] szSource;
                szSource = nullptr;
            }
        }",46,,108,AliasTests.TestGetConsoleAlias.<lambda>0,2,,host\ft_host\API_AliasTests.cpp:<global>
327397,METHOD_REF,1,,"[&] {
            if (nullptr != szExpectedTarget)
            {
                delete[] szExpectedTarget;
                szExpectedTarget = nullptr;
            }
        }",54,,116,AliasTests.TestGetConsoleAlias.<lambda>1,2,,host\ft_host\API_AliasTests.cpp:<global>
327405,METHOD_REF,1,,"[&] {
            if (nullptr != szExeName)
            {
                delete[] szExeName;
                szExeName = nullptr;
            }
        }",47,,124,AliasTests.TestGetConsoleAlias.<lambda>2,2,,host\ft_host\API_AliasTests.cpp:<global>
327708,METHOD_REF,1,,"[&]() {
        if (ptchTargetBuffer != nullptr)
        {
            delete[] ptchTargetBuffer;
        }
    }",45,,139,TestGetConsoleAliasHelperA.<lambda>0,2,,host\ft_host\API_AliasTestsHelpers.hpp:<global>
327747,METHOD_REF,1,,"[&] {
        AddConsoleAliasT(ptszSource, nullptr, ptszExeName);
    }",46,,155,TestGetConsoleAliasHelperA.<lambda>1,2,,host\ft_host\API_AliasTestsHelpers.hpp:<global>
327833,METHOD_REF,1,,"[&] {
        if (ptchExpectedTarget != nullptr)
        {
            delete[] ptchExpectedTarget;
            ptchExpectedTarget = nullptr;
        }
    }",47,,214,TestGetConsoleAliasHelperA.<lambda>2,2,,host\ft_host\API_AliasTestsHelpers.hpp:<global>
331184,METHOD_REF,1,,"[&] {
        Log::Comment(L""Restore original console codepage."");
        SetConsoleOutputCP(uiOriginalCP);
    }",46,,95,FileTests.TestUtf8WriteFileInvalid.<lambda>0,2,,host\ft_host\API_FileTests.cpp:<global>
332634,METHOD_REF,1,,"[&] {
        Log::Comment(L""Background WriteFile scheduled."");
        VERIFY_WIN32_BOOL_SUCCEEDED(WriteFile(hOut, ""def"", 3, nullptr, nullptr), L""Test second write success."");
    }",36,,589,FileTests.TestWriteFileSuspended.<lambda>1,2,,host\ft_host\API_FileTests.cpp:<global>
332836,METHOD_REF,1,,"[&] {
        DWORD dwRead = 0;
        VERIFY_WIN32_BOOL_SUCCEEDED(ReadFile(hIn, &ch, 1, &dwRead, nullptr), L""Read file was successful."");
        VERIFY_ARE_EQUAL(1u, dwRead, L""Verify we read 1 character."");
    }",38,,630,FileTests.TestReadFileBasic.<lambda>2,2,,host\ft_host\API_FileTests.cpp:<global>
332965,METHOD_REF,1,,"[&] {
        DWORD dwRead = 0;
        VERIFY_WIN32_BOOL_SUCCEEDED(ReadFile(hIn, &ch, 1, &dwRead, nullptr), L""Read file was successful."");
        VERIFY_ARE_EQUAL(0u, dwRead, L""We should have read nothing back. It should just return from Ctrl+Z"");
    }",38,,680,FileTests.TestReadFileBasicEmpty.<lambda>3,2,,host\ft_host\API_FileTests.cpp:<global>
333028,METHOD_REF,1,,"[&] {
        DWORD dwRead = 0;
        VERIFY_WIN32_BOOL_SUCCEEDED(ReadFile(hIn, &ch, 1, &dwRead, nullptr), L""Read file was successful."");
        VERIFY_ARE_EQUAL(1u, dwRead, L""Verify we read 1 character."");
    }",38,,707,FileTests.TestReadFileLine.<lambda>4,2,,host\ft_host\API_FileTests.cpp:<global>
335610,METHOD_REF,1,,"[&] {
        while (!fAbortWait)
        {
            doWait.wait();

            if (fAbortWait)
            {
                break;
            }

            HANDLE waits[2];
            waits[0] = doWait.get();
            waits[1] = hIn;
            WaitForMultipleObjects(2, waits, FALSE, INFINITE);

            if (fAbortWait)
            {
                break;
            }

            doneWaiting.SetEvent();
        }
    }",26,,526,InputTests.TestReadWaitOnHandle.<lambda>0,1,,host\ft_host\API_InputTests.cpp:<global>
335618,METHOD_REF,1,,"[&] {
        Log::Comment(L""Tell our background thread to abort waiting, signal it, then wait for it to exit before we finish the test."");
        fAbortWait = true;
        doWait.SetEvent();
        bgThread.join();
    }",35,,550,InputTests.TestReadWaitOnHandle.<lambda>1,2,,host\ft_host\API_InputTests.cpp:<global>
338688,METHOD_REF,3,,"[=]() {
        static auto i = 0;
        return i++ % 2 == 0 ? red : green;
    }",52,,451,OutputTests.WriteConsoleOutputAttributeCheckerTest.<lambda>0,4,,host\ft_host\API_OutputTests.cpp:<global>
340967,METHOD_REF,1,,"[=]() {
        Sleep(500);
        SendMessage(hwnd, WM_CHAR, 27, 0x00010001); // 0x00010001 is the repeat count (1) and scan code (1)
    }",37,,999,WinPtyTestStartSelection.<lambda>1,2,,host\ft_host\API_OutputTests.cpp:<global>
348700,METHOD_REF,1,,"[] {
    if (std_out != nullptr)
    {
        fclose(std_out);
    }
    if (std_in != nullptr)
    {
        fclose(std_in);
    }
    if (nullptr != hJob.get())
    {
        THROW_LAST_ERROR_IF(!TerminateJobObject(hJob.get(), S_OK));
    }
}",41,,28,<lambda>0,2,,host\ft_host\InitTests.cpp:<global>
350759,METHOD_REF,1,,[&] { UnlockConsole(); },35,,1522,ApiRoutines.SetConsoleTitleWImpl.<lambda>0,2,,host\getset.cpp:<global>
352018,METHOD_REF,1,,[&] { UnlockConsole(); },35,,531,ApiRoutines.ExpungeConsoleCommandHistoryWImpl.<lambda>0,2,,host\history.cpp:<global>
352051,METHOD_REF,1,,[&] { UnlockConsole(); },35,,579,ApiRoutines.SetConsoleNumberOfCommandsWImpl.<lambda>1,2,,host\history.cpp:<global>
352072,METHOD_REF,1,,[&] { UnlockConsole(); },35,,611,GetConsoleCommandHistoryLengthImplHelper.<lambda>2,2,,host\history.cpp:<global>
352168,METHOD_REF,1,,[&] { UnlockConsole(); },35,,663,ApiRoutines.GetConsoleCommandHistoryLengthAImpl.<lambda>3,2,,host\history.cpp:<global>
352184,METHOD_REF,1,,[&] { UnlockConsole(); },35,,684,ApiRoutines.GetConsoleCommandHistoryLengthWImpl.<lambda>4,2,,host\history.cpp:<global>
352363,METHOD_REF,1,,[&] { UnlockConsole(); },35,,844,ApiRoutines.GetConsoleCommandHistoryWImpl.<lambda>5,2,,host\history.cpp:<global>
354329,METHOD_REF,3,,"[](const INPUT_RECORD& event) {
        return event.EventType != KEY_EVENT;
    }",68,,352,InputBuffer.FlushAllButKeys.<lambda>0,4,,host\inputBuffer.cpp:<global>
354366,METHOD_REF,1,,[&]() { _vtInputShouldSuppress = false; },53,,499,InputBuffer.Prepend.<lambda>1,2,,host\inputBuffer.cpp:<global>
354463,METHOD_REF,1,,[&]() { _vtInputShouldSuppress = false; },53,,582,InputBuffer.Write.<lambda>2,2,,host\inputBuffer.cpp:<global>
357171,METHOD_REF,1,,"[&] {
        screenInfo.GetTextBuffer().SetCurrentAttributes(attributes);
    }",52,,323,ConhostInternalGetSet.ResizeWindow.<lambda>0,2,,host\outputStream.cpp:<global>
359838,METHOD_REF,3,,[](const auto& wch) { return wch < L' '; },60,,917,COOKED_READ_DATA._writeCharsImpl.<lambda>0,4,,host\readDataCooked.cpp:<global>
377242,METHOD_REF,1,,[&]() { m_state->CleanupReadHandle(); },50,,161,<lambda>0,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
377251,METHOD_REF,1,,[&]() { m_state->CleanupCookedReadData(); },50,,163,<lambda>1,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
377516,METHOD_REF,1,,[&] { gci.UnlockConsole(); },39,,344,<lambda>2,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
377566,METHOD_REF,1,,[&] { gci.UnlockConsole(); },39,,434,<lambda>3,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
377974,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[r""); }",45,,617,<lambda>4,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
377983,METHOD_REF,1,,[&] { gci.UnlockConsole(); },39,,620,<lambda>5,2,,host\ut_host\ApiRoutinesTests.cpp:<global>
382464,METHOD_REF,1,,"[&, previous = codepage]() {
            codepage = previous;
        }",48,,407,<lambda>0,2,,host\ut_host\InputBufferTests.cpp:<global>
385100,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,273,ScreenBufferTests.SingleAlternateBufferCreationTest.<lambda>0,2,,host\ut_host\ScreenBufferTests.cpp:<global>
385223,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,305,ScreenBufferTests.MultipleAlternateBufferCreationTest.<lambda>1,2,,host\ut_host\ScreenBufferTests.cpp:<global>
385389,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,352,ScreenBufferTests.MultipleAlternateBuffersFromMainCreationTest.<lambda>2,2,,host\ut_host\ScreenBufferTests.cpp:<global>
385555,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,397,ScreenBufferTests.AlternateBufferCursorInheritanceTest.<lambda>3,2,,host\ut_host\ScreenBufferTests.cpp:<global>
385658,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },36,,417,ScreenBufferTests.AlternateBufferCursorInheritanceTest.<lambda>4,2,,host\ut_host\ScreenBufferTests.cpp:<global>
387488,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,904,ScreenBufferTests.TestAltBufferTabStops.<lambda>5,2,,host\ut_host\ScreenBufferTests.cpp:<global>
387549,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },36,,918,ScreenBufferTests.TestAltBufferTabStops.<lambda>6,2,,host\ut_host\ScreenBufferTests.cpp:<global>
389097,METHOD_REF,2,,"[&]() {
        return si.GetTextBuffer().GetCursor().GetPosition() - si.GetViewport().Origin();
    }",38,,1301,ScreenBufferTests.VtResizeDECCOLM.<lambda>7,2,,host\ut_host\ScreenBufferTests.cpp:<global>
389101,METHOD_REF,2,,"[&]() {
        const auto margins = _GetRelativeScrollMargins();
        return margins.bottom > margins.top;
    }",26,,1304,ScreenBufferTests.VtResizeDECCOLM.<lambda>8,2,,host\ut_host\ScreenBufferTests.cpp:<global>
390128,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[r""); }",41,,1546,ScreenBufferTests.VtScrollMarginsNewlineColor.<lambda>9,2,,host\ut_host\ScreenBufferTests.cpp:<global>
391225,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[r""); }",41,,1751,ScreenBufferTests.VtNewlineOutsideMargins.<lambda>10,2,,host\ut_host\ScreenBufferTests.cpp:<global>
392730,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2134,ScreenBufferTests.ResizeAltBuffer.<lambda>11,2,,host\ut_host\ScreenBufferTests.cpp:<global>
392921,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2189,ScreenBufferTests.ResizeAltBufferGetScreenBufferInfo.<lambda>12,2,,host\ut_host\ScreenBufferTests.cpp:<global>
392987,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },36,,2205,ScreenBufferTests.ResizeAltBufferGetScreenBufferInfo.<lambda>13,2,,host\ut_host\ScreenBufferTests.cpp:<global>
394102,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2457,ScreenBufferTests.TestAltBufferCursorState.<lambda>14,2,,host\ut_host\ScreenBufferTests.cpp:<global>
394153,METHOD_REF,1,,[&] { alternate.UseMainScreenBuffer(); },40,,2471,ScreenBufferTests.TestAltBufferCursorState.<lambda>15,2,,host\ut_host\ScreenBufferTests.cpp:<global>
394247,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2497,ScreenBufferTests.TestAltBufferVtDispatching.<lambda>16,2,,host\ut_host\ScreenBufferTests.cpp:<global>
394308,METHOD_REF,1,,[&] { alternate.UseMainScreenBuffer(); },40,,2516,ScreenBufferTests.TestAltBufferVtDispatching.<lambda>17,2,,host\ut_host\ScreenBufferTests.cpp:<global>
394640,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,2588,ScreenBufferTests.TestAltBufferRIS.<lambda>18,2,,host\ut_host\ScreenBufferTests.cpp:<global>
396718,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,3052,ScreenBufferTests.SetGlobalColorTable.<lambda>19,2,,host\ut_host\ScreenBufferTests.cpp:<global>
396911,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },36,,3087,ScreenBufferTests.SetGlobalColorTable.<lambda>20,2,,host\ut_host\ScreenBufferTests.cpp:<global>
397254,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,3155,ScreenBufferTests.SetColorTableThreeDigits.<lambda>21,2,,host\ut_host\ScreenBufferTests.cpp:<global>
397445,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },36,,3190,ScreenBufferTests.SetColorTableThreeDigits.<lambda>22,2,,host\ut_host\ScreenBufferTests.cpp:<global>
397659,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,3236,ScreenBufferTests.SetDefaultForegroundColor.<lambda>23,2,,host\ut_host\ScreenBufferTests.cpp:<global>
397831,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,3281,ScreenBufferTests.SetDefaultBackgroundColor.<lambda>24,2,,host\ut_host\ScreenBufferTests.cpp:<global>
398052,METHOD_REF,1,,"[&] {
        renderSettings.SetColorAliasIndex(ColorAlias::DefaultForeground, defaultFg);
        renderSettings.SetColorAliasIndex(ColorAlias::DefaultBackground, defaultBg);
        renderSettings.SetColorAliasIndex(ColorAlias::FrameForeground, frameFg);
        renderSettings.SetColorAliasIndex(ColorAlias::FrameBackground, frameBg);
    }",41,,3331,ScreenBufferTests.AssignColorAliases.<lambda>25,2,,host\ut_host\ScreenBufferTests.cpp:<global>
400676,METHOD_REF,1,,"[&] {
        stateMachine.ProcessString(L""\x1b[r"");
        stateMachine.ProcessString(L""\x1b[s"");
        stateMachine.ProcessString(L""\x1b[?69l"");
    }",41,,3983,ScreenBufferTests.InsertChars.<lambda>26,2,,host\ut_host\ScreenBufferTests.cpp:<global>
401290,METHOD_REF,1,,"[&] {
        stateMachine.ProcessString(L""\x1b[r"");
        stateMachine.ProcessString(L""\x1b[s"");
        stateMachine.ProcessString(L""\x1b[?69l"");
    }",41,,4183,ScreenBufferTests.DeleteChars.<lambda>27,2,,host\ut_host\ScreenBufferTests.cpp:<global>
401898,METHOD_REF,1,,"[&] {
        stateMachine.ProcessString(L""\x1b[r"");
        stateMachine.ProcessString(L""\x1b[s"");
        stateMachine.ProcessString(L""\x1b[?69l"");
    }",41,,4386,ScreenBufferTests.HorizontalScrollOperations.<lambda>28,2,,host\ut_host\ScreenBufferTests.cpp:<global>
404306,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[?69l""); }",41,,4943,ScreenBufferTests.ScrollUpInMargins.<lambda>29,2,,host\ut_host\ScreenBufferTests.cpp:<global>
404563,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[?69l""); }",41,,4998,ScreenBufferTests.ScrollDownInMargins.<lambda>30,2,,host\ut_host\ScreenBufferTests.cpp:<global>
404973,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[?69l""); }",41,,5090,ScreenBufferTests.InsertLinesInMargins.<lambda>31,2,,host\ut_host\ScreenBufferTests.cpp:<global>
405388,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[?69l""); }",41,,5185,ScreenBufferTests.DeleteLinesInMargins.<lambda>32,2,,host\ut_host\ScreenBufferTests.cpp:<global>
405660,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[r""); }",41,,5250,ScreenBufferTests.ReverseLineFeedInMargins.<lambda>33,2,,host\ut_host\ScreenBufferTests.cpp:<global>
405795,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[?69l""); }",41,,5279,ScreenBufferTests.ReverseLineFeedInMargins.<lambda>34,2,,host\ut_host\ScreenBufferTests.cpp:<global>
406181,METHOD_REF,1,,"[&] { stateMachine.ProcessString(L""\x1b[r""); }",45,,5371,ScreenBufferTests.LineFeedEscapeSequences.<lambda>35,2,,host\ut_host\ScreenBufferTests.cpp:<global>
406292,METHOD_REF,1,,"[&] {
            stateMachine.ProcessString(L""\x1b[r"");
            stateMachine.ProcessString(L""\x1b[s"");
            stateMachine.ProcessString(L""\x1b[?69l"");
        }",45,,5396,ScreenBufferTests.LineFeedEscapeSequences.<lambda>36,2,,host\ut_host\ScreenBufferTests.cpp:<global>
406939,METHOD_REF,1,,"[&] { WI_ClearFlag(si.OutputMode, DISABLE_NEWLINE_AUTO_RETURN); }",40,,5551,ScreenBufferTests.SetLineFeedMode.<lambda>37,2,,host\ut_host\ScreenBufferTests.cpp:<global>
407951,METHOD_REF,2,,"[&]() {
        auto offset = 0;
        auto width = si.GetBufferSize().Width();
        for (auto iter = si.GetCellDataAt({}); iter; ++iter, ++offset)
        {
            if (iter->Chars() != L"" "" || iter->TextAttr() != TextAttribute{})
            {
                Log::Comment(NoThrowString().Format(
                    L""Buffer not clear at (X:%d, Y:%d)"",
                    offset % width,
                    offset / width));
                return false;
            }
        }
        return true;
    }",26,,5732,ScreenBufferTests.HardResetBuffer.<lambda>38,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408166,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,5795,ScreenBufferTests.RestoreDownAltBufferWithTerminalScrolling.<lambda>39,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408253,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },40,,5814,ScreenBufferTests.RestoreDownAltBufferWithTerminalScrolling.<lambda>40,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408424,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,5862,ScreenBufferTests.SnapCursorWithTerminalScrolling.<lambda>41,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408873,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,5936,ScreenBufferTests.ClearAlternateBuffer.<lambda>42,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408883,METHOD_REF,2,,"[&](TextBuffer& tbi) {
        // Write text to buffer
        auto& stateMachine = siMain.GetStateMachine();
        auto& cursor = tbi.GetCursor();
        stateMachine.ProcessString(L""foo\nfoo"");
        VERIFY_ARE_EQUAL(cursor.GetPosition().x, 3);
        VERIFY_ARE_EQUAL(cursor.GetPosition().y, 1);
    }",22,,5939,ScreenBufferTests.ClearAlternateBuffer.<lambda>43,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408887,METHOD_REF,2,,"[&](TextBuffer& tbi) {
        // Verify written text in buffer
        {
            auto iter00 = tbi.GetCellDataAt({ 0, 0 });
            auto iter10 = tbi.GetCellDataAt({ 1, 0 });
            auto iter20 = tbi.GetCellDataAt({ 2, 0 });
            auto iter30 = tbi.GetCellDataAt({ 3, 0 });
            auto iter01 = tbi.GetCellDataAt({ 0, 1 });
            auto iter02 = tbi.GetCellDataAt({ 1, 1 });
            auto iter03 = tbi.GetCellDataAt({ 2, 1 });
            VERIFY_ARE_EQUAL(L""f"", iter00->Chars());
            VERIFY_ARE_EQUAL(L""o"", iter10->Chars());
            VERIFY_ARE_EQUAL(L""o"", iter20->Chars());
            VERIFY_ARE_EQUAL(L""\x20"", iter30->Chars());
            VERIFY_ARE_EQUAL(L""f"", iter01->Chars());
            VERIFY_ARE_EQUAL(L""o"", iter02->Chars());
            VERIFY_ARE_EQUAL(L""o"", iter03->Chars());
        }
    }",23,,5948,ScreenBufferTests.ClearAlternateBuffer.<lambda>44,2,,host\ut_host\ScreenBufferTests.cpp:<global>
408946,METHOD_REF,1,,[&] { altBuffer.UseMainScreenBuffer(); },40,,5979,ScreenBufferTests.ClearAlternateBuffer.<lambda>45,2,,host\ut_host\ScreenBufferTests.cpp:<global>
409316,METHOD_REF,2,,"[&](const CharacterAttributes expectedCharAttrs,
                        const std::wstring& vtSequence) {
        auto cursorPos = cursor.GetPosition();

        // Convert the vtSequence to something printable. Lets not set these
        // attrs on the test console
        auto debugString = vtSequence;
        {
            size_t start_pos = 0;
            while ((start_pos = debugString.find(L""\x1b"", start_pos)) != std::string::npos)
            {
                debugString.replace(start_pos, 1, L""\\x1b"");
                start_pos += 4;
            }
        }

        Log::Comment(NoThrowString().Format(
            L""Testing string:\""%s\"""", debugString.c_str()));
        Log::Comment(NoThrowString().Format(
            L""Expecting attrs:0x%02x"", expectedAttrs));

        stateMachine.ProcessString(vtSequence);
        stateMachine.ProcessString(L""X"");

        auto iter = tbi.GetCellDataAt(cursorPos);
        auto currentCharAttrs = iter->TextAttr().GetCharacterAttributes(...",21,,6107,ScreenBufferTests.TestExtendedTextAttributes.<lambda>46,2,,host\ut_host\ScreenBufferTests.cpp:<global>
409855,METHOD_REF,2,,"[&](const TextAttribute attr,
                        const std::wstring& vtSequence) {
        auto cursorPos = cursor.GetPosition();

        // Convert the vtSequence to something printable. Lets not set these
        // attrs on the test console
        auto debugString = vtSequence;
        {
            size_t start_pos = 0;
            while ((start_pos = debugString.find(L""\x1b"", start_pos)) != std::string::npos)
            {
                debugString.replace(start_pos, 1, L""\\x1b"");
                start_pos += 4;
            }
        }

        Log::Comment(NoThrowString().Format(
            L""Testing string:\""%s\"""", debugString.c_str()));
        Log::Comment(NoThrowString().Format(
            L""Expecting attrs:0x%02x"", VerifyOutputTraits<TextAttribute>::ToString(attr).GetBuffer()));

        stateMachine.ProcessString(vtSequence);
        stateMachine.ProcessString(L""X"");

        auto iter = tbi.GetCellDataAt(cursorPos);
        const auto currentAttrs = iter->Tex...",21,,6330,ScreenBufferTests.TestExtendedTextAttributesWithColors.<lambda>47,2,,host\ut_host\ScreenBufferTests.cpp:<global>
411228,METHOD_REF,1,,"[&] {
        stateMachine.ProcessString(L""\x1b[r"");
        stateMachine.ProcessString(L""\x1b[s"");
        stateMachine.ProcessString(L""\x1b[?69l"");
    }",41,,6737,ScreenBufferTests.CursorNextPreviousLine.<lambda>48,2,,host\ut_host\ScreenBufferTests.cpp:<global>
411474,METHOD_REF,1,,"[&] {
        stateMachine.ProcessString(L""\x1b[r"");
        stateMachine.ProcessString(L""\x1b[s"");
        stateMachine.ProcessString(L""\x1b[?69l"");
    }",41,,6809,ScreenBufferTests.CursorPositionRelative.<lambda>49,2,,host\ut_host\ScreenBufferTests.cpp:<global>
412209,METHOD_REF,2,,"[&]() {
        const auto margins = _GetRelativeScrollMargins();
        return margins.bottom > margins.top;
    }",26,,6991,ScreenBufferTests.ScreenAlignmentPattern.<lambda>50,2,,host\ut_host\ScreenBufferTests.cpp:<global>
415169,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,7576,ScreenBufferTests.TestWriteConsoleVTQuirkMode.<lambda>51,2,,host\ut_host\ScreenBufferTests.cpp:<global>
415202,METHOD_REF,2,,"[&](const TextAttribute& expected) {
        const auto& row = mainBuffer.GetTextBuffer().GetRowByOffset(cursor.GetPosition().y);
        auto iter{ row.AttrBegin() };
        iter += cursor.GetPosition().x - 1;
        VERIFY_ARE_EQUAL(expected, *iter);
    }",38,,7588,ScreenBufferTests.TestWriteConsoleVTQuirkMode.<lambda>52,2,,host\ut_host\ScreenBufferTests.cpp:<global>
415736,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& /*viewport*/, const bool /*before*/) {
        const auto width = tb.GetSize().Width();
        Log::Comment(NoThrowString().Format(L""Buffer width: %d"", width));

        auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L'A', red, 5u);
        TestUtils::VerifyLineContains(iter0, L' ', defaultAttrs, static_cast<size_t>(width - 5));

        auto iter1 = tb.GetCellLineDataAt({ 0, 1 });
        TestUtils::VerifyLineContains(iter1, L'B', green, 5u);
        TestUtils::VerifyLineContains(iter1, L' ', defaultAttrs, static_cast<size_t>(width - 5));

        auto iter2 = tb.GetCellLineDataAt({ 0, 2 });
        TestUtils::VerifyLineContains(iter2, L' ', blue, 1u);
        TestUtils::VerifyLineContains(iter2, L'C', blue, 3u);
        TestUtils::VerifyLineContains(iter2, L' ', blue, 1u);
        TestUtils::VerifyLineContains(iter2, L' ', defaultAttrs, static_cast<size_t>(width - 5));

        auto iter3 = tb.GetCellLineDataAt({ 0, 3 });
     ...",25,,7728,ScreenBufferTests.TestReflowEndOfLineColor.<lambda>53,2,,host\ut_host\ScreenBufferTests.cpp:<global>
415949,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& /*viewport*/, const bool before) {
        const auto width = tb.GetSize().Width();
        Log::Comment(NoThrowString().Format(L""Buffer width: %d"", width));

        if (before)
        {
            auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L'A', red, 70u);
            TestUtils::VerifyLineContains(iter0, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter0, L'B', green, 3u);
            TestUtils::VerifyLineContains(iter0, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter0, L' ', defaultAttrs, 5u);
        }
        else
        {
            auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L'A', red, 65u);

            auto iter1 = tb.GetCellLineDataAt({ 0, 1 });
            TestUtils::VerifyLineContains(iter1, L'A', red, 5u);
            TestUtils::VerifyLineContains(iter1, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter1, L'B', green, 3u);
            TestUtils::Verif...",25,,7800,ScreenBufferTests.TestReflowSmallerLongLineWithColor.<lambda>54,2,,host\ut_host\ScreenBufferTests.cpp:<global>
416168,METHOD_REF,2,,"[&](const TextBuffer& tb, const til::rect& /*viewport*/, const bool before) {
        const auto width = tb.GetSize().Width();
        Log::Comment(NoThrowString().Format(L""Buffer width: %d"", width));

        if (before)
        {
            auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L'A', red, 80u);

            auto iter1 = tb.GetCellLineDataAt({ 0, 1 });
            TestUtils::VerifyLineContains(iter1, L'A', red, 5u);
            TestUtils::VerifyLineContains(iter1, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter1, L'B', green, 3u);
            TestUtils::VerifyLineContains(iter1, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter1, L' ', defaultAttrs, static_cast<size_t>(width - 10));
        }
        else
        {
            auto iter0 = TestUtils::VerifyLineContains(tb, { 0, 0 }, L'A', red, 85u);
            TestUtils::VerifyLineContains(iter0, L' ', green, 1u);
            TestUtils::VerifyLineContains(iter0, L'B', green, 3u);...",25,,7879,ScreenBufferTests.TestReflowBiggerLongLineWithColor.<lambda>55,2,,host\ut_host\ScreenBufferTests.cpp:<global>
416287,METHOD_REF,1,,[&] { gci.UnlockConsole(); },35,,7943,ScreenBufferTests.TestDeferredMainBufferResize.<lambda>56,2,,host\ut_host\ScreenBufferTests.cpp:<global>
416345,METHOD_REF,1,,"[](auto&&, auto&&) -> bool { return true; }",41,,7962,ScreenBufferTests.TestDeferredMainBufferResize.<lambda>57,2,,host\ut_host\ScreenBufferTests.cpp:<global>
420494,METHOD_REF,3,,[](wil::ResultException& e) { return e.GetErrorCode() == E_INVALIDARG; },98,,531,TextBufferIteratorTests.ConstructedNoLimit.<lambda>0,3,,host\ut_host\TextBufferIteratorTests.cpp:<global>
420624,METHOD_REF,3,,[](wil::ResultException& e) { return e.GetErrorCode() == E_INVALIDARG; },28,,573,TextBufferIteratorTests.ConstructedLimits.<lambda>1,3,,host\ut_host\TextBufferIteratorTests.cpp:<global>
420668,METHOD_REF,3,,[](wil::ResultException& e) { return e.GetErrorCode() == E_INVALIDARG; },28,,582,TextBufferIteratorTests.ConstructedLimits.<lambda>2,3,,host\ut_host\TextBufferIteratorTests.cpp:<global>
420937,METHOD_REF,2,,"[&](bool expected) {
        auto& Row = textBuffer.GetRowByOffset(0);

        if (expected)
        {
            VERIFY_IS_TRUE(Row.WasWrapForced());
        }
        else
        {
            VERIFY_IS_FALSE(Row.WasWrapForced());
        }
    }",23,,209,TextBufferTests.TestWrapThroughWriteLine.<lambda>0,2,,host\ut_host\TextBufferTests.cpp:<global>
433578,METHOD_REF,1,,"[&]() {
        gci.UnlockConsole();
    }",42,,475,VtIoTests.BasicAnonymousPipeOpeningWithSignalChannelTest.<lambda>0,2,,host\ut_host\VtIoTests.cpp:<global>
436989,METHOD_REF,2,,"[&]() {
            VERIFY_IS_FALSE(engine._firstPaint);
        }",27,,104,VerifyFirstPaint.<lambda>0,2,,host\ut_host\VtRendererTests.cpp:<global>
437460,METHOD_REF,2,,"[&]() {
        VERIFY_IS_TRUE(engine->_invalidMap.all());
    }",24,,236,VtRendererTest.Xterm256TestInvalidate.<lambda>1,2,,host\ut_host\VtRendererTests.cpp:<global>
437487,METHOD_REF,2,,"[&]() {
        VERIFY_IS_TRUE(engine->_invalidMap.one());
        VERIFY_ARE_EQUAL(invalid, *(engine->_invalidMap.begin()));
    }",24,,244,VtRendererTest.Xterm256TestInvalidate.<lambda>2,2,,host\ut_host\VtRendererTests.cpp:<global>
437513,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one down, only top line is invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 1;

        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(1u, runs.size());
        VERIFY_ARE_EQUAL(invalid, runs.front());
        qExpectedInput.push_back(""\x1b[H""); // Go Home
        qExpectedInput.push_back(""\x1b[L""); // insert a line

        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,253,VtRendererTest.Xterm256TestInvalidate.<lambda>3,2,,host\ut_host\VtRendererTests.cpp:<global>
437526,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three down, only top 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);
        // We would expect a CUP here, but the cursor is already at the home position
        qExpectedInput.push_back(""\x1b[3L""); // insert 3 lines
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,271,VtRendererTest.Xterm256TestInvalidate.<lambda>4,2,,host\ut_host\VtRendererTests.cpp:<global>
437539,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one up, only bottom line is invalid. ----""));
        invalid = view.ToExclusive();
        invalid.top = invalid.bottom - 1;

        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(1u, runs.size());
        VERIFY_ARE_EQUAL(invalid, runs.front());

        qExpectedInput.push_back(""\x1b[32;1H""); // Bottom of buffer
        qExpectedInput.push_back(""\n""); // Scroll down once
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,295,VtRendererTest.Xterm256TestInvalidate.<lambda>5,2,,host\ut_host\VtRendererTests.cpp:<global>
437552,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three up, only bottom 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.top = invalid.bottom - 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);

        // We would expect a CUP here, but we're already at the bottom from the last call.
        qExpectedInput.push_back(""\n\n\n""); // Scroll down three times
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,312,VtRendererTest.Xterm256TestInvalidate.<lambda>6,2,,host\ut_host\VtRendererTests.cpp:<global>
437583,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three down, only top 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);

        qExpectedInput.push_back(""\x1b[H""); // Go to home
        qExpectedInput.push_back(""\x1b[3L""); // insert 3 lines
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,342,VtRendererTest.Xterm256TestInvalidate.<lambda>7,2,,host\ut_host\VtRendererTests.cpp:<global>
437636,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one down and one up, nothing should change ----""
            L"" But it still does for now MSFT:14169294""));

        const auto runs = engine->_invalidMap.runs();
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // only the bottom line should be dirty.
        // When we scrolled down, the bitmap looked like this:
        // 1111
        // 0000
        // 0000
        // 0000
        // And then we scrolled up and the top line fell off and a bottom
        // line was filled in like this:
        // 0000
        // 0000
        // 0000
        // 1111
        const til::rect expected{ til::point{ view.Left(), view.BottomInclusive() }, til::size{ view.Width(), 1 } };
        VERIFY_ARE_EQUAL(expected, invalidRect);

        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,374,VtRendererTest.Xterm256TestInvalidate.<lambda>8,2,,host\ut_host\VtRendererTests.cpp:<global>
437743,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""----Change only the BG----""));
        qExpectedInput.push_back(""\x1b[48;2;7;8;9m"");
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({ 0x00030201, 0x00090807 },
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));

        Log::Comment(NoThrowString().Format(
            L""----Change only the FG----""));
        qExpectedInput.push_back(""\x1b[38;2;10;11;12m"");
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({ 0x000c0b0a, 0x00090807 },
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
    }",24,,432,VtRendererTest.Xterm256TestColors.<lambda>9,2,,host\ut_host\VtRendererTests.cpp:<global>
437747,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure that color setting persists across EndPaint/StartPaint""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({ 0x000c0b0a, 0x00090807 },
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1); // This will make sure nothing was written to the callback
    }",24,,452,VtRendererTest.Xterm256TestColors.<lambda>10,2,,host\ut_host\VtRendererTests.cpp:<global>
437776,METHOD_REF,2,,"[&]() {
        TextAttribute textAttributes;

        Log::Comment(NoThrowString().Format(
            L""----Change only the BG----""));
        textAttributes.SetIndexedBackground(TextColor::DARK_RED);
        qExpectedInput.push_back(""\x1b[41m""); // Background DARK_RED
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));

        Log::Comment(NoThrowString().Format(
            L""----Change only the FG----""));
        textAttributes.SetIndexedForeground(TextColor::DARK_WHITE);
        qExpectedInput.push_back(""\x1b[37m""); // Foreground DARK_WHITE
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                        ...",24,,478,VtRendererTest.Xterm256TestColors.<lambda>11,2,,host\ut_host\VtRendererTests.cpp:<global>
437780,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure that color setting persists across EndPaint/StartPaint""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({},
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1); // This will make sure nothing was written to the callback
    }",24,,572,VtRendererTest.Xterm256TestColors.<lambda>12,2,,host\ut_host\VtRendererTests.cpp:<global>
437902,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""----Change the color----""));
        qExpectedInput.push_back(""\x1b[58:2::7:8:9m"");
        textAttributes.SetUnderlineColor(RGB(7, 8, 9));
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
    }",24,,619,VtRendererTest.Xterm256TestITUColors.<lambda>13,2,,host\ut_host\VtRendererTests.cpp:<global>
437906,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure that color setting persists across EndPaint/StartPaint""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1); // This will make sure nothing was written to the callback
    }",24,,631,VtRendererTest.Xterm256TestITUColors.<lambda>14,2,,host\ut_host\VtRendererTests.cpp:<global>
437910,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""----Change the UL color to a 256-color index----""));
        textAttributes.SetUnderlineColor(TextColor{ TextColor::DARK_RED, true });
        qExpectedInput.push_back(""\x1b[58:5:1m"");
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));

        // to test the sequence for the default underline color, temporarily modify fg and bg to be something else.
        textAttributes.SetForeground(RGB(9, 10, 11));
        qExpectedInput.push_back(""\x1b[38;2;9;10;11m"");
        textAttributes.SetBackground(RGB(5, 6, 7));
        qExpectedInput.push_back(""\x1b[48;2;5;6;7m"");

        Log::Comment(NoThrowString().Format(
            L""----Change only the U...",24,,643,VtRendererTest.Xterm256TestITUColors.<lambda>15,2,,host\ut_host\VtRendererTests.cpp:<global>
437914,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure that color setting persists across EndPaint/StartPaint""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({},
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1); // This will make sure nothing was written to the callback
    }",24,,681,VtRendererTest.Xterm256TestITUColors.<lambda>16,2,,host\ut_host\VtRendererTests.cpp:<global>
437989,METHOD_REF,2,,"[&]() {
        qExpectedInput.push_back(""\x1b[2;2H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 1, 1 }));

        Log::Comment(NoThrowString().Format(
            L""----Only move Y coord----""));
        qExpectedInput.push_back(""\x1b[31;2H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 1, 30 }));

        Log::Comment(NoThrowString().Format(
            L""----Only move X coord----""));
        qExpectedInput.push_back(""\x1b[29C"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 30, 30 }));

        Log::Comment(NoThrowString().Format(
            L""----Sending the same move sends nothing----""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 30, 30 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);

        Log::Comment(NoThrowString().Format(
            L""----moving home sends a simple sequence----""));
        qExpectedInput.push_back(""\x1b[H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 0, 0 }));

       ...",24,,707,VtRendererTest.Xterm256TestCursor.<lambda>17,2,,host\ut_host\VtRendererTests.cpp:<global>
437993,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Sending the same move across paint calls sends nothing.""
            L""The cursor's last \""real\"" position was 0,0""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 0, 1 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);

        Log::Comment(NoThrowString().Format(
            L""Paint some text at 0,0, then try moving the cursor to where it currently is.""));
        qExpectedInput.push_back(""\x1b[1C"");
        qExpectedInput.push_back(""asdfghjkl"");

        const auto line = L""asdfghjkl"";
        const unsigned char rgWidths[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };

        std::vector<Cluster> clusters;
        for (size_t i = 0; i < wcslen(line); i++)
        {
            clusters.emplace_back(std::wstring_view{ &line[i], 1 }, static_cast<til::CoordType>(rgWidths[i]));
        }

        VERIFY_SUCCEEDED(engine->PaintBufferLine({ clusters.data(), clusters...",24,,758,VtRendererTest.Xterm256TestCursor.<lambda>18,2,,host\ut_host\VtRendererTests.cpp:<global>
437997,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Sending the same move across paint calls sends nothing.""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 10, 1 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);
    }",24,,789,VtRendererTest.Xterm256TestCursor.<lambda>19,2,,host\ut_host\VtRendererTests.cpp:<global>
438301,METHOD_REF,2,,"[&]() {
        // Merge the ""on"" sequences into expected input.
        std::copy(onSequences.cbegin(), onSequences.cend(), std::back_inserter(qExpectedInput));
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs(desiredAttrs));
    }",24,,884,VtRendererTest.Xterm256TestExtendedAttributes.<lambda>20,2,,host\ut_host\VtRendererTests.cpp:<global>
438314,METHOD_REF,2,,"[&]() {
        std::copy(offSequences.cbegin(), offSequences.cend(), std::back_inserter(qExpectedInput));
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs({}));
    }",24,,892,VtRendererTest.Xterm256TestExtendedAttributes.<lambda>21,2,,host\ut_host\VtRendererTests.cpp:<global>
438327,METHOD_REF,2,,"[&]() {
        std::copy(onSequences.cbegin(), onSequences.cend(), std::back_inserter(qExpectedInput));
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs(desiredAttrs));
    }",24,,899,VtRendererTest.Xterm256TestExtendedAttributes.<lambda>22,2,,host\ut_host\VtRendererTests.cpp:<global>
438833,METHOD_REF,2,,"[&]() {
        attrs.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);
        qExpectedInput.push_back(""\x1b[21m"");
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs(attrs));
    }",24,,1028,VtRendererTest.Xterm256TestDoublyUnderlinedResetBeforeSettingStyle.<lambda>23,2,,host\ut_host\VtRendererTests.cpp:<global>
438846,METHOD_REF,2,,"[&]() {
        attrs.SetUnderlineStyle(UnderlineStyle::CurlyUnderlined);
        qExpectedInput.push_back(""\x1b[24m"");
        qExpectedInput.push_back(""\x1b[4:3m"");
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs(attrs));
    }",24,,1036,VtRendererTest.Xterm256TestDoublyUnderlinedResetBeforeSettingStyle.<lambda>24,2,,host\ut_host\VtRendererTests.cpp:<global>
438859,METHOD_REF,2,,"[&]() {
        attrs.SetUnderlineStyle(UnderlineStyle::NoUnderline);
        qExpectedInput.push_back(""\x1b[24m"");
        VERIFY_SUCCEEDED(engine->_UpdateExtendedAttrs(attrs));
    }",24,,1045,VtRendererTest.Xterm256TestDoublyUnderlinedResetBeforeSettingStyle.<lambda>25,2,,host\ut_host\VtRendererTests.cpp:<global>
438940,METHOD_REF,2,,"[&]() {
        VERIFY_IS_TRUE(engine->_invalidMap.all());
    }",24,,1068,VtRendererTest.XtermTestInvalidate.<lambda>26,2,,host\ut_host\VtRendererTests.cpp:<global>
438967,METHOD_REF,2,,"[&]() {
        VERIFY_IS_TRUE(engine->_invalidMap.one());
        VERIFY_ARE_EQUAL(invalid, *(engine->_invalidMap.begin()));
    }",24,,1076,VtRendererTest.XtermTestInvalidate.<lambda>27,2,,host\ut_host\VtRendererTests.cpp:<global>
438993,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one down, only top line is invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 1;

        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(1u, runs.size());
        VERIFY_ARE_EQUAL(invalid, runs.front());

        qExpectedInput.push_back(""\x1b[H""); // Go Home
        qExpectedInput.push_back(""\x1b[L""); // insert a line
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1085,VtRendererTest.XtermTestInvalidate.<lambda>28,2,,host\ut_host\VtRendererTests.cpp:<global>
439006,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three down, only top 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);
        // We would expect a CUP here, but the cursor is already at the home position
        qExpectedInput.push_back(""\x1b[3L""); // insert 3 lines
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1102,VtRendererTest.XtermTestInvalidate.<lambda>29,2,,host\ut_host\VtRendererTests.cpp:<global>
439019,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one up, only bottom line is invalid. ----""));
        invalid = view.ToExclusive();
        invalid.top = invalid.bottom - 1;

        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(1u, runs.size());
        VERIFY_ARE_EQUAL(invalid, runs.front());

        qExpectedInput.push_back(""\x1b[32;1H""); // Bottom of buffer
        qExpectedInput.push_back(""\n""); // Scroll down once
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1126,VtRendererTest.XtermTestInvalidate.<lambda>30,2,,host\ut_host\VtRendererTests.cpp:<global>
439032,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three up, only bottom 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.top = invalid.bottom - 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);

        // We would expect a CUP here, but we're already at the bottom from the last call.
        qExpectedInput.push_back(""\n\n\n""); // Scroll down three times
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1143,VtRendererTest.XtermTestInvalidate.<lambda>31,2,,host\ut_host\VtRendererTests.cpp:<global>
439063,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled three down, only top 3 lines are invalid. ----""));
        invalid = view.ToExclusive();
        invalid.bottom = 3;

        // we should have 3 runs and build a rectangle out of them
        const auto runs = engine->_invalidMap.runs();
        VERIFY_ARE_EQUAL(3u, runs.size());
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // verify the rect matches the invalid one.
        VERIFY_ARE_EQUAL(invalid, invalidRect);

        qExpectedInput.push_back(""\x1b[H""); // Go to home
        qExpectedInput.push_back(""\x1b[3L""); // insert 3 lines
        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1173,VtRendererTest.XtermTestInvalidate.<lambda>32,2,,host\ut_host\VtRendererTests.cpp:<global>
439116,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""---- Scrolled one down and one up, nothing should change ----""
            L"" But it still does for now MSFT:14169294""));

        const auto runs = engine->_invalidMap.runs();
        auto invalidRect = runs.front();
        for (size_t i = 1; i < runs.size(); ++i)
        {
            invalidRect |= runs[i];
        }

        // only the bottom line should be dirty.
        // When we scrolled down, the bitmap looked like this:
        // 1111
        // 0000
        // 0000
        // 0000
        // And then we scrolled up and the top line fell off and a bottom
        // line was filled in like this:
        // 0000
        // 0000
        // 0000
        // 1111
        const til::rect expected{ til::point{ view.Left(), view.BottomInclusive() }, til::size{ view.Width(), 1 } };
        VERIFY_ARE_EQUAL(expected, invalidRect);

        VERIFY_SUCCEEDED(engine->ScrollFrame());
    }",24,,1205,VtRendererTest.XtermTestInvalidate.<lambda>33,2,,host\ut_host\VtRendererTests.cpp:<global>
439217,METHOD_REF,2,,"[&]() {
        TextAttribute textAttributes;

        Log::Comment(NoThrowString().Format(
            L""----Change only the BG----""));
        textAttributes.SetIndexedBackground(TextColor::DARK_RED);
        qExpectedInput.push_back(""\x1b[41m""); // Background DARK_RED
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));

        Log::Comment(NoThrowString().Format(
            L""----Change only the FG----""));
        textAttributes.SetIndexedForeground(TextColor::DARK_WHITE);
        qExpectedInput.push_back(""\x1b[37m""); // Foreground DARK_WHITE
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes(textAttributes,
                                                      renderSettings,
                        ...",24,,1262,VtRendererTest.XtermTestColors.<lambda>34,2,,host\ut_host\VtRendererTests.cpp:<global>
439221,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure that color setting persists across EndPaint/StartPaint""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->UpdateDrawingBrushes({},
                                                      renderSettings,
                                                      &renderData,
                                                      false,
                                                      false));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1); // This will make sure nothing was written to the callback
    }",24,,1358,VtRendererTest.XtermTestColors.<lambda>35,2,,host\ut_host\VtRendererTests.cpp:<global>
439297,METHOD_REF,2,,"[&]() {
        qExpectedInput.push_back(""\x1b[2;2H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 1, 1 }));

        Log::Comment(NoThrowString().Format(
            L""----Only move Y coord----""));
        qExpectedInput.push_back(""\x1b[31;2H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 1, 30 }));

        Log::Comment(NoThrowString().Format(
            L""----Only move X coord----""));
        qExpectedInput.push_back(""\x1b[29C"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 30, 30 }));

        Log::Comment(NoThrowString().Format(
            L""----Sending the same move sends nothing----""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 30, 30 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);

        Log::Comment(NoThrowString().Format(
            L""----moving home sends a simple sequence----""));
        qExpectedInput.push_back(""\x1b[H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 0, 0 }));

       ...",24,,1384,VtRendererTest.XtermTestCursor.<lambda>36,2,,host\ut_host\VtRendererTests.cpp:<global>
439301,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Sending the same move across paint calls sends nothing.""
            L""The cursor's last \""real\"" position was 0,0""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 0, 1 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);

        Log::Comment(NoThrowString().Format(
            L""Paint some text at 0,0, then try moving the cursor to where it currently is.""));
        qExpectedInput.push_back(""\x1b[1C"");
        qExpectedInput.push_back(""asdfghjkl"");

        const auto line = L""asdfghjkl"";
        const unsigned char rgWidths[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };

        std::vector<Cluster> clusters;
        for (size_t i = 0; i < wcslen(line); i++)
        {
            clusters.emplace_back(std::wstring_view{ &line[i], 1 }, static_cast<til::CoordType>(rgWidths[i]));
        }

        VERIFY_SUCCEEDED(engine->PaintBufferLine({ clusters.data(), clusters...",24,,1435,VtRendererTest.XtermTestCursor.<lambda>37,2,,host\ut_host\VtRendererTests.cpp:<global>
439305,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Sending the same move across paint calls sends nothing.""));
        qExpectedInput.push_back(EMPTY_CALLBACK_SENTINEL);
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 10, 1 }));
        WriteCallback(EMPTY_CALLBACK_SENTINEL, 1);
    }",24,,1466,VtRendererTest.XtermTestCursor.<lambda>38,2,,host\ut_host\VtRendererTests.cpp:<global>
439676,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Make sure the cursor is at 0,0""));
        qExpectedInput.push_back(""\x1b[H"");
        VERIFY_SUCCEEDED(engine->_MoveCursor({ 0, 0 }));
    }",24,,1555,VtRendererTest.TestWrapping.<lambda>39,2,,host\ut_host\VtRendererTests.cpp:<global>
439680,METHOD_REF,2,,"[&]() {
        Log::Comment(NoThrowString().Format(
            L""Painting a line that wrapped, then painting another line, and ""
            L""making sure we don't manually move the cursor between those paints.""));
        qExpectedInput.push_back(""asdfghjkl"");
        // TODO: Undoing this behavior due to 18123777. Will come back in MSFT:16485846
        qExpectedInput.push_back(""\r\n"");
        qExpectedInput.push_back(""zxcvbnm,."");

        const auto line1 = L""asdfghjkl"";
        const auto line2 = L""zxcvbnm,."";
        const unsigned char rgWidths[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };

        std::vector<Cluster> clusters1;
        for (size_t i = 0; i < wcslen(line1); i++)
        {
            clusters1.emplace_back(std::wstring_view{ &line1[i], 1 }, static_cast<til::CoordType>(rgWidths[i]));
        }
        std::vector<Cluster> clusters2;
        for (size_t i = 0; i < wcslen(line2); i++)
        {
            clusters2.emplace_back(std::wstring_view{ &line2[i], 1 }, stati...",24,,1562,VtRendererTest.TestWrapping.<lambda>40,2,,host\ut_host\VtRendererTests.cpp:<global>
439770,METHOD_REF,2,,"[&]() {
        VERIFY_IS_FALSE(engine->_firstPaint);
        VERIFY_IS_FALSE(engine->_suppressResizeRepaint);
    }",24,,1611,VtRendererTest.TestResize.<lambda>41,2,,host\ut_host\VtRendererTests.cpp:<global>
439801,METHOD_REF,2,,"[&]() {
        VERIFY_IS_TRUE(engine->_invalidMap.all());
        VERIFY_IS_FALSE(engine->_firstPaint);
        VERIFY_IS_FALSE(engine->_suppressResizeRepaint);
    }",24,,1623,VtRendererTest.TestResize.<lambda>42,2,,host\ut_host\VtRendererTests.cpp:<global>
439888,METHOD_REF,2,,"[&]() {
        VERIFY_IS_FALSE(engine->_nextCursorIsVisible);
        VERIFY_IS_FALSE(engine->_needToDisableCursor);

        Log::Comment(NoThrowString().Format(L""Make sure the cursor is at 0,0""));
        qExpectedInput.push_back(""\x1b[H"");
        VERIFY_SUCCEEDED(engine->PaintCursor(options));

        VERIFY_IS_TRUE(engine->_nextCursorIsVisible);
        VERIFY_IS_TRUE(engine->_needToDisableCursor);

        // GH#12401:
        // The other tests verify that the cursor is explicitly hidden on the
        // first frame (VerifyFirstPaint). This test on the other hand does
        // the opposite by calling PaintCursor() during the first paint cycle.
        qExpectedInput.push_back(""\x1b[?25h"");
    }",24,,1649,VtRendererTest.TestCursorVisibility.<lambda>43,2,,host\ut_host\VtRendererTests.cpp:<global>
439900,METHOD_REF,2,,"[&]() {
        VERIFY_IS_FALSE(engine->_nextCursorIsVisible);
        VERIFY_IS_FALSE(engine->_needToDisableCursor);

        Log::Comment(NoThrowString().Format(L""If we just paint the cursor again at the same position, the cursor should not need to be disabled""));
        VERIFY_SUCCEEDED(engine->PaintCursor(options));

        VERIFY_IS_TRUE(engine->_nextCursorIsVisible);
        VERIFY_IS_FALSE(engine->_needToDisableCursor);
    }",24,,1673,VtRendererTest.TestCursorVisibility.<lambda>44,2,,host\ut_host\VtRendererTests.cpp:<global>
439912,METHOD_REF,2,,"[&]() {
        VERIFY_IS_FALSE(engine->_nextCursorIsVisible);
        VERIFY_IS_FALSE(engine->_needToDisableCursor);

        Log::Comment(NoThrowString().Format(L""Move the cursor to 2,2""));
        qExpectedInput.push_back(""\x1b[3;3H"");

        options.coordCursor = { 2, 2 };

        VERIFY_SUCCEEDED(engine->PaintCursor(options));

        VERIFY_IS_TRUE(engine->_nextCursorIsVisible);
        VERIFY_IS_TRUE(engine->_needToDisableCursor);

        // Because _needToDisableCursor is true, we'll insert a ?25l at the
        // start of the frame. Unfortunately, we can't test to make sure that
        // it's there, but we can ensure that the matching ?25h is printed:
        qExpectedInput.push_back(""\x1b[?25h"");
    }",24,,1690,VtRendererTest.TestCursorVisibility.<lambda>45,2,,host\ut_host\VtRendererTests.cpp:<global>
439933,METHOD_REF,2,,"[&]() {
        VERIFY_IS_FALSE(engine->_nextCursorIsVisible);
        VERIFY_IS_FALSE(engine->_needToDisableCursor);

        qExpectedInput.push_back(""\x1b[?25l"");
    }",24,,1716,VtRendererTest.TestCursorVisibility.<lambda>46,2,,host\ut_host\VtRendererTests.cpp:<global>
441495,METHOD_REF,2,,"[&escaped](const std::string& search, const std::string& replace) {
            size_t pos = escaped.find(search, 0);
            while (pos != std::string::npos)
            {
                escaped.replace(pos, search.length(), replace);
                pos = escaped.find(search, pos + replace.length());
            }
        }",26,,123,TestUtils.ReplaceEscapes.<lambda>0,2,,TestUtils
447135,METHOD_REF,1,,"[&] {
                if (currentEnvVars)
                {
                    FreeEnvironmentStringsW(currentEnvVars);
                    currentEnvVars = nullptr;
                }
            }",51,,409,til.env.from_current_environment.<lambda>0,2,,til.env
454230,METHOD_REF,2,,"[](auto&& beg, auto&& end) {
                std::uninitialized_value_construct(beg, end);
            }",39,,580,til.small_vector.resize.<lambda>0,2,,til.small_vector
454238,METHOD_REF,2,,"[&](auto&& beg, auto&& end) {
                std::uninitialized_fill(beg, end, value);
            }",39,,587,til.small_vector.resize.<lambda>1,2,,til.small_vector
454403,METHOD_REF,3,,"[&](auto&& it) noexcept(std::is_nothrow_copy_constructible_v<T>) {
                std::construct_at(&*it, value);
            }",44,,664,til.small_vector.insert.<lambda>2,3,,til.small_vector
454413,METHOD_REF,3,,"[&](auto&& it) noexcept {
                std::construct_at(&*it, std::move(value));
            }",44,,674,til.small_vector.insert.<lambda>3,3,,til.small_vector
454423,METHOD_REF,3,,"[&](auto&& it) noexcept(std::is_nothrow_copy_constructible_v<T>) {
#pragma warning(suppress : 26447) // The function is declared 'noexcept' but calls function '...' which may throw exceptions (f.6).
                std::uninitialized_fill_n(it, count, value);
            }",48,,682,til.small_vector.insert.<lambda>4,3,,til.small_vector
454438,METHOD_REF,3,,"[&](auto&& it) noexcept(std::is_nothrow_constructible_v<T, decltype(*first)>) {
#pragma warning(suppress : 26447) // The function is declared 'noexcept' but calls function '...' which may throw exceptions (f.6).
                std::uninitialized_copy(first, last, it);
            }",69,,692,til.small_vector.insert.<lambda>5,3,,til.small_vector
455579,METHOD_REF,2,,[&]() { return _value.load(order) != old; },32,,77,til.spsc.details.atomic_size_type.wait.<lambda>0,3,,til.spsc.details.atomic_size_type
456700,METHOD_REF,3,,"[&](const auto& p) {
                return p.first < key;
            }",82,,49,til.static_map.find.<lambda>0,4,,til.static_map
457067,METHOD_REF,2,,"[](auto ch) {
            // This lookup is branchless: It always checks the filter, but throws
            // away the result if ch >= 128. This is faster than using `&&` (branchy).
            return ((til::at(details::pathFilter, ch & 127) & F_) != 0) & (ch < 128);
        }",28,,56,til.clean_filename.<lambda>0,3,,inc\til\string.hpp:<global>
457081,METHOD_REF,2,,"[](auto ch) {
            return ((til::at(details::pathFilter, ch & 127) & _P) != 0) & (ch < 128);
        }",28,,67,til.clean_path.<lambda>1,3,,inc\til\string.hpp:<global>
457106,METHOD_REF,3,,"[](auto&& ch) {
            return ((til::at(details::pathFilter, ch & 127) & _P) != 0) & (ch < 128);
        }",61,,78,"std.any_of(std.begin(str), std.end(str), [](auto&& ch) {
            return ((til.at(details.pathFilter, ch & 127) & _P) != 0) & (ch < 128);
        }).<lambda>2",4,,inc\til\string.hpp:<global>
462008,METHOD_REF,1,,"[]() noexcept {
            s_conIoSrvComm.reset(nullptr);
        }",52,,32,ConIoSrvComm.GetConIoSrvComm..<lambda>1,2,,interactivity\onecore\ConIoSrvComm.cpp:<global>
462045,METHOD_REF,0,,"[]() {
        s_conIoSrvComm = std::make_unique<ConIoSrvComm>();
        ServiceLocator::SetOneCoreTeardownFunction([]() noexcept {
            s_conIoSrvComm.reset(nullptr);
        });
        return true;
    }",31,,30,ConIoSrvComm.GetConIoSrvComm.<lambda>0,1,,interactivity\onecore\ConIoSrvComm.cpp:<global>
463451,METHOD_REF,3,,ConsoleInputThreadProcOneCore,39,,115,ConsoleInputThreadProcOneCore,3,,WINAPI
464541,METHOD_REF,2,,"[&](const auto& attr) {
        return renderSettings.GetAttributeColors(attr);
    }",37,,279,Clipboard.StoreSelectionToClipboard.<lambda>0,2,,interactivity\win32\Clipboard.cpp:<global>
465609,METHOD_REF,1,,[&] { UnlockConsole(); },43,,53,FindDialogProc.<lambda>0,2,,interactivity\win32\find.cpp:<global>
465714,METHOD_REF,4,,FindDialogProc,81,,98,FindDialogProc,4,,CALLBACK
475681,METHOD_REF,2,,"[&](TextUnit textUnit, til::point utrStart, til::point utrEnd) {
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr,
                                                                            _pUiaData,
                                                                            &_dummyProvider,
                                                                            utrStart,
                                                                            utrEnd));
            THROW_IF_FAILED(utr->ExpandToEnclosingUnit(textUnit));

            const auto boundaries = textUnitBoundaries.at(textUnit);
            VERIFY_ARE_EQUAL(utr->GetEndpoint(TextPatternRangeEndpoint_Start), boundaries.start);
            VERIFY_ARE_EQUAL(utr->GetEndpoint(TextPatternRangeEndpoint_End), boundaries.end);
        }",32,,555,<lambda>0,2,,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp:<global>
475696,METHOD_REF,2,,"[&]() {
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&target,
                                                                            _pUiaData,
                                                                            &_dummyProvider,
                                                                            origin,
                                                                            origin));
        }",31,,645,<lambda>1,2,,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp:<global>
476832,METHOD_REF,2,,"[&](TextAttribute outputAttr) {
            _pTextBuffer->Write({ outputAttr }, { 0, 0 });
        }",29,,1578,<lambda>2,2,,interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp:<global>
485449,METHOD_REF,4,,_ChangeForegroundRGB,59,,350,_ChangeForegroundRGB,4,,void
485469,METHOD_REF,4,,_ChangeBackgroundRGB,59,,356,_ChangeBackgroundRGB,4,,void
485489,METHOD_REF,4,,_ChangeCursorRGB,59,,362,_ChangeCursorRGB,4,,void
498285,METHOD_REF,1,,"[this]() noexcept {
        _api.bufferLine.clear();
        _api.bufferLineColumn.clear();
    }",42,,627,AtlasEngine._flushBufferLine.<lambda>0,2,,renderer\atlas\AtlasEngine.cpp:<global>
503883,METHOD_REF,2,,"[&](const GridLineRange& r, FontDecorationPosition pos) {
        const auto from = r.from >> widthShift;
        const auto to = r.to >> widthShift;

        auto posX = from * cellSize.x + pos.position;
        const auto end = to * cellSize.x;

        D2D1_POINT_2F point0{ 0, static_cast<f32>(textCellCenter) };
        D2D1_POINT_2F point1{ 0, static_cast<f32>(textCellCenter + cellSize.y) };
        const auto brush = _brushWithColor(r.gridlineColor);
        const f32 w = pos.height;
        const f32 hw = w * 0.5f;

        for (; posX < end; posX += cellSize.x)
        {
            const auto centerX = posX + hw;
            point0.x = centerX;
            point1.x = centerX;
            _renderTarget->DrawLine(point0, point1, brush, w, nullptr);
        }
    }",38,,403,BackendD2D._drawGridlineRow.<lambda>0,2,,renderer\atlas\BackendD2D.cpp:<global>
503887,METHOD_REF,2,,"[&](const GridLineRange& r, FontDecorationPosition pos, ID2D1StrokeStyle* strokeStyle, const u32 color) {
        const auto from = r.from >> widthShift;
        const auto to = r.to >> widthShift;

        const auto brush = _brushWithColor(color);
        const f32 w = pos.height;
        const f32 centerY = textCellCenter + pos.position + w * 0.5f;
        const D2D1_POINT_2F point0{ static_cast<f32>(from * cellSize.x), centerY };
        const D2D1_POINT_2F point1{ static_cast<f32>(to * cellSize.x), centerY };
        _renderTarget->DrawLine(point0, point1, brush, w, strokeStyle);
    }",39,,424,BackendD2D._drawGridlineRow.<lambda>1,2,,renderer\atlas\BackendD2D.cpp:<global>
508341,METHOD_REF,1,,"[&]() noexcept {
        _d2dRenderTarget->SetTransform(&identityTransform);
    }",51,,1350,<lambda>0,2,,renderer\atlas\BackendD3D.cpp:<global>
508356,METHOD_REF,1,,"[&]() {
        if (isColorGlyph)
        {
            _d2dRenderTarget4->SetTextAntialiasMode(static_cast<D2D1_TEXT_ANTIALIAS_MODE>(p.s->font->antialiasingMode));
        }
    }",54,,1375,<lambda>1,2,,renderer\atlas\BackendD3D.cpp:<global>
508430,METHOD_REF,1,,"[&]() {
        if (isBoxGlyph)
        {
            _d2dRenderTarget->PopAxisAlignedClip();
        }
    }",50,,1456,<lambda>2,2,,renderer\atlas\BackendD3D.cpp:<global>
509118,METHOD_REF,2,,"[&](const GridLineRange& r, FontDecorationPosition pos) {
        const auto textCellWidth = cellSize.x << horizontalShift;
        const auto offset = pos.position << horizontalShift;
        const auto width = static_cast<u16>(pos.height << horizontalShift);

        auto posX = r.from * cellSize.x + offset;
        const auto end = r.to * cellSize.x;

        for (; posX < end; posX += textCellWidth)
        {
            _appendQuad() = {
                .shadingType = ShadingType::SolidLine,
                .position = { static_cast<i16>(posX), rowTop },
                .size = { width, p.s->font->cellSize.y },
                .color = r.gridlineColor,
            };
        }
    }",38,,1695,BackendD3D._drawGridlines.<lambda>3,2,,renderer\atlas\BackendD3D.cpp:<global>
509122,METHOD_REF,2,,"[&](const GridLineRange& r, FontDecorationPosition pos, ShadingType shadingType, const u32 color) {
        const auto offset = pos.position << verticalShift;
        const auto height = static_cast<u16>(pos.height << verticalShift);

        const auto left = static_cast<i16>(r.from * cellSize.x);
        const auto width = static_cast<u16>((r.to - r.from) * cellSize.x);

        i32 rt = textCellTop + offset;
        i32 rb = rt + height;
        rt = clamp(rt, clipTop, clipBottom);
        rb = clamp(rb, clipTop, clipBottom);

        if (rt < rb)
        {
            _appendQuad() = {
                .shadingType = shadingType,
                .renditionScale = { static_cast<u8>(1 << horizontalShift), static_cast<u8>(1 << verticalShift) },
                .position = { left, static_cast<i16>(rt) },
                .size = { width, static_cast<u16>(rb - rt) },
                .color = color,
            };
        }
    }",39,,1713,BackendD3D._drawGridlines.<lambda>4,2,,renderer\atlas\BackendD3D.cpp:<global>
514770,METHOD_REF,-1,,"[=](auto& errorTotal) {
            errorTotal += errorIncrement;
            if (errorTotal > errorThreshold)
            {
                errorTotal -= errorReset;
                return increment + 1;
            }
            return increment;
        }",16,,202,FontResource._resizeBitPattern..<lambda>1,1,,renderer\base\FontResource.cpp:<global>
515256,METHOD_REF,2,,"[](const auto sourceDimension, const auto targetDimension) {
        const auto increment = sourceDimension / targetDimension;
        const auto errorIncrement = sourceDimension % targetDimension * 2;
        const auto errorThreshold = targetDimension * 2 - std::min(sourceDimension, targetDimension);
        const auto errorReset = targetDimension * 2;

        return [=](auto& errorTotal) {
            errorTotal += errorIncrement;
            if (errorTotal > errorThreshold)
            {
                errorTotal -= errorReset;
                return increment + 1;
            }
            return increment;
        };
    }",42,,196,FontResource._resizeBitPattern.<lambda>0,2,,renderer\base\FontResource.cpp:<global>
518880,METHOD_REF,3,,"[mapOffset](UINT16& n) {
            n -= mapOffset;
        }",71,,1730,CustomTextLayout._SplitCurrentRun.<lambda>0,4,,renderer\dx\CustomTextLayout.cpp:<global>
518897,METHOD_REF,3,,"[](auto& a, auto& b) { return a.textStart < b.textStart; }",43,,1748,CustomTextLayout._OrderRuns.<lambda>1,4,,renderer\dx\CustomTextLayout.cpp:<global>
524182,METHOD_REF,2,,"[=](const auto lineNumber) noexcept {
        return _bitmapBits.begin() + lineNumber * bitmapWidth;
    }",33,,51,DxSoftFont.SetFont.<lambda>0,2,,renderer\dx\DxSoftFont.cpp:<global>
524548,METHOD_REF,1,,[&]() noexcept { d2dContext->PopAxisAlignedClip(); },46,,149,DxSoftFont.Draw.<lambda>1,2,,renderer\dx\DxSoftFont.cpp:<global>
527385,METHOD_REF,1,,"[&]() {
        LOG_IF_FAILED(ResetLineTransform());
    }",47,,785,GdiEngine.PaintCursor.<lambda>0,2,,renderer\gdi\paint.cpp:<global>
542165,METHOD_REF,2,,"[=](const VTInt cellWidth, const VTInt cellHeight) {
        const auto sixelHeight = (cellHeight + 5) / 6 * 6;
        const auto heightInRange = _declaredHeight ? _declaredHeight <= cellHeight : _usedHeight <= sixelHeight;
        const auto widthInRange = _declaredWidth ? _declaredWidth <= cellWidth : _usedWidth <= cellWidth;
        return heightInRange && widthInRange;
    }",26,,401,FontBuffer._calculateDimensions.<lambda>0,2,,terminal\adapter\FontBuffer.cpp:<global>
544168,METHOD_REF,1,,"[&] {
                // Once the invoke depth reaches zero, we know we've reached the end
                // of the root invoke, so we can reset the sequence length tracker.
                if (--_invokedDepth == 0)
                {
                    _invokedSequenceLength = 0;
                }
            }",53,,48,MacroBuffer.InvokeMacro.<lambda>0,2,,terminal\adapter\MacroBuffer.cpp:<global>
550312,METHOD_REF,2,,"[](const auto color, const auto defaultIndex) {
                        return color.IsLegacy() ? color.GetIndex() : defaultIndex;
                    }",45,,1427,AdaptDispatch.RequestChecksumRectangularArea.<lambda>0,2,,terminal\adapter\adaptDispatch.cpp:<global>
556071,METHOD_REF,-1,,"[=](const auto ch) {
        if (conptyPassthrough)
        {
            conptyPassthrough(ch);
        }
        // We pass the data string straight through to the font buffer class
        // until we receive an ESC, indicating the end of the string. At that
        // point we can finalize the buffer, and if valid, update the renderer
        // with the constructed bit pattern.
        if (ch != AsciiChars::ESC)
        {
            _fontBuffer->AddSixelData(ch);
        }
        else if (_fontBuffer->FinalizeSixelData())
        {
            // We also need to inform the character set mapper of the ID that
            // will map to this font (we only support one font buffer so there
            // will only ever be one active dynamic character set).
            if (charsetSize == DispatchTypes::DrcsCharsetSize::Size96)
            {
                _termOutput.SetDrcs96Designation(_fontBuffer->GetDesignation());
            }
            else
            {
                ...",12,,3917,AdaptDispatch.DownloadDRCS.<lambda>1,1,,terminal\adapter\adaptDispatch.cpp:<global>
556093,METHOD_REF,-1,,"[=, &engine, gotId = false](const auto ch) mutable {
            // The character set ID is contained in the first characters of the
            // sequence, so we just ignore that initial content until we receive
            // a ""final"" character (i.e. in range 30 to 7E). At that point we
            // pass through a hard-coded ID of ""@"".
            if (!gotId)
            {
                if (ch >= 0x30 && ch <= 0x7E)
                {
                    gotId = true;
                    defaultPassthrough('@');
                }
            }
            else if (!defaultPassthrough(ch))
            {
                // Once the DECDLD sequence is finished, we also output an SCS
                // sequence to map the character set into the G1 table.
                const auto charset96 = charsetSize == DispatchTypes::DrcsCharsetSize::Size96;
                engine.ActionPassThroughString(charset96 ? L""\033-@"" : L""\033)@"");
            }
            return true;
        }",16,,3966,AdaptDispatch._CreateDrcsPassthroughHandler.<lambda>2,1,,terminal\adapter\adaptDispatch.cpp:<global>
556123,METHOD_REF,-1,,"[&](const auto ch) {
            return _macroBuffer->ParseDefinition(ch);
        }",16,,4012,AdaptDispatch.DefineMacro.<lambda>3,1,,terminal\adapter\adaptDispatch.cpp:<global>
556146,METHOD_REF,1,,"[=, &stateMachine]() {
            macroBuffer->InvokeMacro(macroId, stateMachine);
        }",36,,4039,AdaptDispatch.InvokeMacro.<lambda>4,2,,terminal\adapter\adaptDispatch.cpp:<global>
556181,METHOD_REF,-1,,"[this, parameter = VTInt{}, parameters = std::vector<VTParameter>{}](const auto ch) mutable {
        if (ch >= L'0' && ch <= L'9')
        {
            parameter *= 10;
            parameter += (ch - L'0');
            parameter = std::min(parameter, MAX_PARAMETER_VALUE);
        }
        else if (ch == L';')
        {
            if (parameters.size() < 5)
            {
                parameters.push_back(parameter);
            }
            parameter = 0;
        }
        else if (ch == L'/' || ch == AsciiChars::ESC)
        {
            parameters.push_back(parameter);
            const auto colorParameters = VTParameters{ parameters.data(), parameters.size() };
            const auto colorNumber = colorParameters.at(0).value_or(0);
            if (colorNumber < TextColor::TABLE_SIZE)
            {
                const auto colorModel = DispatchTypes::ColorModel{ colorParameters.at(1) };
                const auto x = colorParameters.at(2).value_or(0);
                con...",12,,4084,AdaptDispatch._RestoreColorTable.<lambda>5,1,,terminal\adapter\adaptDispatch.cpp:<global>
556187,METHOD_REF,-1,,"[this, parameter = VTInt{}, idBuilder = VTIDBuilder{}](const auto ch) mutable {
        const auto isFinal = ch >= L'\x40' && ch <= L'\x7e';
        if (isFinal)
        {
            const auto id = idBuilder.Finalize(ch);
            switch (id)
            {
            case VTID(""m""):
                _ReportSGRSetting();
                break;
            case VTID(""r""):
                _ReportDECSTBMSetting();
                break;
            case VTID(""s""):
                _ReportDECSLRMSetting();
                break;
            case VTID(""\""q""):
                _ReportDECSCASetting();
                break;
            case VTID(""*x""):
                _ReportDECSACESetting();
                break;
            case VTID("",|""):
                _ReportDECACSetting(VTParameter{ parameter });
                break;
            default:
                _api.ReturnResponse(L""\033P0$r\033\\"");
                break;
            }
            return false;
        }
        else...",12,,4142,AdaptDispatch.RequestSetting.<lambda>6,1,,terminal\adapter\adaptDispatch.cpp:<global>
556217,METHOD_REF,2,,"[&](const auto& parameter, const auto enabled) {
        if (enabled)
        {
            response.append(parameter);
        }
    }",31,,4216,AdaptDispatch._ReportSGRSetting.<lambda>7,2,,terminal\adapter\adaptDispatch.cpp:<global>
556304,METHOD_REF,2,,"[&](const auto base, const auto color) {
        if (color.IsIndex16())
        {
            const auto index = color.GetIndex();
            const auto colorParameter = base + (index >= 8 ? 60 : 0) + (index % 8);
            fmt::format_to(std::back_inserter(response), FMT_COMPILE(L"";{}""), colorParameter);
        }
        else if (color.IsIndex256())
        {
            const auto index = color.GetIndex();
            fmt::format_to(std::back_inserter(response), FMT_COMPILE(L"";{}:5:{}""), base + 8, index);
        }
        else if (color.IsRgb())
        {
            const auto r = GetRValue(color.GetRGB());
            const auto g = GetGValue(color.GetRGB());
            const auto b = GetBValue(color.GetRGB());
            fmt::format_to(std::back_inserter(response), FMT_COMPILE(L"";{}:2::{}:{}:{}""), base + 8, r, g, b);
        }
    }",27,,4238,AdaptDispatch._ReportSGRSetting.<lambda>8,2,,terminal\adapter\adaptDispatch.cpp:<global>
557114,METHOD_REF,-1,,"[&, state = State{}](const auto ch) mutable {
        if (numeric.test(state.field))
        {
            if (ch >= '0' && ch <= '9')
            {
                state.value *= 10;
                state.value += (ch - L'0');
                state.value = std::min(state.value, MAX_PARAMETER_VALUE);
            }
            else if (ch == L';' || ch == AsciiChars::ESC)
            {
                if (state.field == Field::Row)
                {
                    state.row = state.value;
                }
                else if (state.field == Field::Column)
                {
                    state.column = state.value;
                }
                else if (state.field == Field::Page)
                {
                    // Paging is not supported yet (GH#13892).
                }
                else if (state.field == Field::GL && state.value <= 3)
                {
                    LockingShift(state.value);
                }
                else if (state.field...",12,,4555,AdaptDispatch._RestoreCursorInformation.<lambda>9,1,,terminal\adapter\adaptDispatch.cpp:<global>
557236,METHOD_REF,-1,,"[this, width, column = size_t{}](const auto ch) mutable {
        if (ch >= L'0' && ch <= L'9')
        {
            column *= 10;
            column += (ch - L'0');
            column = std::min<size_t>(column, MAX_PARAMETER_VALUE);
        }
        else if (ch == L'/' || ch == AsciiChars::ESC)
        {
            // Note that column 1 is always a tab stop, so there is no
            // need to record an entry at that offset.
            if (column > 1u && column <= static_cast<size_t>(width))
            {
                _tabStopColumns.at(column - 1) = true;
            }
            column = 0;
        }
        else
        {
            // If we receive an unexpected character, we don't try and
            // process any more of the input - we just abort.
            return false;
        }
        return (ch != AsciiChars::ESC);
    }",12,,4726,AdaptDispatch._RestoreTabStops.<lambda>10,1,,terminal\adapter\adaptDispatch.cpp:<global>
557304,METHOD_REF,1,,"[=](const auto param) {
        // Values 1 to 25 represent the notes C5 to C7, so we add 71 to
        // obtain the equivalent MIDI note numbers (72 = C5).
        const auto noteNumber = std::min(param.value_or(0), 25) + 71;
        // But value 0 is meant to be silent, so if the note number is 71,
        // we set the velocity to 0 (i.e. no volume).
        _api.PlayMidiNote(noteNumber, noteNumber == 71 ? 0 : velocity, duration);
        return true;
    }",43,,4778,AdaptDispatch.PlaySounds.<lambda>11,2,,terminal\adapter\adaptDispatch.cpp:<global>
557333,METHOD_REF,-1,,"[&, buffer = std::wstring{}](const auto ch) mutable {
            // To make things more efficient, we buffer the string data before
            // passing it through, only flushing if the buffer gets too large,
            // or we're dealing with the last character in the current output
            // fragment, or we've reached the end of the string.
            const auto endOfString = ch == AsciiChars::ESC;
            buffer += ch;
            if (buffer.length() >= 4096 || stateMachine.IsProcessingLastCharacter() || endOfString)
            {
                // The end of the string is signaled with an escape, but for it
                // to be a valid string terminator we need to add a backslash.
                if (endOfString)
                {
                    buffer += L'\\';
                }
                engine.ActionPassThroughString(buffer);
                buffer.clear();
            }
            return !endOfString;
        }",16,,4809,AdaptDispatch._CreatePassthroughHandler.<lambda>12,1,,terminal\adapter\adaptDispatch.cpp:<global>
558535,METHOD_REF,2,,"[&](const TextColor& color) {
        switch (colorItem)
        {
        case ForegroundExtended:
            attr.SetForeground(color);
            break;
        case BackgroundExtended:
            attr.SetBackground(color);
            break;
        case UnderlineColor:
            attr.SetUnderlineColor(color);
            break;
        default:
            break;
        };
    }",29,,103,AdaptDispatch._SetRgbColorsHelperFromSubParams.<lambda>0,2,,terminal\adapter\adaptDispatchGraphics.cpp:<global>
567337,METHOD_REF,1,,"[oldRetainValue, this] {
            _retainResponse = oldRetainValue;
        }",32,,378,TestGetSet.EnableInputRetentionInScope.<lambda>0,2,,TestGetSet
568429,METHOD_REF,2,,"[this](const auto checksum) {
            wchar_t expectedResponse[20];
            swprintf_s(expectedResponse, ARRAYSIZE(expectedResponse), L""\x1bP99!~%s\033\\"", checksum);
            _testGetSet->ValidateInputEvent(expectedResponse);
        }",43,,2045,<lambda>1,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
568433,METHOD_REF,2,,"[&](const auto text) {
            _testGetSet->PrepData();
            _pDispatch->PrintString(text);
            requestChecksumReport(text.length());
        }",33,,2051,<lambda>2,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
568437,METHOD_REF,2,,"[&](const auto text, const auto& attrCallback) {
            _testGetSet->PrepData();
            auto attr = TextAttribute{};
            attrCallback(attr);
            _testGetSet->_textBuffer->SetCurrentAttributes(attr);
            _pDispatch->PrintString(text);
            requestChecksumReport(text.length());
        }",47,,2057,<lambda>3,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
569131,METHOD_REF,2,,"[&](const auto cmw, const auto cmh, const auto ss, const auto u, const std::wstring_view data = {}) {
            const auto cellMatrix = static_cast<DispatchTypes::DrcsCellMatrix>(cmw);
            RETURN_BOOL_IF_FALSE(fontBuffer.SetEraseControl(DispatchTypes::DrcsEraseControl::AllChars));
            RETURN_BOOL_IF_FALSE(fontBuffer.SetAttributes(cellMatrix, cmh, ss, u));
            RETURN_BOOL_IF_FALSE(fontBuffer.SetStartChar(0, DispatchTypes::DrcsCharsetSize::Size94));

            fontBuffer.AddSixelData(L'B'); // Charset identifier
            for (auto ch : data)
            {
                fontBuffer.AddSixelData(ch);
            }
            RETURN_BOOL_IF_FALSE(fontBuffer.FinalizeSixelData());

            const auto cellSize = fontBuffer.GetCellSize();
            Log::Comment(NoThrowString().Format(L""Cell size: %dx%d"", cellSize.width, cellSize.height));
            VERIFY_ARE_EQUAL(expectedCellSize.width, cellSize.width);
            VERIFY_ARE_EQUAL(expectedCellSize....",29,,2793,<lambda>4,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
569675,METHOD_REF,2,,"[&](const auto id, const auto value) {
            _pDispatch->_macroBuffer->_macros.at(id) = value;
        }",35,,3131,<lambda>5,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
569683,METHOD_REF,2,,"[&]() {
            const auto& textBuffer = _testGetSet->GetTextBuffer();
            const auto cursorPos = textBuffer.GetCursor().GetPosition();
            return textBuffer.GetRowByOffset(cursorPos.y).GetText().substr(0, cursorPos.x);
        }",38,,3140,<lambda>6,2,,terminal\adapter\ut_adapter\adapterTest.cpp:<global>
579673,METHOD_REF,1,,"[&](const auto eraseType) {
            return _dispatch->EraseInDisplay(eraseType);
        }",39,,483,OutputStateMachineEngine.ActionCsiDispatch.<lambda>0,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579685,METHOD_REF,1,,"[&](const auto eraseType) {
            return _dispatch->SelectiveEraseInDisplay(eraseType);
        }",39,,488,OutputStateMachineEngine.ActionCsiDispatch.<lambda>1,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579697,METHOD_REF,1,,"[&](const auto eraseType) {
            return _dispatch->EraseInLine(eraseType);
        }",39,,493,OutputStateMachineEngine.ActionCsiDispatch.<lambda>2,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579709,METHOD_REF,1,,"[&](const auto eraseType) {
            return _dispatch->SelectiveEraseInLine(eraseType);
        }",39,,498,OutputStateMachineEngine.ActionCsiDispatch.<lambda>3,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579721,METHOD_REF,1,,"[&](const auto mode) {
            return _dispatch->SetMode(DispatchTypes::ANSIStandardMode(mode));
        }",39,,503,OutputStateMachineEngine.ActionCsiDispatch.<lambda>4,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579733,METHOD_REF,1,,"[&](const auto mode) {
            return _dispatch->SetMode(DispatchTypes::DECPrivateMode(mode));
        }",39,,508,OutputStateMachineEngine.ActionCsiDispatch.<lambda>5,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579745,METHOD_REF,1,,"[&](const auto mode) {
            return _dispatch->ResetMode(DispatchTypes::ANSIStandardMode(mode));
        }",39,,513,OutputStateMachineEngine.ActionCsiDispatch.<lambda>6,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
579757,METHOD_REF,1,,"[&](const auto mode) {
            return _dispatch->ResetMode(DispatchTypes::DECPrivateMode(mode));
        }",39,,518,OutputStateMachineEngine.ActionCsiDispatch.<lambda>7,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
580023,METHOD_REF,1,,"[&](const auto clearType) {
            return _dispatch->TabClear(clearType);
        }",39,,565,OutputStateMachineEngine.ActionCsiDispatch.<lambda>8,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
580035,METHOD_REF,1,,"[&](const auto setType) {
            return _dispatch->TabSet(setType);
        }",39,,570,OutputStateMachineEngine.ActionCsiDispatch.<lambda>9,2,,terminal\parser\OutputStateMachineEngine.cpp:<global>
582996,METHOD_REF,2,,"[](auto& r, auto& error, auto ch) {
        // n will be in the range [0, 0x3f] for valid ch
        // and exactly 0xff for invalid ch.
        const auto n = decodeTable[ch & 0x7f];
        // Both ch > 0x7f, as well as n > 0x7f are invalid values and count as an error.
        // We can add the error state by checking if any bits ~0x7f are set (which is 0xff80).
        error |= (ch | n) & 0xff80;
        r = r << 6 | n;
    }",40,,78,Base64.Decode.<lambda>0,2,,terminal\parser\base64.cpp:<global>
584603,METHOD_REF,2,,"[](BYTE) { return CFuzzChance::GetRandom<BYTE>(2, 0xF); }",10,,46,<lambda>0,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584606,METHOD_REF,2,,"[](BYTE) { return CFuzzChance::GetRandom<BYTE>(2, 0xFF); }",10,,47,<lambda>1,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584609,METHOD_REF,2,,[](BYTE) { return (BYTE)0; },11,,48,<lambda>2,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584637,METHOD_REF,2,,"[&](std::string) { return CFuzzChance::SelectOne(g_tokenGenerators, ARRAYSIZE(g_tokenGenerators))(); }",14,,73,GenerateTokenLowProbability.<lambda>3,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584640,METHOD_REF,2,,[](std::string) { return GenerateInvalidToken(); },14,,74,GenerateTokenLowProbability.<lambda>4,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584643,METHOD_REF,2,,[](std::string) { return GenerateTextToken(); },14,,75,GenerateTokenLowProbability.<lambda>5,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584646,METHOD_REF,2,,[](std::string) { return GenerateWhiteSpaceToken(); },14,,76,GenerateTokenLowProbability.<lambda>6,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584674,METHOD_REF,2,,[](std::string) { return GenerateTextToken(); },15,,86,GenerateToken.<lambda>7,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584677,METHOD_REF,2,,"[&](std::string) { return CFuzzChance::SelectOne(g_tokenGenerators, ARRAYSIZE(g_tokenGenerators))(); }",15,,87,GenerateToken.<lambda>8,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584680,METHOD_REF,2,,[](std::string) { return GenerateInvalidToken(); },14,,88,GenerateToken.<lambda>9,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584683,METHOD_REF,2,,[](std::string) { return GenerateWhiteSpaceToken(); },14,,89,GenerateToken.<lambda>10,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584711,METHOD_REF,2,,"[](DWORD) { return CFuzzChance::GetRandom<DWORD>(0, 0xF); }",14,,99,GenerateWhiteSpaceToken.<lambda>11,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584714,METHOD_REF,2,,"[](DWORD) { return CFuzzChance::GetRandom<DWORD>(0, 0xFF); }",14,,100,GenerateWhiteSpaceToken.<lambda>12,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584860,METHOD_REF,2,,"[&](std::string) { std::string s; AppendFormat(s, ""%02d"", CFuzzChance::SelectOne(psValid, ARRAYSIZE(psValid))); return s; }",15,,232,GenerateSGRToken.<lambda>13,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584863,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,233,GenerateSGRToken.<lambda>14,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584866,METHOD_REF,2,,"[](std::string) { return std::string(""35;5""); }",15,,234,GenerateSGRToken.<lambda>15,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584869,METHOD_REF,2,,"[](std::string) { return std::string(""48;5""); }",15,,235,GenerateSGRToken.<lambda>16,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584905,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d"", CFuzzChance::GetRandom<USHORT>()); return s; }",15,,247,GenerateCUXToken.<lambda>17,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584908,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,248,GenerateCUXToken.<lambda>18,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584968,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d;%d"", CFuzzChance::GetRandom<BYTE>(), CFuzzChance::GetRandom<BYTE>()); return s; }",15,,271,GenerateCUXToken3.<lambda>19,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584971,METHOD_REF,2,,"[](std::string) { return std::string("";""); }",15,,272,GenerateCUXToken3.<lambda>20,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584974,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d;"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,273,GenerateCUXToken3.<lambda>21,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
584977,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, "";%d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,274,GenerateCUXToken3.<lambda>22,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585063,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""?%02d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,309,GeneratePrivateModeParamToken.<lambda>23,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585066,METHOD_REF,2,,"[](std::string) { return std::string(""?1""); }",14,,310,GeneratePrivateModeParamToken.<lambda>24,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585069,METHOD_REF,2,,"[](std::string) { return std::string(""?2""); }",14,,311,GeneratePrivateModeParamToken.<lambda>25,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585072,METHOD_REF,2,,"[](std::string) { return std::string(""?3""); }",14,,312,GeneratePrivateModeParamToken.<lambda>26,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585075,METHOD_REF,2,,"[](std::string) { return std::string(""?12""); }",14,,313,GeneratePrivateModeParamToken.<lambda>27,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585078,METHOD_REF,2,,"[](std::string) { return std::string(""?25""); }",14,,314,GeneratePrivateModeParamToken.<lambda>28,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585081,METHOD_REF,2,,"[](std::string) { return std::string(""?1000""); }",14,,315,GeneratePrivateModeParamToken.<lambda>29,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585084,METHOD_REF,2,,"[](std::string) { return std::string(""?1002""); }",14,,316,GeneratePrivateModeParamToken.<lambda>30,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585087,METHOD_REF,2,,"[](std::string) { return std::string(""?1003""); }",14,,317,GeneratePrivateModeParamToken.<lambda>31,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585090,METHOD_REF,2,,"[](std::string) { return std::string(""?1005""); }",14,,318,GeneratePrivateModeParamToken.<lambda>32,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585093,METHOD_REF,2,,"[](std::string) { return std::string(""?1006""); }",14,,319,GeneratePrivateModeParamToken.<lambda>33,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585096,METHOD_REF,2,,"[](std::string) { return std::string(""?1007""); }",14,,320,GeneratePrivateModeParamToken.<lambda>34,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585099,METHOD_REF,2,,"[](std::string) { return std::string(""?1049""); }",14,,321,GeneratePrivateModeParamToken.<lambda>35,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585130,METHOD_REF,2,,"[](std::string) { return std::string(""""); }",14,,332,GenerateEraseToken.<lambda>36,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585133,METHOD_REF,2,,"[](std::string) { return std::string(""0""); }",15,,333,GenerateEraseToken.<lambda>37,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585136,METHOD_REF,2,,"[](std::string) { return std::string(""1""); }",15,,334,GenerateEraseToken.<lambda>38,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585139,METHOD_REF,2,,"[](std::string) { return std::string(""2""); }",15,,335,GenerateEraseToken.<lambda>39,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585142,METHOD_REF,2,,"[](std::string) { return std::string(""3""); }",15,,336,GenerateEraseToken.<lambda>40,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585145,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%02d"", CFuzzChance::GetRandom<BYTE>()); return s; }",14,,337,GenerateEraseToken.<lambda>41,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585175,METHOD_REF,2,,"[](std::string) { return std::string(""""); }",15,,348,GenerateDeviceAttributesToken.<lambda>42,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585178,METHOD_REF,2,,"[](std::string) { return std::string(""0""); }",15,,349,GenerateDeviceAttributesToken.<lambda>43,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585181,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%02d"", CFuzzChance::GetRandom<BYTE>()); return s; }",14,,350,GenerateDeviceAttributesToken.<lambda>44,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585211,METHOD_REF,2,,"[](std::string) { return std::string(""6""); }",15,,361,GenerateDeviceStatusReportToken.<lambda>45,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585214,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%02d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,362,GenerateDeviceStatusReportToken.<lambda>46,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585242,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%08d"", CFuzzChance::GetRandom<ULONG>()); return s; }",14,,374,GenerateScrollToken.<lambda>47,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585245,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%08d"", CFuzzChance::GetRandom<USHORT>()); return s; }",14,,375,GenerateScrollToken.<lambda>48,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585248,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",15,,376,GenerateScrollToken.<lambda>49,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585251,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%02d"", CFuzzChance::GetRandom<BYTE>()); return s; }",15,,377,GenerateScrollToken.<lambda>50,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585278,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d;%d;%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000), CFuzzChance::GetRandom<USHORT>(0, 0x4000), CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",14,,394,GenerateResizeToken.<lambda>51,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585281,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d;%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000), CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",14,,395,GenerateResizeToken.<lambda>52,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585284,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",14,,396,GenerateResizeToken.<lambda>53,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585287,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""8;%d;%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000), CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",15,,397,GenerateResizeToken.<lambda>54,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585290,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""8;%d;"", CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",15,,398,GenerateResizeToken.<lambda>55,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585293,METHOD_REF,2,,"[](std::string) { std::string s; AppendFormat(s, ""8;;%d"", CFuzzChance::GetRandom<USHORT>(0, 0x4000)); return s; }",15,,399,GenerateResizeToken.<lambda>56,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585323,METHOD_REF,2,,"[](std::string) {
              std::string s;
              auto limit = CFuzzChance::GetRandom<SHORT>(0, 10);
              // append up to 10 numbers for the param
              for (SHORT i = 0; i < limit; i++)
              {
                  AppendFormat(s, ""%d"", CFuzzChance::GetRandom<BYTE>(0, 9));
              }
              s.append("";"");
              // append some characters for the string
              limit = CFuzzChance::GetRandom<SHORT>();
              for (SHORT i = 0; i < limit; i++)
              {
                  AppendFormat(s, ""%c"", CFuzzChance::GetRandom<BYTE>());
              }
              return s;
          }",11,,412,GenerateOscTitleToken.<lambda>57,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585354,METHOD_REF,2,,"[](std::string) {
              std::string s;
              auto limit = CFuzzChance::GetRandom<SHORT>(0, 10);
              // append up to 10 numbers for the param
              for (SHORT i = 0; i < limit; i++)
              {
                  AppendFormat(s, ""%d"", CFuzzChance::GetRandom<BYTE>(0, 9));
              }
              s.append("";"");

              // Append some random numbers for the index
              limit = CFuzzChance::GetRandom<SHORT>(0, 10);
              // append up to 10 numbers for the param
              for (SHORT i = 0; i < limit; i++)
              {
                  AppendFormat(s, ""%d"", CFuzzChance::GetRandom<BYTE>(0, 9));
              }
              // Maybe add more text
              if (CFuzzChance::GetRandom<BOOL>())
              {
                  // usually add a RGB
                  limit = CFuzzChance::GetRandom<SHORT>(0, 10);
                  switch (limit)
                  {
                  case 0:
                  case 1:
  ...",11,,441,GenerateOscColorTableToken.<lambda>58,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
585471,METHOD_REF,2,,"[](std::string) {
              std::string s;
              AppendFormat(s, ""%d"", 8);
              s.append("";"");

              // Maybe append some key-value pairs
              auto numPairs = CFuzzChance::GetRandom<SHORT>(0, 5);
              for (SHORT i = 0; i < numPairs; i++)
              {
                  // usually add an id
                  auto limit = CFuzzChance::GetRandom<SHORT>(0, 10);
                  switch (limit)
                  {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                      s.append(""id="");
                      break;
                  case 7:
                      s.append(""rgb="");
                      break;
                  case 8:
                      s.append(""cmyk="");
                      break;
                  default:
                      // append some characters for the string
   ...",11,,546,GenerateOscHyperlinkToken.<lambda>59,2,,terminal\parser\ft_fuzzer\VTCommandFuzzer.cpp:<global>
586432,METHOD_REF,2,,"[&](_Type* psz, std::function<void(_Type*)> dealloc) {
                FreeFuzzedString();
                _Type* pszFuzzed = psz;
                if (psz && psz != this->m_tInit)
                {
                    auto cb = (sizeof(_Type) == sizeof(char)) ?
                                  (strlen(reinterpret_cast<LPSTR>(psz)) + 1) * sizeof(char) :
                                  (wcslen(reinterpret_cast<LPWSTR>(psz)) + 1) * sizeof(WCHAR);
                    m_pszFuzzed = reinterpret_cast<_Type*>(_Alloc::Allocate(cb));
                    if (m_pszFuzzed)
                    {
                        (sizeof(_Type) == sizeof(char)) ?
                            StringCbCopyA(reinterpret_cast<LPSTR>(m_pszFuzzed), cb, reinterpret_cast<LPCSTR>(psz)) :
                            StringCbCopyW(reinterpret_cast<LPWSTR>(m_pszFuzzed), cb, reinterpret_cast<LPCWSTR>(psz));
                        pszFuzzed = m_pszFuzzed;
                    }

                    if (dealloc)
       ...",47,,985,fuzz.CFuzzString.OnFuzzedValueFromMap.<lambda>0,2,,fuzz.CFuzzString
587506,METHOD_REF,1,,"[=]() {
        return _engine->ActionExecute(wch);
    }",47,,382,StateMachine._ActionExecute.<lambda>0,1,,terminal\parser\stateMachine.cpp:<global>
587521,METHOD_REF,1,,"[=]() {
        return _engine->ActionExecuteFromEscape(wch);
    }",47,,398,StateMachine._ActionExecuteFromEscape.<lambda>1,1,,terminal\parser\stateMachine.cpp:<global>
587536,METHOD_REF,1,,"[=]() {
        return _engine->ActionPrint(wch);
    }",47,,412,StateMachine._ActionPrint.<lambda>2,1,,terminal\parser\stateMachine.cpp:<global>
587542,METHOD_REF,1,,"[=]() {
        return _engine->ActionPrintString(string);
    }",18,,425,StateMachine._ActionPrintString.<lambda>3,1,,terminal\parser\stateMachine.cpp:<global>
587562,METHOD_REF,1,,"[=]() {
        return _engine->ActionEscDispatch(_identifier.Finalize(wch));
    }",47,,441,StateMachine._ActionEscDispatch.<lambda>4,1,,terminal\parser\stateMachine.cpp:<global>
587577,METHOD_REF,1,,"[=]() {
        return _engine->ActionVt52EscDispatch(_identifier.Finalize(wch), { _parameters.data(), _parameters.size() });
    }",47,,456,StateMachine._ActionVt52EscDispatch.<lambda>5,1,,terminal\parser\stateMachine.cpp:<global>
587592,METHOD_REF,1,,"[=]() {
        return _engine->ActionCsiDispatch(_identifier.Finalize(wch),
                                          { _parameters, _subParameters, _subParameterRanges });
    }",47,,471,StateMachine._ActionCsiDispatch.<lambda>6,1,,terminal\parser\stateMachine.cpp:<global>
587935,METHOD_REF,1,,"[=]() {
        return _engine->ActionOscDispatch(wch, _oscParameter, _oscString);
    }",47,,697,StateMachine._ActionOscDispatch.<lambda>7,1,,terminal\parser\stateMachine.cpp:<global>
587950,METHOD_REF,1,,"[=]() {
        return _engine->ActionSs3Dispatch(wch, { _parameters.data(), _parameters.size() });
    }",47,,712,StateMachine._ActionSs3Dispatch.<lambda>8,1,,terminal\parser\stateMachine.cpp:<global>
587964,METHOD_REF,1,,"[=]() {
        _dcsStringHandler = _engine->ActionDcsDispatch(_identifier.Finalize(wch), { _parameters.data(), _parameters.size() });
        // If the returned handler is null, the sequence is not supported.
        return _dcsStringHandler != nullptr;
    }",39,,728,StateMachine._ActionDcsDispatch.<lambda>9,1,,terminal\parser\stateMachine.cpp:<global>
589428,METHOD_REF,1,,"[=]() {
            return _engine->ActionPassThroughString(*_cachedSequence);
        }",32,,1937,StateMachine.FlushToTerminal.<lambda>10,1,,terminal\parser\stateMachine.cpp:<global>
589439,METHOD_REF,1,,"[=]() {
            return _engine->ActionPassThroughString(_CurrentRun());
        }",32,,1949,StateMachine.FlushToTerminal.<lambda>11,1,,terminal\parser\stateMachine.cpp:<global>
590259,METHOD_REF,1,,"[]() noexcept {
        TraceLoggingUnregister(g_hConsoleVirtTermParserEventTraceProvider);
    }",28,,21,<lambda>1,2,,terminal\parser\tracing.cpp:<global>
590275,METHOD_REF,0,,"[]() noexcept {
    TraceLoggingRegister(g_hConsoleVirtTermParserEventTraceProvider);
    return wil::scope_exit([]() noexcept {
        TraceLoggingUnregister(g_hConsoleVirtTermParserEventTraceProvider);
    });
}",29,,19,<lambda>0,1,,terminal\parser\tracing.cpp:<global>
593680,METHOD_REF,2,,"[&](const std::span<const INPUT_RECORD>& inEvents) {
        for (auto& ev : inEvents)
        {
            if (const auto str = terminalInput.HandleKey(ev))
            {
                translation.append(*str);
            }
        }
    }",41,,960,InputEngineTest.AltIntermediateTest.<lambda>0,2,,terminal\parser\ut_parser\InputEngineTest.cpp:<global>
601101,METHOD_REF,-1,,[=](const auto ch) { dcsDataString += ch; return true; },16,,118,TestStateMachineEngine.ActionDcsDispatch.<lambda>0,1,,TestStateMachineEngine
606174,METHOD_REF,2,,[v = 0]() mutable { return v++; },39,,194,SPSCTests.IntegrationTest..<lambda>1,3,,til\ut_til\SPSCTests.cpp:<global>
606721,METHOD_REF,1,,"[tx = std::move(tx)]() {
        std::array<int, 11> buffer{};
        std::ranges::generate(buffer, [v = 0]() mutable { return v++; });

        for (auto i = 0; i < 37; ++i)
        {
            tx.emplace(i);
        }
        for (auto i = 0; i < 3; ++i)
        {
            tx.push(buffer.begin(), buffer.end());
        }
    }",19,,192,SPSCTests.IntegrationTest.<lambda>0,1,,til\ut_til\SPSCTests.cpp:<global>
610762,METHOD_REF,1,,"[&]() {
        check_hresult(CoRevokeClassObject(dwRegistration));
    }",36,,101,appLoop.<lambda>0,2,,tools\MonarchPeasantSample\main.cpp:<global>
611064,METHOD_REF,2,,"defer
    {
        SetConsoleMode(outputHandle, consoleMode);
    }",5,,129,main.<lambda>0,2,,tools\RenderingTests\main.cpp:<global>
611077,METHOD_REF,2,,"defer
    {
        printUTF16(
            L""\x1b[?1049l"" // disable alternative screen buffer
        );
    }",5,,137,main.<lambda>1,2,,tools\RenderingTests\main.cpp:<global>
619371,METHOD_REF,2,,"[&](int n, int /*n2*/) {
        genChild(n, L"""", allocChunk, out);
        if (useJob)
        {
            out.push_back(kChildCommand_Job);
            out.push_back(std::to_wstring((uintptr_t)job));
        }
        else
        {
            out.push_back(kChildCommand_Read);
            out.push_back(std::to_wstring((uintptr_t)pipe.rh));
        }
    }",22,,425,genBatch.<lambda>0,2,,tools\closetest\closetest.cpp:<global>
619375,METHOD_REF,2,,"[&](int n, int n2) {
        const auto desc = L""child "" + std::to_wstring(n) +
                          L"" kills child "" + std::to_wstring(n2);
        genChild(n, desc, allocChunk, out);
        out.push_back(kChildCommand_Hold);
        out.push_back(std::to_wstring((uintptr_t)(useJob ? job : pipe.wh)));
    }",22,,439,genBatch.<lambda>1,2,,tools\closetest\closetest.cpp:<global>
621435,METHOD_REF,1,,CtrlHandler,27,,348,CtrlHandler,1,,WINAPI
624449,METHOD_REF,2,,ReadCallback,30,,118,ReadCallback,2,,void
625393,METHOD_REF,1,,"[&] {
        SetConsoleOutputCP(launchOutputCP);
        SetConsoleCP(launchCP);
    }",36,,472,InputThread.<lambda>0,2,,tools\vtpipeterm\main.cpp:<global>
625438,METHOD_REF,3,,InputThread,40,,501,InputThread,3,,WINAPI
625473,METHOD_REF,1,,CtrlHandler,27,,529,CtrlHandler,1,,WINAPI
625633,METHOD_REF,2,,DebugReadCallback,31,,592,DebugReadCallback,2,,void
633781,METHOD_REF,2,,"[](long clientPos, double termControlPos, double padding, double scaleFactor) {
        auto result = base::ClampedNumeric<double>(padding);
        // only the padding is in DIPs now
        result *= scaleFactor;
        result += clientPos;
        result += termControlPos;
        return result;
    }",33,,80,TermControlUiaTextRange._TranslatePointToScreen.<lambda>0,2,,types\TermControlUiaTextRange.cpp:<global>
633848,METHOD_REF,2,,"[](long screenPos, double termControlPos, double padding, double scaleFactor) {
        auto result = base::ClampedNumeric<double>(padding);
        // only the padding is in DIPs now
        result /= scaleFactor;
        result -= screenPos;
        result -= termControlPos;
        return result;
    }",33,,114,TermControlUiaTextRange._TranslatePointFromScreen.<lambda>1,2,,types\TermControlUiaTextRange.cpp:<global>
636614,METHOD_REF,2,,"[options]() {
            switch (options)
            {
            case ProviderOptions_ServerSideProvider:
                return L""ServerSideProvider"";
            default:
                return L""UNKNOWN VALUE"";
            }
        }",27,,488,UiaTracing.TextProvider.get_ProviderOptions.<lambda>0,2,,types\UiaTracing.cpp:<global>
636651,METHOD_REF,2,,"[patternId]() {
            switch (patternId)
            {
            case UIA_TextPatternId:
                return L""TextPattern"";
            default:
                return L""UNKNOWN VALUE"";
            }
        }",27,,513,UiaTracing.TextProvider.GetPatternProvider.<lambda>1,2,,types\UiaTracing.cpp:<global>
636688,METHOD_REF,2,,"[propertyId]() {
            switch (propertyId)
            {
            case UIA_ControlTypePropertyId:
                return L""ControlTypePropertyId"";
            case UIA_NamePropertyId:
                return L""NamePropertyId"";
            case UIA_AutomationIdPropertyId:
                return L""AutomationIdPropertyId"";
            case UIA_IsControlElementPropertyId:
                return L""IsControlElementPropertyId"";
            case UIA_IsContentElementPropertyId:
                return L""IsContentElementPropertyId"";
            case UIA_IsKeyboardFocusablePropertyId:
                return L""IsKeyboardFocusablePropertyId"";
            case UIA_HasKeyboardFocusPropertyId:
                return L""HasKeyboardFocusPropertyId"";
            case UIA_ProviderDescriptionPropertyId:
                return L""ProviderDescriptionPropertyId"";
            case UIA_IsEnabledPropertyId:
                return L""IsEnabledPropertyId"";
            default:
                return L""UNKNO...",28,,538,UiaTracing.TextProvider.GetPropertyValue.<lambda>2,2,,types\UiaTracing.cpp:<global>
636960,METHOD_REF,2,,"[point]() {
            std::wstringstream stream;
            stream << ""{ "" << point.x << "", "" << point.y << "" }"";
            return stream.str();
        }",25,,680,UiaTracing.TextProvider.RangeFromPoint.<lambda>3,2,,types\UiaTracing.cpp:<global>
637045,METHOD_REF,2,,"[result]() {
            switch (result)
            {
            case SupportedTextSelection_Single:
                return L""Single"";
            default:
                return L""UNKNOWN VALUE"";
            }
        }",26,,717,UiaTracing.TextProvider.get_SupportedTextSelection.<lambda>4,2,,types\UiaTracing.cpp:<global>
642242,METHOD_REF,2,,"[](auto& expected, auto& cwd, auto& startingDir) {
        VERIFY_ARE_EQUAL(expected, EvaluateStartingDirectory(cwd, startingDir));
    }",17,,557,UtilsTests.TestEvaluateStartingDirectory.<lambda>0,2,,types\ut_types\UtilsTests.cpp:<global>
643175,METHOD_REF,4,,"[](const auto x) {
            return x >= L'A' && x <= L'Z' ? static_cast<wchar_t>(std::towlower(x)) : x;
        }",70,,183,Utils.ColorFromXParseColorSpec.<lambda>0,5,,types\utils.cpp:<global>
643509,METHOD_REF,0,,"[] {
        std::array<uint8_t, 101> lut{};
        for (size_t i = 0; i < std::size(lut); i++)
        {
            lut.at(i) = gsl::narrow_cast<uint8_t>((i * 255 + 50) / 100);
        }
        return lut;
    }",43,,346,Utils.ColorFromRGB100.<lambda>1,1,,types\utils.cpp:<global>
643971,METHOD_REF,2,,"[](wchar_t c) {
        if (c >= L'\x20' && c < L'\x7f')
        {
            // Printable ASCII characters.
            return false;
        }

        if (c > L'\x9f')
        {
            // Not a control code.
            return false;
        }

        // All C0 & C1 control codes will be removed except HT(0x09), LF(0x0a) and CR(0x0d).
        return c != L'\x09' && c != L'\x0a' && c != L'\x0d';
    }",32,,536,Utils.FilterStringForPaste.<lambda>2,2,,types\utils.cpp:<global>
644283,METHOD_REF,0,,"[]() {
        try
        {
            wil::unique_handle processToken{ GetCurrentProcessToken() };
            const auto elevationType = wil::get_token_information<TOKEN_ELEVATION_TYPE>(processToken.get());
            const auto elevationState = wil::get_token_information<TOKEN_ELEVATION>(processToken.get());
            if (elevationType == TokenElevationTypeDefault && elevationState.TokenIsElevated)
            {
                // In this case, the user has UAC entirely disabled. This is sort of
                // weird, we treat this like the user isn't an admin at all. There's no
                // separation of powers, so the things we normally want to gate on
                // ""having special powers"" doesn't apply.
                //
                // See GH#7754, GH#11096
                return false;
                // drag drop is _not_ broken -> they _can_ drag drop
            }

            // If they are running admin, they cannot drag drop.
            return w...",36,,667,Utils.CanUwpDragDrop.<lambda>3,1,,types\utils.cpp:<global>
644295,METHOD_REF,0,,"[]() {
        try
        {
            return wil::test_token_membership(nullptr, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS);
        }
        catch (...)
        {
            LOG_CAUGHT_EXCEPTION();
            return false;
        }
    }",30,,703,Utils.IsRunningElevated.<lambda>4,1,,types\utils.cpp:<global>
644641,METHOD_REF,0,,"[]() noexcept {
        OSVERSIONINFOEXW osver{};
        osver.dwOSVersionInfoSize = sizeof(osver);
        osver.dwBuildNumber = 22000;

        DWORDLONG dwlConditionMask = 0;
        VER_SET_CONDITION(dwlConditionMask, VER_BUILDNUMBER, VER_GREATER_EQUAL);

        if (VerifyVersionInfoW(&osver, VER_BUILDNUMBER, dwlConditionMask) != FALSE)
        {
            return true;
        }
        return false;
    }",37,,858,Utils.IsWindows11.<lambda>5,1,,types\utils.cpp:<global>
646274,METHOD_REF,1,,"[&] {
        DeleteProcThreadAttributeList(siEx.lpAttributeList);
    }",43,,128,AttachPseudoConsole.<lambda>0,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
646528,METHOD_REF,1,,"[&] {
        _ClosePseudoConsoleMembers(&pcon, INFINITE);
    }",37,,214,ConPtyTests.GoodCreate.<lambda>1,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
646623,METHOD_REF,1,,"[&] {
        _ClosePseudoConsoleMembers(&pcon1, INFINITE);
    }",38,,243,ConPtyTests.GoodCreateMultiple.<lambda>2,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
646645,METHOD_REF,1,,"[&] {
        _ClosePseudoConsoleMembers(&pcon2, INFINITE);
    }",38,,253,ConPtyTests.GoodCreateMultiple.<lambda>3,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
646738,METHOD_REF,1,,"[&] {
        _ClosePseudoConsoleMembers(&pty, INFINITE);
    }",38,,280,ConPtyTests.SurvivesOnBreakOutput.<lambda>4,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
646913,METHOD_REF,1,,"[&] {
        _ClosePseudoConsoleMembers(&pty, INFINITE);
    }",38,,339,ConPtyTests.DiesOnClose.<lambda>5,2,,winconpty\ft_pty\ConPtyTests.cpp:<global>
647297,METHOD_REF,0,,"[]() {
#if defined(__INSIDE_WINDOWS)
        return _InboxConsoleHostPath();
#else
        // Use the STL only if we're not building in Windows.
        std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
        modulePath.replace_filename(L""OpenConsole.exe"");
        if (!std::filesystem::exists(modulePath))
        {
            std::wstring_view architectureInfix{};
            USHORT unusedImageFileMachine{}, nativeMachine{};
            if (IsWow64Process2(GetCurrentProcess(), &unusedImageFileMachine, &nativeMachine))
            {
                // Despite being a machine type, the values IsWow64Process2 returns are *image* types
                switch (nativeMachine)
                {
                case IMAGE_FILE_MACHINE_AMD64:
                    architectureInfix = L""x64"";
                    break;
                case IMAGE_FILE_MACHINE_ARM64:
                    architectureInfix = L""arm64"";
                    ...",35,,42,_ConsoleHostPath.<lambda>0,1,,winconpty\winconpty.cpp:<global>
