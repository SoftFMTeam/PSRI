103,UNKNOWN,8,,"void MidiAudio::PlayNote(HWND windowHandle, const int noteNumber, const int velocity, const std::chrono::milliseconds duration) noexcept
try
{
    if (_skip.is_signaled())
    {
        return;
    }

    if (_hwnd != windowHandle)
    {
        _initialize(windowHandle);
    }

    const auto& buffer = _buffers.at(_activeBufferIndex);
    if (velocity && buffer)
    {
        // The formula for frequency is 2^(n/12) * 440Hz, where n is zero for
        // the A above middle C (A4). In MIDI terms, A4 is note number 69,
        // which is why we subtract 69. We also need to multiply by the size
        // of the wave form to determine the frequency that the sound buffer
        // has to be played to achieve the equivalent note frequency.
        const auto frequency = std::pow(2.0, (noteNumber - 69.0) / 12.0) * 440.0 * WAVE_SIZE;
        buffer->SetFrequency(gsl::narrow_cast<DWORD>(frequency));
        // For the volume, we're using the formula defined in the General
        // MID...",1,<empty>,,45,8,CPPASTProblemDeclaration,,<empty>
638,UNKNOWN,-1,,"try
    {
        switch (_mode)
        {
        case Mode::Loose:
        case Mode::LooseTextOnly:
        {
            // In lieu of using start and end, this custom iterator type simply becomes bool false
            // when we run out of items to iterate over.
            return _pos < std::get<std::wstring_view>(_run).length();
        }
        case Mode::Fill:
        {
            if (_fillLimit > 0)
            {
                return _pos < _fillLimit;
            }
            return true;
        }
        case Mode::Cell:
        {
            return _pos < std::get<std::span<const OutputCell>>(_run).size();
        }
        case Mode::CharInfo:
        {
            return _pos < std::get<std::span<const CHAR_INFO>>(_run).size();
        }
        case Mode::LegacyAttr:
        {
            return _pos < std::get<std::span<const WORD>>(_run).size();
        }
        default:
            FAIL_FAST_HR(E_NOTIMPL);
        }
    }
    CATCH_FAIL_FAST();",5,<empty>,,163,1,CPPASTProblemStatement,,<empty>
2173,UNKNOWN,-1,,e,24,<empty>,,374,4,CPPASTProblemStatement,,<empty>
3073,UNKNOWN,1,,size_t,77,<empty>,,740,1,CPPASTTypeId,,<empty>
4191,UNKNOWN,1,,uint16_t,24,<empty>,,1098,1,CPPASTTypeId,,<empty>
4203,UNKNOWN,1,,uint16_t,24,<empty>,,1104,1,CPPASTTypeId,,<empty>
4217,UNKNOWN,1,,uint16_t,24,<empty>,,1110,1,CPPASTTypeId,,<empty>
5201,UNKNOWN,1,,WORD,40,<empty>,,119,1,CPPASTTypeId,,<empty>
5304,UNKNOWN,1,,UnderlineStyle,24,<empty>,,175,1,CPPASTTypeId,,<empty>
5673,UNKNOWN,1,,CharacterAttributes,76,<empty>,,366,1,CPPASTTypeId,,<empty>
7376,UNKNOWN,5,,"static UText* U_CALLCONV utextClone(UText* dest, const UText* src, UBool deep, UErrorCode* status) noexcept
{
    __assume(status != nullptr);

    if (deep)
    {
        *status = U_UNSUPPORTED_ERROR;
        return dest;
    }

    dest = utext_setup(dest, 0, status);
    if (*status <= U_ZERO_ERROR)
    {
        memcpy(dest, src, sizeof(UText));
    }

    return dest;
}",1,<empty>,,48,5,CPPASTProblemDeclaration,,<empty>
7377,UNKNOWN,6,,"static int64_t U_CALLCONV utextNativeLength(UText* ut) noexcept
try
{
    auto length = accessLength(ut);

    if (!length)
    {
        const auto& textBuffer = *static_cast<const TextBuffer*>(ut->context);
        const auto range = accessRowRange(ut);

        for (til::CoordType y = range.begin; y < range.end; ++y)
        {
            length += textBuffer.GetRowByOffset(y).GetText().size();
        }

        accessLength(ut) = length;
    }

    return gsl::narrow_cast<int64_t>(length);
}",1,<empty>,,73,6,CPPASTProblemDeclaration,,<empty>
7378,UNKNOWN,7,,"catch (...)
{
    return 0;
}",1,<empty>,,93,7,CPPASTProblemDeclaration,,<empty>
7379,UNKNOWN,8,,"static UBool U_CALLCONV utextAccess(UText* ut, int64_t nativeIndex, UBool forward) noexcept
try
{
    if (nativeIndex < 0)
    {
        nativeIndex = 0;
    }

    auto neededIndex = nativeIndex;
    if (!forward)
    {
        neededIndex--;
    }

    const auto& textBuffer = *static_cast<const TextBuffer*>(ut->context);
    const auto range = accessRowRange(ut);
    auto start = ut->chunkNativeStart;
    auto limit = ut->chunkNativeLimit;
    auto y = accessCurrentRow(ut);
    std::wstring_view text;

    if (neededIndex < start || neededIndex >= limit)
    {
        if (neededIndex < start)
        {
            do
            {
                --y;
                if (y < range.begin)
                {
                    return false;
                }

                text = textBuffer.GetRowByOffset(y).GetText();
                limit = start;
                start -= text.size();
            } while (neededIndex < start);
        }
        else
        {
            do
   ...",1,<empty>,,111,8,CPPASTProblemDeclaration,,<empty>
7380,UNKNOWN,9,,"catch (...)
{
    return false;
}",1,<empty>,,186,9,CPPASTProblemDeclaration,,<empty>
7381,UNKNOWN,10,,"static int32_t U_CALLCONV utextExtract(UText* ut, int64_t nativeStart, int64_t nativeLimit, char16_t* dest, int32_t destCapacity, UErrorCode* status) noexcept
try
{
    __assume(status != nullptr);

    if (*status > U_ZERO_ERROR)
    {
        return 0;
    }
    if (destCapacity < 0 || (dest == nullptr && destCapacity > 0) || nativeStart > nativeLimit)
    {
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    if (!utextAccess(ut, nativeStart, true))
    {
        return 0;
    }

    nativeLimit = std::min(ut->chunkNativeLimit, nativeLimit);

    if (destCapacity <= 0)
    {
        return gsl::narrow_cast<int32_t>(nativeLimit - nativeStart);
    }

    const auto& textBuffer = *static_cast<const TextBuffer*>(ut->context);
    const auto y = accessCurrentRow(ut);
    const auto offset = ut->chunkNativeStart - nativeStart;
    const auto text = textBuffer.GetRowByOffset(y).GetText().substr(gsl::narrow_cast<size_t>(std::max<int64_t>(0, offset)));
    const auto ...",1,<empty>,,208,10,CPPASTProblemDeclaration,,<empty>
7382,UNKNOWN,11,,"catch (...)
{
    // The only thing that can fail is GetRowByOffset() which in turn can only fail when VirtualAlloc() fails.
    *status = U_MEMORY_ALLOCATION_ERROR;
    return 0;
}",1,<empty>,,252,11,CPPASTProblemDeclaration,,<empty>
7383,UNKNOWN,12,,"static constexpr UTextFuncs utextFuncs{
    .tableSize = sizeof(UTextFuncs),
    .clone = utextClone,
    .nativeLength = utextNativeLength,
    .access = utextAccess,",1,<empty>,,259,12,CPPASTProblemDeclaration,,<empty>
7384,UNKNOWN,13,,};,1,<empty>,,264,13,CPPASTProblemDeclaration,,<empty>
7447,UNKNOWN,1,,const char16_t*,50,<empty>,,284,1,CPPASTTypeId,,<empty>
7514,UNKNOWN,1,,const TextBuffer*,43,<empty>,,303,1,CPPASTTypeId,,<empty>
7843,UNKNOWN,-1,,"try
    {
        _parentBuffer.TriggerRedrawCursor(_cPosition);
    }
    CATCH_LOG();",5,<empty>,,191,1,CPPASTProblemStatement,,<empty>
8909,UNKNOWN,1,,int,61,<empty>,,2369,1,CPPASTTypeId,,<empty>
8914,UNKNOWN,1,,int,63,<empty>,,2370,1,CPPASTTypeId,,<empty>
8919,UNKNOWN,1,,int,62,<empty>,,2371,1,CPPASTTypeId,,<empty>
9207,UNKNOWN,1,,std::byte*,21,<empty>,,109,1,CPPASTTypeId,,<empty>
9350,UNKNOWN,1,,ROW*,43,<empty>,,156,1,CPPASTTypeId,,<empty>
9356,UNKNOWN,1,,wchar_t*,45,<empty>,,157,1,CPPASTTypeId,,<empty>
9364,UNKNOWN,1,,uint16_t*,47,<empty>,,158,1,CPPASTTypeId,,<empty>
9402,UNKNOWN,1,,ROW*,42,<empty>,,168,1,CPPASTTypeId,,<empty>
9442,UNKNOWN,1,,ROW*,30,<empty>,,184,1,CPPASTTypeId,,<empty>
9469,UNKNOWN,1,,TextBuffer*,23,<empty>,,203,1,CPPASTTypeId,,<empty>
10205,UNKNOWN,-1,,e,21,<empty>,,588,2,CPPASTProblemStatement,,<empty>
10248,UNKNOWN,-1,,e,28,<empty>,,612,2,CPPASTProblemStatement,,<empty>
14621,UNKNOWN,-1,,e,32,<empty>,,2642,6,CPPASTProblemStatement,,<empty>
18284,UNKNOWN,1,,void,14,<empty>,,619,1,CPPASTTypeId,,<empty>
18405,UNKNOWN,1,,void,14,<empty>,,672,1,CPPASTTypeId,,<empty>
18761,UNKNOWN,-1,,"TEST_METHOD(TestReflowCases)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""DataSource"", L""Export:ReflowTestDataSource"")
        END_TEST_METHOD_PROPERTIES()

        WEX::TestExecution::DisableVerifyExceptions disableVerifyExceptions{};",5,<empty>,,779,6,CPPASTProblemDeclaration,,<empty>
18764,UNKNOWN,-1,,"TestData::TryGetValue(L""index"", i);",9,<empty>,,789,9,CPPASTProblemDeclaration,,<empty>
18766,UNKNOWN,-1,,"Log::Comment(NoThrowString().Format(L""[%zu.0] Test case \""%.*s\"""", i, testCase.name.size(), testCase.name.data()));",9,<empty>,,791,11,CPPASTProblemDeclaration,,<empty>
18768,UNKNOWN,-1,,for (size_t bufferIndex{ 1 };,9,<empty>,,795,13,CPPASTProblemDeclaration,,<empty>
18769,UNKNOWN,-1,,bufferIndex < testCase.buffers.size();,39,<empty>,,795,14,CPPASTProblemDeclaration,,<empty>
18770,UNKNOWN,-1,,"++bufferIndex)
        {
            const auto& testBuffer{ til::at(testCase.buffers, bufferIndex) };
            Log::Comment(NoThrowString().Format(L""[%zu.%zu] Resizing to %dx%d"", i, bufferIndex, testBuffer.size.width, testBuffer.size.height));

            auto newBuffer{ _textBufferByReflowingTextBuffer(*textBuffer, testBuffer.size) };

            // All future operations are based on the new buffer
            std::swap(textBuffer, newBuffer);

            _compareTextBufferAgainstTestBuffer(*textBuffer, testBuffer);
        }",78,<empty>,,795,15,CPPASTProblemDeclaration,,<empty>
18804,UNKNOWN,5,,},5,<empty>,,807,5,CPPASTProblemDeclaration,,<empty>
18805,UNKNOWN,6,,};,1,<empty>,,808,6,CPPASTProblemDeclaration,,<empty>
19024,UNKNOWN,1,,WORD,44,<empty>,,78,1,CPPASTTypeId,,<empty>
21186,UNKNOWN,-1,,),42,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
21187,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleColorScheme);",13,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
21346,UNKNOWN,1,,uint32_t,69,<empty>,,88,1,CPPASTTypeId,,<empty>
21885,UNKNOWN,-1,,),38,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
21886,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ManyCommandsSameAction);",13,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
24275,UNKNOWN,-1,,),46,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
24276,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ValidateProfilesExist);",13,<empty>,,37,3,CPPASTProblemDeclaration,,<empty>
24555,UNKNOWN,1,,size_t,42,<empty>,,244,1,CPPASTTypeId,,<empty>
24566,UNKNOWN,1,,size_t,42,<empty>,,245,1,CPPASTTypeId,,<empty>
24611,UNKNOWN,1,,size_t,42,<empty>,,253,1,CPPASTTypeId,,<empty>
24634,UNKNOWN,1,,size_t,42,<empty>,,256,1,CPPASTTypeId,,<empty>
24679,UNKNOWN,1,,size_t,42,<empty>,,264,1,CPPASTTypeId,,<empty>
24702,UNKNOWN,1,,size_t,42,<empty>,,267,1,CPPASTTypeId,,<empty>
24747,UNKNOWN,1,,size_t,42,<empty>,,275,1,CPPASTTypeId,,<empty>
24758,UNKNOWN,1,,size_t,42,<empty>,,276,1,CPPASTTypeId,,<empty>
24802,UNKNOWN,1,,size_t,38,<empty>,,319,1,CPPASTTypeId,,<empty>
24825,UNKNOWN,1,,size_t,38,<empty>,,322,1,CPPASTTypeId,,<empty>
25771,UNKNOWN,-1,,"VERIFY_THROWS_SPECIFIC(winrt::make_self<implementation::CascadiaSettings>(settingsWithoutProfiles), const implementation::SettingsException, [](const auto& ex) {
                return ex.Error() == SettingsLoadErrors::AllProfilesHidden;
            }",13,<empty>,,713,1,CPPASTProblemStatement,,<empty>
25772,UNKNOWN,-1,,);,14,<empty>,,715,2,CPPASTProblemStatement,,<empty>
27111,UNKNOWN,1,,int32_t,99,<empty>,,1294,1,CPPASTTypeId,,<empty>
27124,UNKNOWN,1,,int32_t,99,<empty>,,1295,1,CPPASTTypeId,,<empty>
27137,UNKNOWN,1,,int32_t,99,<empty>,,1296,1,CPPASTTypeId,,<empty>
27364,UNKNOWN,1,,int32_t,71,<empty>,,1379,1,CPPASTTypeId,,<empty>
27469,UNKNOWN,1,,int32_t,71,<empty>,,1396,1,CPPASTTypeId,,<empty>
27569,UNKNOWN,1,,int32_t,71,<empty>,,1410,1,CPPASTTypeId,,<empty>
27669,UNKNOWN,1,,int32_t,71,<empty>,,1424,1,CPPASTTypeId,,<empty>
27769,UNKNOWN,1,,int32_t,71,<empty>,,1438,1,CPPASTTypeId,,<empty>
28901,UNKNOWN,1,,int,80,<empty>,,1971,1,CPPASTTypeId,,<empty>
29246,UNKNOWN,-1,,),42,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
29247,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(KeyChords);",13,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
29769,UNKNOWN,1,,int32_t,99,<empty>,,206,1,CPPASTTypeId,,<empty>
29817,UNKNOWN,1,,int32_t,99,<empty>,,216,1,CPPASTTypeId,,<empty>
29865,UNKNOWN,1,,int32_t,99,<empty>,,226,1,CPPASTTypeId,,<empty>
29913,UNKNOWN,1,,int32_t,99,<empty>,,236,1,CPPASTTypeId,,<empty>
29948,UNKNOWN,1,,int32_t,99,<empty>,,242,1,CPPASTTypeId,,<empty>
29993,UNKNOWN,1,,int32_t,76,<empty>,,255,1,CPPASTTypeId,,<empty>
30103,UNKNOWN,1,,int32_t,65,<empty>,,299,1,CPPASTTypeId,,<empty>
30150,UNKNOWN,1,,int32_t,64,<empty>,,309,1,CPPASTTypeId,,<empty>
30197,UNKNOWN,1,,int32_t,64,<empty>,,319,1,CPPASTTypeId,,<empty>
30244,UNKNOWN,1,,int32_t,65,<empty>,,329,1,CPPASTTypeId,,<empty>
30307,UNKNOWN,1,,int32_t,64,<empty>,,340,1,CPPASTTypeId,,<empty>
30382,UNKNOWN,1,,int32_t,64,<empty>,,353,1,CPPASTTypeId,,<empty>
30457,UNKNOWN,1,,int32_t,64,<empty>,,366,1,CPPASTTypeId,,<empty>
30512,UNKNOWN,1,,int32_t,64,<empty>,,377,1,CPPASTTypeId,,<empty>
30567,UNKNOWN,1,,int32_t,65,<empty>,,388,1,CPPASTTypeId,,<empty>
30623,UNKNOWN,1,,int32_t,65,<empty>,,399,1,CPPASTTypeId,,<empty>
30713,UNKNOWN,1,,int32_t,65,<empty>,,425,1,CPPASTTypeId,,<empty>
30762,UNKNOWN,1,,int32_t,65,<empty>,,433,1,CPPASTTypeId,,<empty>
30811,UNKNOWN,1,,int32_t,65,<empty>,,441,1,CPPASTTypeId,,<empty>
30860,UNKNOWN,1,,int32_t,65,<empty>,,449,1,CPPASTTypeId,,<empty>
30951,UNKNOWN,1,,int32_t,65,<empty>,,474,1,CPPASTTypeId,,<empty>
30997,UNKNOWN,1,,int32_t,65,<empty>,,482,1,CPPASTTypeId,,<empty>
31060,UNKNOWN,1,,int32_t,65,<empty>,,492,1,CPPASTTypeId,,<empty>
31148,UNKNOWN,1,,int32_t,65,<empty>,,515,1,CPPASTTypeId,,<empty>
31228,UNKNOWN,1,,int32_t,66,<empty>,,542,1,CPPASTTypeId,,<empty>
31274,UNKNOWN,1,,int32_t,66,<empty>,,550,1,CPPASTTypeId,,<empty>
31320,UNKNOWN,1,,int32_t,65,<empty>,,558,1,CPPASTTypeId,,<empty>
31366,UNKNOWN,1,,int32_t,65,<empty>,,566,1,CPPASTTypeId,,<empty>
31412,UNKNOWN,1,,int32_t,64,<empty>,,574,1,CPPASTTypeId,,<empty>
31467,UNKNOWN,1,,int32_t,64,<empty>,,583,1,CPPASTTypeId,,<empty>
31538,UNKNOWN,-1,,VERIFY_THROWS(invalidActionMap->LayerJson(bindingsInvalidJson);,13,<empty>,,596,8,CPPASTProblemStatement,,<empty>
31539,UNKNOWN,-1,,", std::exception);",76,<empty>,,596,9,CPPASTProblemStatement,,<empty>
31592,UNKNOWN,1,,int32_t,66,<empty>,,615,1,CPPASTTypeId,,<empty>
31641,UNKNOWN,1,,int32_t,66,<empty>,,623,1,CPPASTTypeId,,<empty>
31732,UNKNOWN,-1,,VERIFY_THROWS(invalidActionMap->LayerJson(bindingsInvalidJson);,13,<empty>,,641,8,CPPASTProblemStatement,,<empty>
31733,UNKNOWN,-1,,", std::exception);",76,<empty>,,641,9,CPPASTProblemStatement,,<empty>
31786,UNKNOWN,1,,int32_t,66,<empty>,,661,1,CPPASTTypeId,,<empty>
31835,UNKNOWN,1,,int32_t,65,<empty>,,669,1,CPPASTTypeId,,<empty>
31884,UNKNOWN,1,,int32_t,64,<empty>,,677,1,CPPASTTypeId,,<empty>
31949,UNKNOWN,-1,,VERIFY_THROWS(invalidActionMap->LayerJson(bindingsInvalidJson);,13,<empty>,,689,8,CPPASTProblemStatement,,<empty>
31950,UNKNOWN,-1,,", std::exception);",76,<empty>,,689,9,CPPASTProblemStatement,,<empty>
32050,UNKNOWN,1,,int32_t,80,<empty>,,726,1,CPPASTTypeId,,<empty>
32105,UNKNOWN,1,,int32_t,80,<empty>,,737,1,CPPASTTypeId,,<empty>
32174,UNKNOWN,1,,int32_t,80,<empty>,,749,1,CPPASTTypeId,,<empty>
32218,UNKNOWN,1,,int32_t,109,<empty>,,757,1,CPPASTTypeId,,<empty>
32376,UNKNOWN,-1,,),41,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
32377,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(DefaultsToRemainingProfiles);",13,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
32603,UNKNOWN,-1,,),38,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
32604,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ProfileGeneratesGuid);",13,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
33703,UNKNOWN,1,,uint32_t,42,<empty>,,371,1,CPPASTTypeId,,<empty>
33760,UNKNOWN,1,,uint32_t,38,<empty>,,394,1,CPPASTTypeId,,<empty>
33939,UNKNOWN,-1,,),44,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
33940,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(GlobalSettings);",13,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
34590,UNKNOWN,-1,,),47,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
34591,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(TryCreateWinRTType);",13,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
34600,UNKNOWN,-1,,"TEST_CLASS_SETUP(ClassSetup)
        {
            return true;",9,<empty>,,48,12,CPPASTProblemDeclaration,,<empty>
34601,UNKNOWN,-1,,},9,<empty>,,51,2,CPPASTProblemDeclaration,,<empty>
34660,UNKNOWN,1,,int,47,<empty>,,76,1,CPPASTTypeId,,<empty>
34697,UNKNOWN,1,,bool,48,<empty>,,87,1,CPPASTTypeId,,<empty>
34704,UNKNOWN,1,,size_t,44,<empty>,,89,1,CPPASTTypeId,,<empty>
34713,UNKNOWN,1,,wchar_t,41,<empty>,,90,1,CPPASTTypeId,,<empty>
34827,UNKNOWN,1,,size_t,59,<empty>,,122,1,CPPASTTypeId,,<empty>
35128,UNKNOWN,1,,uint16_t,60,<empty>,,265,1,CPPASTTypeId,,<empty>
35147,UNKNOWN,1,,const GUID&,60,<empty>,,266,1,CPPASTTypeId,,<empty>
35267,UNKNOWN,1,,int32_t,65,<empty>,,329,1,CPPASTTypeId,,<empty>
35418,UNKNOWN,1,,int32_t,65,<empty>,,350,1,CPPASTTypeId,,<empty>
35578,UNKNOWN,1,,int32_t,65,<empty>,,372,1,CPPASTTypeId,,<empty>
35738,UNKNOWN,1,,int32_t,65,<empty>,,394,1,CPPASTTypeId,,<empty>
35898,UNKNOWN,1,,int32_t,65,<empty>,,416,1,CPPASTTypeId,,<empty>
36058,UNKNOWN,1,,int32_t,65,<empty>,,439,1,CPPASTTypeId,,<empty>
36227,UNKNOWN,1,,int32_t,65,<empty>,,462,1,CPPASTTypeId,,<empty>
36370,UNKNOWN,1,,int32_t,65,<empty>,,482,1,CPPASTTypeId,,<empty>
36528,UNKNOWN,1,,int32_t,65,<empty>,,504,1,CPPASTTypeId,,<empty>
36695,UNKNOWN,1,,int32_t,65,<empty>,,527,1,CPPASTTypeId,,<empty>
36853,UNKNOWN,1,,int32_t,65,<empty>,,549,1,CPPASTTypeId,,<empty>
37020,UNKNOWN,1,,int32_t,65,<empty>,,572,1,CPPASTTypeId,,<empty>
37960,UNKNOWN,11,,},1,<empty>,,885,11,CPPASTProblemDeclaration,,<empty>
38019,UNKNOWN,1,,wchar_t,31,<empty>,,44,1,CPPASTTypeId,,<empty>
38086,UNKNOWN,-1,,),36,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
38087,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleTheme);",13,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
39083,UNKNOWN,-1,,),41,<empty>,,40,2,CPPASTProblemDeclaration,,<empty>
39084,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(ParseSimpleCommandline);",13,<empty>,,41,3,CPPASTProblemDeclaration,,<empty>
39630,UNKNOWN,-1,,),38,<empty>,,195,4,CPPASTProblemStatement,,<empty>
39634,UNKNOWN,-1,,),67,<empty>,,196,6,CPPASTProblemStatement,,<empty>
39751,UNKNOWN,-1,,),38,<empty>,,228,4,CPPASTProblemStatement,,<empty>
39755,UNKNOWN,-1,,),64,<empty>,,229,6,CPPASTProblemStatement,,<empty>
39879,UNKNOWN,-1,,),38,<empty>,,262,4,CPPASTProblemStatement,,<empty>
39883,UNKNOWN,-1,,),67,<empty>,,263,6,CPPASTProblemStatement,,<empty>
41086,UNKNOWN,-1,,),38,<empty>,,452,2,CPPASTProblemStatement,,<empty>
41090,UNKNOWN,-1,,),72,<empty>,,453,4,CPPASTProblemStatement,,<empty>
41092,UNKNOWN,-1,,),36,<empty>,,454,6,CPPASTProblemStatement,,<empty>
41096,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `nt` instead of `new-tab`"")",9,<empty>,,456,1,CPPASTProblemStatement,,<empty>
42731,UNKNOWN,-1,,),38,<empty>,,710,2,CPPASTProblemStatement,,<empty>
42735,UNKNOWN,-1,,),72,<empty>,,711,4,CPPASTProblemStatement,,<empty>
42737,UNKNOWN,-1,,),36,<empty>,,712,6,CPPASTProblemStatement,,<empty>
42741,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `sp` instead of `split-pane`"")",9,<empty>,,714,1,CPPASTProblemStatement,,<empty>
43730,UNKNOWN,-1,,),38,<empty>,,891,2,CPPASTProblemStatement,,<empty>
43734,UNKNOWN,-1,,),78,<empty>,,892,4,CPPASTProblemStatement,,<empty>
43738,UNKNOWN,-1,,),81,<empty>,,893,6,CPPASTProblemStatement,,<empty>
43740,UNKNOWN,-1,,),36,<empty>,,894,8,CPPASTProblemStatement,,<empty>
43744,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortFormNewTab, L""If true, use `nt` instead of `new-tab`"")",9,<empty>,,896,1,CPPASTProblemStatement,,<empty>
43748,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortFormSplitPane, L""If true, use `sp` instead of `split-pane`"")",9,<empty>,,897,1,CPPASTProblemStatement,,<empty>
44485,UNKNOWN,-1,,),38,<empty>,,1022,2,CPPASTProblemStatement,,<empty>
44489,UNKNOWN,-1,,),72,<empty>,,1023,4,CPPASTProblemStatement,,<empty>
44491,UNKNOWN,-1,,),36,<empty>,,1024,6,CPPASTProblemStatement,,<empty>
44495,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `ft` instead of `focus-tab`"")",9,<empty>,,1026,1,CPPASTProblemStatement,,<empty>
44780,UNKNOWN,1,,uint32_t,42,<empty>,,1086,1,CPPASTTypeId,,<empty>
44886,UNKNOWN,-1,,),38,<empty>,,1114,2,CPPASTProblemStatement,,<empty>
44890,UNKNOWN,-1,,),72,<empty>,,1115,4,CPPASTProblemStatement,,<empty>
44892,UNKNOWN,-1,,),36,<empty>,,1116,6,CPPASTProblemStatement,,<empty>
44896,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `mf` instead of `move-focus`"")",9,<empty>,,1118,1,CPPASTProblemStatement,,<empty>
45913,UNKNOWN,-1,,),38,<empty>,,1345,2,CPPASTProblemStatement,,<empty>
45917,UNKNOWN,-1,,),72,<empty>,,1346,4,CPPASTProblemStatement,,<empty>
45919,UNKNOWN,-1,,),36,<empty>,,1347,6,CPPASTProblemStatement,,<empty>
45923,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `fp` instead of `focus-pane`"")",9,<empty>,,1349,1,CPPASTProblemStatement,,<empty>
48060,UNKNOWN,-1,,),38,<empty>,,1778,2,CPPASTProblemStatement,,<empty>
48064,UNKNOWN,-1,,),72,<empty>,,1779,4,CPPASTProblemStatement,,<empty>
48066,UNKNOWN,-1,,),36,<empty>,,1780,6,CPPASTProblemStatement,,<empty>
48070,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useShortForm, L""If true, use `sp` instead of `split-pane`"")",9,<empty>,,1782,1,CPPASTProblemStatement,,<empty>
50925,UNKNOWN,-1,,),46,<empty>,,20,2,CPPASTProblemDeclaration,,<empty>
50926,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(VerifyHighlighting);",13,<empty>,,21,3,CPPASTProblemDeclaration,,<empty>
50993,UNKNOWN,-1,,),39,<empty>,,56,2,CPPASTProblemDeclaration,,<empty>
50994,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""RunAs"", L""UAP"")
            TEST_CLASS_PROPERTY(L""UAP:AppXManifest"", L""TestHostAppXManifest.xml"")
        END_TEST_CLASS()

        TEST_METHOD(TestIterateCommands);",13,<empty>,,57,3,CPPASTProblemDeclaration,,<empty>
51004,UNKNOWN,-1,,"TEST_CLASS_SETUP(ClassSetup)
        {
            return true;",9,<empty>,,74,13,CPPASTProblemDeclaration,,<empty>
51005,UNKNOWN,-1,,},9,<empty>,,77,4,CPPASTProblemDeclaration,,<empty>
51006,UNKNOWN,-1,,"private:
        void _logCommandNames(winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, Command> commands, const int indentation = 1)
        {
            if (indentation == 1)
            {
                Log::Comment((commands.Size() == 0) ? L""Commands:\n  <none>"" : L""Commands:"");
            }
            for (const auto& nameAndCommand : commands)
            {
                Log::Comment(fmt::format(L""{0:>{1}}* {2}->{3}"",
                                         L"""",
                                         indentation,
                                         nameAndCommand.Key(),
                                         nameAndCommand.Value().Name())
                                 .c_str());

                if (nameAndCommand.Value().HasNestedCommands())
                {
                    _logCommandNames(nameAndCommand.Value().NestedCommands(), indentation + 2);
                }
            }
        }",5,<empty>,,79,5,CPPASTProblemDeclaration,,<empty>
53824,UNKNOWN,-1,,"""",90,<empty>,,942,2,CPPASTProblemStatement,,<empty>
54064,UNKNOWN,-1,,"""",90,<empty>,,1047,2,CPPASTProblemStatement,,<empty>
55115,UNKNOWN,1,,int32_t,65,<empty>,,1382,1,CPPASTTypeId,,<empty>
55260,UNKNOWN,1,,int32_t,65,<empty>,,1404,1,CPPASTTypeId,,<empty>
55405,UNKNOWN,1,,int32_t,65,<empty>,,1426,1,CPPASTTypeId,,<empty>
55550,UNKNOWN,1,,int32_t,65,<empty>,,1449,1,CPPASTTypeId,,<empty>
55706,UNKNOWN,1,,int32_t,65,<empty>,,1472,1,CPPASTTypeId,,<empty>
55862,UNKNOWN,1,,int32_t,65,<empty>,,1495,1,CPPASTTypeId,,<empty>
56018,UNKNOWN,1,,int32_t,65,<empty>,,1519,1,CPPASTTypeId,,<empty>
56174,UNKNOWN,1,,int32_t,65,<empty>,,1541,1,CPPASTTypeId,,<empty>
56330,UNKNOWN,1,,int32_t,65,<empty>,,1564,1,CPPASTTypeId,,<empty>
56473,UNKNOWN,12,,},1,<empty>,,1586,12,CPPASTProblemDeclaration,,<empty>
59493,UNKNOWN,-1,,"private:
        void _initializeTerminalPage(winrt::com_ptr<winrt::TerminalApp::implementation::TerminalPage>& page,
                                     CascadiaSettings initialSettings);",5,<empty>,,111,2,CPPASTProblemDeclaration,,<empty>
60128,UNKNOWN,-1,,),38,<empty>,,698,2,CPPASTProblemStatement,,<empty>
60132,UNKNOWN,-1,,),62,<empty>,,699,4,CPPASTProblemStatement,,<empty>
60134,UNKNOWN,-1,,),36,<empty>,,700,6,CPPASTProblemStatement,,<empty>
60677,UNKNOWN,-1,,),38,<empty>,,1254,2,CPPASTProblemStatement,,<empty>
60681,UNKNOWN,-1,,),62,<empty>,,1255,4,CPPASTProblemStatement,,<empty>
60683,UNKNOWN,-1,,),36,<empty>,,1256,6,CPPASTProblemStatement,,<empty>
60709,UNKNOWN,-1,,),38,<empty>,,1286,2,CPPASTProblemStatement,,<empty>
60713,UNKNOWN,-1,,),62,<empty>,,1287,4,CPPASTProblemStatement,,<empty>
60715,UNKNOWN,-1,,),36,<empty>,,1288,6,CPPASTProblemStatement,,<empty>
60894,UNKNOWN,28,,},1,<empty>,,1563,28,CPPASTProblemDeclaration,,<empty>
60908,UNKNOWN,-1,,"void App::OnLaunched(Windows::ApplicationModel::Activation::LaunchActivatedEventArgs ^ e)
    {
        Windows::UI::Xaml::Window::Current->Activate();
        Microsoft::VisualStudio::TestPlatform::TestExecutor::WinRTCore::UnitTestClient::Run(e->Arguments);
    }",5,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
60917,UNKNOWN,-1,,"ref class App sealed
    {
    protected:
        virtual void OnLaunched(Windows::ApplicationModel::Activation::LaunchActivatedEventArgs ^ e) override;

        internal :
            App();
    };",5,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
61097,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, ShowWindowCommand, SW_NORMAL);",9,<empty>,,34,7,CPPASTProblemDeclaration,,<empty>
61130,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Microsoft::Terminal::Remoting::CommandlineArgs, Args, nullptr);",9,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
61131,UNKNOWN,-1,,"WINRT_PROPERTY(int, ResultTargetWindow, -1);",9,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
61132,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, ResultTargetWindowName);",9,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
61162,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowLayoutJson, L"""");",9,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
61163,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>, WindowLayoutJsonAsync, nullptr)",9,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
61555,UNKNOWN,-1,,"try
        {
            _desktopManager = winrt::create_instance<IVirtualDesktopManager>(__uuidof(VirtualDesktopManager));
        }
        CATCH_LOG();",9,<empty>,,26,1,CPPASTProblemStatement,,<empty>
62321,UNKNOWN,1,,HWND,101,<empty>,,572,1,CPPASTTypeId,,<empty>
63462,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, Id);",9,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
63463,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowName);",9,<empty>,,68,6,CPPASTProblemDeclaration,,<empty>
63464,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, CurrentDirectory);",9,<empty>,,69,7,CPPASTProblemDeclaration,,<empty>
63465,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Content);",9,<empty>,,70,8,CPPASTProblemDeclaration,,<empty>
63466,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, ShowWindowCommand, SW_NORMAL);",9,<empty>,,71,9,CPPASTProblemDeclaration,,<empty>
63467,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, CurrentEnvironment);",9,<empty>,,72,10,CPPASTProblemDeclaration,,<empty>
63468,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::IReference<Windows::Foundation::Rect>, InitialBounds);",9,<empty>,,73,11,CPPASTProblemDeclaration,,<empty>
63546,UNKNOWN,-1,,"TYPED_EVENT(FindTargetWindowRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::FindTargetWindowArgs);",9,<empty>,,104,17,CPPASTProblemDeclaration,,<empty>
63547,UNKNOWN,-1,,"TYPED_EVENT(ShowNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,105,18,CPPASTProblemDeclaration,,<empty>
63548,UNKNOWN,-1,,"TYPED_EVENT(HideNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,106,19,CPPASTProblemDeclaration,,<empty>
63549,UNKNOWN,-1,,"TYPED_EVENT(WindowCreated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,107,20,CPPASTProblemDeclaration,,<empty>
63550,UNKNOWN,-1,,"TYPED_EVENT(WindowClosed, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,108,21,CPPASTProblemDeclaration,,<empty>
63551,UNKNOWN,-1,,"TYPED_EVENT(QuitAllRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::QuitAllRequestedArgs);",9,<empty>,,109,22,CPPASTProblemDeclaration,,<empty>
63552,UNKNOWN,-1,,"TYPED_EVENT(RequestNewWindow, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::WindowRequestedArgs);",9,<empty>,,111,23,CPPASTProblemDeclaration,,<empty>
64321,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Content);",9,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
64322,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabIndex);",9,<empty>,,20,2,CPPASTProblemDeclaration,,<empty>
64330,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, SourceWindow);",9,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
64331,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, TargetWindow);",9,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
64332,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabIndex);",9,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
64424,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowName);",9,<empty>,,71,20,CPPASTProblemDeclaration,,<empty>
64425,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, ActiveTabTitle);",9,<empty>,,72,21,CPPASTProblemDeclaration,,<empty>
64426,UNKNOWN,-1,,"TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::WindowActivatedArgs);",9,<empty>,,74,22,CPPASTProblemDeclaration,,<empty>
64427,UNKNOWN,-1,,"TYPED_EVENT(ExecuteCommandlineRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::CommandlineArgs);",9,<empty>,,75,23,CPPASTProblemDeclaration,,<empty>
64428,UNKNOWN,-1,,"TYPED_EVENT(IdentifyWindowsRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,76,24,CPPASTProblemDeclaration,,<empty>
64429,UNKNOWN,-1,,"TYPED_EVENT(DisplayWindowIdRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,77,25,CPPASTProblemDeclaration,,<empty>
64430,UNKNOWN,-1,,"TYPED_EVENT(RenameRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::RenameRequestArgs);",9,<empty>,,78,26,CPPASTProblemDeclaration,,<empty>
64431,UNKNOWN,-1,,"TYPED_EVENT(SummonRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::SummonWindowBehavior);",9,<empty>,,79,27,CPPASTProblemDeclaration,,<empty>
64432,UNKNOWN,-1,,"TYPED_EVENT(ShowNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,81,28,CPPASTProblemDeclaration,,<empty>
64433,UNKNOWN,-1,,"TYPED_EVENT(HideNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,82,29,CPPASTProblemDeclaration,,<empty>
64434,UNKNOWN,-1,,"TYPED_EVENT(QuitAllRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,83,30,CPPASTProblemDeclaration,,<empty>
64435,UNKNOWN,-1,,"TYPED_EVENT(QuitRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,84,31,CPPASTProblemDeclaration,,<empty>
64436,UNKNOWN,-1,,"TYPED_EVENT(GetWindowLayoutRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::GetWindowLayoutArgs);",9,<empty>,,85,32,CPPASTProblemDeclaration,,<empty>
64437,UNKNOWN,-1,,"TYPED_EVENT(AttachRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::AttachRequest);",9,<empty>,,87,33,CPPASTProblemDeclaration,,<empty>
64438,UNKNOWN,-1,,"TYPED_EVENT(SendContentRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::RequestReceiveContentArgs);",9,<empty>,,88,34,CPPASTProblemDeclaration,,<empty>
64501,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, Id);",9,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
64502,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowName);",9,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
64503,UNKNOWN,-1,,"WINRT_PROPERTY(bool, ShouldCreateWindow, true);",9,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
64533,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::IAsyncAction, BeforeQuitAllAction, nullptr)",9,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
64564,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, NewName);",9,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
64565,UNKNOWN,-1,,"WINRT_PROPERTY(bool, Succeeded, false);",9,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
64605,UNKNOWN,-1,,"WINRT_PROPERTY(bool, MoveToCurrentDesktop, true);",9,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
64606,UNKNOWN,-1,,"WINRT_PROPERTY(bool, ToggleVisibility, true);",9,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
64607,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, DropdownDuration, 0);",9,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
64608,UNKNOWN,-1,,"WINRT_PROPERTY(Remoting::MonitorBehavior, ToMonitor, Remoting::MonitorBehavior::ToCurrent);",9,<empty>,,30,5,CPPASTProblemDeclaration,,<empty>
64653,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowName);",9,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
64654,UNKNOWN,-1,,"WINRT_PROPERTY(bool, FoundMatch, false);",9,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
64655,UNKNOWN,-1,,"WINRT_PROPERTY(bool, OnCurrentDesktop, false);",9,<empty>,,34,5,CPPASTProblemDeclaration,,<empty>
64656,UNKNOWN,-1,,"WINRT_PROPERTY(SummonWindowBehavior, SummonBehavior);",9,<empty>,,35,6,CPPASTProblemDeclaration,,<empty>
64657,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::IReference<uint64_t>, WindowID);",9,<empty>,,37,7,CPPASTProblemDeclaration,,<empty>
64705,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, PeasantID, 0);",9,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
64706,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::guid, DesktopID);",9,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
64707,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::DateTime, ActivatedTime, {}",9,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
64708,UNKNOWN,-1,,);,79,<empty>,,31,4,CPPASTProblemDeclaration,,<empty>
64709,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, Hwnd, 0);",9,<empty>,,32,5,CPPASTProblemDeclaration,,<empty>
65286,UNKNOWN,-1,,"try
            {
                _monarch.SignalClose(peasant.GetID());
            }
            CATCH_LOG()",13,<empty>,,374,1,CPPASTProblemStatement,,<empty>
65321,UNKNOWN,-1,,"try
            {
                return _monarch.GetNumberOfPeasants();
            }
            CATCH_LOG()",13,<empty>,,406,1,CPPASTProblemStatement,,<empty>
65372,UNKNOWN,-1,,"try
            {
                return _monarch.GetAllWindowLayouts();
            }
            CATCH_LOG()",13,<empty>,,441,1,CPPASTProblemStatement,,<empty>
65501,UNKNOWN,-1,,"TYPED_EVENT(FindTargetWindowRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::FindTargetWindowArgs);",9,<empty>,,50,16,CPPASTProblemDeclaration,,<empty>
65502,UNKNOWN,-1,,"TYPED_EVENT(WindowCreated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,52,17,CPPASTProblemDeclaration,,<empty>
65503,UNKNOWN,-1,,"TYPED_EVENT(WindowClosed, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,53,18,CPPASTProblemDeclaration,,<empty>
65504,UNKNOWN,-1,,"TYPED_EVENT(QuitAllRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::QuitAllRequestedArgs);",9,<empty>,,54,19,CPPASTProblemDeclaration,,<empty>
65505,UNKNOWN,-1,,"TYPED_EVENT(GetWindowLayoutRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::GetWindowLayoutArgs);",9,<empty>,,55,20,CPPASTProblemDeclaration,,<empty>
65506,UNKNOWN,-1,,"TYPED_EVENT(RequestNewWindow, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::WindowRequestedArgs);",9,<empty>,,57,21,CPPASTProblemDeclaration,,<empty>
65567,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hRemotingProvider,
    ""Microsoft.Windows.Terminal.Remoting"",
    // {d6f04aad-629f-539a-77c1-73f5c3e4aa7b}
    (0xd6f04aad, 0x629f, 0x539a, 0x77, 0xc1, 0x73, 0xf5, 0xc3, 0xe4, 0xaa, 0x7b),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
65568,UNKNOWN,2,,BOOL,1,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
65605,UNKNOWN,4,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""Microsoft.Terminal.Remoting/Resources"");",1,<empty>,,37,4,CPPASTProblemDeclaration,,<empty>
65675,UNKNOWN,3,,"HRESULT OpenTerminalHere::Invoke(IShellItemArray* psiItemArray,
                                 IBindCtx* /*pBindContext*/)
try
{
    const auto runElevated = IsControlAndShiftPressed();

    wil::com_ptr_nothrow<IShellItem> psi;
    RETURN_IF_FAILED(GetBestLocationFromSelectionOrSite(psiItemArray, psi.put()));
    if (!psi)
    {
        return S_FALSE;
    }

    wil::unique_cotaskmem_string pszName;
    RETURN_IF_FAILED(psi->GetDisplayName(SIGDN_FILESYSPATH, &pszName));

    {
        wil::unique_process_information _piClient;
        STARTUPINFOEX siEx{ 0 };
        siEx.StartupInfo.cb = sizeof(STARTUPINFOEX);

        // Explicitly create the terminal window visible.
        siEx.StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
        siEx.StartupInfo.wShowWindow = SW_SHOWNORMAL;

        std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
        std::wstring cmdline;
        if (runElevated)
        {
            RETURN_IF_...",1,<empty>,,26,3,CPPASTProblemDeclaration,,<empty>
65761,UNKNOWN,6,,"HRESULT OpenTerminalHere::GetIcon(IShellItemArray* /*psiItemArray*/,
                                  LPWSTR* ppszIcon)
try
{
    std::filesystem::path modulePath{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
    modulePath.replace_filename(WindowsTerminalExe);
    // WindowsTerminal.exe,-101 will be the first icon group in WT
    // We're using WindowsTerminal here explicitly, and not wt (from GetWtExePath), because
    // WindowsTerminal is the only one built with the right icons.
    const auto resource{ modulePath.wstring() + L"",-101"" };
    return SHStrDupW(resource.c_str(), ppszIcon);
}
CATCH_RETURN();",1,<empty>,,130,6,CPPASTProblemDeclaration,,<empty>
66080,UNKNOWN,2,,"STDAPI DllGetActivationFactory(_In_ HSTRING activatableClassId, _COM_Outptr_ IActivationFactory** factory)
{
    return Module<InProc>::GetModule().GetActivationFactory(activatableClassId, factory);
}",1,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
66081,UNKNOWN,3,,"STDAPI DllGetClassObject(_In_ REFCLSID rclsid, _In_ REFIID riid, _COM_Outptr_ void** ppv)
{
    return Module<InProc>::GetModule().GetClassObject(rclsid, riid, ppv);
}",1,<empty>,,21,3,CPPASTProblemDeclaration,,<empty>
66083,UNKNOWN,5,,),13,<empty>,,26,5,CPPASTProblemDeclaration,,<empty>
66084,UNKNOWN,6,,"DllMain(_In_opt_ HINSTANCE hinst, DWORD reason, _In_opt_ void*)
{
    if (reason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hinst);
    }
    return TRUE;
}",1,<empty>,,27,6,CPPASTProblemDeclaration,,<empty>
66085,UNKNOWN,7,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""TerminalApp/ContextMenu"")",1,<empty>,,37,7,CPPASTProblemDeclaration,,<empty>
66314,UNKNOWN,-1,,t,58,<empty>,,100,3,CPPASTProblemStatement,,<empty>
66395,UNKNOWN,-1,,t,49,<empty>,,128,3,CPPASTProblemStatement,,<empty>
66457,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,18,4,CPPASTProblemDeclaration,,<empty>
66458,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, UpdatesAvailable, _PropertyChangedHandlers, false);",9,<empty>,,19,5,CPPASTProblemDeclaration,,<empty>
66459,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, CheckingForUpdates, _PropertyChangedHandlers, false);",9,<empty>,,20,6,CPPASTProblemDeclaration,,<empty>
66547,UNKNOWN,-1,,"WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::Command, Command, nullptr);",9,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
71231,UNKNOWN,1,,unsigned int,48,<empty>,,343,1,CPPASTTypeId,,<empty>
71289,UNKNOWN,1,,unsigned int,51,<empty>,,390,1,CPPASTTypeId,,<empty>
71327,UNKNOWN,1,,IActionArgs,53,<empty>,,400,1,CPPASTTypeId,,<empty>
71333,UNKNOWN,1,,IActionArgs,53,<empty>,,401,1,CPPASTTypeId,,<empty>
71593,UNKNOWN,1,,uint32_t,49,<empty>,,529,1,CPPASTTypeId,,<empty>
71672,UNKNOWN,1,,int,35,<empty>,,34,1,CPPASTTypeId,,<empty>
72520,UNKNOWN,1,,winrt::Windows::UI::Color,39,<empty>,,650,1,CPPASTTypeId,,<empty>
72972,UNKNOWN,1,,uint32_t,43,<empty>,,961,1,CPPASTTypeId,,<empty>
73793,UNKNOWN,1,,size_t,62,<empty>,,51,1,CPPASTTypeId,,<empty>
73826,UNKNOWN,1,,uint32_t,40,<empty>,,83,1,CPPASTTypeId,,<empty>
74290,UNKNOWN,-1,,"void AppLogic::_ApplyLanguageSettingChange() noexcept
    try
    {
        if (!IsPackaged())
        {
            return;
        }

        using ApplicationLanguages = winrt::Windows::Globalization::ApplicationLanguages;

        // NOTE: PrimaryLanguageOverride throws if this instance is unpackaged.
        const auto primaryLanguageOverride = ApplicationLanguages::PrimaryLanguageOverride();
        const auto language = _settings.GlobalSettings().Language();

        if (primaryLanguageOverride != language)
        {
            ApplicationLanguages::PrimaryLanguageOverride(language);
        }
    }
    CATCH_LOG()

    fire_and_forget AppLogic::_ApplyStartupTaskStateChange()
    try
    {
        // First, make sure we're running in a packaged context. This method
        // won't work, and will crash mysteriously if we're running unpackaged.
        if (!IsPackaged())
        {
            co_return;
        }

        const auto tryEnableStartupTask = _settings.GlobalSett...",5,<empty>,,337,11,CPPASTProblemDeclaration,,<empty>
74291,UNKNOWN,-1,,CATCH_LOG();,5,<empty>,,390,12,CPPASTProblemDeclaration,,<empty>
74350,UNKNOWN,1,,uint64_t,79,<empty>,,427,1,CPPASTTypeId,,<empty>
74974,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, WindowId, -1);",9,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
74975,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, WindowName, L"""");",9,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
75075,UNKNOWN,-1,,"TYPED_EVENT(SettingsChanged, winrt::Windows::Foundation::IInspectable, winrt::TerminalApp::SettingsLoadEventArgs);",9,<empty>,,77,22,CPPASTProblemDeclaration,,<empty>
75576,UNKNOWN,1,,uint8_t,31,<empty>,,102,1,CPPASTTypeId,,<empty>
75588,UNKNOWN,1,,uint8_t,31,<empty>,,103,1,CPPASTTypeId,,<empty>
75600,UNKNOWN,1,,uint8_t,31,<empty>,,104,1,CPPASTTypeId,,<empty>
76372,UNKNOWN,-1,,"WINRT_CALLBACK(ColorCleared, TerminalApp::ColorClearedArgs);",9,<empty>,,16,7,CPPASTProblemDeclaration,,<empty>
76373,UNKNOWN,-1,,"WINRT_CALLBACK(ColorSelected, TerminalApp::ColorSelectedArgs);",9,<empty>,,17,8,CPPASTProblemDeclaration,,<empty>
76423,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, CommandLine);",9,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
77104,UNKNOWN,1,,int32_t,112,<empty>,,273,1,CPPASTTypeId,,<empty>
77107,UNKNOWN,1,,int32_t,139,<empty>,,273,1,CPPASTTypeId,,<empty>
77968,UNKNOWN,1,,int32_t,52,<empty>,,597,1,CPPASTTypeId,,<empty>
79892,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,51,15,CPPASTProblemDeclaration,,<empty>
79893,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, NoMatchesText, _PropertyChangedHandlers);",9,<empty>,,52,16,CPPASTProblemDeclaration,,<empty>
79894,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, SearchBoxPlaceholderText, _PropertyChangedHandlers);",9,<empty>,,53,17,CPPASTProblemDeclaration,,<empty>
79895,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, PrefixCharacter, _PropertyChangedHandlers);",9,<empty>,,54,18,CPPASTProblemDeclaration,,<empty>
79896,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ControlName, _PropertyChangedHandlers);",9,<empty>,,55,19,CPPASTProblemDeclaration,,<empty>
79897,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ParentCommandName, _PropertyChangedHandlers);",9,<empty>,,56,20,CPPASTProblemDeclaration,,<empty>
79898,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ParsedCommandLineText, _PropertyChangedHandlers);",9,<empty>,,57,21,CPPASTProblemDeclaration,,<empty>
79899,UNKNOWN,-1,,"TYPED_EVENT(SwitchToTabRequested, winrt::TerminalApp::CommandPalette, winrt::TerminalApp::TabBase);",9,<empty>,,59,22,CPPASTProblemDeclaration,,<empty>
79900,UNKNOWN,-1,,"TYPED_EVENT(CommandLineExecutionRequested, winrt::TerminalApp::CommandPalette, winrt::hstring);",9,<empty>,,60,23,CPPASTProblemDeclaration,,<empty>
79901,UNKNOWN,-1,,"TYPED_EVENT(DispatchCommandRequested, winrt::TerminalApp::CommandPalette, Microsoft::Terminal::Settings::Model::Command);",9,<empty>,,61,24,CPPASTProblemDeclaration,,<empty>
79902,UNKNOWN,-1,,"TYPED_EVENT(PreviewAction, Windows::Foundation::IInspectable, Microsoft::Terminal::Settings::Model::Command);",9,<empty>,,62,25,CPPASTProblemDeclaration,,<empty>
80910,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);",9,<empty>,,26,10,CPPASTProblemDeclaration,,<empty>
80911,UNKNOWN,-1,,"TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, winrt::Windows::Foundation::IInspectable);",9,<empty>,,28,11,CPPASTProblemDeclaration,,<empty>
81558,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,26,5,CPPASTProblemDeclaration,,<empty>
81559,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::PaletteItem, Item, _PropertyChangedHandlers, nullptr);",9,<empty>,,27,6,CPPASTProblemDeclaration,,<empty>
81560,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Filter, _PropertyChangedHandlers);",9,<empty>,,28,7,CPPASTProblemDeclaration,,<empty>
81561,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::HighlightedText, HighlightedName, _PropertyChangedHandlers);",9,<empty>,,29,8,CPPASTProblemDeclaration,,<empty>
81562,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(int, Weight, _PropertyChangedHandlers);",9,<empty>,,30,9,CPPASTProblemDeclaration,,<empty>
81627,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
81628,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, TextSegment, _PropertyChangedHandlers);",9,<empty>,,17,4,CPPASTProblemDeclaration,,<empty>
81629,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsHighlighted, _PropertyChangedHandlers);",9,<empty>,,18,5,CPPASTProblemDeclaration,,<empty>
81640,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,26,3,CPPASTProblemDeclaration,,<empty>
81641,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<winrt::TerminalApp::HighlightedTextSegment>, Segments, _PropertyChangedHandlers);",9,<empty>,,27,4,CPPASTProblemDeclaration,,<empty>
81874,UNKNOWN,1,,"DEFINE_PROPERTYKEY(PKEY_AppUserModel_DestListLogoUri, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 29);",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
81991,UNKNOWN,-1,,"try
    {
        auto jumplistInstance = winrt::create_instance<ICustomDestinationList>(CLSID_DestinationList, CLSCTX_ALL);

        // Start the Jumplist edit transaction
        uint32_t slots;
        winrt::com_ptr<IObjectCollection> jumplistItems;
        jumplistItems.capture(jumplistInstance, &ICustomDestinationList::BeginList, &slots);

        // Update the list of profiles.
        _updateProfiles(jumplistItems.get(), strongSettings.ActiveProfiles().GetView());

        // TODO GH#1571: Add items from the future customizable new tab dropdown as well.
        // This could either replace the default profiles, or be added alongside them.

        // Add the items to the jumplist Task section.
        // The Tasks section is immutable by the user, unlike the destinations
        // section that can have its items pinned and removed.
        THROW_IF_FAILED(jumplistInstance->AddUserTasks(jumplistItems.get()));

        THROW_IF_FAILED(jumplistInstance->CommitList());
    }
  ...",5,<empty>,,83,5,CPPASTProblemStatement,,<empty>
82110,UNKNOWN,1,,wchar_t*,36,<empty>,,156,1,CPPASTTypeId,,<empty>
82213,UNKNOWN,1,,wchar_t*,39,<empty>,,180,1,CPPASTTypeId,,<empty>
82303,UNKNOWN,1,,ITfInputProcessorProfileActivationSink*,92,<empty>,,15,1,CPPASTTypeId,,<empty>
82347,UNKNOWN,-1,,"try
        {
            _callback();
        }
        CATCH_RETURN();",9,<empty>,,35,2,CPPASTProblemStatement,,<empty>
83059,UNKNOWN,-1,,"TYPED_EVENT(MinimizeClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);",9,<empty>,,31,9,CPPASTProblemDeclaration,,<empty>
83060,UNKNOWN,-1,,"TYPED_EVENT(MaximizeClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);",9,<empty>,,32,10,CPPASTProblemDeclaration,,<empty>
83061,UNKNOWN,-1,,"TYPED_EVENT(CloseClick, TerminalApp::MinMaxCloseControl, winrt::Windows::UI::Xaml::RoutedEventArgs);",9,<empty>,,33,11,CPPASTProblemDeclaration,,<empty>
83137,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,14,2,CPPASTProblemDeclaration,,<empty>
83138,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Name, _PropertyChangedHandlers);",9,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
83139,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Icon, _PropertyChangedHandlers);",9,<empty>,,17,4,CPPASTProblemDeclaration,,<empty>
83140,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, KeyChordText, _PropertyChangedHandlers);",9,<empty>,,18,5,CPPASTProblemDeclaration,,<empty>
83248,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, TabItemTemplate);",9,<empty>,,17,4,CPPASTProblemDeclaration,,<empty>
83249,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, NestedItemTemplate);",9,<empty>,,18,5,CPPASTProblemDeclaration,,<empty>
83250,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::UI::Xaml::DataTemplate, GeneralItemTemplate);",9,<empty>,,19,6,CPPASTProblemDeclaration,,<empty>
84845,UNKNOWN,1,,winrt::Windows::UI::Color,102,<empty>,,161,1,CPPASTTypeId,,<empty>
84877,UNKNOWN,-1,,return { .args = {},13,<empty>,,217,1,CPPASTProblemStatement,,<empty>
84878,UNKNOWN,-1,,", .firstPane = shared_from_this(), .focusedPaneId = currentId, .panesCreated = 0",32,<empty>,,217,2,CPPASTProblemStatement,,<empty>
84879,UNKNOWN,-1,,return { .args = {},9,<empty>,,220,2,CPPASTProblemStatement,,<empty>
84880,UNKNOWN,-1,,", .firstPane = shared_from_this(), .focusedPaneId = std::nullopt, .panesCreated = 0",28,<empty>,,220,3,CPPASTProblemStatement,,<empty>
84883,UNKNOWN,15,,},5,<empty>,,221,15,CPPASTProblemDeclaration,,<empty>
84888,UNKNOWN,18,,"if (asContent && _IsLeaf())
    {
        return {
            .args = { buildSplitPane(shared_from_this()) },
            .firstPane = shared_from_this(),
            .focusedPaneId = currentId,
            .panesCreated = 1
        };
    }",5,<empty>,,237,18,CPPASTProblemDeclaration,,<empty>
84893,UNKNOWN,21,,"if (_firstChild->_IsLeaf() && _secondChild->_IsLeaf())
    {
        auto actionAndArgs = buildSplitPane(_secondChild);
        std::optional<uint32_t> focusedPaneId = std::nullopt;
        if (_firstChild->_lastActive)
        {
            focusedPaneId = currentId;
        }
        else if (_secondChild->_lastActive)
        {
            focusedPaneId = nextId;
        }

        return {
            .args = { actionAndArgs },
            .firstPane = _firstChild,
            .focusedPaneId = focusedPaneId,
            .panesCreated = 1
        };
    }",5,<empty>,,260,21,CPPASTProblemDeclaration,,<empty>
84924,UNKNOWN,28,,actions.reserve(firstState.args.size() + secondState.args.size() + 3);,5,<empty>,,290,28,CPPASTProblemDeclaration,,<empty>
84932,UNKNOWN,31,,actions.emplace_back(std::move(newSplit));,5,<empty>,,294,31,CPPASTProblemDeclaration,,<empty>
84933,UNKNOWN,32,,"if (firstState.args.size() > 0)
    {
        // Then move to the first child and execute any actions on the left branch
        // then move back
        actions.emplace_back(buildMoveFocus(FocusDirection::PreviousInOrder));
        actions.insert(actions.end(), std::make_move_iterator(std::begin(firstState.args)), std::make_move_iterator(std::end(firstState.args)));
        actions.emplace_back(buildMoveFocus(FocusDirection::NextInOrder));
    }",5,<empty>,,296,32,CPPASTProblemDeclaration,,<empty>
84934,UNKNOWN,33,,"if (secondState.args.size() > 0)
    {
        actions.insert(actions.end(), std::make_move_iterator(secondState.args.begin()), std::make_move_iterator(secondState.args.end()));
    }",5,<empty>,,306,33,CPPASTProblemDeclaration,,<empty>
84951,UNKNOWN,36,,"return {
        .args = { actions },
        .firstPane = firstState.firstPane,
        .focusedPaneId = focusedPaneId,
        .panesCreated = firstState.panesCreated + secondState.panesCreated + 1
    };",5,<empty>,,315,36,CPPASTProblemDeclaration,,<empty>
84952,UNKNOWN,37,,},1,<empty>,,321,37,CPPASTProblemDeclaration,,<empty>
86236,UNKNOWN,-1,,"try
            {
                _bellPlayerCreated = true;
                _bellPlayer = winrt::Windows::Media::Playback::MediaPlayer();
                // GH#12258: The media keys (like play/pause) should have no effect on our bell sound.
                _bellPlayer.CommandManager().IsEnabled(false);
            }
            CATCH_LOG();",13,<empty>,,1135,1,CPPASTProblemStatement,,<empty>
86298,UNKNOWN,1,,int,25,<empty>,,1172,1,CPPASTTypeId,,<empty>
86381,UNKNOWN,1,,LPCTSTR,62,<empty>,,1186,1,CPPASTTypeId,,<empty>
90641,UNKNOWN,-1,,"WINRT_CALLBACK(ClosedByParent, winrt::delegate<>);",5,<empty>,,213,49,CPPASTProblemDeclaration,,<empty>
90642,UNKNOWN,-1,,"WINRT_CALLBACK(Closed, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>);",5,<empty>,,214,50,CPPASTProblemDeclaration,,<empty>
90644,UNKNOWN,-1,,"WINRT_CALLBACK(GotFocus, gotFocusArgs);",5,<empty>,,218,52,CPPASTProblemDeclaration,,<empty>
90645,UNKNOWN,-1,,"WINRT_CALLBACK(LostFocus, winrt::delegate<std::shared_ptr<Pane>>);",5,<empty>,,219,53,CPPASTProblemDeclaration,,<empty>
90646,UNKNOWN,-1,,"WINRT_CALLBACK(PaneRaiseBell, winrt::Windows::Foundation::EventHandler<bool>);",5,<empty>,,220,54,CPPASTProblemDeclaration,,<empty>
90647,UNKNOWN,-1,,"WINRT_CALLBACK(Detached, winrt::delegate<std::shared_ptr<Pane>>);",5,<empty>,,221,55,CPPASTProblemDeclaration,,<empty>
90648,UNKNOWN,-1,,"WINRT_CALLBACK(RestartTerminalRequested, winrt::delegate<std::shared_ptr<Pane>>);",5,<empty>,,222,56,CPPASTProblemDeclaration,,<empty>
91089,UNKNOWN,-1,,"WINRT_PROPERTY(bool, Reload, false);",9,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
91090,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, Result, S_OK);",9,<empty>,,13,2,CPPASTProblemDeclaration,,<empty>
91091,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, ExceptionText, L"""");",9,<empty>,,14,3,CPPASTProblemDeclaration,,<empty>
91092,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::SettingsLoadWarnings>, Warnings, nullptr);",9,<empty>,,15,4,CPPASTProblemDeclaration,,<empty>
91093,UNKNOWN,-1,,"WINRT_PROPERTY(Microsoft::Terminal::Settings::Model::CascadiaSettings, NewSettings, nullptr);",9,<empty>,,16,5,CPPASTProblemDeclaration,,<empty>
93900,UNKNOWN,1,,int32_t,52,<empty>,,555,1,CPPASTTypeId,,<empty>
95235,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,53,17,CPPASTProblemDeclaration,,<empty>
95236,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, NoMatchesText, _PropertyChangedHandlers);",9,<empty>,,54,18,CPPASTProblemDeclaration,,<empty>
95237,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, SearchBoxPlaceholderText, _PropertyChangedHandlers);",9,<empty>,,55,19,CPPASTProblemDeclaration,,<empty>
95238,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ControlName, _PropertyChangedHandlers);",9,<empty>,,56,20,CPPASTProblemDeclaration,,<empty>
95239,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ParentCommandName, _PropertyChangedHandlers);",9,<empty>,,57,21,CPPASTProblemDeclaration,,<empty>
95240,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, ParsedCommandLineText, _PropertyChangedHandlers);",9,<empty>,,58,22,CPPASTProblemDeclaration,,<empty>
97078,UNKNOWN,-1,,"WINRT_CALLBACK(RequestFocusActiveControl, winrt::delegate<void()>);",9,<empty>,,35,11,CPPASTProblemDeclaration,,<empty>
97079,UNKNOWN,-1,,"WINRT_CALLBACK(Closed, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>);",9,<empty>,,37,12,CPPASTProblemDeclaration,,<empty>
97080,UNKNOWN,-1,,"WINRT_CALLBACK(CloseRequested, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>);",9,<empty>,,38,13,CPPASTProblemDeclaration,,<empty>
97081,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,39,14,CPPASTProblemDeclaration,,<empty>
97082,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabViewIndex, 0);",9,<empty>,,42,15,CPPASTProblemDeclaration,,<empty>
97083,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabViewNumTabs, 0);",9,<empty>,,44,16,CPPASTProblemDeclaration,,<empty>
97084,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Title, _PropertyChangedHandlers);",9,<empty>,,46,17,CPPASTProblemDeclaration,,<empty>
97085,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Icon, _PropertyChangedHandlers);",9,<empty>,,47,18,CPPASTProblemDeclaration,,<empty>
97086,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, ReadOnly, _PropertyChangedHandlers, false);",9,<empty>,,48,19,CPPASTProblemDeclaration,,<empty>
97087,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Microsoft::UI::Xaml::Controls::TabViewItem, TabViewItem, nullptr);",9,<empty>,,49,20,CPPASTProblemDeclaration,,<empty>
97088,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::FrameworkElement, Content, _PropertyChangedHandlers, nullptr);",9,<empty>,,51,21,CPPASTProblemDeclaration,,<empty>
97573,UNKNOWN,-1,,"WINRT_CALLBACK(TitleChangeRequested, TerminalApp::TitleChangeRequestedArgs);",9,<empty>,,22,5,CPPASTProblemDeclaration,,<empty>
97574,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,24,6,CPPASTProblemDeclaration,,<empty>
97575,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Title, _PropertyChangedHandlers);",9,<empty>,,25,7,CPPASTProblemDeclaration,,<empty>
97576,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(double, RenamerMaxWidth, _PropertyChangedHandlers);",9,<empty>,,26,8,CPPASTProblemDeclaration,,<empty>
97577,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);",9,<empty>,,27,9,CPPASTProblemDeclaration,,<empty>
97578,UNKNOWN,-1,,"TYPED_EVENT(RenameEnded, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,29,10,CPPASTProblemDeclaration,,<empty>
97874,UNKNOWN,-1,,"HRESULT TerminalPage::_OpenNewTab(const NewTerminalArgs& newTerminalArgs, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection existingConnection)
    try
    {
        const auto profile{ _settings.GetProfileForArgs(newTerminalArgs) };
        // GH#11114: GetProfileForArgs can return null if the index is higher
        // than the number of available profiles.
        if (!profile)
        {
            return S_FALSE;
        }
        const auto settings{ TerminalSettings::CreateWithNewTerminalArgs(_settings, newTerminalArgs, *_bindings) };

        // Try to handle auto-elevation
        if (_maybeElevate(newTerminalArgs, settings, profile))
        {
            return S_OK;
        }
        // We can't go in the other direction (elevated->unelevated)
        // unfortunately. This seems to be due to Centennial quirks. It works
        // unpackaged, but not packaged.
        //
        // This call to _MakePane won't return nullptr, we already checked that
   ...",5,<empty>,,66,1,CPPASTProblemDeclaration,,<empty>
98249,UNKNOWN,-1,,"try
        {
            // TODO: GH#5047 - We're duplicating the whole profile, which might
            // be a dangling reference to old settings.
            //
            // In the future, it may be preferable to just duplicate the
            // current control's live settings (which will include changes
            // made through VT).
            uint32_t insertPosition = _tabs.Size();
            if (_settings.GlobalSettings().NewTabPosition() == NewTabPosition::AfterCurrentTab)
            {
                insertPosition = tab.TabViewIndex() + 1;
            }
            _CreateNewTabFromPane(_MakePane(nullptr, tab, nullptr), insertPosition);

            const auto runtimeTabText{ tab.GetTabText() };
            if (!runtimeTabText.empty())
            {
                if (auto newTab{ _GetFocusedTabImpl() })
                {
                    newTab->SetTabText(runtimeTabText);
                }
            }
        }
        CATCH_LOG();",9,<empty>,,300,1,CPPASTProblemStatement,,<empty>
98282,UNKNOWN,-1,,"try
        {
            if (const auto control{ tab.GetActiveTerminalControl() })
            {
                auto path = filepath;

                if (path.empty())
                {
                    // GH#11356 - we can't use the UWP apis for writing the file,
                    // because they don't work elevated (shocker) So just use the
                    // shell32 file picker manually.
                    std::wstring filename{ tab.Title() };
                    filename = til::clean_filename(filename);
                    path = co_await SaveFilePicker(*_hostingHwnd, [filename = std::move(filename)](auto&& dialog) {
                        THROW_IF_FAILED(dialog->SetClientGuid(clientGuidExportFile));
                        try
                        {
                            // Default to the Downloads folder
                            auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_Downloads, KF_FLAG_DEFAULT, nullptr) };
   ...",9,<empty>,,344,5,CPPASTProblemStatement,,<empty>
98330,UNKNOWN,-1,,t,41,<empty>,,421,3,CPPASTProblemStatement,,<empty>
98952,UNKNOWN,-1,,t,41,<empty>,,735,3,CPPASTProblemStatement,,<empty>
98962,UNKNOWN,-1,,n,25,<empty>,,740,2,CPPASTProblemStatement,,<empty>
98970,UNKNOWN,-1,,n,17,<empty>,,754,3,CPPASTProblemStatement,,<empty>
99345,UNKNOWN,-1,,"try
        {
            _tabContent.Children().Clear();
            _tabContent.Children().Append(tab.Content());

            // GH#7409: If the tab switcher is open, then we _don't_ want to
            // automatically focus the new tab here. The tab switcher wants
            // to be able to ""preview"" the selected tab as the user tabs
            // through the menu, but if we toss the focus to the control
            // here, then the user won't be able to navigate the ATS any
            // longer.
            //
            // When the tab switcher is eventually dismissed, the focus will
            // get tossed back to the focused terminal control, so we don't
            // need to worry about focus getting lost.
            const auto p = CommandPaletteElement();
            if (!p || p.Visibility() != Visibility::Visible)
            {
                tab.Focus(FocusState::Programmatic);
                _UpdateMRUTab(tab);
                _updateAllTabCloseButtons();
 ...",9,<empty>,,928,2,CPPASTProblemStatement,,<empty>
99691,UNKNOWN,-1,,"try
            {
                auto& tabs{ _tabs };
                auto tab = tabs.GetAt(from.value());
                tabs.RemoveAt(from.value());
                tabs.InsertAt(to.value(), tab);
                _UpdateTabIndices();
            }
            CATCH_LOG();",13,<empty>,,1085,1,CPPASTProblemStatement,,<empty>
100037,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::TerminalApp::TerminalTabStatus, TabStatus, _PropertyChangedHandlers);",9,<empty>,,21,4,CPPASTProblemDeclaration,,<empty>
100111,UNKNOWN,1,,uint32_t,44,<empty>,,64,1,CPPASTTypeId,,<empty>
100120,UNKNOWN,1,,uint32_t,49,<empty>,,65,1,CPPASTTypeId,,<empty>
100142,UNKNOWN,1,,uint32_t,54,<empty>,,69,1,CPPASTTypeId,,<empty>
100230,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,20,5,CPPASTProblemDeclaration,,<empty>
100231,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, ShowElevationShield, _PropertyChangedHandlers, false);",9,<empty>,,21,6,CPPASTProblemDeclaration,,<empty>
100338,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, State, 0);",9,<empty>,,25,5,CPPASTProblemDeclaration,,<empty>
100339,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, Progress, 0);",9,<empty>,,26,6,CPPASTProblemDeclaration,,<empty>
100364,UNKNOWN,1,,uint64_t,62,<empty>,,93,1,CPPASTTypeId,,<empty>
100793,UNKNOWN,1,,int,33,<empty>,,2989,1,CPPASTTypeId,,<empty>
100795,UNKNOWN,1,,uintptr_t,55,<empty>,,2989,1,CPPASTTypeId,,<empty>
101357,UNKNOWN,-1,,"try
        {
            return Application::Current().as<TerminalApp::App>().Logic().IsRunningElevated();
        }
        CATCH_LOG();",9,<empty>,,141,1,CPPASTProblemStatement,,<empty>
101364,UNKNOWN,-1,,"try
        {
            return Application::Current().as<TerminalApp::App>().Logic().CanDragDrop();
        }
        CATCH_LOG();",9,<empty>,,150,1,CPPASTProblemStatement,,<empty>
101766,UNKNOWN,-1,,"try
        {
            _defaultPointerCursor = CoreWindow::GetForCurrentThread().PointerCursor();
        }
        CATCH_LOG();",9,<empty>,,281,36,CPPASTProblemStatement,,<empty>
101950,UNKNOWN,-1,,"winrt::fire_and_forget TerminalPage::_NewTerminalByDrop(const Windows::Foundation::IInspectable&, winrt::Windows::UI::Xaml::DragEventArgs e)
    try
    {
        const auto data = e.DataView();
        if (!data.Contains(StandardDataFormats::StorageItems()))
        {
            co_return;
        }

        const auto weakThis = get_weak();
        const auto items = co_await data.GetStorageItemsAsync();
        const auto strongThis = weakThis.get();
        if (!strongThis)
        {
            co_return;
        }

        TraceLoggingWrite(
            g_hTerminalAppProvider,
            ""NewTabByDragDrop"",
            TraceLoggingDescription(""Event emitted when the user drag&drops onto the new tab button""),
            TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
            TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage));

        for (const auto& item : items)
        {
            auto directory = item.Path();

            std::filesystem::path path(std::wstring...",5,<empty>,,406,10,CPPASTProblemDeclaration,,<empty>
102259,UNKNOWN,-1,,t,30,<empty>,,724,2,CPPASTProblemStatement,,<empty>
105946,UNKNOWN,-1,,t,41,<empty>,,1893,4,CPPASTProblemStatement,,<empty>
106238,UNKNOWN,-1,,t,41,<empty>,,1992,6,CPPASTProblemStatement,,<empty>
107266,UNKNOWN,-1,,"try
                {
                    if (auto focusedControl{ _GetActiveControl() })
                    {
                        return focusedControl.Title();
                    }
                }
                CATCH_LOG();",17,<empty>,,2481,1,CPPASTProblemStatement,,<empty>
107505,UNKNOWN,-1,,"try
        {
            Clipboard::SetContent(dataPack);
            Clipboard::Flush();
        }
        CATCH_LOG();",9,<empty>,,2626,13,CPPASTProblemStatement,,<empty>
107508,UNKNOWN,-1,,"fire_and_forget TerminalPage::_PasteFromClipboardHandler(const IInspectable /*sender*/, const PasteFromClipboardEventArgs eventArgs)
    try
    {
        // The old Win32 clipboard API as used below is somewhere in the order of 300-1000x faster than
        // the WinRT one on average, depending on CPU load. Don't use the WinRT clipboard API if you can.
        const auto weakThis = get_weak();
        const auto dispatcher = Dispatcher();
        const auto globalSettings = _settings.GlobalSettings();
        winrt::hstring text;

        // GetClipboardData might block for up to 30s for delay-rendered contents.
        co_await winrt::resume_background();

        {
            // According to various reports on the internet, OpenClipboard might
            // fail to acquire the internal lock, for instance due to rdpclip.exe.
            for (int attempts = 1;;)
            {
                if (OpenClipboard(nullptr))
                {
                    break;
               ...",5,<empty>,,2645,78,CPPASTProblemDeclaration,,<empty>
108044,UNKNOWN,1,,uint64_t,46,<empty>,,3064,1,CPPASTTypeId,,<empty>
109629,UNKNOWN,-1,,"try
        {
            NewTerminalArgs newTerminalArgs;
            newTerminalArgs.Commandline(connection.Commandline());
            newTerminalArgs.TabTitle(connection.StartingTitle());
            // GH #12370: We absolutely cannot allow a defterm connection to
            // auto-elevate. Defterm doesn't work for elevated scenarios in the
            // first place. If we try accepting the connection, the spawning an
            // elevated version of the Terminal with that profile... that's a
            // recipe for disaster. We won't ever open up a tab in this window.
            newTerminalArgs.Elevate(false);
            const auto newPane = _MakePane(newTerminalArgs, nullptr, connection);
            newPane->WalkTree([](auto pane) {
                pane->FinalizeConfigurationGivenDefault();
            });
            _CreateNewTabFromPane(newPane);

            // Request a summon of this window to the foreground
            _SummonWindowRequestedHandlers(*this, nul...",9,<empty>,,3824,3,CPPASTProblemStatement,,<empty>
109693,UNKNOWN,1,,uint64_t,55,<empty>,,3891,1,CPPASTTypeId,,<empty>
110116,UNKNOWN,-1,,"try
                {
                    window.PointerCursor(nullptr);
                    _isMouseHidden = true;
                }
                CATCH_LOG();",17,<empty>,,4121,1,CPPASTProblemStatement,,<empty>
110137,UNKNOWN,-1,,"try
                {
                    window.PointerCursor(_defaultPointerCursor);
                    _isMouseHidden = false;
                }
                CATCH_LOG();",17,<empty>,,4141,1,CPPASTProblemStatement,,<empty>
111565,UNKNOWN,-1,,"try
        {
            auto commandsCollection = Command::ParsePowerShellMenuComplete(args.MenuJson(),
                                                                           args.ReplacementLength());

            auto weakThis{ get_weak() };
            Dispatcher().RunAsync(CoreDispatcherPriority::Normal, [weakThis, commandsCollection, sender]() {
                // On the UI thread...
                if (const auto& page{ weakThis.get() })
                {
                    // Open the Suggestions UI with the commands from the control
                    page->_OpenSuggestions(sender.try_as<TermControl>(), commandsCollection, SuggestionsMode::Menu, L"""");
                }
            });
        }
        CATCH_LOG();",9,<empty>,,4810,2,CPPASTProblemStatement,,<empty>
112600,UNKNOWN,-1,,"WINRT_PROPERTY(bool, ClearPersistedState);",9,<empty>,,49,1,CPPASTProblemDeclaration,,<empty>
112607,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, ProposedName);",9,<empty>,,58,1,CPPASTProblemDeclaration,,<empty>
112614,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Window);",9,<empty>,,67,1,CPPASTProblemDeclaration,,<empty>
112615,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Content);",9,<empty>,,68,2,CPPASTProblemDeclaration,,<empty>
112616,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabIndex);",9,<empty>,,69,3,CPPASTProblemDeclaration,,<empty>
112617,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::IReference<Windows::Foundation::Point>, WindowPosition);",9,<empty>,,70,4,CPPASTProblemDeclaration,,<empty>
112626,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, SourceWindow);",9,<empty>,,81,1,CPPASTProblemDeclaration,,<empty>
112627,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, TargetWindow);",9,<empty>,,82,2,CPPASTProblemDeclaration,,<empty>
112628,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, TabIndex);",9,<empty>,,83,3,CPPASTProblemDeclaration,,<empty>
112868,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,175,51,CPPASTProblemDeclaration,,<empty>
112869,UNKNOWN,-1,,"TYPED_EVENT(TitleChanged, IInspectable, winrt::hstring);",9,<empty>,,178,52,CPPASTProblemDeclaration,,<empty>
112870,UNKNOWN,-1,,"TYPED_EVENT(LastTabClosed, IInspectable, winrt::TerminalApp::LastTabClosedEventArgs);",9,<empty>,,179,53,CPPASTProblemDeclaration,,<empty>
112871,UNKNOWN,-1,,"TYPED_EVENT(SetTitleBarContent, IInspectable, winrt::Windows::UI::Xaml::UIElement);",9,<empty>,,180,54,CPPASTProblemDeclaration,,<empty>
112872,UNKNOWN,-1,,"TYPED_EVENT(FocusModeChanged, IInspectable, IInspectable);",9,<empty>,,181,55,CPPASTProblemDeclaration,,<empty>
112873,UNKNOWN,-1,,"TYPED_EVENT(FullscreenChanged, IInspectable, IInspectable);",9,<empty>,,182,56,CPPASTProblemDeclaration,,<empty>
112874,UNKNOWN,-1,,"TYPED_EVENT(ChangeMaximizeRequested, IInspectable, IInspectable);",9,<empty>,,183,57,CPPASTProblemDeclaration,,<empty>
112875,UNKNOWN,-1,,"TYPED_EVENT(AlwaysOnTopChanged, IInspectable, IInspectable);",9,<empty>,,184,58,CPPASTProblemDeclaration,,<empty>
112876,UNKNOWN,-1,,"TYPED_EVENT(RaiseVisualBell, IInspectable, IInspectable);",9,<empty>,,185,59,CPPASTProblemDeclaration,,<empty>
112877,UNKNOWN,-1,,"TYPED_EVENT(SetTaskbarProgress, IInspectable, IInspectable);",9,<empty>,,186,60,CPPASTProblemDeclaration,,<empty>
112878,UNKNOWN,-1,,"TYPED_EVENT(Initialized, IInspectable, IInspectable);",9,<empty>,,187,61,CPPASTProblemDeclaration,,<empty>
112879,UNKNOWN,-1,,"TYPED_EVENT(IdentifyWindowsRequested, IInspectable, IInspectable);",9,<empty>,,188,62,CPPASTProblemDeclaration,,<empty>
112880,UNKNOWN,-1,,"TYPED_EVENT(RenameWindowRequested, Windows::Foundation::IInspectable, winrt::TerminalApp::RenameWindowRequestedArgs);",9,<empty>,,189,63,CPPASTProblemDeclaration,,<empty>
112881,UNKNOWN,-1,,"TYPED_EVENT(SummonWindowRequested, IInspectable, IInspectable);",9,<empty>,,190,64,CPPASTProblemDeclaration,,<empty>
112882,UNKNOWN,-1,,"TYPED_EVENT(CloseRequested, IInspectable, IInspectable);",9,<empty>,,192,65,CPPASTProblemDeclaration,,<empty>
112883,UNKNOWN,-1,,"TYPED_EVENT(OpenSystemMenu, IInspectable, IInspectable);",9,<empty>,,193,66,CPPASTProblemDeclaration,,<empty>
112884,UNKNOWN,-1,,"TYPED_EVENT(QuitRequested, IInspectable, IInspectable);",9,<empty>,,194,67,CPPASTProblemDeclaration,,<empty>
112885,UNKNOWN,-1,,"TYPED_EVENT(ShowWindowChanged, IInspectable, winrt::Microsoft::Terminal::Control::ShowWindowArgs)

        TYPED_EVENT(RequestMoveContent, Windows::Foundation::IInspectable, winrt::TerminalApp::RequestMoveContentArgs);",9,<empty>,,195,68,CPPASTProblemDeclaration,,<empty>
112886,UNKNOWN,-1,,"TYPED_EVENT(RequestReceiveContent, Windows::Foundation::IInspectable, winrt::TerminalApp::RequestReceiveContentArgs);",9,<empty>,,198,69,CPPASTProblemDeclaration,,<empty>
112887,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, TitlebarBrush, _PropertyChangedHandlers, nullptr);",9,<empty>,,200,70,CPPASTProblemDeclaration,,<empty>
112888,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, FrameBrush, _PropertyChangedHandlers, nullptr);",9,<empty>,,201,71,CPPASTProblemDeclaration,,<empty>
116042,UNKNOWN,-1,,"try
        {
            // Make sure to try/catch this, because the LocalTests won't be
            // able to use this helper.
            const auto settings{ winrt::TerminalApp::implementation::AppLogic::CurrentAppSettings() };
            if (settings.GlobalSettings().TabWidthMode() == winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode::SizeToContent)
            {
                _headerControl.RenamerMaxWidth(HeaderRenameBoxWidthTitleLength);
            }
            else
            {
                _headerControl.RenamerMaxWidth(HeaderRenameBoxWidthDefault);
            }
        }
        CATCH_LOG()",9,<empty>,,150,1,CPPASTProblemStatement,,<empty>
119382,UNKNOWN,-1,,"WINRT_CALLBACK(ActivePaneChanged, winrt::delegate<>);",9,<empty>,,99,48,CPPASTProblemDeclaration,,<empty>
119383,UNKNOWN,-1,,"WINRT_CALLBACK(TabRaiseVisualBell, winrt::delegate<>);",9,<empty>,,100,49,CPPASTProblemDeclaration,,<empty>
119384,UNKNOWN,-1,,"TYPED_EVENT(TaskbarProgressChanged, IInspectable, IInspectable);",9,<empty>,,101,50,CPPASTProblemDeclaration,,<empty>
119653,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,14,2,CPPASTProblemDeclaration,,<empty>
119654,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsConnectionClosed, _PropertyChangedHandlers);",9,<empty>,,15,3,CPPASTProblemDeclaration,,<empty>
119655,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsPaneZoomed, _PropertyChangedHandlers);",9,<empty>,,16,4,CPPASTProblemDeclaration,,<empty>
119656,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingActive, _PropertyChangedHandlers);",9,<empty>,,17,5,CPPASTProblemDeclaration,,<empty>
119657,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsProgressRingIndeterminate, _PropertyChangedHandlers);",9,<empty>,,18,6,CPPASTProblemDeclaration,,<empty>
119658,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, BellIndicator, _PropertyChangedHandlers);",9,<empty>,,19,7,CPPASTProblemDeclaration,,<empty>
119659,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsReadOnlyActive, _PropertyChangedHandlers);",9,<empty>,,20,8,CPPASTProblemDeclaration,,<empty>
119660,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(uint32_t, ProgressValue, _PropertyChangedHandlers);",9,<empty>,,21,9,CPPASTProblemDeclaration,,<empty>
119661,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsInputBroadcastActive, _PropertyChangedHandlers);",9,<empty>,,22,10,CPPASTProblemDeclaration,,<empty>
119789,UNKNOWN,1,,size_t,64,<empty>,,59,1,CPPASTTypeId,,<empty>
119822,UNKNOWN,1,,uint32_t,40,<empty>,,93,1,CPPASTTypeId,,<empty>
120297,UNKNOWN,-1,,t,26,<empty>,,366,12,CPPASTProblemStatement,,<empty>
120768,UNKNOWN,1,,float,40,<empty>,,565,1,CPPASTTypeId,,<empty>
120771,UNKNOWN,1,,float,66,<empty>,,565,1,CPPASTTypeId,,<empty>
121081,UNKNOWN,1,,bool,37,<empty>,,726,1,CPPASTTypeId,,<empty>
121458,UNKNOWN,-1,,t,101,<empty>,,927,2,CPPASTProblemStatement,,<empty>
122224,UNKNOWN,-1,,"try
            {
                _PropertyChangedHandlers(*this, Windows::UI::Xaml::Data::PropertyChangedEventArgs{ L""WindowName"" });
                _PropertyChangedHandlers(*this, Windows::UI::Xaml::Data::PropertyChangedEventArgs{ L""WindowNameForDisplay"" });
            }
            CATCH_LOG();",13,<empty>,,1356,2,CPPASTProblemStatement,,<empty>
122313,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Name, L"""");",9,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
122314,UNKNOWN,-1,,"WINRT_PROPERTY(SystemMenuChangeAction, Action, SystemMenuChangeAction::Add);",9,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
122315,UNKNOWN,-1,,"WINRT_PROPERTY(SystemMenuItemHandler, Handler, nullptr);",9,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
122354,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, VirtualWorkingDirectory, _PropertyChangedHandlers, L"""");",9,<empty>,,51,8,CPPASTProblemDeclaration,,<empty>
122355,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,53,9,CPPASTProblemDeclaration,,<empty>
122693,UNKNOWN,-1,,"TYPED_EVENT(RequestedThemeChanged, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Settings::Model::Theme);",9,<empty>,,166,64,CPPASTProblemDeclaration,,<empty>
122752,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(Initialized, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, Initialized);",9,<empty>,,214,88,CPPASTProblemDeclaration,,<empty>
122753,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(SetTitleBarContent, winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Xaml::UIElement, _root, SetTitleBarContent);",9,<empty>,,216,89,CPPASTProblemDeclaration,,<empty>
122754,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(TitleChanged, winrt::Windows::Foundation::IInspectable, winrt::hstring, _root, TitleChanged);",9,<empty>,,217,90,CPPASTProblemDeclaration,,<empty>
122755,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(LastTabClosed, winrt::Windows::Foundation::IInspectable, winrt::TerminalApp::LastTabClosedEventArgs, _root, LastTabClosed);",9,<empty>,,218,91,CPPASTProblemDeclaration,,<empty>
122756,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(FocusModeChanged, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, FocusModeChanged);",9,<empty>,,219,92,CPPASTProblemDeclaration,,<empty>
122757,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(FullscreenChanged, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, FullscreenChanged);",9,<empty>,,220,93,CPPASTProblemDeclaration,,<empty>
122758,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(ChangeMaximizeRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, ChangeMaximizeRequested);",9,<empty>,,221,94,CPPASTProblemDeclaration,,<empty>
122759,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(AlwaysOnTopChanged, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, AlwaysOnTopChanged);",9,<empty>,,222,95,CPPASTProblemDeclaration,,<empty>
122760,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(RaiseVisualBell, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, RaiseVisualBell);",9,<empty>,,223,96,CPPASTProblemDeclaration,,<empty>
122761,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(SetTaskbarProgress, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable, _root, SetTaskbarProgress);",9,<empty>,,224,97,CPPASTProblemDeclaration,,<empty>
122762,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(IdentifyWindowsRequested, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable, _root, IdentifyWindowsRequested);",9,<empty>,,225,98,CPPASTProblemDeclaration,,<empty>
122763,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(RenameWindowRequested, Windows::Foundation::IInspectable, winrt::TerminalApp::RenameWindowRequestedArgs, _root, RenameWindowRequested);",9,<empty>,,226,99,CPPASTProblemDeclaration,,<empty>
122764,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(SummonWindowRequested, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable, _root, SummonWindowRequested);",9,<empty>,,227,100,CPPASTProblemDeclaration,,<empty>
122765,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(CloseRequested, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable, _root, CloseRequested);",9,<empty>,,228,101,CPPASTProblemDeclaration,,<empty>
122766,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(OpenSystemMenu, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable, _root, OpenSystemMenu);",9,<empty>,,229,102,CPPASTProblemDeclaration,,<empty>
122767,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(QuitRequested, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable, _root, QuitRequested);",9,<empty>,,230,103,CPPASTProblemDeclaration,,<empty>
122768,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(ShowWindowChanged, Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Control::ShowWindowArgs, _root, ShowWindowChanged);",9,<empty>,,231,104,CPPASTProblemDeclaration,,<empty>
122769,UNKNOWN,-1,,"TYPED_EVENT(IsQuakeWindowChanged, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable);",9,<empty>,,233,105,CPPASTProblemDeclaration,,<empty>
122770,UNKNOWN,-1,,"TYPED_EVENT(SystemMenuChangeRequested, winrt::Windows::Foundation::IInspectable, winrt::TerminalApp::SystemMenuChangeArgs);",9,<empty>,,235,106,CPPASTProblemDeclaration,,<empty>
122771,UNKNOWN,-1,,"TYPED_EVENT(SettingsChanged, winrt::Windows::Foundation::IInspectable, winrt::TerminalApp::SettingsLoadEventArgs);",9,<empty>,,237,107,CPPASTProblemDeclaration,,<empty>
122772,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(RequestMoveContent, Windows::Foundation::IInspectable, winrt::TerminalApp::RequestMoveContentArgs, _root, RequestMoveContent);",9,<empty>,,239,108,CPPASTProblemDeclaration,,<empty>
122773,UNKNOWN,-1,,"FORWARDED_TYPED_EVENT(RequestReceiveContent, Windows::Foundation::IInspectable, winrt::TerminalApp::RequestReceiveContentArgs, _root, RequestReceiveContent);",9,<empty>,,240,109,CPPASTProblemDeclaration,,<empty>
123175,UNKNOWN,-1,,),37,<empty>,,144,4,CPPASTProblemStatement,,<empty>
123176,UNKNOWN,-1,,.Dispatcher();,38,<empty>,,144,5,CPPASTProblemStatement,,<empty>
123534,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hTerminalAppProvider,
    ""Microsoft.Windows.Terminal.App"",
    // {24a1622f-7da7-5c77-3303-d850bd1ab2ed}
    (0x24a1622f, 0x7da7, 0x5c77, 0x33, 0x03, 0xd8, 0x50, 0xbd, 0x1a, 0xb2, 0xed),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,9,1,CPPASTProblemDeclaration,,<empty>
123535,UNKNOWN,2,,BOOL,1,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
123572,UNKNOWN,4,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""TerminalApp/Resources"")",1,<empty>,,36,4,CPPASTProblemDeclaration,,<empty>
124504,UNKNOWN,1,,AzureConnection*,52,<empty>,,128,1,CPPASTTypeId,,<empty>
125059,UNKNOWN,-1,,"void AzureConnection::Resize(uint32_t rows, uint32_t columns)
    try
    {
        if (!_isConnected())
        {
            _initialRows = rows;
            _initialCols = columns;
        }
        else // We only transition to Connected when we've established the websocket.
        {
            auto uri{ fmt::format(L""{}terminals/{}/size?cols={}&rows={}&version=2019-01-01"", _cloudShellUri, _terminalID, columns, rows) };

            WWH::HttpStringContent content{
                L"""",
                WSS::UnicodeEncoding::Utf8,
                // LOAD-BEARING. the API returns ""'content-type' should be 'application/json' or 'multipart/form-data'""
                L""application/json""
            };

            // Send the request (don't care about the response)
            std::ignore = _SendRequestReturningJson(uri, content);
        }
    }
    CATCH_LOG();",5,<empty>,,231,9,CPPASTProblemDeclaration,,<empty>
125490,UNKNOWN,-1,,"try
            {
                auto nameJson = WDJ::JsonObject::Parse(entry.UserName());
                std::optional<int> credentialVersion;
                if (nameJson.HasKey(L""ver""))
                {
                    credentialVersion = static_cast<int>(nameJson.GetNamedNumber(L""ver""));
                }

                if (!credentialVersion.has_value() || credentialVersion.value() != CurrentCredentialVersion)
                {
                    // ignore credentials that aren't from the latest credential revision
                    vault.Remove(entry);
                    oldVersionEncountered = true;
                    continue;
                }

                auto newTenant{ _tenantList.emplace_back(_crackTenant(nameJson)) };

                _WriteStringWithNewline(_formatTenant(numTenants, newTenant));
                numTenants++;
            }
            CATCH_LOG();",13,<empty>,,466,1,CPPASTProblemStatement,,<empty>
126312,UNKNOWN,1,,winrt::hstring,36,<empty>,,798,1,CPPASTTypeId,,<empty>
127130,UNKNOWN,-1,,"try
            {
                vault.Remove(cred);
            }
            CATCH_LOG();",13,<empty>,,1083,1,CPPASTProblemStatement,,<empty>
127193,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);",9,<empty>,,29,9,CPPASTProblemDeclaration,,<empty>
127409,UNKNOWN,6,,"HRESULT CTerminalHandoff::s_StartListening(NewHandoffFunction pfnHandoff)
try
{
    std::unique_lock lock{ _mtx };

    RETURN_HR_IF(E_NOT_VALID_STATE, _pfnHandoff != nullptr);

    const auto classFactory = Make<SimpleClassFactory<CTerminalHandoff>>();

    RETURN_IF_NULL_ALLOC(classFactory);

    ComPtr<IUnknown> unk;
    RETURN_IF_FAILED(classFactory.As(&unk));

    RETURN_IF_FAILED(CoRegisterClassObject(__uuidof(CTerminalHandoff), unk.Get(), CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &g_cTerminalHandoffRegistration));

    _pfnHandoff = pfnHandoff;

    return S_OK;
}
CATCH_RETURN()

// Routine Description:
// - Stops listening for TerminalHandoff requests by revoking the registration
//   our class and interface with COM
// Arguments:
// - <none>
// Return Value:
// - S_OK, E_NOT_VALID_STATE (stop called when not started), or relevant COM class revoke error
HRESULT CTerminalHandoff::s_StopListening()
{
    std::unique_lock lock{ _mtx };
    return s_StopListeningLocked();
}",1,<empty>,,24,6,CPPASTProblemDeclaration,,<empty>
127611,UNKNOWN,1,,HSTRING,39,<empty>,,30,1,CPPASTTypeId,,<empty>
127632,UNKNOWN,1,,::IInspectable**,37,<empty>,,36,1,CPPASTTypeId,,<empty>
127705,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::ValueSet, Settings);",9,<empty>,,33,5,CPPASTProblemDeclaration,,<empty>
127737,UNKNOWN,-1,,"TYPED_EVENT(StateChanged, ITerminalConnection, winrt::Windows::Foundation::IInspectable);",9,<empty>,,11,2,CPPASTProblemDeclaration,,<empty>
127738,UNKNOWN,-1,,"bool _transitionToState(const ConnectionState state) noexcept
        try
        {
            {
                std::lock_guard<std::mutex> stateLock{ _stateMutex };
                // only allow movement up the state gradient
                if (state < _connectionState)
                {
                    return false;
                }
                _connectionState = state;
            }
            // Dispatch the event outside of lock.
#pragma warning(suppress : 26491) // We can't avoid static_cast downcast because this is template magic.
            _StateChangedHandlers(*static_cast<T*>(this), nullptr);
            return true;
        }
        CATCH_FAIL_FAST()

        // Method Description:
        // - Returns whether the state is one of the N specified states.
        // Arguments:
        // - ""..."": the states
        // Return Value:
        //   Whether we're in one of the states.
        template<typename... Args>
        bool _isStateOneOf(const Args&&... a...",9,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
127739,UNKNOWN,-1,,"CATCH_FAIL_FAST()

        // Method Description:
        // - Returns whether the state has reached or surpassed the specified state.
        // Arguments:
        // - state; the state to check against
        // Return Value:
        //   Whether we're at or beyond the specified state
        bool _isStateAtOrBeyond(const ConnectionState state) const noexcept
        try
        {
            std::lock_guard<std::mutex> stateLock{ _stateMutex };
            return _connectionState >= state;
        }",9,<empty>,,63,4,CPPASTProblemDeclaration,,<empty>
127740,UNKNOWN,-1,,"CATCH_FAIL_FAST()
#pragma warning(pop)

        // Method Description:
        // - (Convenience:) Returns whether we're ""connected"".
        // Return Value:
        //   Whether we're ""connected""
        bool _isConnected() const noexcept
        {
            return _isStateOneOf(ConnectionState::Connected);
        }",9,<empty>,,77,5,CPPASTProblemDeclaration,,<empty>
127761,UNKNOWN,1,,ConptyConnection*,52,<empty>,,410,1,CPPASTTypeId,,<empty>
127884,UNKNOWN,-1,,"HRESULT ConptyConnection::_LaunchAttachedClient() noexcept
    try
    {
        STARTUPINFOEX siEx{ 0 };
        siEx.StartupInfo.cb = sizeof(STARTUPINFOEX);
        siEx.StartupInfo.dwFlags = STARTF_USESTDHANDLES;
        SIZE_T size{};
        // This call will return an error (by design); we are ignoring it.
        InitializeProcThreadAttributeList(nullptr, 1, 0, &size);
#pragma warning(suppress : 26414) // We don't move/touch this smart pointer, but we have to allocate strangely for the adjustable size list.
        auto attrList{ std::make_unique<std::byte[]>(size) };
#pragma warning(suppress : 26490) // We have to use reinterpret_cast because we allocated a byte array as a proxy for the adjustable size list.
        siEx.lpAttributeList = reinterpret_cast<PPROC_THREAD_ATTRIBUTE_LIST>(attrList.get());
        RETURN_IF_WIN32_BOOL_FALSE(InitializeProcThreadAttributeList(siEx.lpAttributeList, 1, 0, &size));

        RETURN_IF_WIN32_BOOL_FALSE(UpdateProcThreadAttribute(siEx.lpAt...",5,<empty>,,61,2,CPPASTProblemDeclaration,,<empty>
127946,UNKNOWN,-1,,"try
        {
            _commandline = _commandlineFromProcess(hClientProcess);
        }
        CATCH_LOG()",9,<empty>,,204,7,CPPASTProblemStatement,,<empty>
128413,UNKNOWN,1,,HWND,90,<empty>,,365,1,CPPASTTypeId,,<empty>
128467,UNKNOWN,1,,HWND,86,<empty>,,391,1,CPPASTTypeId,,<empty>
128524,UNKNOWN,-1,,"try
        {
            // GH#11556 - make sure to format the error code to this string as an UNSIGNED int
            winrt::hstring exitText{ fmt::format(std::wstring_view{ RS_(L""ProcessExited"") }, fmt::format(_errorFormat, status)) };
            _TerminalOutputHandlers(L""\r\n"");
            _TerminalOutputHandlers(exitText);
            _TerminalOutputHandlers(L""\r\n"");
            _TerminalOutputHandlers(RS_(L""CtrlDToClose""));
            _TerminalOutputHandlers(L""\r\n"");
        }
        CATCH_LOG();",9,<empty>,,459,1,CPPASTProblemStatement,,<empty>
128527,UNKNOWN,-1,,"void ConptyConnection::_LastConPtyClientDisconnected() noexcept
    try
    {
        DWORD exitCode{ 0 };
        GetExitCodeProcess(_piClient.hProcess, &exitCode);

        // Signal the closing or failure of the process.
        // exitCode might be STILL_ACTIVE if a client has called FreeConsole() and
        // thus caused the tab to close, even though the CLI app is still running.
        _transitionToState(exitCode == 0 || exitCode == STILL_ACTIVE ? ConnectionState::Closed : ConnectionState::Failed);
        _indicateExitWithStatus(exitCode);
    }
    CATCH_LOG()

    void ConptyConnection::WriteInput(const hstring& data)
    {
        if (!_isConnected())
        {
            return;
        }

        // convert from UTF-16LE to UTF-8 as ConPty expects UTF-8
        // TODO GH#3378 reconcile and unify UTF-8 converters
        auto str = winrt::to_string(data);
        LOG_IF_WIN32_BOOL_FALSE(WriteFile(_inPipe.get(), str.c_str(), (DWORD)str.length(), nullptr, nullptr));
    }",5,<empty>,,474,13,CPPASTProblemDeclaration,,<empty>
128620,UNKNOWN,1,,HWND,86,<empty>,,548,1,CPPASTTypeId,,<empty>
128624,UNKNOWN,-1,,"void ConptyConnection::Close() noexcept
    try
    {
        _transitionToState(ConnectionState::Closing);

        // .reset()ing either of these two will signal ConPTY to send out a CTRL_CLOSE_EVENT to all attached clients.
        // FYI: The other members of this class are concurrently read by the _hOutputThread
        // thread running in the background and so they're not safe to be .reset().
        _hPC.reset();
        _inPipe.reset();

        if (_hOutputThread)
        {
            // Loop around `CancelSynchronousIo()` just in case the signal to shut down was missed.
            // This may happen if we called `CancelSynchronousIo()` while not being stuck
            // in `ReadFile()` and if OpenConsole refuses to exit in a timely manner.
            for (;;)
            {
                // ConptyConnection::Close() blocks the UI thread, because `_TerminalOutputHandlers` might indirectly
                // reference UI objects like `ControlCore`. CancelSynchronousIo...",5,<empty>,,552,18,CPPASTProblemDeclaration,,<empty>
128832,UNKNOWN,-1,,"HRESULT ConptyConnection::NewHandoff(HANDLE in, HANDLE out, HANDLE signal, HANDLE ref, HANDLE server, HANDLE client, TERMINAL_STARTUP_INFO startupInfo) noexcept
    try
    {
        _newConnectionHandlers(winrt::make<ConptyConnection>(signal, in, out, ref, server, client, startupInfo));

        return S_OK;
    }
    CATCH_RETURN()

    void ConptyConnection::StartInboundListener()
    {
        THROW_IF_FAILED(CTerminalHandoff::s_StartListening(&ConptyConnection::NewHandoff));
    }",5,<empty>,,713,24,CPPASTProblemDeclaration,,<empty>
128980,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);",9,<empty>,,61,21,CPPASTProblemDeclaration,,<empty>
129271,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, TerminalOutputHandler);",9,<empty>,,23,8,CPPASTProblemDeclaration,,<empty>
129272,UNKNOWN,-1,,"TYPED_EVENT(StateChanged, ITerminalConnection, IInspectable);",9,<empty>,,24,9,CPPASTProblemDeclaration,,<empty>
129290,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hTerminalConnectionProvider,
    ""Microsoft.Windows.Terminal.Connection"",
    // {e912fe7b-eeb6-52a5-c628-abe388e5f792}
    (0xe912fe7b, 0xeeb6, 0x52a5, 0xc6, 0x28, 0xab, 0xe3, 0x88, 0xe5, 0xf7, 0x92),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
129291,UNKNOWN,2,,BOOL,1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
129330,UNKNOWN,4,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""Microsoft.Terminal.TerminalConnection/Resources"");",1,<empty>,,40,4,CPPASTProblemDeclaration,,<empty>
129831,UNKNOWN,1,,int32_t,76,<empty>,,45,1,CPPASTTypeId,,<empty>
132540,UNKNOWN,1,,int,41,<empty>,,985,1,CPPASTTypeId,,<empty>
133084,UNKNOWN,1,,SelectionEndpointTarget,37,<empty>,,1197,1,CPPASTTypeId,,<empty>
133446,UNKNOWN,1,,Control::SelectionInteractionMode,28,<empty>,,1332,1,CPPASTTypeId,,<empty>
133578,UNKNOWN,1,,uint16_t,28,<empty>,,1405,1,CPPASTTypeId,,<empty>
133696,UNKNOWN,1,,winrt::Windows::UI::Color,112,<empty>,,1445,1,CPPASTTypeId,,<empty>
133986,UNKNOWN,1,,HWND,46,<empty>,,1606,1,CPPASTTypeId,,<empty>
134386,UNKNOWN,1,,uint64_t,90,<empty>,,1763,1,CPPASTTypeId,,<empty>
135017,UNKNOWN,1,,uint64_t,33,<empty>,,2043,1,CPPASTTypeId,,<empty>
139370,UNKNOWN,1,,float,41,<empty>,,397,1,CPPASTTypeId,,<empty>
141931,UNKNOWN,-1,,"WINRT_PROPERTY(hstring, Title);",9,<empty>,,47,2,CPPASTProblemDeclaration,,<empty>
141980,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::Point, Position);",9,<empty>,,83,2,CPPASTProblemDeclaration,,<empty>
141995,UNKNOWN,-1,,"WINRT_PROPERTY(bool, BracketedPasteEnabled, false);",9,<empty>,,98,3,CPPASTProblemDeclaration,,<empty>
142039,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, ViewTop);",9,<empty>,,143,2,CPPASTProblemDeclaration,,<empty>
142040,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, ViewHeight);",9,<empty>,,144,3,CPPASTProblemDeclaration,,<empty>
142041,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, BufferSize);",9,<empty>,,145,4,CPPASTProblemDeclaration,,<empty>
142048,UNKNOWN,-1,,"WINRT_PROPERTY(uint64_t, Result);",9,<empty>,,156,2,CPPASTProblemDeclaration,,<empty>
142055,UNKNOWN,-1,,"WINRT_PROPERTY(double, Opacity);",9,<empty>,,167,2,CPPASTProblemDeclaration,,<empty>
142062,UNKNOWN,-1,,"WINRT_PROPERTY(bool, FoundMatch);",9,<empty>,,178,2,CPPASTProblemDeclaration,,<empty>
142063,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, TotalMatches);",9,<empty>,,179,3,CPPASTProblemDeclaration,,<empty>
142064,UNKNOWN,-1,,"WINRT_PROPERTY(int32_t, CurrentMatch);",9,<empty>,,180,4,CPPASTProblemDeclaration,,<empty>
142071,UNKNOWN,-1,,"WINRT_PROPERTY(bool, ShowOrHide);",9,<empty>,,191,2,CPPASTProblemDeclaration,,<empty>
142078,UNKNOWN,-1,,"WINRT_PROPERTY(bool, ClearMarkers, false);",9,<empty>,,202,2,CPPASTProblemDeclaration,,<empty>
142086,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, MenuJson, L"""");",9,<empty>,,214,2,CPPASTProblemDeclaration,,<empty>
142087,UNKNOWN,-1,,"WINRT_PROPERTY(uint32_t, ReplacementLength, 0);",9,<empty>,,215,3,CPPASTProblemDeclaration,,<empty>
142097,UNKNOWN,-1,,"WINRT_PROPERTY(WORD, VKey);",9,<empty>,,227,2,CPPASTProblemDeclaration,,<empty>
142098,UNKNOWN,-1,,"WINRT_PROPERTY(WORD, ScanCode);",9,<empty>,,228,3,CPPASTProblemDeclaration,,<empty>
142099,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Microsoft::Terminal::Core::ControlKeyStates, Modifiers);",9,<empty>,,229,4,CPPASTProblemDeclaration,,<empty>
142100,UNKNOWN,-1,,"WINRT_PROPERTY(bool, KeyDown, false);",9,<empty>,,230,5,CPPASTProblemDeclaration,,<empty>
142109,UNKNOWN,-1,,"WINRT_PROPERTY(wchar_t, Character);",9,<empty>,,241,2,CPPASTProblemDeclaration,,<empty>
142110,UNKNOWN,-1,,"WINRT_PROPERTY(WORD, ScanCode);",9,<empty>,,242,3,CPPASTProblemDeclaration,,<empty>
142111,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Microsoft::Terminal::Core::ControlKeyStates, Modifiers);",9,<empty>,,243,4,CPPASTProblemDeclaration,,<empty>
142118,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Text);",9,<empty>,,252,2,CPPASTProblemDeclaration,,<empty>
142216,UNKNOWN,6,,LRESULT,1,<empty>,,27,6,CPPASTProblemDeclaration,,<empty>
142232,UNKNOWN,1,,CREATESTRUCT*,36,<empty>,,37,1,CPPASTTypeId,,<empty>
142238,UNKNOWN,1,,HwndTerminal*,42,<empty>,,38,1,CPPASTTypeId,,<empty>
142255,UNKNOWN,1,,LONG_PTR,64,<empty>,,42,1,CPPASTTypeId,,<empty>
142267,UNKNOWN,1,,HwndTerminal*,50,<empty>,,46,1,CPPASTTypeId,,<empty>
142391,UNKNOWN,-1,,"try
                {
                    const auto lock = publicTerminal->_terminal->LockForWriting();
                    const auto bufferData = publicTerminal->_terminal->RetrieveSelectedTextFromBuffer(false);
                    LOG_IF_FAILED(publicTerminal->_CopyTextToSystemClipboard(bufferData, true));
                    publicTerminal->_ClearSelection();
                }
                CATCH_LOG();",17,<empty>,,107,1,CPPASTProblemStatement,,<empty>
142753,UNKNOWN,12,,"void HwndTerminal::Teardown() noexcept
try
{
    // As a rule, detach resources from the Terminal before shutting them down.
    // This ensures that teardown is reentrant.

    // Shut down the renderer (and therefore the thread) before we implode
    if (auto localRenderEngine{ std::exchange(_renderEngine, nullptr) })
    {
        if (auto localRenderer{ std::exchange(_renderer, nullptr) })
        {
            localRenderer->TriggerTeardown();
            // renderer is destroyed
        }
        // renderEngine is destroyed
    }

    if (auto localHwnd{ _hwnd.release() })
    {
        // If we're being called through WM_DESTROY, we won't get here (hwnd is already released)
        // If we're not, we may end up in Teardown _again_... but by the time we do, all other
        // resources have been released and will not be released again.
        DestroyWindow(localHwnd);
    }
}
CATCH_LOG();",1,<empty>,,237,12,CPPASTProblemDeclaration,,<empty>
142782,UNKNOWN,-1,,"try
    {
        auto callingText{ wil::make_cotaskmem_string(input.data(), input.size()) };
        _pfnWriteCallback(callingText.release());
    }
    CATCH_LOG();",5,<empty>,,280,2,CPPASTProblemStatement,,<empty>
142785,UNKNOWN,15,,"void HwndTerminal::RegisterWriteCallback(const void _stdcall callback(wchar_t*))
{
    _pfnWriteCallback = callback;
}",1,<empty>,,288,15,CPPASTProblemDeclaration,,<empty>
142910,UNKNOWN,20,,"HRESULT HwndTerminal::Refresh(const til::size windowSize, _Out_ til::size* dimensions)
{
    RETURN_HR_IF_NULL(E_NOT_VALID_STATE, _terminal);
    RETURN_HR_IF_NULL(E_INVALIDARG, dimensions);

    const auto lock = _terminal->LockForWriting();

    _terminal->ClearSelection();

    RETURN_IF_FAILED(_renderEngine->SetWindowSize(windowSize));

    // Invalidate everything
    _renderer->TriggerRedrawAll();

    // Convert our new dimensions to characters
    const auto viewInPixels = Viewport::FromDimensions(windowSize);
    const auto vp = _renderEngine->GetViewportInCharacters(viewInPixels);

    // Guard against resizing the window to 0 columns/rows, which the text buffer classes don't really support.
    auto size = vp.Dimensions();
    size.width = std::max(size.width, 1);
    size.height = std::max(size.height, 1);

    // If this function succeeds with S_FALSE, then the terminal didn't
    //      actually change size. No need to notify the connection of this
    //      no-op.
...",1,<empty>,,344,20,CPPASTProblemDeclaration,,<empty>
142933,UNKNOWN,22,,"HRESULT _stdcall CreateTerminal(HWND parentHwnd, _Out_ void** hwnd, _Out_ void** terminal)
{
    auto publicTerminal = std::make_unique<HwndTerminal>(parentHwnd);

    RETURN_IF_FAILED(publicTerminal->Initialize());

    *hwnd = publicTerminal->GetHwnd();
    *terminal = publicTerminal.release();

    return S_OK;
}",1,<empty>,,390,22,CPPASTProblemDeclaration,,<empty>
142934,UNKNOWN,23,,"void _stdcall TerminalRegisterScrollCallback(void* terminal, void __stdcall callback(int, int, int))
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->RegisterScrollCallback(callback);
}",1,<empty>,,402,23,CPPASTProblemDeclaration,,<empty>
142935,UNKNOWN,24,,"CATCH_LOG()

void _stdcall TerminalRegisterWriteCallback(void* terminal, const void __stdcall callback(wchar_t*))
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->RegisterWriteCallback(callback);
}",1,<empty>,,408,24,CPPASTProblemDeclaration,,<empty>
142936,UNKNOWN,25,,"CATCH_LOG()

void _stdcall TerminalSendOutput(void* terminal, LPCWSTR data)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->SendOutput(data);
}",1,<empty>,,416,25,CPPASTProblemDeclaration,,<empty>
142937,UNKNOWN,26,,"CATCH_LOG()

/// <summary>
/// Triggers a terminal resize using the new width and height in pixel.
/// </summary>
/// <param name=""terminal"">Terminal pointer.</param>
/// <param name=""width"">New width of the terminal in pixels.</param>
/// <param name=""height"">New height of the terminal in pixels</param>
/// <param name=""dimensions"">Out parameter containing the columns and rows that fit the new size.</param>
/// <returns>HRESULT of the attempted resize.</returns>
HRESULT _stdcall TerminalTriggerResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions)
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);

    LOG_IF_WIN32_BOOL_FALSE(SetWindowPos(
        publicTerminal->GetHwnd(),
        nullptr,
        0,
        0,
        static_cast<int>(width),
        static_cast<int>(height),
        0));

    const til::size windowSize{ width, height };
    return publicTerminal->Refresh(windowSize, dimensions);
}",1,<empty>,,424,26,CPPASTProblemDeclaration,,<empty>
142938,UNKNOWN,27,,"HRESULT _stdcall TerminalTriggerResizeWithDimension(_In_ void* terminal, _In_ til::size dimensionsInCharacters, _Out_ til::size* dimensionsInPixels)
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, dimensionsInPixels);

    const auto publicTerminal = static_cast<const HwndTerminal*>(terminal);

    Viewport viewInPixels;
    {
        const auto viewInCharacters = Viewport::FromDimensions(dimensionsInCharacters);
        const auto lock = publicTerminal->_terminal->LockForReading();
        viewInPixels = publicTerminal->_renderEngine->GetViewportInPixels(viewInCharacters);
    }

    dimensionsInPixels->width = viewInPixels.Width();
    dimensionsInPixels->height = viewInPixels.Height();

    til::size unused;

    return TerminalTriggerResize(terminal, viewInPixels.Width(), viewInPixels.Height(), &unused);
}",1,<empty>,,458,27,CPPASTProblemDeclaration,,<empty>
142939,UNKNOWN,28,,"CATCH_RETURN()

/// <summary>
/// Calculates the amount of rows and columns that fit in the provided width and height.
/// </summary>
/// <param name=""terminal"">Terminal pointer</param>
/// <param name=""width"">Width of the terminal area to calculate.</param>
/// <param name=""height"">Height of the terminal area to calculate.</param>
/// <param name=""dimensions"">Out parameter containing the columns and rows that fit the new size.</param>
/// <returns>HRESULT of the calculation.</returns>
HRESULT _stdcall TerminalCalculateResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions)
try
{
    const auto publicTerminal = static_cast<const HwndTerminal*>(terminal);

    const auto viewInPixels = Viewport::FromDimensions({ width, height });
    const auto lock = publicTerminal->_terminal->LockForReading();
    const auto viewInCharacters = publicTerminal->_renderEngine->GetViewportInCharacters(viewInPixels);

    dimensions->width = viewIn...",1,<empty>,,479,28,CPPASTProblemDeclaration,,<empty>
142940,UNKNOWN,29,,"CATCH_RETURN()

void _stdcall TerminalDpiChanged(void* terminal, int newDpi)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    const auto lock = publicTerminal->_terminal->LockForWriting();
    publicTerminal->_UpdateFont(newDpi);
}",1,<empty>,,503,29,CPPASTProblemDeclaration,,<empty>
142941,UNKNOWN,30,,"CATCH_LOG()

void _stdcall TerminalUserScroll(void* terminal, int viewTop)
try
{
    if (const auto publicTerminal = static_cast<const HwndTerminal*>(terminal); publicTerminal && publicTerminal->_terminal)
    {
        const auto lock = publicTerminal->_terminal->LockForWriting();
        publicTerminal->_terminal->UserScrollViewport(viewTop);
    }
}",1,<empty>,,512,30,CPPASTProblemDeclaration,,<empty>
142942,UNKNOWN,31,,"CATCH_LOG()

const unsigned int HwndTerminal::_NumberOfClicks(til::point point, std::chrono::steady_clock::time_point timestamp) noexcept
{
    // if click occurred at a different location or past the multiClickTimer...
    const auto delta{ timestamp - _lastMouseClickTimestamp };
    if (point != _lastMouseClickPos || delta > _multiClickTime)
    {
        // exit early. This is a single click.
        _multiClickCounter = 1;
    }
    else
    {
        _multiClickCounter++;
    }
    return _multiClickCounter;
}",1,<empty>,,523,31,CPPASTProblemDeclaration,,<empty>
142943,UNKNOWN,32,,"HRESULT HwndTerminal::_StartSelection(LPARAM lParam) noexcept
try
{
    RETURN_HR_IF_NULL(E_NOT_VALID_STATE, _terminal);
    const til::point cursorPosition{
        GET_X_LPARAM(lParam),
        GET_Y_LPARAM(lParam),
    };

    const auto lock = _terminal->LockForWriting();
    const auto altPressed = GetKeyState(VK_MENU) < 0;
    const til::size fontSize{ this->_actualFont.GetSize() };

    this->_terminal->SetBlockSelection(altPressed);

    const auto clickCount{ _NumberOfClicks(cursorPosition, std::chrono::steady_clock::now()) };

    // This formula enables the number of clicks to cycle properly between single-, double-, and triple-click.
    // To increase the number of acceptable click states, simply increment MAX_CLICK_COUNT and add another if-statement
    const unsigned int MAX_CLICK_COUNT = 3;
    const auto multiClickMapper = clickCount > MAX_CLICK_COUNT ? ((clickCount + MAX_CLICK_COUNT - 1) % MAX_CLICK_COUNT) + 1 : clickCount;

    if (multiClickMapper == 3)
    {
   ...",1,<empty>,,541,32,CPPASTProblemDeclaration,,<empty>
142944,UNKNOWN,33,,"HRESULT HwndTerminal::_MoveSelection(LPARAM lParam) noexcept
try
{
    RETURN_HR_IF_NULL(E_NOT_VALID_STATE, _terminal);
    const til::point cursorPosition{
        GET_X_LPARAM(lParam),
        GET_Y_LPARAM(lParam),
    };

    const auto lock = _terminal->LockForWriting();
    const til::size fontSize{ this->_actualFont.GetSize() };

    RETURN_HR_IF(E_NOT_VALID_STATE, fontSize.area() == 0); // either dimension = 0, area == 0

    // This is a copy of ControlInteractivity::PointerMoved
    if (_singleClickTouchdownPos)
    {
        const auto touchdownPoint = *_singleClickTouchdownPos;
        const auto dx = cursorPosition.x - touchdownPoint.x;
        const auto dy = cursorPosition.y - touchdownPoint.y;
        const auto w = fontSize.width;
        const auto distanceSquared = dx * dx + dy * dy;
        const auto maxDistanceSquared = w * w / 16; // (w / 4)^2

        if (distanceSquared >= maxDistanceSquared)
        {
            _terminal->SetSelectionAnchor(touchdownPoint ...",1,<empty>,,585,33,CPPASTProblemDeclaration,,<empty>
142962,UNKNOWN,35,,"void _stdcall TerminalClearSelection(void* terminal)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    const auto lock = publicTerminal->_terminal->LockForWriting();
    publicTerminal->_ClearSelection();
}",1,<empty>,,634,35,CPPASTProblemDeclaration,,<empty>
142963,UNKNOWN,36,,"CATCH_LOG()

bool _stdcall TerminalIsSelectionActive(void* terminal)
try
{
    if (const auto publicTerminal = static_cast<const HwndTerminal*>(terminal); publicTerminal && publicTerminal->_terminal)
    {
        const auto lock = publicTerminal->_terminal->LockForReading();
        return publicTerminal->_terminal->IsSelectionActive();
    }
    return false;
}",1,<empty>,,641,36,CPPASTProblemDeclaration,,<empty>
142964,UNKNOWN,37,,"catch (...)
{
    LOG_CAUGHT_EXCEPTION();
    return false;
}",1,<empty>,,653,37,CPPASTProblemDeclaration,,<empty>
142965,UNKNOWN,38,,"const wchar_t* _stdcall TerminalGetSelection(void* terminal)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    if (!publicTerminal || !publicTerminal->_terminal)
    {
        return nullptr;
    }

    TextBuffer::TextAndColor bufferData;
    {
        const auto lock = publicTerminal->_terminal->LockForWriting();
        bufferData = publicTerminal->_terminal->RetrieveSelectedTextFromBuffer(false);
        publicTerminal->_ClearSelection();
    }

    // convert text: vector<string> --> string
    std::wstring selectedText;
    for (const auto& text : bufferData.text)
    {
        selectedText += text;
    }

    auto returnText = wil::make_cotaskmem_string_nothrow(selectedText.c_str());
    return returnText.release();
}",1,<empty>,,660,38,CPPASTProblemDeclaration,,<empty>
142966,UNKNOWN,39,,"catch (...)
{
    LOG_CAUGHT_EXCEPTION();
    return nullptr;
}",1,<empty>,,686,39,CPPASTProblemDeclaration,,<empty>
143165,UNKNOWN,43,,"void HwndTerminal::_SendKeyEvent(WORD vkey, WORD scanCode, WORD flags, bool keyDown) noexcept
try
{
    if (!_terminal)
    {
        return;
    }

    auto modifiers = getControlKeyState();
    if (WI_IsFlagSet(flags, ENHANCED_KEY))
    {
        modifiers |= ControlKeyStates::EnhancedKey;
    }
    if (vkey && keyDown && _uiaProvider)
    {
        _uiaProvider->RecordKeyEvent(vkey);
    }

    TerminalInput::OutputType out;
    {
        const auto lock = _terminal->LockForReading();
        out = _terminal->SendKeyEvent(vkey, scanCode, modifiers, keyDown);
    }
    if (out)
    {
        _WriteTextToConnection(*out);
    }
}
CATCH_LOG();",1,<empty>,,779,43,CPPASTProblemDeclaration,,<empty>
143166,UNKNOWN,44,,"void HwndTerminal::_SendCharEvent(wchar_t ch, WORD scanCode, WORD flags) noexcept
try
{
    if (!_terminal)
    {
        return;
    }

    TerminalInput::OutputType out;
    {
        const auto lock = _terminal->LockForWriting();

        if (_terminal->IsSelectionActive())
        {
            _ClearSelection();
            if (ch == UNICODE_ESC)
            {
                // ESC should clear any selection before it triggers input.
                // Other characters pass through.
                return;
            }
        }

        if (ch == UNICODE_TAB)
        {
            // TAB was handled as a keydown event (cf. Terminal::SendKeyEvent)
            return;
        }

        auto modifiers = getControlKeyState();
        if (WI_IsFlagSet(flags, ENHANCED_KEY))
        {
            modifiers |= ControlKeyStates::EnhancedKey;
        }

        out = _terminal->SendCharEvent(ch, scanCode, modifiers);
    }
    if (out)
    {
        _WriteTextToConnection(*out);
    ...",1,<empty>,,809,44,CPPASTProblemDeclaration,,<empty>
143167,UNKNOWN,45,,"void _stdcall TerminalSendKeyEvent(void* terminal, WORD vkey, WORD scanCode, WORD flags, bool keyDown)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->_SendKeyEvent(vkey, scanCode, flags, keyDown);
}",1,<empty>,,853,45,CPPASTProblemDeclaration,,<empty>
143168,UNKNOWN,46,,"CATCH_LOG()

void _stdcall TerminalSendCharEvent(void* terminal, wchar_t ch, WORD scanCode, WORD flags)
try
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->_SendCharEvent(ch, scanCode, flags);
}",1,<empty>,,859,46,CPPASTProblemDeclaration,,<empty>
143169,UNKNOWN,47,,"CATCH_LOG()

void _stdcall DestroyTerminal(void* terminal)
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    delete publicTerminal;
}",1,<empty>,,867,47,CPPASTProblemDeclaration,,<empty>
143170,UNKNOWN,48,,"void _stdcall TerminalSetTheme(void* terminal, TerminalTheme theme, LPCWSTR fontFamily, til::CoordType fontSize, int newDpi)
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    if (!publicTerminal || !publicTerminal->_terminal)
    {
        return;
    }

    {
        const auto lock = publicTerminal->_terminal->LockForWriting();

        auto& renderSettings = publicTerminal->_terminal->GetRenderSettings();
        renderSettings.SetColorTableEntry(TextColor::DEFAULT_FOREGROUND, theme.DefaultForeground);
        renderSettings.SetColorTableEntry(TextColor::DEFAULT_BACKGROUND, theme.DefaultBackground);

        publicTerminal->_renderEngine->SetSelectionBackground(theme.DefaultSelectionBackground, theme.SelectionBackgroundAlpha);

        // Set the font colors
        for (size_t tableIndex = 0; tableIndex < 16; tableIndex++)
        {
            // It's using gsl::at to check the index is in bounds, but the analyzer still calls this array-to-pointer-deca...",1,<empty>,,876,48,CPPASTProblemDeclaration,,<empty>
143171,UNKNOWN,49,,"void _stdcall TerminalBlinkCursor(void* terminal)
try
{
    const auto publicTerminal = static_cast<const HwndTerminal*>(terminal);
    if (!publicTerminal || !publicTerminal->_terminal)
    {
        return;
    }

    const auto lock = publicTerminal->_terminal->LockForWriting();
    publicTerminal->_terminal->BlinkCursor();
}",1,<empty>,,916,49,CPPASTProblemDeclaration,,<empty>
143172,UNKNOWN,50,,"CATCH_LOG()

void _stdcall TerminalSetCursorVisible(void* terminal, const bool visible)
try
{
    const auto publicTerminal = static_cast<const HwndTerminal*>(terminal);
    if (!publicTerminal || !publicTerminal->_terminal)
    {
        return;
    }
    const auto lock = publicTerminal->_terminal->LockForWriting();
    publicTerminal->_terminal->SetCursorOn(visible);
}",1,<empty>,,928,50,CPPASTProblemDeclaration,,<empty>
143173,UNKNOWN,51,,"CATCH_LOG()

void __stdcall TerminalSetFocus(void* terminal)
{
    const auto publicTerminal = static_cast<HwndTerminal*>(terminal);
    publicTerminal->_focused = true;
    if (auto uiaEngine = publicTerminal->_uiaEngine.get())
    {
        LOG_IF_FAILED(uiaEngine->Enable());
    }
}",1,<empty>,,941,51,CPPASTProblemDeclaration,,<empty>
143181,UNKNOWN,1,,HwndTerminal*,45,<empty>,,955,1,CPPASTTypeId,,<empty>
143207,UNKNOWN,53,,"HRESULT HwndTerminal::_CopyTextToSystemClipboard(const TextBuffer::TextAndColor& rows, const bool fAlsoCopyFormatting)
try
{
    RETURN_HR_IF_NULL(E_NOT_VALID_STATE, _terminal);
    std::wstring finalString;

    // Concatenate strings into one giant string to put onto the clipboard.
    for (const auto& str : rows.text)
    {
        finalString += str;
    }

    // allocate the final clipboard data
    const auto cchNeeded = finalString.size() + 1;
    const auto cbNeeded = sizeof(wchar_t) * cchNeeded;
    wil::unique_hglobal globalHandle(GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cbNeeded));
    RETURN_LAST_ERROR_IF_NULL(globalHandle.get());

    auto pwszClipboard = static_cast<PWSTR>(GlobalLock(globalHandle.get()));
    RETURN_LAST_ERROR_IF_NULL(pwszClipboard);

    // The pattern gets a bit strange here because there's no good wil built-in for global lock of this type.
    // Try to copy then immediately unlock. Don't throw until after (so the hglobal won't be freed until we ...",1,<empty>,,968,53,CPPASTProblemDeclaration,,<empty>
143237,UNKNOWN,1,,PCWCH,40,<empty>,,1084,1,CPPASTTypeId,,<empty>
143283,UNKNOWN,1,,double,24,<empty>,,1113,1,CPPASTTypeId,,<empty>
143286,UNKNOWN,1,,double,59,<empty>,,1113,1,CPPASTTypeId,,<empty>
143358,UNKNOWN,4,,"__declspec(dllexport) HRESULT _stdcall CreateTerminal(HWND parentHwnd, _Out_ void** hwnd, _Out_ void** terminal);",1,<empty>,,27,4,CPPASTProblemDeclaration,,<empty>
143359,UNKNOWN,5,,"__declspec(dllexport) void _stdcall TerminalSendOutput(void* terminal, LPCWSTR data);",1,<empty>,,28,5,CPPASTProblemDeclaration,,<empty>
143360,UNKNOWN,6,,"__declspec(dllexport) void _stdcall TerminalRegisterScrollCallback(void* terminal, void __stdcall callback(int, int, int));",1,<empty>,,29,6,CPPASTProblemDeclaration,,<empty>
143361,UNKNOWN,7,,"__declspec(dllexport) HRESULT _stdcall TerminalTriggerResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions);",1,<empty>,,30,7,CPPASTProblemDeclaration,,<empty>
143362,UNKNOWN,8,,"__declspec(dllexport) HRESULT _stdcall TerminalTriggerResizeWithDimension(_In_ void* terminal, _In_ til::size dimensions, _Out_ til::size* dimensionsInPixels);",1,<empty>,,31,8,CPPASTProblemDeclaration,,<empty>
143363,UNKNOWN,9,,"__declspec(dllexport) HRESULT _stdcall TerminalCalculateResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions);",1,<empty>,,32,9,CPPASTProblemDeclaration,,<empty>
143364,UNKNOWN,10,,"__declspec(dllexport) void _stdcall TerminalDpiChanged(void* terminal, int newDpi);",1,<empty>,,33,10,CPPASTProblemDeclaration,,<empty>
143365,UNKNOWN,11,,"__declspec(dllexport) void _stdcall TerminalUserScroll(void* terminal, int viewTop);",1,<empty>,,34,11,CPPASTProblemDeclaration,,<empty>
143366,UNKNOWN,12,,__declspec(dllexport) void _stdcall TerminalClearSelection(void* terminal);,1,<empty>,,35,12,CPPASTProblemDeclaration,,<empty>
143367,UNKNOWN,13,,__declspec(dllexport) const wchar_t* _stdcall TerminalGetSelection(void* terminal);,1,<empty>,,36,13,CPPASTProblemDeclaration,,<empty>
143368,UNKNOWN,14,,__declspec(dllexport) bool _stdcall TerminalIsSelectionActive(void* terminal);,1,<empty>,,37,14,CPPASTProblemDeclaration,,<empty>
143369,UNKNOWN,15,,__declspec(dllexport) void _stdcall DestroyTerminal(void* terminal);,1,<empty>,,38,15,CPPASTProblemDeclaration,,<empty>
143370,UNKNOWN,16,,"__declspec(dllexport) void _stdcall TerminalSetTheme(void* terminal, TerminalTheme theme, LPCWSTR fontFamily, til::CoordType fontSize, int newDpi);",1,<empty>,,39,16,CPPASTProblemDeclaration,,<empty>
143371,UNKNOWN,17,,"__declspec(dllexport) void _stdcall TerminalRegisterWriteCallback(void* terminal, const void __stdcall callback(wchar_t*));",1,<empty>,,40,17,CPPASTProblemDeclaration,,<empty>
143372,UNKNOWN,18,,"__declspec(dllexport) void _stdcall TerminalSendKeyEvent(void* terminal, WORD vkey, WORD scanCode, WORD flags, bool keyDown);",1,<empty>,,41,18,CPPASTProblemDeclaration,,<empty>
143373,UNKNOWN,19,,"__declspec(dllexport) void _stdcall TerminalSendCharEvent(void* terminal, wchar_t ch, WORD flags, WORD scanCode);",1,<empty>,,42,19,CPPASTProblemDeclaration,,<empty>
143374,UNKNOWN,20,,__declspec(dllexport) void _stdcall TerminalBlinkCursor(void* terminal);,1,<empty>,,43,20,CPPASTProblemDeclaration,,<empty>
143375,UNKNOWN,21,,"__declspec(dllexport) void _stdcall TerminalSetCursorVisible(void* terminal, const bool visible);",1,<empty>,,44,21,CPPASTProblemDeclaration,,<empty>
143376,UNKNOWN,22,,__declspec(dllexport) void _stdcall TerminalSetFocus(void* terminal);,1,<empty>,,45,22,CPPASTProblemDeclaration,,<empty>
143377,UNKNOWN,23,,__declspec(dllexport) void _stdcall TerminalKillFocus(void* terminal);,1,<empty>,,46,23,CPPASTProblemDeclaration,,<empty>
143421,UNKNOWN,-1,,"HRESULT Refresh(const til::size windowSize, _Out_ til::size* dimensions);",5,<empty>,,63,10,CPPASTProblemDeclaration,,<empty>
143427,UNKNOWN,-1,,void RegisterWriteCallback(const void _stdcall callback(wchar_t*));,5,<empty>,,65,12,CPPASTProblemDeclaration,,<empty>
143436,UNKNOWN,-1,,"static LRESULT CALLBACK HwndTerminalWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) noexcept;",5,<empty>,,69,15,CPPASTProblemDeclaration,,<empty>
143453,UNKNOWN,-1,,"friend HRESULT _stdcall CreateTerminal(HWND parentHwnd, _Out_ void** hwnd, _Out_ void** terminal);",5,<empty>,,93,32,CPPASTProblemDeclaration,,<empty>
143454,UNKNOWN,-1,,"friend HRESULT _stdcall TerminalTriggerResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions);",5,<empty>,,94,33,CPPASTProblemDeclaration,,<empty>
143455,UNKNOWN,-1,,"friend HRESULT _stdcall TerminalTriggerResizeWithDimension(_In_ void* terminal, _In_ til::size dimensions, _Out_ til::size* dimensionsInPixels);",5,<empty>,,95,34,CPPASTProblemDeclaration,,<empty>
143456,UNKNOWN,-1,,"friend HRESULT _stdcall TerminalCalculateResize(_In_ void* terminal, _In_ til::CoordType width, _In_ til::CoordType height, _Out_ til::size* dimensions);",5,<empty>,,96,35,CPPASTProblemDeclaration,,<empty>
143457,UNKNOWN,-1,,"friend void _stdcall TerminalDpiChanged(void* terminal, int newDpi);",5,<empty>,,97,36,CPPASTProblemDeclaration,,<empty>
143458,UNKNOWN,-1,,"friend void _stdcall TerminalUserScroll(void* terminal, int viewTop);",5,<empty>,,98,37,CPPASTProblemDeclaration,,<empty>
143459,UNKNOWN,-1,,friend void _stdcall TerminalClearSelection(void* terminal);,5,<empty>,,99,38,CPPASTProblemDeclaration,,<empty>
143460,UNKNOWN,-1,,friend const wchar_t* _stdcall TerminalGetSelection(void* terminal);,5,<empty>,,100,39,CPPASTProblemDeclaration,,<empty>
143461,UNKNOWN,-1,,friend bool _stdcall TerminalIsSelectionActive(void* terminal);,5,<empty>,,101,40,CPPASTProblemDeclaration,,<empty>
143462,UNKNOWN,-1,,"friend void _stdcall TerminalSendKeyEvent(void* terminal, WORD vkey, WORD scanCode, WORD flags, bool keyDown);",5,<empty>,,102,41,CPPASTProblemDeclaration,,<empty>
143463,UNKNOWN,-1,,"friend void _stdcall TerminalSendCharEvent(void* terminal, wchar_t ch, WORD scanCode, WORD flags);",5,<empty>,,103,42,CPPASTProblemDeclaration,,<empty>
143464,UNKNOWN,-1,,"friend void _stdcall TerminalSetTheme(void* terminal, TerminalTheme theme, LPCWSTR fontFamily, til::CoordType fontSize, int newDpi);",5,<empty>,,104,43,CPPASTProblemDeclaration,,<empty>
143465,UNKNOWN,-1,,friend void _stdcall TerminalBlinkCursor(void* terminal);,5,<empty>,,105,44,CPPASTProblemDeclaration,,<empty>
143466,UNKNOWN,-1,,"friend void _stdcall TerminalSetCursorVisible(void* terminal, const bool visible);",5,<empty>,,106,45,CPPASTProblemDeclaration,,<empty>
143467,UNKNOWN,-1,,friend void _stdcall TerminalSetFocus(void* terminal);,5,<empty>,,107,46,CPPASTProblemDeclaration,,<empty>
143468,UNKNOWN,-1,,friend void _stdcall TerminalKillFocus(void* terminal);,5,<empty>,,108,47,CPPASTProblemDeclaration,,<empty>
143719,UNKNOWN,7,,"IFACEMETHODIMP HwndTerminalAutomationPeer::GetPropertyValue(_In_ PROPERTYID propertyId,
                                                            _Out_ VARIANT* pVariant) noexcept
{
    pVariant->vt = VT_EMPTY;

    // Returning the default will leave the property as the default
    // so we only really need to touch it for the properties we want to implement
    if (propertyId == UIA_ClassNamePropertyId)
    {
        // IMPORTANT: Do NOT change the name. Screen readers like may be dependent on this being ""WpfTermControl"".
        pVariant->bstrVal = SysAllocString(L""WPFTermControl"");
        if (pVariant->bstrVal != nullptr)
        {
            pVariant->vt = VT_BSTR;
        }
    }
    else
    {
        // fall back to shared implementation
        return TermControlUiaProvider::GetPropertyValue(propertyId, pVariant);
    }
    return S_OK;
}",1,<empty>,,74,7,CPPASTProblemDeclaration,,<empty>
143858,UNKNOWN,-1,,"__try
    {
        LOG_IF_FAILED(UiaRaiseNotificationEvent(this, NotificationKind_ActionCompleted, NotificationProcessing_All, string, activity));
    }",5,<empty>,,181,1,CPPASTProblemStatement,,<empty>
143862,UNKNOWN,-1,,),60,<empty>,,185,3,CPPASTProblemStatement,,<empty>
143886,UNKNOWN,-1,,"IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                    _Out_ VARIANT* pVariant) noexcept override;",5,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
144142,UNKNOWN,1,,XamlAutomation::SupportedTextSelection,28,<empty>,,143,1,CPPASTTypeId,,<empty>
144642,UNKNOWN,1,,uint64_t,30,<empty>,,53,1,CPPASTTypeId,,<empty>
145761,UNKNOWN,-1,,"WINRT_CALLBACK(Search, SearchHandler);",9,<empty>,,47,18,CPPASTProblemDeclaration,,<empty>
145762,UNKNOWN,-1,,"WINRT_CALLBACK(SearchChanged, SearchHandler);",9,<empty>,,48,19,CPPASTProblemDeclaration,,<empty>
145763,UNKNOWN,-1,,"TYPED_EVENT(Closed, Control::SearchBoxControl, Windows::UI::Xaml::RoutedEventArgs);",9,<empty>,,49,20,CPPASTProblemDeclaration,,<empty>
146078,UNKNOWN,-1,,"void TSFInputControl::TryRedrawCanvas()
    try
    {
        if (!_focused || !Canvas())
        {
            return;
        }

        // Get the cursor position in text buffer position
        auto cursorArgs = winrt::make_self<CursorPositionEventArgs>();
        _CurrentCursorPositionHandlers(*this, *cursorArgs);
        const til::point cursorPos{ til::math::flooring, cursorArgs->CurrentPosition() };

        const auto actualCanvasWidth{ Canvas().ActualWidth() };
        const auto actualTextBlockHeight{ TextBlock().ActualHeight() };
        const auto actualWindowBounds{ CoreWindow::GetForCurrentThread().Bounds() };

        if (_currentTerminalCursorPos == cursorPos &&
            _currentCanvasWidth == actualCanvasWidth &&
            _currentTextBlockHeight == actualTextBlockHeight &&
            _currentWindowBounds == actualWindowBounds)
        {
            return;
        }

        _currentTerminalCursorPos = cursorPos;
        _currentCanvasWidth = actualCanvasWid...",5,<empty>,,117,6,CPPASTProblemDeclaration,,<empty>
146138,UNKNOWN,-1,,"try
        {
            const auto range = args.Request().Range();
            const auto text = _inputBuffer.substr(
                range.StartCaretPosition,
                range.EndCaretPosition - range.StartCaretPosition);
            args.Request().Text(text);
        }
        CATCH_LOG();",9,<empty>,,313,1,CPPASTProblemStatement,,<empty>
146343,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Point, CurrentPosition);",9,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
146349,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Size, FontSize);",9,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
146350,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, FontFace);",9,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
146351,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::UI::Text::FontWeight, FontWeight);",9,<empty>,,30,4,CPPASTProblemDeclaration,,<empty>
146377,UNKNOWN,-1,,"TYPED_EVENT(CurrentCursorPosition, Control::TSFInputControl, Control::CursorPositionEventArgs);",9,<empty>,,46,7,CPPASTProblemDeclaration,,<empty>
146378,UNKNOWN,-1,,"TYPED_EVENT(CurrentFontInfo, Control::TSFInputControl, Control::FontInfoEventArgs);",9,<empty>,,47,8,CPPASTProblemDeclaration,,<empty>
146379,UNKNOWN,-1,,"WINRT_CALLBACK(CompositionCompleted, Control::CompositionCompletedEventArgs);",9,<empty>,,48,9,CPPASTProblemDeclaration,,<empty>
146785,UNKNOWN,1,,DWORD*,50,<empty>,,362,1,CPPASTTypeId,,<empty>
147584,UNKNOWN,1,,int,96,<empty>,,159,1,CPPASTTypeId,,<empty>
147720,UNKNOWN,1,,HANDLE,53,<empty>,,239,1,CPPASTTypeId,,<empty>
148489,UNKNOWN,1,,til::color,47,<empty>,,604,1,CPPASTTypeId,,<empty>
149301,UNKNOWN,1,,HANDLE,37,<empty>,,983,1,CPPASTTypeId,,<empty>
149321,UNKNOWN,1,,HRESULT,37,<empty>,,1000,1,CPPASTTypeId,,<empty>
149477,UNKNOWN,1,,float,45,<empty>,,1042,1,CPPASTTypeId,,<empty>
149486,UNKNOWN,1,,float,46,<empty>,,1043,1,CPPASTTypeId,,<empty>
149891,UNKNOWN,1,,void,14,<empty>,,1228,1,CPPASTTypeId,,<empty>
149996,UNKNOWN,1,,void,18,<empty>,,1263,1,CPPASTTypeId,,<empty>
151112,UNKNOWN,-1,,"try
        {
            _changeBackgroundOpacity();
        }
        CATCH_LOG();",9,<empty>,,1763,3,CPPASTProblemStatement,,<empty>
152207,UNKNOWN,1,,float,42,<empty>,,2433,1,CPPASTTypeId,,<empty>
152227,UNKNOWN,1,,float,43,<empty>,,2441,1,CPPASTTypeId,,<empty>
152241,UNKNOWN,1,,float,38,<empty>,,2444,1,CPPASTTypeId,,<empty>
152254,UNKNOWN,1,,float,39,<empty>,,2445,1,CPPASTTypeId,,<empty>
152314,UNKNOWN,1,,float,38,<empty>,,2482,1,CPPASTTypeId,,<empty>
152326,UNKNOWN,1,,float,34,<empty>,,2487,1,CPPASTTypeId,,<empty>
152337,UNKNOWN,1,,float,35,<empty>,,2488,1,CPPASTTypeId,,<empty>
152942,UNKNOWN,1,,float,49,<empty>,,2755,1,CPPASTTypeId,,<empty>
152947,UNKNOWN,1,,float,82,<empty>,,2755,1,CPPASTTypeId,,<empty>
153023,UNKNOWN,-1,,"try
            {
                auto link{ co_await e.DataView().GetApplicationLinkAsync() };",13,<empty>,,2810,1,CPPASTProblemStatement,,<empty>
153032,UNKNOWN,-1,,"else if (e.DataView().Contains(StandardDataFormats::WebLink()))
        {
            try
            {
                auto link{ co_await e.DataView().GetWebLinkAsync() };
                _pasteTextWithBroadcast(link.AbsoluteUri());
            }
            CATCH_LOG();
        }",9,<empty>,,2817,106,CPPASTProblemDeclaration,,<empty>
153033,UNKNOWN,-1,,"else if (e.DataView().Contains(StandardDataFormats::Text()))
        {
            try
            {
                auto text{ co_await e.DataView().GetTextAsync() };
                _pasteTextWithBroadcast(text);
            }
            CATCH_LOG();
        }",9,<empty>,,2826,107,CPPASTProblemDeclaration,,<empty>
153034,UNKNOWN,-1,,"else if (e.DataView().Contains(StandardDataFormats::StorageItems()))
        {
            Windows::Foundation::Collections::IVectorView<Windows::Storage::IStorageItem> items;
            try
            {
                items = co_await e.DataView().GetStorageItemsAsync();
            }
            CATCH_LOG();

            if (items.Size() > 0)
            {
                std::vector<std::wstring> fullPaths;

                // GH#14628: Workaround for GetStorageItemsAsync() only returning 16 items
                // at most when dragging and dropping from archives (zip, 7z, rar, etc.)
                if (items.Size() == 16 && e.DataView().Contains(winrt::hstring{ L""FileDrop"" }))
                {
                    auto fileDropData = co_await e.DataView().GetDataAsync(winrt::hstring{ L""FileDrop"" });
                    if (fileDropData != nullptr)
                    {
                        auto stream = fileDropData.as<IRandomAccessStream>();
                        strea...",9,<empty>,,2839,108,CPPASTProblemDeclaration,,<empty>
154290,UNKNOWN,-1,,e,23,<empty>,,3521,7,CPPASTProblemStatement,,<empty>
154938,UNKNOWN,66,,},1,<empty>,,3737,66,CPPASTProblemDeclaration,,<empty>
155985,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, BackgroundBrush, _PropertyChangedHandlers, nullptr)",9,<empty>,,198,2,CPPASTProblemStatement,,<empty>
155986,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, BackgroundBrush, _PropertyChangedHandlers, nullptr)",9,<empty>,,198,3,CPPASTProblemStatement,,<empty>
156778,UNKNOWN,-1,,"try
                    {
                        strongThis->RaiseNotificationEvent(AutomationNotificationKind::ActionCompleted,
                                                           AutomationNotificationProcessing::All,
                                                           sanitizedCopy,
                                                           L""TerminalTextOutput"");
                    }
                    CATCH_LOG();",21,<empty>,,260,1,CPPASTProblemStatement,,<empty>
157857,UNKNOWN,1,,UIA::TextPatternRangeEndpoint,68,<empty>,,58,1,CPPASTTypeId,,<empty>
157866,UNKNOWN,1,,UIA::TextPatternRangeEndpoint,68,<empty>,,60,1,CPPASTTypeId,,<empty>
157883,UNKNOWN,1,,UIA::TextUnit,73,<empty>,,67,1,CPPASTTypeId,,<empty>
158066,UNKNOWN,1,,void**,62,<empty>,,160,1,CPPASTTypeId,,<empty>
158151,UNKNOWN,1,,::Microsoft::Console::Types::UiaTextRangeBase*,94,<empty>,,186,1,CPPASTTypeId,,<empty>
158199,UNKNOWN,1,,UIA::TextUnit,56,<empty>,,201,1,CPPASTTypeId,,<empty>
158220,UNKNOWN,1,,UIA::TextPatternRangeEndpoint,70,<empty>,,212,1,CPPASTTypeId,,<empty>
158223,UNKNOWN,1,,UIA::TextUnit,70,<empty>,,213,1,CPPASTTypeId,,<empty>
158253,UNKNOWN,1,,UIA::TextPatternRangeEndpoint,71,<empty>,,224,1,CPPASTTypeId,,<empty>
158262,UNKNOWN,1,,UIA::TextPatternRangeEndpoint,71,<empty>,,226,1,CPPASTTypeId,,<empty>
158459,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hTerminalControlProvider,
    ""Microsoft.Windows.Terminal.Control"",
    // {28c82e50-57af-5a86-c25b-e39cd990032b}
    (0x28c82e50, 0x57af, 0x5a86, 0xc2, 0x5b, 0xe3, 0x9c, 0xd9, 0x90, 0x03, 0x2b),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
158460,UNKNOWN,2,,BOOL,1,<empty>,,19,2,CPPASTProblemDeclaration,,<empty>
158499,UNKNOWN,4,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""Microsoft.Terminal.Control/Resources"");",1,<empty>,,40,4,CPPASTProblemDeclaration,,<empty>
158931,UNKNOWN,-1,,"virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendKeyEvent(const WORD vkey, const WORD scanCode, const ControlKeyStates states, const bool keyDown) = 0;",9,<empty>,,19,6,CPPASTProblemDeclaration,,<empty>
158932,UNKNOWN,-1,,"virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendMouseEvent(const til::point viewportPos, const unsigned int uiButton, const ControlKeyStates states, const short wheelDelta, const Microsoft::Console::VirtualTerminal::TerminalInput::MouseButtonState state) = 0;",9,<empty>,,20,7,CPPASTProblemDeclaration,,<empty>
158933,UNKNOWN,-1,,"virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType SendCharEvent(const wchar_t ch, const WORD scanCode, const ControlKeyStates states) = 0;",9,<empty>,,21,8,CPPASTProblemDeclaration,,<empty>
158934,UNKNOWN,-1,,virtual [[nodiscard]] ::Microsoft::Console::VirtualTerminal::TerminalInput::OutputType FocusChanged(const bool focused) = 0;,9,<empty>,,22,9,CPPASTProblemDeclaration,,<empty>
159684,UNKNOWN,1,,OutputStateMachineEngine&,37,<empty>,,212,1,CPPASTTypeId,,<empty>
159705,UNKNOWN,1,,OutputStateMachineEngine&,37,<empty>,,218,1,CPPASTTypeId,,<empty>
159742,UNKNOWN,12,,"[[nodiscard]] HRESULT Terminal::UserResize(const til::size viewportSize) noexcept
try
{
    const auto oldDimensions = _GetMutableViewport().Dimensions();
    if (viewportSize == oldDimensions)
    {
        return S_FALSE;
    }

    if (_inAltBuffer())
    {
        // _deferredResize will indicate to UseMainScreenBuffer() that it needs to reflow the main buffer.
        // Deferring the reflow of the main buffer has the benefit that it avoids destroying the state
        // of the text buffer any more than necessary. For ConPTY in particular a reflow is destructive,
        // because it ""forgets"" text that wraps beyond the top of its viewport when shrinking it.
        _deferredResize = viewportSize;

        // GH#3494: We don't need to reflow the alt buffer. Apps that use the alt buffer will
        // redraw themselves. This prevents graphical artifacts and is consistent with VTE.
        _altBuffer->ResizeTraditional(viewportSize);

        _altBufferSize = viewportSize;
   ...",1,<empty>,,240,12,CPPASTProblemDeclaration,,<empty>
160642,UNKNOWN,1,,til::recursive_ticket_lock&,41,<empty>,,942,1,CPPASTTypeId,,<empty>
160941,UNKNOWN,-1,,"try
        {
            _pfnCursorPositionChanged();
        }
        CATCH_LOG();",9,<empty>,,1097,1,CPPASTProblemStatement,,<empty>
162227,UNKNOWN,-1,,"try
        {
            if (matchMode == winrt::Microsoft::Terminal::Core::MatchMode::None)
            {
                colorSelection(start, end, attr);
            }
            else if (matchMode == winrt::Microsoft::Terminal::Core::MatchMode::All)
            {
                const auto& textBuffer = _activeBuffer();
                const auto text = textBuffer.GetPlainText(start, end);
                std::wstring_view textView{ text };

                if (IsBlockSelection())
                {
                    textView = Utils::TrimPaste(textView);
                }

                if (!textView.empty())
                {
                    const auto hits = textBuffer.SearchText(textView, true);
                    for (const auto& s : hits)
                    {
                        colorSelection(s.start, s.end, attr);
                    }
                }
            }
        }
        CATCH_LOG();",9,<empty>,,1562,1,CPPASTProblemStatement,,<empty>
162251,UNKNOWN,86,,"extern ""C"" UINT OneCoreSafeMapVirtualKeyW(_In_ UINT uCode, _In_ UINT uMapType)
{
    return MapVirtualKeyW(uCode, uMapType);
}",1,<empty>,,1607,86,CPPASTProblemDeclaration,,<empty>
162252,UNKNOWN,87,,"extern ""C"" SHORT OneCoreSafeVkKeyScanW(_In_ WCHAR ch)
{
    return VkKeyScanW(ch);
}",1,<empty>,,1612,87,CPPASTProblemDeclaration,,<empty>
162253,UNKNOWN,88,,"extern ""C"" SHORT OneCoreSafeGetKeyState(_In_ int nVirtKey)
{
    return GetKeyState(nVirtKey);
}",1,<empty>,,1617,88,CPPASTProblemDeclaration,,<empty>
163353,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(g_hCTerminalCoreProvider,
                             ""Microsoft.Terminal.Core"",
                             // {103ac8cf-97d2-51aa-b3ba-5ffd5528fa5f}
                             (0x103ac8cf, 0x97d2, 0x51aa, 0xb3, 0xba, 0x5f, 0xfd, 0x55, 0x28, 0xfa, 0x5f),
                             TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
163388,UNKNOWN,6,,"void Terminal::SetViewportPosition(const til::point position) noexcept
try
{
    // The viewport is fixed at 0,0 for the alt buffer, so this is a no-op.
    if (!_inAltBuffer())
    {
        const auto viewportDelta = position.y - _GetMutableViewport().Origin().y;
        const auto dimensions = _GetMutableViewport().Dimensions();
        _mutableViewport = Viewport::FromDimensions(position, dimensions);
        _PreserveUserScrollOffset(viewportDelta);
        _NotifyScrollEvent();
    }
}
CATCH_LOG()

void Terminal::SetTextAttributes(const TextAttribute& attrs) noexcept
{
    _activeBuffer().SetCurrentAttributes(attrs);
}",1,<empty>,,46,6,CPPASTProblemDeclaration,,<empty>
163480,UNKNOWN,1,,size_t,33,<empty>,,132,1,CPPASTTypeId,,<empty>
163702,UNKNOWN,-1,,"try
    {
        _activeBuffer().TriggerRedrawAll();
    }
    CATCH_LOG();",5,<empty>,,243,12,CPPASTProblemStatement,,<empty>
164438,UNKNOWN,-1,,"try
    {
        return _activeBuffer().GetTextRects(_selection->start, _selection->end, _blockSelection, false);
    }
    CATCH_LOG();",5,<empty>,,58,3,CPPASTProblemStatement,,<empty>
164460,UNKNOWN,-1,,"try
    {
        return _activeBuffer().GetTextSpans(_selection->start, _selection->end, _blockSelection, false);
    }
    CATCH_LOG();",5,<empty>,,79,3,CPPASTProblemStatement,,<empty>
165685,UNKNOWN,1,,SelectionEndpoint,38,<empty>,,614,1,CPPASTTypeId,,<empty>
166409,UNKNOWN,1,,SelectionEndpoint,38,<empty>,,830,1,CPPASTTypeId,,<empty>
168291,UNKNOWN,-1,,"WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);",9,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
168292,UNKNOWN,-1,,"WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);",9,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
168293,UNKNOWN,-1,,"WINRT_PROPERTY(hstring, OldActionName);",9,<empty>,,34,4,CPPASTProblemDeclaration,,<empty>
168294,UNKNOWN,-1,,"WINRT_PROPERTY(hstring, NewActionName);",9,<empty>,,35,5,CPPASTProblemDeclaration,,<empty>
168424,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(IInspectable, ProposedAction)",9,<empty>,,76,2,CPPASTProblemStatement,,<empty>
168445,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(hstring, CurrentAction)",9,<empty>,,77,2,CPPASTProblemStatement,,<empty>
168449,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<hstring>, AvailableActions, nullptr);",9,<empty>,,78,28,CPPASTProblemDeclaration,,<empty>
168467,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(Control::KeyChord, ProposedKeys)",9,<empty>,,82,2,CPPASTProblemStatement,,<empty>
168488,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(Control::KeyChord, CurrentKeys, nullptr)",9,<empty>,,83,2,CPPASTProblemStatement,,<empty>
168509,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsInEditMode, false)",9,<empty>,,85,2,CPPASTProblemStatement,,<empty>
168530,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsNewlyAdded, false)",9,<empty>,,86,2,CPPASTProblemStatement,,<empty>
168551,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(Windows::UI::Xaml::Controls::Flyout, AcceptChangesFlyout, nullptr)",9,<empty>,,87,2,CPPASTProblemStatement,,<empty>
168572,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsAutomationPeerAttached, false)",9,<empty>,,88,2,CPPASTProblemStatement,,<empty>
168593,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsHovered, false)",9,<empty>,,89,2,CPPASTProblemStatement,,<empty>
168614,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsContainerFocused, false)",9,<empty>,,90,2,CPPASTProblemStatement,,<empty>
168635,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(bool, IsEditButtonFocused, false)",9,<empty>,,91,2,CPPASTProblemStatement,,<empty>
168656,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(Windows::UI::Xaml::Media::Brush, ContainerBackground, nullptr)",9,<empty>,,92,2,CPPASTProblemStatement,,<empty>
168660,UNKNOWN,-1,,"TYPED_EVENT(ModifyKeyBindingRequested, Editor::KeyBindingViewModel, Editor::ModifyKeyBindingEventArgs);",9,<empty>,,93,59,CPPASTProblemDeclaration,,<empty>
168661,UNKNOWN,-1,,"TYPED_EVENT(DeleteKeyBindingRequested, Editor::KeyBindingViewModel, Terminal::Control::KeyChord);",9,<empty>,,94,60,CPPASTProblemDeclaration,,<empty>
168662,UNKNOWN,-1,,"TYPED_EVENT(DeleteNewlyAddedKeyBinding, Editor::KeyBindingViewModel, IInspectable);",9,<empty>,,95,61,CPPASTProblemDeclaration,,<empty>
168722,UNKNOWN,-1,,"WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)",9,<empty>,,107,2,CPPASTProblemDeclaration,,<empty>
168743,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,119,5,CPPASTProblemDeclaration,,<empty>
168744,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::ActionsPageNavigationState, State, nullptr);",9,<empty>,,120,6,CPPASTProblemDeclaration,,<empty>
168745,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::KeyBindingViewModel>, KeyBindingList);",9,<empty>,,121,7,CPPASTProblemDeclaration,,<empty>
168944,UNKNOWN,-1,,"WINRT_PROPERTY(Model::CascadiaSettings, Settings, nullptr)
        WINRT_CALLBACK(AddNew, AddNewArgs);",9,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
168973,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::AddProfilePageNavigationState, State, nullptr);",9,<empty>,,57,6,CPPASTProblemDeclaration,,<empty>
168974,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,58,7,CPPASTProblemDeclaration,,<empty>
168975,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, IsProfileSelected, _PropertyChangedHandlers, nullptr);",9,<empty>,,59,8,CPPASTProblemDeclaration,,<empty>
169076,UNKNOWN,1,,int32_t,59,<empty>,,368,1,CPPASTTypeId,,<empty>
170682,UNKNOWN,1,,int32_t,53,<empty>,,345,1,CPPASTTypeId,,<empty>
170740,UNKNOWN,1,,int32_t,51,<empty>,,421,1,CPPASTTypeId,,<empty>
170808,UNKNOWN,1,,HWND,49,<empty>,,437,1,CPPASTTypeId,,<empty>
170817,UNKNOWN,-1,,t,28,<empty>,,438,7,CPPASTProblemStatement,,<empty>
170868,UNKNOWN,1,,ConvergedAlignment,67,<empty>,,452,1,CPPASTTypeId,,<empty>
171073,UNKNOWN,-1,,"WINRT_PROPERTY(hstring, Name);",9,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
171074,UNKNOWN,-1,,"WINRT_PROPERTY(hstring, LocalizedName);",9,<empty>,,50,5,CPPASTProblemDeclaration,,<empty>
171145,UNKNOWN,-1,,"WINRT_PROPERTY(bool, IsDefault, false);",9,<empty>,,80,16,CPPASTProblemDeclaration,,<empty>
171180,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontFace)",9,<empty>,,87,2,CPPASTProblemStatement,,<empty>
171227,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontFace)",9,<empty>,,87,1,CPPASTProblemStatement,,<empty>
171279,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontSize)",9,<empty>,,88,2,CPPASTProblemStatement,,<empty>
171326,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontSize)",9,<empty>,,88,1,CPPASTProblemStatement,,<empty>
171378,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontWeight)",9,<empty>,,89,2,CPPASTProblemStatement,,<empty>
171425,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance.SourceProfile().FontInfo(), FontWeight)",9,<empty>,,89,1,CPPASTProblemStatement,,<empty>
171465,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, RetroTerminalEffect)",9,<empty>,,91,2,CPPASTProblemStatement,,<empty>
171494,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, RetroTerminalEffect)",9,<empty>,,91,1,CPPASTProblemStatement,,<empty>
171528,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, CursorShape)",9,<empty>,,92,2,CPPASTProblemStatement,,<empty>
171557,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, CursorShape)",9,<empty>,,92,1,CPPASTProblemStatement,,<empty>
171591,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, CursorHeight)",9,<empty>,,93,2,CPPASTProblemStatement,,<empty>
171620,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, CursorHeight)",9,<empty>,,93,1,CPPASTProblemStatement,,<empty>
171654,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, DarkColorSchemeName)",9,<empty>,,94,2,CPPASTProblemStatement,,<empty>
171683,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, DarkColorSchemeName)",9,<empty>,,94,1,CPPASTProblemStatement,,<empty>
171717,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, LightColorSchemeName)",9,<empty>,,95,2,CPPASTProblemStatement,,<empty>
171746,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, LightColorSchemeName)",9,<empty>,,95,1,CPPASTProblemStatement,,<empty>
171780,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImagePath)",9,<empty>,,96,2,CPPASTProblemStatement,,<empty>
171809,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImagePath)",9,<empty>,,96,1,CPPASTProblemStatement,,<empty>
171843,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageOpacity)",9,<empty>,,97,2,CPPASTProblemStatement,,<empty>
171872,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageOpacity)",9,<empty>,,97,1,CPPASTProblemStatement,,<empty>
171906,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageStretchMode)",9,<empty>,,98,2,CPPASTProblemStatement,,<empty>
171935,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageStretchMode)",9,<empty>,,98,1,CPPASTProblemStatement,,<empty>
171969,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageAlignment)",9,<empty>,,99,2,CPPASTProblemStatement,,<empty>
171998,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, BackgroundImageAlignment)",9,<empty>,,99,1,CPPASTProblemStatement,,<empty>
172032,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, IntenseTextStyle)",9,<empty>,,100,2,CPPASTProblemStatement,,<empty>
172061,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, IntenseTextStyle)",9,<empty>,,100,1,CPPASTProblemStatement,,<empty>
172095,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, AdjustIndistinguishableColors)",9,<empty>,,101,2,CPPASTProblemStatement,,<empty>
172124,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_appearance, AdjustIndistinguishableColors)",9,<empty>,,101,1,CPPASTProblemStatement,,<empty>
172136,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::ColorSchemeViewModel>, SchemesList, _propertyChangedHandlers, nullptr);",9,<empty>,,102,87,CPPASTProblemDeclaration,,<empty>
172196,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::EnumEntry>, FontWeightList);",9,<empty>,,132,13,CPPASTProblemDeclaration,,<empty>
172349,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,137,24,CPPASTProblemDeclaration,,<empty>
172384,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::ProfileViewModel, SourceProfile, nullptr);",9,<empty>,,139,29,CPPASTProblemDeclaration,,<empty>
172385,UNKNOWN,-1,,"WINRT_PROPERTY(IHostedInWindow, WindowRoot, nullptr);",9,<empty>,,140,30,CPPASTProblemDeclaration,,<empty>
172542,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(bool, ShowProportionalFontWarning, _PropertyChangedHandlers, nullptr);",9,<empty>,,144,41,CPPASTProblemDeclaration,,<empty>
173300,UNKNOWN,-1,,"WINRT_PROPERTY(bool, IsInBoxScheme);",9,<empty>,,42,11,CPPASTProblemDeclaration,,<empty>
173301,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IVector<Editor::ColorTableEntry>, NonBrightColorTable, nullptr);",9,<empty>,,43,12,CPPASTProblemDeclaration,,<empty>
173302,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IVector<Editor::ColorTableEntry>, BrightColorTable, nullptr);",9,<empty>,,44,13,CPPASTProblemDeclaration,,<empty>
173303,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorTableEntry, ForegroundColor, _propertyChangedHandlers, nullptr);",9,<empty>,,46,14,CPPASTProblemDeclaration,,<empty>
173304,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorTableEntry, BackgroundColor, _propertyChangedHandlers, nullptr);",9,<empty>,,47,15,CPPASTProblemDeclaration,,<empty>
173305,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorTableEntry, CursorColor, _propertyChangedHandlers, nullptr);",9,<empty>,,48,16,CPPASTProblemDeclaration,,<empty>
173306,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorTableEntry, SelectionBackgroundColor, _propertyChangedHandlers, nullptr);",9,<empty>,,49,17,CPPASTProblemDeclaration,,<empty>
173361,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,71,4,CPPASTProblemDeclaration,,<empty>
173362,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Windows::UI::Color, Color, _PropertyChangedHandlers);",9,<empty>,,72,5,CPPASTProblemDeclaration,,<empty>
173363,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, Name, _PropertyChangedHandlers);",9,<empty>,,73,6,CPPASTProblemDeclaration,,<empty>
173364,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(IInspectable, Tag, _PropertyChangedHandlers);",9,<empty>,,74,7,CPPASTProblemDeclaration,,<empty>
173556,UNKNOWN,-1,,"WINRT_PROPERTY(Model::ColorScheme, CurrentColorScheme, nullptr);",9,<empty>,,24,5,CPPASTProblemDeclaration,,<empty>
173557,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemesPageViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,25,6,CPPASTProblemDeclaration,,<empty>
173558,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,27,7,CPPASTProblemDeclaration,,<empty>
174231,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(ColorSchemesSubPage, CurrentPage, _propertyChangedHandlers, ColorSchemesSubPage::Base);",9,<empty>,,37,13,CPPASTProblemDeclaration,,<empty>
174232,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::ColorSchemeViewModel>, AllColorSchemes, _propertyChangedHandlers, nullptr);",9,<empty>,,38,14,CPPASTProblemDeclaration,,<empty>
174284,UNKNOWN,1,,int,28,<empty>,,12,1,CPPASTTypeId,,<empty>
175069,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::ColorSchemeViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,23,7,CPPASTProblemDeclaration,,<empty>
175070,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,25,8,CPPASTProblemDeclaration,,<empty>
175157,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,54,3,CPPASTProblemDeclaration,,<empty>
175158,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::hstring, EnumName, _PropertyChangedHandlers);",9,<empty>,,55,4,CPPASTProblemDeclaration,,<empty>
175159,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(winrt::Windows::Foundation::IInspectable, EnumValue, _PropertyChangedHandlers);",9,<empty>,,56,5,CPPASTProblemDeclaration,,<empty>
175225,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,18,3,CPPASTProblemDeclaration,,<empty>
175226,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::GlobalAppearanceViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,19,4,CPPASTProblemDeclaration,,<empty>
176045,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Model::Theme>, ThemeList, nullptr);",9,<empty>,,20,2,CPPASTProblemDeclaration,,<empty>
176271,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, AlwaysShowTabs)",9,<empty>,,44,2,CPPASTProblemStatement,,<empty>
176305,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, ShowTabsInTitlebar)",9,<empty>,,45,2,CPPASTProblemStatement,,<empty>
176339,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, UseAcrylicInTabRow)",9,<empty>,,46,2,CPPASTProblemStatement,,<empty>
176373,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, ShowTitleInTitlebar)",9,<empty>,,47,2,CPPASTProblemStatement,,<empty>
176407,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, AlwaysOnTop)",9,<empty>,,48,2,CPPASTProblemStatement,,<empty>
176441,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, AutoHideWindow)",9,<empty>,,49,2,CPPASTProblemStatement,,<empty>
176475,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, AlwaysShowNotificationIcon)",9,<empty>,,50,2,CPPASTProblemStatement,,<empty>
176509,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, MinimizeToNotificationArea)",9,<empty>,,51,2,CPPASTProblemStatement,,<empty>
176597,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,17,3,CPPASTProblemDeclaration,,<empty>
176598,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::InteractionViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,18,4,CPPASTProblemDeclaration,,<empty>
177118,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, CopyOnSelect)",9,<empty>,,23,2,CPPASTProblemStatement,,<empty>
177152,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimBlockSelection)",9,<empty>,,24,2,CPPASTProblemStatement,,<empty>
177186,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, TrimPaste)",9,<empty>,,25,2,CPPASTProblemStatement,,<empty>
177220,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, SnapToGridOnResize)",9,<empty>,,26,2,CPPASTProblemStatement,,<empty>
177254,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, FocusFollowMouse)",9,<empty>,,27,2,CPPASTProblemStatement,,<empty>
177288,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, DetectURLs)",9,<empty>,,28,2,CPPASTProblemStatement,,<empty>
177322,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, WordDelimiters)",9,<empty>,,29,2,CPPASTProblemStatement,,<empty>
177356,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_GlobalSettings, ConfirmCloseAllTabs)",9,<empty>,,30,2,CPPASTProblemStatement,,<empty>
177726,UNKNOWN,1,,int32_t,39,<empty>,,134,1,CPPASTTypeId,,<empty>
177949,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,18,3,CPPASTProblemDeclaration,,<empty>
177950,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::LaunchViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,19,4,CPPASTProblemDeclaration,,<empty>
179271,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_Settings.GlobalSettings(), CenterOnLaunch)",9,<empty>,,41,2,CPPASTProblemStatement,,<empty>
179314,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_Settings.GlobalSettings(), StartOnUserLogin)",9,<empty>,,42,2,CPPASTProblemStatement,,<empty>
179357,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_Settings.GlobalSettings(), InitialRows)",9,<empty>,,43,2,CPPASTProblemStatement,,<empty>
179400,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_Settings.GlobalSettings(), InitialCols)",9,<empty>,,44,2,CPPASTProblemStatement,,<empty>
180192,UNKNOWN,1,,HWND,47,<empty>,,191,1,CPPASTTypeId,,<empty>
180286,UNKNOWN,1,,uint64_t,33,<empty>,,241,1,CPPASTTypeId,,<empty>
181766,UNKNOWN,-1,,"WINRT_PROPERTY(IInspectable, Tag);",9,<empty>,,21,3,CPPASTProblemDeclaration,,<empty>
181767,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Label);",9,<empty>,,22,4,CPPASTProblemDeclaration,,<empty>
181768,UNKNOWN,-1,,"WINRT_PROPERTY(BreadcrumbSubPage, SubPage);",9,<empty>,,23,5,CPPASTProblemDeclaration,,<empty>
181848,UNKNOWN,-1,,"TYPED_EVENT(OpenJson, Windows::Foundation::IInspectable, Model::SettingsTarget);",9,<empty>,,49,16,CPPASTProblemDeclaration,,<empty>
181971,UNKNOWN,1,,int,45,<empty>,,19,1,CPPASTTypeId,,<empty>
181995,UNKNOWN,1,,"DECLARE_CONVERTER(winrt::Microsoft::Terminal::Settings::Editor, PercentageSignConverter);",1,<empty>,,9,1,CPPASTProblemDeclaration,,<empty>
182143,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);",9,<empty>,,34,9,CPPASTProblemDeclaration,,<empty>
182144,UNKNOWN,-1,,"TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspectable);",9,<empty>,,35,10,CPPASTProblemDeclaration,,<empty>
182781,UNKNOWN,-1,,"void ProfileViewModel::UpdateFontList() noexcept
    try
    {
        // initialize font list
        std::vector<Editor::Font> fontList;
        std::vector<Editor::Font> monospaceFontList;

        // get the font collection; subscribe to updates
        wil::com_ptr<IDWriteFactory> factory;
        THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(factory), reinterpret_cast<::IUnknown**>(factory.addressof())));

        wil::com_ptr<IDWriteFontCollection> fontCollection;
        THROW_IF_FAILED(factory->GetSystemFontCollection(fontCollection.addressof(), TRUE));

        for (UINT32 i = 0; i < fontCollection->GetFontFamilyCount(); ++i)
        {
            try
            {
                // get the font family
                com_ptr<IDWriteFontFamily> fontFamily;
                THROW_IF_FAILED(fontCollection->GetFontFamily(i, fontFamily.put()));

                // construct a font entry for tracking
                if (const auto fontEntry{ _FontObje...",5,<empty>,,101,8,CPPASTProblemDeclaration,,<empty>
182790,UNKNOWN,-1,,"try
        {
            const auto& currentFontList{ CompleteFontList() };
            for (const auto& font : currentFontList)
            {
                if (font.LocalizedName() == name)
                {
                    return font;
                }
                else if (font.LocalizedName() == L""Cascadia Mono"")
                {
                    fallbackFont = font;
                }
            }
        }
        CATCH_LOG();",9,<empty>,,164,3,CPPASTProblemStatement,,<empty>
183465,UNKNOWN,-1,,"VIEW_MODEL_OBSERVABLE_PROPERTY(ProfileSubPage, CurrentPage)",9,<empty>,,78,2,CPPASTProblemStatement,,<empty>
183491,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_profile, Guid)",9,<empty>,,80,2,CPPASTProblemStatement,,<empty>
183525,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_profile, ConnectionType)",9,<empty>,,81,2,CPPASTProblemStatement,,<empty>
183559,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Name)",9,<empty>,,82,2,CPPASTProblemStatement,,<empty>
183588,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Name)",9,<empty>,,82,1,CPPASTProblemStatement,,<empty>
183622,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Source)",9,<empty>,,83,2,CPPASTProblemStatement,,<empty>
183651,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Source)",9,<empty>,,83,1,CPPASTProblemStatement,,<empty>
183685,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Hidden)",9,<empty>,,84,2,CPPASTProblemStatement,,<empty>
183714,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Hidden)",9,<empty>,,84,1,CPPASTProblemStatement,,<empty>
183748,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Icon)",9,<empty>,,85,2,CPPASTProblemStatement,,<empty>
183777,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Icon)",9,<empty>,,85,1,CPPASTProblemStatement,,<empty>
183811,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, CloseOnExit)",9,<empty>,,86,2,CPPASTProblemStatement,,<empty>
183840,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, CloseOnExit)",9,<empty>,,86,1,CPPASTProblemStatement,,<empty>
183874,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, TabTitle)",9,<empty>,,87,2,CPPASTProblemStatement,,<empty>
183903,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, TabTitle)",9,<empty>,,87,1,CPPASTProblemStatement,,<empty>
183937,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, TabColor)",9,<empty>,,88,2,CPPASTProblemStatement,,<empty>
183966,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, TabColor)",9,<empty>,,88,1,CPPASTProblemStatement,,<empty>
184000,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, SuppressApplicationTitle)",9,<empty>,,89,2,CPPASTProblemStatement,,<empty>
184029,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, SuppressApplicationTitle)",9,<empty>,,89,1,CPPASTProblemStatement,,<empty>
184063,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, ScrollState)",9,<empty>,,90,2,CPPASTProblemStatement,,<empty>
184092,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, ScrollState)",9,<empty>,,90,1,CPPASTProblemStatement,,<empty>
184126,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Padding)",9,<empty>,,91,2,CPPASTProblemStatement,,<empty>
184155,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Padding)",9,<empty>,,91,1,CPPASTProblemStatement,,<empty>
184189,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Commandline)",9,<empty>,,92,2,CPPASTProblemStatement,,<empty>
184218,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Commandline)",9,<empty>,,92,1,CPPASTProblemStatement,,<empty>
184252,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, StartingDirectory)",9,<empty>,,93,2,CPPASTProblemStatement,,<empty>
184281,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, StartingDirectory)",9,<empty>,,93,1,CPPASTProblemStatement,,<empty>
184315,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, AntialiasingMode)",9,<empty>,,94,2,CPPASTProblemStatement,,<empty>
184344,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, AntialiasingMode)",9,<empty>,,94,1,CPPASTProblemStatement,,<empty>
184384,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Foreground)",9,<empty>,,95,2,CPPASTProblemStatement,,<empty>
184422,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Foreground)",9,<empty>,,95,1,CPPASTProblemStatement,,<empty>
184465,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Background)",9,<empty>,,96,2,CPPASTProblemStatement,,<empty>
184503,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Background)",9,<empty>,,96,1,CPPASTProblemStatement,,<empty>
184546,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), SelectionBackground)",9,<empty>,,97,2,CPPASTProblemStatement,,<empty>
184584,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), SelectionBackground)",9,<empty>,,97,1,CPPASTProblemStatement,,<empty>
184627,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), CursorColor)",9,<empty>,,98,2,CPPASTProblemStatement,,<empty>
184665,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), CursorColor)",9,<empty>,,98,1,CPPASTProblemStatement,,<empty>
184708,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Opacity)",9,<empty>,,99,2,CPPASTProblemStatement,,<empty>
184746,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), Opacity)",9,<empty>,,99,1,CPPASTProblemStatement,,<empty>
184789,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), UseAcrylic)",9,<empty>,,100,2,CPPASTProblemStatement,,<empty>
184827,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile.DefaultAppearance(), UseAcrylic)",9,<empty>,,100,1,CPPASTProblemStatement,,<empty>
184864,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, HistorySize)",9,<empty>,,101,2,CPPASTProblemStatement,,<empty>
184893,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, HistorySize)",9,<empty>,,101,1,CPPASTProblemStatement,,<empty>
184927,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, SnapOnInput)",9,<empty>,,102,2,CPPASTProblemStatement,,<empty>
184956,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, SnapOnInput)",9,<empty>,,102,1,CPPASTProblemStatement,,<empty>
184990,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, AltGrAliasing)",9,<empty>,,103,2,CPPASTProblemStatement,,<empty>
185019,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, AltGrAliasing)",9,<empty>,,103,1,CPPASTProblemStatement,,<empty>
185053,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, BellStyle)",9,<empty>,,104,2,CPPASTProblemStatement,,<empty>
185082,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, BellStyle)",9,<empty>,,104,1,CPPASTProblemStatement,,<empty>
185116,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, UseAtlasEngine)",9,<empty>,,105,2,CPPASTProblemStatement,,<empty>
185145,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, UseAtlasEngine)",9,<empty>,,105,1,CPPASTProblemStatement,,<empty>
185179,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Elevate)",9,<empty>,,106,2,CPPASTProblemStatement,,<empty>
185208,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, Elevate)",9,<empty>,,106,1,CPPASTProblemStatement,,<empty>
185242,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, VtPassthrough)",9,<empty>,,107,2,CPPASTProblemStatement,,<empty>
185271,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, VtPassthrough)",9,<empty>,,107,1,CPPASTProblemStatement,,<empty>
185305,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, ReloadEnvironmentVariables)",9,<empty>,,108,2,CPPASTProblemStatement,,<empty>
185334,UNKNOWN,-1,,"OBSERVABLE_PROJECTED_SETTING(_profile, ReloadEnvironmentVariables)",9,<empty>,,108,1,CPPASTProblemStatement,,<empty>
185346,UNKNOWN,-1,,"WINRT_PROPERTY(bool, IsBaseLayer, false);",9,<empty>,,110,172,CPPASTProblemDeclaration,,<empty>
185347,UNKNOWN,-1,,"WINRT_PROPERTY(bool, FocusDeleteButton, false);",9,<empty>,,111,173,CPPASTProblemDeclaration,,<empty>
185560,UNKNOWN,-1,,"TYPED_EVENT(DeleteProfile, Editor::ProfileViewModel, Editor::DeleteProfileEventArgs);",9,<empty>,,116,189,CPPASTProblemDeclaration,,<empty>
185689,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,20,4,CPPASTProblemDeclaration,,<empty>
185690,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);",9,<empty>,,21,5,CPPASTProblemDeclaration,,<empty>
186011,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,25,7,CPPASTProblemDeclaration,,<empty>
186012,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);",9,<empty>,,26,8,CPPASTProblemDeclaration,,<empty>
186097,UNKNOWN,-1,,"try
            {
                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };
                dialog->SetDefaultFolder(folderShellItem.get());
            }
            CATCH_LOG();",13,<empty>,,93,2,CPPASTProblemStatement,,<empty>
186148,UNKNOWN,-1,,"try
            {
                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };
                dialog->SetDefaultFolder(folderShellItem.get());
            }
            CATCH_LOG();",13,<empty>,,129,4,CPPASTProblemStatement,,<empty>
186377,UNKNOWN,1,,HWND,49,<empty>,,90,1,CPPASTTypeId,,<empty>
186386,UNKNOWN,-1,,t,28,<empty>,,91,11,CPPASTProblemStatement,,<empty>
186417,UNKNOWN,1,,HWND,49,<empty>,,114,1,CPPASTTypeId,,<empty>
186426,UNKNOWN,-1,,t,28,<empty>,,115,7,CPPASTProblemStatement,,<empty>
186456,UNKNOWN,1,,HWND,49,<empty>,,125,1,CPPASTTypeId,,<empty>
186465,UNKNOWN,-1,,t,30,<empty>,,126,7,CPPASTProblemStatement,,<empty>
186551,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,27,10,CPPASTProblemDeclaration,,<empty>
186552,UNKNOWN,-1,,"WINRT_PROPERTY(Editor::ProfileViewModel, Profile, nullptr);",9,<empty>,,28,11,CPPASTProblemDeclaration,,<empty>
186624,UNKNOWN,-1,,"WINRT_CALLBACK(PropertyChanged, Windows::UI::Xaml::Data::PropertyChangedEventHandler);",9,<empty>,,17,3,CPPASTProblemDeclaration,,<empty>
186625,UNKNOWN,-1,,"WINRT_OBSERVABLE_PROPERTY(Editor::RenderingViewModel, ViewModel, _PropertyChangedHandlers, nullptr);",9,<empty>,,18,4,CPPASTProblemDeclaration,,<empty>
186704,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.ProfileDefaults(), UseAtlasEngine)",9,<empty>,,15,2,CPPASTProblemStatement,,<empty>
186747,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), ForceFullRepaintRendering)",9,<empty>,,16,2,CPPASTProblemStatement,,<empty>
186790,UNKNOWN,-1,,"PERMANENT_OBSERVABLE_PROJECTED_SETTING(_settings.GlobalSettings(), SoftwareRendering)",9,<empty>,,17,2,CPPASTProblemStatement,,<empty>
187709,UNKNOWN,-1,,"TYPED_EVENT(ClearSettingValue, Editor::SettingContainer, Windows::Foundation::IInspectable);",9,<empty>,,38,27,CPPASTProblemDeclaration,,<empty>
187747,UNKNOWN,1,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""Microsoft.Terminal.Settings.Editor/Resources"");",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
187927,UNKNOWN,1,,T*,47,<empty>,,23,1,CPPASTTypeId,,<empty>
190688,UNKNOWN,1,,std::string,36,<empty>,,294,1,CPPASTTypeId,,<empty>
190699,UNKNOWN,1,,std::string,36,<empty>,,301,1,CPPASTTypeId,,<empty>
190757,UNKNOWN,1,,std::string,36,<empty>,,321,1,CPPASTTypeId,,<empty>
190760,UNKNOWN,1,,std::string,75,<empty>,,321,1,CPPASTTypeId,,<empty>
190768,UNKNOWN,1,,std::string,28,<empty>,,328,1,CPPASTTypeId,,<empty>
191045,UNKNOWN,-1,,"WINRT_PROPERTY(ShortcutAction, Action, ShortcutAction::Invalid);",9,<empty>,,31,11,CPPASTProblemDeclaration,,<empty>
191046,UNKNOWN,-1,,"WINRT_PROPERTY(IActionArgs, Args, nullptr);",9,<empty>,,32,12,CPPASTProblemDeclaration,,<empty>
191625,UNKNOWN,1,,CopyFormat,62,<empty>,,213,1,CPPASTTypeId,,<empty>
192820,UNKNOWN,1,,SuggestionsSource,40,<empty>,,727,1,CPPASTTypeId,,<empty>
193050,UNKNOWN,-1,,"try
        {
            return winrt::hstring{
                fmt::format(std::wstring_view(RS_(L""SearchForTextCommandKey"")),
                            Windows::Foundation::Uri(QueryUrl()).Domain().c_str())
            };
        }
        CATCH_LOG();",9,<empty>,,824,2,CPPASTProblemStatement,,<empty>
193737,UNKNOWN,-1,,"WINRT_PROPERTY(IActionArgs, ActionArgs, nullptr);",9,<empty>,,294,3,CPPASTProblemDeclaration,,<empty>
193738,UNKNOWN,-1,,"WINRT_PROPERTY(bool, Handled, false);",9,<empty>,,295,4,CPPASTProblemDeclaration,,<empty>
194743,UNKNOWN,-1,,"WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);",9,<empty>,,473,3,CPPASTProblemDeclaration,,<empty>
194928,UNKNOWN,-1,,"WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);",9,<empty>,,542,9,CPPASTProblemDeclaration,,<empty>
195287,UNKNOWN,-1,,"WINRT_PROPERTY(Model::NewTerminalArgs, TerminalArgs, nullptr);",9,<empty>,,626,3,CPPASTProblemDeclaration,,<empty>
202608,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IVector<ActionAndArgs>, Actions);",9,<empty>,,767,2,CPPASTProblemDeclaration,,<empty>
207478,UNKNOWN,1,,size_t,32,<empty>,,38,1,CPPASTTypeId,,<empty>
211365,UNKNOWN,-1,,"void ApplicationState::Reset() noexcept
    try
    {
        LOG_LAST_ERROR_IF(!DeleteFile(_sharedPath.c_str()));
        LOG_LAST_ERROR_IF(!DeleteFile(_elevatedPath.c_str()));
        *_state.lock() = {};
    }
    CATCH_LOG()

    // Deserializes the state.json and user-state (or elevated-state if
    // elevated) into this ApplicationState.
    // * ANY errors during app state will result in the creation of a new empty state.
    // * ANY errors during runtime will result in changes being partially ignored.
    void ApplicationState::_read() const noexcept
    try
    {
        std::string errs;
        std::unique_ptr<Json::CharReader> reader{ Json::CharReaderBuilder{}.newCharReader() };

        // First get shared state out of `state.json`.
        const auto sharedData = _readSharedContents().value_or(std::string{});
        if (!sharedData.empty())
        {
            Json::Value root;
            if (!reader->parse(sharedData.data(), sharedData.data() + sharedData.size()...",5,<empty>,,147,7,CPPASTProblemDeclaration,,<empty>
211366,UNKNOWN,-1,,"CATCH_LOG()

    // Serialized this ApplicationState (in `context`) into the state.json at _path.
    // * Errors are only logged.
    // * _state->_writeScheduled is set to false, signaling our
    //   setters that _synchronize() needs to be called again.
    void ApplicationState::_write() const noexcept
    try
    {
        Json::StreamWriterBuilder wbuilder;

        // When we're elevated, we've got to be tricky. We don't want to write
        // our window state, allowed commandlines, and other Local properties
        // into the shared `state.json`. But, if we only serialize the Shared
        // properties to a json blob, then we'll omit windowState entirely,
        // _removing_ the window state of the unelevated instance. Oh no!
        //
        // So, to be tricky, we'll first _load_ the shared state to a json blob.
        // We'll then serialize our view of the shared properties on top of that
        // blob. Then we'll write that blob back to the file. This will...",5,<empty>,,203,8,CPPASTProblemDeclaration,,<empty>
211367,UNKNOWN,-1,,"CATCH_LOG()

    // Returns the application-global ApplicationState object.
    Microsoft::Terminal::Settings::Model::ApplicationState ApplicationState::SharedInstance()
    {
        auto root{ GetBaseSettingsPath() };
        static auto state = winrt::make_self<ApplicationState>(root);
        return *state;
    }",5,<empty>,,258,9,CPPASTProblemDeclaration,,<empty>
212054,UNKNOWN,-1,,"WINRT_PROPERTY(Windows::Foundation::Collections::IVector<Model::ActionAndArgs>, TabLayout, nullptr);",9,<empty>,,50,3,CPPASTProblemDeclaration,,<empty>
212055,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::IReference<Model::LaunchPosition>, InitialPosition, nullptr);",9,<empty>,,51,4,CPPASTProblemDeclaration,,<empty>
212056,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Size>, InitialSize, nullptr);",9,<empty>,,52,5,CPPASTProblemDeclaration,,<empty>
212057,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::IReference<Model::LaunchMode>, LaunchMode, nullptr);",9,<empty>,,53,6,CPPASTProblemDeclaration,,<empty>
212223,UNKNOWN,-1,,),31,<empty>,,108,2,CPPASTProblemDeclaration,,<empty>
212414,UNKNOWN,-1,,"try
            {
                _commandLinesCache.emplace_back(NormalizeCommandLine(cmd.c_str()), profile);
            }
            CATCH_LOG()",13,<empty>,,663,5,CPPASTProblemStatement,,<empty>
212466,UNKNOWN,1,,bool,28,<empty>,,1123,1,CPPASTTypeId,,<empty>
214901,UNKNOWN,1,,std::wstring&,51,<empty>,,793,1,CPPASTTypeId,,<empty>
215387,UNKNOWN,-1,,"try
    {
        const auto package{ winrt::Windows::ApplicationModel::Package::Current() };
        return package.DisplayName();
    }
    CATCH_LOG();",5,<empty>,,1028,1,CPPASTProblemStatement,,<empty>
215399,UNKNOWN,-1,,"try
    {
        const auto package{ winrt::Windows::ApplicationModel::Package::Current() };
        const auto version{ package.Id().Version() };
        winrt::hstring formatted{ wil::str_printf<std::wstring>(L""%u.%u.%u.%u"", version.Major, version.Minor, version.Build, version.Revision) };
        return formatted;
    }
    CATCH_LOG();",5,<empty>,,1040,1,CPPASTProblemStatement,,<empty>
215400,UNKNOWN,-1,,"try
    {
        struct LocalizationInfo
        {
            WORD language, codepage;
        };
        // Use the current module instance handle for TerminalApp.dll, nullptr for WindowsTerminal.exe
        auto filename{ wil::GetModuleFileNameW<std::wstring>(wil::GetModuleInstanceHandle()) };
        auto size{ GetFileVersionInfoSizeExW(0, filename.c_str(), nullptr) };
        THROW_LAST_ERROR_IF(size == 0);
        auto versionBuffer{ std::make_unique<std::byte[]>(size) };
        THROW_IF_WIN32_BOOL_FALSE(GetFileVersionInfoExW(0, filename.c_str(), 0, size, versionBuffer.get()));

        // Get the list of Version localizations
        LocalizationInfo* pVarLocalization{ nullptr };
        UINT varLen{ 0 };
        THROW_IF_WIN32_BOOL_FALSE(VerQueryValueW(versionBuffer.get(), L""\\VarFileInfo\\Translation"", reinterpret_cast<void**>(&pVarLocalization), &varLen));
        THROW_HR_IF(E_UNEXPECTED, varLen < sizeof(*pVarLocalization)); // there must be at least one translation

  ...",5,<empty>,,1055,2,CPPASTProblemStatement,,<empty>
215541,UNKNOWN,-1,,"try
    {
        WriteUTF8FileAtomic({ path.c_str() }, til::u16u8(content));
    }
    CATCH_LOG();",5,<empty>,,1201,1,CPPASTProblemStatement,,<empty>
216214,UNKNOWN,-1,,finalVal.emplace(co_await task);,9,<empty>,,92,4,CPPASTProblemStatement,,<empty>
216239,UNKNOWN,-1,,"try
                {
                    const auto content = ReadUTF8File(fragmentExt.path());
                    _parseFragment(source, content, fragmentSettings);
                }
                CATCH_LOG();",17,<empty>,,237,1,CPPASTProblemStatement,,<empty>
216808,UNKNOWN,-1,,"try
    {
        const auto catalog = AppExtensionCatalog::Open(AppExtensionHostName);
        extensions = extractValueFromTaskWithoutMainThreadAwait(catalog.FindAllAsync());
    }
    CATCH_LOG();",5,<empty>,,281,6,CPPASTProblemStatement,,<empty>
217631,UNKNOWN,-1,,"try
            {
                if (const auto scheme = ColorScheme::FromJson(schemeJson))
                {
                    settings.globals->AddColorScheme(*scheme);
                }
            }
            CATCH_LOG()",13,<empty>,,641,1,CPPASTProblemStatement,,<empty>
217662,UNKNOWN,-1,,"try
            {
                auto profile = _parseProfile(OriginTag::Fragment, source, profileJson);
                // GH#9962: Discard Guid-less, Name-less profiles, but...
                // allow ones with an Updates field, as those are special for fragments.
                // We need to make sure to only call Guid() if HasGuid() is true,
                // as Guid() will dynamically generate a return value otherwise.
                const auto guid = profile->HasGuid() ? profile->Guid() : profile->Updates();
                if (guid != winrt::guid{})
                {
                    _appendProfile(std::move(profile), guid, settings);
                }
            }
            CATCH_LOG()",13,<empty>,,659,1,CPPASTProblemStatement,,<empty>
217856,UNKNOWN,1,,const winrt::com_ptr<Profile>&,59,<empty>,,739,1,CPPASTTypeId,,<empty>
217969,UNKNOWN,-1,,"try
    {
        generator.GenerateProfiles(inboxSettings.profiles);
    }
    CATCH_LOG_MSG(""Dynamic Profile Namespace: \""%.*s\"""", gsl::narrow<int>(generatorNamespace.size()), generatorNamespace.data())

    // If the generator produced some profiles we're going to give them default attributes.
    // By setting the Origin/Source/etc. here, we deduplicate some code and ensure they aren't missing accidentally.
    if (inboxSettings.profiles.size() > previousSize)
    {
        const winrt::hstring source{ generatorNamespace };

        for (const auto& profile : std::span(inboxSettings.profiles).subspan(previousSize))
        {
            profile->Origin(OriginTag::Generated);
            profile->Source(source);
        }
    }",5,<empty>,,806,6,CPPASTProblemStatement,,<empty>
219940,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Name);",9,<empty>,,54,12,CPPASTProblemDeclaration,,<empty>
219941,UNKNOWN,-1,,"WINRT_PROPERTY(Core::Color, Foreground, static_cast<Core::Color>(DEFAULT_FOREGROUND));",9,<empty>,,55,13,CPPASTProblemDeclaration,,<empty>
219942,UNKNOWN,-1,,"WINRT_PROPERTY(Core::Color, Background, static_cast<Core::Color>(DEFAULT_BACKGROUND));",9,<empty>,,56,14,CPPASTProblemDeclaration,,<empty>
219943,UNKNOWN,-1,,"WINRT_PROPERTY(Core::Color, SelectionBackground, static_cast<Core::Color>(DEFAULT_FOREGROUND));",9,<empty>,,57,15,CPPASTProblemDeclaration,,<empty>
219944,UNKNOWN,-1,,"WINRT_PROPERTY(Core::Color, CursorColor, static_cast<Core::Color>(DEFAULT_CURSOR_COLOR));",9,<empty>,,58,16,CPPASTProblemDeclaration,,<empty>
220096,UNKNOWN,1,,std::wstring_view,57,<empty>,,674,1,CPPASTTypeId,,<empty>
220976,UNKNOWN,-1,,"try
                {
                    const auto result = Command::FromJson(value, warnings);
                    if (result->ActionAndArgs().Action() == ShortcutAction::Invalid && !result->HasNestedCommands())
                    {
                        // If there wasn't a parsed command, then try to get the
                        // name from the json blob. If that name currently
                        // exists in our list of commands, we should remove it.
                        const auto name = _nameFromJson(value);
                        if (name.has_value() && !name->empty())
                        {
                            commands.Remove(*name);
                        }
                    }
                    else
                    {
                        // Override commands with the same name
                        commands.Insert(result->Name(), *result);
                    }
                }
                CATCH_LOG();",17,<empty>,,369,1,CPPASTProblemStatement,,<empty>
221865,UNKNOWN,-1,,"WINRT_PROPERTY(ExpandCommandType, IterateOn, ExpandCommandType::None);",9,<empty>,,75,23,CPPASTProblemDeclaration,,<empty>
221866,UNKNOWN,-1,,"WINRT_PROPERTY(Model::ActionAndArgs, ActionAndArgs);",9,<empty>,,76,24,CPPASTProblemDeclaration,,<empty>
223635,UNKNOWN,1,,size_t,44,<empty>,,177,1,CPPASTTypeId,,<empty>
224330,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Name);",9,<empty>,,42,7,CPPASTProblemDeclaration,,<empty>
224331,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Icon);",9,<empty>,,43,8,CPPASTProblemDeclaration,,<empty>
224332,UNKNOWN,-1,,"WINRT_PROPERTY(FolderEntryInlining, Inlining, FolderEntryInlining::Never);",9,<empty>,,44,9,CPPASTProblemDeclaration,,<empty>
224333,UNKNOWN,-1,,"WINRT_PROPERTY(bool, AllowEmpty, false);",9,<empty>,,45,10,CPPASTProblemDeclaration,,<empty>
233193,UNKNOWN,-1,,MTSM_GLOBAL_SETTINGS(GLOBAL_SETTINGS_INITIALIZE),9,<empty>,,76,2,CPPASTProblemStatement,,<empty>
233963,UNKNOWN,1,,const uint8_t*,38,<empty>,,41,1,CPPASTTypeId,,<empty>
234032,UNKNOWN,1,,T*,53,<empty>,,37,1,CPPASTTypeId,,<empty>
234034,UNKNOWN,1,,const T*,69,<empty>,,37,1,CPPASTTypeId,,<empty>
234168,UNKNOWN,-1,,"try
            {
                winrt::Windows::Foundation::Uri iconUri{ path };
                typename BitmapIconSource<TIconSource>::type iconSource;
                // Make sure to set this to false, so we keep the RGB data of the
                // image. Otherwise, the icon will be white for all the
                // non-transparent pixels in the image.
                iconSource.ShowAsMonochrome(monochrome);
                iconSource.UriSource(iconUri);
                return iconSource;
            }
            CATCH_LOG();",13,<empty>,,81,1,CPPASTProblemStatement,,<empty>
234243,UNKNOWN,-1,,"try
                {
                    typename FontIconSource<TIconSource>::type icon;
                    const auto ch = iconPath[0];

                    // The range of MDL2 Icons isn't explicitly defined, but
                    // we're using this based off the table on:
                    // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
                    const auto isMDL2Icon = ch >= L'\uE700' && ch <= L'\uF8FF';
                    if (isMDL2Icon)
                    {
                        icon.FontFamily(winrt::Windows::UI::Xaml::Media::FontFamily{ L""Segoe Fluent Icons, Segoe MDL2 Assets"" });
                    }
                    else
                    {
                        // Note: you _do_ need to manually set the font here.
                        icon.FontFamily(winrt::Windows::UI::Xaml::Media::FontFamily{ L""Segoe UI"" });
                    }
                    icon.FontSize(12);
                    icon.Glyph(iconP...",17,<empty>,,140,1,CPPASTProblemStatement,,<empty>
234547,UNKNOWN,1,,int,32,<empty>,,305,1,CPPASTTypeId,,<empty>
234806,UNKNOWN,1,,std::string,24,<empty>,,45,1,CPPASTTypeId,,<empty>
234924,UNKNOWN,1,,bool,115,<empty>,,100,1,CPPASTTypeId,,<empty>
235423,UNKNOWN,1,,winrt::guid,32,<empty>,,338,1,CPPASTTypeId,,<empty>
236239,UNKNOWN,1,,const TBase&,42,<empty>,,957,1,CPPASTTypeId,,<empty>
236410,UNKNOWN,1,,const TBase&,54,<empty>,,1023,1,CPPASTTypeId,,<empty>
236540,UNKNOWN,1,,T,48,<empty>,,1001,1,CPPASTTypeId,,<empty>
236547,UNKNOWN,1,,T,50,<empty>,,1002,1,CPPASTTypeId,,<empty>
236722,UNKNOWN,-1,,p,36,<empty>,,132,4,CPPASTProblemStatement,,<empty>
237198,UNKNOWN,1,,int32_t,40,<empty>,,187,1,CPPASTTypeId,,<empty>
237311,UNKNOWN,-1,,p,36,<empty>,,248,3,CPPASTProblemStatement,,<empty>
238193,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Name);",9,<empty>,,33,5,CPPASTProblemDeclaration,,<empty>
238194,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Commandline);",9,<empty>,,34,6,CPPASTProblemDeclaration,,<empty>
238195,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Source);",9,<empty>,,35,7,CPPASTProblemDeclaration,,<empty>
238254,UNKNOWN,1,,_TIL_INLINEPREFIX,1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
238493,UNKNOWN,-1,,"WINRT_PROPERTY(NewTabMenuEntryType, Type, NewTabMenuEntryType::Invalid);",9,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
240736,UNKNOWN,-1,,"WINRT_PROPERTY(bool, Deleted, false);",9,<empty>,,108,16,CPPASTProblemDeclaration,,<empty>
240737,UNKNOWN,-1,,"WINRT_PROPERTY(OriginTag, Origin, OriginTag::None);",9,<empty>,,109,17,CPPASTProblemDeclaration,,<empty>
240738,UNKNOWN,-1,,"WINRT_PROPERTY(guid, Updates);",9,<empty>,,110,18,CPPASTProblemDeclaration,,<empty>
244843,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Windows::Foundation::Collections::IMap<int COMMA Model::Profile>, Profiles);",9,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
244978,UNKNOWN,-1,,"WINRT_PROPERTY(Model::Profile, Profile);",9,<empty>,,42,6,CPPASTProblemDeclaration,,<empty>
244979,UNKNOWN,-1,,"WINRT_PROPERTY(int, ProfileIndex);",9,<empty>,,43,7,CPPASTProblemDeclaration,,<empty>
245228,UNKNOWN,-1,,"try
    {
        for (const auto& path : { SSH_EXE_PATH1, SSH_EXE_PATH2, SSH_EXE_PATH3 })
        {
            if (std::filesystem::exists(wil::ExpandEnvironmentStringsW<std::wstring>(path.data())))
            {
                sshExePath = path;
                return true;
            }
        }
    }
    CATCH_LOG();",5,<empty>,,53,1,CPPASTProblemStatement,,<empty>
245238,UNKNOWN,-1,,"try
    {
        if (!line.empty() && !line.starts_with(L""#""))
        {
            std::wstring input{ line };
            std::wsmatch match;
            if (std::regex_search(input, match, SshHostGenerator::_configKeyValueRegex))
            {
                key = match[1];
                value = match[2];
                return true;
            }
        }
    }
    CATCH_LOG();",5,<empty>,,71,1,CPPASTProblemStatement,,<empty>
245247,UNKNOWN,-1,,"try
    {
        const std::filesystem::path resolvedConfigPath{ wil::ExpandEnvironmentStringsW<std::wstring>(configPath.data()) };
        if (std::filesystem::exists(resolvedConfigPath))
        {
            std::wifstream inputStream(resolvedConfigPath);

            std::wstring line;
            std::wstring key;
            std::wstring value;

            std::wstring lastHost;

            while (std::getline(inputStream, line))
            {
                if (_tryParseConfigKeyValue(line, key, value))
                {
                    if (til::equals_insensitive_ascii(key, SSH_CONFIG_HOST_KEY))
                    {
                        // Save potential Host value for later
                        lastHost = value;
                    }
                    else if (til::equals_insensitive_ascii(key, SSH_CONFIG_HOSTNAME_KEY))
                    {
                        // HostName was specified
                        if (!lastHost.empty())
                    ...",5,<empty>,,92,1,CPPASTProblemStatement,,<empty>
245375,UNKNOWN,1,,winrt::Microsoft::Terminal::Core::Color,36,<empty>,,400,1,CPPASTTypeId,,<empty>
245388,UNKNOWN,1,,winrt::Microsoft::Terminal::Core::Color,36,<empty>,,428,1,CPPASTTypeId,,<empty>
245422,UNKNOWN,1,,ConvergedAlignment,41,<empty>,,20,1,CPPASTTypeId,,<empty>
245479,UNKNOWN,1,,ConvergedAlignment,41,<empty>,,36,1,CPPASTTypeId,,<empty>
245875,UNKNOWN,1,,winrt::Microsoft::Terminal::Core::Color,143,<empty>,,166,1,CPPASTTypeId,,<empty>
246487,UNKNOWN,1,,winrt::Microsoft::Terminal::Core::Color,37,<empty>,,318,1,CPPASTTypeId,,<empty>
255260,UNKNOWN,1,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Core::CursorStyle)
{
    static constexpr std::array<pair_type, 6> mappings = {
        pair_type{ ""bar"", ValueType::Bar },
        pair_type{ ""vintage"", ValueType::Vintage },
        pair_type{ ""underscore"", ValueType::Underscore },
        pair_type{ ""doubleUnderscore"", ValueType::DoubleUnderscore },
        pair_type{ ""filledBox"", ValueType::FilledBox },
        pair_type{ ""emptyBox"", ValueType::EmptyBox }
    };
};",1,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
255261,UNKNOWN,2,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Core::AdjustTextMode)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""never"", ValueType::Never },
        pair_type{ ""indexed"", ValueType::Indexed },
        pair_type{ ""always"", ValueType::Always },
    };

    // Override mapping parser to add boolean parsing
    ::winrt::Microsoft::Terminal::Core::AdjustTextMode FromJson(const Json::Value& json)
    {
        if (json.isBool())
        {
            return json.asBool() ? ValueType::Indexed : ValueType::Never;
        }
        return EnumMapper::FromJson(json);
    }

    bool CanConvert(const Json::Value& json)
    {
        return EnumMapper::CanConvert(json) || json.isBool();
    }

    using EnumMapper::TypeDescription;
};",1,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
255262,UNKNOWN,3,,"JSON_ENUM_MAPPER(::winrt::Windows::UI::Xaml::Media::Stretch)
{
    static constexpr std::array<pair_type, 4> mappings = {
        pair_type{ ""uniformToFill"", ValueType::UniformToFill },
        pair_type{ ""none"", ValueType::None },
        pair_type{ ""fill"", ValueType::Fill },
        pair_type{ ""uniform"", ValueType::Uniform }
    };
};",1,<empty>,,62,3,CPPASTProblemDeclaration,,<empty>
255263,UNKNOWN,4,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Control::ScrollbarState)
{
    static constexpr std::array<pair_type, 3> mappings = {
        pair_type{ ""visible"", ValueType::Visible },
        pair_type{ ""hidden"", ValueType::Hidden },
        pair_type{ ""always"", ValueType::Always }
    };
};",1,<empty>,,72,4,CPPASTProblemDeclaration,,<empty>
255264,UNKNOWN,5,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Core::MatchMode)
{
    static constexpr std::array<pair_type, 2> mappings = {
        pair_type{ ""none"", ValueType::None },
        pair_type{ ""all"", ValueType::All }
    };
};",1,<empty>,,81,5,CPPASTProblemDeclaration,,<empty>
255265,UNKNOWN,6,,"JSON_FLAG_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::BellStyle)
{
    static constexpr std::array<pair_type, 6> mappings = {
        pair_type{ ""none"", AllClear },
        pair_type{ ""audible"", ValueType::Audible },
        pair_type{ ""visual"", ValueType::Window | ValueType::Taskbar },
        pair_type{ ""window"", ValueType::Window },
        pair_type{ ""taskbar"", ValueType::Taskbar },
        pair_type{ ""all"", AllSet },
    };

    auto FromJson(const Json::Value& json)
    {
        if (json.isBool())
        {
            return json.asBool() ? AllSet : AllClear;
        }
        return BaseFlagMapper::FromJson(json);
    }

    bool CanConvert(const Json::Value& json)
    {
        return BaseFlagMapper::CanConvert(json) || json.isBool();
    }

    Json::Value ToJson(const ::winrt::Microsoft::Terminal::Settings::Model::BellStyle& bellStyle)
    {
        return BaseFlagMapper::ToJson(bellStyle);
    }
};",1,<empty>,,89,6,CPPASTProblemDeclaration,,<empty>
255266,UNKNOWN,7,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::ConvergedAlignment)
{
    // reduce repetition
    static constexpr std::array<pair_type, 9> mappings = {
        pair_type{ ""center"", ValueType::Horizontal_Center | ValueType::Vertical_Center },
        pair_type{ ""topLeft"", ValueType::Horizontal_Left | ValueType::Vertical_Top },
        pair_type{ ""bottomLeft"", ValueType::Horizontal_Left | ValueType::Vertical_Bottom },
        pair_type{ ""left"", ValueType::Horizontal_Left | ValueType::Vertical_Center },
        pair_type{ ""topRight"", ValueType::Horizontal_Right | ValueType::Vertical_Top },
        pair_type{ ""bottomRight"", ValueType::Horizontal_Right | ValueType::Vertical_Bottom },
        pair_type{ ""right"", ValueType::Horizontal_Right | ValueType::Vertical_Center },
        pair_type{ ""top"", ValueType::Horizontal_Center | ValueType::Vertical_Top },
        pair_type{ ""bottom"", ValueType::Horizontal_Center | ValueType::Vertical_Bottom }
    };
};",1,<empty>,,120,7,CPPASTProblemDeclaration,,<empty>
255267,UNKNOWN,8,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Control::TextAntialiasingMode)
{
    static constexpr std::array<pair_type, 3> mappings = {
        pair_type{ ""grayscale"", ValueType::Grayscale },
        pair_type{ ""cleartype"", ValueType::Cleartype },
        pair_type{ ""aliased"", ValueType::Aliased }
    };
};",1,<empty>,,136,8,CPPASTProblemDeclaration,,<empty>
255268,UNKNOWN,9,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::CloseOnExitMode)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""always"", ValueType::Always },
        pair_type{ ""graceful"", ValueType::Graceful },
        pair_type{ ""never"", ValueType::Never },
        pair_type{ ""automatic"", ValueType::Automatic },
    };

    // Override mapping parser to add boolean parsing
    ::winrt::Microsoft::Terminal::Settings::Model::CloseOnExitMode FromJson(const Json::Value& json)
    {
        if (json.isBool())
        {
            return json.asBool() ? ValueType::Graceful : ValueType::Never;
        }
        return EnumMapper::FromJson(json);
    }

    bool CanConvert(const Json::Value& json)
    {
        return EnumMapper::CanConvert(json) || json.isBool();
    }

    using EnumMapper::TypeDescription;
};",1,<empty>,,147,9,CPPASTProblemDeclaration,,<empty>
255269,UNKNOWN,10,,"template<>
struct ::Microsoft::Terminal::Settings::Model::JsonUtils::ConversionTrait<::winrt::Windows::UI::Text::FontWeight> :
    public ::Microsoft::Terminal::Settings::Model::JsonUtils::EnumMapper<
        uint16_t,
        ::Microsoft::Terminal::Settings::Model::JsonUtils::ConversionTrait<::winrt::Windows::UI::Text::FontWeight>>
{
    // The original parser used the font weight getters Bold(), Normal(), etc.
    // They were both cumbersome and *not constant expressions*
    JSON_MAPPINGS(11) = {
        pair_type{ ""thin"", static_cast<uint16_t>(100u) },
        pair_type{ ""extra-light"", static_cast<uint16_t>(200u) },
        pair_type{ ""light"", static_cast<uint16_t>(300u) },
        pair_type{ ""semi-light"", static_cast<uint16_t>(350u) },
        pair_type{ ""normal"", static_cast<uint16_t>(400u) },
        pair_type{ ""medium"", static_cast<uint16_t>(500u) },
        pair_type{ ""semi-bold"", static_cast<uint16_t>(600u) },
        pair_type{ ""bold"", static_cast<uint16_t>(700u) },
    ...",1,<empty>,,177,10,CPPASTProblemDeclaration,,<empty>
255270,UNKNOWN,11,,"JSON_ENUM_MAPPER(::winrt::Windows::UI::Xaml::ElementTheme)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""system"", ValueType::Default },
        pair_type{ ""light"", ValueType::Light },
        pair_type{ ""dark"", ValueType::Dark },
    };
};",1,<empty>,,242,11,CPPASTProblemDeclaration,,<empty>
255271,UNKNOWN,12,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::NewTabPosition)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""afterLastTab"", ValueType::AfterLastTab },
        pair_type{ ""afterCurrentTab"", ValueType::AfterCurrentTab },
    };
};",1,<empty>,,251,12,CPPASTProblemDeclaration,,<empty>
255272,UNKNOWN,13,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::FirstWindowPreference)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""defaultProfile"", ValueType::DefaultProfile },
        pair_type{ ""persistedWindowLayout"", ValueType::PersistedWindowLayout },
    };
};",1,<empty>,,259,13,CPPASTProblemDeclaration,,<empty>
255273,UNKNOWN,14,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::LaunchMode)
{
    JSON_MAPPINGS(8) = {
        pair_type{ ""default"", ValueType::DefaultMode },
        pair_type{ ""maximized"", ValueType::MaximizedMode },
        pair_type{ ""fullscreen"", ValueType::FullscreenMode },
        pair_type{ ""maximizedFullscreen"", ValueType::MaximizedMode | ValueType::FullscreenMode },
        pair_type{ ""focus"", ValueType::FocusMode },
        pair_type{ ""maximizedFocus"", ValueType::MaximizedFocusMode },
        pair_type{ ""fullscreenFocus"", ValueType::FullscreenMode | ValueType::FocusMode },
        pair_type{ ""maximizedFullscreenFocus"", ValueType::MaximizedMode | ValueType::FullscreenMode | ValueType::FocusMode },
    };
};",1,<empty>,,267,14,CPPASTProblemDeclaration,,<empty>
255274,UNKNOWN,15,,"JSON_ENUM_MAPPER(::winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""equal"", ValueType::Equal },
        pair_type{ ""titleLength"", ValueType::SizeToContent },
        pair_type{ ""compact"", ValueType::Compact },
    };
};",1,<empty>,,281,15,CPPASTProblemDeclaration,,<empty>
255275,UNKNOWN,16,,"JSON_ENUM_MAPPER(winrt::Microsoft::Terminal::Settings::Model::ExpandCommandType)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""profiles"", ValueType::Profiles },
        pair_type{ ""schemes"", ValueType::ColorSchemes },
    };
};",1,<empty>,,290,16,CPPASTProblemDeclaration,,<empty>
255276,UNKNOWN,17,,"JSON_FLAG_MAPPER(::winrt::Microsoft::Terminal::Control::CopyFormat)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""none"", AllClear },
        pair_type{ ""html"", ValueType::HTML },
        pair_type{ ""rtf"", ValueType::RTF },
        pair_type{ ""all"", AllSet },
    };

    auto FromJson(const Json::Value& json)
    {
        if (json.isBool())
        {
            return json.asBool() ? AllSet : AllClear;
        }
        return BaseFlagMapper::FromJson(json);
    }

    bool CanConvert(const Json::Value& json)
    {
        return BaseFlagMapper::CanConvert(json) || json.isBool();
    }
};",1,<empty>,,298,17,CPPASTProblemDeclaration,,<empty>
255277,UNKNOWN,18,,"template<>
struct ::Microsoft::Terminal::Settings::Model::JsonUtils::ConversionTrait<::winrt::Microsoft::Terminal::Settings::Model::LaunchPosition>
{
    ::winrt::Microsoft::Terminal::Settings::Model::LaunchPosition FromJson(const Json::Value& json)
    {
        return LaunchPositionFromString(json.asString());
    }

    bool CanConvert(const Json::Value& json)
    {
        return json.isString();
    }

    Json::Value ToJson(const ::winrt::Microsoft::Terminal::Settings::Model::LaunchPosition& val)
    {
        std::stringstream ss;
        if (val.X)
        {
            ss << val.X.Value();
        }
        ss << "","";
        if (val.Y)
        {
            ss << val.Y.Value();
        }
        return ss.str();
    }

    std::string TypeDescription() const
    {
        return ""x, y"";
    }
};",1,<empty>,,322,18,CPPASTProblemDeclaration,,<empty>
255355,UNKNOWN,20,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::FocusDirection)
{
    JSON_MAPPINGS(10) = {
        pair_type{ ""left"", ValueType::Left },
        pair_type{ ""right"", ValueType::Right },
        pair_type{ ""up"", ValueType::Up },
        pair_type{ ""down"", ValueType::Down },
        pair_type{ ""previous"", ValueType::Previous },
        pair_type{ ""previousInOrder"", ValueType::PreviousInOrder },
        pair_type{ ""nextInOrder"", ValueType::NextInOrder },
        pair_type{ ""first"", ValueType::First },
        pair_type{ ""parent"", ValueType::Parent },
        pair_type{ ""child"", ValueType::Child },
    };
};",1,<empty>,,385,20,CPPASTProblemDeclaration,,<empty>
255356,UNKNOWN,21,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::ResizeDirection)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""left"", ValueType::Left },
        pair_type{ ""right"", ValueType::Right },
        pair_type{ ""up"", ValueType::Up },
        pair_type{ ""down"", ValueType::Down }
    };
};",1,<empty>,,402,21,CPPASTProblemDeclaration,,<empty>
255357,UNKNOWN,22,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::SplitDirection)
{
    JSON_MAPPINGS(7) = {
        pair_type{ ""auto"", ValueType::Automatic },
        pair_type{ ""up"", ValueType::Up },
        pair_type{ ""right"", ValueType::Right },
        pair_type{ ""down"", ValueType::Down },
        pair_type{ ""left"", ValueType::Left },
        pair_type{ ""vertical"", ValueType::Right },
        pair_type{ ""horizontal"", ValueType::Down },
    };
};",1,<empty>,,413,22,CPPASTProblemDeclaration,,<empty>
255358,UNKNOWN,23,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::SplitType)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""manual"", ValueType::Manual },
        pair_type{ ""duplicate"", ValueType::Duplicate },
    };
};",1,<empty>,,427,23,CPPASTProblemDeclaration,,<empty>
255359,UNKNOWN,24,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::SettingsTarget)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""settingsFile"", ValueType::SettingsFile },
        pair_type{ ""defaultsFile"", ValueType::DefaultsFile },
        pair_type{ ""allFiles"", ValueType::AllFiles },
        pair_type{ ""settingsUI"", ValueType::SettingsUI },
    };
};",1,<empty>,,435,24,CPPASTProblemDeclaration,,<empty>
255360,UNKNOWN,25,,"JSON_ENUM_MAPPER(::winrt::Windows::System::VirtualKey)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""ctrl"", ValueType::Control },
        pair_type{ ""alt"", ValueType::Menu },
        pair_type{ ""shift"", ValueType::Shift },
    };
};",1,<empty>,,445,25,CPPASTProblemDeclaration,,<empty>
255361,UNKNOWN,26,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::TabSwitcherMode)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""mru"", ValueType::MostRecentlyUsed },
        pair_type{ ""inOrder"", ValueType::InOrder },
        pair_type{ ""disabled"", ValueType::Disabled },
    };

    auto FromJson(const Json::Value& json)
    {
        if (json.isBool())
        {
            return json.asBool() ? ValueType::MostRecentlyUsed : ValueType::Disabled;
        }
        return BaseEnumMapper::FromJson(json);
    }

    bool CanConvert(const Json::Value& json)
    {
        return BaseEnumMapper::CanConvert(json) || json.isBool();
    }
};",1,<empty>,,454,26,CPPASTProblemDeclaration,,<empty>
255362,UNKNOWN,27,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::MoveTabDirection)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""forward"", ValueType::Forward },
        pair_type{ ""backward"", ValueType::Backward },
    };
};",1,<empty>,,478,27,CPPASTProblemDeclaration,,<empty>
255363,UNKNOWN,28,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::CommandPaletteLaunchMode)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""action"", ValueType::Action },
        pair_type{ ""commandLine"", ValueType::CommandLine },
    };
};",1,<empty>,,486,28,CPPASTProblemDeclaration,,<empty>
255364,UNKNOWN,29,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::FindMatchDirection)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""next"", ValueType::Next },
        pair_type{ ""prev"", ValueType::Previous },
    };
};",1,<empty>,,494,29,CPPASTProblemDeclaration,,<empty>
255365,UNKNOWN,30,,"JSON_FLAG_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::SuggestionsSource)
{
    static constexpr std::array<pair_type, 5> mappings = {
        pair_type{ ""none"", AllClear },
        pair_type{ ""tasks"", ValueType::Tasks },
        pair_type{ ""commandHistory"", ValueType::CommandHistory },
        pair_type{ ""directoryHistory"", ValueType::DirectoryHistory },
        pair_type{ ""all"", AllSet },
    };
};",1,<empty>,,502,30,CPPASTProblemDeclaration,,<empty>
255366,UNKNOWN,31,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::WindowingMode)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""useNew"", ValueType::UseNew },
        pair_type{ ""useAnyExisting"", ValueType::UseAnyExisting },
        pair_type{ ""useExisting"", ValueType::UseExisting },
    };
};",1,<empty>,,513,31,CPPASTProblemDeclaration,,<empty>
255367,UNKNOWN,32,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::DesktopBehavior)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""any"", ValueType::Any },
        pair_type{ ""toCurrent"", ValueType::ToCurrent },
        pair_type{ ""onCurrent"", ValueType::OnCurrent },
    };
};",1,<empty>,,522,32,CPPASTProblemDeclaration,,<empty>
255368,UNKNOWN,33,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::MonitorBehavior)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""any"", ValueType::Any },
        pair_type{ ""toCurrent"", ValueType::ToCurrent },
        pair_type{ ""toMouse"", ValueType::ToMouse },
    };
};",1,<empty>,,531,33,CPPASTProblemDeclaration,,<empty>
255369,UNKNOWN,34,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Control::ClearBufferType)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""all"", ValueType::All },
        pair_type{ ""screen"", ValueType::Screen },
        pair_type{ ""scrollback"", ValueType::Scrollback },
    };
};",1,<empty>,,540,34,CPPASTProblemDeclaration,,<empty>
255370,UNKNOWN,35,,"JSON_FLAG_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::IntenseStyle)
{
    static constexpr std::array<pair_type, 4> mappings = {
        pair_type{ ""none"", AllClear },
        pair_type{ ""bold"", ValueType::Bold },
        pair_type{ ""bright"", ValueType::Bright },
        pair_type{ ""all"", AllSet },

    };
};",1,<empty>,,549,35,CPPASTProblemDeclaration,,<empty>
255371,UNKNOWN,36,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::InfoBarMessage)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""closeOnExitInfo"", ValueType::CloseOnExitInfo },
        pair_type{ ""keyboardServiceWarning"", ValueType::KeyboardServiceWarning },
        pair_type{ ""setAsDefault"", ValueType::SetAsDefault },
    };
};",1,<empty>,,560,36,CPPASTProblemDeclaration,,<empty>
255372,UNKNOWN,37,,"template<>
struct ::Microsoft::Terminal::Settings::Model::JsonUtils::ConversionTrait<winrt::Microsoft::Terminal::Settings::Model::ThemeColor>
{
    static constexpr std::string_view accentString{ ""accent"" };
    static constexpr std::string_view terminalBackgroundString{ ""terminalBackground"" };

    winrt::Microsoft::Terminal::Settings::Model::ThemeColor FromJson(const Json::Value& json)
    {
        if (json == Json::Value::null)
        {
            return nullptr;
        }
        const auto string{ Detail::GetStringView(json) };
        if (string == accentString)
        {
            return winrt::Microsoft::Terminal::Settings::Model::ThemeColor::FromAccent();
        }
        else if (string == terminalBackgroundString)
        {
            return winrt::Microsoft::Terminal::Settings::Model::ThemeColor::FromTerminalBackground();
        }
        else
        {
            return winrt::Microsoft::Terminal::Settings::Model::ThemeColor::FromColor(::Microsoft::Console::Uti...",1,<empty>,,569,37,CPPASTProblemDeclaration,,<empty>
255373,UNKNOWN,38,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::TabCloseButtonVisibility)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""always"", ValueType::Always },
        pair_type{ ""hover"", ValueType::Hover },
        pair_type{ ""never"", ValueType::Never },
        pair_type{ ""activeOnly"", ValueType::ActiveOnly },
    };
};",1,<empty>,,645,38,CPPASTProblemDeclaration,,<empty>
255374,UNKNOWN,39,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::IconStyle)
{
    JSON_MAPPINGS(3) = {
        pair_type{ ""default"", ValueType::Default },
        pair_type{ ""hidden"", ValueType::Hidden },
        pair_type{ ""monochrome"", ValueType::Monochrome },
    };
};",1,<empty>,,655,39,CPPASTProblemDeclaration,,<empty>
255375,UNKNOWN,40,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Control::ScrollToMarkDirection)
{
    JSON_MAPPINGS(4) = {
        pair_type{ ""previous"", ValueType::Previous },
        pair_type{ ""next"", ValueType::Next },
        pair_type{ ""first"", ValueType::First },
        pair_type{ ""last"", ValueType::Last },
    };
};",1,<empty>,,665,40,CPPASTProblemDeclaration,,<empty>
255376,UNKNOWN,41,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::NewTabMenuEntryType)
{
    JSON_MAPPINGS(5) = {
        pair_type{ ""profile"", ValueType::Profile },
        pair_type{ ""separator"", ValueType::Separator },
        pair_type{ ""folder"", ValueType::Folder },
        pair_type{ ""remainingProfiles"", ValueType::RemainingProfiles },
        pair_type{ ""matchProfiles"", ValueType::MatchProfiles },
    };
};",1,<empty>,,676,41,CPPASTProblemDeclaration,,<empty>
255377,UNKNOWN,42,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::FolderEntryInlining)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""never"", ValueType::Never },
        pair_type{ ""auto"", ValueType::Auto },
    };
};",1,<empty>,,688,42,CPPASTProblemDeclaration,,<empty>
255378,UNKNOWN,43,,"JSON_ENUM_MAPPER(::winrt::Microsoft::Terminal::Settings::Model::SelectOutputDirection)
{
    JSON_MAPPINGS(2) = {
        pair_type{ ""prev"", ValueType::Previous },
        pair_type{ ""next"", ValueType::Next },
    };
};",1,<empty>,,696,43,CPPASTProblemDeclaration,,<empty>
255379,UNKNOWN,44,,"template<>
struct ::Microsoft::Terminal::Settings::Model::JsonUtils::ConversionTrait<::winrt::Microsoft::Terminal::Control::SelectionColor>
{
    ::winrt::Microsoft::Terminal::Control::SelectionColor FromJson(const Json::Value& json)
    {
        const auto string = Detail::GetStringView(json);
        const auto isIndexed16 = string.size() == 3 && string.front() == 'i';
        til::color color;

        if (isIndexed16)
        {
            const auto indexStr = string.substr(1);
            const auto idx = til::to_ulong(indexStr, 16);
            color.r = gsl::narrow_cast<uint8_t>(std::min(idx, 15ul));
        }
        else
        {
            color = ::Microsoft::Console::Utils::ColorFromHexString(string);
        }

        winrt::Microsoft::Terminal::Control::SelectionColor selection;
        selection.Color(color);
        selection.IsIndex16(isIndexed16);
        return selection;
    }

    bool CanConvert(const Json::Value& json)
    {
        if (!json.isString())
...",1,<empty>,,704,44,CPPASTProblemDeclaration,,<empty>
255832,UNKNOWN,1,,BYTE*,94,<empty>,,101,1,CPPASTTypeId,,<empty>
255849,UNKNOWN,1,,COLORREF,36,<empty>,,109,1,CPPASTTypeId,,<empty>
255996,UNKNOWN,27,,"THEME_OBJECT_CONVERTER(winrt::Microsoft::Terminal::Settings::Model, WindowTheme, MTSM_THEME_WINDOW_SETTINGS)",1,<empty>,,221,27,CPPASTProblemDeclaration,,<empty>
255997,UNKNOWN,28,,"THEME_OBJECT_CONVERTER(winrt::Microsoft::Terminal::Settings::Model, TabRowTheme, MTSM_THEME_TABROW_SETTINGS)",1,<empty>,,222,28,CPPASTProblemDeclaration,,<empty>
255998,UNKNOWN,29,,"THEME_OBJECT_CONVERTER(winrt::Microsoft::Terminal::Settings::Model, TabTheme, MTSM_THEME_TAB_SETTINGS)",1,<empty>,,223,29,CPPASTProblemDeclaration,,<empty>
256550,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, DarkName);",9,<empty>,,48,7,CPPASTProblemDeclaration,,<empty>
256551,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, LightName);",9,<empty>,,49,8,CPPASTProblemDeclaration,,<empty>
256586,UNKNOWN,-1,,"WINRT_PROPERTY(til::color, Color);",9,<empty>,,67,8,CPPASTProblemDeclaration,,<empty>
256587,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::Microsoft::Terminal::Settings::Model::ThemeColorType, ColorType);",9,<empty>,,68,9,CPPASTProblemDeclaration,,<empty>
256597,UNKNOWN,-1,,"THEME_OBJECT(WindowTheme, MTSM_THEME_WINDOW_SETTINGS)",5,<empty>,,83,3,CPPASTProblemDeclaration,,<empty>
256607,UNKNOWN,-1,,"THEME_OBJECT(TabRowTheme, MTSM_THEME_TABROW_SETTINGS)",5,<empty>,,84,3,CPPASTProblemDeclaration,,<empty>
256617,UNKNOWN,-1,,"THEME_OBJECT(TabTheme, MTSM_THEME_TAB_SETTINGS)",5,<empty>,,85,3,CPPASTProblemDeclaration,,<empty>
256658,UNKNOWN,-1,,"WINRT_PROPERTY(winrt::hstring, Name);",9,<empty>,,105,10,CPPASTProblemDeclaration,,<empty>
256659,UNKNOWN,-1,,"MTSM_THEME_SETTINGS(THEME_SETTINGS_INITIALIZE)

    private:",9,<empty>,,107,11,CPPASTProblemDeclaration,,<empty>
256858,UNKNOWN,-1,,"try
    {
        if (!IsInstanceValid(instance))
        {
            return;
        }

        const auto seed = GetProfileGuidSeed(instance);
        const winrt::guid profileGuid{ ::Microsoft::Console::Utils::CreateV5Uuid(TERMINAL_PROFILE_NAMESPACE_GUID, std::as_bytes(std::span{ seed })) };
        auto profile = winrt::make_self<implementation::Profile>(profileGuid);
        profile->Name(winrt::hstring{ GetProfileName(instance) });
        profile->Commandline(winrt::hstring{ GetProfileCommandLine(instance) });
        profile->StartingDirectory(winrt::hstring{ instance.GetInstallationPath() });
        profile->Icon(winrt::hstring{ GetProfileIconPath() });
        profile->Hidden(hidden);
        profiles.emplace_back(std::move(profile));
    }
    CATCH_LOG();",5,<empty>,,12,1,CPPASTProblemStatement,,<empty>
257001,UNKNOWN,-1,,"try
    {
        if (!IsInstanceValid(instance))
        {
            return;
        }

        const auto seed = GetProfileGuidSeed(instance);
        const winrt::guid profileGuid{ ::Microsoft::Console::Utils::CreateV5Uuid(TERMINAL_PROFILE_NAMESPACE_GUID, std::as_bytes(std::span{ seed })) };
        auto profile = winrt::make_self<implementation::Profile>(profileGuid);
        profile->Name(winrt::hstring{ GetProfileName(instance) });
        profile->Commandline(winrt::hstring{ GetProfileCommandLine(instance) });
        profile->StartingDirectory(winrt::hstring{ instance.GetInstallationPath() });
        profile->Icon(winrt::hstring{ GetProfileIconPath() });
        profile->Hidden(hidden);
        profiles.emplace_back(std::move(profile));
    }
    CATCH_LOG();",5,<empty>,,13,1,CPPASTProblemStatement,,<empty>
258028,UNKNOWN,1,,BYTE*,114,<empty>,,194,1,CPPASTTypeId,,<empty>
258531,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hSettingsModelProvider,
    ""Microsoft.Windows.Terminal.Setting.Model"",
    // {be579944-4d33-5202-e5d6-a7a57f1935cb}
    (0xbe579944, 0x4d33, 0x5202, 0xe5, 0xd6, 0xa7, 0xa5, 0x7f, 0x19, 0x35, 0xcb),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,9,1,CPPASTProblemDeclaration,,<empty>
258532,UNKNOWN,2,,BOOL,1,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
258569,UNKNOWN,4,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""Microsoft.Terminal.Settings.Model/Resources"")",1,<empty>,,36,4,CPPASTProblemDeclaration,,<empty>
260303,UNKNOWN,16,,},1,<empty>,,574,16,CPPASTProblemDeclaration,,<empty>
260688,UNKNOWN,-1,,),38,<empty>,,129,6,CPPASTProblemStatement,,<empty>
260692,UNKNOWN,-1,,),70,<empty>,,130,8,CPPASTProblemStatement,,<empty>
260694,UNKNOWN,-1,,),36,<empty>,,131,10,CPPASTProblemStatement,,<empty>
260824,UNKNOWN,-1,,),38,<empty>,,199,2,CPPASTProblemStatement,,<empty>
260828,UNKNOWN,-1,,),62,<empty>,,200,4,CPPASTProblemStatement,,<empty>
260830,UNKNOWN,-1,,),36,<empty>,,201,6,CPPASTProblemStatement,,<empty>
261111,UNKNOWN,-1,,),38,<empty>,,297,2,CPPASTProblemStatement,,<empty>
261115,UNKNOWN,-1,,),62,<empty>,,298,4,CPPASTProblemStatement,,<empty>
261117,UNKNOWN,-1,,),36,<empty>,,299,6,CPPASTProblemStatement,,<empty>
263861,UNKNOWN,13,,},1,<empty>,,1053,13,CPPASTProblemDeclaration,,<empty>
263915,UNKNOWN,-1,,"WINRT_CALLBACK(TerminalOutput, winrt::Microsoft::Terminal::TerminalConnection::TerminalOutputHandler);",9,<empty>,,28,8,CPPASTProblemDeclaration,,<empty>
263916,UNKNOWN,-1,,"TYPED_EVENT(StateChanged, winrt::Microsoft::Terminal::TerminalConnection::ITerminalConnection, IInspectable);",9,<empty>,,29,9,CPPASTProblemDeclaration,,<empty>
263933,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
263934,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,3,CPPASTProblemDeclaration,,<empty>
263935,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,4,CPPASTProblemDeclaration,,<empty>
263936,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,5,CPPASTProblemDeclaration,,<empty>
263937,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,6,CPPASTProblemDeclaration,,<empty>
263938,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,7,CPPASTProblemDeclaration,,<empty>
263939,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,8,CPPASTProblemDeclaration,,<empty>
263940,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,9,CPPASTProblemDeclaration,,<empty>
263941,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,10,CPPASTProblemDeclaration,,<empty>
263942,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,11,CPPASTProblemDeclaration,,<empty>
263943,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,12,CPPASTProblemDeclaration,,<empty>
263944,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,13,CPPASTProblemDeclaration,,<empty>
263945,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,14,CPPASTProblemDeclaration,,<empty>
263946,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,15,CPPASTProblemDeclaration,,<empty>
263947,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,16,CPPASTProblemDeclaration,,<empty>
263948,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,17,CPPASTProblemDeclaration,,<empty>
263949,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,18,CPPASTProblemDeclaration,,<empty>
263950,UNKNOWN,-1,,CORE_SETTINGS(SETTINGS_GEN),9,<empty>,,22,19,CPPASTProblemDeclaration,,<empty>
263951,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,20,CPPASTProblemDeclaration,,<empty>
263952,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,21,CPPASTProblemDeclaration,,<empty>
263953,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,22,CPPASTProblemDeclaration,,<empty>
263954,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,23,CPPASTProblemDeclaration,,<empty>
263955,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,24,CPPASTProblemDeclaration,,<empty>
263956,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,25,CPPASTProblemDeclaration,,<empty>
263957,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,26,CPPASTProblemDeclaration,,<empty>
263958,UNKNOWN,-1,,CORE_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,23,27,CPPASTProblemDeclaration,,<empty>
263959,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,28,CPPASTProblemDeclaration,,<empty>
263960,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,29,CPPASTProblemDeclaration,,<empty>
263961,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,30,CPPASTProblemDeclaration,,<empty>
263962,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,31,CPPASTProblemDeclaration,,<empty>
263963,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,32,CPPASTProblemDeclaration,,<empty>
263964,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,33,CPPASTProblemDeclaration,,<empty>
263965,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,34,CPPASTProblemDeclaration,,<empty>
263966,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,35,CPPASTProblemDeclaration,,<empty>
263967,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,36,CPPASTProblemDeclaration,,<empty>
263968,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,37,CPPASTProblemDeclaration,,<empty>
263969,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,38,CPPASTProblemDeclaration,,<empty>
263970,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,39,CPPASTProblemDeclaration,,<empty>
263971,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,40,CPPASTProblemDeclaration,,<empty>
263972,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,41,CPPASTProblemDeclaration,,<empty>
263973,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,42,CPPASTProblemDeclaration,,<empty>
263974,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,43,CPPASTProblemDeclaration,,<empty>
263975,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,44,CPPASTProblemDeclaration,,<empty>
263976,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,45,CPPASTProblemDeclaration,,<empty>
263977,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,46,CPPASTProblemDeclaration,,<empty>
263978,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,47,CPPASTProblemDeclaration,,<empty>
263979,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,48,CPPASTProblemDeclaration,,<empty>
263980,UNKNOWN,-1,,CONTROL_SETTINGS(SETTINGS_GEN),9,<empty>,,24,49,CPPASTProblemDeclaration,,<empty>
263981,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,50,CPPASTProblemDeclaration,,<empty>
263982,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,51,CPPASTProblemDeclaration,,<empty>
263983,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,52,CPPASTProblemDeclaration,,<empty>
263984,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,53,CPPASTProblemDeclaration,,<empty>
263985,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,54,CPPASTProblemDeclaration,,<empty>
263986,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,55,CPPASTProblemDeclaration,,<empty>
263987,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,56,CPPASTProblemDeclaration,,<empty>
263988,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,57,CPPASTProblemDeclaration,,<empty>
263989,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,58,CPPASTProblemDeclaration,,<empty>
263990,UNKNOWN,-1,,CONTROL_APPEARANCE_SETTINGS(SETTINGS_GEN),9,<empty>,,25,59,CPPASTProblemDeclaration,,<empty>
264458,UNKNOWN,1,,uint64_t,48,<empty>,,1892,1,CPPASTTypeId,,<empty>
264510,UNKNOWN,1,,uint64_t,48,<empty>,,1939,1,CPPASTTypeId,,<empty>
264559,UNKNOWN,1,,uint64_t,48,<empty>,,1976,1,CPPASTTypeId,,<empty>
264608,UNKNOWN,1,,uint64_t,48,<empty>,,2006,1,CPPASTTypeId,,<empty>
264657,UNKNOWN,1,,uint64_t,48,<empty>,,2036,1,CPPASTTypeId,,<empty>
264744,UNKNOWN,1,,uint64_t,48,<empty>,,2143,1,CPPASTTypeId,,<empty>
264841,UNKNOWN,1,,uint64_t,48,<empty>,,2284,1,CPPASTTypeId,,<empty>
264998,UNKNOWN,1,,uint64_t,48,<empty>,,2527,1,CPPASTTypeId,,<empty>
265111,UNKNOWN,1,,int32_t,40,<empty>,,69,1,CPPASTTypeId,,<empty>
265125,UNKNOWN,1,,int32_t,26,<empty>,,70,1,CPPASTTypeId,,<empty>
265139,UNKNOWN,1,,int32_t,37,<empty>,,71,1,CPPASTTypeId,,<empty>
265153,UNKNOWN,1,,int32_t,41,<empty>,,72,1,CPPASTTypeId,,<empty>
265168,UNKNOWN,1,,int32_t,62,<empty>,,73,1,CPPASTTypeId,,<empty>
265182,UNKNOWN,1,,int32_t,27,<empty>,,74,1,CPPASTTypeId,,<empty>
265197,UNKNOWN,1,,int32_t,76,<empty>,,75,1,CPPASTTypeId,,<empty>
265212,UNKNOWN,1,,int32_t,76,<empty>,,76,1,CPPASTTypeId,,<empty>
265226,UNKNOWN,1,,int32_t,39,<empty>,,77,1,CPPASTTypeId,,<empty>
265240,UNKNOWN,1,,int32_t,32,<empty>,,78,1,CPPASTTypeId,,<empty>
265254,UNKNOWN,1,,int32_t,49,<empty>,,79,1,CPPASTTypeId,,<empty>
265268,UNKNOWN,1,,int32_t,62,<empty>,,80,1,CPPASTTypeId,,<empty>
265283,UNKNOWN,1,,int32_t,73,<empty>,,81,1,CPPASTTypeId,,<empty>
265298,UNKNOWN,1,,int32_t,69,<empty>,,82,1,CPPASTTypeId,,<empty>
265312,UNKNOWN,1,,int32_t,44,<empty>,,83,1,CPPASTTypeId,,<empty>
265326,UNKNOWN,1,,int32_t,44,<empty>,,84,1,CPPASTTypeId,,<empty>
265340,UNKNOWN,1,,int32_t,42,<empty>,,85,1,CPPASTTypeId,,<empty>
265354,UNKNOWN,1,,int32_t,31,<empty>,,86,1,CPPASTTypeId,,<empty>
265368,UNKNOWN,1,,int32_t,21,<empty>,,87,1,CPPASTTypeId,,<empty>
265383,UNKNOWN,1,,int32_t,61,<empty>,,88,1,CPPASTTypeId,,<empty>
265398,UNKNOWN,1,,int32_t,91,<empty>,,89,1,CPPASTTypeId,,<empty>
265402,UNKNOWN,-1,,"TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, Remoting::WindowActivatedArgs);",9,<empty>,,90,23,CPPASTProblemDeclaration,,<empty>
265403,UNKNOWN,-1,,"TYPED_EVENT(ExecuteCommandlineRequested, winrt::Windows::Foundation::IInspectable, Remoting::CommandlineArgs);",9,<empty>,,91,24,CPPASTProblemDeclaration,,<empty>
265404,UNKNOWN,-1,,"TYPED_EVENT(IdentifyWindowsRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,92,25,CPPASTProblemDeclaration,,<empty>
265405,UNKNOWN,-1,,"TYPED_EVENT(DisplayWindowIdRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,93,26,CPPASTProblemDeclaration,,<empty>
265406,UNKNOWN,-1,,"TYPED_EVENT(RenameRequested, winrt::Windows::Foundation::IInspectable, Remoting::RenameRequestArgs);",9,<empty>,,94,27,CPPASTProblemDeclaration,,<empty>
265407,UNKNOWN,-1,,"TYPED_EVENT(SummonRequested, winrt::Windows::Foundation::IInspectable, Remoting::SummonWindowBehavior);",9,<empty>,,95,28,CPPASTProblemDeclaration,,<empty>
265408,UNKNOWN,-1,,"TYPED_EVENT(ShowNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,96,29,CPPASTProblemDeclaration,,<empty>
265409,UNKNOWN,-1,,"TYPED_EVENT(HideNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,97,30,CPPASTProblemDeclaration,,<empty>
265410,UNKNOWN,-1,,"TYPED_EVENT(QuitAllRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,98,31,CPPASTProblemDeclaration,,<empty>
265411,UNKNOWN,-1,,"TYPED_EVENT(QuitRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,99,32,CPPASTProblemDeclaration,,<empty>
265412,UNKNOWN,-1,,"TYPED_EVENT(GetWindowLayoutRequested, winrt::Windows::Foundation::IInspectable, Remoting::GetWindowLayoutArgs);",9,<empty>,,100,33,CPPASTProblemDeclaration,,<empty>
265413,UNKNOWN,-1,,"TYPED_EVENT(AttachRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::AttachRequest);",9,<empty>,,101,34,CPPASTProblemDeclaration,,<empty>
265414,UNKNOWN,-1,,"TYPED_EVENT(SendContentRequested, winrt::Windows::Foundation::IInspectable, winrt::Microsoft::Terminal::Remoting::RequestReceiveContentArgs);",9,<empty>,,102,35,CPPASTProblemDeclaration,,<empty>
265430,UNKNOWN,1,,int32_t,27,<empty>,,109,1,CPPASTTypeId,,<empty>
265445,UNKNOWN,1,,int32_t,61,<empty>,,110,1,CPPASTTypeId,,<empty>
265459,UNKNOWN,1,,int32_t,40,<empty>,,111,1,CPPASTTypeId,,<empty>
265474,UNKNOWN,1,,int32_t,99,<empty>,,112,1,CPPASTTypeId,,<empty>
265489,UNKNOWN,1,,int32_t,76,<empty>,,113,1,CPPASTTypeId,,<empty>
265504,UNKNOWN,1,,int32_t,73,<empty>,,114,1,CPPASTTypeId,,<empty>
265519,UNKNOWN,1,,int32_t,50,<empty>,,115,1,CPPASTTypeId,,<empty>
265533,UNKNOWN,1,,int32_t,33,<empty>,,117,1,CPPASTTypeId,,<empty>
265547,UNKNOWN,1,,int32_t,37,<empty>,,118,1,CPPASTTypeId,,<empty>
265561,UNKNOWN,1,,int32_t,103,<empty>,,119,1,CPPASTTypeId,,<empty>
265575,UNKNOWN,1,,int32_t,96,<empty>,,120,1,CPPASTTypeId,,<empty>
265593,UNKNOWN,1,,int32_t,149,<empty>,,121,1,CPPASTTypeId,,<empty>
265608,UNKNOWN,1,,int32_t,70,<empty>,,122,1,CPPASTTypeId,,<empty>
265612,UNKNOWN,-1,,"TYPED_EVENT(FindTargetWindowRequested, winrt::Windows::Foundation::IInspectable, Remoting::FindTargetWindowArgs);",9,<empty>,,124,15,CPPASTProblemDeclaration,,<empty>
265613,UNKNOWN,-1,,"TYPED_EVENT(ShowNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,125,16,CPPASTProblemDeclaration,,<empty>
265614,UNKNOWN,-1,,"TYPED_EVENT(HideNotificationIconRequested, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,126,17,CPPASTProblemDeclaration,,<empty>
265615,UNKNOWN,-1,,"TYPED_EVENT(WindowCreated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,127,18,CPPASTProblemDeclaration,,<empty>
265616,UNKNOWN,-1,,"TYPED_EVENT(WindowClosed, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,128,19,CPPASTProblemDeclaration,,<empty>
265617,UNKNOWN,-1,,"TYPED_EVENT(QuitAllRequested, winrt::Windows::Foundation::IInspectable, Remoting::QuitAllRequestedArgs);",9,<empty>,,129,20,CPPASTProblemDeclaration,,<empty>
265618,UNKNOWN,-1,,"TYPED_EVENT(RequestNewWindow, winrt::Windows::Foundation::IInspectable, Remoting::WindowRequestedArgs);",9,<empty>,,130,21,CPPASTProblemDeclaration,,<empty>
265619,UNKNOWN,-1,,"class RemotingTests
    {
        BEGIN_TEST_CLASS(RemotingTests)
        END_TEST_CLASS()

        TEST_METHOD(CreateMonarch);
        TEST_METHOD(CreatePeasant);
        TEST_METHOD(CreatePeasantWithNew);
        TEST_METHOD(AddPeasants);
        TEST_METHOD(GetPeasantsByID);
        TEST_METHOD(AddPeasantsToNewMonarch);
        TEST_METHOD(RemovePeasantFromMonarchWhenFreed);

        TEST_METHOD(ProposeCommandlineNoWindow);
        TEST_METHOD(ProposeCommandlineGivenWindow);
        TEST_METHOD(ProposeCommandlineNegativeWindow);
        TEST_METHOD(ProposeCommandlineCurrentWindow);
        TEST_METHOD(ProposeCommandlineNonExistentWindow);
        TEST_METHOD(ProposeCommandlineDeadWindow);

        TEST_METHOD(MostRecentWindowSameDesktops);
        TEST_METHOD(MostRecentWindowDifferentDesktops);
        TEST_METHOD(MostRecentWindowMoveDesktops);
        TEST_METHOD(GetMostRecentAnyDesktop);
        TEST_METHOD(MostRecentIsDead);

        TEST_METHOD(MostRecentIsQuake);

        TE...",5,<empty>,,133,4,CPPASTProblemDeclaration,,<empty>
266445,UNKNOWN,1,,bool,34,<empty>,,438,1,CPPASTTypeId,,<empty>
266498,UNKNOWN,1,,bool,34,<empty>,,448,1,CPPASTTypeId,,<empty>
266607,UNKNOWN,1,,bool,34,<empty>,,475,1,CPPASTTypeId,,<empty>
266711,UNKNOWN,1,,bool,38,<empty>,,496,1,CPPASTTypeId,,<empty>
266755,UNKNOWN,1,,bool,38,<empty>,,504,1,CPPASTTypeId,,<empty>
266904,UNKNOWN,1,,bool,38,<empty>,,541,1,CPPASTTypeId,,<empty>
267001,UNKNOWN,1,,bool,38,<empty>,,565,1,CPPASTTypeId,,<empty>
267066,UNKNOWN,1,,bool,38,<empty>,,578,1,CPPASTTypeId,,<empty>
267170,UNKNOWN,1,,bool,37,<empty>,,600,1,CPPASTTypeId,,<empty>
267223,UNKNOWN,1,,bool,37,<empty>,,609,1,CPPASTTypeId,,<empty>
267399,UNKNOWN,1,,bool,38,<empty>,,655,1,CPPASTTypeId,,<empty>
267437,UNKNOWN,1,,bool,37,<empty>,,663,1,CPPASTTypeId,,<empty>
270685,UNKNOWN,1,,bool,38,<empty>,,1365,1,CPPASTTypeId,,<empty>
270729,UNKNOWN,1,,bool,38,<empty>,,1374,1,CPPASTTypeId,,<empty>
270787,UNKNOWN,1,,bool,38,<empty>,,1386,1,CPPASTTypeId,,<empty>
274045,UNKNOWN,1,,bool,34,<empty>,,2404,1,CPPASTTypeId,,<empty>
274132,UNKNOWN,1,,bool,34,<empty>,,2429,1,CPPASTTypeId,,<empty>
274674,UNKNOWN,44,,},1,<empty>,,2609,44,CPPASTProblemDeclaration,,<empty>
275265,UNKNOWN,1,,wchar_t,54,<empty>,,829,1,CPPASTTypeId,,<empty>
275372,UNKNOWN,1,,wchar_t,44,<empty>,,867,1,CPPASTTypeId,,<empty>
275412,UNKNOWN,1,,wchar_t,51,<empty>,,879,1,CPPASTTypeId,,<empty>
275429,UNKNOWN,1,,wchar_t,63,<empty>,,880,1,CPPASTTypeId,,<empty>
275962,UNKNOWN,1,,wchar_t,62,<empty>,,1598,1,CPPASTTypeId,,<empty>
276062,UNKNOWN,1,,wchar_t,62,<empty>,,1716,1,CPPASTTypeId,,<empty>
277383,UNKNOWN,1,,size_t,125,<empty>,,3007,1,CPPASTTypeId,,<empty>
277418,UNKNOWN,1,,size_t,93,<empty>,,3012,1,CPPASTTypeId,,<empty>
277595,UNKNOWN,1,,size_t,82,<empty>,,3150,1,CPPASTTypeId,,<empty>
277613,UNKNOWN,1,,size_t,91,<empty>,,3152,1,CPPASTTypeId,,<empty>
278336,UNKNOWN,1,,size_t,69,<empty>,,3845,1,CPPASTTypeId,,<empty>
278356,UNKNOWN,1,,size_t,69,<empty>,,3848,1,CPPASTTypeId,,<empty>
278450,UNKNOWN,1,,size_t,69,<empty>,,3867,1,CPPASTTypeId,,<empty>
278550,UNKNOWN,1,,size_t,69,<empty>,,3998,1,CPPASTTypeId,,<empty>
278570,UNKNOWN,1,,size_t,69,<empty>,,4001,1,CPPASTTypeId,,<empty>
278664,UNKNOWN,1,,size_t,69,<empty>,,4020,1,CPPASTTypeId,,<empty>
278868,UNKNOWN,1,,uint32_t,85,<empty>,,4253,1,CPPASTTypeId,,<empty>
278926,UNKNOWN,1,,uint32_t,80,<empty>,,4300,1,CPPASTTypeId,,<empty>
278992,UNKNOWN,3,,"TEST_METHOD_SETUP(MethodSetup)
    {
        // STEP 1: Set up the Terminal
        term = std::make_unique<Terminal>(Terminal::TestDummyMarker{});",5,<empty>,,87,3,CPPASTProblemDeclaration,,<empty>
278993,UNKNOWN,4,,emptyRenderer = std::make_unique<DummyRenderer>(term.get());,9,<empty>,,91,4,CPPASTProblemDeclaration,,<empty>
278994,UNKNOWN,5,,"term->Create({ TerminalViewWidth, TerminalViewHeight }",9,<empty>,,92,5,CPPASTProblemDeclaration,,<empty>
278995,UNKNOWN,6,,", 100, *emptyRenderer);",63,<empty>,,92,6,CPPASTProblemDeclaration,,<empty>
279010,UNKNOWN,11,,"gci.SetColorTableEntry(TextColor::DEFAULT_FOREGROUND, INVALID_COLOR);",9,<empty>,,100,11,CPPASTProblemDeclaration,,<empty>
279011,UNKNOWN,12,,"gci.SetColorTableEntry(TextColor::DEFAULT_BACKGROUND, INVALID_COLOR);",9,<empty>,,101,12,CPPASTProblemDeclaration,,<empty>
279012,UNKNOWN,13,,gci.SetFillAttribute(0x07);,9,<empty>,,102,13,CPPASTProblemDeclaration,,<empty>
279013,UNKNOWN,14,,gci.CalculateDefaultColorIndices();,9,<empty>,,103,14,CPPASTProblemDeclaration,,<empty>
279014,UNKNOWN,15,,"m_state->PrepareNewTextBufferInfo(true, TerminalViewWidth, TerminalViewHeight);",9,<empty>,,105,15,CPPASTProblemDeclaration,,<empty>
279022,UNKNOWN,18,,VERIFY_IS_FALSE(currentBuffer._IsAltBuffer());,9,<empty>,,108,18,CPPASTProblemDeclaration,,<empty>
279023,UNKNOWN,19,,"VERIFY_SUCCEEDED(currentBuffer.SetViewportOrigin(true, { 0, 0 }",9,<empty>,,109,19,CPPASTProblemDeclaration,,<empty>
279024,UNKNOWN,20,,", true));",72,<empty>,,109,20,CPPASTProblemDeclaration,,<empty>
279025,UNKNOWN,21,,VERIFY_ARE_EQUAL(til::point{,9,<empty>,,110,21,CPPASTProblemDeclaration,,<empty>
279026,UNKNOWN,22,,},37,<empty>,,110,22,CPPASTProblemDeclaration,,<empty>
279027,UNKNOWN,23,,", currentBuffer.GetTextBuffer().GetCursor().GetPosition());",38,<empty>,,110,23,CPPASTProblemDeclaration,,<empty>
279082,UNKNOWN,32,,vtRenderEngine->SetTestCallback(pfn);,9,<empty>,,119,32,CPPASTProblemDeclaration,,<empty>
279083,UNKNOWN,33,,vtRenderEngine->SetResizeQuirk(true);,9,<empty>,,122,33,CPPASTProblemDeclaration,,<empty>
279084,UNKNOWN,34,,g.pRender->AddRenderEngine(vtRenderEngine.get());,9,<empty>,,126,34,CPPASTProblemDeclaration,,<empty>
279085,UNKNOWN,35,,gci.GetActiveOutputBuffer().SetTerminalConnection(vtRenderEngine.get());,9,<empty>,,127,35,CPPASTProblemDeclaration,,<empty>
279086,UNKNOWN,36,,_pConApi = std::make_unique<ConhostInternalGetSet>(gci);,9,<empty>,,129,36,CPPASTProblemDeclaration,,<empty>
279087,UNKNOWN,37,,g.EnableConptyModeForTests(std::move(vtRenderEngine));,9,<empty>,,134,37,CPPASTProblemDeclaration,,<empty>
279088,UNKNOWN,38,,expectedOutput.clear();,9,<empty>,,136,38,CPPASTProblemDeclaration,,<empty>
279089,UNKNOWN,39,,_checkConptyOutput = true;,9,<empty>,,137,39,CPPASTProblemDeclaration,,<empty>
279090,UNKNOWN,40,,_logConpty = false;,9,<empty>,,138,40,CPPASTProblemDeclaration,,<empty>
279091,UNKNOWN,41,,"VERIFY_ARE_EQUAL(gci.GetActiveOutputBuffer().GetViewport().Dimensions(),
                         gci.GetActiveOutputBuffer().GetBufferSize().Dimensions(),
                         L""If this test fails, then there's a good chance ""
                         L""another test resized the buffer but didn't use IsolationLevel:Method"");",9,<empty>,,140,41,CPPASTProblemDeclaration,,<empty>
279092,UNKNOWN,42,,"VERIFY_ARE_EQUAL(gci.GetActiveOutputBuffer().GetViewport(),
                         gci.GetActiveOutputBuffer().GetBufferSize(),
                         L""If this test fails, then there's a good chance ""
                         L""another test resized the buffer but didn't use IsolationLevel:Method"");",9,<empty>,,144,42,CPPASTProblemDeclaration,,<empty>
279093,UNKNOWN,43,,return true;,9,<empty>,,149,43,CPPASTProblemDeclaration,,<empty>
279094,UNKNOWN,44,,},5,<empty>,,150,44,CPPASTProblemDeclaration,,<empty>
279095,UNKNOWN,45,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,152,45,CPPASTProblemDeclaration,,<empty>
279107,UNKNOWN,48,,"std::fill(engines.begin(), engines.end(), nullptr);",9,<empty>,,157,48,CPPASTProblemDeclaration,,<empty>
279108,UNKNOWN,49,,"VERIFY_ARE_EQUAL(0u, expectedOutput.size(), L""Tests should drain all the output they push into the expected output buffer."");",9,<empty>,,159,49,CPPASTProblemDeclaration,,<empty>
279109,UNKNOWN,50,,emptyRenderer = nullptr;,9,<empty>,,161,50,CPPASTProblemDeclaration,,<empty>
279110,UNKNOWN,51,,term = nullptr;,9,<empty>,,162,51,CPPASTProblemDeclaration,,<empty>
279111,UNKNOWN,52,,return true;,9,<empty>,,164,52,CPPASTProblemDeclaration,,<empty>
279112,UNKNOWN,53,,},5,<empty>,,165,53,CPPASTProblemDeclaration,,<empty>
279156,UNKNOWN,97,,"private:
    bool _writeCallback(const char* const pch, const size_t cch);",1,<empty>,,236,97,CPPASTProblemDeclaration,,<empty>
279191,UNKNOWN,112,,};,1,<empty>,,257,112,CPPASTProblemDeclaration,,<empty>
279214,UNKNOWN,1,,size_t,44,<empty>,,266,1,CPPASTTypeId,,<empty>
280135,UNKNOWN,1,,wchar_t,38,<empty>,,587,1,CPPASTTypeId,,<empty>
280271,UNKNOWN,1,,wchar_t,38,<empty>,,648,1,CPPASTTypeId,,<empty>
280473,UNKNOWN,-1,,),34,<empty>,,757,2,CPPASTProblemStatement,,<empty>
280477,UNKNOWN,-1,,),58,<empty>,,758,4,CPPASTProblemStatement,,<empty>
280481,UNKNOWN,-1,,),55,<empty>,,759,6,CPPASTProblemStatement,,<empty>
280485,UNKNOWN,-1,,),64,<empty>,,760,8,CPPASTProblemStatement,,<empty>
280489,UNKNOWN,-1,,),70,<empty>,,761,10,CPPASTProblemStatement,,<empty>
280491,UNKNOWN,-1,,),32,<empty>,,762,12,CPPASTProblemStatement,,<empty>
280651,UNKNOWN,1,,wchar_t,49,<empty>,,795,1,CPPASTTypeId,,<empty>
282680,UNKNOWN,1,,wchar_t,38,<empty>,,1571,1,CPPASTTypeId,,<empty>
282751,UNKNOWN,1,,char,57,<empty>,,1612,1,CPPASTTypeId,,<empty>
283226,UNKNOWN,-1,,),34,<empty>,,1831,2,CPPASTProblemStatement,,<empty>
283230,UNKNOWN,-1,,),68,<empty>,,1832,4,CPPASTProblemStatement,,<empty>
283234,UNKNOWN,-1,,),72,<empty>,,1833,6,CPPASTProblemStatement,,<empty>
283238,UNKNOWN,-1,,),72,<empty>,,1834,8,CPPASTProblemStatement,,<empty>
283242,UNKNOWN,-1,,),72,<empty>,,1835,10,CPPASTProblemStatement,,<empty>
283246,UNKNOWN,-1,,),69,<empty>,,1836,12,CPPASTProblemStatement,,<empty>
283250,UNKNOWN,-1,,),76,<empty>,,1837,14,CPPASTProblemStatement,,<empty>
283263,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, paintEachNewline, L""Any of: manually PaintFrame after each newline is emitted, once at the end of all newlines, or not at all"")",5,<empty>,,1842,1,CPPASTProblemStatement,,<empty>
283266,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, cursorOnNextLine, L""Either leave the cursor on the first line, or place it on the second line of the buffer"")",5,<empty>,,1843,1,CPPASTProblemStatement,,<empty>
283270,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, paintAfterDECALN, L""Controls whether we manually paint a frame after the DECALN sequence is emitted."")",5,<empty>,,1844,1,CPPASTProblemStatement,,<empty>
283274,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, changeAttributes, L""If true, change the text attributes after the 'A's and spaces"")",5,<empty>,,1845,1,CPPASTProblemStatement,,<empty>
283277,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, useLongSpaces, L""If true, print 10 spaces instead of 5, longer than a CUF sequence."")",5,<empty>,,1846,1,CPPASTProblemStatement,,<empty>
283280,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, printTextAfterSpaces, L""If true, print \""ZZZZZ\"" after the spaces on the first line."")",5,<empty>,,1847,1,CPPASTProblemStatement,,<empty>
284444,UNKNOWN,-1,,),34,<empty>,,2361,2,CPPASTProblemStatement,,<empty>
284448,UNKNOWN,-1,,),82,<empty>,,2362,4,CPPASTProblemStatement,,<empty>
284481,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, cursorMovementMode, L""Controls how we move the cursor, either with CUP, newline/carriage-return, or some other VT sequence"")",5,<empty>,,2371,1,CPPASTProblemStatement,,<empty>
284981,UNKNOWN,-1,,),34,<empty>,,2584,2,CPPASTProblemStatement,,<empty>
284985,UNKNOWN,-1,,),58,<empty>,,2585,4,CPPASTProblemStatement,,<empty>
284987,UNKNOWN,-1,,),32,<empty>,,2586,6,CPPASTProblemStatement,,<empty>
285171,UNKNOWN,-1,,),34,<empty>,,2709,2,CPPASTProblemStatement,,<empty>
285175,UNKNOWN,-1,,),69,<empty>,,2710,4,CPPASTProblemStatement,,<empty>
285192,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, clearBufferMethod, L""Controls whether we clear the buffer like cmd or like powershell"")",5,<empty>,,2715,1,CPPASTProblemStatement,,<empty>
285644,UNKNOWN,-1,,),34,<empty>,,2868,3,CPPASTProblemStatement,,<empty>
285648,UNKNOWN,-1,,),58,<empty>,,2869,5,CPPASTProblemStatement,,<empty>
285652,UNKNOWN,-1,,),64,<empty>,,2870,7,CPPASTProblemStatement,,<empty>
285656,UNKNOWN,-1,,),64,<empty>,,2871,9,CPPASTProblemStatement,,<empty>
285658,UNKNOWN,-1,,),32,<empty>,,2872,11,CPPASTProblemStatement,,<empty>
285662,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dx, L""The change in width of the buffer"")",5,<empty>,,2874,1,CPPASTProblemStatement,,<empty>
285666,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dy, L""The change in height of the buffer"")",5,<empty>,,2875,1,CPPASTProblemStatement,,<empty>
285773,UNKNOWN,-1,,),34,<empty>,,2919,3,CPPASTProblemStatement,,<empty>
285777,UNKNOWN,-1,,),58,<empty>,,2920,5,CPPASTProblemStatement,,<empty>
285781,UNKNOWN,-1,,),55,<empty>,,2921,7,CPPASTProblemStatement,,<empty>
285785,UNKNOWN,-1,,),55,<empty>,,2922,9,CPPASTProblemStatement,,<empty>
285789,UNKNOWN,-1,,),73,<empty>,,2923,11,CPPASTProblemStatement,,<empty>
285791,UNKNOWN,-1,,),32,<empty>,,2924,13,CPPASTProblemStatement,,<empty>
285795,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dx, L""The change in width of the buffer"")",5,<empty>,,2926,1,CPPASTProblemStatement,,<empty>
285799,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dy, L""The change in height of the buffer"")",5,<empty>,,2927,1,CPPASTProblemStatement,,<empty>
285802,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, leaveTrailingChar, L""If true, we'll print one additional '#' on row 3"")",5,<empty>,,2928,1,CPPASTProblemStatement,,<empty>
286073,UNKNOWN,-1,,),34,<empty>,,3049,2,CPPASTProblemStatement,,<empty>
286077,UNKNOWN,-1,,),72,<empty>,,3050,4,CPPASTProblemStatement,,<empty>
286081,UNKNOWN,-1,,),72,<empty>,,3051,6,CPPASTProblemStatement,,<empty>
286086,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, paintEachNewline, L""If true, call PaintFrame after each pair of lines."")",5,<empty>,,3054,1,CPPASTProblemStatement,,<empty>
286089,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, spacesToPrint, L""Controls the number of spaces printed after the first '#'"")",5,<empty>,,3055,1,CPPASTProblemStatement,,<empty>
286324,UNKNOWN,-1,,),34,<empty>,,3177,2,CPPASTProblemStatement,,<empty>
286328,UNKNOWN,-1,,),68,<empty>,,3178,4,CPPASTProblemStatement,,<empty>
286332,UNKNOWN,-1,,),62,<empty>,,3179,6,CPPASTProblemStatement,,<empty>
286336,UNKNOWN,-1,,),64,<empty>,,3180,8,CPPASTProblemStatement,,<empty>
286354,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, writingMethod, L""Controls using either ProcessString or WriteCharsLegacy to write to the buffer"")",5,<empty>,,3193,1,CPPASTProblemStatement,,<empty>
286357,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, circledRows, L""Controls the number of lines we output."")",5,<empty>,,3194,1,CPPASTProblemStatement,,<empty>
286361,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, paintEachNewline, L""Controls whether we should call PaintFrame every line of text or not."")",5,<empty>,,3195,1,CPPASTProblemStatement,,<empty>
286444,UNKNOWN,1,,size_t,36,<empty>,,3227,1,CPPASTTypeId,,<empty>
286629,UNKNOWN,-1,,),34,<empty>,,3352,3,CPPASTProblemStatement,,<empty>
286633,UNKNOWN,-1,,),64,<empty>,,3353,5,CPPASTProblemStatement,,<empty>
286637,UNKNOWN,-1,,),68,<empty>,,3354,7,CPPASTProblemStatement,,<empty>
286641,UNKNOWN,-1,,),62,<empty>,,3355,9,CPPASTProblemStatement,,<empty>
286659,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, writingMethod, L""Controls using either ProcessString or WriteCharsLegacy to write to the buffer"")",5,<empty>,,3368,1,CPPASTProblemStatement,,<empty>
286662,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, circledRows, L""Controls the number of lines we output."")",5,<empty>,,3369,1,CPPASTProblemStatement,,<empty>
286666,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, paintEachNewline, L""Controls whether we should call PaintFrame every line of text or not."")",5,<empty>,,3370,1,CPPASTProblemStatement,,<empty>
286728,UNKNOWN,1,,size_t,36,<empty>,,3385,1,CPPASTTypeId,,<empty>
288677,UNKNOWN,-1,,),34,<empty>,,4178,3,CPPASTProblemStatement,,<empty>
288681,UNKNOWN,-1,,),58,<empty>,,4179,5,CPPASTProblemStatement,,<empty>
288683,UNKNOWN,-1,,),32,<empty>,,4180,7,CPPASTProblemStatement,,<empty>
289481,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(actualDimensions.height, SHRT_MAX, L""Row count clamped to SHRT_MAX == "" WCS(SHRT_MAX));",5,<empty>,,45,10,CPPASTProblemStatement,,<empty>
289529,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(actualDimensions.width, SHRT_MAX, L""Column count clamped to SHRT_MAX == "" WCS(SHRT_MAX));",5,<empty>,,54,19,CPPASTProblemStatement,,<empty>
289937,UNKNOWN,-1,,HRESULT PrepareForTeardown(_Out_ bool* /*pForcePaint*/) noexcept { return S_OK; },9,<empty>,,45,6,CPPASTProblemDeclaration,,<empty>
289989,UNKNOWN,-1,,HRESULT InvalidateCircling(_Out_ bool* /*pForcePaint*/) noexcept { return S_OK; },9,<empty>,,57,14,CPPASTProblemDeclaration,,<empty>
290042,UNKNOWN,-1,,"HRESULT UpdateFont(const FontInfoDesired& /*FontInfoDesired*/, _Out_ FontInfo& /*FontInfo*/) noexcept { return S_OK; }",9,<empty>,,64,21,CPPASTProblemDeclaration,,<empty>
290057,UNKNOWN,-1,,"HRESULT GetProposedFont(const FontInfoDesired& /*FontInfoDesired*/, _Out_ FontInfo& /*FontInfo*/, int /*iDpi*/) noexcept { return S_OK; }",9,<empty>,,67,24,CPPASTProblemDeclaration,,<empty>
290065,UNKNOWN,-1,,HRESULT GetFontSize(_Out_ til::size* /*pFontSize*/) noexcept { return S_OK; },9,<empty>,,69,26,CPPASTProblemDeclaration,,<empty>
290066,UNKNOWN,-1,,"HRESULT IsGlyphWideByFont(std::wstring_view /*glyph*/, _Out_ bool* /*pResult*/) noexcept { return S_OK; }",9,<empty>,,70,27,CPPASTProblemDeclaration,,<empty>
290091,UNKNOWN,4,,"private:
    std::unique_ptr<Terminal> _term;",1,<empty>,,134,4,CPPASTProblemDeclaration,,<empty>
290095,UNKNOWN,8,,};,1,<empty>,,139,8,CPPASTProblemDeclaration,,<empty>
290099,UNKNOWN,-1,,),34,<empty>,,157,2,CPPASTProblemStatement,,<empty>
290103,UNKNOWN,-1,,),72,<empty>,,158,4,CPPASTProblemStatement,,<empty>
290108,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, notifyOnCircling, L""Controls whether we should always request scroll notifications"")",5,<empty>,,160,1,CPPASTProblemStatement,,<empty>
290586,UNKNOWN,1,,size_t,65,<empty>,,81,1,CPPASTTypeId,,<empty>
290668,UNKNOWN,-1,,"TEST_METHOD(OverflowTests)
        {
            const til::point maxCoord = { SHRT_MAX, SHRT_MAX };",9,<empty>,,109,2,CPPASTProblemDeclaration,,<empty>
290681,UNKNOWN,-1,,"Log::Comment(L""Single click selection with NO scrollback value"");",13,<empty>,,150,9,CPPASTProblemDeclaration,,<empty>
290682,UNKNOWN,-1,,"ValidateSingleClickSelection(0, { 9, 9, 9, 9 }",13,<empty>,,151,10,CPPASTProblemDeclaration,,<empty>
290683,UNKNOWN,-1,,);,59,<empty>,,151,11,CPPASTProblemDeclaration,,<empty>
290684,UNKNOWN,-1,,"Log::Comment(L""Double click selection with NO scrollback value"");",13,<empty>,,152,12,CPPASTProblemDeclaration,,<empty>
290685,UNKNOWN,-1,,"ValidateDoubleClickSelection(0, { 0, 9, 9, 9 }",13,<empty>,,153,13,CPPASTProblemDeclaration,,<empty>
290686,UNKNOWN,-1,,);,59,<empty>,,153,14,CPPASTProblemDeclaration,,<empty>
290687,UNKNOWN,-1,,"Log::Comment(L""Triple click selection with NO scrollback value"");",13,<empty>,,154,15,CPPASTProblemDeclaration,,<empty>
290688,UNKNOWN,-1,,"ValidateTripleClickSelection(0, { 0, 9, 9, 9 }",13,<empty>,,155,16,CPPASTProblemDeclaration,,<empty>
290689,UNKNOWN,-1,,);,59,<empty>,,155,17,CPPASTProblemDeclaration,,<empty>
290696,UNKNOWN,-1,,"Log::Comment(L""Single click selection with MAXIMUM scrollback value"");",13,<empty>,,159,20,CPPASTProblemDeclaration,,<empty>
290697,UNKNOWN,-1,,"ValidateSingleClickSelection(SHRT_MAX, { 9, expected_row, 9, expected_row }",13,<empty>,,160,21,CPPASTProblemDeclaration,,<empty>
290698,UNKNOWN,-1,,);,88,<empty>,,160,22,CPPASTProblemDeclaration,,<empty>
290699,UNKNOWN,-1,,"Log::Comment(L""Double click selection with MAXIMUM scrollback value"");",13,<empty>,,161,23,CPPASTProblemDeclaration,,<empty>
290700,UNKNOWN,-1,,"ValidateDoubleClickSelection(SHRT_MAX, { 0, expected_row, 9, expected_row }",13,<empty>,,162,24,CPPASTProblemDeclaration,,<empty>
290701,UNKNOWN,-1,,);,88,<empty>,,162,25,CPPASTProblemDeclaration,,<empty>
290702,UNKNOWN,-1,,"Log::Comment(L""Triple click selection with MAXIMUM scrollback value"");",13,<empty>,,163,26,CPPASTProblemDeclaration,,<empty>
290703,UNKNOWN,-1,,"ValidateTripleClickSelection(SHRT_MAX, { 0, expected_row, 9, expected_row }",13,<empty>,,164,27,CPPASTProblemDeclaration,,<empty>
290704,UNKNOWN,-1,,);,88,<empty>,,164,28,CPPASTProblemDeclaration,,<empty>
290705,UNKNOWN,2,,"TEST_METHOD(SelectFromOutofBounds)
        {
            /*  NOTE:
                ensuring that the selection anchors are clamped to be valid permits us to make the following assumption:
                    - All selection expansion functions will operate as if they were performed at the boundary
            */

            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,167,2,CPPASTProblemDeclaration,,<empty>
290712,UNKNOWN,5,,"term.Create({ 10, 10 }",13,<empty>,,176,5,CPPASTProblemDeclaration,,<empty>
290713,UNKNOWN,6,,", 0, renderer);",35,<empty>,,176,6,CPPASTProblemDeclaration,,<empty>
290749,UNKNOWN,17,,"term.SetSelectionAnchor({ 20, 5 }",13,<empty>,,186,17,CPPASTProblemDeclaration,,<empty>
290750,UNKNOWN,18,,);,46,<empty>,,186,18,CPPASTProblemDeclaration,,<empty>
290751,UNKNOWN,19,,"Log::Comment(L""Out of bounds: X-value too large"");",13,<empty>,,187,19,CPPASTProblemDeclaration,,<empty>
290752,UNKNOWN,20,,"ValidateSingleRowSelection(term, { rightBoundary, 5, rightBoundary, 5 }",13,<empty>,,188,20,CPPASTProblemDeclaration,,<empty>
290753,UNKNOWN,21,,);,84,<empty>,,188,21,CPPASTProblemDeclaration,,<empty>
290754,UNKNOWN,22,,"term.SetSelectionAnchor({ -20, 5 }",13,<empty>,,192,22,CPPASTProblemDeclaration,,<empty>
290755,UNKNOWN,23,,);,47,<empty>,,192,23,CPPASTProblemDeclaration,,<empty>
290756,UNKNOWN,24,,"Log::Comment(L""Out of bounds: X-value too negative"");",13,<empty>,,193,24,CPPASTProblemDeclaration,,<empty>
290757,UNKNOWN,25,,"ValidateSingleRowSelection(term, { leftBoundary, 5, leftBoundary, 5 }",13,<empty>,,194,25,CPPASTProblemDeclaration,,<empty>
290758,UNKNOWN,26,,);,82,<empty>,,194,26,CPPASTProblemDeclaration,,<empty>
290759,UNKNOWN,27,,"term.SetSelectionAnchor({ 5, -20 }",13,<empty>,,198,27,CPPASTProblemDeclaration,,<empty>
290760,UNKNOWN,28,,);,47,<empty>,,198,28,CPPASTProblemDeclaration,,<empty>
290761,UNKNOWN,29,,"Log::Comment(L""Out of bounds: Y-value too negative"");",13,<empty>,,199,29,CPPASTProblemDeclaration,,<empty>
290762,UNKNOWN,30,,"ValidateSingleRowSelection(term, { 5, topBoundary, 5, topBoundary }",13,<empty>,,200,30,CPPASTProblemDeclaration,,<empty>
290763,UNKNOWN,31,,);,80,<empty>,,200,31,CPPASTProblemDeclaration,,<empty>
290764,UNKNOWN,32,,"term.SetSelectionAnchor({ 5, 20 }",13,<empty>,,204,32,CPPASTProblemDeclaration,,<empty>
290765,UNKNOWN,33,,);,46,<empty>,,204,33,CPPASTProblemDeclaration,,<empty>
290766,UNKNOWN,34,,"Log::Comment(L""Out of bounds: Y-value too large"");",13,<empty>,,205,34,CPPASTProblemDeclaration,,<empty>
290767,UNKNOWN,35,,"ValidateSingleRowSelection(term, { 5, bottomBoundary, 5, bottomBoundary }",13,<empty>,,206,35,CPPASTProblemDeclaration,,<empty>
290768,UNKNOWN,36,,);,86,<empty>,,206,36,CPPASTProblemDeclaration,,<empty>
290769,UNKNOWN,37,,},9,<empty>,,207,37,CPPASTProblemDeclaration,,<empty>
290770,UNKNOWN,38,,"TEST_METHOD(SelectToOutOfBounds)
        {
            /*  NOTE:
                ensuring that the selection anchors are clamped to be valid permits us to make the following assumption:
                    - All selection expansion functions will operate as if they were performed at the boundary
            */

            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,209,38,CPPASTProblemDeclaration,,<empty>
290777,UNKNOWN,41,,"term.Create({ 10, 10 }",13,<empty>,,218,41,CPPASTProblemDeclaration,,<empty>
290778,UNKNOWN,42,,", 0, renderer);",35,<empty>,,218,42,CPPASTProblemDeclaration,,<empty>
290797,UNKNOWN,49,,"term.SetSelectionAnchor({ 5, 5 }",13,<empty>,,225,49,CPPASTProblemDeclaration,,<empty>
290798,UNKNOWN,50,,);,45,<empty>,,225,50,CPPASTProblemDeclaration,,<empty>
290799,UNKNOWN,51,,"Log::Comment(L""Out of bounds: X-value too large"");",13,<empty>,,228,51,CPPASTProblemDeclaration,,<empty>
290800,UNKNOWN,52,,"term.SetSelectionEnd({ 20, 5 }",13,<empty>,,229,52,CPPASTProblemDeclaration,,<empty>
290801,UNKNOWN,53,,);,43,<empty>,,229,53,CPPASTProblemDeclaration,,<empty>
290802,UNKNOWN,54,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 5, 5, rightBoundary, 5 }",13,<empty>,,230,54,CPPASTProblemDeclaration,,<empty>
290803,UNKNOWN,55,,));,92,<empty>,,230,55,CPPASTProblemDeclaration,,<empty>
290804,UNKNOWN,56,,"Log::Comment(L""Out of bounds: X-value negative"");",13,<empty>,,233,56,CPPASTProblemDeclaration,,<empty>
290805,UNKNOWN,57,,"term.SetSelectionEnd({ -20, 5 }",13,<empty>,,234,57,CPPASTProblemDeclaration,,<empty>
290806,UNKNOWN,58,,);,44,<empty>,,234,58,CPPASTProblemDeclaration,,<empty>
290807,UNKNOWN,59,,"ValidateSingleRowSelection(term, { leftBoundary, 5, 5, 5 }",13,<empty>,,235,59,CPPASTProblemDeclaration,,<empty>
290808,UNKNOWN,60,,);,71,<empty>,,235,60,CPPASTProblemDeclaration,,<empty>
290809,UNKNOWN,61,,"Log::Comment(L""Out of bounds: Y-value negative"");",13,<empty>,,238,61,CPPASTProblemDeclaration,,<empty>
290810,UNKNOWN,62,,"term.SetSelectionEnd({ 5, -20 }",13,<empty>,,239,62,CPPASTProblemDeclaration,,<empty>
290811,UNKNOWN,63,,);,44,<empty>,,239,63,CPPASTProblemDeclaration,,<empty>
290812,UNKNOWN,64,,"{
                auto selectionRects = term.GetSelectionRects();

                // Validate selection area
                VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(6));
                for (auto selectionRect : selectionRects)
                {
                    auto selection = viewport.ConvertToOrigin(selectionRect).ToInclusive();
                    auto rowValue = selectionRect.BottomInclusive();

                    if (rowValue == 0)
                    {
                        // Verify top line
                        VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, rowValue, rightBoundary, rowValue }));
                    }
                    else if (rowValue == 5)
                    {
                        // Verify last line
                        VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ leftBoundary, rowValue, 5, rowValue }));
                    }
                    else
                    {
                        // Verif...",13,<empty>,,240,64,CPPASTProblemDeclaration,,<empty>
290813,UNKNOWN,65,,"Log::Comment(L""Out of bounds: Y-value too large"");",13,<empty>,,269,65,CPPASTProblemDeclaration,,<empty>
290814,UNKNOWN,66,,"term.SetSelectionEnd({ 5, 20 }",13,<empty>,,270,66,CPPASTProblemDeclaration,,<empty>
290815,UNKNOWN,67,,);,43,<empty>,,270,67,CPPASTProblemDeclaration,,<empty>
290816,UNKNOWN,68,,"{
                auto selectionRects = term.GetSelectionRects();

                // Validate selection area
                VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(5));
                for (auto selectionRect : selectionRects)
                {
                    auto selection = viewport.ConvertToOrigin(selectionRect).ToInclusive();
                    auto rowValue = selectionRect.BottomInclusive();

                    if (rowValue == 5)
                    {
                        // Verify top line
                        VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, 5, rightBoundary, 5 }));
                    }
                    else if (rowValue == 9)
                    {
                        // Verify bottom line
                        VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ leftBoundary, rowValue, 5, rowValue }));
                    }
                    else
                    {
                        // Verify other line...",13,<empty>,,271,68,CPPASTProblemDeclaration,,<empty>
290817,UNKNOWN,69,,},9,<empty>,,298,69,CPPASTProblemDeclaration,,<empty>
290818,UNKNOWN,70,,"TEST_METHOD(SelectBoxArea)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,300,70,CPPASTProblemDeclaration,,<empty>
290825,UNKNOWN,73,,"term.Create({ 100, 100 }",13,<empty>,,304,73,CPPASTProblemDeclaration,,<empty>
290826,UNKNOWN,74,,", 0, renderer);",37,<empty>,,304,74,CPPASTProblemDeclaration,,<empty>
290831,UNKNOWN,77,,"term.SetSelectionAnchor({ 5, rowValue }",13,<empty>,,312,77,CPPASTProblemDeclaration,,<empty>
290832,UNKNOWN,78,,);,52,<empty>,,312,78,CPPASTProblemDeclaration,,<empty>
290833,UNKNOWN,79,,term.SetBlockSelection(true);,13,<empty>,,313,79,CPPASTProblemDeclaration,,<empty>
290834,UNKNOWN,80,,"term.SetSelectionEnd({ 15, 20 }",13,<empty>,,316,80,CPPASTProblemDeclaration,,<empty>
290835,UNKNOWN,81,,);,44,<empty>,,316,81,CPPASTProblemDeclaration,,<empty>
290843,UNKNOWN,84,,"VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(11));",13,<empty>,,322,84,CPPASTProblemDeclaration,,<empty>
290851,UNKNOWN,87,,"for (auto selectionRect : selectionRects)
            {
                auto selection = viewport.ConvertToOrigin(selectionRect).ToInclusive();

                // Verify all lines
                VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, rowValue, 15, rowValue }));

                rowValue++;
            }",13,<empty>,,325,87,CPPASTProblemDeclaration,,<empty>
290852,UNKNOWN,88,,},9,<empty>,,334,88,CPPASTProblemDeclaration,,<empty>
290853,UNKNOWN,89,,"TEST_METHOD(SelectAreaAfterScroll)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,336,89,CPPASTProblemDeclaration,,<empty>
290864,UNKNOWN,94,,"term.Create({ 100, 100 }",13,<empty>,,341,94,CPPASTProblemDeclaration,,<empty>
290865,UNKNOWN,95,,", scrollbackLines, renderer);",37,<empty>,,341,95,CPPASTProblemDeclaration,,<empty>
290870,UNKNOWN,98,,"term.SetSelectionAnchor({ 5, rowValue }",13,<empty>,,349,98,CPPASTProblemDeclaration,,<empty>
290871,UNKNOWN,99,,);,52,<empty>,,349,99,CPPASTProblemDeclaration,,<empty>
290872,UNKNOWN,100,,"term.SetSelectionEnd({ 15, 20 }",13,<empty>,,352,100,CPPASTProblemDeclaration,,<empty>
290873,UNKNOWN,101,,);,44,<empty>,,352,101,CPPASTProblemDeclaration,,<empty>
290881,UNKNOWN,104,,"VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(11));",13,<empty>,,358,104,CPPASTProblemDeclaration,,<empty>
290896,UNKNOWN,109,,"for (auto selectionRect : selectionRects)
            {
                auto selection = viewport.ConvertToOrigin(selectionRect).ToInclusive();

                if (rowValue == 10)
                {
                    // Verify top line
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, 10, rightBoundary, 10 }));
                }
                else if (rowValue == 20)
                {
                    // Verify bottom line
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 0, 20, 15, 20 }));
                }
                else
                {
                    // Verify other lines (full)
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 0, rowValue, rightBoundary, rowValue }));
                }

                rowValue++;
            }",13,<empty>,,362,109,CPPASTProblemDeclaration,,<empty>
290897,UNKNOWN,110,,},9,<empty>,,384,110,CPPASTProblemDeclaration,,<empty>
290898,UNKNOWN,111,,"TEST_METHOD(SelectWideGlyph_Trailing)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,386,111,CPPASTProblemDeclaration,,<empty>
290905,UNKNOWN,114,,"term.Create({ 100, 100 }",13,<empty>,,390,114,CPPASTProblemDeclaration,,<empty>
290906,UNKNOWN,115,,", 0, renderer);",37,<empty>,,390,115,CPPASTProblemDeclaration,,<empty>
290911,UNKNOWN,118,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,397,118,CPPASTProblemDeclaration,,<empty>
290912,UNKNOWN,119,,);,67,<empty>,,397,119,CPPASTProblemDeclaration,,<empty>
290913,UNKNOWN,120,,term.Write(burrito);,13,<empty>,,398,120,CPPASTProblemDeclaration,,<empty>
290921,UNKNOWN,123,,term.SetSelectionAnchor(clickPos);,13,<empty>,,402,123,CPPASTProblemDeclaration,,<empty>
290922,UNKNOWN,124,,"ValidateSingleRowSelection(term, { 4, 10, 5, 10 }",13,<empty>,,406,124,CPPASTProblemDeclaration,,<empty>
290923,UNKNOWN,125,,);,62,<empty>,,406,125,CPPASTProblemDeclaration,,<empty>
290924,UNKNOWN,126,,},9,<empty>,,407,126,CPPASTProblemDeclaration,,<empty>
290925,UNKNOWN,127,,"TEST_METHOD(SelectWideGlyph_Leading)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,409,127,CPPASTProblemDeclaration,,<empty>
290932,UNKNOWN,130,,"term.Create({ 100, 100 }",13,<empty>,,413,130,CPPASTProblemDeclaration,,<empty>
290933,UNKNOWN,131,,", 0, renderer);",37,<empty>,,413,131,CPPASTProblemDeclaration,,<empty>
290938,UNKNOWN,134,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,420,134,CPPASTProblemDeclaration,,<empty>
290939,UNKNOWN,135,,);,67,<empty>,,420,135,CPPASTProblemDeclaration,,<empty>
290940,UNKNOWN,136,,term.Write(burrito);,13,<empty>,,421,136,CPPASTProblemDeclaration,,<empty>
290948,UNKNOWN,139,,term.SetSelectionAnchor(clickPos);,13,<empty>,,425,139,CPPASTProblemDeclaration,,<empty>
290949,UNKNOWN,140,,"ValidateSingleRowSelection(term, { 4, 10, 5, 10 }",13,<empty>,,429,140,CPPASTProblemDeclaration,,<empty>
290950,UNKNOWN,141,,);,62,<empty>,,429,141,CPPASTProblemDeclaration,,<empty>
290951,UNKNOWN,142,,},9,<empty>,,430,142,CPPASTProblemDeclaration,,<empty>
290952,UNKNOWN,143,,"TEST_METHOD(SelectWideGlyphsInBoxSelection)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,432,143,CPPASTProblemDeclaration,,<empty>
290959,UNKNOWN,146,,"term.Create({ 100, 100 }",13,<empty>,,436,146,CPPASTProblemDeclaration,,<empty>
290960,UNKNOWN,147,,", 0, renderer);",37,<empty>,,436,147,CPPASTProblemDeclaration,,<empty>
290965,UNKNOWN,150,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,443,150,CPPASTProblemDeclaration,,<empty>
290966,UNKNOWN,151,,);,67,<empty>,,443,151,CPPASTProblemDeclaration,,<empty>
290967,UNKNOWN,152,,term.Write(burrito);,13,<empty>,,444,152,CPPASTProblemDeclaration,,<empty>
290968,UNKNOWN,153,,"term.GetTextBuffer().GetCursor().SetPosition({ 7, 11 }",13,<empty>,,447,153,CPPASTProblemDeclaration,,<empty>
290969,UNKNOWN,154,,);,67,<empty>,,447,154,CPPASTProblemDeclaration,,<empty>
290970,UNKNOWN,155,,term.Write(burrito);,13,<empty>,,448,155,CPPASTProblemDeclaration,,<empty>
290971,UNKNOWN,156,,"term.SetSelectionAnchor({ 5, 8 }",13,<empty>,,451,156,CPPASTProblemDeclaration,,<empty>
290972,UNKNOWN,157,,);,45,<empty>,,451,157,CPPASTProblemDeclaration,,<empty>
290973,UNKNOWN,158,,term.SetBlockSelection(true);,13,<empty>,,452,158,CPPASTProblemDeclaration,,<empty>
290974,UNKNOWN,159,,"term.SetSelectionEnd({ 7, 12 }",13,<empty>,,455,159,CPPASTProblemDeclaration,,<empty>
290975,UNKNOWN,160,,);,43,<empty>,,455,160,CPPASTProblemDeclaration,,<empty>
290983,UNKNOWN,163,,"VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(5));",13,<empty>,,461,163,CPPASTProblemDeclaration,,<empty>
290995,UNKNOWN,168,,"for (auto selectionRect : selectionRects)
            {
                auto selection = viewport.ConvertToOrigin(selectionRect).ToInclusive();

                if (rowValue == 10)
                {
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 4, rowValue, 7, rowValue }));
                }
                else if (rowValue == 11)
                {
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, rowValue, 8, rowValue }));
                }
                else
                {
                    // Verify all lines
                    VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 5, rowValue, 7, rowValue }));
                }

                rowValue++;
            }",13,<empty>,,465,168,CPPASTProblemDeclaration,,<empty>
290996,UNKNOWN,169,,},9,<empty>,,485,169,CPPASTProblemDeclaration,,<empty>
290997,UNKNOWN,170,,"TEST_METHOD(DoubleClick_GeneralCase)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,487,170,CPPASTProblemDeclaration,,<empty>
291004,UNKNOWN,173,,"term.Create({ 100, 100 }",13,<empty>,,491,173,CPPASTProblemDeclaration,,<empty>
291005,UNKNOWN,174,,", 0, renderer);",37,<empty>,,491,174,CPPASTProblemDeclaration,,<empty>
291020,UNKNOWN,177,,term.UpdateSettings(settings);,13,<empty>,,495,177,CPPASTProblemDeclaration,,<empty>
291025,UNKNOWN,180,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,499,180,CPPASTProblemDeclaration,,<empty>
291026,UNKNOWN,181,,);,67,<empty>,,499,181,CPPASTProblemDeclaration,,<empty>
291027,UNKNOWN,182,,term.Write(text);,13,<empty>,,500,182,CPPASTProblemDeclaration,,<empty>
291035,UNKNOWN,185,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Word);",13,<empty>,,504,185,CPPASTProblemDeclaration,,<empty>
291036,UNKNOWN,186,,"ValidateSingleRowSelection(term, til::inclusive_rect{ 4, 10, gsl::narrow<til::CoordType>(4 + text.size() - 1), 10 }",13,<empty>,,507,186,CPPASTProblemDeclaration,,<empty>
291037,UNKNOWN,187,,);,128,<empty>,,507,187,CPPASTProblemDeclaration,,<empty>
291038,UNKNOWN,188,,},9,<empty>,,508,188,CPPASTProblemDeclaration,,<empty>
291039,UNKNOWN,189,,"TEST_METHOD(DoubleClick_Delimiter)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,510,189,CPPASTProblemDeclaration,,<empty>
291046,UNKNOWN,192,,"term.Create({ 100, 100 }",13,<empty>,,514,192,CPPASTProblemDeclaration,,<empty>
291047,UNKNOWN,193,,", 0, renderer);",37,<empty>,,514,193,CPPASTProblemDeclaration,,<empty>
291062,UNKNOWN,196,,term.UpdateSettings(settings);,13,<empty>,,518,196,CPPASTProblemDeclaration,,<empty>
291070,UNKNOWN,199,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Word);",13,<empty>,,522,199,CPPASTProblemDeclaration,,<empty>
291078,UNKNOWN,202,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 0, 10, 99, 10 }",13,<empty>,,528,202,CPPASTProblemDeclaration,,<empty>
291079,UNKNOWN,203,,));,83,<empty>,,528,203,CPPASTProblemDeclaration,,<empty>
291080,UNKNOWN,204,,},9,<empty>,,529,204,CPPASTProblemDeclaration,,<empty>
291081,UNKNOWN,205,,"TEST_METHOD(DoubleClick_DelimiterClass)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,531,205,CPPASTProblemDeclaration,,<empty>
291088,UNKNOWN,208,,"term.Create({ 100, 100 }",13,<empty>,,535,208,CPPASTProblemDeclaration,,<empty>
291089,UNKNOWN,209,,", 0, renderer);",37,<empty>,,535,209,CPPASTProblemDeclaration,,<empty>
291104,UNKNOWN,212,,term.UpdateSettings(settings);,13,<empty>,,539,212,CPPASTProblemDeclaration,,<empty>
291109,UNKNOWN,215,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,543,215,CPPASTProblemDeclaration,,<empty>
291110,UNKNOWN,216,,);,67,<empty>,,543,216,CPPASTProblemDeclaration,,<empty>
291111,UNKNOWN,217,,term.Write(text);,13,<empty>,,544,217,CPPASTProblemDeclaration,,<empty>
291119,UNKNOWN,220,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Word);",13,<empty>,,549,220,CPPASTProblemDeclaration,,<empty>
291120,UNKNOWN,221,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 15, 10, 15, 10 }",13,<empty>,,556,221,CPPASTProblemDeclaration,,<empty>
291121,UNKNOWN,222,,));,84,<empty>,,556,222,CPPASTProblemDeclaration,,<empty>
291122,UNKNOWN,223,,},9,<empty>,,557,223,CPPASTProblemDeclaration,,<empty>
291123,UNKNOWN,224,,"TEST_METHOD(DoubleClickDrag_Right)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,559,224,CPPASTProblemDeclaration,,<empty>
291130,UNKNOWN,227,,"term.Create({ 100, 100 }",13,<empty>,,563,227,CPPASTProblemDeclaration,,<empty>
291131,UNKNOWN,228,,", 0, renderer);",37,<empty>,,563,228,CPPASTProblemDeclaration,,<empty>
291146,UNKNOWN,231,,term.UpdateSettings(settings);,13,<empty>,,567,231,CPPASTProblemDeclaration,,<empty>
291151,UNKNOWN,234,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,571,234,CPPASTProblemDeclaration,,<empty>
291152,UNKNOWN,235,,);,67,<empty>,,571,235,CPPASTProblemDeclaration,,<empty>
291153,UNKNOWN,236,,term.Write(text);,13,<empty>,,572,236,CPPASTProblemDeclaration,,<empty>
291154,UNKNOWN,237,,"term.MultiClickSelection({ 5, 10 }",13,<empty>,,575,237,CPPASTProblemDeclaration,,<empty>
291155,UNKNOWN,238,,", Terminal::SelectionExpansion::Word);",47,<empty>,,575,238,CPPASTProblemDeclaration,,<empty>
291156,UNKNOWN,239,,"term.SetSelectionEnd({ 21, 10 }",13,<empty>,,582,239,CPPASTProblemDeclaration,,<empty>
291157,UNKNOWN,240,,);,44,<empty>,,582,240,CPPASTProblemDeclaration,,<empty>
291158,UNKNOWN,241,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }",13,<empty>,,585,241,CPPASTProblemDeclaration,,<empty>
291159,UNKNOWN,242,,));,83,<empty>,,585,242,CPPASTProblemDeclaration,,<empty>
291160,UNKNOWN,243,,},9,<empty>,,586,243,CPPASTProblemDeclaration,,<empty>
291161,UNKNOWN,244,,"TEST_METHOD(DoubleClickDrag_Left)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,588,244,CPPASTProblemDeclaration,,<empty>
291168,UNKNOWN,247,,"term.Create({ 100, 100 }",13,<empty>,,592,247,CPPASTProblemDeclaration,,<empty>
291169,UNKNOWN,248,,", 0, renderer);",37,<empty>,,592,248,CPPASTProblemDeclaration,,<empty>
291184,UNKNOWN,251,,term.UpdateSettings(settings);,13,<empty>,,596,251,CPPASTProblemDeclaration,,<empty>
291189,UNKNOWN,254,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,600,254,CPPASTProblemDeclaration,,<empty>
291190,UNKNOWN,255,,);,67,<empty>,,600,255,CPPASTProblemDeclaration,,<empty>
291191,UNKNOWN,256,,term.Write(text);,13,<empty>,,601,256,CPPASTProblemDeclaration,,<empty>
291192,UNKNOWN,257,,"term.MultiClickSelection({ 21, 10 }",13,<empty>,,604,257,CPPASTProblemDeclaration,,<empty>
291193,UNKNOWN,258,,", Terminal::SelectionExpansion::Word);",48,<empty>,,604,258,CPPASTProblemDeclaration,,<empty>
291194,UNKNOWN,259,,"term.SetSelectionEnd({ 5, 10 }",13,<empty>,,611,259,CPPASTProblemDeclaration,,<empty>
291195,UNKNOWN,260,,);,43,<empty>,,611,260,CPPASTProblemDeclaration,,<empty>
291196,UNKNOWN,261,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }",13,<empty>,,614,261,CPPASTProblemDeclaration,,<empty>
291197,UNKNOWN,262,,));,83,<empty>,,614,262,CPPASTProblemDeclaration,,<empty>
291198,UNKNOWN,263,,},9,<empty>,,615,263,CPPASTProblemDeclaration,,<empty>
291199,UNKNOWN,264,,"TEST_METHOD(TripleClick_GeneralCase)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,617,264,CPPASTProblemDeclaration,,<empty>
291206,UNKNOWN,267,,"term.Create({ 100, 100 }",13,<empty>,,621,267,CPPASTProblemDeclaration,,<empty>
291207,UNKNOWN,268,,", 0, renderer);",37,<empty>,,621,268,CPPASTProblemDeclaration,,<empty>
291215,UNKNOWN,271,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Line);",13,<empty>,,625,271,CPPASTProblemDeclaration,,<empty>
291216,UNKNOWN,272,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 0, 10, 99, 10 }",13,<empty>,,628,272,CPPASTProblemDeclaration,,<empty>
291217,UNKNOWN,273,,));,83,<empty>,,628,273,CPPASTProblemDeclaration,,<empty>
291218,UNKNOWN,274,,},9,<empty>,,629,274,CPPASTProblemDeclaration,,<empty>
291219,UNKNOWN,275,,"TEST_METHOD(TripleClickDrag_Horizontal)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,631,275,CPPASTProblemDeclaration,,<empty>
291226,UNKNOWN,278,,"term.Create({ 100, 100 }",13,<empty>,,635,278,CPPASTProblemDeclaration,,<empty>
291227,UNKNOWN,279,,", 0, renderer);",37,<empty>,,635,279,CPPASTProblemDeclaration,,<empty>
291235,UNKNOWN,282,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Line);",13,<empty>,,639,282,CPPASTProblemDeclaration,,<empty>
291236,UNKNOWN,283,,"term.SetSelectionEnd({ 7, 10 }",13,<empty>,,642,283,CPPASTProblemDeclaration,,<empty>
291237,UNKNOWN,284,,);,43,<empty>,,642,284,CPPASTProblemDeclaration,,<empty>
291238,UNKNOWN,285,,"ValidateSingleRowSelection(term, til::inclusive_rect({ 0, 10, 99, 10 }",13,<empty>,,645,285,CPPASTProblemDeclaration,,<empty>
291239,UNKNOWN,286,,));,83,<empty>,,645,286,CPPASTProblemDeclaration,,<empty>
291240,UNKNOWN,287,,},9,<empty>,,646,287,CPPASTProblemDeclaration,,<empty>
291241,UNKNOWN,288,,"TEST_METHOD(TripleClickDrag_Vertical)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,648,288,CPPASTProblemDeclaration,,<empty>
291248,UNKNOWN,291,,"term.Create({ 100, 100 }",13,<empty>,,652,291,CPPASTProblemDeclaration,,<empty>
291249,UNKNOWN,292,,", 0, renderer);",37,<empty>,,652,292,CPPASTProblemDeclaration,,<empty>
291257,UNKNOWN,295,,"term.MultiClickSelection(clickPos, Terminal::SelectionExpansion::Line);",13,<empty>,,656,295,CPPASTProblemDeclaration,,<empty>
291258,UNKNOWN,296,,"term.SetSelectionEnd({ 5, 11 }",13,<empty>,,659,296,CPPASTProblemDeclaration,,<empty>
291259,UNKNOWN,297,,);,43,<empty>,,659,297,CPPASTProblemDeclaration,,<empty>
291267,UNKNOWN,300,,"VERIFY_ARE_EQUAL(selectionRects.size(), static_cast<size_t>(2));",13,<empty>,,665,300,CPPASTProblemDeclaration,,<empty>
291286,UNKNOWN,303,,"VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 0, 10, 99, 10 }",13,<empty>,,669,303,CPPASTProblemDeclaration,,<empty>
291287,UNKNOWN,304,,));,78,<empty>,,669,304,CPPASTProblemDeclaration,,<empty>
291288,UNKNOWN,305,,selection = term.GetViewport().ConvertToOrigin(selectionRects.at(1)).ToInclusive();,13,<empty>,,672,305,CPPASTProblemDeclaration,,<empty>
291289,UNKNOWN,306,,"VERIFY_ARE_EQUAL(selection, til::inclusive_rect({ 0, 11, 99, 11 }",13,<empty>,,673,306,CPPASTProblemDeclaration,,<empty>
291290,UNKNOWN,307,,));,78,<empty>,,673,307,CPPASTProblemDeclaration,,<empty>
291291,UNKNOWN,308,,},9,<empty>,,674,308,CPPASTProblemDeclaration,,<empty>
291292,UNKNOWN,309,,"TEST_METHOD(ShiftClick)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,676,309,CPPASTProblemDeclaration,,<empty>
291299,UNKNOWN,312,,"term.Create({ 100, 100 }",13,<empty>,,680,312,CPPASTProblemDeclaration,,<empty>
291300,UNKNOWN,313,,", 0, renderer);",37,<empty>,,680,313,CPPASTProblemDeclaration,,<empty>
291315,UNKNOWN,316,,term.UpdateSettings(settings);,13,<empty>,,684,316,CPPASTProblemDeclaration,,<empty>
291320,UNKNOWN,319,,"term.GetTextBuffer().GetCursor().SetPosition({ 4, 10 }",13,<empty>,,688,319,CPPASTProblemDeclaration,,<empty>
291321,UNKNOWN,320,,);,67,<empty>,,688,320,CPPASTProblemDeclaration,,<empty>
291322,UNKNOWN,321,,term.Write(text);,13,<empty>,,689,321,CPPASTProblemDeclaration,,<empty>
291323,UNKNOWN,322,,"{
                // Simulate double click at (x,y) = (5,10)
                term.MultiClickSelection({ 5, 10 }, Terminal::SelectionExpansion::Word);

                // Validate selection area: ""doubleClickMe"" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 16, 10 }));
            }",13,<empty>,,692,322,CPPASTProblemDeclaration,,<empty>
291324,UNKNOWN,323,,"{
                // Simulate Shift+Click at (x,y) = (21,10)
                //
                // buffer: doubleClickMe dragThroughHere
                //         ^                ^
                //       start            finish
                term.SetSelectionEnd({ 21, 10 }, Terminal::SelectionExpansion::Char);

                // Validate selection area: ""doubleClickMe drag"" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 21, 10 }));
            }",13,<empty>,,701,323,CPPASTProblemDeclaration,,<empty>
291325,UNKNOWN,324,,"{
                // Simulate Shift+DoubleClick at (x,y) = (21,10)
                //
                // buffer: doubleClickMe dragThroughHere
                //         ^                ^          ^
                //       start            click      finish
                term.SetSelectionEnd({ 21, 10 }, Terminal::SelectionExpansion::Word);

                // Validate selection area: ""doubleClickMe dragThroughHere"" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }));
            }",13,<empty>,,714,324,CPPASTProblemDeclaration,,<empty>
291326,UNKNOWN,325,,"{
                // Simulate Shift+TripleClick at (x,y) = (21,10)
                //
                // buffer: doubleClickMe dragThroughHere     |
                //         ^                ^                ^
                //       start            click            finish (boundary)
                term.SetSelectionEnd({ 21, 10 }, Terminal::SelectionExpansion::Line);

                // Validate selection area: ""doubleClickMe dragThroughHere..."" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 99, 10 }));
            }",13,<empty>,,727,325,CPPASTProblemDeclaration,,<empty>
291327,UNKNOWN,326,,"{
                // Simulate Shift+DoubleClick at (x,y) = (21,10)
                //
                // buffer: doubleClickMe dragThroughHere
                //         ^                ^          ^
                //       start            click      finish
                term.SetSelectionEnd({ 21, 10 }, Terminal::SelectionExpansion::Word);

                // Validate selection area: ""doubleClickMe dragThroughHere"" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }));
            }",13,<empty>,,740,326,CPPASTProblemDeclaration,,<empty>
291328,UNKNOWN,327,,"{
                // Simulate drag to (x,y) = (35,10)
                // Since we were preceded by a double-click, we're in ""word"" expansion mode
                //
                // buffer: doubleClickMe dragThroughHere     |
                //         ^                                 ^
                //       start                             finish (boundary)
                term.SetSelectionEnd({ 35, 10 });

                // Validate selection area: ""doubleClickMe dragThroughHere..."" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 99, 10 }));
            }",13,<empty>,,753,327,CPPASTProblemDeclaration,,<empty>
291329,UNKNOWN,328,,"{
                // Simulate drag to (x,y) = (21,10)
                //
                // buffer: doubleClickMe dragThroughHere
                //         ^                ^          ^
                //       start             drag      finish
                term.SetSelectionEnd({ 21, 10 });

                // Validate selection area: ""doubleClickMe dragThroughHere"" selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }));
            }",13,<empty>,,767,328,CPPASTProblemDeclaration,,<empty>
291330,UNKNOWN,329,,"{
                // Simulate drag to (x,y) = (25,10)
                //
                // buffer: doubleClickMe dragThroughHere
                //         ^                    ^      ^
                //       start                 drag  finish
                term.SetSelectionEnd({ 25, 10 });

                // Validate selection area: ""doubleClickMe dragThroughHere"" still selected
                ValidateSingleRowSelection(term, til::inclusive_rect({ 4, 10, 32, 10 }));
            }",13,<empty>,,780,329,CPPASTProblemDeclaration,,<empty>
291331,UNKNOWN,330,,},9,<empty>,,791,330,CPPASTProblemDeclaration,,<empty>
291332,UNKNOWN,331,,"TEST_METHOD(Pivot)
        {
            Terminal term{ Terminal::TestDummyMarker{} };",9,<empty>,,793,331,CPPASTProblemDeclaration,,<empty>
291339,UNKNOWN,334,,"term.Create({ 100, 100 }",13,<empty>,,797,334,CPPASTProblemDeclaration,,<empty>
291340,UNKNOWN,335,,", 0, renderer);",37,<empty>,,797,335,CPPASTProblemDeclaration,,<empty>
291341,UNKNOWN,336,,"{
                // (10,10) to (20, 10)
                term.SelectNewRegion({ 10, 10 }, { 20, 10 });

                // Validate selection area
                ValidateSingleRowSelection(term, til::inclusive_rect({ 10, 10, 20, 10 }));
            }",13,<empty>,,800,336,CPPASTProblemDeclaration,,<empty>
291342,UNKNOWN,337,,"{
                term.SetSelectionEnd({ 5, 10 });

                // Validate selection area
                // NOTE: Pivot should be (10, 10)
                ValidateSingleRowSelection(term, til::inclusive_rect({ 5, 10, 10, 10 }));
            }",13,<empty>,,809,337,CPPASTProblemDeclaration,,<empty>
291343,UNKNOWN,338,,"{
                term.SetSelectionEnd({ 20, 10 });

                // Validate selection area
                // NOTE: Pivot should still be (10, 10)
                ValidateSingleRowSelection(term, til::inclusive_rect({ 10, 10, 20, 10 }));
            }",13,<empty>,,818,338,CPPASTProblemDeclaration,,<empty>
291344,UNKNOWN,339,,"{
                term.SetSelectionEnd({ 5, 10 }, Terminal::SelectionExpansion::Char);

                // Validate selection area
                // NOTE: Pivot should still be (10, 10)
                ValidateSingleRowSelection(term, til::inclusive_rect({ 5, 10, 10, 10 }));
            }",13,<empty>,,827,339,CPPASTProblemDeclaration,,<empty>
291345,UNKNOWN,340,,"{
                term.SetSelectionEnd({ 20, 10 }, Terminal::SelectionExpansion::Char);

                // Validate selection area
                // NOTE: Pivot should still be (10, 10)
                ValidateSingleRowSelection(term, til::inclusive_rect({ 10, 10, 20, 10 }));
            }",13,<empty>,,836,340,CPPASTProblemDeclaration,,<empty>
291346,UNKNOWN,341,,},9,<empty>,,843,341,CPPASTProblemDeclaration,,<empty>
291347,UNKNOWN,342,,};,5,<empty>,,844,342,CPPASTProblemDeclaration,,<empty>
291348,UNKNOWN,343,,},1,<empty>,,845,343,CPPASTProblemDeclaration,,<empty>
291358,UNKNOWN,1,,Baton*,51,<empty>,,98,1,CPPASTTypeId,,<empty>
293236,UNKNOWN,3,,"private:
    void _SetTabStops(std::list<til::CoordType> columns, bool replace);",1,<empty>,,72,3,CPPASTProblemDeclaration,,<empty>
293243,UNKNOWN,7,,};,1,<empty>,,78,7,CPPASTProblemDeclaration,,<empty>
293389,UNKNOWN,1,,wchar_t,38,<empty>,,115,1,CPPASTTypeId,,<empty>
295353,UNKNOWN,1,,bool,22,<empty>,,84,1,CPPASTTypeId,,<empty>
295359,UNKNOWN,1,,bool,22,<empty>,,87,1,CPPASTTypeId,,<empty>
295363,UNKNOWN,1,,bool,22,<empty>,,89,1,CPPASTTypeId,,<empty>
295377,UNKNOWN,1,,bool,21,<empty>,,94,1,CPPASTTypeId,,<empty>
295385,UNKNOWN,1,,bool,21,<empty>,,98,1,CPPASTTypeId,,<empty>
295389,UNKNOWN,1,,bool,21,<empty>,,100,1,CPPASTTypeId,,<empty>
295707,UNKNOWN,2,,"static ScopedResourceLoader GetLibraryResourceLoader()
try
{
    ScopedResourceLoader loader{ g_WinRTUtilsLibraryResourceScope };
#ifdef _DEBUG
    EnsureAllResourcesArePresent(loader);
#endif
    return loader;
}
CATCH_FAIL_FAST()

winrt::hstring GetLibraryResourceString(const std::wstring_view key)
try
{
    static auto loader{ GetLibraryResourceLoader() };
    return loader.GetLocalizedString(key);
}",1,<empty>,,79,2,CPPASTProblemDeclaration,,<empty>
295708,UNKNOWN,3,,"CATCH_FAIL_FAST()

bool HasLibraryResourceWithName(const std::wstring_view key)
try
{
    static auto loader{ GetLibraryResourceLoader() };
    return loader.HasResourceWithName(key);
}",1,<empty>,,96,3,CPPASTProblemDeclaration,,<empty>
295709,UNKNOWN,4,,CATCH_FAIL_FAST(),1,<empty>,,104,4,CPPASTProblemDeclaration,,<empty>
295766,UNKNOWN,-1,,"try
        {
            auto pictureFolderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_PicturesLibrary, KF_FLAG_DEFAULT, nullptr) };
            dialog->SetDefaultFolder(pictureFolderShellItem.get());
        }
        CATCH_LOG();",9,<empty>,,21,2,CPPASTProblemStatement,,<empty>
296055,UNKNOWN,-1,,"try
                    {
                        self->_func();
                    }
                    CATCH_LOG();",21,<empty>,,87,1,CPPASTProblemStatement,,<empty>
296086,UNKNOWN,-1,,"try
                    {
                        std::apply(self->_func, self->_storage.take());
                    }
                    CATCH_LOG();",21,<empty>,,114,1,CPPASTProblemStatement,,<empty>
296189,UNKNOWN,1,,ThrottledFunc*,21,<empty>,,77,1,CPPASTTypeId,,<empty>
296458,UNKNOWN,-1,,"try
            {
                const auto package = winrt::Windows::ApplicationModel::Package::Current();
                const auto id = package.Id();
                const auto name = id.FullName();
                return til::starts_with(name, L""WindowsTerminalDev"");
            }
            CATCH_LOG();",13,<empty>,,39,1,CPPASTProblemStatement,,<empty>
296469,UNKNOWN,-1,,"try
            {
                const auto package = winrt::Windows::ApplicationModel::Package::Current();
                const auto id = package.Id();
                const auto pfn = id.FamilyName();
                if (!pfn.empty())
                {
                    const std::filesystem::path windowsAppsPath{ wil::ExpandEnvironmentStringsW<std::wstring>(LocalAppDataAppsPath.data()) };
                    const auto wtPath = windowsAppsPath / std::wstring_view{ pfn } / (IsDevBuild() ? WtdExe : WtExe);
                    return wtPath;
                }
            }
            CATCH_LOG();",13,<empty>,,78,1,CPPASTProblemStatement,,<empty>
296470,UNKNOWN,-1,,"try
        {
            std::filesystem::path module = wil::GetModuleFileNameW<std::wstring>(nullptr);
            module.replace_filename(WindowsTerminalExe);
            return module;
        }
        CATCH_LOG();",9,<empty>,,96,2,CPPASTProblemStatement,,<empty>
296506,UNKNOWN,11,,_TIL_INLINEPREFIX,1,<empty>,,7,11,CPPASTProblemDeclaration,,<empty>
296518,UNKNOWN,13,,_TIL_INLINEPREFIX,1,<empty>,,33,13,CPPASTProblemDeclaration,,<empty>
296530,UNKNOWN,15,,_TIL_INLINEPREFIX,1,<empty>,,65,15,CPPASTProblemDeclaration,,<empty>
296542,UNKNOWN,17,,_TIL_INLINEPREFIX,1,<empty>,,117,17,CPPASTProblemDeclaration,,<empty>
296742,UNKNOWN,1,,bool*,58,<empty>,,653,1,CPPASTTypeId,,<empty>
298087,UNKNOWN,1,,::IUnknown*,66,<empty>,,408,1,CPPASTTypeId,,<empty>
298391,UNKNOWN,-1,,"try
    {
        // Get the position of the current window. This includes the
        // non-client already.
        const auto window = _window->GetWindowRect();

        const auto dpi = _window->GetCurrentDpi();
        const auto nonClientArea = _window->GetNonClientFrame(dpi);

        // The nonClientArea adjustment is negative, so subtract that out.
        // This way we save the user-visible location of the terminal.
        pos.X = window.left - nonClientArea.left;
        pos.Y = window.top;
    }
    CATCH_LOG();",5,<empty>,,563,4,CPPASTProblemStatement,,<empty>
298556,UNKNOWN,1,,LPARAM,26,<empty>,,658,1,CPPASTTypeId,,<empty>
298799,UNKNOWN,1,,NonClientIslandWindow*,43,<empty>,,755,1,CPPASTTypeId,,<empty>
299007,UNKNOWN,-1,,"try
                {
                    // Translate the event to the coordinate space of the control
                    // we're attempting to dispatch it to
                    const auto transform = e.TransformToVisual(nullptr);
                    const til::point controlOrigin{ til::math::flooring, transform.TransformPoint({}) };

                    const auto offsetPoint = coord - controlOrigin;

                    const auto lButtonDown = WI_IsFlagSet(GetKeyState(VK_LBUTTON), KeyPressed);
                    const auto mButtonDown = WI_IsFlagSet(GetKeyState(VK_MBUTTON), KeyPressed);
                    const auto rButtonDown = WI_IsFlagSet(GetKeyState(VK_RBUTTON), KeyPressed);

                    if (control.OnMouseWheel(offsetPoint.to_winrt_point(), delta, lButtonDown, mButtonDown, rButtonDown))
                    {
                        // If the element handled the mouse wheel event, don't
                        // continue to iterate over the remaining controls....",17,<empty>,,861,1,CPPASTProblemStatement,,<empty>
299142,UNKNOWN,1,,uint64_t,26,<empty>,,949,1,CPPASTTypeId,,<empty>
299190,UNKNOWN,-1,,"try
    {
        const auto pos = _GetWindowLaunchPosition();
        layoutJson = _windowLogic.GetWindowLayoutJson(pos);
    }
    CATCH_LOG()

    co_return layoutJson;",5,<empty>,,981,10,CPPASTProblemStatement,,<empty>
300027,UNKNOWN,1,,NonClientIslandWindow*,47,<empty>,,1385,1,CPPASTTypeId,,<empty>
300562,UNKNOWN,-1,,"WINRT_CALLBACK(UpdateSettingsRequested, winrt::delegate<void()>);",5,<empty>,,36,12,CPPASTProblemDeclaration,,<empty>
300951,UNKNOWN,1,,T*,33,<empty>,,16,1,CPPASTTypeId,,<empty>
300974,UNKNOWN,1,,CREATESTRUCT*,40,<empty>,,25,1,CPPASTTypeId,,<empty>
300980,UNKNOWN,1,,T*,35,<empty>,,26,1,CPPASTTypeId,,<empty>
301158,UNKNOWN,1,,RECT*,50,<empty>,,110,1,CPPASTTypeId,,<empty>
301271,UNKNOWN,1,,float,40,<empty>,,144,1,CPPASTTypeId,,<empty>
301274,UNKNOWN,1,,float,66,<empty>,,144,1,CPPASTTypeId,,<empty>
301379,UNKNOWN,1,,LPARAM,74,<empty>,,190,1,CPPASTTypeId,,<empty>
301409,UNKNOWN,1,,LONG_PTR,73,<empty>,,215,1,CPPASTTypeId,,<empty>
301630,UNKNOWN,1,,HINSTANCE,37,<empty>,,106,1,CPPASTTypeId,,<empty>
301721,UNKNOWN,1,,CREATESTRUCTW*,33,<empty>,,186,1,CPPASTTypeId,,<empty>
301801,UNKNOWN,1,,LPRECT,37,<empty>,,229,1,CPPASTTypeId,,<empty>
302034,UNKNOWN,1,,LPRECT,37,<empty>,,325,1,CPPASTTypeId,,<empty>
302266,UNKNOWN,1,,LPMINMAXINFO,42,<empty>,,474,1,CPPASTTypeId,,<empty>
302526,UNKNOWN,-1,,"try
        {
            // This whole handler is a hack for GH#979.
            //
            // On some laptops, their trackpads won't scroll inactive windows
            // _ever_. With our entire window just being one giant XAML Island, the
            // touchpad driver thinks our entire window is inactive, and won't
            // scroll the XAML island. On those types of laptops, we'll get a
            // WM_MOUSEWHEEL here, in our root window, when the trackpad scrolls.
            // We're going to take that message and manually plumb it through to our
            // TermControl's, or anything else that implements IMouseWheelListener.

            // https://msdn.microsoft.com/en-us/library/windows/desktop/ms645617(v=vs.85).aspx
            // Important! Do not use the LOWORD or HIWORD macros to extract the x-
            // and y- coordinates of the cursor position because these macros return
            // incorrect results on systems with multiple monitors. Systems wi...",9,<empty>,,624,50,CPPASTProblemStatement,,<empty>
302547,UNKNOWN,1,,LPWINDOWPOS,28,<empty>,,669,1,CPPASTTypeId,,<empty>
302757,UNKNOWN,1,,wchar_t*,40,<empty>,,746,1,CPPASTTypeId,,<empty>
302859,UNKNOWN,1,,DWORD,42,<empty>,,862,1,CPPASTTypeId,,<empty>
304738,UNKNOWN,1,,LPWSTR,34,<empty>,,1887,1,CPPASTTypeId,,<empty>
304748,UNKNOWN,1,,UINT,28,<empty>,,1888,1,CPPASTTypeId,,<empty>
305131,UNKNOWN,-1,,"WINRT_CALLBACK(DragRegionClicked, winrt::delegate<>);",5,<empty>,,75,38,CPPASTProblemDeclaration,,<empty>
305132,UNKNOWN,-1,,"WINRT_CALLBACK(WindowCloseButtonClicked, winrt::delegate<>);",5,<empty>,,76,39,CPPASTProblemDeclaration,,<empty>
305133,UNKNOWN,-1,,"WINRT_CALLBACK(MouseScrolled, winrt::delegate<void(til::point, int32_t)>);",5,<empty>,,77,40,CPPASTProblemDeclaration,,<empty>
305134,UNKNOWN,-1,,"WINRT_CALLBACK(WindowActivated, winrt::delegate<void(bool)>);",5,<empty>,,78,41,CPPASTProblemDeclaration,,<empty>
305135,UNKNOWN,-1,,"WINRT_CALLBACK(NotifyNotificationIconPressed, winrt::delegate<void()>);",5,<empty>,,79,42,CPPASTProblemDeclaration,,<empty>
305136,UNKNOWN,-1,,"WINRT_CALLBACK(NotifyWindowHidden, winrt::delegate<void()>);",5,<empty>,,80,43,CPPASTProblemDeclaration,,<empty>
305137,UNKNOWN,-1,,"WINRT_CALLBACK(NotifyShowNotificationIconContextMenu, winrt::delegate<void(til::point)>);",5,<empty>,,81,44,CPPASTProblemDeclaration,,<empty>
305138,UNKNOWN,-1,,"WINRT_CALLBACK(NotifyNotificationIconMenuItemSelected, winrt::delegate<void(HMENU, UINT)>);",5,<empty>,,82,45,CPPASTProblemDeclaration,,<empty>
305139,UNKNOWN,-1,,"WINRT_CALLBACK(NotifyReAddNotificationIcon, winrt::delegate<void()>);",5,<empty>,,83,46,CPPASTProblemDeclaration,,<empty>
305140,UNKNOWN,-1,,"WINRT_CALLBACK(ShouldExitFullscreen, winrt::delegate<void()>);",5,<empty>,,84,47,CPPASTProblemDeclaration,,<empty>
305141,UNKNOWN,-1,,"WINRT_CALLBACK(MaximizeChanged, winrt::delegate<void(bool)>);",5,<empty>,,85,48,CPPASTProblemDeclaration,,<empty>
305142,UNKNOWN,-1,,"WINRT_CALLBACK(AutomaticShutdownRequested, winrt::delegate<void(void)>);",5,<empty>,,86,49,CPPASTProblemDeclaration,,<empty>
305143,UNKNOWN,-1,,"WINRT_CALLBACK(WindowMoved, winrt::delegate<void()>);",5,<empty>,,88,50,CPPASTProblemDeclaration,,<empty>
305144,UNKNOWN,-1,,"WINRT_CALLBACK(WindowVisibilityChanged, winrt::delegate<void(bool)>);",5,<empty>,,89,51,CPPASTProblemDeclaration,,<empty>
305145,UNKNOWN,-1,,"WINRT_CALLBACK(UpdateSettingsRequested, winrt::delegate<void()>);",5,<empty>,,90,52,CPPASTProblemDeclaration,,<empty>
305405,UNKNOWN,1,,HBRUSH,47,<empty>,,78,1,CPPASTTypeId,,<empty>
305484,UNKNOWN,1,,HWND,34,<empty>,,693,1,CPPASTTypeId,,<empty>
305558,UNKNOWN,1,,CREATESTRUCT*,36,<empty>,,50,1,CPPASTTypeId,,<empty>
305565,UNKNOWN,1,,NonClientIslandWindow*,54,<empty>,,51,1,CPPASTTypeId,,<empty>
305573,UNKNOWN,1,,LONG_PTR,66,<empty>,,52,1,CPPASTTypeId,,<empty>
305584,UNKNOWN,1,,NonClientIslandWindow*,59,<empty>,,55,1,CPPASTTypeId,,<empty>
305808,UNKNOWN,1,,winrt::TerminalApp::CaptionButton,47,<empty>,,200,1,CPPASTTypeId,,<empty>
305916,UNKNOWN,1,,winrt::TerminalApp::CaptionButton,47,<empty>,,261,1,CPPASTTypeId,,<empty>
305958,UNKNOWN,1,,winrt::TerminalApp::CaptionButton,47,<empty>,,290,1,CPPASTTypeId,,<empty>
306149,UNKNOWN,1,,uint64_t,71,<empty>,,376,1,CPPASTTypeId,,<empty>
306335,UNKNOWN,1,,float,25,<empty>,,476,1,CPPASTTypeId,,<empty>
306341,UNKNOWN,1,,float,25,<empty>,,477,1,CPPASTTypeId,,<empty>
306463,UNKNOWN,-1,,"try
        {
            _titlebar.SetWindowVisualState(state);
        }
        CATCH_LOG();",9,<empty>,,553,7,CPPASTProblemStatement,,<empty>
306562,UNKNOWN,1,,NCCALCSIZE_PARAMS*,36,<empty>,,632,1,CPPASTTypeId,,<empty>
306670,UNKNOWN,1,,UINT,23,<empty>,,683,1,CPPASTTypeId,,<empty>
306904,UNKNOWN,1,,DWORD,42,<empty>,,855,1,CPPASTTypeId,,<empty>
306947,UNKNOWN,1,,LONG,57,<empty>,,879,1,CPPASTTypeId,,<empty>
307745,UNKNOWN,1,,HICON,28,<empty>,,34,1,CPPASTTypeId,,<empty>
307833,UNKNOWN,1,,HICON,29,<empty>,,89,1,CPPASTTypeId,,<empty>
308091,UNKNOWN,1,,UINT_PTR,39,<empty>,,186,1,CPPASTTypeId,,<empty>
308103,UNKNOWN,1,,UINT_PTR,42,<empty>,,189,1,CPPASTTypeId,,<empty>
308366,UNKNOWN,-1,,"WINRT_CALLBACK(SummonWindowRequested, winrt::delegate<void(winrt::Microsoft::Terminal::Remoting::SummonWindowSelectionArgs)>);",5,<empty>,,30,10,CPPASTProblemDeclaration,,<empty>
308448,UNKNOWN,1,,BYTE*,116,<empty>,,36,1,CPPASTTypeId,,<empty>
308532,UNKNOWN,1,,BYTE*,116,<empty>,,64,1,CPPASTTypeId,,<empty>
308639,UNKNOWN,1,,GUID*,42,<empty>,,96,1,CPPASTTypeId,,<empty>
308857,UNKNOWN,-1,,"try
        {
            window->CreateHost();

            if (auto self{ weakThis.lock() })
            {
                self->_windowStartedHandlerPostXAML(window);
            }
            while (window->KeepWarm())
            {
                // Now that the window is ready to go, we can add it to our list of windows,
                // because we know it will be well behaved.
                //
                // Be sure to only modify the list of windows under lock.

                if (auto self{ weakThis.lock() })
                {
                    auto lockedWindows{ self->_windows.lock() };
                    lockedWindows->push_back(window);
                }
                auto removeWindow = wil::scope_exit([&]() {
                    if (auto self{ weakThis.lock() })
                    {
                        self->_removeWindow(window->PeasantID());
                    }
                });

                auto decrementWindowCount = wil::scope_exit([&]...",9,<empty>,,185,1,CPPASTProblemStatement,,<empty>
309683,UNKNOWN,1,,WindowEmperor*,29,<empty>,,465,1,CPPASTTypeId,,<empty>
309704,UNKNOWN,1,,CREATESTRUCT*,36,<empty>,,473,1,CPPASTTypeId,,<empty>
309710,UNKNOWN,1,,WindowEmperor*,43,<empty>,,474,1,CPPASTTypeId,,<empty>
309739,UNKNOWN,1,,LONG_PTR,79,<empty>,,478,1,CPPASTTypeId,,<empty>
309785,UNKNOWN,1,,HINSTANCE,37,<empty>,,491,1,CPPASTTypeId,,<empty>
309864,UNKNOWN,1,,long,36,<empty>,,522,1,CPPASTTypeId,,<empty>
309921,UNKNOWN,1,,HMENU,46,<empty>,,546,1,CPPASTTypeId,,<empty>
309924,UNKNOWN,1,,UINT,61,<empty>,,546,1,CPPASTTypeId,,<empty>
310054,UNKNOWN,1,,size_t,40,<empty>,,623,1,CPPASTTypeId,,<empty>
311268,UNKNOWN,-1,,"WINRT_CALLBACK(UpdateSettingsRequested, winrt::delegate<void()>);",5,<empty>,,28,10,CPPASTProblemDeclaration,,<empty>
311437,UNKNOWN,1,,LPARAM,71,<empty>,,50,1,CPPASTTypeId,,<empty>
311452,UNKNOWN,1,,LPARAM,69,<empty>,,54,1,CPPASTTypeId,,<empty>
311488,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_hWindowsTerminalProvider,
    ""Microsoft.Windows.Terminal.Win32Host"",
    // {56c06166-2e2e-5f4d-7ff3-74f4b78c87d6}
    (0x56c06166, 0x2e2e, 0x5f4d, 0x7f, 0xf3, 0x74, 0xf4, 0xb7, 0x8c, 0x87, 0xd6),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,18,1,CPPASTProblemDeclaration,,<empty>
311489,UNKNOWN,2,,"UTILS_DEFINE_LIBRARY_RESOURCE_SCOPE(L""TerminalApp/Resources"");",1,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
311862,UNKNOWN,1,,void**,53,<empty>,,186,1,CPPASTTypeId,,<empty>
311955,UNKNOWN,-1,,),42,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
311956,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""ActivationContext"", L""TerminalApp.Unit.Tests.manifest"")
        END_TEST_CLASS()

        TEST_METHOD(ConvertRgbToHsl);",13,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
312622,UNKNOWN,5,,"JSON_ENUM_MAPPER(JsonTestEnum)
{
    JSON_MAPPINGS(5) = {
        pair_type{ ""first"", JsonTestEnum::First }, // DEFAULT
        pair_type{ ""second"", JsonTestEnum::Second },
        pair_type{ ""third"", JsonTestEnum::Third },
        pair_type{ ""fourth"", JsonTestEnum::Fourth },
        pair_type{ ""fifth"", JsonTestEnum::Fifth },
    };
};",1,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
312668,UNKNOWN,8,,"JSON_FLAG_MAPPER(JsonTestFlags)
{
    JSON_MAPPINGS(7) = {
        pair_type{ ""none"", AllClear },
        pair_type{ ""first"", JsonTestFlags::First },
        pair_type{ ""second"", JsonTestFlags::Second },
        pair_type{ ""third"", JsonTestFlags::Third },
        pair_type{ ""fourth"", JsonTestFlags::Fourth },
        pair_type{ ""fifth"", JsonTestFlags::Fifth },
        pair_type{ ""all"", AllSet },
    };
};",1,<empty>,,91,8,CPPASTProblemDeclaration,,<empty>
314105,UNKNOWN,1,,bool,36,<empty>,,619,1,CPPASTTypeId,,<empty>
314120,UNKNOWN,1,,bool,36,<empty>,,623,1,CPPASTTypeId,,<empty>
314124,UNKNOWN,1,,bool,36,<empty>,,624,1,CPPASTTypeId,,<empty>
315200,UNKNOWN,39,,"void ConsoleArguments::s_ConsumeArg(_Inout_ std::vector<std::wstring>& args, _In_ size_t& index)
{
    args.erase(args.begin() + index);
}",1,<empty>,,164,39,CPPASTProblemDeclaration,,<empty>
315201,UNKNOWN,40,,"[[nodiscard]] HRESULT ConsoleArguments::s_GetArgumentValue(_Inout_ std::vector<std::wstring>& args,
                                                           _Inout_ size_t& index,
                                                           _Out_opt_ std::wstring* const pSetting)
{
    auto hasNext = (index + 1) < args.size();
    if (hasNext)
    {
        s_ConsumeArg(args, index);
        if (pSetting != nullptr)
        {
            *pSetting = args[index];
        }
        s_ConsumeArg(args, index);
    }
    return (hasNext) ? S_OK : E_INVALIDARG;
}",1,<empty>,,191,40,CPPASTProblemDeclaration,,<empty>
315202,UNKNOWN,41,,"[[nodiscard]] HRESULT ConsoleArguments::s_HandleFeatureValue(_Inout_ std::vector<std::wstring>& args, _Inout_ size_t& index)
{
    auto hr = E_INVALIDARG;
    auto hasNext = (index + 1) < args.size();
    if (hasNext)
    {
        s_ConsumeArg(args, index);
        auto value = args[index];
        if (value == FEATURE_PTY_ARG)
        {
            hr = S_OK;
        }
        s_ConsumeArg(args, index);
    }
    return (hasNext) ? hr : E_INVALIDARG;
}",1,<empty>,,222,41,CPPASTProblemDeclaration,,<empty>
315203,UNKNOWN,42,,"[[nodiscard]] HRESULT ConsoleArguments::s_GetArgumentValue(_Inout_ std::vector<std::wstring>& args,
                                                           _Inout_ size_t& index,
                                                           _Out_opt_ short* const pSetting)
{
    auto succeeded = (index + 1) < args.size();
    if (succeeded)
    {
        s_ConsumeArg(args, index);
        if (pSetting != nullptr)
        {
            try
            {
                size_t pos = 0;
                auto value = std::stoi(args[index], &pos);
                // If the entire string was a number, pos will be equal to the
                //      length of the string. Otherwise, a string like 8foo will
                //       be parsed as ""8""
                if (value > SHORT_MAX || pos != args[index].length())
                {
                    succeeded = false;
                }
                else
                {
                    *pSetting = static_cast<short>(value);
    ...",1,<empty>,,252,42,CPPASTProblemDeclaration,,<empty>
315204,UNKNOWN,43,,"[[nodiscard]] HRESULT ConsoleArguments::s_ParseHandleArg(const std::wstring& handleAsText, _Inout_ DWORD& handleAsVal)
{
    auto hr = S_OK;

    // The handle should have a valid prefix.
    if (handleAsText.substr(0, HANDLE_PREFIX.length()) != HANDLE_PREFIX)
    {
        hr = E_INVALIDARG;
    }
    else if (0 == handleAsVal)
    {
        handleAsVal = wcstoul(handleAsText.c_str(), nullptr /*endptr*/, 16 /*base*/);

        // If the handle didn't parse into a reasonable handle ID, invalid.
        if (handleAsVal == 0)
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // If we're trying to set the handle a second time, invalid.
        hr = E_INVALIDARG;
    }

    return hr;
}",1,<empty>,,298,43,CPPASTProblemDeclaration,,<empty>
315205,UNKNOWN,44,,"[[nodiscard]] HRESULT ConsoleArguments::_GetClientCommandline(_Inout_ std::vector<std::wstring>& args, const size_t index, const bool skipFirst)
{
    auto start = args.begin() + index;

    // Erase the first token.
    //  Used to get rid of the explicit commandline token ""--""
    if (skipFirst)
    {
        // Make sure that the arg we're deleting is ""--""
        FAIL_FAST_IF(!(CLIENT_COMMANDLINE_ARG == start->c_str()));
        args.erase(start);
    }

    _clientCommandline = L"""";
    size_t j = 0;
    for (j = index; j < args.size(); j++)
    {
        _clientCommandline += EscapeArgument(args[j]); // escape commandline
        if (j + 1 < args.size())
        {
            _clientCommandline += L"" "";
        }
    }
    args.erase(args.begin() + index, args.begin() + j);

    return S_OK;
}",1,<empty>,,341,44,CPPASTProblemDeclaration,,<empty>
315905,UNKNOWN,-1,,"[[nodiscard]] HRESULT _GetClientCommandline(_Inout_ std::vector<std::wstring>& args,
                                                const size_t index,
                                                const bool skipFirst);",5,<empty>,,146,61,CPPASTProblemDeclaration,,<empty>
315906,UNKNOWN,-1,,"static void s_ConsumeArg(_Inout_ std::vector<std::wstring>& args,
                             _In_ size_t& index);",5,<empty>,,150,62,CPPASTProblemDeclaration,,<empty>
315907,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetArgumentValue(_Inout_ std::vector<std::wstring>& args,
                                                    _Inout_ size_t& index,
                                                    _Out_opt_ std::wstring* const pSetting);",5,<empty>,,152,63,CPPASTProblemDeclaration,,<empty>
315908,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetArgumentValue(_Inout_ std::vector<std::wstring>& args,
                                                    _Inout_ size_t& index,
                                                    _Out_opt_ short* const pSetting);",5,<empty>,,155,64,CPPASTProblemDeclaration,,<empty>
315909,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_HandleFeatureValue(_Inout_ std::vector<std::wstring>& args,
                                                      _Inout_ size_t& index);",5,<empty>,,158,65,CPPASTProblemDeclaration,,<empty>
315910,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_ParseHandleArg(const std::wstring& handleAsText,
                                                  _Inout_ DWORD& handleAsVal);",5,<empty>,,161,66,CPPASTProblemDeclaration,,<empty>
315935,UNKNOWN,1,,"static void CALLBACK CursorTimerRoutineWrapper(_Inout_ PTP_CALLBACK_INSTANCE /*Instance*/, _Inout_opt_ PVOID /*Context*/, _Inout_ PTP_TIMER /*Timer*/)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    // There's a slight race condition here.
    // CreateThreadpoolTimer callbacks may be scheduled even after they were canceled.
    // But I'm not too concerned that this will lead to issues at the time of writing,
    // as CursorBlinker is allocated as a static variable through the Globals class.
    // It'd be nice to fix this, but realistically it'll likely not lead to issues.
    gci.LockConsole();
    gci.GetCursorBlinker().TimerRoutine(gci.GetActiveOutputBuffer());
    gci.UnlockConsole();
}",1,<empty>,,13,1,CPPASTProblemDeclaration,,<empty>
316331,UNKNOWN,1,,int64_t,42,<empty>,,173,1,CPPASTTypeId,,<empty>
316340,UNKNOWN,1,,FILETIME*,55,<empty>,,174,1,CPPASTTypeId,,<empty>
316474,UNKNOWN,3,,"DWORD WINAPI PtySignalInputThread::StaticThreadProc(_In_ LPVOID lpParameter)
{
    const auto pInstance = reinterpret_cast<PtySignalInputThread*>(lpParameter);
    return pInstance->_InputThread();
}",1,<empty>,,45,3,CPPASTProblemDeclaration,,<empty>
316505,UNKNOWN,1,,HWND,64,<empty>,,90,1,CPPASTTypeId,,<empty>
316518,UNKNOWN,6,,"[[nodiscard]] HRESULT PtySignalInputThread::_InputThread() noexcept
try
{
    const auto shutdown = wil::scope_exit([this]() {
        _Shutdown();
    });

    for (;;)
    {
        PtySignal signalId;
        if (!_GetData(&signalId, sizeof(signalId)))
        {
            return S_OK;
        }

        switch (signalId)
        {
        case PtySignal::ShowHideWindow:
        {
            ShowHideData msg = { 0 };
            if (!_GetData(&msg, sizeof(msg)))
            {
                return S_OK;
            }

            _DoShowHide(msg);
            break;
        }
        case PtySignal::ClearBuffer:
        {
            _DoClearBuffer();
            break;
        }
        case PtySignal::ResizeWindow:
        {
            ResizeWindowData resizeMsg = { 0 };
            if (!_GetData(&resizeMsg, sizeof(resizeMsg)))
            {
                return S_OK;
            }

            _DoResizeWindow(resizeMsg);
            break;
        }
        case PtySigna...",1,<empty>,,99,6,CPPASTProblemDeclaration,,<empty>
316609,UNKNOWN,1,,HWND,40,<empty>,,253,1,CPPASTTypeId,,<empty>
316636,UNKNOWN,1,,LONG_PTR,75,<empty>,,280,1,CPPASTTypeId,,<empty>
316640,UNKNOWN,10,,"[[nodiscard]] bool PtySignalInputThread::_GetData(_Out_writes_bytes_(cbBuffer) void* const pBuffer, const DWORD cbBuffer)
{
    if (!_hFile)
    {
        return false;
    }

    DWORD dwRead = 0;
    if (FALSE == ReadFile(_hFile.get(), pBuffer, cbBuffer, &dwRead, nullptr))
    {
        if (const auto err = GetLastError(); err != ERROR_BROKEN_PIPE)
        {
            LOG_WIN32(err);
        }
        _hFile.reset();
        return false;
    }

    if (dwRead != cbBuffer)
    {
        return false;
    }

    return true;
}",1,<empty>,,292,10,CPPASTProblemDeclaration,,<empty>
316715,UNKNOWN,-1,,PtySignalInputThread(_In_ wil::unique_hfile hPipe);,9,<empty>,,25,1,CPPASTProblemDeclaration,,<empty>
316724,UNKNOWN,-1,,static DWORD WINAPI StaticThreadProc(_In_ LPVOID lpParameter);,9,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
316775,UNKNOWN,-1,,"[[nodiscard]] bool _GetData(_Out_writes_bytes_(cbBuffer) void* const pBuffer, const DWORD cbBuffer);",9,<empty>,,64,14,CPPASTProblemDeclaration,,<empty>
316929,UNKNOWN,1,,void,10,<empty>,,103,1,CPPASTTypeId,,<empty>
316935,UNKNOWN,1,,void,10,<empty>,,104,1,CPPASTTypeId,,<empty>
317009,UNKNOWN,1,,void,10,<empty>,,141,1,CPPASTTypeId,,<empty>
317015,UNKNOWN,1,,void,10,<empty>,,142,1,CPPASTTypeId,,<empty>
317039,UNKNOWN,1,,void,10,<empty>,,155,1,CPPASTTypeId,,<empty>
317048,UNKNOWN,1,,void,10,<empty>,,159,1,CPPASTTypeId,,<empty>
317057,UNKNOWN,1,,void,6,<empty>,,162,1,CPPASTTypeId,,<empty>
317080,UNKNOWN,1,,void,6,<empty>,,173,1,CPPASTTypeId,,<empty>
317087,UNKNOWN,1,,void,6,<empty>,,174,1,CPPASTTypeId,,<empty>
317121,UNKNOWN,1,,void,6,<empty>,,190,1,CPPASTTypeId,,<empty>
317128,UNKNOWN,1,,void,6,<empty>,,191,1,CPPASTTypeId,,<empty>
317134,UNKNOWN,1,,BYTE,65,<empty>,,191,1,CPPASTTypeId,,<empty>
317138,UNKNOWN,1,,void,6,<empty>,,192,1,CPPASTTypeId,,<empty>
317144,UNKNOWN,1,,BYTE,65,<empty>,,192,1,CPPASTTypeId,,<empty>
317150,UNKNOWN,1,,void,6,<empty>,,193,1,CPPASTTypeId,,<empty>
317162,UNKNOWN,1,,void,6,<empty>,,194,1,CPPASTTypeId,,<empty>
317193,UNKNOWN,1,,void,10,<empty>,,209,1,CPPASTTypeId,,<empty>
317200,UNKNOWN,1,,void,10,<empty>,,210,1,CPPASTTypeId,,<empty>
317208,UNKNOWN,1,,void,10,<empty>,,211,1,CPPASTTypeId,,<empty>
317251,UNKNOWN,1,,void,6,<empty>,,229,1,CPPASTTypeId,,<empty>
317277,UNKNOWN,1,,void,10,<empty>,,236,1,CPPASTTypeId,,<empty>
317284,UNKNOWN,1,,void,6,<empty>,,239,1,CPPASTTypeId,,<empty>
317348,UNKNOWN,1,,void,18,<empty>,,283,1,CPPASTTypeId,,<empty>
317354,UNKNOWN,1,,void,53,<empty>,,283,1,CPPASTTypeId,,<empty>
317360,UNKNOWN,1,,void,6,<empty>,,284,1,CPPASTTypeId,,<empty>
317387,UNKNOWN,1,,void,6,<empty>,,299,1,CPPASTTypeId,,<empty>
317415,UNKNOWN,1,,void,6,<empty>,,300,1,CPPASTTypeId,,<empty>
317428,UNKNOWN,1,,void,6,<empty>,,301,1,CPPASTTypeId,,<empty>
317434,UNKNOWN,1,,BYTE,65,<empty>,,301,1,CPPASTTypeId,,<empty>
317440,UNKNOWN,1,,void,6,<empty>,,302,1,CPPASTTypeId,,<empty>
317446,UNKNOWN,1,,BYTE,65,<empty>,,302,1,CPPASTTypeId,,<empty>
317454,UNKNOWN,1,,void,6,<empty>,,306,1,CPPASTTypeId,,<empty>
317500,UNKNOWN,1,,void,10,<empty>,,327,1,CPPASTTypeId,,<empty>
317507,UNKNOWN,1,,void,10,<empty>,,328,1,CPPASTTypeId,,<empty>
317559,UNKNOWN,1,,void,6,<empty>,,366,1,CPPASTTypeId,,<empty>
317565,UNKNOWN,1,,BYTE,65,<empty>,,366,1,CPPASTTypeId,,<empty>
317569,UNKNOWN,1,,void,6,<empty>,,367,1,CPPASTTypeId,,<empty>
317575,UNKNOWN,1,,BYTE,65,<empty>,,367,1,CPPASTTypeId,,<empty>
317581,UNKNOWN,1,,void,6,<empty>,,368,1,CPPASTTypeId,,<empty>
317596,UNKNOWN,1,,void,6,<empty>,,376,1,CPPASTTypeId,,<empty>
317620,UNKNOWN,1,,void,6,<empty>,,377,1,CPPASTTypeId,,<empty>
317819,UNKNOWN,1,,void,10,<empty>,,455,1,CPPASTTypeId,,<empty>
317839,UNKNOWN,1,,void,14,<empty>,,461,1,CPPASTTypeId,,<empty>
317845,UNKNOWN,1,,BYTE,73,<empty>,,461,1,CPPASTTypeId,,<empty>
317851,UNKNOWN,1,,void,14,<empty>,,462,1,CPPASTTypeId,,<empty>
317857,UNKNOWN,1,,BYTE,73,<empty>,,462,1,CPPASTTypeId,,<empty>
317865,UNKNOWN,1,,void,14,<empty>,,463,1,CPPASTTypeId,,<empty>
317887,UNKNOWN,1,,void,6,<empty>,,470,1,CPPASTTypeId,,<empty>
317906,UNKNOWN,1,,void,6,<empty>,,482,1,CPPASTTypeId,,<empty>
317917,UNKNOWN,1,,void,10,<empty>,,486,1,CPPASTTypeId,,<empty>
317923,UNKNOWN,1,,BYTE,69,<empty>,,486,1,CPPASTTypeId,,<empty>
317927,UNKNOWN,1,,void,10,<empty>,,487,1,CPPASTTypeId,,<empty>
317933,UNKNOWN,1,,BYTE,69,<empty>,,487,1,CPPASTTypeId,,<empty>
317939,UNKNOWN,1,,void,10,<empty>,,488,1,CPPASTTypeId,,<empty>
317954,UNKNOWN,1,,void,6,<empty>,,491,1,CPPASTTypeId,,<empty>
317983,UNKNOWN,1,,void,10,<empty>,,504,1,CPPASTTypeId,,<empty>
317990,UNKNOWN,1,,void,10,<empty>,,505,1,CPPASTTypeId,,<empty>
317997,UNKNOWN,1,,void,10,<empty>,,506,1,CPPASTTypeId,,<empty>
318023,UNKNOWN,1,,void,6,<empty>,,520,1,CPPASTTypeId,,<empty>
318030,UNKNOWN,1,,void,6,<empty>,,521,1,CPPASTTypeId,,<empty>
318037,UNKNOWN,1,,void,6,<empty>,,522,1,CPPASTTypeId,,<empty>
318218,UNKNOWN,1,,void,6,<empty>,,613,1,CPPASTTypeId,,<empty>
318225,UNKNOWN,1,,void,6,<empty>,,614,1,CPPASTTypeId,,<empty>
319196,UNKNOWN,1,,"VtInputThread::VtInputThread(_In_ wil::unique_hfile hPipe,
                             const bool inheritCursor) :
    _hFile{ std::move(hPipe) }",1,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
319197,UNKNOWN,2,,",
    _hThread{}",31,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
319198,UNKNOWN,3,,",
    _u8State{}",15,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
319199,UNKNOWN,4,,",
    _dwThreadId{ 0 }",15,<empty>,,30,4,CPPASTProblemDeclaration,,<empty>
319200,UNKNOWN,5,,",
    _pfnSetLookingForDSR{}",21,<empty>,,31,5,CPPASTProblemDeclaration,,<empty>
319201,UNKNOWN,6,,"{
    THROW_HR_IF(E_HANDLE, _hFile.get() == INVALID_HANDLE_VALUE);

    auto dispatch = std::make_unique<InteractDispatch>();

    auto engine = std::make_unique<InputStateMachineEngine>(std::move(dispatch), inheritCursor);

    auto engineRef = engine.get();

    _pInputStateMachine = std::make_unique<StateMachine>(std::move(engine));

    // we need this callback to be able to flush an unknown input sequence to the app
    auto flushCallback = std::bind(&StateMachine::FlushToTerminal, _pInputStateMachine.get());
    engineRef->SetFlushToInputQueueCallback(flushCallback);

    // we need this callback to capture the reply if someone requests a status from the terminal
    _pfnSetLookingForDSR = std::bind(&InputStateMachineEngine::SetLookingForDSR, engineRef, std::placeholders::_1);
}",1,<empty>,,33,6,CPPASTProblemDeclaration,,<empty>
319202,UNKNOWN,7,,"DWORD WINAPI VtInputThread::StaticVtInputThreadProc(_In_ LPVOID lpParameter)
{
    const auto pInstance = reinterpret_cast<VtInputThread*>(lpParameter);
    pInstance->_InputThread();
    return S_OK;
}",1,<empty>,,58,7,CPPASTProblemDeclaration,,<empty>
319254,UNKNOWN,-1,,"try
    {
        // Make sure to call the GLOBAL Lock/Unlock, not the gci's lock/unlock.
        // Only the global unlock attempts to dispatch ctrl events. If you use the
        //      gci's unlock, when you press C-c, it won't be dispatched until the
        //      next console API call. For something like `powershell sleep 60`,
        //      that won't happen for 60s
        LockConsole();
        const auto unlock = wil::scope_exit([&] { UnlockConsole(); });

        _pInputStateMachine->ProcessString(_wstr);
    }
    CATCH_LOG();",5,<empty>,,98,8,CPPASTProblemStatement,,<empty>
319343,UNKNOWN,-1,,"VtInputThread(_In_ wil::unique_hfile hPipe, const bool inheritCursor);",9,<empty>,,24,1,CPPASTProblemDeclaration,,<empty>
319348,UNKNOWN,-1,,static DWORD WINAPI StaticVtInputThreadProc(_In_ LPVOID lpParameter);,9,<empty>,,27,3,CPPASTProblemDeclaration,,<empty>
319416,UNKNOWN,2,,"[[nodiscard]] HRESULT VtIo::ParseIoMode(const std::wstring& VtMode, _Out_ VtIoMode& ioMode)
{
    ioMode = VtIoMode::INVALID;

    if (VtMode == XTERM_256_STRING)
    {
        ioMode = VtIoMode::XTERM_256;
    }
    else if (VtMode == XTERM_STRING)
    {
        ioMode = VtIoMode::XTERM;
    }
    else if (VtMode == XTERM_ASCII_STRING)
    {
        ioMode = VtIoMode::XTERM_ASCII;
    }
    else if (VtMode == DEFAULT_STRING)
    {
        ioMode = VtIoMode::XTERM_256;
    }
    else
    {
        return E_INVALIDARG;
    }
    return S_OK;
}",1,<empty>,,43,2,CPPASTProblemDeclaration,,<empty>
319468,UNKNOWN,4,,"[[nodiscard]] HRESULT VtIo::_Initialize(const HANDLE InHandle,
                                        const HANDLE OutHandle,
                                        const std::wstring& VtMode,
                                        _In_opt_ const HANDLE SignalHandle)
{
    FAIL_FAST_IF_MSG(_initialized, ""Someone attempted to double-_Initialize VtIo"");

    RETURN_IF_FAILED(ParseIoMode(VtMode, _IoMode));

    _hInput.reset(InHandle);
    _hOutput.reset(OutHandle);
    _hSignal.reset(SignalHandle);

    // The only way we're initialized is if the args said we're in conpty mode.
    // If the args say so, then at least one of in, out, or signal was specified
    _initialized = true;
    return S_OK;
}",1,<empty>,,106,4,CPPASTProblemDeclaration,,<empty>
319496,UNKNOWN,-1,,"try
    {
        if (IsValidHandle(_hInput.get()))
        {
            _pVtInputThread = std::make_unique<VtInputThread>(std::move(_hInput), _lookingForCursorPosition);
        }

        if (IsValidHandle(_hOutput.get()))
        {
            auto initialViewport = Viewport::FromDimensions({ 0, 0 },
                                                            gci.GetWindowSize().width,
                                                            gci.GetWindowSize().height);
            switch (_IoMode)
            {
            case VtIoMode::XTERM_256:
            {
                auto xterm256Engine = std::make_unique<Xterm256Engine>(std::move(_hOutput),
                                                                       initialViewport);
                if constexpr (Feature_VtPassthroughMode::IsEnabled())
                {
                    if (_passthroughMode)
                    {
                        auto vtapi = new VtApiRoutines();
                        vtapi...",5,<empty>,,147,7,CPPASTProblemStatement,,<empty>
319525,UNKNOWN,-1,,"try
        {
            g.pRender->AddRenderEngine(_pVtRenderEngine.get());
            g.getConsoleInformation().GetActiveOutputBuffer().SetTerminalConnection(_pVtRenderEngine.get());

            // Force the whole window to be put together first.
            // We don't really need the handle, we just want to leverage the setup steps.
            ServiceLocator::LocatePseudoWindow();
        }
        CATCH_RETURN();",9,<empty>,,254,1,CPPASTProblemStatement,,<empty>
319645,UNKNOWN,-1,,"try
        {
            _pPtySignalInputThread = std::make_unique<PtySignalInputThread>(std::move(_hSignal));

            // Start it if it was successfully created.
            RETURN_IF_FAILED(_pPtySignalInputThread->Start());
        }
        CATCH_RETURN();",9,<empty>,,374,1,CPPASTProblemStatement,,<empty>
319863,UNKNOWN,-1,,"[[nodiscard]] static HRESULT ParseIoMode(const std::wstring& VtMode, _Out_ VtIoMode& ioMode);",9,<empty>,,34,7,CPPASTProblemDeclaration,,<empty>
319934,UNKNOWN,-1,,"[[nodiscard]] HRESULT _Initialize(const HANDLE InHandle, const HANDLE OutHandle, const std::wstring& VtMode, _In_opt_ const HANDLE SignalHandle);",9,<empty>,,77,33,CPPASTProblemDeclaration,,<empty>
320204,UNKNOWN,-1,,"try
    {
        OutputCellIterator it(chars);
        const auto finished = screenInfo.Write(it, target);
        used = finished.GetInputDistance(it);
    }
    CATCH_RETURN();",5,<empty>,,131,11,CPPASTProblemStatement,,<empty>
320234,UNKNOWN,-1,,"try
    {
        // convert to wide chars so we can call the W version of this function
        const auto wideChars = ConvertToW(codepage, chars);

        size_t wideCharsWritten = 0;
        RETURN_IF_FAILED(WriteConsoleOutputCharacterWImpl(OutContext, wideChars, target, wideCharsWritten));

        // Create a view over the wide chars and reduce it to the amount actually written (do in two steps to enforce bounds)
        std::wstring_view writtenView(wideChars);
        writtenView = writtenView.substr(0, wideCharsWritten);

        // Look over written wide chars to find equivalent count of ascii chars so we can properly report back
        // how many elements were actually written
        used = GetALengthFromW(codepage, writtenView);
    }
    CATCH_RETURN();",5,<empty>,,161,6,CPPASTProblemStatement,,<empty>
320289,UNKNOWN,-1,,"try
    {
        TextAttribute useThisAttr(attribute);
        const OutputCellIterator it(useThisAttr, lengthToWrite);
        const auto done = screenBuffer.Write(it, startingCoordinate);
        const auto cellsModifiedCoord = done.GetCellDistance(it);

        cellsModified = cellsModifiedCoord;

        if (screenBuffer.HasAccessibilityEventing())
        {
            // Notify accessibility
            auto endingCoordinate = startingCoordinate;
            bufferSize.MoveInBounds(cellsModifiedCoord, endingCoordinate);
            screenBuffer.NotifyAccessibilityEventing(startingCoordinate.x, startingCoordinate.y, endingCoordinate.x, endingCoordinate.y);
        }
    }
    CATCH_RETURN();",5,<empty>,,216,11,CPPASTProblemStatement,,<empty>
320349,UNKNOWN,-1,,"try
    {
        const OutputCellIterator it(character, lengthToWrite);

        // when writing to the buffer, specifically unset wrap if we get to the last column.
        // a fill operation should UNSET wrap in that scenario. See GH #1126 for more details.
        const auto done = screenInfo.Write(it, startingCoordinate, false);
        const auto cellsModifiedCoord = done.GetInputDistance(it);

        cellsModified = cellsModifiedCoord;

        // Notify accessibility
        if (screenInfo.HasAccessibilityEventing())
        {
            auto endingCoordinate = startingCoordinate;
            bufferSize.MoveInBounds(cellsModifiedCoord, endingCoordinate);
            screenInfo.NotifyAccessibilityEventing(startingCoordinate.x, startingCoordinate.y, endingCoordinate.x, endingCoordinate.y);
        }

        // GH#3126 - This is a shim for powershell's `Clear-Host` function. In
        // the vintage console, `Clear-Host` is supposed to clear the entire
        // buffer. I...",5,<empty>,,278,13,CPPASTProblemStatement,,<empty>
320354,UNKNOWN,7,,"[[nodiscard]] HRESULT ApiRoutines::FillConsoleOutputCharacterAImpl(IConsoleOutputObject& OutContext,
                                                                   const char character,
                                                                   const size_t lengthToWrite,
                                                                   const til::point startingCoordinate,
                                                                   size_t& cellsModified) noexcept
try
{
    // In case ConvertToW throws causing an early return, set modified cells to 0.
    cellsModified = 0;

    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    // convert to wide chars and call W version
    const auto wchs = ConvertToW(gci.OutputCP, { &character, 1 });

    LOG_HR_IF(E_UNEXPECTED, wchs.size() > 1);

    return FillConsoleOutputCharacterWImpl(OutContext, wchs.at(0), lengthToWrite, startingCoordinate, cellsModified);
}
CATCH_RETURN()",1,<empty>,,337,7,CPPASTProblemDeclaration,,<empty>
320421,UNKNOWN,1,,"static void AdjustCursorPosition(SCREEN_INFORMATION& screenInfo, _In_ til::point coordCursor, _Inout_opt_ til::CoordType* psScrollY)
{
    const auto bufferSize = screenInfo.GetBufferSize().Dimensions();
    if (coordCursor.x < 0)
    {
        if (coordCursor.y > 0)
        {
            coordCursor.x = bufferSize.width + coordCursor.x;
            coordCursor.y = coordCursor.y - 1;
        }
        else
        {
            coordCursor.x = 0;
        }
    }
    else if (coordCursor.x >= bufferSize.width)
    {
        // at end of line. if wrap mode, wrap cursor.  otherwise leave it where it is.
        if (screenInfo.OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT)
        {
            coordCursor.y += coordCursor.x / bufferSize.width;
            coordCursor.x = coordCursor.x % bufferSize.width;
        }
        else
        {
            coordCursor.x = screenInfo.GetTextBuffer().GetCursor().GetPosition().x;
        }
    }

    if (coordCursor.y >= bufferSize.height)
    {
       ...",1,<empty>,,42,1,CPPASTProblemDeclaration,,<empty>
320450,UNKNOWN,-1,,e,17,<empty>,,118,8,CPPASTProblemStatement,,<empty>
320969,UNKNOWN,4,,"[[nodiscard]] NTSTATUS DoWriteConsole(_In_reads_bytes_(*pcbBuffer) PCWCHAR pwchBuffer,
                                      _Inout_ size_t* const pcbBuffer,
                                      SCREEN_INFORMATION& screenInfo,
                                      bool requiresVtQuirk,
                                      std::unique_ptr<WriteData>& waiter)
try
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    if (WI_IsAnyFlagSet(gci.Flags, (CONSOLE_SUSPENDED | CONSOLE_SELECTING | CONSOLE_SCROLLBAR_TRACKING)))
    {
        waiter = std::make_unique<WriteData>(screenInfo,
                                             pwchBuffer,
                                             *pcbBuffer,
                                             gci.OutputCP,
                                             requiresVtQuirk);
        return CONSOLE_STATUS_WAIT;
    }

    const auto vtIo = ServiceLocator::LocateGlobals().getConsoleInformation().GetVtIo();
    const aut...",1,<empty>,,273,4,CPPASTProblemDeclaration,,<empty>
320970,UNKNOWN,5,,"NT_CATCH_RETURN()

// Routine Description:
// - This method performs the actual work of attempting to write to the console, converting data types as necessary
//   to adapt from the server types to the legacy internal host types.
// - It operates on Unicode data only. It's assumed the text is translated by this point.
// Arguments:
// - OutContext - the console output object to write the new text into
// - pwsTextBuffer - wide character text buffer provided by client application to insert
// - cchTextBufferLength - text buffer counted in characters
// - pcchTextBufferRead - character count of the number of characters we were able to insert before returning
// - ppWaiter - If we are blocked from writing now and need to wait, this is filled with contextual data for the server to restore the call later
// Return Value:
// - S_OK if successful.
// - S_OK if we need to wait (check if ppWaiter is not nullptr).
// - Or a suitable HRESULT code for math/string/memory failures.
[[nodiscard]] ...",1,<empty>,,324,5,CPPASTProblemDeclaration,,<empty>
320978,UNKNOWN,-1,,"try
    {
        // Ensure output variables are initialized.
        read = 0;
        waiter.reset();

        if (buffer.empty())
        {
            return S_OK;
        }

        LockConsole();
        auto unlock{ wil::scope_exit([&] { UnlockConsole(); }) };

        auto& screenInfo{ context.GetActiveBuffer() };
        const auto& consoleInfo{ ServiceLocator::LocateGlobals().getConsoleInformation() };
        const auto codepage{ consoleInfo.OutputCP };
        auto leadByteCaptured{ false };
        auto leadByteConsumed{ false };
        std::wstring wstr{};
        static til::u8state u8State{};

        // Convert our input parameters to Unicode
        if (codepage == CP_UTF8)
        {
            RETURN_IF_FAILED(til::u8u16(buffer, wstr, u8State));
            read = buffer.size();
        }
        else
        {
            // In case the codepage changes from UTF-8 to another,
            // we discard partials that might still be cached.
            u8State.res...",5,<empty>,,392,1,CPPASTProblemStatement,,<empty>
320988,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto unlock = wil::scope_exit([&] { UnlockConsole(); });

        std::unique_ptr<WriteData> writeDataWaiter;
        RETURN_IF_FAILED(WriteConsoleWImplHelper(context.GetActiveBuffer(), buffer, read, requiresVtQuirk, writeDataWaiter));

        // Transfer specific waiter pointer into the generic interface wrapper.
        waiter.reset(writeDataWaiter.release());

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,582,1,CPPASTProblemStatement,,<empty>
321005,UNKNOWN,2,,"[[nodiscard]] NTSTATUS DoWriteConsole(_In_reads_bytes_(pcbBuffer) const wchar_t* pwchBuffer,
                                      _Inout_ size_t* const pcbBuffer,
                                      SCREEN_INFORMATION& screenInfo,
                                      bool requiresVtQuirk,
                                      std::unique_ptr<WriteData>& waiter);",1,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
321143,UNKNOWN,-1,,"try
    {
        const auto sourceW = ConvertToW(codepage, source);
        const auto targetW = ConvertToW(codepage, target);
        const auto exeNameW = ConvertToW(codepage, exeName);

        return AddConsoleAliasWImpl(sourceW, targetW, exeNameW);
    }
    CATCH_RETURN();",5,<empty>,,68,5,CPPASTProblemStatement,,<empty>
321168,UNKNOWN,-1,,"try
    {
        std::wstring exeNameString(exeName);
        std::wstring sourceString(source);
        std::wstring targetString(target);

        std::transform(exeNameString.begin(), exeNameString.end(), exeNameString.begin(), towlower);
        std::transform(sourceString.begin(), sourceString.end(), sourceString.begin(), towlower);

        if (targetString.size() == 0)
        {
            // Only try to dig in and erase if the exeName exists.
            auto exeData = g_aliasData.find(exeNameString);
            if (exeData != g_aliasData.end())
            {
                g_aliasData[exeNameString].erase(sourceString);
            }
        }
        else
        {
            // Map will auto-create each level as necessary
            g_aliasData[exeNameString][sourceString] = targetString;
        }
    }
    CATCH_RETURN();",5,<empty>,,96,5,CPPASTProblemStatement,,<empty>
321345,UNKNOWN,-1,,"try
    {
        if (target.size() > 0)
        {
            til::at(target, 0) = ANSI_NULL;
        }

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Convert our input parameters to Unicode.
        const auto sourceW = ConvertToW(codepage, source);
        const auto exeNameW = ConvertToW(codepage, exeName);

        // Figure out how big our temporary Unicode buffer must be to retrieve output
        size_t targetNeeded;
        RETURN_IF_FAILED(GetConsoleAliasWImplHelper(sourceW, std::nullopt, targetNeeded, exeNameW));

        // If there's nothing to get, then simply return.
        RETURN_HR_IF(S_OK, 0 == targetNeeded);

        // If the user hasn't given us a buffer at all and we need one, return an error.
        RETURN_HR_IF(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), 0 == target.size());

        // Allocate a unicode buffer of the right size.
        auto targetBuffer = std::make_unique<wchar_t[]>(targetNeeded);
...",5,<empty>,,207,6,CPPASTProblemStatement,,<empty>
321363,UNKNOWN,-1,,"try
    {
        auto hr = GetConsoleAliasWImplHelper(source, target, written, exeName);

        if (FAILED(hr))
        {
            written = target.size();
        }

        return hr;
    }
    CATCH_RETURN();",5,<empty>,,278,4,CPPASTProblemStatement,,<empty>
321378,UNKNOWN,-1,,"try
    {
        const std::wstring exeNameString(exeName);

        size_t cchNeeded = 0;

        // Each of the aliases will be made up of the source, a separator, the target, then a null character.
        // They are of the form ""Source=Target"" when returned.
        const size_t cchNull = 1;
        auto cchSeparator = aliasesSeparator.size();
        // If we're counting how much multibyte space will be needed, trial convert the separator before we add.
        if (!countInUnicode)
        {
            cchSeparator = GetALengthFromW(codepage, aliasesSeparator);
        }

        // Find without creating.
        auto exeIter = g_aliasData.find(exeNameString);
        if (exeIter != g_aliasData.end())
        {
            auto list = exeIter->second;
            for (auto& pair : list)
            {
                // Alias stores lengths in bytes.
                auto cchSource = pair.first.size();
                auto cchTarget = pair.second.size();

                // I...",5,<empty>,,316,2,CPPASTProblemStatement,,<empty>
321415,UNKNOWN,-1,,"try
    {
        const auto exeNameW = ConvertToW(codepage, exeName);

        return GetConsoleAliasesLengthWImplHelper(exeNameW, false, codepage, bufferRequired);
    }
    CATCH_RETURN();",5,<empty>,,386,9,CPPASTProblemStatement,,<empty>
321431,UNKNOWN,-1,,"try
    {
        return GetConsoleAliasesLengthWImplHelper(exeName, true, 0, bufferRequired);
    }
    CATCH_RETURN();",5,<empty>,,409,4,CPPASTProblemStatement,,<empty>
321734,UNKNOWN,-1,,"try
    {
        if (alias.size() > 0)
        {
            til::at(alias, 0) = '\0';
        }

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Convert our input parameters to Unicode.
        const auto exeNameW = ConvertToW(codepage, exeName);
        wistd::unique_ptr<wchar_t[]> pwsExeName;

        // Figure out how big our temporary Unicode buffer must be to retrieve output
        size_t bufferNeeded;
        RETURN_IF_FAILED(GetConsoleAliasesWImplHelper(exeNameW, std::nullopt, bufferNeeded));

        // If there's nothing to get, then simply return.
        RETURN_HR_IF(S_OK, 0 == bufferNeeded);

        // Allocate a unicode buffer of the right size.
        auto aliasBuffer = std::make_unique<wchar_t[]>(bufferNeeded);
        RETURN_IF_NULL_ALLOC(aliasBuffer);

        // Call the Unicode version of this method
        size_t bufferWritten;
        RETURN_IF_FAILED(GetConsoleAliasesWImplHelper(exeNameW, std::span<wchar...",5,<empty>,,539,6,CPPASTProblemStatement,,<empty>
321751,UNKNOWN,-1,,"try
    {
        return GetConsoleAliasesWImplHelper(exeName, alias, written);
    }
    CATCH_RETURN();",5,<empty>,,600,4,CPPASTProblemStatement,,<empty>
322015,UNKNOWN,-1,,"try
    {
        if (aliasExes.size() > 0)
        {
            til::at(aliasExes, 0) = '\0';
        }

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Figure our how big our temporary Unicode buffer must be to retrieve output
        size_t bufferNeeded;
        RETURN_IF_FAILED(GetConsoleAliasExesWImplHelper(std::nullopt, bufferNeeded));

        // If there's nothing to get, then simply return.
        RETURN_HR_IF(S_OK, 0 == bufferNeeded);

        // Allocate a unicode buffer of the right size.
        auto targetBuffer = std::make_unique<wchar_t[]>(bufferNeeded);
        RETURN_IF_NULL_ALLOC(targetBuffer);

        // Call the Unicode version of this method
        size_t bufferWritten;
        RETURN_IF_FAILED(GetConsoleAliasExesWImplHelper(std::span<wchar_t>(targetBuffer.get(), bufferNeeded), bufferWritten));

        // Convert result to A
        const auto converted = ConvertToA(codepage, { targetBuffer.get(), bufferW...",5,<empty>,,757,6,CPPASTProblemStatement,,<empty>
322031,UNKNOWN,-1,,"try
    {
        return GetConsoleAliasExesWImplHelper(aliasExes, written);
    }
    CATCH_RETURN();",5,<empty>,,813,4,CPPASTProblemStatement,,<empty>
322985,UNKNOWN,-1,,"try
    {
        _screenBuffer->ClearTextData();
    }
    CATCH_LOG();",5,<empty>,,123,2,CPPASTProblemStatement,,<empty>
323580,UNKNOWN,13,,I,27,<empty>,,142,13,CPPASTProblemDeclaration,,<empty>
323582,UNKNOWN,15,,I,13,<empty>,,144,15,CPPASTProblemDeclaration,,<empty>
323583,UNKNOWN,16,,"NtQueryVolumeInformationFile(
            _In_ HANDLE FileHandle,
            _Out_ PIO_STATUS_BLOCK IoStatusBlock,
            _Out_writes_bytes_(Length) PVOID FsInformation,
            _In_ ULONG Length,
            _In_ FS_INFORMATION_CLASS FsInformationClass);",9,<empty>,,145,16,CPPASTProblemDeclaration,,<empty>
323853,UNKNOWN,-1,,"try
    {
        ConvAreaCompStr.emplace_back(bufferSize,
                                     windowSize,
                                     fill,
                                     popupFill,
                                     fontInfo);
    }
    CATCH_RETURN();",5,<empty>,,159,14,CPPASTProblemStatement,,<empty>
324138,UNKNOWN,1,,ptrdiff_t,48,<empty>,,339,1,CPPASTTypeId,,<empty>
325686,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto pIme = &gci.ConsoleIme;
        pIme->RedrawCompMessage();
    }
    CATCH_RETURN();",5,<empty>,,70,1,CPPASTProblemStatement,,<empty>
325803,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        gci.LockConsole();
        auto unlock = wil::scope_exit([&] { gci.UnlockConsole(); });

        const auto pIme = &gci.ConsoleIme;
        pIme->WriteCompMessage(text, attributes, colorArray);
    }
    CATCH_RETURN();",5,<empty>,,122,1,CPPASTProblemStatement,,<empty>
325810,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        gci.LockConsole();
        auto unlock = wil::scope_exit([&] { gci.UnlockConsole(); });

        const auto pIme = &gci.ConsoleIme;
        pIme->ClearAllAreas();
    }
    CATCH_RETURN();",5,<empty>,,137,1,CPPASTProblemStatement,,<empty>
325818,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        gci.LockConsole();
        auto unlock = wil::scope_exit([&] { gci.UnlockConsole(); });

        const auto pIme = &gci.ConsoleIme;
        pIme->WriteResultMessage(text);
    }
    CATCH_RETURN();",5,<empty>,,152,1,CPPASTProblemStatement,,<empty>
325857,UNKNOWN,-1,,IN,5,<empty>,,72,1,CPPASTProblemDeclaration,,<empty>
325859,UNKNOWN,-1,,IN,5,<empty>,,73,3,CPPASTProblemDeclaration,,<empty>
325864,UNKNOWN,-1,,IN,5,<empty>,,78,1,CPPASTProblemDeclaration,,<empty>
325866,UNKNOWN,-1,,IN,5,<empty>,,79,3,CPPASTProblemDeclaration,,<empty>
325870,UNKNOWN,18,,"NTSTATUS ConsoleControl(
    __in CONSOLECONTROL Command,
    __in_bcount_opt(ConsoleInformationLength) PVOID ConsoleInformation,
    __in DWORD ConsoleInformationLength);",1,<empty>,,82,18,CPPASTProblemDeclaration,,<empty>
325888,UNKNOWN,1,,"bool CheckBisectStringA(_In_reads_bytes_(cbBuf) PCHAR pchBuf, _In_ DWORD cbBuf, const CPINFO* const pCPInfo)
{
    while (cbBuf)
    {
        if (IsDBCSLeadByteConsole(*pchBuf, pCPInfo))
        {
            if (cbBuf <= 1)
            {
                return true;
            }
            else
            {
                pchBuf += 2;
                cbBuf -= 2;
            }
        }
        else
        {
            pchBuf++;
            cbBuf--;
        }
    }

    return false;
}",1,<empty>,,24,1,CPPASTProblemDeclaration,,<empty>
326008,UNKNOWN,1,,unsigned char,33,<empty>,,112,1,CPPASTTypeId,,<empty>
326060,UNKNOWN,1,,DWORD*,32,<empty>,,132,1,CPPASTTypeId,,<empty>
326124,UNKNOWN,1,,BYTE,13,<empty>,,162,1,CPPASTTypeId,,<empty>
326163,UNKNOWN,1,,"bool CheckBisectStringA(_In_reads_bytes_(cbBuf) PCHAR pchBuf, _In_ DWORD cbBuf, const CPINFO* const pCPInfo);",1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
326275,UNKNOWN,-1,,"try
    {
        waiter.reset();

        if (eventReadCount == 0)
        {
            return STATUS_SUCCESS;
        }

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto Status = inputBuffer.Read(outEvents,
                                             eventReadCount,
                                             IsPeek,
                                             true,
                                             IsUnicode,
                                             false);

        if (CONSOLE_STATUS_WAIT == Status)
        {
            // If we're told to wait until later, move all of our context
            // to the read data object and send it back up to the server.
            waiter = std::make_unique<DirectReadData>(&inputBuffer,
                                                      &readHandleState,
                                                      eventReadCount);
        }
        return Status;
    }
  ...",5,<empty>,,61,1,CPPASTProblemStatement,,<empty>
326284,UNKNOWN,-1,,"try
    {
        written = 0;

        // add to InputBuffer
        if (append)
        {
            written = context.Write(events);
        }
        else
        {
            written = context.Prepend(events);
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,108,1,CPPASTProblemStatement,,<empty>
326287,UNKNOWN,3,,"[[nodiscard]] HRESULT ApiRoutines::WriteConsoleInputAImpl(InputBuffer& context,
                                                          const std::span<const INPUT_RECORD> buffer,
                                                          size_t& written,
                                                          const bool append) noexcept
try
{
    written = 0;

    if (buffer.empty())
    {
        return S_OK;
    }

    LockConsole();
    auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    InputEventQueue events;

    auto it = buffer.begin();
    const auto end = buffer.end();

    // Check out the loop below. When a previous call ended on a leading DBCS we store it for
    // the next call to WriteConsoleInputAImpl to join it with the now available trailing DBCS.
    if (context.IsWritePartialByteSequenceAvailable())
    {
        auto lead = context.FetchWritePartialByteSequence();
     ...",1,<empty>,,137,3,CPPASTProblemDeclaration,,<empty>
326306,UNKNOWN,-1,,"try
    {
        return _WriteConsoleInputWImplHelper(context, buffer, written, append);
    }
    CATCH_RETURN();",5,<empty>,,252,5,CPPASTProblemStatement,,<empty>
326314,UNKNOWN,-1,,"try
    {
        const auto size = rectangle.Dimensions();
        auto outIter = buffer.begin();

        for (til::CoordType i = 0; i < size.height; ++i)
        {
            for (til::CoordType j = 0; j < size.width; ++j, ++outIter)
            {
                auto& in1 = *outIter;

                // If .AsciiChar and .UnicodeChar have the same offset (since they're a union),
                // we can just write the latter with a byte-sized value to set the former
                // _and_ simultaneously clear the upper byte of .UnicodeChar to 0. Nice!
                static_assert(offsetof(CHAR_INFO, Char.AsciiChar) == offsetof(CHAR_INFO, Char.UnicodeChar));

                // Any time we see the lead flag, we presume there will be a trailing one following it.
                // Giving us two bytes of space (one per cell in the ascii part of the character union)
                // to fill with whatever this Unicode character converts into.
                if (WI_IsFlagSet(i...",5,<empty>,,272,1,CPPASTProblemStatement,,<empty>
326322,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

        const auto size = rectangle.Dimensions();
        auto outIter = buffer.begin();

        for (til::CoordType i = 0; i < size.height; ++i)
        {
            for (til::CoordType j = 0; j < size.width; ++j, ++outIter)
            {
                // Clear lead/trailing flags. We'll determine it for ourselves versus the given codepage.
                auto& in1 = *outIter;
                WI_ClearAllFlags(in1.Attributes, COMMON_LVB_SBCSDBCS);

                // If the 1 byte given is a lead in this codepage, we likely need two cells for the width.
                if (IsDBCSLeadByteConsole(in1.Char.AsciiChar, &gci.OutputCPInfo))
                {
                    // If we're not on the last column, we have two cells to use.
                    if (j < size.width - 1)
                    {
                        // Mark we're consuming two cells.
                        ++outIt...",5,<empty>,,349,1,CPPASTProblemStatement,,<empty>
326461,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto& storageBuffer = context.GetActiveBuffer().GetTextBuffer();
        const auto storageSize = storageBuffer.GetSize().Dimensions();

        const auto targetSize = requestRectangle.Dimensions();

        // If either dimension of the request is too small, return an empty rectangle as read and exit early.
        if (targetSize.width <= 0 || targetSize.height <= 0)
        {
            readRectangle = Viewport::FromDimensions(requestRectangle.Origin(), { 0, 0 });
            return S_OK;
        }

        // The buffer given should be big enough to hold the dimensions of the request.
        const auto targetArea = targetSize.area<size_t>();
        RETURN_HR_IF(E_INVALIDARG, targetArea < targetBuffer.size());

        // Clip the request rectangle to the size of the storage buffer
        auto clip = requestRectangle.ToExclusive();
        clip.right = std::min(clip.righ...",5,<empty>,,471,1,CPPASTProblemStatement,,<empty>
326479,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto codepage = gci.OutputCP;

        RETURN_IF_FAILED(_ReadConsoleOutputWImplHelper(context, buffer, sourceRectangle, readRectangle));

        LOG_IF_FAILED(_ConvertCellsToAInplace(codepage, buffer, readRectangle));

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,564,4,CPPASTProblemStatement,,<empty>
326497,UNKNOWN,-1,,"try
    {
        RETURN_IF_FAILED(_ReadConsoleOutputWImplHelper(context, buffer, sourceRectangle, readRectangle));

        if (!context.GetActiveBuffer().GetCurrentFont().IsTrueTypeFont())
        {
            // For compatibility reasons, we must maintain the behavior that munges the data if we are writing while a raster font is enabled.
            // This can be removed when raster font support is removed.
            UnicodeRasterFontCellMungeOnRead(buffer);
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,586,4,CPPASTProblemStatement,,<empty>
326506,UNKNOWN,-1,,"try
    {
        auto& storageBuffer = context.GetActiveBuffer();
        const auto storageRectangle = storageBuffer.GetBufferSize();
        const auto storageSize = storageRectangle.Dimensions();

        const auto sourceSize = requestRectangle.Dimensions();

        // If either dimension of the request is too small, return an empty rectangle as the read and exit early.
        if (sourceSize.width <= 0 || sourceSize.height <= 0)
        {
            writtenRectangle = Viewport::FromDimensions(requestRectangle.Origin(), { 0, 0 });
            return S_OK;
        }

        // If the top and left of the destination we're trying to write it outside the buffer,
        // give the original request rectangle back and exit early OK.
        if (requestRectangle.Left() >= storageSize.width || requestRectangle.Top() >= storageSize.height)
        {
            writtenRectangle = requestRectangle;
            return S_OK;
        }

        // Do clipping according to the legacy pat...",5,<empty>,,607,1,CPPASTProblemStatement,,<empty>
326524,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto codepage = gci.OutputCP;
        LOG_IF_FAILED(_ConvertCellsToWInplace(codepage, buffer, requestRectangle));

        RETURN_IF_FAILED(_WriteConsoleOutputWImplHelper(context, buffer, requestRectangle, writtenRectangle));

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,710,4,CPPASTProblemStatement,,<empty>
326542,UNKNOWN,-1,,"try
    {
        if (!context.GetActiveBuffer().GetCurrentFont().IsTrueTypeFont())
        {
            // For compatibility reasons, we must maintain the behavior that munges the data if we are writing while a raster font is enabled.
            // This can be removed when raster font support is removed.
            auto translated = _ConvertCellsToMungedW(buffer, requestRectangle);
            RETURN_IF_FAILED(_WriteConsoleOutputWImplHelper(context, translated, requestRectangle, writtenRectangle));
        }
        else
        {
            RETURN_IF_FAILED(_WriteConsoleOutputWImplHelper(context, buffer, requestRectangle, writtenRectangle));
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,731,4,CPPASTProblemStatement,,<empty>
326563,UNKNOWN,-1,,"try
    {
        const auto attrs = ReadOutputAttributes(context.GetActiveBuffer(), origin, buffer.size());
        std::copy(attrs.cbegin(), attrs.cend(), buffer.begin());
        written = attrs.size();

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,760,5,CPPASTProblemStatement,,<empty>
326584,UNKNOWN,-1,,"try
    {
        const auto chars = ReadOutputStringA(context.GetActiveBuffer(),
                                             origin,
                                             buffer.size());

        // for compatibility reasons, if we receive more chars than can fit in the buffer
        // then we don't send anything back.
        if (chars.size() <= buffer.size())
        {
            std::copy(chars.cbegin(), chars.cend(), buffer.begin());
            written = chars.size();
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,781,5,CPPASTProblemStatement,,<empty>
326605,UNKNOWN,-1,,"try
    {
        const auto chars = ReadOutputStringW(context.GetActiveBuffer(),
                                             origin,
                                             buffer.size());

        // Only copy if the whole result will fit.
        if (chars.size() <= buffer.size())
        {
            std::copy(chars.cbegin(), chars.cend(), buffer.begin());
            written = chars.size();
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,810,5,CPPASTProblemStatement,,<empty>
326608,UNKNOWN,17,,"[[nodiscard]] NTSTATUS ConsoleCreateScreenBuffer(std::unique_ptr<ConsoleHandleData>& handle,
                                                 _In_ PCONSOLE_API_MSG /*Message*/,
                                                 _In_ PCD_CREATE_OBJECT_INFORMATION Information,
                                                 _In_ PCONSOLE_CREATESCREENBUFFER_MSG a)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::CreateConsoleScreenBuffer);
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    // If any buffer type except the one we support is set, it's invalid.
    if (WI_IsAnyFlagSet(a->Flags, ~CONSOLE_TEXTMODE_BUFFER))
    {
        // We no longer support anything other than a textmode buffer
        return STATUS_INVALID_PARAMETER;
    }

    const auto HandleType = ConsoleHandleData::HandleType::Output;

    const auto& siExisting = gci.GetActiveOutputBuffer();

    // Create new screen buffer.
    auto WindowSize = siExisting.GetViewport().D...",1,<empty>,,839,17,CPPASTProblemDeclaration,,<empty>
326619,UNKNOWN,2,,"[[nodiscard]] NTSTATUS ConsoleCreateScreenBuffer(std::unique_ptr<ConsoleHandleData>& handle,
                                                 _In_ PCONSOLE_API_MSG Message,
                                                 _In_ PCD_CREATE_OBJECT_INFORMATION Information,
                                                 _In_ PCONSOLE_CREATESCREENBUFFER_MSG a);",1,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
326649,UNKNOWN,2,,"HRESULT CConsoleHandoff::EstablishHandoff(HANDLE server,
                                          HANDLE inputEvent,
                                          PCCONSOLE_PORTABLE_ATTACH_MSG msg,
                                          HANDLE signalPipe,
                                          HANDLE inboxProcess,
                                          HANDLE* process)
try
{
    RETURN_HR_IF(E_INVALIDARG, !process);

    // Fill the descriptor portion of a fresh api message with the received data.
    // The descriptor portion is the ""received"" packet from the last ask of the driver.
    // The other portions are unnecessary as they track the other buffer state, error codes,
    // and the return portion of the api message.
    // We will re-retrieve the connect information (title, window state, etc.) when the
    // new console session begins servicing this.
    CONSOLE_API_MSG apiMsg{};
    apiMsg.Descriptor.Identifier.HighPart = msg->IdHighPart;
    apiMsg.Descriptor.Identi...",1,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
326688,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(
    g_ConhostLauncherProvider,
    ""Microsoft.Windows.Console.Launcher"",
    // {770aa552-671a-5e97-579b-151709ec0dbd}
    (0x770aa552, 0x671a, 0x5e97, 0x57, 0x9b, 0x15, 0x17, 0x09, 0xec, 0x0d, 0xbd),
    TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
326693,UNKNOWN,-1,,"STDMETHOD(RegisterCOMObject)
    (_In_opt_z_ const wchar_t* serverName, _In_reads_(count) IID* clsids, _In_reads_(count) IClassFactory** factories, _Inout_updates_(count) DWORD* cookies, unsigned int count)
    {
        return Microsoft::WRL::Details::RegisterCOMObject<RegClsType>(serverName, clsids, factories, cookies, count);
    }",5,<empty>,,39,3,CPPASTProblemDeclaration,,<empty>
326763,UNKNOWN,1,,U,24,<empty>,,205,1,CPPASTTypeId,,<empty>
326785,UNKNOWN,9,,"int CALLBACK wWinMain(
    _In_ HINSTANCE hInstance,
    _In_ HINSTANCE /*hPrevInstance*/,
    _In_ PWSTR /*pwszCmdLine*/,
    _In_ int /*nCmdShow*/)
{
    Microsoft::Console::Interactivity::ServiceLocator::LocateGlobals().hInstance = hInstance;

    ConsoleCheckDebug();

    // Set up OutOfProc COM server stuff in case we become one.
    // WRL Module gets going right before winmain is called, so if we don't
    // set this up appropriately... other things using WRL that aren't us
    // could get messed up by the singleton module and cause unexpected errors.
    _comServerExitEvent.create();

    // We will use a single use server to ensure that each out-of-box console that
    // gets activated to take over a session from the OS console will only be responsible
    // for ONE console server session. This ensures that we, as the handoff target, are
    // responsible for only one session and one server handle to the driver and we maintain
    // the one-to-one relationship between...",1,<empty>,,219,9,CPPASTProblemDeclaration,,<empty>
327067,UNKNOWN,1,,HANDLE,44,<empty>,,93,1,CPPASTTypeId,,<empty>
327161,UNKNOWN,1,,const char*,73,<empty>,,131,1,CPPASTTypeId,,<empty>
327253,UNKNOWN,-1,,),32,<empty>,,37,2,CPPASTProblemDeclaration,,<empty>
327254,UNKNOWN,-1,,"END_TEST_CLASS()

    BEGIN_TEST_METHOD(TestGetConsoleAlias)
        TEST_METHOD_PROPERTY(L""Data:strSource"", L""{g}"")
        TEST_METHOD_PROPERTY(L""Data:strExpectedTarget"", L""{cmd.exe /k echo foo}"")
        TEST_METHOD_PROPERTY(L""Data:strExeName"", L""{cmd.exe}"")
        TEST_METHOD_PROPERTY(L""Data:dwSource"", L""{0, 1}"")
        TEST_METHOD_PROPERTY(L""Data:dwTarget"", L""{0, 1, 2, 3, 4, 5, 6}"")
        TEST_METHOD_PROPERTY(L""Data:dwExeName"", L""{0, 1}"")
        TEST_METHOD_PROPERTY(L""Data:bUnicode"", L""{FALSE, TRUE}"")
        TEST_METHOD_PROPERTY(L""Data:bSetFirst"", L""{FALSE, TRUE}"")
    END_TEST_METHOD()",5,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
327255,UNKNOWN,2,,"void ConvertWToA(_In_ PCWSTR pwsz,
                 _Out_ char** ppsz)
{
    *ppsz = nullptr;

    const auto cp = CP_ACP;

    const auto dwBytesNeeded = WideCharToMultiByte(cp, 0, pwsz, -1, nullptr, 0, nullptr, nullptr);
    VERIFY_WIN32_BOOL_SUCCEEDED(dwBytesNeeded, L""Verify that WC2MB could detect bytes needed for conversion."");

    auto psz = new char[dwBytesNeeded];
    VERIFY_IS_NOT_NULL(psz, L""Verify we could allocate necessary bytes for conversion."");

    VERIFY_WIN32_BOOL_SUCCEEDED(WideCharToMultiByte(cp, 0, pwsz, -1, psz, dwBytesNeeded, nullptr, nullptr), L""Verify that WC2MB did the conversion successfully."");

    *ppsz = psz;
}",1,<empty>,,53,2,CPPASTProblemDeclaration,,<empty>
327349,UNKNOWN,1,,wchar_t*,37,<empty>,,92,1,CPPASTTypeId,,<empty>
327355,UNKNOWN,1,,wchar_t*,37,<empty>,,93,1,CPPASTTypeId,,<empty>
327361,UNKNOWN,1,,wchar_t*,37,<empty>,,94,1,CPPASTTypeId,,<empty>
327613,UNKNOWN,1,,DWORD,43,<empty>,,100,1,CPPASTTypeId,,<empty>
327953,UNKNOWN,-1,,),33,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
327954,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_CLASS()

    TEST_METHOD(TestSetConsoleActiveScreenBufferInvalid);",9,<empty>,,18,3,CPPASTProblemDeclaration,,<empty>
327958,UNKNOWN,-1,,),54,<empty>,,26,7,CPPASTProblemDeclaration,,<empty>
327959,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:UseVtOutput"", L""{true, false}"")
    END_TEST_METHOD()

    TEST_METHOD(ScrollLargeBufferPerformance);",9,<empty>,,27,8,CPPASTProblemDeclaration,,<empty>
328058,UNKNOWN,1,,DWORD,34,<empty>,,75,1,CPPASTTypeId,,<empty>
328567,UNKNOWN,-1,,),34,<empty>,,188,2,CPPASTProblemStatement,,<empty>
328571,UNKNOWN,-1,,),52,<empty>,,189,4,CPPASTProblemStatement,,<empty>
328573,UNKNOWN,-1,,),32,<empty>,,190,6,CPPASTProblemStatement,,<empty>
328650,UNKNOWN,1,,short,21,<empty>,,215,1,CPPASTTypeId,,<empty>
328763,UNKNOWN,-1,,),34,<empty>,,236,2,CPPASTProblemStatement,,<empty>
328767,UNKNOWN,-1,,),52,<empty>,,237,4,CPPASTProblemStatement,,<empty>
328769,UNKNOWN,-1,,),32,<empty>,,238,6,CPPASTProblemStatement,,<empty>
328855,UNKNOWN,1,,char*,17,<empty>,,279,1,CPPASTTypeId,,<empty>
328975,UNKNOWN,-1,,),33,<empty>,,12,2,CPPASTProblemDeclaration,,<empty>
328976,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(TestSetup);",5,<empty>,,13,3,CPPASTProblemDeclaration,,<empty>
328979,UNKNOWN,-1,,),50,<empty>,,18,6,CPPASTProblemDeclaration,,<empty>
328980,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:dwSize"", L""{0, 1, 50, 100, 101, 0xFFFFFFFF}"")
        // Both possible values
        TEST_METHOD_PROPERTY(L""Data:bVisible"", L""{TRUE, FALSE}"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestSetConsoleCursorPosition)
        TEST_METHOD_PROPERTY(L""HostDestructive"", L""True"")
    END_TEST_METHOD()",9,<empty>,,20,7,CPPASTProblemDeclaration,,<empty>
329353,UNKNOWN,-1,,),37,<empty>,,21,2,CPPASTProblemDeclaration,,<empty>
329354,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(TestSetup);",5,<empty>,,22,3,CPPASTProblemDeclaration,,<empty>
329359,UNKNOWN,-1,,),47,<empty>,,30,8,CPPASTProblemDeclaration,,<empty>
329360,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:bAbsolute"", L""{TRUE, FALSE}"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestSetConsoleScreenBufferSize)
        // 0x1 = X, 0x2 = Y, 0x3 = Both
        TEST_METHOD_PROPERTY(L""Data:scaleChoices"", L""{1, 2, 3}"")
    END_TEST_METHOD()

    TEST_METHOD(TestZeroSizedConsoleScreenBuffers);",9,<empty>,,32,9,CPPASTProblemDeclaration,,<empty>
330356,UNKNOWN,1,,DWORD,27,<empty>,,342,1,CPPASTTypeId,,<empty>
330765,UNKNOWN,1,,SHORT,46,<empty>,,463,1,CPPASTTypeId,,<empty>
331091,UNKNOWN,-1,,),31,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
331092,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_CLASS();",9,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
331097,UNKNOWN,-1,,),43,<empty>,,31,8,CPPASTProblemDeclaration,,<empty>
331098,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:fFlagOn"", L""{true, false}"")
    END_TEST_METHOD();",9,<empty>,,32,9,CPPASTProblemDeclaration,,<empty>
331100,UNKNOWN,-1,,),48,<empty>,,35,11,CPPASTProblemDeclaration,,<empty>
331101,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:fVtOn"", L""{true, false}"")
        TEST_METHOD_PROPERTY(L""Data:fProcessedOn"", L""{true, false}"")
    END_TEST_METHOD();",9,<empty>,,36,12,CPPASTProblemDeclaration,,<empty>
331103,UNKNOWN,-1,,),60,<empty>,,40,14,CPPASTProblemDeclaration,,<empty>
331104,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:fDisableAutoReturn"", L""{true, false}"")
        TEST_METHOD_PROPERTY(L""Data:fProcessedOn"", L""{true, false}"")
    END_TEST_METHOD();",9,<empty>,,41,15,CPPASTProblemDeclaration,,<empty>
331206,UNKNOWN,1,,DWORD,14,<empty>,,113,1,CPPASTTypeId,,<empty>
331232,UNKNOWN,1,,DWORD,14,<empty>,,123,1,CPPASTTypeId,,<empty>
331258,UNKNOWN,1,,DWORD,14,<empty>,,133,1,CPPASTTypeId,,<empty>
331290,UNKNOWN,1,,DWORD,27,<empty>,,150,1,CPPASTTypeId,,<empty>
331376,UNKNOWN,1,,SHORT,41,<empty>,,173,1,CPPASTTypeId,,<empty>
331615,UNKNOWN,1,,DWORD,20,<empty>,,257,1,CPPASTTypeId,,<empty>
331624,UNKNOWN,1,,DWORD,24,<empty>,,259,1,CPPASTTypeId,,<empty>
331672,UNKNOWN,1,,DWORD,20,<empty>,,275,1,CPPASTTypeId,,<empty>
331681,UNKNOWN,1,,DWORD,24,<empty>,,277,1,CPPASTTypeId,,<empty>
331729,UNKNOWN,1,,DWORD,20,<empty>,,296,1,CPPASTTypeId,,<empty>
331738,UNKNOWN,1,,DWORD,24,<empty>,,298,1,CPPASTTypeId,,<empty>
331786,UNKNOWN,1,,DWORD,20,<empty>,,315,1,CPPASTTypeId,,<empty>
331795,UNKNOWN,1,,DWORD,24,<empty>,,317,1,CPPASTTypeId,,<empty>
331852,UNKNOWN,1,,DWORD,20,<empty>,,337,1,CPPASTTypeId,,<empty>
331861,UNKNOWN,1,,DWORD,24,<empty>,,339,1,CPPASTTypeId,,<empty>
331909,UNKNOWN,1,,DWORD,20,<empty>,,356,1,CPPASTTypeId,,<empty>
331918,UNKNOWN,1,,DWORD,24,<empty>,,358,1,CPPASTTypeId,,<empty>
332212,UNKNOWN,1,,DWORD,27,<empty>,,453,1,CPPASTTypeId,,<empty>
332260,UNKNOWN,1,,DWORD,43,<empty>,,468,1,CPPASTTypeId,,<empty>
332299,UNKNOWN,1,,SHORT,29,<empty>,,479,1,CPPASTTypeId,,<empty>
332735,UNKNOWN,1,,WORD,46,<empty>,,608,1,CPPASTTypeId,,<empty>
332785,UNKNOWN,1,,DWORD,62,<empty>,,614,1,CPPASTTypeId,,<empty>
332793,UNKNOWN,1,,DWORD,23,<empty>,,615,1,CPPASTTypeId,,<empty>
333223,UNKNOWN,2,,"TEST_METHOD(WriteWideGlyphUnicode)
    {
        auto hConsole = GetStdOutputHandle();",5,<empty>,,83,2,CPPASTProblemDeclaration,,<empty>
333228,UNKNOWN,5,,"VERIFY_WIN32_BOOL_SUCCEEDED(FillConsoleOutputCharacterW(hConsole,
                                                                L'\x304F',
                                                                1,
                                                                { 0, 0 }",9,<empty>,,87,5,CPPASTProblemDeclaration,,<empty>
333229,UNKNOWN,6,,",
                                                                &charsWritten));",73,<empty>,,90,6,CPPASTProblemDeclaration,,<empty>
333230,UNKNOWN,7,,"VERIFY_ARE_EQUAL(1u, charsWritten);",9,<empty>,,92,7,CPPASTProblemDeclaration,,<empty>
333231,UNKNOWN,8,,},5,<empty>,,93,8,CPPASTProblemDeclaration,,<empty>
333232,UNKNOWN,9,,"TEST_METHOD(UnsetWrap)
    {
        // WARNING: If this test suddenly decides to start failing,
        // this is because the wrap registry key is not set.
        // TODO GH #2859: Get/Set Registry Key for Wrap

        auto hConsole = GetStdOutputHandle();",5,<empty>,,95,9,CPPASTProblemDeclaration,,<empty>
333242,UNKNOWN,14,,sbiex.cbSize = sizeof(sbiex);,9,<empty>,,105,14,CPPASTProblemDeclaration,,<empty>
333243,UNKNOWN,15,,"VERIFY_WIN32_BOOL_SUCCEEDED(GetConsoleScreenBufferInfoEx(hConsole, &sbiex));",9,<empty>,,106,15,CPPASTProblemDeclaration,,<empty>
333262,UNKNOWN,22,,"VERIFY_WIN32_BOOL_SUCCEEDED(WriteConsoleW(hConsole,
                                                  input.data(),
                                                  gsl::narrow_cast<DWORD>(input.size()),
                                                  &charsWritten,
                                                  nullptr));",9,<empty>,,114,22,CPPASTProblemDeclaration,,<empty>
333275,UNKNOWN,27,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                consoleWidth,
                                                                { 0, 0 }",9,<empty>,,123,27,CPPASTProblemDeclaration,,<empty>
333276,UNKNOWN,28,,",
                                                                &readSize));",73,<empty>,,126,28,CPPASTProblemDeclaration,,<empty>
333291,UNKNOWN,33,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,131,33,CPPASTProblemDeclaration,,<empty>
333292,UNKNOWN,34,,bufferText = std::make_unique<wchar_t[]>(2);,9,<empty>,,133,34,CPPASTProblemDeclaration,,<empty>
333293,UNKNOWN,35,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                2,
                                                                { 0, 1 }",9,<empty>,,134,35,CPPASTProblemDeclaration,,<empty>
333294,UNKNOWN,36,,",
                                                                &readSize));",73,<empty>,,137,36,CPPASTProblemDeclaration,,<empty>
333295,UNKNOWN,37,,"VERIFY_ARE_EQUAL(2u, readSize);",9,<empty>,,140,37,CPPASTProblemDeclaration,,<empty>
333296,UNKNOWN,38,,"expected = WEX::Common::String(input.c_str(), readSize);",9,<empty>,,141,38,CPPASTProblemDeclaration,,<empty>
333297,UNKNOWN,39,,"actual = WEX::Common::String(bufferText.get(), readSize);",9,<empty>,,142,39,CPPASTProblemDeclaration,,<empty>
333298,UNKNOWN,40,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,143,40,CPPASTProblemDeclaration,,<empty>
333299,UNKNOWN,41,,"VERIFY_WIN32_BOOL_SUCCEEDED(FillConsoleOutputCharacterW(hConsole,
                                                                L'b',
                                                                consoleWidth,
                                                                { 2, 0 }",9,<empty>,,146,41,CPPASTProblemDeclaration,,<empty>
333300,UNKNOWN,42,,",
                                                                &charsWritten));",73,<empty>,,149,42,CPPASTProblemDeclaration,,<empty>
333301,UNKNOWN,43,,bufferText = std::make_unique<wchar_t[]>(consoleWidth);,9,<empty>,,153,43,CPPASTProblemDeclaration,,<empty>
333302,UNKNOWN,44,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                consoleWidth,
                                                                { 0, 0 }",9,<empty>,,154,44,CPPASTProblemDeclaration,,<empty>
333303,UNKNOWN,45,,",
                                                                &readSize));",73,<empty>,,157,45,CPPASTProblemDeclaration,,<empty>
333304,UNKNOWN,46,,"expected = WEX::Common::String(input.c_str(), 2);",9,<empty>,,160,46,CPPASTProblemDeclaration,,<empty>
333305,UNKNOWN,47,,"actual = WEX::Common::String(bufferText.get(), 2);",9,<empty>,,161,47,CPPASTProblemDeclaration,,<empty>
333306,UNKNOWN,48,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,162,48,CPPASTProblemDeclaration,,<empty>
333307,UNKNOWN,49,,"expected = WEX::Common::String(filled.c_str(), consoleWidth - 2);",9,<empty>,,164,49,CPPASTProblemDeclaration,,<empty>
333308,UNKNOWN,50,,"actual = WEX::Common::String(&bufferText[2], readSize - 2);",9,<empty>,,165,50,CPPASTProblemDeclaration,,<empty>
333309,UNKNOWN,51,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,166,51,CPPASTProblemDeclaration,,<empty>
333310,UNKNOWN,52,,bufferText = std::make_unique<wchar_t[]>(2);,9,<empty>,,169,52,CPPASTProblemDeclaration,,<empty>
333311,UNKNOWN,53,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                static_cast<SHORT>(2),
                                                                { 0, 0 }",9,<empty>,,170,53,CPPASTProblemDeclaration,,<empty>
333312,UNKNOWN,54,,",
                                                                &readSize));",73,<empty>,,173,54,CPPASTProblemDeclaration,,<empty>
333313,UNKNOWN,55,,"VERIFY_ARE_EQUAL(2u, readSize);",9,<empty>,,176,55,CPPASTProblemDeclaration,,<empty>
333314,UNKNOWN,56,,"expected = WEX::Common::String(input.c_str(), 2);",9,<empty>,,177,56,CPPASTProblemDeclaration,,<empty>
333315,UNKNOWN,57,,"actual = WEX::Common::String(bufferText.get(), readSize);",9,<empty>,,178,57,CPPASTProblemDeclaration,,<empty>
333316,UNKNOWN,58,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,179,58,CPPASTProblemDeclaration,,<empty>
333317,UNKNOWN,59,,sbiex.srWindow.Right -= 2;,9,<empty>,,182,59,CPPASTProblemDeclaration,,<empty>
333318,UNKNOWN,60,,sbiex.dwSize.X -= 2;,9,<empty>,,183,60,CPPASTProblemDeclaration,,<empty>
333319,UNKNOWN,61,,"VERIFY_WIN32_BOOL_SUCCEEDED(SetConsoleScreenBufferInfoEx(hConsole, &sbiex));",9,<empty>,,184,61,CPPASTProblemDeclaration,,<empty>
333320,UNKNOWN,62,,bufferText = std::make_unique<wchar_t[]>(consoleWidth - 2);,9,<empty>,,187,62,CPPASTProblemDeclaration,,<empty>
333321,UNKNOWN,63,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                consoleWidth - static_cast<SHORT>(2),
                                                                { 0, 0 }",9,<empty>,,188,63,CPPASTProblemDeclaration,,<empty>
333322,UNKNOWN,64,,",
                                                                &readSize));",73,<empty>,,191,64,CPPASTProblemDeclaration,,<empty>
333323,UNKNOWN,65,,"expected = WEX::Common::String(input.c_str(), 2);",9,<empty>,,194,65,CPPASTProblemDeclaration,,<empty>
333324,UNKNOWN,66,,"actual = WEX::Common::String(bufferText.get(), 2);",9,<empty>,,195,66,CPPASTProblemDeclaration,,<empty>
333325,UNKNOWN,67,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,196,67,CPPASTProblemDeclaration,,<empty>
333326,UNKNOWN,68,,"expected = WEX::Common::String(filled.c_str(), consoleWidth - 4);",9,<empty>,,198,68,CPPASTProblemDeclaration,,<empty>
333327,UNKNOWN,69,,"actual = WEX::Common::String(&bufferText[2], readSize - 2);",9,<empty>,,199,69,CPPASTProblemDeclaration,,<empty>
333328,UNKNOWN,70,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,200,70,CPPASTProblemDeclaration,,<empty>
333329,UNKNOWN,71,,bufferText = std::make_unique<wchar_t[]>(static_cast<SHORT>(2));,9,<empty>,,203,71,CPPASTProblemDeclaration,,<empty>
333330,UNKNOWN,72,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleOutputCharacterW(hConsole,
                                                                bufferText.get(),
                                                                static_cast<SHORT>(2),
                                                                { 0, 0 }",9,<empty>,,204,72,CPPASTProblemDeclaration,,<empty>
333331,UNKNOWN,73,,",
                                                                &readSize));",73,<empty>,,207,73,CPPASTProblemDeclaration,,<empty>
333332,UNKNOWN,74,,"VERIFY_ARE_EQUAL(2u, readSize);",9,<empty>,,210,74,CPPASTProblemDeclaration,,<empty>
333333,UNKNOWN,75,,"expected = WEX::Common::String(input.c_str(), 2);",9,<empty>,,211,75,CPPASTProblemDeclaration,,<empty>
333334,UNKNOWN,76,,"actual = WEX::Common::String(bufferText.get(), readSize);",9,<empty>,,212,76,CPPASTProblemDeclaration,,<empty>
333335,UNKNOWN,77,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,213,77,CPPASTProblemDeclaration,,<empty>
333336,UNKNOWN,78,,},5,<empty>,,214,78,CPPASTProblemDeclaration,,<empty>
333337,UNKNOWN,79,,};,1,<empty>,,215,79,CPPASTProblemDeclaration,,<empty>
333357,UNKNOWN,-1,,),31,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
333358,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(TestSetup);",5,<empty>,,17,3,CPPASTProblemDeclaration,,<empty>
333361,UNKNOWN,-1,,),49,<empty>,,22,6,CPPASTProblemDeclaration,,<empty>
333362,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:dwConsoleOutput"", L""{0, 1, 0xFFFFFFFF}"")
        TEST_METHOD_PROPERTY(L""Data:bMaximumWindow"", L""{TRUE, FALSE}"")
        TEST_METHOD_PROPERTY(L""Data:strOperation"", L""{Get, GetEx, SetEx}"")
    END_TEST_METHOD();",9,<empty>,,23,7,CPPASTProblemDeclaration,,<empty>
333364,UNKNOWN,-1,,),45,<empty>,,28,9,CPPASTProblemDeclaration,,<empty>
333365,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:dwConsoleOutput"", L""{0, 0xFFFFFFFF}"")
    END_TEST_METHOD();",9,<empty>,,29,10,CPPASTProblemDeclaration,,<empty>
333440,UNKNOWN,1,,HANDLE,27,<empty>,,70,1,CPPASTTypeId,,<empty>
333462,UNKNOWN,1,,BOOL,94,<empty>,,79,1,CPPASTTypeId,,<empty>
333475,UNKNOWN,1,,BOOL,91,<empty>,,83,1,CPPASTTypeId,,<empty>
333498,UNKNOWN,1,,BOOL,89,<empty>,,89,1,CPPASTTypeId,,<empty>
333521,UNKNOWN,1,,BOOL,89,<empty>,,94,1,CPPASTTypeId,,<empty>
333552,UNKNOWN,1,,HANDLE,60,<empty>,,110,1,CPPASTTypeId,,<empty>
333562,UNKNOWN,1,,DWORD,39,<empty>,,112,1,CPPASTTypeId,,<empty>
333587,UNKNOWN,1,,DWORD,39,<empty>,,120,1,CPPASTTypeId,,<empty>
334442,UNKNOWN,-1,,),32,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
334443,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_CLASS_SETUP(TestSetup);",5,<empty>,,27,3,CPPASTProblemDeclaration,,<empty>
334462,UNKNOWN,-1,,),44,<empty>,,54,22,CPPASTProblemDeclaration,,<empty>
334463,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD();",9,<empty>,,55,23,CPPASTProblemDeclaration,,<empty>
334464,UNKNOWN,2,,"void VerifyNumberOfInputRecords(const HANDLE hConsoleInput, _In_ DWORD nInputs)
{
    WEX::TestExecution::SetVerifyOutput verifySettings(WEX::TestExecution::VerifyOutputSettings::LogOnlyFailures);
    auto nInputEvents = (DWORD)-1;
    VERIFY_WIN32_BOOL_SUCCEEDED(GetNumberOfConsoleInputEvents(hConsoleInput, &nInputEvents));
    VERIFY_ARE_EQUAL(nInputEvents,
                     nInputs,
                     L""Verify number of input events"");
}",1,<empty>,,59,2,CPPASTProblemDeclaration,,<empty>
334527,UNKNOWN,1,,DWORD,30,<empty>,,93,1,CPPASTTypeId,,<empty>
334550,UNKNOWN,6,,"void GenerateAndWriteInputRecords(const HANDLE hConsoleInput,
                                  const UINT cRecordsToGenerate,
                                  _Out_writes_(cRecs) INPUT_RECORD* prgRecs,
                                  const DWORD cRecs,
                                  _Out_ PDWORD pdwWritten)
{
    Log::Comment(String().Format(L""Generating %d input events"", cRecordsToGenerate));
    for (UINT iRecord = 0; iRecord < cRecs; iRecord++)
    {
        prgRecs[iRecord].EventType = KEY_EVENT;
        prgRecs[iRecord].Event.KeyEvent.bKeyDown = FALSE;
        prgRecs[iRecord].Event.KeyEvent.wRepeatCount = 1;
        prgRecs[iRecord].Event.KeyEvent.wVirtualKeyCode = ('A' + (WORD)iRecord);
    }

    Log::Comment(L""Writing events"");
    VERIFY_WIN32_BOOL_SUCCEEDED(WriteConsoleInput(hConsoleInput, prgRecs, cRecs, pdwWritten));
    VERIFY_ARE_EQUAL(*pdwWritten,
                     cRecs,
                     L""verify number written"");
}",1,<empty>,,103,6,CPPASTProblemDeclaration,,<empty>
334880,UNKNOWN,1,,DWORD,32,<empty>,,219,1,CPPASTTypeId,,<empty>
334901,UNKNOWN,1,,DWORD,32,<empty>,,225,1,CPPASTTypeId,,<empty>
334946,UNKNOWN,1,,DWORD,32,<empty>,,236,1,CPPASTTypeId,,<empty>
334975,UNKNOWN,1,,DWORD,30,<empty>,,247,1,CPPASTTypeId,,<empty>
334992,UNKNOWN,1,,DWORD,30,<empty>,,251,1,CPPASTTypeId,,<empty>
335035,UNKNOWN,1,,DWORD,30,<empty>,,265,1,CPPASTTypeId,,<empty>
335058,UNKNOWN,1,,DWORD,30,<empty>,,270,1,CPPASTTypeId,,<empty>
335083,UNKNOWN,1,,DWORD,31,<empty>,,279,1,CPPASTTypeId,,<empty>
335116,UNKNOWN,1,,DWORD,31,<empty>,,290,1,CPPASTTypeId,,<empty>
335139,UNKNOWN,1,,DWORD,31,<empty>,,295,1,CPPASTTypeId,,<empty>
335143,UNKNOWN,13,,"void FillInputRecordHelper(_Inout_ INPUT_RECORD* const pir, _In_ wchar_t wch, _In_ bool fIsKeyDown)
{
    pir->EventType = KEY_EVENT;
    pir->Event.KeyEvent.wRepeatCount = 1;
    pir->Event.KeyEvent.dwControlKeyState = 0;
    pir->Event.KeyEvent.bKeyDown = !!fIsKeyDown;
    pir->Event.KeyEvent.uChar.UnicodeChar = wch;

    // This only holds true for capital letters from A-Z.
    VERIFY_IS_TRUE(wch >= 'A' && wch <= 'Z');
    pir->Event.KeyEvent.wVirtualKeyCode = wch;

    pir->Event.KeyEvent.wVirtualScanCode = static_cast<WORD>(MapVirtualKeyW(pir->Event.KeyEvent.wVirtualKeyCode, MAPVK_VK_TO_VSC));
}",1,<empty>,,298,13,CPPASTProblemDeclaration,,<empty>
335205,UNKNOWN,1,,DWORD,38,<empty>,,333,1,CPPASTTypeId,,<empty>
335753,UNKNOWN,1,,DWORD,50,<empty>,,590,1,CPPASTTypeId,,<empty>
335888,UNKNOWN,1,,DWORD,34,<empty>,,624,1,CPPASTTypeId,,<empty>
335906,UNKNOWN,1,,DWORD,31,<empty>,,628,1,CPPASTTypeId,,<empty>
336021,UNKNOWN,1,,DWORD,34,<empty>,,650,1,CPPASTTypeId,,<empty>
336039,UNKNOWN,1,,DWORD,31,<empty>,,654,1,CPPASTTypeId,,<empty>
336259,UNKNOWN,1,,DWORD,49,<empty>,,697,1,CPPASTTypeId,,<empty>
336303,UNKNOWN,1,,DWORD,50,<empty>,,710,1,CPPASTTypeId,,<empty>
336319,UNKNOWN,1,,DWORD,46,<empty>,,717,1,CPPASTTypeId,,<empty>
336332,UNKNOWN,-1,,),31,<empty>,,13,2,CPPASTProblemDeclaration,,<empty>
336333,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(TestSetup);",5,<empty>,,14,3,CPPASTProblemDeclaration,,<empty>
336363,UNKNOWN,-1,,),34,<empty>,,43,2,CPPASTProblemStatement,,<empty>
336367,UNKNOWN,-1,,),52,<empty>,,44,4,CPPASTProblemStatement,,<empty>
336369,UNKNOWN,-1,,),32,<empty>,,45,6,CPPASTProblemStatement,,<empty>
336529,UNKNOWN,1,,DWORD,37,<empty>,,95,1,CPPASTTypeId,,<empty>
336700,UNKNOWN,1,,DWORD,38,<empty>,,163,1,CPPASTTypeId,,<empty>
336720,UNKNOWN,1,,DWORD,38,<empty>,,170,1,CPPASTTypeId,,<empty>
336749,UNKNOWN,1,,DWORD,38,<empty>,,179,1,CPPASTTypeId,,<empty>
336782,UNKNOWN,1,,DWORD,38,<empty>,,189,1,CPPASTTypeId,,<empty>
336811,UNKNOWN,1,,DWORD,38,<empty>,,199,1,CPPASTTypeId,,<empty>
336848,UNKNOWN,1,,DWORD,38,<empty>,,210,1,CPPASTTypeId,,<empty>
336893,UNKNOWN,-1,,),50,<empty>,,10,2,CPPASTProblemDeclaration,,<empty>
336894,UNKNOWN,-1,,"END_TEST_CLASS()

    // This test is intended to make sure that we do not regress after the _handlePostCharInputLoop fix in OpenConsole:c0ab9cb5b
    TEST_METHOD(WriteWhileReadingInputCrash)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"") // Don't pollute other tests by isolating our potential crash and buffer resizing to this test.
        END_TEST_METHOD_PROPERTIES()

        // OneCore systems can't adjust the window/buffer size, so we'll skip making it smaller.
        // On Desktop systems, make it smaller so the test runs faster.
        if (!OneCoreDelay::IsIsWindowPresent())
        {
            Log::Comment(L""This scenario requires a large buffer size, which OneCore does not provide."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }

        using namespace std::string_view_literals;

        const auto inputHandle = GetStdInputHandle();
        const auto outputHandle ...",5,<empty>,,11,3,CPPASTProblemDeclaration,,<empty>
336946,UNKNOWN,-1,,),33,<empty>,,19,2,CPPASTProblemDeclaration,,<empty>
336947,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_CLASS()

    TEST_CLASS_SETUP(TestSetup);",9,<empty>,,20,3,CPPASTProblemDeclaration,,<empty>
339152,UNKNOWN,1,,DWORD,34,<empty>,,562,1,CPPASTTypeId,,<empty>
339172,UNKNOWN,1,,DWORD,34,<empty>,,565,1,CPPASTTypeId,,<empty>
339346,UNKNOWN,1,,DWORD,34,<empty>,,611,1,CPPASTTypeId,,<empty>
339366,UNKNOWN,1,,DWORD,34,<empty>,,614,1,CPPASTTypeId,,<empty>
339573,UNKNOWN,1,,DWORD,34,<empty>,,671,1,CPPASTTypeId,,<empty>
339593,UNKNOWN,1,,DWORD,34,<empty>,,674,1,CPPASTTypeId,,<empty>
339860,UNKNOWN,1,,DWORD,34,<empty>,,742,1,CPPASTTypeId,,<empty>
339880,UNKNOWN,1,,DWORD,34,<empty>,,745,1,CPPASTTypeId,,<empty>
340293,UNKNOWN,1,,DWORD,34,<empty>,,836,1,CPPASTTypeId,,<empty>
340313,UNKNOWN,1,,DWORD,34,<empty>,,839,1,CPPASTTypeId,,<empty>
340729,UNKNOWN,1,,DWORD,34,<empty>,,936,1,CPPASTTypeId,,<empty>
340749,UNKNOWN,1,,DWORD,34,<empty>,,939,1,CPPASTTypeId,,<empty>
340999,UNKNOWN,1,,DWORD,21,<empty>,,1019,1,CPPASTTypeId,,<empty>
341043,UNKNOWN,-1,,),34,<empty>,,1035,2,CPPASTProblemStatement,,<empty>
341047,UNKNOWN,-1,,),55,<empty>,,1036,4,CPPASTProblemStatement,,<empty>
341051,UNKNOWN,-1,,),65,<empty>,,1037,6,CPPASTProblemStatement,,<empty>
341127,UNKNOWN,-1,,),33,<empty>,,11,2,CPPASTProblemDeclaration,,<empty>
341128,UNKNOWN,-1,,"END_TEST_CLASS()

// UAP test type doesn't work quite right in VSO, skip. We'll get it in the RI-TP internally.
#ifdef __INSIDE_WINDOWS
    BEGIN_TEST_METHOD(WrongWayVerbsUAP)
        TEST_METHOD_PROPERTY(L""RunAs"", L""UAP"")
        TEST_METHOD_PROPERTY(L""UAP:AppxManifest"", L""MUA"")
    END_TEST_METHOD();
#endif

    BEGIN_TEST_METHOD(WrongWayVerbsUser)
        TEST_METHOD_PROPERTY(L""RunAs"", L""User"")
    END_TEST_METHOD();",5,<empty>,,12,3,CPPASTProblemDeclaration,,<empty>
341129,UNKNOWN,2,,"void DoWrongWayVerbTest(_In_ BOOL bResultExpected, _In_ DWORD dwStatusExpected)
{
    DWORD dwResult;
    BOOL bResultActual;

    // Try to read the output buffer
    {
        Log::Comment(L""Read the output buffer using string commands."");
        {
            wchar_t pwsz[50];
            char psz[50];
            COORD coord = { 0 };

            SetLastError(0);
            bResultActual = ReadConsoleOutputCharacterW(GetStdOutputHandle(), pwsz, ARRAYSIZE(pwsz), coord, &dwResult);
            VERIFY_ARE_EQUAL(bResultExpected, bResultActual);
            VERIFY_ARE_EQUAL(dwStatusExpected, GetLastError());

            SetLastError(0);
            bResultActual = ReadConsoleOutputCharacterA(GetStdOutputHandle(), psz, ARRAYSIZE(psz), coord, &dwResult);
            VERIFY_ARE_EQUAL(bResultExpected, bResultActual);
            VERIFY_ARE_EQUAL(dwStatusExpected, GetLastError());

            WORD attrs[50];
            SetLastError(0);
            bResultActual = ReadConsoleOutputAtt...",1,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
341186,UNKNOWN,-1,,),35,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
341187,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(MethodSetup)
    {
        g_hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        DWORD outMode;
        VERIFY_WIN32_BOOL_SUCCEEDED(GetConsoleMode(g_hOut, &outMode));
        outMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_PROCESSED_OUTPUT;
        VERIFY_WIN32_BOOL_SUCCEEDED(SetConsoleMode(g_hOut, outMode));
        CONSOLE_SCREEN_BUFFER_INFOEX sbiex = { 0 };
        sbiex.cbSize = sizeof(sbiex);

        auto fSuccess = GetConsoleScreenBufferInfoEx(g_hOut, &sbiex);
        if (fSuccess)
        {
            sbiex.srWindow.Bottom++; // hack because the API is not good at roundtrip

            g_sbiex_backup = sbiex;

            // Set the Color table to a known color table
            sbiex.ColorTable[0] = RGB(0x0000, 0x0000, 0x0000);
            sbiex.ColorTable[1] = RGB(0x0000, 0x0000, 0x0080);
            sbiex.ColorTable[2] = RGB(0x0000, 0x0080, 0x0000);
            sbiex.ColorTable[3] = RGB(0x0000, 0x0080, 0x0080);
            sbie...",5,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
341188,UNKNOWN,-1,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        SetConsoleScreenBufferInfoEx(g_hOut, &g_sbiex_backup);",5,<empty>,,68,4,CPPASTProblemDeclaration,,<empty>
341189,UNKNOWN,-1,,return true;,9,<empty>,,72,5,CPPASTProblemDeclaration,,<empty>
341195,UNKNOWN,23,,};,1,<empty>,,79,23,CPPASTProblemDeclaration,,<empty>
342592,UNKNOWN,-1,,),32,<empty>,,13,2,CPPASTProblemDeclaration,,<empty>
342593,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD_SETUP(TestSetup);",5,<empty>,,14,3,CPPASTProblemDeclaration,,<empty>
342615,UNKNOWN,4,,"void TestGetConsoleTitleAFillHelper(_Out_writes_all_(cchBuffer) char* const chBuffer,
                                    const size_t cchBuffer,
                                    const char chFill)
{
    for (size_t i = 0; i < cchBuffer; i++)
    {
        chBuffer[i] = chFill;
    }
}",1,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
342616,UNKNOWN,5,,"void TestGetConsoleTitleWFillHelper(_Out_writes_all_(cchBuffer) wchar_t* const wchBuffer,
                                    const size_t cchBuffer,
                                    const wchar_t wchFill)
{
    for (size_t i = 0; i < cchBuffer; i++)
    {
        wchBuffer[i] = wchFill;
    }
}",1,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
342617,UNKNOWN,6,,"void TestGetConsoleTitleAPrepExpectedHelper(_In_reads_(cchTitle) const char* const chTitle,
                                            const size_t cchTitle,
                                            _Inout_updates_all_(cchReadBuffer) char* const chReadBuffer,
                                            const size_t cchReadBuffer,
                                            _Inout_updates_all_(cchReadExpected) char* const chReadExpected,
                                            const size_t cchReadExpected,
                                            const size_t cchTryToRead)
{
    // Fill our read buffer and expected with all Zs to start
    TestGetConsoleTitleAFillHelper(chReadBuffer, cchReadBuffer, 'Z');
    TestGetConsoleTitleAFillHelper(chReadExpected, cchReadExpected, 'Z');

    // Prep expected data
    if (cchTryToRead >= cchTitle - 1)
    {
        VERIFY_SUCCEEDED(StringCchCopyNA(chReadExpected, cchReadExpected, chTitle, cchTryToRead)); // Copy as much room as we sa...",1,<empty>,,53,6,CPPASTProblemDeclaration,,<empty>
342618,UNKNOWN,7,,"void TestGetConsoleTitleWPrepExpectedHelper(_In_reads_(cchTitle) const wchar_t* const wchTitle,
                                            const size_t cchTitle,
                                            _Inout_updates_all_(cchReadBuffer) wchar_t* const wchReadBuffer,
                                            const size_t cchReadBuffer,
                                            _Inout_updates_all_(cchReadExpected) wchar_t* const wchReadExpected,
                                            const size_t cchReadExpected,
                                            const size_t cchTryToRead)
{
    // Fill our read buffer and expected with all Zs to start
    TestGetConsoleTitleWFillHelper(wchReadBuffer, cchReadBuffer, L'Z');
    TestGetConsoleTitleWFillHelper(wchReadExpected, cchReadExpected, L'Z');

    // Prep expected data
    const auto cchCopy = std::min(cchTitle, cchTryToRead);
    VERIFY_SUCCEEDED(StringCchCopyNW(wchReadExpected, cchReadBuffer, wchTitle, cchCopy - 1)); // ...",1,<empty>,,81,7,CPPASTProblemDeclaration,,<empty>
342619,UNKNOWN,8,,"void TestGetConsoleTitleAVerifyHelper(_Inout_updates_(cchReadBuffer) char* const chReadBuffer,
                                      const size_t cchReadBuffer,
                                      const size_t cchTryToRead,
                                      const DWORD dwExpectedRetVal,
                                      const DWORD dwExpectedLastError,
                                      _In_reads_(cchExpected) const char* const chReadExpected,
                                      const size_t cchExpected)
{
    VERIFY_ARE_EQUAL(cchExpected, cchReadBuffer);

    SetLastError(0);
    const auto dwRetVal = GetConsoleTitleA(chReadBuffer, (DWORD)cchTryToRead);
    const auto dwLastError = GetLastError();

    VERIFY_ARE_EQUAL(dwExpectedRetVal, dwRetVal);
    VERIFY_ARE_EQUAL(dwExpectedLastError, dwLastError);

    if (chReadExpected != nullptr)
    {
        for (size_t i = 0; i < cchExpected; i++)
        {
            const wchar_t wchExpectedVis = chReadExpected[i] < 0x3...",1,<empty>,,98,8,CPPASTProblemDeclaration,,<empty>
342620,UNKNOWN,9,,"void TestGetConsoleTitleWVerifyHelper(_Inout_updates_(cchReadBuffer) wchar_t* const wchReadBuffer,
                                      const size_t cchReadBuffer,
                                      const size_t cchTryToRead,
                                      const DWORD dwExpectedRetVal,
                                      const DWORD dwExpectedLastError,
                                      _In_reads_(cchExpected) const wchar_t* const wchReadExpected,
                                      const size_t cchExpected)
{
    VERIFY_ARE_EQUAL(cchExpected, cchReadBuffer);

    SetLastError(0);
    const auto dwRetVal = GetConsoleTitleW(wchReadBuffer, (DWORD)cchTryToRead);
    const auto dwLastError = GetLastError();

    VERIFY_ARE_EQUAL(dwExpectedRetVal, dwRetVal);
    VERIFY_ARE_EQUAL(dwExpectedLastError, dwLastError);

    if (wchReadExpected != nullptr)
    {
        for (size_t i = 0; i < cchExpected; i++)
        {
            const wchar_t wchExpectedVis = wchReadExpect...",1,<empty>,,134,9,CPPASTProblemDeclaration,,<empty>
342755,UNKNOWN,1,,DWORD,88,<empty>,,215,1,CPPASTTypeId,,<empty>
342797,UNKNOWN,1,,DWORD,88,<empty>,,230,1,CPPASTTypeId,,<empty>
342841,UNKNOWN,1,,DWORD,88,<empty>,,245,1,CPPASTTypeId,,<empty>
342963,UNKNOWN,1,,DWORD,89,<empty>,,284,1,CPPASTTypeId,,<empty>
343003,UNKNOWN,1,,DWORD,89,<empty>,,299,1,CPPASTTypeId,,<empty>
343045,UNKNOWN,1,,DWORD,89,<empty>,,314,1,CPPASTTypeId,,<empty>
343089,UNKNOWN,1,,DWORD,89,<empty>,,329,1,CPPASTTypeId,,<empty>
343155,UNKNOWN,1,,WCHAR,41,<empty>,,25,1,CPPASTTypeId,,<empty>
343227,UNKNOWN,-1,,"void TestRunner(_In_opt_ WORD* const pwAttrOverride,
                    const bool fUseTrueType,
                    const DbcsWriteRead::WriteMode WriteMode,
                    const UnicodeMode fWriteInUnicode,
                    const DbcsWriteRead::ReadMode ReadMode,
                    const bool fReadWithUnicode);",5,<empty>,,64,4,CPPASTProblemDeclaration,,<empty>
343228,UNKNOWN,-1,,"bool Setup(_In_ bool fIsTrueType,
               _Out_ HANDLE* const phOut,
               _Out_ WORD* const pwAttributes);",5,<empty>,,71,5,CPPASTProblemDeclaration,,<empty>
343280,UNKNOWN,-1,,),31,<empty>,,111,2,CPPASTProblemDeclaration,,<empty>
343281,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Class"")
    END_TEST_CLASS();",9,<empty>,,112,3,CPPASTProblemDeclaration,,<empty>
343286,UNKNOWN,-1,,),40,<empty>,,122,8,CPPASTProblemDeclaration,,<empty>
343287,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""Data:fUseTrueTypeFont"", L""{true, false}"")
        TEST_METHOD_PROPERTY(L""Data:WriteMode"", L""{0, 1, 2, 3}"")
        TEST_METHOD_PROPERTY(L""Data:fWriteInUnicode"", L""{0, 1, 2}"")
        TEST_METHOD_PROPERTY(L""Data:ReadMode"", L""{0, 1}"")
        TEST_METHOD_PROPERTY(L""Data:fReadInUnicode"", L""{true, false}"")
    END_TEST_METHOD()

    TEST_METHOD(TestDbcsBisect);",9,<empty>,,123,9,CPPASTProblemDeclaration,,<empty>
343289,UNKNOWN,-1,,),53,<empty>,,132,11,CPPASTProblemDeclaration,,<empty>
343290,UNKNOWN,-1,,"TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsBisectWriteCellsEndW)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsBisectWriteCellsBeginA)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsBisectWriteCellsEndA)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsOneByOne)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsTrailLead)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsStdCoutScenario)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestDbcsBackupRestore)
        TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_METHOD()

    BEGIN_TEST_MET...",9,<empty>,,133,12,CPPASTProblemDeclaration,,<empty>
343297,UNKNOWN,11,,"bool DbcsWriteRead::Setup(_In_ bool fIsTrueType,
                          _Out_ HANDLE* const phOut,
                          _Out_ WORD* const pwAttributes)
{
    const auto hOut = GetStdOutputHandle();

    // Ensure that the console is set into the appropriate codepage for the test
    VERIFY_WIN32_BOOL_SUCCEEDED_RETURN(SetConsoleCP(JAPANESE_CP));
    VERIFY_WIN32_BOOL_SUCCEEDED_RETURN(SetConsoleOutputCP(JAPANESE_CP));

    // Now set up the font. Many of these APIs are oddly dependent on font, so set as appropriate.
    CONSOLE_FONT_INFOEX cfiex = { 0 };
    cfiex.cbSize = sizeof(cfiex);
    if (!fIsTrueType)
    {
        // We use Terminal as the raster font name always.
        wcscpy_s(cfiex.FaceName, L""Terminal"");

        // Use default raster font size from Japanese system.
        cfiex.dwFontSize.X = 8;
        cfiex.dwFontSize.Y = 18;
    }
    else
    {
        wcscpy_s(cfiex.FaceName, L""MS Gothic"");
        cfiex.dwFontSize.Y = 16;
    }

    VERIFY_WIN32_BOOL_SUC...",1,<empty>,,174,11,CPPASTProblemDeclaration,,<empty>
345250,UNKNOWN,19,,"void DbcsWriteRead::TestRunner(_In_opt_ WORD* const pwAttrOverride,
                               const bool fUseTrueType,
                               const DbcsWriteRead::WriteMode WriteMode,
                               const UnicodeMode fWriteInUnicode,
                               const DbcsWriteRead::ReadMode ReadMode,
                               const bool fReadWithUnicode)
{
    // First we need to set up the tests by clearing out the first line of the buffer,
    // retrieving the appropriate output handle, and getting the colors (attributes)
    // used by default in the buffer (set during clearing as well).
    HANDLE hOut;
    WORD wAttributes;
    if (!DbcsWriteRead::Setup(fUseTrueType, &hOut, &wAttributes))
    {
        // If we can't set up (setup will detect systems where this test cannot operate) then return early.
        return;
    }

    // Some tests might want to override the colors applied to ensure both parts of the CHAR_INFO union
    // work for...",1,<empty>,,1343,19,CPPASTProblemDeclaration,,<empty>
345273,UNKNOWN,1,,DbcsWriteRead::WriteMode,23,<empty>,,1391,1,CPPASTTypeId,,<empty>
345287,UNKNOWN,1,,DbcsWriteRead::UnicodeMode,29,<empty>,,1395,1,CPPASTTypeId,,<empty>
345301,UNKNOWN,1,,DbcsWriteRead::ReadMode,22,<empty>,,1399,1,CPPASTTypeId,,<empty>
346476,UNKNOWN,1,,DWORD,68,<empty>,,1795,1,CPPASTTypeId,,<empty>
346512,UNKNOWN,1,,BYTE,32,<empty>,,1808,1,CPPASTTypeId,,<empty>
346565,UNKNOWN,1,,DWORD,74,<empty>,,1832,1,CPPASTTypeId,,<empty>
346575,UNKNOWN,1,,DWORD,50,<empty>,,1837,1,CPPASTTypeId,,<empty>
346615,UNKNOWN,1,,BYTE,40,<empty>,,1846,1,CPPASTTypeId,,<empty>
346620,UNKNOWN,1,,BYTE,72,<empty>,,1846,1,CPPASTTypeId,,<empty>
346960,UNKNOWN,1,,unsigned char,31,<empty>,,1970,1,CPPASTTypeId,,<empty>
346963,UNKNOWN,1,,unsigned char,51,<empty>,,1970,1,CPPASTTypeId,,<empty>
346969,UNKNOWN,1,,unsigned char,31,<empty>,,1971,1,CPPASTTypeId,,<empty>
346972,UNKNOWN,1,,unsigned char,51,<empty>,,1971,1,CPPASTTypeId,,<empty>
346985,UNKNOWN,1,,unsigned char,34,<empty>,,1976,1,CPPASTTypeId,,<empty>
346988,UNKNOWN,1,,unsigned char,57,<empty>,,1976,1,CPPASTTypeId,,<empty>
346994,UNKNOWN,1,,unsigned char,34,<empty>,,1977,1,CPPASTTypeId,,<empty>
346997,UNKNOWN,1,,unsigned char,57,<empty>,,1977,1,CPPASTTypeId,,<empty>
347059,UNKNOWN,1,,DWORD,22,<empty>,,2005,1,CPPASTTypeId,,<empty>
347094,UNKNOWN,1,,unsigned char,23,<empty>,,2011,1,CPPASTTypeId,,<empty>
347097,UNKNOWN,1,,unsigned char,43,<empty>,,2011,1,CPPASTTypeId,,<empty>
347103,UNKNOWN,1,,unsigned char,23,<empty>,,2012,1,CPPASTTypeId,,<empty>
347106,UNKNOWN,1,,unsigned char,43,<empty>,,2012,1,CPPASTTypeId,,<empty>
347118,UNKNOWN,1,,DWORD,22,<empty>,,2015,1,CPPASTTypeId,,<empty>
347153,UNKNOWN,1,,unsigned char,23,<empty>,,2021,1,CPPASTTypeId,,<empty>
347158,UNKNOWN,1,,unsigned char,47,<empty>,,2021,1,CPPASTTypeId,,<empty>
347164,UNKNOWN,1,,unsigned char,23,<empty>,,2022,1,CPPASTTypeId,,<empty>
347169,UNKNOWN,1,,unsigned char,48,<empty>,,2022,1,CPPASTTypeId,,<empty>
347175,UNKNOWN,1,,unsigned char,23,<empty>,,2023,1,CPPASTTypeId,,<empty>
347178,UNKNOWN,1,,unsigned char,43,<empty>,,2023,1,CPPASTTypeId,,<empty>
347184,UNKNOWN,1,,unsigned char,23,<empty>,,2024,1,CPPASTTypeId,,<empty>
347187,UNKNOWN,1,,unsigned char,43,<empty>,,2024,1,CPPASTTypeId,,<empty>
347199,UNKNOWN,1,,DWORD,22,<empty>,,2027,1,CPPASTTypeId,,<empty>
347234,UNKNOWN,1,,unsigned char,23,<empty>,,2033,1,CPPASTTypeId,,<empty>
347239,UNKNOWN,1,,unsigned char,47,<empty>,,2033,1,CPPASTTypeId,,<empty>
347245,UNKNOWN,1,,unsigned char,23,<empty>,,2034,1,CPPASTTypeId,,<empty>
347250,UNKNOWN,1,,unsigned char,48,<empty>,,2034,1,CPPASTTypeId,,<empty>
347256,UNKNOWN,1,,unsigned char,23,<empty>,,2035,1,CPPASTTypeId,,<empty>
347261,UNKNOWN,1,,unsigned char,48,<empty>,,2035,1,CPPASTTypeId,,<empty>
347267,UNKNOWN,1,,unsigned char,23,<empty>,,2036,1,CPPASTTypeId,,<empty>
347272,UNKNOWN,1,,unsigned char,48,<empty>,,2036,1,CPPASTTypeId,,<empty>
347278,UNKNOWN,1,,unsigned char,23,<empty>,,2037,1,CPPASTTypeId,,<empty>
347283,UNKNOWN,1,,unsigned char,48,<empty>,,2037,1,CPPASTTypeId,,<empty>
347289,UNKNOWN,1,,unsigned char,23,<empty>,,2038,1,CPPASTTypeId,,<empty>
347294,UNKNOWN,1,,unsigned char,48,<empty>,,2038,1,CPPASTTypeId,,<empty>
347300,UNKNOWN,1,,unsigned char,23,<empty>,,2039,1,CPPASTTypeId,,<empty>
347305,UNKNOWN,1,,unsigned char,48,<empty>,,2039,1,CPPASTTypeId,,<empty>
347311,UNKNOWN,1,,unsigned char,23,<empty>,,2040,1,CPPASTTypeId,,<empty>
347316,UNKNOWN,1,,unsigned char,48,<empty>,,2040,1,CPPASTTypeId,,<empty>
347356,UNKNOWN,1,,DWORD,31,<empty>,,2059,1,CPPASTTypeId,,<empty>
347740,UNKNOWN,-1,,),33,<empty>,,13,2,CPPASTProblemDeclaration,,<empty>
347741,UNKNOWN,-1,,"END_TEST_CLASS()

    TEST_METHOD(LaunchV1Console);",5,<empty>,,14,3,CPPASTProblemDeclaration,,<empty>
347968,UNKNOWN,1,,DWORD,45,<empty>,,97,1,CPPASTTypeId,,<empty>
348206,UNKNOWN,16,,"bool CheckIfFileExists(_In_ PCWSTR pwszPath) noexcept
{
    wil::unique_hfile hFile(CreateFileW(pwszPath,
                                        GENERIC_READ,
                                        0,
                                        nullptr,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        nullptr));

    if (hFile.get() != nullptr && hFile.get() != INVALID_HANDLE_VALUE)
    {
        return true;
    }
    else
    {
        return false;
    }
}",1,<empty>,,124,16,CPPASTProblemDeclaration,,<empty>
348602,UNKNOWN,12,,[[nodiscard]] bool CheckIfFileExists(_In_ PCWSTR pwszPath) noexcept;,1,<empty>,,61,12,CPPASTProblemDeclaration,,<empty>
348702,UNKNOWN,18,,"BEGIN_MODULE()
    MODULE_PROPERTY(L""WinPerfSource"", L""Console"")
    MODULE_PROPERTY(L""WinPerf.WPRProfile"", L""ConsolePerf.wprp"")
    MODULE_PROPERTY(L""WinPerf.WPRProfileId"", L""ConsolePerf.Verbose.File"")
    MODULE_PROPERTY(L""WinPerf.Regions"", L""ConsolePerf.Regions.xml"")

    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\sdk\\lib\\minwin\\$arch\\api-ms-win-core-console-l1-2-1.lib"")
    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\sdk\\lib\\minwin\\$arch\\api-ms-win-core-console-l2-2-0.lib"")
    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\sdk\\lib\\minwin\\$arch\\api-ms-win-core-console-l3-2-0.lib"")
    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\mincore\\priv_sdk\\lib\\$arch\\api-ms-win-core-console-ansi-l2-1-0.lib"")
    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\minwin\\priv_sdk\\inc\\conmsgl1.h"")
    MODULE_PROPERTY(L""ArtifactUnderTest"", L""onecore\\internal\\minwin\\priv_sdk\\inc\\conmsgl2.h"")
    MODULE_PROPE...",1,<empty>,,45,18,CPPASTProblemDeclaration,,<empty>
348703,UNKNOWN,19,,"MODULE_CLEANUP(ModuleCleanup)
{
    v2ModeHelper.reset();",1,<empty>,,289,19,CPPASTProblemDeclaration,,<empty>
348704,UNKNOWN,20,,return true;,5,<empty>,,292,20,CPPASTProblemDeclaration,,<empty>
348705,UNKNOWN,21,,},1,<empty>,,293,21,CPPASTProblemDeclaration,,<empty>
348727,UNKNOWN,-1,,),35,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
348728,UNKNOWN,-1,,"END_TEST_CLASS()

    void TurnOffModifierKeys(HWND hwnd)
    {
        // these are taken from GetControlKeyState.
        static const WPARAM modifiers[8] = {
            VK_LMENU,
            VK_RMENU,
            VK_LCONTROL,
            VK_RCONTROL,
            VK_SHIFT,
            VK_NUMLOCK,
            VK_SCROLL,
            VK_CAPITAL
        };
        for (unsigned int i = 0; i < 8; ++i)
        {
            PostMessage(hwnd, CM_SET_KEY_STATE, modifiers[i], KEY_STATE_RELEASED);
        }
    }",5,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
348729,UNKNOWN,-1,,"TEST_METHOD(TestContextMenuKey)
    {
        if (!OneCoreDelay::IsPostMessageWPresent())
        {
            Log::Comment(L""Injecting keys to the window message queue cannot be done on systems without a classic window message queue. Skipping."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",5,<empty>,,54,4,CPPASTProblemDeclaration,,<empty>
348730,UNKNOWN,-1,,"Log::Comment(L""Checks that the context menu key is correctly added to the input buffer."");",9,<empty>,,63,5,CPPASTProblemDeclaration,,<empty>
348731,UNKNOWN,-1,,"Log::Comment(L""This test will fail on some keyboard layouts. Ensure you're using a QWERTY keyboard if ""
                     L""you're encountering a test failure here."");",9,<empty>,,64,6,CPPASTProblemDeclaration,,<empty>
348733,UNKNOWN,-1,,VERIFY_IS_TRUE(!!IsWindow(hwnd));,9,<empty>,,68,8,CPPASTProblemDeclaration,,<empty>
348737,UNKNOWN,-1,,"VERIFY_WIN32_BOOL_SUCCEEDED(GetNumberOfConsoleInputEvents(inputHandle, &events));",9,<empty>,,74,12,CPPASTProblemDeclaration,,<empty>
348738,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(events, 0u);",9,<empty>,,75,13,CPPASTProblemDeclaration,,<empty>
348740,UNKNOWN,-1,,Sleep(SLEEP_WAIT_TIME);,9,<empty>,,79,15,CPPASTProblemDeclaration,,<empty>
348742,UNKNOWN,-1,,"PostMessageW(hwnd, WM_KEYDOWN, VK_APPS, EXTENDED_KEY_FLAG | SINGLE_KEY_REPEAT | (scanCode << 16));",9,<empty>,,81,17,CPPASTProblemDeclaration,,<empty>
348743,UNKNOWN,-1,,Sleep(SLEEP_WAIT_TIME);,9,<empty>,,82,18,CPPASTProblemDeclaration,,<empty>
348745,UNKNOWN,-1,,expectedRecord.EventType = KEY_EVENT;,9,<empty>,,85,20,CPPASTProblemDeclaration,,<empty>
348746,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.uChar.UnicodeChar = 0x0;,9,<empty>,,86,21,CPPASTProblemDeclaration,,<empty>
348747,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.bKeyDown = true;,9,<empty>,,87,22,CPPASTProblemDeclaration,,<empty>
348748,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.dwControlKeyState = ENHANCED_KEY;,9,<empty>,,88,23,CPPASTProblemDeclaration,,<empty>
348749,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.wRepeatCount = SINGLE_KEY_REPEAT;,9,<empty>,,89,24,CPPASTProblemDeclaration,,<empty>
348750,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.wVirtualKeyCode = VK_APPS;,9,<empty>,,90,25,CPPASTProblemDeclaration,,<empty>
348751,UNKNOWN,-1,,expectedRecord.Event.KeyEvent.wVirtualScanCode = (WORD)scanCode;,9,<empty>,,91,26,CPPASTProblemDeclaration,,<empty>
348753,UNKNOWN,-1,,"VERIFY_WIN32_BOOL_SUCCEEDED(ReadConsoleInputW(inputHandle, &record, 1, &events));",9,<empty>,,95,28,CPPASTProblemDeclaration,,<empty>
348754,UNKNOWN,-1,,"VERIFY_IS_GREATER_THAN(events, 0u);",9,<empty>,,96,29,CPPASTProblemDeclaration,,<empty>
348755,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(expectedRecord, record);",9,<empty>,,97,30,CPPASTProblemDeclaration,,<empty>
348775,UNKNOWN,2,,},5,<empty>,,98,2,CPPASTProblemDeclaration,,<empty>
348777,UNKNOWN,4,,),32,<empty>,,100,4,CPPASTProblemDeclaration,,<empty>
348778,UNKNOWN,5,,"TEST_METHOD_PROPERTY(L""Ignore[@DevTest=true]"", L""false"")
        TEST_METHOD_PROPERTY(L""Ignore[default]"", L""true"")
    END_TEST_METHOD()

    TEST_METHOD(TestInvalidKeyPressIsIgnored)
    {
        if (!OneCoreDelay::IsSendMessageWPresent())
        {
            Log::Comment(L""Injecting keys to the window message queue cannot be done on systems without a classic window message queue. Skipping."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }

        Log::Comment(L""Testing that key events with an invalid virtual keycode and an invalid scan code are properly ignored, and not put into the input buffer"");
        BOOL successBool;
        auto hwnd = GetConsoleWindow();
        VERIFY_IS_TRUE(!!IsWindow(hwnd));
        auto inputHandle = GetStdHandle(STD_INPUT_HANDLE);
        DWORD events = 0;

        // flush input buffer
        FlushConsoleInputBuffer(inputHandle);
        successBool = GetNumberOfConsoleInputEvents(inputHandle, &event...",9,<empty>,,101,5,CPPASTProblemDeclaration,,<empty>
348779,UNKNOWN,6,,"TEST_METHOD(TestKeyPressWithScanCodeZero)
    {
        if (!OneCoreDelay::IsSendMessageWPresent())
        {
            Log::Comment(L""Injecting keys to the window message queue cannot be done on systems without a classic window message queue. Skipping."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",5,<empty>,,149,6,CPPASTProblemDeclaration,,<empty>
348780,UNKNOWN,7,,"Log::Comment(L""Testing that key events with a valid keycode and an invalid scancode (0) are properly processed."");",9,<empty>,,158,7,CPPASTProblemDeclaration,,<empty>
348786,UNKNOWN,11,,VERIFY_IS_TRUE(!!IsWindow(hwnd));,9,<empty>,,161,11,CPPASTProblemDeclaration,,<empty>
348797,UNKNOWN,17,,"successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);",9,<empty>,,167,17,CPPASTProblemDeclaration,,<empty>
348798,UNKNOWN,18,,VERIFY_IS_TRUE(!!successBool);,9,<empty>,,168,18,CPPASTProblemDeclaration,,<empty>
348799,UNKNOWN,19,,"VERIFY_ARE_EQUAL(events, 0u);",9,<empty>,,169,19,CPPASTProblemDeclaration,,<empty>
348820,UNKNOWN,28,,"SendMessage(hwnd, WM_KEYDOWN, vKey, lParam);",9,<empty>,,178,28,CPPASTProblemDeclaration,,<empty>
348821,UNKNOWN,29,,events = 0;,9,<empty>,,181,29,CPPASTProblemDeclaration,,<empty>
348822,UNKNOWN,30,,"successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);",9,<empty>,,182,30,CPPASTProblemDeclaration,,<empty>
348823,UNKNOWN,31,,VERIFY_IS_TRUE(!!successBool);,9,<empty>,,183,31,CPPASTProblemDeclaration,,<empty>
348824,UNKNOWN,32,,"VERIFY_ARE_EQUAL(events, 1u);",9,<empty>,,184,32,CPPASTProblemDeclaration,,<empty>
348833,UNKNOWN,35,,"PeekConsoleInput(inputHandle,
                         inputBuffer.get(),
                         1,
                         &events);",9,<empty>,,186,35,CPPASTProblemDeclaration,,<empty>
348834,UNKNOWN,36,,"VERIFY_ARE_EQUAL(events, 1u);",9,<empty>,,190,36,CPPASTProblemDeclaration,,<empty>
348835,UNKNOWN,37,,"VERIFY_ARE_EQUAL(inputBuffer[0].EventType, KEY_EVENT);",9,<empty>,,191,37,CPPASTProblemDeclaration,,<empty>
348836,UNKNOWN,38,,"VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wRepeatCount, 1, NoThrowString().Format(L""%d"", inputBuffer[0].Event.KeyEvent.wRepeatCount));",9,<empty>,,192,38,CPPASTProblemDeclaration,,<empty>
348837,UNKNOWN,39,,"VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wVirtualScanCode, VK_LWIN);",9,<empty>,,194,39,CPPASTProblemDeclaration,,<empty>
348838,UNKNOWN,40,,VERIFY_IS_TRUE(inputBuffer[0].Event.KeyEvent.dwControlKeyState & ENHANCED_KEY);,9,<empty>,,196,40,CPPASTProblemDeclaration,,<empty>
348839,UNKNOWN,41,,},5,<empty>,,197,41,CPPASTProblemDeclaration,,<empty>
348840,UNKNOWN,42,,"TEST_METHOD(TestCoalesceSameKeyPress)
    {
        if (!OneCoreDelay::IsSendMessageWPresent())
        {
            Log::Comment(L""Injecting keys to the window message queue cannot be done on systems without a classic window message queue. Skipping."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",5,<empty>,,199,42,CPPASTProblemDeclaration,,<empty>
348841,UNKNOWN,43,,"Log::Comment(L""Testing that key events are properly coalesced when the same key is pressed repeatedly"");",9,<empty>,,208,43,CPPASTProblemDeclaration,,<empty>
348847,UNKNOWN,47,,VERIFY_IS_TRUE(!!IsWindow(hwnd));,9,<empty>,,211,47,CPPASTProblemDeclaration,,<empty>
348858,UNKNOWN,53,,"successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);",9,<empty>,,217,53,CPPASTProblemDeclaration,,<empty>
348859,UNKNOWN,54,,VERIFY_IS_TRUE(!!successBool);,9,<empty>,,218,54,CPPASTProblemDeclaration,,<empty>
348860,UNKNOWN,55,,"VERIFY_ARE_EQUAL(events, 0u);",9,<empty>,,219,55,CPPASTProblemDeclaration,,<empty>
348869,UNKNOWN,60,,for (unsigned int i = 0;,9,<empty>,,224,60,CPPASTProblemDeclaration,,<empty>
348870,UNKNOWN,61,,i < messageSendCount;,34,<empty>,,224,61,CPPASTProblemDeclaration,,<empty>
348871,UNKNOWN,62,,"++i)
        {
            SendMessage(hwnd,
                        WM_CHAR,
                        0x41,
                        repeatCount); // WM_CHAR doesn't use scan code
        }",56,<empty>,,224,62,CPPASTProblemDeclaration,,<empty>
348872,UNKNOWN,63,,events = 0;,9,<empty>,,233,63,CPPASTProblemDeclaration,,<empty>
348873,UNKNOWN,64,,"successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);",9,<empty>,,234,64,CPPASTProblemDeclaration,,<empty>
348874,UNKNOWN,65,,VERIFY_IS_TRUE(!!successBool);,9,<empty>,,235,65,CPPASTProblemDeclaration,,<empty>
348875,UNKNOWN,66,,"VERIFY_IS_GREATER_THAN(events, 0u, NoThrowString().Format(L""%d"", events));",9,<empty>,,236,66,CPPASTProblemDeclaration,,<empty>
348884,UNKNOWN,69,,"PeekConsoleInput(inputHandle,
                         inputBuffer.get(),
                         1,
                         &events);",9,<empty>,,238,69,CPPASTProblemDeclaration,,<empty>
348885,UNKNOWN,70,,"VERIFY_ARE_EQUAL(events, 1u);",9,<empty>,,242,70,CPPASTProblemDeclaration,,<empty>
348886,UNKNOWN,71,,"VERIFY_ARE_EQUAL(inputBuffer[0].EventType, KEY_EVENT);",9,<empty>,,243,71,CPPASTProblemDeclaration,,<empty>
348887,UNKNOWN,72,,"VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wRepeatCount, messageSendCount, NoThrowString().Format(L""%d"", inputBuffer[0].Event.KeyEvent.wRepeatCount));",9,<empty>,,244,72,CPPASTProblemDeclaration,,<empty>
348888,UNKNOWN,73,,},5,<empty>,,245,73,CPPASTProblemDeclaration,,<empty>
348889,UNKNOWN,74,,"TEST_METHOD(TestCtrlKeyDownUp)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            // VKeys for A-Z
            // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
            TEST_METHOD_PROPERTY(L""Data:vKey"", L""{""
                                               ""0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,""
                                               ""0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A""
                                               ""}"")
        END_TEST_METHOD_PROPERTIES();",5,<empty>,,247,74,CPPASTProblemDeclaration,,<empty>
348890,UNKNOWN,75,,"if (!OneCoreDelay::IsSendMessageWPresent())
        {
            Log::Comment(L""Ctrl key eventing scenario can't be checked on platform without window message queuing."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",9,<empty>,,258,75,CPPASTProblemDeclaration,,<empty>
348892,UNKNOWN,77,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""vKey"", vk));",9,<empty>,,266,77,CPPASTProblemDeclaration,,<empty>
348893,UNKNOWN,78,,"Log::Comment(L""Testing the right number of input events is generated by Ctrl+Key press"");",9,<empty>,,268,78,CPPASTProblemDeclaration,,<empty>
348899,UNKNOWN,82,,VERIFY_IS_TRUE(!!IsWindow(hwnd));,9,<empty>,,271,82,CPPASTProblemDeclaration,,<empty>
348909,UNKNOWN,87,,"SetConsoleMode(inputHandle, 0);",9,<empty>,,276,87,CPPASTProblemDeclaration,,<empty>
348911,UNKNOWN,89,,"VERIFY_WIN32_BOOL_SUCCEEDED(GetNumberOfConsoleInputEvents(inputHandle, &events));",9,<empty>,,280,89,CPPASTProblemDeclaration,,<empty>
348912,UNKNOWN,90,,"VERIFY_ARE_EQUAL(events, 0u);",9,<empty>,,281,90,CPPASTProblemDeclaration,,<empty>
348917,UNKNOWN,93,,"GetConsoleMode(inputHandle, &dwInMode);",9,<empty>,,284,93,CPPASTProblemDeclaration,,<empty>
348918,UNKNOWN,94,,"Log::Comment(NoThrowString().Format(L""Mode:0x%x"", dwInMode));",9,<empty>,,285,94,CPPASTProblemDeclaration,,<empty>
348973,UNKNOWN,109,,"Log::Comment(NoThrowString().Format(L""Testing Ctrl+%c"", vk));",9,<empty>,,299,109,CPPASTProblemDeclaration,,<empty>
348974,UNKNOWN,110,,"Log::Comment(NoThrowString().Format(L""DownFlags=0x%x, CtrlFlags=0x%x"", DownFlags, CtrlFlags));",9,<empty>,,300,110,CPPASTProblemDeclaration,,<empty>
348975,UNKNOWN,111,,"Log::Comment(NoThrowString().Format(L""UpFlags=0x%x, CtrlUpFlags=0x%x"", UpFlags, CtrlUpFlags));",9,<empty>,,301,111,CPPASTProblemDeclaration,,<empty>
348976,UNKNOWN,112,,"SendMessage(hwnd, WM_KEYDOWN, vkCtrl, CtrlFlags);",9,<empty>,,306,112,CPPASTProblemDeclaration,,<empty>
348977,UNKNOWN,113,,"SendMessage(hwnd, WM_KEYDOWN, vk, DownFlags);",9,<empty>,,307,113,CPPASTProblemDeclaration,,<empty>
348978,UNKNOWN,114,,"SendMessage(hwnd, WM_KEYUP, vk, UpFlags);",9,<empty>,,308,114,CPPASTProblemDeclaration,,<empty>
348979,UNKNOWN,115,,"SendMessage(hwnd, WM_KEYUP, vkCtrl, CtrlUpFlags);",9,<empty>,,309,115,CPPASTProblemDeclaration,,<empty>
348980,UNKNOWN,116,,Sleep(50);,9,<empty>,,311,116,CPPASTProblemDeclaration,,<empty>
348981,UNKNOWN,117,,events = 0;,9,<empty>,,313,117,CPPASTProblemDeclaration,,<empty>
348982,UNKNOWN,118,,"successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);",9,<empty>,,314,118,CPPASTProblemDeclaration,,<empty>
348983,UNKNOWN,119,,VERIFY_IS_TRUE(!!successBool);,9,<empty>,,315,119,CPPASTProblemDeclaration,,<empty>
348984,UNKNOWN,120,,"VERIFY_IS_GREATER_THAN(events, 0u, NoThrowString().Format(L""%d events found"", events));",9,<empty>,,316,120,CPPASTProblemDeclaration,,<empty>
348993,UNKNOWN,123,,"PeekConsoleInput(inputHandle,
                         inputBuffer.get(),
                         16,
                         &events);",9,<empty>,,319,123,CPPASTProblemDeclaration,,<empty>
348994,UNKNOWN,124,,for (size_t i = 0;,9,<empty>,,324,124,CPPASTProblemDeclaration,,<empty>
348995,UNKNOWN,125,,i < events;,28,<empty>,,324,125,CPPASTProblemDeclaration,,<empty>
348996,UNKNOWN,126,,"i++)
        {
            auto rc = inputBuffer[i];
            switch (rc.EventType)
            {
            case KEY_EVENT:
            {
                Log::Comment(NoThrowString().Format(
                    L""Down: %d Repeat: %d KeyCode: 0x%x ScanCode: 0x%x Char: %c (0x%x) KeyState: 0x%x"",
                    rc.Event.KeyEvent.bKeyDown,
                    rc.Event.KeyEvent.wRepeatCount,
                    rc.Event.KeyEvent.wVirtualKeyCode,
                    rc.Event.KeyEvent.wVirtualScanCode,
                    rc.Event.KeyEvent.uChar.UnicodeChar != 0 ? rc.Event.KeyEvent.uChar.UnicodeChar : ' ',
                    rc.Event.KeyEvent.uChar.UnicodeChar,
                    rc.Event.KeyEvent.dwControlKeyState));

                break;
            }
            default:
                Log::Comment(NoThrowString().Format(L""Another event type was found.""));
            }
        }",40,<empty>,,324,126,CPPASTProblemDeclaration,,<empty>
348997,UNKNOWN,127,,"VERIFY_ARE_EQUAL(events, 4u);",9,<empty>,,347,127,CPPASTProblemDeclaration,,<empty>
348998,UNKNOWN,128,,"VERIFY_ARE_EQUAL(inputBuffer[0].EventType, KEY_EVENT);",9,<empty>,,348,128,CPPASTProblemDeclaration,,<empty>
348999,UNKNOWN,129,,"VERIFY_ARE_EQUAL(inputBuffer[1].EventType, KEY_EVENT);",9,<empty>,,349,129,CPPASTProblemDeclaration,,<empty>
349000,UNKNOWN,130,,"VERIFY_ARE_EQUAL(inputBuffer[2].EventType, KEY_EVENT);",9,<empty>,,350,130,CPPASTProblemDeclaration,,<empty>
349001,UNKNOWN,131,,"VERIFY_ARE_EQUAL(inputBuffer[3].EventType, KEY_EVENT);",9,<empty>,,351,131,CPPASTProblemDeclaration,,<empty>
349003,UNKNOWN,133,,},5,<empty>,,354,133,CPPASTProblemDeclaration,,<empty>
349004,UNKNOWN,134,,"TEST_METHOD(TestMaximize)
    {
        if (!OneCoreDelay::IsSendMessageWPresent())
        {
            Log::Comment(L""Injecting keys to the window message queue cannot be done on systems without a classic window message queue. Skipping."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",5,<empty>,,356,134,CPPASTProblemDeclaration,,<empty>
349014,UNKNOWN,139,,VERIFY_IS_TRUE(!!IsWindow(hwnd));,9,<empty>,,367,139,CPPASTProblemDeclaration,,<empty>
349015,UNKNOWN,140,,"SetConsoleMode(inputHandle, ENABLE_PROCESSED_INPUT);",9,<empty>,,370,140,CPPASTProblemDeclaration,,<empty>
349054,UNKNOWN,152,,"SendMessage(hwnd, WM_KEYDOWN, VK_F11, F11Flags);",9,<empty>,,384,152,CPPASTProblemDeclaration,,<empty>
349055,UNKNOWN,153,,"SendMessage(hwnd, WM_KEYUP, VK_F11, F11UpFlags);",9,<empty>,,385,153,CPPASTProblemDeclaration,,<empty>
349068,UNKNOWN,158,,"SendMessage(hwnd, WM_KEYDOWN, VK_F11, F11Flags);",9,<empty>,,391,158,CPPASTProblemDeclaration,,<empty>
349069,UNKNOWN,159,,"SendMessage(hwnd, WM_KEYUP, VK_F11, F11UpFlags);",9,<empty>,,392,159,CPPASTProblemDeclaration,,<empty>
349088,UNKNOWN,170,,"VERIFY_ARE_NOT_EQUAL(maxStyle, oldStyle);",9,<empty>,,407,170,CPPASTProblemDeclaration,,<empty>
349089,UNKNOWN,171,,"VERIFY_ARE_NOT_EQUAL(maxExStyle, oldExStyle);",9,<empty>,,408,171,CPPASTProblemDeclaration,,<empty>
349090,UNKNOWN,172,,"WI_ClearAllFlags(oldStyle, WS_HSCROLL | WS_VSCROLL);",9,<empty>,,411,172,CPPASTProblemDeclaration,,<empty>
349091,UNKNOWN,173,,"WI_ClearAllFlags(newStyle, WS_HSCROLL | WS_VSCROLL);",9,<empty>,,412,173,CPPASTProblemDeclaration,,<empty>
349092,UNKNOWN,174,,"VERIFY_ARE_EQUAL(oldStyle, newStyle);",9,<empty>,,413,174,CPPASTProblemDeclaration,,<empty>
349093,UNKNOWN,175,,"VERIFY_ARE_EQUAL(oldExStyle, newExStyle);",9,<empty>,,414,175,CPPASTProblemDeclaration,,<empty>
349094,UNKNOWN,176,,},5,<empty>,,415,176,CPPASTProblemDeclaration,,<empty>
349095,UNKNOWN,177,,};,1,<empty>,,416,177,CPPASTProblemDeclaration,,<empty>
349349,UNKNOWN,1,,WORD,55,<empty>,,480,1,CPPASTTypeId,,<empty>
349533,UNKNOWN,7,,"BOOL APIENTRY OneCoreDelay::AddConsoleAliasA(
    _In_ LPSTR Source,
    _In_ LPSTR Target,
    _In_ LPSTR ExeName)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnAddConsoleAliasA)(LPSTR Source, LPSTR Target, LPSTR ExeName);

        static PfnAddConsoleAliasA pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnAddConsoleAliasA)GetProcAddress(h, ""AddConsoleAliasA"");
        }

        if (pfn != nullptr)
        {
            return pfn(Source, Target, ExeName);
        }
    }

    return FALSE;
}",1,<empty>,,66,7,CPPASTProblemDeclaration,,<empty>
349534,UNKNOWN,8,,"BOOL APIENTRY OneCoreDelay::AddConsoleAliasW(
    _In_ LPWSTR Source,
    _In_ LPWSTR Target,
    _In_ LPWSTR ExeName)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnAddConsoleAliasW)(LPWSTR Source, LPWSTR Target, LPWSTR ExeName);

        static PfnAddConsoleAliasW pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnAddConsoleAliasW)GetProcAddress(h, ""AddConsoleAliasW"");
        }

        if (pfn != nullptr)
        {
            return pfn(Source, Target, ExeName);
        }
    }

    return FALSE;
}",1,<empty>,,93,8,CPPASTProblemDeclaration,,<empty>
349535,UNKNOWN,9,,"DWORD APIENTRY OneCoreDelay::GetConsoleAliasA(
    _In_ LPSTR Source,
    _Out_writes_(TargetBufferLength) LPSTR TargetBuffer,
    _In_ DWORD TargetBufferLength,
    _In_ LPSTR ExeName)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnGetConsoleAliasA)(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName);

        static PfnGetConsoleAliasA pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetConsoleAliasA)GetProcAddress(h, ""GetConsoleAliasA"");
        }

        if (pfn != nullptr)
        {
            return pfn(Source, TargetBuffer, TargetBufferLength, ExeName);
        }
    }

    return FALSE;
}",1,<empty>,,120,9,CPPASTProblemDeclaration,,<empty>
349536,UNKNOWN,10,,"DWORD APIENTRY OneCoreDelay::GetConsoleAliasW(
    _In_ LPWSTR Source,
    _Out_writes_(TargetBufferLength) LPWSTR TargetBuffer,
    _In_ DWORD TargetBufferLength,
    _In_ LPWSTR ExeName)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnGetConsoleAliasW)(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName);

        static PfnGetConsoleAliasW pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetConsoleAliasW)GetProcAddress(h, ""GetConsoleAliasW"");
        }

        if (pfn != nullptr)
        {
            return pfn(Source, TargetBuffer, TargetBufferLength, ExeName);
        }
    }

    return FALSE;
}",1,<empty>,,148,10,CPPASTProblemDeclaration,,<empty>
349537,UNKNOWN,11,,"BOOL WINAPI OneCoreDelay::GetCurrentConsoleFont(
    _In_ HANDLE hConsoleOutput,
    _In_ BOOL bMaximumWindow,
    _Out_ PCONSOLE_FONT_INFO lpConsoleCurrentFont)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnGetCurrentConsoleFont)(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont);

        static PfnGetCurrentConsoleFont pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetCurrentConsoleFont)GetProcAddress(h, ""GetCurrentConsoleFont"");
        }

        if (pfn != nullptr)
        {
            return pfn(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
        }
    }

    return FALSE;
}",1,<empty>,,176,11,CPPASTProblemDeclaration,,<empty>
349538,UNKNOWN,12,,"BOOL WINAPI OneCoreDelay::GetCurrentConsoleFontEx(
    _In_ HANDLE hConsoleOutput,
    _In_ BOOL bMaximumWindow,
    _Out_ PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnGetCurrentConsoleFontEx)(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

        static PfnGetCurrentConsoleFontEx pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetCurrentConsoleFontEx)GetProcAddress(h, ""GetCurrentConsoleFontEx"");
        }

        if (pfn != nullptr)
        {
            return pfn(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        }
    }

    return FALSE;
}",1,<empty>,,203,12,CPPASTProblemDeclaration,,<empty>
349539,UNKNOWN,13,,"BOOL WINAPI OneCoreDelay::SetCurrentConsoleFontEx(
    _In_ HANDLE hConsoleOutput,
    _In_ BOOL bMaximumWindow,
    _In_ PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnSetCurrentConsoleFontEx)(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

        static PfnSetCurrentConsoleFontEx pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnSetCurrentConsoleFontEx)GetProcAddress(h, ""SetCurrentConsoleFontEx"");
        }

        if (pfn != nullptr)
        {
            return pfn(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        }
    }

    return FALSE;
}",1,<empty>,,230,13,CPPASTProblemDeclaration,,<empty>
349540,UNKNOWN,14,,"COORD WINAPI OneCoreDelay::GetConsoleFontSize(
    _In_ HANDLE hConsoleOutput,
    _In_ DWORD nFont)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef COORD(WINAPI * PfnGetConsoleFontSize)(HANDLE hConsoleOutput, DWORD nFont);

        static PfnGetConsoleFontSize pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetConsoleFontSize)GetProcAddress(h, ""GetConsoleFontSize"");
        }

        if (pfn != nullptr)
        {
            return pfn(hConsoleOutput, nFont);
        }
    }

    return { 0 };
}",1,<empty>,,257,14,CPPASTProblemDeclaration,,<empty>
349541,UNKNOWN,15,,"BOOL WINAPI OneCoreDelay::GetNumberOfConsoleMouseButtons(
    _Out_ LPDWORD lpNumberOfMouseButtons)
{
    auto h = GetKernel32();

    if (h != nullptr)
    {
        typedef BOOL(WINAPI * PfnGetNumberOfConsoleMouseButtons)(LPDWORD lpNumberOfMouseButtons);

        static PfnGetNumberOfConsoleMouseButtons pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetNumberOfConsoleMouseButtons)GetProcAddress(h, ""GetNumberOfConsoleMouseButtons"");
        }

        if (pfn != nullptr)
        {
            return pfn(lpNumberOfMouseButtons);
        }
    }

    return FALSE;
}",1,<empty>,,283,15,CPPASTProblemDeclaration,,<empty>
349542,UNKNOWN,16,,"HMENU WINAPI OneCoreDelay::GetMenu(
    _In_ HWND hWnd)
{
    auto h = GetUser32();

    if (h != nullptr)
    {
        typedef HMENU(WINAPI * PfnGetMenu)(HWND hWnd);

        static PfnGetMenu pfn = nullptr;

        if (pfn == nullptr)
        {
            pfn = (PfnGetMenu)GetProcAddress(h, ""GetMenu"");
        }

        if (pfn != nullptr)
        {
            return pfn(hWnd);
        }
    }

    return nullptr;
}",1,<empty>,,308,16,CPPASTProblemDeclaration,,<empty>
349568,UNKNOWN,-1,,Y,16,<empty>,,37,6,CPPASTProblemDeclaration,,<empty>
349569,UNKNOWN,-1,,"AddConsoleAliasA(
            _In_ LPSTR Source,
            _In_ LPSTR Target,
            _In_ LPSTR ExeName);",9,<empty>,,38,7,CPPASTProblemDeclaration,,<empty>
349571,UNKNOWN,-1,,Y,16,<empty>,,44,9,CPPASTProblemDeclaration,,<empty>
349572,UNKNOWN,-1,,"AddConsoleAliasW(
            _In_ LPWSTR Source,
            _In_ LPWSTR Target,
            _In_ LPWSTR ExeName);",9,<empty>,,45,10,CPPASTProblemDeclaration,,<empty>
349574,UNKNOWN,-1,,Y,12,<empty>,,51,12,CPPASTProblemDeclaration,,<empty>
349575,UNKNOWN,-1,,"GetConsoleAliasA(
        _In_ LPSTR Source,
        _Out_writes_(TargetBufferLength) LPSTR TargetBuffer,
        _In_ DWORD TargetBufferLength,
        _In_ LPSTR ExeName);",5,<empty>,,52,13,CPPASTProblemDeclaration,,<empty>
349577,UNKNOWN,-1,,Y,12,<empty>,,59,15,CPPASTProblemDeclaration,,<empty>
349578,UNKNOWN,-1,,"GetConsoleAliasW(
        _In_ LPWSTR Source,
        _Out_writes_(TargetBufferLength) LPWSTR TargetBuffer,
        _In_ DWORD TargetBufferLength,
        _In_ LPWSTR ExeName);",5,<empty>,,60,16,CPPASTProblemDeclaration,,<empty>
349580,UNKNOWN,-1,,I,14,<empty>,,67,18,CPPASTProblemDeclaration,,<empty>
349581,UNKNOWN,-1,,"GetCurrentConsoleFont(
            _In_ HANDLE hConsoleOutput,
            _In_ BOOL bMaximumWindow,
            _Out_ PCONSOLE_FONT_INFO lpConsoleCurrentFont);",9,<empty>,,68,19,CPPASTProblemDeclaration,,<empty>
349583,UNKNOWN,-1,,I,14,<empty>,,74,21,CPPASTProblemDeclaration,,<empty>
349584,UNKNOWN,-1,,"GetCurrentConsoleFontEx(
            _In_ HANDLE hConsoleOutput,
            _In_ BOOL bMaximumWindow,
            _Out_ PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);",9,<empty>,,75,22,CPPASTProblemDeclaration,,<empty>
349586,UNKNOWN,-1,,I,14,<empty>,,81,24,CPPASTProblemDeclaration,,<empty>
349587,UNKNOWN,-1,,"SetCurrentConsoleFontEx(
            _In_ HANDLE hConsoleOutput,
            _In_ BOOL bMaximumWindow,
            _In_ PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);",9,<empty>,,82,25,CPPASTProblemDeclaration,,<empty>
349589,UNKNOWN,-1,,I,10,<empty>,,88,27,CPPASTProblemDeclaration,,<empty>
349590,UNKNOWN,-1,,"GetConsoleFontSize(
        _In_ HANDLE hConsoleOutput,
        _In_ DWORD nFont);",5,<empty>,,89,28,CPPASTProblemDeclaration,,<empty>
349592,UNKNOWN,-1,,I,14,<empty>,,94,30,CPPASTProblemDeclaration,,<empty>
349593,UNKNOWN,-1,,"GetNumberOfConsoleMouseButtons(
            _Out_ LPDWORD lpNumberOfMouseButtons);",9,<empty>,,95,31,CPPASTProblemDeclaration,,<empty>
349595,UNKNOWN,-1,,I,10,<empty>,,99,33,CPPASTProblemDeclaration,,<empty>
349596,UNKNOWN,-1,,"GetMenu(
        _In_ HWND hWnd);",5,<empty>,,100,34,CPPASTProblemDeclaration,,<empty>
349667,UNKNOWN,11,,"static void s_ExpandAnyEnvStrings(_Inout_ std::unique_ptr<wchar_t[]>& cmdline)
{
    const DWORD cchNeeded = ExpandEnvironmentStringsW(cmdline.get(), nullptr, 0);
    THROW_LAST_ERROR_IF(0 == cchNeeded);

    std::unique_ptr<wchar_t[]> cmdlineExpanded = std::make_unique<wchar_t[]>(cchNeeded);

    THROW_LAST_ERROR_IF(0 == ExpandEnvironmentStringsW(cmdline.get(), cmdlineExpanded.get(), cchNeeded));

    cmdline.swap(cmdlineExpanded);
}",1,<empty>,,18,11,CPPASTProblemDeclaration,,<empty>
349668,UNKNOWN,12,,"static void s_RunViaCreateProcess(_In_ PCWSTR pwszExePath)
{
    STARTUPINFOW si = { 0 };
    si.cb = sizeof(si);
    si.wShowWindow = SW_SHOWNORMAL;

    wil::unique_process_information pi;

    // We will need a mutable string to give to CreateProcessW.
    const size_t cchNeeded = wcslen(pwszExePath) + 1;
    std::unique_ptr<wchar_t[]> cmdlineMutable = std::make_unique<wchar_t[]>(cchNeeded);
    THROW_IF_FAILED(StringCchCopyW(cmdlineMutable.get(), cchNeeded, pwszExePath));

    // Replace the environment vars with their actual paths
    s_ExpandAnyEnvStrings(cmdlineMutable);

    LOG_OUTPUT(L""Launching '%s'"", cmdlineMutable.get());

    THROW_IF_WIN32_BOOL_FALSE(CreateProcessW(nullptr,
                                             cmdlineMutable.get(),
                                             nullptr,
                                             nullptr,
                                             TRUE,
                                             0,
                         ...",1,<empty>,,30,12,CPPASTProblemDeclaration,,<empty>
349675,UNKNOWN,-1,,f,26,<empty>,,69,3,CPPASTProblemStatement,,<empty>
349686,UNKNOWN,-1,,f,69,<empty>,,70,5,CPPASTProblemStatement,,<empty>
349797,UNKNOWN,-1,,"auto appPackage = DeploymentHelper::AddPackage(testDeploymentDir + ref new String(L""ConsoleIntegrityUWP.appx""));",5,<empty>,,126,6,CPPASTProblemStatement,,<empty>
350116,UNKNOWN,1,,"LOG_OUTPUT(L""Terminating"");",5,<empty>,,180,1,CPPASTProblemStatement,,<empty>
350148,UNKNOWN,25,,"void IntegrityTest::_TestValidationHelper(const bool fIsBlockExpected,
                                          _In_ PCWSTR pwszIntegrityExpected)
{
    CONSOLE_SCREEN_BUFFER_INFOEX csbiex = { 0 };
    csbiex.cbSize = sizeof(csbiex);
    GetConsoleScreenBufferInfoEx(GetStdHandle(STD_OUTPUT_HANDLE),
                                 &csbiex);

    LOG_OUTPUT(L""Buffer Size X:%d Y:%d"", csbiex.dwSize.X, csbiex.dwSize.Y);

    size_t cch = csbiex.dwSize.X;
    wistd::unique_ptr<wchar_t[]> stringData = wil::make_unique_nothrow<wchar_t[]>(cch);
    THROW_IF_NULL_ALLOC(stringData);

    COORD coordRead = { 0 };
    for (coordRead.Y = 0; coordRead.Y < 8; coordRead.Y++)
    {
        ZeroMemory(stringData.get(), sizeof(wchar_t) * cch);

        DWORD dwRead = 0;

        ReadConsoleOutputCharacterW(GetStdHandle(STD_OUTPUT_HANDLE),
                                    stringData.get(),
                                    (DWORD)cch,
                                    coordRead,
               ...",1,<empty>,,209,25,CPPASTProblemDeclaration,,<empty>
350314,UNKNOWN,1,,"BEGIN_MODULE()
    // We need setup fixtures to run as system to ensure we have authority.
    MODULE_PROPERTY(L""RunFixtureAs:Module"", L""System"")
END_MODULE()

MODULE_SETUP(ModuleSetup);",1,<empty>,,6,1,CPPASTProblemDeclaration,,<empty>
350318,UNKNOWN,-1,,),35,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
350319,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Method"")
    END_TEST_CLASS()

    TEST_CLASS_SETUP(ClassSetup)
    TEST_CLASS_CLEANUP(ClassCleanup)

    BEGIN_TEST_METHOD(TestLaunchLowILFromHigh)
        TEST_METHOD_PROPERTY(L""RunAs"", L""ElevatedUserOrSystem"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestLaunchLowILFromMedium)
        TEST_METHOD_PROPERTY(L""RunAs"", L""RestrictedUser"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestLaunchAppFromHigh)
        TEST_METHOD_PROPERTY(L""RunAs"", L""ElevatedUserOrSystem"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestLaunchAppFromMedium)
        TEST_METHOD_PROPERTY(L""RunAs"", L""RestrictedUser"")
    END_TEST_METHOD()

    BEGIN_TEST_METHOD(TestLaunchAppAlone)
        TEST_METHOD_PROPERTY(L""RunAs"", L""RestrictedUser"")
    END_TEST_METHOD()

    static PCWSTR s_GetMyIntegrityLevel();",9,<empty>,,19,3,CPPASTProblemDeclaration,,<empty>
350325,UNKNOWN,-1,,Platform::String ^ _appAumid;,5,<empty>,,49,5,CPPASTProblemDeclaration,,<empty>
350338,UNKNOWN,-1,,"void _TestValidationHelper(const bool fIsBlockExpected,
                               _In_ PCWSTR pwszIntegrityExpected);",5,<empty>,,56,9,CPPASTProblemDeclaration,,<empty>
350413,UNKNOWN,-1,,"try
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleMode);
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        mode = context.InputMode;

        if (WI_IsFlagSet(gci.Flags, CONSOLE_USE_PRIVATE_FLAGS))
        {
            WI_SetFlag(mode, ENABLE_EXTENDED_FLAGS);
            WI_SetFlagIf(mode, ENABLE_INSERT_MODE, gci.GetInsertMode());
            WI_SetFlagIf(mode, ENABLE_QUICK_EDIT_MODE, WI_IsFlagSet(gci.Flags, CONSOLE_QUICK_EDIT_MODE));
            WI_SetFlagIf(mode, ENABLE_AUTO_POSITION, WI_IsFlagSet(gci.Flags, CONSOLE_AUTO_POSITION));
        }
    }
    CATCH_LOG();",5,<empty>,,42,1,CPPASTProblemStatement,,<empty>
350420,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        mode = context.GetActiveBuffer().OutputMode;
    }
    CATCH_LOG();",5,<empty>,,69,1,CPPASTProblemStatement,,<empty>
350427,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto readyEventCount = context.GetNumberOfReadyEvents();
        RETURN_IF_FAILED(SizeTToULong(readyEventCount, &events));

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,88,1,CPPASTProblemStatement,,<empty>
350434,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        data.bFullscreenSupported = FALSE; // traditional full screen with the driver support is no longer supported.
        // see MSFT: 19918103
        // Make sure to use the active buffer here. There are clients that will
        //      use WINDOW_SIZE_EVENTs as a signal to then query the console
        //      with GetConsoleScreenBufferInfoEx to get the actual viewport
        //      size.
        // If they're in the alt buffer, then when they query in that way, the
        //      value they'll get is the main buffer's size, which isn't updated
        //      until we switch back to it.
        til::size dwSize;
        til::point dwCursorPosition;
        til::inclusive_rect srWindow;
        til::size dwMaximumWindowSize;

        context.GetActiveBuffer().GetScreenBufferInformation(&dwSize,
                                                             &dwCursorPosition,...",5,<empty>,,109,1,CPPASTProblemStatement,,<empty>
350442,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        size = context.GetActiveBuffer().GetTextBuffer().GetCursor().GetSize();
        isVisible = context.GetTextBuffer().GetCursor().IsVisible();
    }
    CATCH_LOG();",5,<empty>,,163,1,CPPASTProblemStatement,,<empty>
350448,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto& selection = Selection::Instance();
        if (selection.IsInSelectingState())
        {
            consoleSelectionInfo.dwFlags = selection.GetPublicSelectionFlags();

            WI_SetFlag(consoleSelectionInfo.dwFlags, CONSOLE_SELECTION_IN_PROGRESS);

            consoleSelectionInfo.dwSelectionAnchor = til::unwrap_coord(selection.GetSelectionAnchor());
            consoleSelectionInfo.srSelection = til::unwrap_small_rect(selection.GetSelectionRectangle());
        }
        else
        {
            ZeroMemory(&consoleSelectionInfo, sizeof(consoleSelectionInfo));
        }
    }
    CATCH_LOG();",5,<empty>,,180,1,CPPASTProblemStatement,,<empty>
350454,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        buttons = ServiceLocator::LocateSystemConfigurationProvider()->GetNumberOfMouseButtons();
    }
    CATCH_LOG();",5,<empty>,,209,1,CPPASTProblemStatement,,<empty>
350462,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        if (index == 0)
        {
            // As of the November 2015 renderer system, we only have a single font at index 0.
            size = context.GetActiveBuffer().GetCurrentFont().GetUnscaledSize();
            return S_OK;
        }
        else
        {
            // Invalid font is 0,0 with STATUS_INVALID_PARAMETER
            size = {};
            return E_INVALIDARG;
        }
    }
    CATCH_RETURN();",5,<empty>,,231,1,CPPASTProblemStatement,,<empty>
350470,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto& activeScreenInfo = context.GetActiveBuffer();

        til::size WindowSize;
        if (isForMaximumWindowSize)
        {
            WindowSize = activeScreenInfo.GetMaxWindowSizeInCharacters();
        }
        else
        {
            WindowSize = activeScreenInfo.GetCurrentFont().GetUnscaledSize();
        }
        consoleFontInfoEx.dwFontSize = til::unwrap_coord_size(WindowSize);

        consoleFontInfoEx.nFont = 0;

        const auto& fontInfo = activeScreenInfo.GetCurrentFont();
        consoleFontInfoEx.FontFamily = fontInfo.GetFamily();
        consoleFontInfoEx.FontWeight = fontInfo.GetWeight();
        fontInfo.FillLegacyNameBuffer(consoleFontInfoEx.FaceName);

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,264,1,CPPASTProblemStatement,,<empty>
350478,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& activeScreenInfo = context.GetActiveBuffer();

        WCHAR FaceName[ARRAYSIZE(consoleFontInfoEx.FaceName)];
        RETURN_IF_FAILED(StringCchCopyW(FaceName, ARRAYSIZE(FaceName), consoleFontInfoEx.FaceName));

        FontInfo fi(FaceName,
                    gsl::narrow_cast<unsigned char>(consoleFontInfoEx.FontFamily),
                    consoleFontInfoEx.FontWeight,
                    til::wrap_coord_size(consoleFontInfoEx.dwFontSize),
                    gci.OutputCP);

        // TODO: MSFT: 9574827 - should this have a failure case?
        activeScreenInfo.UpdateFont(&fi);

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,306,1,CPPASTProblemStatement,,<empty>
350485,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto oldQuickEditMode{ WI_IsFlagSet(gci.Flags, CONSOLE_QUICK_EDIT_MODE) };

        if (WI_IsAnyFlagSet(mode, PRIVATE_MODES))
        {
            WI_SetFlag(gci.Flags, CONSOLE_USE_PRIVATE_FLAGS);

            WI_UpdateFlag(gci.Flags, CONSOLE_QUICK_EDIT_MODE, WI_IsFlagSet(mode, ENABLE_QUICK_EDIT_MODE));
            WI_UpdateFlag(gci.Flags, CONSOLE_AUTO_POSITION, WI_IsFlagSet(mode, ENABLE_AUTO_POSITION));

            const auto PreviousInsertMode = gci.GetInsertMode();
            gci.SetInsertMode(WI_IsFlagSet(mode, ENABLE_INSERT_MODE));
            if (gci.GetInsertMode() != PreviousInsertMode)
            {
                gci.GetActiveOutputBuffer().SetCursorDBMode(false);
                if (gci.HasPendingCookedRead())
                {
                    gci.CookedReadData().SetInsertMode...",5,<empty>,,340,1,CPPASTProblemStatement,,<empty>
350492,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Flags we don't understand are invalid.
        RETURN_HR_IF(E_INVALIDARG, WI_IsAnyFlagSet(mode, ~OUTPUT_MODES));

        auto& screenInfo = context.GetActiveBuffer();
        const auto dwOldMode = screenInfo.OutputMode;
        const auto dwNewMode = mode;

        screenInfo.OutputMode = dwNewMode;

        // if we're moving from VT on->off
        if (WI_IsFlagClear(dwNewMode, ENABLE_VIRTUAL_TERMINAL_PROCESSING) &&
            WI_IsFlagSet(dwOldMode, ENABLE_VIRTUAL_TERMINAL_PROCESSING))
        {
            // jiggle the handle
            screenInfo.GetStateMachine().ResetState();
        }

        // if we changed rendering modes then redraw the output buffer,
        // but only do this if we're not in conpty mode.
        if (!gci.IsInVtIoMode() &&
            (WI_IsFlagSet(dwNewMode, ENA...",5,<empty>,,418,1,CPPASTProblemStatement,,<empty>
350498,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        SetActiveScreenBuffer(newContext.GetActiveBuffer());
    }
    CATCH_LOG();",5,<empty>,,465,1,CPPASTProblemStatement,,<empty>
350504,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        context.Flush();
    }
    CATCH_LOG();",5,<empty>,,481,1,CPPASTProblemStatement,,<empty>
350511,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        const auto& screenInfo = context.GetActiveBuffer();

        size = screenInfo.GetLargestWindowSizeInCharacters();
    }
    CATCH_LOG();",5,<empty>,,499,1,CPPASTProblemStatement,,<empty>
350518,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& screenInfo = context.GetActiveBuffer();

        // microsoft/terminal#3907 - We shouldn't resize the buffer to be
        // smaller than the viewport. This was previously erroneously checked
        // when the host was not in conpty mode.
        RETURN_HR_IF(E_INVALIDARG, (size.width < screenInfo.GetViewport().Width() || size.height < screenInfo.GetViewport().Height()));

        // see MSFT:17415266
        // We only really care about the minimum window size if we have a head.
        if (!ServiceLocator::LocateGlobals().IsHeadless())
        {
            const auto coordMin = screenInfo.GetMinWindowSizeInCharacters();
            // Make sure requested screen buffer size isn't smaller than the window.
            RETURN_HR_IF(E_INVALIDARG, (size.height < coordMin.height || size.width < coordMin.width));
        }

        // Ensure the requested size isn't larger ...",5,<empty>,,521,1,CPPASTProblemStatement,,<empty>
350525,UNKNOWN,-1,,"try
    {
        // clang-format off
        RETURN_HR_IF(E_INVALIDARG, (data.dwSize.X == 0 ||
                                    data.dwSize.Y == 0 ||
                                    data.dwSize.X == SHRT_MAX ||
                                    data.dwSize.Y == SHRT_MAX));
        // clang-format on

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& g = ServiceLocator::LocateGlobals();
        auto& gci = g.getConsoleInformation();

        const auto coordScreenBufferSize = context.GetBufferSize().Dimensions();
        const auto requestedBufferSize = til::wrap_coord_size(data.dwSize);
        if (requestedBufferSize != coordScreenBufferSize)
        {
            LOG_IF_FAILED(context.ResizeScreenBuffer(requestedBufferSize, TRUE));
        }
        const auto newBufferSize = context.GetBufferSize().Dimensions();

        bool changedOneTableEntry = false;
        for (size_t i = 0; i < std::size(data.ColorTable); i++)...",5,<empty>,,584,1,CPPASTProblemStatement,,<empty>
350532,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& buffer = context.GetActiveBuffer();

        const auto coordScreenBufferSize = buffer.GetBufferSize().Dimensions();
        // clang-format off
        RETURN_HR_IF(E_INVALIDARG, (position.x >= coordScreenBufferSize.width ||
                                    position.y >= coordScreenBufferSize.height ||
                                    position.x < 0 ||
                                    position.y < 0));
        // clang-format on

        // MSFT: 15813316 - Try to use this SetCursorPosition call to inherit the cursor position.
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        RETURN_IF_FAILED(gci.GetVtIo()->SetCursorPosition(position));

        RETURN_IF_NTSTATUS_FAILED(buffer.SetCursorPosition(position, true));

        LOG_IF_FAILED(ConsoleImeResizeCompStrView());

        // Attempt to ""snap"" the viewport to the cursor posi...",5,<empty>,,700,1,CPPASTProblemStatement,,<empty>
350540,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // If more than 100% or less than 0% cursor height, reject it.
        RETURN_HR_IF(E_INVALIDARG, (size > 100 || size == 0));

        context.SetCursorInformation(size, isVisible);

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,785,1,CPPASTProblemStatement,,<empty>
350548,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& g = ServiceLocator::LocateGlobals();
        auto Window = windowRect;

        if (!isAbsolute)
        {
            auto currentViewport = context.GetViewport().ToInclusive();
            Window.left += currentViewport.left;
            Window.right += currentViewport.right;
            Window.top += currentViewport.top;
            Window.bottom += currentViewport.bottom;
        }

        RETURN_HR_IF(E_INVALIDARG, (Window.right < Window.left || Window.bottom < Window.top));

        til::size NewWindowSize;
        NewWindowSize.width = CalcWindowSizeX(Window);
        NewWindowSize.height = CalcWindowSizeY(Window);

        // see MSFT:17415266
        // If we have a actual head, we care about the maximum size the window can be.
        // if we're headless, not so much. However, GetMaxWindowSizeInCharacters
        //      will only return the buffer size, so we...",5,<empty>,,813,1,CPPASTProblemStatement,,<empty>
350559,UNKNOWN,-1,,"try
    {
        const auto unicodeFillCharacter = CharToWchar(&fillCharacter, 1);

        return ScrollConsoleScreenBufferWImpl(context, source, target, clip, unicodeFillCharacter, fillAttribute);
    }
    CATCH_RETURN();",5,<empty>,,891,1,CPPASTProblemStatement,,<empty>
350571,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        auto& buffer = context.GetActiveBuffer();

        TextAttribute useThisAttr(fillAttribute);
        ScrollRegion(buffer, source, clip, target, fillCharacter, useThisAttr);

        auto hr = S_OK;

        // GH#3126 - This is a shim for cmd's `cls` function. In the
        // legacy console, `cls` is supposed to clear the entire buffer. In
        // conpty however, there's no difference between the viewport and the
        // entirety of the buffer. We're going to see if this API call exactly
        // matched the way we expect cmd to call it. If it does, then
        // let's manually emit a ^[[3J to the connected terminal, so that their
        // entire buffer will be cleared as well.
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        if (enableCmdShim && gci.IsInVtIoMode())
        {
            const auto currentBufferDimensions = buff...",5,<empty>,,922,1,CPPASTProblemStatement,,<empty>
350588,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        RETURN_HR_IF(E_INVALIDARG, WI_IsAnyFlagSet(attribute, ~VALID_TEXT_ATTRIBUTES));

        const TextAttribute attr{ attribute };
        context.SetAttributes(attr);

        gci.ConsoleIme.RefreshAreaAttributes();

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,980,3,CPPASTProblemStatement,,<empty>
350629,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });
        return DoSrvSetConsoleOutputCodePage(codepage);
    }
    CATCH_RETURN();",5,<empty>,,1024,1,CPPASTProblemStatement,,<empty>
350635,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Return if it's not known as a valid codepage ID.
        RETURN_HR_IF(E_INVALIDARG, !(IsValidCodePage(codepage)));

        // Do nothing if no change.
        if (gci.CP != codepage)
        {
            // Set new code page
            gci.CP = codepage;

            SetConsoleCPInfo(FALSE);
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,1041,1,CPPASTProblemStatement,,<empty>
350641,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        codepage = gci.CP;
    }
    CATCH_LOG();",5,<empty>,,1070,1,CPPASTProblemStatement,,<empty>
350647,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        codepage = gci.OutputCP;
    }
    CATCH_LOG();",5,<empty>,,1087,1,CPPASTProblemStatement,,<empty>
350653,UNKNOWN,-1,,"try
    {
        // Set return to null before we do anything in case of failures/errors.
        hwnd = nullptr;

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });
        const IConsoleWindow* pWindow = ServiceLocator::LocateConsoleWindow();
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        if (pWindow != nullptr)
        {
            hwnd = pWindow->GetWindowHandle();
        }
        else
        {
            // Some applications will fail silently if this API returns 0 (cygwin)
            // If we're in pty mode, we need to return a fake window handle that
            //      doesn't actually do anything, but is a unique HWND to this
            //      console, so that they know that this console is in fact a real
            //      console window.
            if (gci.IsInVtIoMode())
            {
                hwnd = ServiceLocator::LocatePseudoWindow();
            }
        }
    }
    CAT...",5,<empty>,,1103,1,CPPASTProblemStatement,,<empty>
350659,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        consoleHistoryInfo.HistoryBufferSize = gci.GetHistoryBufferSize();
        consoleHistoryInfo.NumberOfHistoryBuffers = gci.GetNumberOfHistoryBuffers();
        WI_SetFlagIf(consoleHistoryInfo.dwFlags, HISTORY_NO_DUP_FLAG, WI_IsFlagSet(gci.Flags, CONSOLE_HISTORY_NODUP));
    }
    CATCH_LOG();",5,<empty>,,1138,1,CPPASTProblemStatement,,<empty>
350665,UNKNOWN,-1,,"try
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        RETURN_HR_IF(E_INVALIDARG, consoleHistoryInfo.HistoryBufferSize > SHORT_MAX);
        RETURN_HR_IF(E_INVALIDARG, consoleHistoryInfo.NumberOfHistoryBuffers > SHORT_MAX);
        RETURN_HR_IF(E_INVALIDARG, WI_IsAnyFlagSet(consoleHistoryInfo.dwFlags, ~CHI_VALID_FLAGS));

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        CommandHistory::s_ResizeAll(consoleHistoryInfo.HistoryBufferSize);
        gci.SetNumberOfHistoryBuffers(consoleHistoryInfo.NumberOfHistoryBuffers);

        WI_UpdateFlag(gci.Flags, CONSOLE_HISTORY_NODUP, WI_IsFlagSet(consoleHistoryInfo.dwFlags, HISTORY_NO_DUP_FLAG));

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,1159,1,CPPASTProblemStatement,,<empty>
350671,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Initialize flags portion of structure
        flags = 0;

        const auto pWindow = ServiceLocator::LocateConsoleWindow();
        if (pWindow != nullptr && pWindow->IsInFullscreen())
        {
            WI_SetFlag(flags, CONSOLE_FULLSCREEN_MODE);
        }
    }
    CATCH_LOG();",5,<empty>,,1186,1,CPPASTProblemStatement,,<empty>
350679,UNKNOWN,-1,,"try
    {
        // SetIsFullscreen() below ultimately calls SetwindowLong, which ultimately calls SendMessage(). If we retain
        // the console lock, we'll deadlock since ConsoleWindowProc takes the lock before processing messages. Instead,
        // we'll release early.
        LockConsole();
        {
            auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

            auto& screenInfo = context.GetActiveBuffer();

            newSize = screenInfo.GetBufferSize().Dimensions();
            RETURN_HR_IF(E_INVALIDARG, !(screenInfo.IsActiveScreenBuffer()));
        }

        const auto pWindow = ServiceLocator::LocateConsoleWindow();
        if (WI_IsFlagSet(flags, CONSOLE_FULLSCREEN_MODE))
        {
            if (pWindow != nullptr)
            {
                pWindow->SetIsFullscreen(true);
            }
        }
        else if (WI_IsFlagSet(flags, CONSOLE_WINDOWED_MODE))
        {
            if (pWindow != nullptr)
            {
                pWindow-...",5,<empty>,,1222,1,CPPASTProblemStatement,,<empty>
350688,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        // Ensure output variables are initialized.
        written = 0;
        needed = 0;

        if (title.has_value() && title->size() > 0)
        {
            til::at(*title, 0) = ANSI_NULL;
        }

        // Get the appropriate title and length depending on the mode.
        const auto storedTitle = isOriginal ? gci.GetOriginalTitle() : gci.GetTitle();

        // Always report how much space we would need.
        needed = storedTitle.size();

        // If we have a pointer to receive the data, then copy it out.
        if (title.has_value())
        {
            const auto hr = StringCchCopyNW(title->data(), title->size(), storedTitle.data(), storedTitle.size());

            // Insufficient buffer is allowed. If we return a partial string, that's still OK by historical/compat standards.
            // Just say how much we managed to return.
            if (SUCCEEDED(hr) ||...",5,<empty>,,1277,1,CPPASTProblemStatement,,<empty>
350697,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        // Ensure output variables are initialized.
        written = 0;
        needed = 0;

        if (title.size() > 0)
        {
            til::at(title, 0) = ANSI_NULL;
        }

        // Figure out how big our temporary Unicode buffer must be to get the title.
        size_t unicodeNeeded;
        size_t unicodeWritten;
        RETURN_IF_FAILED(GetConsoleTitleWImplHelper(std::nullopt, unicodeWritten, unicodeNeeded, isOriginal));

        // If there's nothing to get, then simply return.
        RETURN_HR_IF(S_OK, 0 == unicodeNeeded);

        // Allocate a unicode buffer of the right size.
        const auto unicodeSize = unicodeNeeded + 1; // add one for null terminator space
        auto unicodeBuffer = std::make_unique<wchar_t[]>(unicodeSize);
        RETURN_IF_NULL_ALLOC(unicodeBuffer);

        const std::span<wchar_t> unicodeSpan(unicodeBuffer.get(), unicodeSize);

        ...",5,<empty>,,1328,1,CPPASTProblemStatement,,<empty>
350705,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        return GetConsoleTitleAImplHelper(title, written, needed, false);
    }
    CATCH_RETURN();",5,<empty>,,1415,1,CPPASTProblemStatement,,<empty>
350713,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        return GetConsoleTitleWImplHelper(title, written, needed, false);
    }
    CATCH_RETURN();",5,<empty>,,1438,1,CPPASTProblemStatement,,<empty>
350721,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        return GetConsoleTitleAImplHelper(title, written, needed, true);
    }
    CATCH_RETURN();",5,<empty>,,1461,1,CPPASTProblemStatement,,<empty>
350729,UNKNOWN,-1,,"try
    {
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        return GetConsoleTitleWImplHelper(title, written, needed, true);
    }
    CATCH_RETURN();",5,<empty>,,1484,1,CPPASTProblemStatement,,<empty>
350745,UNKNOWN,-1,,"try
    {
        const auto titleW = ConvertToW(gci.CP, title);

        return SetConsoleTitleWImpl(titleW);
    }
    CATCH_RETURN();",5,<empty>,,1504,3,CPPASTProblemStatement,,<empty>
351227,UNKNOWN,-1,,"try
    {
        if (_commands.size() == 0 ||
            _commands.back().size() != newCommand.size() ||
            !std::equal(_commands.back().cbegin(),
                        _commands.back().cbegin() + newCommand.size(),
                        newCommand.cbegin(),
                        newCommand.cend()))
        {
            std::wstring reuse{};

            if (suppressDuplicates)
            {
                Index index;
                if (FindMatchingCommand(newCommand, LastDisplayed, index, CommandHistory::MatchOptions::ExactMatch))
                {
                    reuse = Remove(index);
                }
            }

            // find free record.  if all records are used, free the lru one.
            if (GetNumberOfCommands() == _maxCommands)
            {
                _commands.erase(_commands.cbegin());
                // move LastDisplayed back one in order to stay synced with the
                // command it referred to before erasing the lru ...",5,<empty>,,100,4,CPPASTProblemStatement,,<empty>
351941,UNKNOWN,-1,,"try
    {
        for (size_t i = 0; i < _commands.size(); i++)
        {
            const auto& storedCommand = _commands.at(indexFound);
            if ((WI_IsFlagClear(options, MatchOptions::ExactMatch) && (givenCommand.size() <= storedCommand.size())) || (givenCommand.size() == storedCommand.size()))
            {
                if (til::starts_with(storedCommand, givenCommand))
                {
                    return true;
                }
            }

            _Prev(indexFound);
        }
    }
    CATCH_LOG();",5,<empty>,,458,5,CPPASTProblemStatement,,<empty>
352004,UNKNOWN,-1,,"try
    {
        const auto exeNameW = ConvertToW(gci.CP, exeName);

        return ExpungeConsoleCommandHistoryWImpl(exeNameW);
    }
    CATCH_RETURN();",5,<empty>,,513,3,CPPASTProblemStatement,,<empty>
352019,UNKNOWN,-1,,"try
    {
        const auto history = CommandHistory::s_FindByExe(exeName);
        if (history)
        {
            history->Empty();
        }

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,533,4,CPPASTProblemStatement,,<empty>
352036,UNKNOWN,-1,,"try
    {
        const auto exeNameW = ConvertToW(gci.CP, exeName);

        return SetConsoleNumberOfCommandsWImpl(exeNameW, numberOfCommands);
    }
    CATCH_RETURN();",5,<empty>,,559,3,CPPASTProblemStatement,,<empty>
352052,UNKNOWN,-1,,"try
    {
        CommandHistory::s_ReallocExeToFront(exeName, numberOfCommands);

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,581,4,CPPASTProblemStatement,,<empty>
352169,UNKNOWN,-1,,"try
    {
        const auto exeNameW = ConvertToW(codepage, exeName);
        return GetConsoleCommandHistoryLengthImplHelper(exeNameW, false, codepage, length);
    }
    CATCH_RETURN();",5,<empty>,,665,9,CPPASTProblemStatement,,<empty>
352185,UNKNOWN,-1,,"try
    {
        return GetConsoleCommandHistoryLengthImplHelper(exeName, true, 0, length);
    }
    CATCH_RETURN();",5,<empty>,,686,4,CPPASTProblemStatement,,<empty>
352347,UNKNOWN,-1,,"try
    {
        if (commandHistory.size() > 0)
        {
            til::at(commandHistory, 0) = ANSI_NULL;
        }

        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // Convert our input parameters to Unicode.
        const auto exeNameW = ConvertToW(codepage, exeName);

        // Figure out how big our temporary Unicode buffer must be to retrieve output
        size_t bufferNeeded;
        RETURN_IF_FAILED(GetConsoleCommandHistoryWImplHelper(exeNameW, {}, bufferNeeded));

        // If there's nothing to get, then simply return.
        RETURN_HR_IF(S_OK, 0 == bufferNeeded);

        // Allocate a unicode buffer of the right size.
        auto buffer = std::make_unique<wchar_t[]>(bufferNeeded);
        RETURN_IF_NULL_ALLOC(buffer);

        // Call the Unicode version of this method
        size_t bufferWritten;
        RETURN_IF_FAILED(GetConsoleCommandHistoryWImplHelper(exeNameW, std::span<wchar_t>(buffer.get(), bufferNeeded),...",5,<empty>,,785,6,CPPASTProblemStatement,,<empty>
352364,UNKNOWN,-1,,"try
    {
        return GetConsoleCommandHistoryWImplHelper(exeName, commandHistory, written);
    }
    CATCH_RETURN();",5,<empty>,,846,4,CPPASTProblemStatement,,<empty>
352698,UNKNOWN,1,,LPBYTE,30,<empty>,,88,1,CPPASTTypeId,,<empty>
352733,UNKNOWN,1,,"void InitSideBySide(_Out_writes_(ScratchBufferSize) PWSTR ScratchBuffer, __range(MAX_PATH, MAX_PATH) DWORD ScratchBufferSize);",1,<empty>,,8,1,CPPASTProblemDeclaration,,<empty>
353311,UNKNOWN,10,,"static void CALLBACK midiSkipTimerCallback(HWND, UINT, UINT_PTR idEvent, DWORD) noexcept
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto& midiAudio = gci.GetMidiAudio();

    KillTimer(nullptr, idEvent);
    midiAudio.EndSkip();
}",1,<empty>,,237,10,CPPASTProblemDeclaration,,<empty>
354285,UNKNOWN,15,,"void InputBuffer::TerminateRead(_In_ WaitTerminationReason Flag)
{
    WaitQueue.NotifyWaiters(true, Flag);
}",1,<empty>,,310,15,CPPASTProblemDeclaration,,<empty>
354341,UNKNOWN,19,,"[[nodiscard]] NTSTATUS InputBuffer::Read(_Out_ InputEventQueue& OutEvents,
                                         const size_t AmountToRead,
                                         const bool Peek,
                                         const bool WaitForData,
                                         const bool Unicode,
                                         const bool Stream)
try
{
    assert(OutEvents.empty());

    const auto cp = ServiceLocator::LocateGlobals().getConsoleInformation().CP;

    if (Peek)
    {
        PeekCached(Unicode, AmountToRead, OutEvents);
    }
    else
    {
        ConsumeCached(Unicode, AmountToRead, OutEvents);
    }

    auto it = _storage.begin();
    const auto end = _storage.end();

    while (it != end && OutEvents.size() < AmountToRead)
    {
        if (it->EventType == KEY_EVENT)
        {
            auto event = *it;
            WORD repeat = 1;

            // for stream reads we need to split any key events that have been coalesced
...",1,<empty>,,375,19,CPPASTProblemDeclaration,,<empty>
354342,UNKNOWN,20,,"catch (...)
{
    return NTSTATUS_FROM_HRESULT(wil::ResultFromCaughtException());
}",1,<empty>,,475,20,CPPASTProblemDeclaration,,<empty>
354495,UNKNOWN,24,,"void InputBuffer::WriteString(const std::wstring_view& text)
try
{
    if (text.empty())
    {
        return;
    }

    const auto initiallyEmptyQueue = _storage.empty();

    _writeString(text);

    if (initiallyEmptyQueue && !_storage.empty())
    {
        ServiceLocator::LocateGlobals().hInputEvent.SetEvent();
    }

    WakeUpReadersWaitingForData();
}
CATCH_LOG()

// This can be considered a ""privileged"" variant of Write() which allows FOCUS_EVENTs to generate focus VT sequences.
// If we didn't do this, someone could write a FOCUS_EVENT_RECORD with WriteConsoleInput, exit without flushing the
// input buffer and the next application will suddenly get a ""\x1b[I"" sequence in their input. See GH#13238.
void InputBuffer::WriteFocusEvent(bool focused) noexcept
{
    if (IsInVirtualTerminalInputMode())
    {
        if (const auto out = _termInput.HandleFocus(focused))
        {
            _HandleTerminalInputCallback(*out);
        }
    }
    else
    {
        // This is a m...",1,<empty>,,605,24,CPPASTProblemDeclaration,,<empty>
354622,UNKNOWN,27,,"void InputBuffer::_WriteBuffer(const std::span<const INPUT_RECORD>& inEvents, _Out_ size_t& eventsWritten, _Out_ bool& setWaitEvent)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    eventsWritten = 0;
    setWaitEvent = false;
    const auto initiallyEmptyQueue = _storage.empty();
    const auto initialInEventsSize = inEvents.size();
    const auto vtInputMode = IsInVirtualTerminalInputMode();

    for (const auto& inEvent : inEvents)
    {
        if (inEvent.EventType == KEY_EVENT && inEvent.Event.KeyEvent.bKeyDown)
        {
            // if output is suspended, any keyboard input releases it.
            if (WI_IsFlagSet(gci.Flags, CONSOLE_SUSPENDED) && !IsSystemKey(inEvent.Event.KeyEvent.wVirtualKeyCode))
            {
                UnblockWriteConsole(CONSOLE_OUTPUT_SUSPENDED);
                continue;
            }
            // intercept control-s
            if (WI_IsFlagSet(InputMode, ENABLE_LINE_INPUT) && IsPauseKey(inEvent.Event.KeyEve...",1,<empty>,,708,27,CPPASTProblemDeclaration,,<empty>
354984,UNKNOWN,-1,,void TerminateRead(_In_ WaitTerminationReason Flag);,5,<empty>,,46,16,CPPASTProblemDeclaration,,<empty>
354997,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS Read(_Out_ InputEventQueue& OutEvents,
                                const size_t AmountToRead,
                                const bool Peek,
                                const bool WaitForData,
                                const bool Unicode,
                                const bool Stream);",5,<empty>,,51,20,CPPASTProblemDeclaration,,<empty>
355065,UNKNOWN,-1,,"void _WriteBuffer(const std::span<const INPUT_RECORD>& inRecords, _Out_ size_t& eventsWritten, _Out_ bool& setWaitEvent);",5,<empty>,,97,43,CPPASTProblemDeclaration,,<empty>
355421,UNKNOWN,1,,"WCHAR CharToWchar(_In_reads_(cch) const char* const pch, const UINT cch)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto wc = L'\0';

    FAIL_FAST_IF(!(IsDBCSLeadByteConsole(*pch, &gci.OutputCPInfo) || cch == 1));

    ConvertOutputToUnicode(gci.OutputCP, pch, cch, &wc, 1);

    return wc;
}",1,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
355482,UNKNOWN,3,,"int ConvertToOem(const UINT uiCodePage,
                 _In_reads_(cchSource) const WCHAR* const pwchSource,
                 const UINT cchSource,
                 _Out_writes_(cchTarget) CHAR* const pchTarget,
                 const UINT cchTarget) noexcept
{
    FAIL_FAST_IF(!(pwchSource != (LPWSTR)pchTarget));
    DBGCHARS((""ConvertToOem U->%d %.*ls\n"", uiCodePage, cchSource > 10 ? 10 : cchSource, pwchSource));
    // clang-format off
#pragma prefast(suppress: __WARNING_W2A_BEST_FIT, ""WC_NO_BEST_FIT_CHARS doesn't work in many codepages. Retain old behavior."")
    // clang-format on
    return LOG_IF_WIN32_BOOL_FALSE(WideCharToMultiByte(uiCodePage, 0, pwchSource, cchSource, pchTarget, cchTarget, nullptr, nullptr));
}",1,<empty>,,60,3,CPPASTProblemDeclaration,,<empty>
355483,UNKNOWN,4,,"int ConvertOutputToUnicode(_In_ UINT uiCodePage,
                           _In_reads_(cchSource) const CHAR* const pchSource,
                           _In_ UINT cchSource,
                           _Out_writes_(cchTarget) WCHAR* pwchTarget,
                           _In_ UINT cchTarget) noexcept
{
    FAIL_FAST_IF(!(cchTarget > 0));
    pwchTarget[0] = L'\0';
    DBGCHARS((""ConvertOutputToUnicode %d->U %.*s\n"", uiCodePage, cchSource > 10 ? 10 : cchSource, pchSource));
    return MultiByteToWideChar(uiCodePage, MB_USEGLYPHCHARS, pchSource, cchSource, pwchTarget, cchTarget);
}",1,<empty>,,75,4,CPPASTProblemDeclaration,,<empty>
355497,UNKNOWN,1,,"WCHAR CharToWchar(_In_reads_(cch) const char* const pch, const UINT cch);",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
355503,UNKNOWN,3,,"int ConvertToOem(const UINT uiCodePage,
                 _In_reads_(cchSource) const WCHAR* const pwchSource,
                 const UINT cchSource,
                 _Out_writes_(cchTarget) CHAR* const pchTarget,
                 const UINT cchTarget) noexcept;",1,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
355504,UNKNOWN,4,,"int ConvertOutputToUnicode(_In_ UINT uiCodePage,
                           _In_reads_(cchSource) const CHAR* const pchSource,
                           _In_ UINT cchSource,
                           _Out_writes_(cchTarget) WCHAR* pwchTarget,
                           _In_ UINT cchTarget) noexcept;",1,<empty>,,37,4,CPPASTProblemDeclaration,,<empty>
355522,UNKNOWN,2,,"[[nodiscard]] NTSTATUS NtPrivApi::s_GetProcessParentId(_Inout_ PULONG ProcessId)
{
    // TODO: Get Parent current not really available without winternl + NtQueryInformationProcess. http://osgvsowi/8394495
    OBJECT_ATTRIBUTES oa;
#pragma warning(suppress : 26477) // This macro contains a bare NULL
    InitializeObjectAttributes(&oa, nullptr, 0, nullptr, nullptr);

    CLIENT_ID ClientId;
    ClientId.UniqueProcess = UlongToHandle(*ProcessId);
    ClientId.UniqueThread = nullptr;

    HANDLE ProcessHandle;
    auto Status = s_NtOpenProcess(&ProcessHandle, PROCESS_QUERY_LIMITED_INFORMATION, &oa, &ClientId);

    PROCESS_BASIC_INFORMATION_EXPANDED BasicInfo = { 0 };
    if (SUCCEEDED_NTSTATUS(Status))
    {
        Status = s_NtQueryInformationProcess(ProcessHandle, ProcessBasicInformation, &BasicInfo, sizeof(BasicInfo), nullptr);
        LOG_IF_FAILED(s_NtClose(ProcessHandle));
    }

    if (FAILED_NTSTATUS(Status))
    {
        *ProcessId = 0;
        return Status;
    }

    *P...",1,<empty>,,21,2,CPPASTProblemDeclaration,,<empty>
355523,UNKNOWN,3,,"[[nodiscard]] NTSTATUS NtPrivApi::s_NtOpenProcess(_Out_ PHANDLE ProcessHandle,
                                                  _In_ ACCESS_MASK DesiredAccess,
                                                  _In_ POBJECT_ATTRIBUTES ObjectAttributes,
                                                  _In_opt_ CLIENT_ID* ClientId)
{
    auto hNtDll = _Instance()._hNtDll;

    if (hNtDll != nullptr)
    {
        typedef NTSTATUS (*PfnNtOpenProcess)(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, CLIENT_ID * ClientId);

        static auto pfn = (PfnNtOpenProcess)GetProcAddress(hNtDll, ""NtOpenProcess"");

        if (pfn != nullptr)
        {
            return pfn(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
        }
    }

    return STATUS_UNSUCCESSFUL;
}",1,<empty>,,52,3,CPPASTProblemDeclaration,,<empty>
355524,UNKNOWN,4,,"[[nodiscard]] NTSTATUS NtPrivApi::s_NtQueryInformationProcess(_In_ HANDLE ProcessHandle,
                                                              _In_ PROCESSINFOCLASS ProcessInformationClass,
                                                              _Out_ PVOID ProcessInformation,
                                                              _In_ ULONG ProcessInformationLength,
                                                              _Out_opt_ PULONG ReturnLength)
{
    auto hNtDll = _Instance()._hNtDll;

    if (hNtDll != nullptr)
    {
        typedef NTSTATUS (*PfnNtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

        static auto pfn = (PfnNtQueryInformationProcess)GetProcAddress(hNtDll, ""NtQueryInformationProcess"");

        if (pfn != nullptr)
        {
            return pfn(ProcessHandle, ProcessInformationClass, ProcessInformation, Proce...",1,<empty>,,74,4,CPPASTProblemDeclaration,,<empty>
355525,UNKNOWN,5,,"[[nodiscard]] NTSTATUS NtPrivApi::s_NtClose(_In_ HANDLE Handle)
{
    auto hNtDll = _Instance()._hNtDll;

    if (hNtDll != nullptr)
    {
        typedef NTSTATUS (*PfnNtClose)(HANDLE Handle);

        static auto pfn = (PfnNtClose)GetProcAddress(hNtDll, ""NtClose"");

        if (pfn != nullptr)
        {
            return pfn(Handle);
        }
    }

    return STATUS_UNSUCCESSFUL;
}",1,<empty>,,97,5,CPPASTProblemDeclaration,,<empty>
355563,UNKNOWN,1,,"class NtPrivApi sealed
{
public:
    [[nodiscard]] static NTSTATUS s_GetProcessParentId(_Inout_ PULONG ProcessId);

    ~NtPrivApi();

private:
    [[nodiscard]] static NTSTATUS s_NtOpenProcess(_Out_ PHANDLE ProcessHandle,
                                                  _In_ ACCESS_MASK DesiredAccess,
                                                  _In_ POBJECT_ATTRIBUTES ObjectAttributes,
                                                  _In_opt_ CLIENT_ID* ClientId);

    [[nodiscard]] static NTSTATUS s_NtQueryInformationProcess(_In_ HANDLE ProcessHandle,
                                                              _In_ PROCESSINFOCLASS ProcessInformationClass,
                                                              _Out_ PVOID ProcessInformation,
                                                              _In_ ULONG ProcessInformationLength,
                                                              _Out_opt_ PULONG ReturnLength);

    [[nodiscard]] static NTSTATU...",1,<empty>,,18,1,CPPASTProblemDeclaration,,<empty>
356674,UNKNOWN,7,,"VOID SetConsoleWindowOwner(const HWND hwnd, _Inout_opt_ ConsoleProcessHandle* pProcessData);",1,<empty>,,48,7,CPPASTProblemDeclaration,,<empty>
356715,UNKNOWN,1,,"ConhostInternalGetSet::ConhostInternalGetSet(_In_ IIoProvider& io) :
    _io{ io }",1,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
356716,UNKNOWN,2,,"{
}",1,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
357453,UNKNOWN,-1,,ConhostInternalGetSet(_In_ Microsoft::Console::IIoProvider& io);,5,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
357695,UNKNOWN,1,,"ReadData::ReadData(_In_ InputBuffer* const pInputBuffer,
                   _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData) :
    IWaitRoutine(ReplyDataType::Read),
    _pInputBuffer(THROW_HR_IF_NULL(E_INVALIDARG, pInputBuffer)),
    _pInputReadHandleData(THROW_HR_IF_NULL(E_INVALIDARG, pInputReadHandleData))
{
    _pInputReadHandleData->IncrementReadCount();
}",1,<empty>,,15,1,CPPASTProblemDeclaration,,<empty>
357749,UNKNOWN,-1,,"ReadData(_In_ InputBuffer* const pInputBuffer,
             _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData);",5,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
358070,UNKNOWN,15,,"COOKED_READ_DATA::COOKED_READ_DATA(_In_ InputBuffer* const pInputBuffer,
                                   _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData,
                                   SCREEN_INFORMATION& screenInfo,
                                   _In_ size_t UserBufferSize,
                                   _In_ char* UserBuffer,
                                   _In_ ULONG CtrlWakeupMask,
                                   _In_ const std::wstring_view exeName,
                                   _In_ const std::wstring_view initialData,
                                   _In_ ConsoleProcessHandle* const pClientProcess) :
    ReadData(pInputBuffer, pInputReadHandleData),
    _screenInfo{ screenInfo }",1,<empty>,,120,15,CPPASTProblemDeclaration,,<empty>
358071,UNKNOWN,16,,",
    _userBuffer{ UserBuffer, UserBufferSize }",30,<empty>,,130,16,CPPASTProblemDeclaration,,<empty>
358072,UNKNOWN,17,,",
    _exeName{ exeName }",46,<empty>,,131,17,CPPASTProblemDeclaration,,<empty>
358073,UNKNOWN,18,,",
    _processHandle{ pClientProcess }",24,<empty>,,132,18,CPPASTProblemDeclaration,,<empty>
358074,UNKNOWN,19,,",
    _history{ CommandHistory::s_Find(pClientProcess) }",37,<empty>,,133,19,CPPASTProblemDeclaration,,<empty>
358075,UNKNOWN,20,,",
    _ctrlWakeupMask{ CtrlWakeupMask }",55,<empty>,,134,20,CPPASTProblemDeclaration,,<empty>
358076,UNKNOWN,21,,",
    _insertMode{ ServiceLocator::LocateGlobals().getConsoleInformation().GetInsertMode() }",38,<empty>,,135,21,CPPASTProblemDeclaration,,<empty>
358077,UNKNOWN,22,,"{
#ifndef UNIT_TESTING
    // The screen buffer instance is basically a reference counted HANDLE given out to the user.
    // We need to ensure that it stays alive for the duration of the read.
    // Coincidentally this serves another important purpose: It checks whether we're allowed to read from
    // the given buffer in the first place. If it's missing the FILE_SHARE_READ flag, we can't read from it.
    //
    // GH#16158: It's important that we hold a handle to the main instead of the alt buffer
    // even if this cooked read targets the latter, because alt buffers are fake
    // SCREEN_INFORMATION objects that are owned by the main buffer.
    THROW_IF_FAILED(_screenInfo.GetMainBuffer().AllocateIoHandle(ConsoleHandleData::HandleType::Output, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, _tempHandle));
#endif

    if (!initialData.empty())
    {
        _buffer.Replace(initialData);

        // The console API around `nInitialChars` in `CONSOLE_READCONSOLE_CONTROL` is...",1,<empty>,,137,22,CPPASTProblemDeclaration,,<empty>
358078,UNKNOWN,23,,"bool COOKED_READ_DATA::Notify(const WaitTerminationReason TerminationReason,
                              const bool fIsUnicode,
                              _Out_ NTSTATUS* const pReplyStatus,
                              _Out_ size_t* const pNumBytes,
                              _Out_ DWORD* const pControlKeyState,
                              _Out_ void* const /*pOutputData*/) noexcept
try
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    *pNumBytes = 0;
    *pControlKeyState = 0;
    *pReplyStatus = STATUS_SUCCESS;

    // if ctrl-c or ctrl-break was seen, terminate read.
    if (WI_IsAnyFlagSet(TerminationReason, (WaitTerminationReason::CtrlC | WaitTerminationReason::CtrlBreak)))
    {
        *pReplyStatus = STATUS_ALERTED;
        gci.SetCookedReadData(nullptr);
        return true;
    }

    // See if we were called because the thread that owns this wait block is exiting.
    if (WI_IsFlagSet(TerminationReason, WaitTerminationReason::Thre...",1,<empty>,,214,23,CPPASTProblemDeclaration,,<empty>
358079,UNKNOWN,24,,"NT_CATCH_RETURN()

void COOKED_READ_DATA::MigrateUserBuffersOnTransitionToBackgroundWait(const void* oldBuffer, void* newBuffer) noexcept
{
    // See the comment in WaitBlock.cpp for more information.
    if (_userBuffer.data() == oldBuffer)
    {
        _userBuffer = { static_cast<char*>(newBuffer), _userBuffer.size() };
    }
}",1,<empty>,,262,24,CPPASTProblemDeclaration,,<empty>
358397,UNKNOWN,1,,wchar_t,42,<empty>,,414,1,CPPASTTypeId,,<empty>
358406,UNKNOWN,1,,uint16_t,43,<empty>,,415,1,CPPASTTypeId,,<empty>
360080,UNKNOWN,1,,ptrdiff_t,36,<empty>,,1013,1,CPPASTTypeId,,<empty>
360169,UNKNOWN,1,,ptrdiff_t,32,<empty>,,1034,1,CPPASTTypeId,,<empty>
360177,UNKNOWN,1,,ptrdiff_t,32,<empty>,,1035,1,CPPASTTypeId,,<empty>
360648,UNKNOWN,-1,,e,21,<empty>,,1174,4,CPPASTProblemStatement,,<empty>
361265,UNKNOWN,-1,,e,21,<empty>,,1379,4,CPPASTProblemStatement,,<empty>
361508,UNKNOWN,-1,,e,17,<empty>,,1462,4,CPPASTProblemStatement,,<empty>
361708,UNKNOWN,-1,,e,17,<empty>,,1504,21,CPPASTProblemStatement,,<empty>
361844,UNKNOWN,-1,,"COOKED_READ_DATA(_In_ InputBuffer* pInputBuffer,
                     _In_ INPUT_READ_HANDLE_DATA* pInputReadHandleData,
                     SCREEN_INFORMATION& screenInfo,
                     _In_ size_t UserBufferSize,
                     _In_ char* UserBuffer,
                     _In_ ULONG CtrlWakeupMask,
                     _In_ std::wstring_view exeName,
                     _In_ std::wstring_view initialData,
                     _In_ ConsoleProcessHandle* pClientProcess);",5,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
361851,UNKNOWN,-1,,"bool Notify(WaitTerminationReason TerminationReason,
                bool fIsUnicode,
                _Out_ NTSTATUS* pReplyStatus,
                _Out_ size_t* pNumBytes,
                _Out_ DWORD* pControlKeyState,
                _Out_ void* pOutputData) noexcept override;",5,<empty>,,24,3,CPPASTProblemDeclaration,,<empty>
362176,UNKNOWN,1,,size_t,48,<empty>,,43,1,CPPASTTypeId,,<empty>
362222,UNKNOWN,1,,"DirectReadData::DirectReadData(_In_ InputBuffer* const pInputBuffer,
                               _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData,
                               const size_t eventReadCount) :
    ReadData(pInputBuffer, pInputReadHandleData),
    _eventReadCount{ eventReadCount }",1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
362223,UNKNOWN,2,,"{
}",1,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
362224,UNKNOWN,3,,"bool DirectReadData::Notify(const WaitTerminationReason TerminationReason,
                            const bool fIsUnicode,
                            _Out_ NTSTATUS* const pReplyStatus,
                            _Out_ size_t* const pNumBytes,
                            _Out_ DWORD* const pControlKeyState,
                            _Out_ void* const pOutputData)
try
{
    FAIL_FAST_IF_NULL(pOutputData);
    FAIL_FAST_IF(_pInputReadHandleData->GetReadCount() == 0);

    assert(Microsoft::Console::Interactivity::ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    *pReplyStatus = STATUS_SUCCESS;
    *pControlKeyState = 0;
    *pNumBytes = 0;

    // If ctrl-c or ctrl-break was seen, ignore it.
    if (WI_IsAnyFlagSet(TerminationReason, (WaitTerminationReason::CtrlC | WaitTerminationReason::CtrlBreak)))
    {
        return false;
    }

    // See if called by CsrDestroyProcess or CsrDestroyThread
    // via ConsoleNotifyWaitBlock. If so, just decre...",1,<empty>,,55,3,CPPASTProblemDeclaration,,<empty>
362225,UNKNOWN,4,,"catch (...)
{
    *pReplyStatus = wil::StatusFromCaughtException();
    return true;
}",1,<empty>,,126,4,CPPASTProblemDeclaration,,<empty>
362246,UNKNOWN,-1,,"DirectReadData(_In_ InputBuffer* const pInputBuffer,
                   _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData,
                   const size_t eventReadCount);",5,<empty>,,34,1,CPPASTProblemDeclaration,,<empty>
362258,UNKNOWN,-1,,"bool Notify(const WaitTerminationReason TerminationReason,
                const bool fIsUnicode,
                _Out_ NTSTATUS* const pReplyStatus,
                _Out_ size_t* const pNumBytes,
                _Out_ DWORD* const pControlKeyState,
                _Out_ void* const pOutputData) override;",5,<empty>,,41,4,CPPASTProblemDeclaration,,<empty>
362278,UNKNOWN,1,,"RAW_READ_DATA::RAW_READ_DATA(_In_ InputBuffer* const pInputBuffer,
                             _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData,
                             const size_t BufferSize,
                             _In_ WCHAR* const BufPtr) :
    ReadData(pInputBuffer, pInputReadHandleData),
    _BufferSize{ BufferSize }",1,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
362279,UNKNOWN,2,,",
    _BufPtr{ THROW_HR_IF_NULL(E_INVALIDARG, BufPtr) }",30,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
362280,UNKNOWN,3,,"{
    THROW_HR_IF(E_INVALIDARG, _BufferSize == 0);
}",1,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
362285,UNKNOWN,5,,"bool RAW_READ_DATA::Notify(const WaitTerminationReason TerminationReason,
                           const bool fIsUnicode,
                           _Out_ NTSTATUS* const pReplyStatus,
                           _Out_ size_t* const pNumBytes,
                           _Out_ DWORD* const pControlKeyState,
                           _Out_ void* const /*pOutputData*/)
{
    // This routine should be called by a thread owning the same lock
    // on the same console as we're reading from.
    FAIL_FAST_IF(_pInputReadHandleData->GetReadCount() == 0);

    FAIL_FAST_IF(!Microsoft::Console::Interactivity::ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    *pReplyStatus = STATUS_SUCCESS;
    *pControlKeyState = 0;

    *pNumBytes = 0;

    // If a ctrl-c is seen, don't terminate read. If ctrl-break is seen, terminate read.
    if (WI_IsFlagSet(TerminationReason, WaitTerminationReason::CtrlC))
    {
        return false;
    }

    if (WI_IsFlagSet(Terminatio...",1,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
362294,UNKNOWN,1,,const wchar_t*,32,<empty>,,126,1,CPPASTTypeId,,<empty>
362300,UNKNOWN,1,,wchar_t*,31,<empty>,,128,1,CPPASTTypeId,,<empty>
362312,UNKNOWN,-1,,"RAW_READ_DATA(_In_ InputBuffer* const pInputBuffer,
                  _In_ INPUT_READ_HANDLE_DATA* const pInputReadHandleData,
                  const size_t BufferSize,
                  _In_ WCHAR* const BufPtr);",5,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
362328,UNKNOWN,-1,,"bool Notify(const WaitTerminationReason TerminationReason,
                const bool fIsUnicode,
                _Out_ NTSTATUS* const pReplyStatus,
                _Out_ size_t* const pNumBytes,
                _Out_ DWORD* const pControlKeyState,
                _Out_ void* const pOutputData) override;",5,<empty>,,41,5,CPPASTProblemDeclaration,,<empty>
362346,UNKNOWN,1,,"Registry::Registry(_In_ Settings* const pSettings) :
    _pSettings(pSettings)
{
}",1,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
362351,UNKNOWN,3,,"void Registry::GetEditKeys(_In_opt_ HKEY hConsoleKey) const
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    NTSTATUS Status;
    HKEY hCurrentUserKey = nullptr;
    if (hConsoleKey == nullptr)
    {
        Status = RegistrySerialization::s_OpenConsoleKey(&hCurrentUserKey, &hConsoleKey);
        if (FAILED_NTSTATUS(Status))
        {
            return;
        }
    }

    // determine whether the user wants to allow alt-f4 to close the console (global setting)
    DWORD dwValue;
    Status = RegistrySerialization::s_QueryValue(hConsoleKey,
                                                 CONSOLE_REGISTRY_ALLOW_ALTF4_CLOSE,
                                                 sizeof(dwValue),
                                                 REG_DWORD,
                                                 (PBYTE)&dwValue,
                                                 nullptr);
    if (SUCCEEDED_NTSTATUS(Status) && dwValue <= 1)
    {
        gci.SetAltF4Clos...",1,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
362352,UNKNOWN,4,,"void Registry::_LoadMappedProperties(_In_reads_(cPropertyMappings) const RegistrySerialization::RegPropertyMap* const rgPropertyMappings,
                                     const size_t cPropertyMappings,
                                     const HKEY hKey)
{
    // Iterate through properties table and load each setting for common property types
    for (UINT iMapping = 0; iMapping < cPropertyMappings; iMapping++)
    {
        const auto pPropMap = &(rgPropertyMappings[iMapping]);

        auto Status = STATUS_SUCCESS;

        switch (pPropMap->propertyType)
        {
        case RegistrySerialization::_RegPropertyType::Boolean:
        case RegistrySerialization::_RegPropertyType::Dword:
        case RegistrySerialization::_RegPropertyType::Word:
        case RegistrySerialization::_RegPropertyType::Byte:
        case RegistrySerialization::_RegPropertyType::Coordinate:
        {
            Status = RegistrySerialization::s_LoadRegDword(hKey, pPropMap, _pSettings);
         ...",1,<empty>,,124,4,CPPASTProblemDeclaration,,<empty>
362382,UNKNOWN,1,,HKEY,22,<empty>,,177,1,CPPASTTypeId,,<empty>
362386,UNKNOWN,1,,HKEY,22,<empty>,,178,1,CPPASTTypeId,,<empty>
362396,UNKNOWN,7,,"void Registry::LoadFromRegistry(_In_ PCWSTR const pwszConsoleTitle)
{
    HKEY hCurrentUserKey;
    HKEY hConsoleKey;
    auto Status = RegistrySerialization::s_OpenConsoleKey(&hCurrentUserKey, &hConsoleKey);
    if (FAILED_NTSTATUS(Status))
    {
        return;
    }

    // Open the console title subkey.
    auto TranslatedConsoleTitle = TranslateConsoleTitle(pwszConsoleTitle, TRUE, TRUE);
    if (TranslatedConsoleTitle == nullptr)
    {
        RegCloseKey(hConsoleKey);
        RegCloseKey(hCurrentUserKey);
        return;
    }

    HKEY hTitleKey;
    Status = RegistrySerialization::s_OpenKey(hConsoleKey, TranslatedConsoleTitle, &hTitleKey);
    delete[] TranslatedConsoleTitle;
    TranslatedConsoleTitle = nullptr;

    if (FAILED_NTSTATUS(Status))
    {
        TranslatedConsoleTitle = TranslateConsoleTitle(pwszConsoleTitle, TRUE, FALSE);

        if (TranslatedConsoleTitle == nullptr)
        {
            RegCloseKey(hConsoleKey);
            RegCloseKey(hCurrentUserKey);
 ...",1,<empty>,,199,7,CPPASTProblemDeclaration,,<empty>
362405,UNKNOWN,-1,,Registry(_In_ Settings* const pSettings);,5,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
362418,UNKNOWN,-1,,void LoadFromRegistry(_In_ PCWSTR const pwszConsoleTitle);,5,<empty>,,31,5,CPPASTProblemDeclaration,,<empty>
362419,UNKNOWN,-1,,void GetEditKeys(_In_opt_ HKEY hConsoleKey) const;,5,<empty>,,33,6,CPPASTProblemDeclaration,,<empty>
362420,UNKNOWN,-1,,"void _LoadMappedProperties(_In_reads_(cPropertyMappings) const RegistrySerialization::RegPropertyMap* const rgPropertyMappings,
                               const size_t cPropertyMappings,
                               const HKEY hKey);",5,<empty>,,36,7,CPPASTProblemDeclaration,,<empty>
362531,UNKNOWN,-1,,"try
    {
        for (const auto& select : Selection::Instance().GetSelectionRects())
        {
            result.emplace_back(Viewport::FromInclusive(select));
        }
    }
    CATCH_LOG();",5,<empty>,,70,2,CPPASTProblemStatement,,<empty>
362780,UNKNOWN,-1,,"try
    {
        // First retrieve the IME information and build overlays.
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto& ime = gci.ConsoleIme;

        for (const auto& composition : ime.ConvAreaCompStr)
        {
            // Only send the overlay to the renderer on request if it's not supposed to be hidden at this moment.
            if (!composition.IsHidden())
            {
                // This is holding the data.
                const auto& textBuffer = composition.GetTextBuffer();

                // The origin of the text buffer above (top left corner) is supposed to sit at this
                // point within the visible viewport of the current window.
                const auto origin = composition.GetAreaBufferInfo().coordConView;

                // This is the area of the viewport that is actually in use relative to the text buffer itself.
                // (e.g. 0,0 is the origin of the text buffer above, ...",5,<empty>,,213,2,CPPASTProblemStatement,,<empty>
363228,UNKNOWN,3,,"[[nodiscard]] HRESULT RenderFontDefaults::RetrieveDefaultFontNameForCodepage(const unsigned int codePage,
                                                                             std::wstring& outFaceName)
try
{
    // GH#3123: Propagate font length changes up through Settings and propsheet
    wchar_t faceName[LF_FACESIZE]{ 0 };
    auto status = TrueTypeFontList::s_SearchByCodePage(codePage, faceName, ARRAYSIZE(faceName));
    outFaceName.assign(faceName);
    return HRESULT_FROM_NT(status);
}
CATCH_RETURN();",1,<empty>,,20,3,CPPASTProblemDeclaration,,<empty>
363236,UNKNOWN,1,,"class RenderFontDefaults sealed : public Microsoft::Console::Render::IFontDefaultList
{
public:
    RenderFontDefaults();
    ~RenderFontDefaults();

    [[nodiscard]] HRESULT RetrieveDefaultFontNameForCodepage(const unsigned int codePage,
                                                             std::wstring& outFaceName);
};",1,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
363273,UNKNOWN,1,,"SCREEN_INFORMATION::SCREEN_INFORMATION(
    _In_ IWindowMetrics* pMetrics,
    _In_ IAccessibilityNotifier* pNotifier,
    const TextAttribute popupAttributes,
    const FontInfo fontInfo) :
    OutputMode{ ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT }",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
363274,UNKNOWN,2,,",
    WheelDelta{ 0 }",70,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
363275,UNKNOWN,3,,",
    HWheelDelta{ 0 }",20,<empty>,,37,3,CPPASTProblemDeclaration,,<empty>
363276,UNKNOWN,4,,",
    _textBuffer{ nullptr }",21,<empty>,,38,4,CPPASTProblemDeclaration,,<empty>
363277,UNKNOWN,5,,",
    Next{ nullptr }",27,<empty>,,39,5,CPPASTProblemDeclaration,,<empty>
363278,UNKNOWN,6,,",
    WriteConsoleDbcsLeadByte{ 0, 0 }",20,<empty>,,40,6,CPPASTProblemDeclaration,,<empty>
363279,UNKNOWN,7,,",
    FillOutDbcsLeadChar{ 0 }",37,<empty>,,41,7,CPPASTProblemDeclaration,,<empty>
363280,UNKNOWN,8,,",
    ConvScreenInfo{ nullptr }",29,<empty>,,42,8,CPPASTProblemDeclaration,,<empty>
363281,UNKNOWN,9,,",
    ScrollScale{ 1ul }",30,<empty>,,43,9,CPPASTProblemDeclaration,,<empty>
363282,UNKNOWN,10,,",
    _pConsoleWindowMetrics{ pMetrics }",23,<empty>,,44,10,CPPASTProblemDeclaration,,<empty>
363283,UNKNOWN,11,,",
    _pAccessibilityNotifier{ pNotifier }",39,<empty>,,45,11,CPPASTProblemDeclaration,,<empty>
363284,UNKNOWN,12,,",
    _api{ *this }",41,<empty>,,46,12,CPPASTProblemDeclaration,,<empty>
363285,UNKNOWN,13,,",
    _stateMachine{ nullptr }",18,<empty>,,47,13,CPPASTProblemDeclaration,,<empty>
363286,UNKNOWN,14,,",
    _viewport(Viewport::Empty()),
    _psiAlternateBuffer{ nullptr }",29,<empty>,,48,14,CPPASTProblemDeclaration,,<empty>
363287,UNKNOWN,15,,",
    _psiMainBuffer{ nullptr }",35,<empty>,,50,15,CPPASTProblemDeclaration,,<empty>
363288,UNKNOWN,16,,",
    _fAltWindowChanged{ false }",30,<empty>,,51,16,CPPASTProblemDeclaration,,<empty>
363289,UNKNOWN,17,,",
    _PopupAttributes{ popupAttributes }",32,<empty>,,52,17,CPPASTProblemDeclaration,,<empty>
363290,UNKNOWN,18,,",
    _virtualBottom{ 0 }",40,<empty>,,53,18,CPPASTProblemDeclaration,,<empty>
363291,UNKNOWN,19,,",
    _currentFont{ fontInfo }",24,<empty>,,54,19,CPPASTProblemDeclaration,,<empty>
363292,UNKNOWN,20,,",
    _desiredFont{ fontInfo }",29,<empty>,,55,20,CPPASTProblemDeclaration,,<empty>
363293,UNKNOWN,21,,",
    _ignoreLegacyEquivalentVTAttributes{ false }",29,<empty>,,56,21,CPPASTProblemDeclaration,,<empty>
363294,UNKNOWN,22,,"{
    // Check if VT mode should be enabled by default. This can be true if
    // VirtualTerminalLevel is set to !=0 in the registry, or when conhost
    // is started in conpty mode.
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    if (gci.GetDefaultVirtTermLevel() != 0)
    {
        OutputMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    }
}",1,<empty>,,58,22,CPPASTProblemDeclaration,,<empty>
363300,UNKNOWN,24,,"[[nodiscard]] NTSTATUS SCREEN_INFORMATION::CreateInstance(_In_ til::size coordWindowSize,
                                                          const FontInfo fontInfo,
                                                          _In_ til::size coordScreenBufferSize,
                                                          const TextAttribute defaultAttributes,
                                                          const TextAttribute popupAttributes,
                                                          const UINT uiCursorSize,
                                                          _Outptr_ SCREEN_INFORMATION** const ppScreen)
{
    *ppScreen = nullptr;

    try
    {
        auto pMetrics = ServiceLocator::LocateWindowMetrics();
        THROW_HR_IF_NULL(E_FAIL, pMetrics);

        const auto pNotifier = ServiceLocator::LocateAccessibilityNotifier();
        // It is possible for pNotifier to be null and that's OK.
        // For instance, the PTY doesn't need to send e...",1,<empty>,,89,24,CPPASTProblemDeclaration,,<empty>
363376,UNKNOWN,29,,"void SCREEN_INFORMATION::s_InsertScreenBuffer(_In_ SCREEN_INFORMATION* const pScreenInfo)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    FAIL_FAST_IF(!(gci.IsConsoleLocked()));

    pScreenInfo->Next = gci.ScreenBuffers;
    gci.ScreenBuffers = pScreenInfo;
}",1,<empty>,,188,29,CPPASTProblemDeclaration,,<empty>
363377,UNKNOWN,30,,"void SCREEN_INFORMATION::s_RemoveScreenBuffer(_In_ SCREEN_INFORMATION* const pScreenInfo)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    if (pScreenInfo == gci.ScreenBuffers)
    {
        gci.ScreenBuffers = pScreenInfo->Next;
    }
    else
    {
        auto* Cur = gci.ScreenBuffers;
        auto* Prev = Cur;
        while (Cur != nullptr)
        {
            if (pScreenInfo == Cur)
            {
                break;
            }

            Prev = Cur;
            Cur = Cur->Next;
        }

        FAIL_FAST_IF_NULL(Cur);
        Prev->Next = Cur->Next;
    }

    if (pScreenInfo == gci.pCurrentScreenBuffer &&
        gci.ScreenBuffers != gci.pCurrentScreenBuffer)
    {
        if (gci.ScreenBuffers != nullptr)
        {
            SetActiveScreenBuffer(*gci.ScreenBuffers);
        }
        else
        {
            gci.pCurrentScreenBuffer = nullptr;
        }
    }

    delete pScreenInfo;
}",1,<empty>,,204,30,CPPASTProblemDeclaration,,<empty>
363541,UNKNOWN,37,,"void SCREEN_INFORMATION::GetScreenBufferInformation(_Out_ til::size* pcoordSize,
                                                    _Out_ til::point* pcoordCursorPosition,
                                                    _Out_ til::inclusive_rect* psrWindow,
                                                    _Out_ PWORD pwAttributes,
                                                    _Out_ til::size* pcoordMaximumWindowSize,
                                                    _Out_ PWORD pwPopupAttributes,
                                                    _Out_writes_(COLOR_TABLE_SIZE) LPCOLORREF lpColorTable) const
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    *pcoordSize = GetBufferSize().Dimensions();

    *pcoordCursorPosition = _textBuffer->GetCursor().GetPosition();

    *psrWindow = _viewport.ToInclusive();

    *pwAttributes = GetAttributes().GetLegacyAttributes();
    *pwPopupAttributes = _PopupAttributes.GetLegacyAttributes();...",1,<empty>,,345,37,CPPASTProblemDeclaration,,<empty>
363851,UNKNOWN,42,,"void SCREEN_INFORMATION::GetRequiredConsoleSizeInPixels(_Out_ til::size* const pRequiredSize) const
{
    const auto coordFontSize = GetCurrentFont().GetSize();

    // TODO: Assert valid size boundaries
    pRequiredSize->width = GetViewport().Width() * coordFontSize.width;
    pRequiredSize->height = GetViewport().Height() * coordFontSize.height;
}",1,<empty>,,493,42,CPPASTProblemDeclaration,,<empty>
364606,UNKNOWN,55,,"[[nodiscard]] HRESULT SCREEN_INFORMATION::_AdjustScreenBufferHelper(const til::rect* const prcClientNew,
                                                                    const til::size coordBufferOld,
                                                                    _Out_ til::size* const pcoordClientNewCharacters)
{
    // Get the font size ready.
    const auto coordFontSize = GetScreenFontSize();

    // We cannot operate if the font size is 0. This shouldn't happen, but stop early if it does.
    RETURN_HR_IF(E_NOT_VALID_STATE, 0 == coordFontSize.width || 0 == coordFontSize.height);

    // Find out how much client space we have to work with in the new area.
    til::size sizeClientNewPixels;
    sizeClientNewPixels.width = prcClientNew->width();
    sizeClientNewPixels.height = prcClientNew->height();

    // Subtract out scroll bar space if scroll bars will be necessary.
    auto fIsHorizontalVisible = false;
    auto fIsVerticalVisible = false;
    s_CalculateScrollbarV...",1,<empty>,,877,55,CPPASTProblemDeclaration,,<empty>
364747,UNKNOWN,57,,"void SCREEN_INFORMATION::_CalculateViewportSize(const til::rect* const prcClientArea, _Out_ til::size* const pcoordSize)
{
    const auto coordBufferSize = GetBufferSize().Dimensions();
    const auto coordFontSize = GetScreenFontSize();

    til::size sizeClientPixels;
    sizeClientPixels.width = prcClientArea->width();
    sizeClientPixels.height = prcClientArea->height();

    bool fIsHorizontalVisible;
    bool fIsVerticalVisible;
    s_CalculateScrollbarVisibility(prcClientArea,
                                   &coordBufferSize,
                                   &coordFontSize,
                                   &fIsHorizontalVisible,
                                   &fIsVerticalVisible);

    if (fIsHorizontalVisible)
    {
        sizeClientPixels.height -= ServiceLocator::LocateGlobals().sHorizontalScrollSize;
    }

    if (fIsVerticalVisible)
    {
        sizeClientPixels.width -= ServiceLocator::LocateGlobals().sVerticalScrollSize;
    }

    pcoordSize->width = (t...",1,<empty>,,990,57,CPPASTProblemDeclaration,,<empty>
365281,UNKNOWN,60,,"void SCREEN_INFORMATION::s_CalculateScrollbarVisibility(const til::rect* const prcClientArea,
                                                        const til::size* const pcoordBufferSize,
                                                        const til::size* const pcoordFontSize,
                                                        _Out_ bool* const pfIsHorizontalVisible,
                                                        _Out_ bool* const pfIsVerticalVisible)
{
    // Start with bars not visible as the initial state of the client area doesn't account for scroll bars.
    *pfIsHorizontalVisible = false;
    *pfIsVerticalVisible = false;

    // Set up the client area in pixels
    til::size sizeClientPixels;
    sizeClientPixels.width = prcClientArea->width();
    sizeClientPixels.height = prcClientArea->height();

    // Set up the buffer area in pixels by multiplying the size by the font size scale factor
    til::size sizeBufferPixels;
    sizeBufferPixels.width = pc...",1,<empty>,,1278,60,CPPASTProblemDeclaration,,<empty>
365332,UNKNOWN,64,,"[[nodiscard]] NTSTATUS SCREEN_INFORMATION::ResizeWithReflow(const til::size coordNewScreenSize)
try
{
    if ((USHORT)coordNewScreenSize.width >= SHORT_MAX || (USHORT)coordNewScreenSize.height >= SHORT_MAX)
    {
        RIPMSG2(RIP_WARNING, ""Invalid screen buffer size (0x%x, 0x%x)"", coordNewScreenSize.width, coordNewScreenSize.height);
        return STATUS_INVALID_PARAMETER;
    }

    // GH#3848 - We'll initialize the new buffer with the default attributes,
    // but after the resize, we'll want to make sure that the new buffer's current
    // attributes (the ones used for printing new text) match the old buffer's.
    auto newTextBuffer = std::make_unique<TextBuffer>(coordNewScreenSize,
                                                      TextAttribute{},
                                                      0, // temporarily set size to 0 so it won't render.
                                                      _textBuffer->IsActiveBuffer(),
                                 ...",1,<empty>,,1359,64,CPPASTProblemDeclaration,,<empty>
365333,UNKNOWN,65,,"NT_CATCH_RETURN()

//
// Routine Description:
// - This routine resizes the screen buffer.
// Arguments:
// - NewScreenSize - new size of screen in characters
// - DoScrollBarUpdate - indicates whether to update scroll bars at the end
// Return Value:
// - Success if successful. Invalid parameter if screen buffer size is unexpected. No memory if allocation failed.
[[nodiscard]] NTSTATUS SCREEN_INFORMATION::ResizeScreenBuffer(const til::size coordNewScreenSize,
                                                              const bool fDoScrollBarUpdate)
{
    // If the size hasn't actually changed, do nothing.
    if (coordNewScreenSize == GetBufferSize().Dimensions())
    {
        return STATUS_SUCCESS;
    }

    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto status = STATUS_SUCCESS;

    // cancel any active selection before resizing or it will not necessarily line up with the new buffer positions
    Selection::Instance().ClearSelection();

    if (...",1,<empty>,,1433,65,CPPASTProblemDeclaration,,<empty>
365334,UNKNOWN,66,,"void SCREEN_INFORMATION::ClipToScreenBuffer(_Inout_ til::inclusive_rect* const psrClip) const
{
    const auto bufferSize = GetBufferSize();

    psrClip->left = std::max(psrClip->left, bufferSize.Left());
    psrClip->top = std::max(psrClip->top, bufferSize.Top());
    psrClip->right = std::min(psrClip->right, bufferSize.RightInclusive());
    psrClip->bottom = std::min(psrClip->bottom, bufferSize.BottomInclusive());
}",1,<empty>,,1529,66,CPPASTProblemDeclaration,,<empty>
365707,UNKNOWN,1,,SCREEN_INFORMATION&,23,<empty>,,1734,1,CPPASTTypeId,,<empty>
365711,UNKNOWN,1,,const SCREEN_INFORMATION* const,56,<empty>,,1734,1,CPPASTTypeId,,<empty>
365735,UNKNOWN,1,,SCREEN_INFORMATION&,23,<empty>,,1756,1,CPPASTTypeId,,<empty>
365739,UNKNOWN,1,,const SCREEN_INFORMATION* const,56,<empty>,,1756,1,CPPASTTypeId,,<empty>
365759,UNKNOWN,77,,"[[nodiscard]] NTSTATUS SCREEN_INFORMATION::_CreateAltBuffer(const TextAttribute& initAttributes, _Out_ SCREEN_INFORMATION** const ppsiNewScreenBuffer)
{
    // Create new screen buffer.
    auto WindowSize = _viewport.Dimensions();

    const auto& existingFont = GetCurrentFont();

    auto Status = SCREEN_INFORMATION::CreateInstance(WindowSize,
                                                     existingFont,
                                                     WindowSize,
                                                     initAttributes,
                                                     GetPopupAttributes(),
                                                     Cursor::CURSOR_SMALL_SIZE,
                                                     ppsiNewScreenBuffer);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        // Update the alt buffer's cursor style, visibility, and position to match our own.
        auto& myCursor = GetTextBuffer().GetCursor();
        auto* const createdBuf...",1,<empty>,,1778,77,CPPASTProblemDeclaration,,<empty>
366468,UNKNOWN,1,,OutputStateMachineEngine&,37,<empty>,,2198,1,CPPASTTypeId,,<empty>
366501,UNKNOWN,92,,"void SCREEN_INFORMATION::SetTerminalConnection(_In_ VtEngine* const pTtyConnection)
{
    auto& engine = reinterpret_cast<OutputStateMachineEngine&>(_stateMachine->Engine());
    if (pTtyConnection)
    {
        engine.SetTerminalConnection(pTtyConnection,
                                     [&stateMachine = *_stateMachine]() -> bool {
                                         ServiceLocator::LocateGlobals().pRender->NotifyPaintFrame();
                                         return stateMachine.FlushToTerminal();
                                     });
    }
    else
    {
        engine.SetTerminalConnection(nullptr,
                                     nullptr);
    }
}",1,<empty>,,2217,92,CPPASTProblemDeclaration,,<empty>
367077,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS CreateInstance(_In_ til::size coordWindowSize,
                                                 const FontInfo fontInfo,
                                                 _In_ til::size coordScreenBufferSize,
                                                 const TextAttribute defaultAttributes,
                                                 const TextAttribute popupAttributes,
                                                 const UINT uiCursorSize,
                                                 _Outptr_ SCREEN_INFORMATION** const ppScreen);",5,<empty>,,61,1,CPPASTProblemDeclaration,,<empty>
367082,UNKNOWN,-1,,"void GetScreenBufferInformation(_Out_ til::size* pcoordSize,
                                    _Out_ til::point* pcoordCursorPosition,
                                    _Out_ til::inclusive_rect* psrWindow,
                                    _Out_ PWORD pwAttributes,
                                    _Out_ til::size* pcoordMaximumWindowSize,
                                    _Out_ PWORD pwPopupAttributes,
                                    _Out_writes_(COLOR_TABLE_SIZE) LPCOLORREF lpColorTable) const;",5,<empty>,,71,3,CPPASTProblemDeclaration,,<empty>
367083,UNKNOWN,-1,,void GetRequiredConsoleSizeInPixels(_Out_ til::size* const pRequiredSize) const;,5,<empty>,,79,4,CPPASTProblemDeclaration,,<empty>
367088,UNKNOWN,-1,,void ClipToScreenBuffer(_Inout_ til::inclusive_rect* const psrClip) const;,5,<empty>,,83,6,CPPASTProblemDeclaration,,<empty>
367218,UNKNOWN,-1,,static void s_InsertScreenBuffer(_In_ SCREEN_INFORMATION* const pScreenInfo);,5,<empty>,,129,33,CPPASTProblemDeclaration,,<empty>
367219,UNKNOWN,-1,,static void s_RemoveScreenBuffer(_In_ SCREEN_INFORMATION* const pScreenInfo);,5,<empty>,,130,34,CPPASTProblemDeclaration,,<empty>
367391,UNKNOWN,-1,,void SetTerminalConnection(_In_ Microsoft::Console::Render::VtEngine* const pTtyConnection);,5,<empty>,,218,77,CPPASTProblemDeclaration,,<empty>
367412,UNKNOWN,-1,,"SCREEN_INFORMATION(_In_ Microsoft::Console::Interactivity::IWindowMetrics* pMetrics,
                       _In_ Microsoft::Console::Interactivity::IAccessibilityNotifier* pNotifier,
                       const TextAttribute popupAttributes,
                       const FontInfo fontInfo);",5,<empty>,,232,83,CPPASTProblemDeclaration,,<empty>
367415,UNKNOWN,-1,,"[[nodiscard]] HRESULT _AdjustScreenBufferHelper(const til::rect* const prcClientNew,
                                                    const til::size coordBufferOld,
                                                    _Out_ til::size* const pcoordClientNewCharacters);",5,<empty>,,240,86,CPPASTProblemDeclaration,,<empty>
367421,UNKNOWN,-1,,"void _CalculateViewportSize(const til::rect* const prcClientArea, _Out_ til::size* const pcoordSize);",5,<empty>,,244,88,CPPASTProblemDeclaration,,<empty>
367436,UNKNOWN,-1,,"static void s_CalculateScrollbarVisibility(const til::rect* const prcClientArea,
                                               const til::size* const pcoordBufferSize,
                                               const til::size* const pcoordFontSize,
                                               _Out_ bool* const pfIsHorizontalVisible,
                                               _Out_ bool* const pfIsVerticalVisible);",5,<empty>,,248,91,CPPASTProblemDeclaration,,<empty>
367455,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS _CreateAltBuffer(const TextAttribute& initAttributes,
                                            _Out_ SCREEN_INFORMATION** const ppsiNewScreenBuffer);",5,<empty>,,260,96,CPPASTProblemDeclaration,,<empty>
367799,UNKNOWN,10,,"void Scrolling::s_HandleMouseWheel(_In_ bool isMouseWheel,
                                   _In_ bool isMouseHWheel,
                                   _In_ short wheelDelta,
                                   _In_ bool hasShift,
                                   SCREEN_INFORMATION& ScreenInfo)
{
    auto NewOrigin = ScreenInfo.GetViewport().Origin();

    // s_ucWheelScrollLines == 0 means that it is turned off.
    if (isMouseWheel && s_ucWheelScrollLines > 0)
    {
        // Rounding could cause this to be zero if gucWSL is bigger than 240 or so.
        const auto ulActualDelta = std::max(WHEEL_DELTA / s_ucWheelScrollLines, 1);

        // If we change direction we need to throw away any remainder we may have in the other direction.
        if ((ScreenInfo.WheelDelta > 0) == (wheelDelta > 0))
        {
            ScreenInfo.WheelDelta += wheelDelta;
        }
        else
        {
            ScreenInfo.WheelDelta = wheelDelta;
        }

        if (abs(ScreenInfo.WheelDe...",1,<empty>,,103,10,CPPASTProblemDeclaration,,<empty>
368090,UNKNOWN,-1,,"static void s_HandleMouseWheel(_In_ bool isMouseWheel,
                                   _In_ bool isMouseHWheel,
                                   _In_ short wheelDelta,
                                   _In_ bool hasShift,
                                   SCREEN_INFORMATION& ScreenInfo);",5,<empty>,,34,6,CPPASTProblemDeclaration,,<empty>
368123,UNKNOWN,1,,void*,17,<empty>,,25,1,CPPASTTypeId,,<empty>
368130,UNKNOWN,1,,void*,17,<empty>,,26,1,CPPASTTypeId,,<empty>
368137,UNKNOWN,1,,void*,17,<empty>,,27,1,CPPASTTypeId,,<empty>
368425,UNKNOWN,10,,"void Selection::ExtendSelection(_In_ til::point coordBufferPos)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto& screenInfo = gci.GetActiveOutputBuffer();

    _allowMouseDragSelection = true;

    // ensure position is within buffer bounds. Not less than 0 and not greater than the screen buffer size.
    try
    {
        screenInfo.GetTerminalBufferSize().Clamp(coordBufferPos);
    }
    CATCH_LOG_RETURN();

    if (!IsAreaSelected())
    {
        // we should only be extending a selection that has no area yet if we're coming from mark mode.
        // if not, just return.
        if (IsMouseInitiatedSelection())
        {
            return;
        }

        // scroll if necessary to make cursor visible.
        screenInfo.MakeCursorVisible(coordBufferPos);

        _dwSelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;
        _srSelectionRect.left = _srSelectionRect.right = _coordSelectionAnchor.x;
        _srSelectionRect.top = _srSelectionRec...",1,<empty>,,195,10,CPPASTProblemDeclaration,,<empty>
368658,UNKNOWN,-1,,"try
        {
            screenInfo.Write(OutputCellIterator(attr, cchWrite), coordTarget);
        }
        CATCH_LOG();",9,<empty>,,419,3,CPPASTProblemStatement,,<empty>
368666,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        const auto& screenInfo = gci.GetActiveOutputBuffer();

        const auto rectangles = screenInfo.GetTextBuffer().GetTextRects(coordSelectionStart, coordSelectionEnd, false, true);
        for (const auto& rect : rectangles)
        {
            ColorSelection(rect, attr);
        }
    }
    CATCH_LOG();",5,<empty>,,438,1,CPPASTProblemStatement,,<empty>
369069,UNKNOWN,-1,,void ExtendSelection(_In_ til::point coordBufferPos);,5,<empty>,,55,10,CPPASTProblemDeclaration,,<empty>
369152,UNKNOWN,-1,,"[[nodiscard]] static bool s_GetInputLineBoundaries(_Out_opt_ til::point* const pcoordInputStart, _Out_opt_ til::point* const pcoordInputEnd);",5,<empty>,,101,28,CPPASTProblemDeclaration,,<empty>
369153,UNKNOWN,-1,,"void GetValidAreaBoundaries(_Out_opt_ til::point* const pcoordValidStart, _Out_opt_ til::point* const pcoordValidEnd) const;",5,<empty>,,102,29,CPPASTProblemDeclaration,,<empty>
369935,UNKNOWN,-1,,"try
            {
                const auto attr = gci.GetActiveOutputBuffer().GetCellDataAt(coordSelPoint)->DbcsAttr();
                if (attr == DbcsAttribute::Trailing)
                {
                    bufferSize.IncrementInBounds(coordSelPoint);
                }
            }
            CATCH_LOG();",13,<empty>,,358,2,CPPASTProblemStatement,,<empty>
370296,UNKNOWN,-1,,"try
    {
        const auto attr = gci.GetActiveOutputBuffer().GetCellDataAt(coordSelPoint)->DbcsAttr();
        if (attr == DbcsAttribute::Trailing)
        {
            // try to move off by highlighting the lead half too.
            auto fSuccess = bufferSize.DecrementInBounds(coordSelPoint);

            // if that fails, move off to the next character
            if (!fSuccess)
            {
                bufferSize.IncrementInBounds(coordSelPoint);
            }
        }
    }
    CATCH_LOG();",5,<empty>,,581,25,CPPASTProblemStatement,,<empty>
370450,UNKNOWN,-1,,"try
            {
                const auto selectionRects = GetSelectionRects();
                if (selectionRects.size() > 0)
                {
                    // Pull the selection out of the buffer to pass to the
                    // search function. Clamp to max search string length.
                    // We just copy the bytes out of the row buffer.

                    std::wstring str;
                    for (const auto& selectRect : selectionRects)
                    {
                        auto it = screenInfo.GetCellDataAt({ selectRect.left, selectRect.top });

                        for (til::CoordType i = 0; i < (selectRect.right - selectRect.left + 1);)
                        {
                            str.append(it->Chars());
                            i += it->Columns();
                            it += it->Columns();
                        }
                    }

                    // Clear the selection and call the search / mark function.
  ...",13,<empty>,,682,1,CPPASTProblemStatement,,<empty>
370556,UNKNOWN,-1,,"try
        {
            auto it = ScreenInfo.GetCellLineDataAt(cursorPos);

            // calculate next right
            if (it->DbcsAttr() == DbcsAttribute::Leading)
            {
                iNextRightX = 2;
            }
            else
            {
                iNextRightX = 1;
            }

            // calculate next left
            if (cursorPos.x > 0)
            {
                it--;
                if (it->DbcsAttr() == DbcsAttribute::Trailing)
                {
                    iNextLeftX = 2;
                }
                else if (it->DbcsAttr() == DbcsAttribute::Leading)
                {
                    if (cursorPos.x - 1 > 0)
                    {
                        it--;
                        if (it->DbcsAttr() == DbcsAttribute::Trailing)
                        {
                            iNextLeftX = 3;
                        }
                        else
                        {
                            iNextLeftX = 2...",9,<empty>,,763,11,CPPASTProblemStatement,,<empty>
370860,UNKNOWN,8,,"[[nodiscard]] bool Selection::s_GetInputLineBoundaries(_Out_opt_ til::point* const pcoordInputStart, _Out_opt_ til::point* const pcoordInputEnd)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    if (gci.HasPendingCookedRead())
    {
        auto boundaries = gci.CookedReadData().GetBoundaries();
        if (boundaries.start < boundaries.end)
        {
            if (pcoordInputStart != nullptr)
            {
                *pcoordInputStart = boundaries.start;
            }
            if (pcoordInputEnd != nullptr)
            {
                // - 1 so the coordinate is on top of the last position of the text, not one past it.
                gci.GetActiveOutputBuffer().GetBufferSize().MoveInBounds(-1, boundaries.end);
                *pcoordInputEnd = boundaries.end;
            }
            return true;
        }
    }

    return false;
}",1,<empty>,,948,8,CPPASTProblemDeclaration,,<empty>
370861,UNKNOWN,9,,"void Selection::GetValidAreaBoundaries(_Out_opt_ til::point* const pcoordValidStart, _Out_opt_ til::point* const pcoordValidEnd) const
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    til::point coordEnd;
    coordEnd.x = 0;
    coordEnd.y = 0;

    const auto fHaveInput = s_GetInputLineBoundaries(nullptr, &coordEnd);

    if (!fHaveInput)
    {
        if (IsInSelectingState() && IsKeyboardMarkSelection())
        {
            coordEnd = _coordSavedCursorPosition;
        }
        else
        {
            coordEnd = gci.GetActiveOutputBuffer().GetTextBuffer().GetCursor().GetPosition();
        }
    }

    if (pcoordValidStart != nullptr)
    {
        // valid area always starts at 0,0
        pcoordValidStart->x = 0;
        pcoordValidStart->y = 0;
    }

    if (pcoordValidEnd != nullptr)
    {
        pcoordValidEnd->x = coordEnd.x;
        pcoordValidEnd->y = coordEnd.y;
    }
}",1,<empty>,,982,9,CPPASTProblemDeclaration,,<empty>
371368,UNKNOWN,-1,,friend void SetActiveScreenBuffer(_Inout_ SCREEN_INFORMATION& screenInfo);,5,<empty>,,139,42,CPPASTProblemDeclaration,,<empty>
371513,UNKNOWN,1,,void*,17,<empty>,,73,1,CPPASTTypeId,,<empty>
371758,UNKNOWN,9,,"void Settings::InitFromStateInfo(_In_ PCONSOLE_STATE_INFO pStateInfo)
{
    _wFillAttribute = pStateInfo->ScreenAttributes;
    _wPopupFillAttribute = pStateInfo->PopupAttributes;
    _dwScreenBufferSize = pStateInfo->ScreenBufferSize;
    _dwWindowSize = pStateInfo->WindowSize;
    _dwWindowOrigin.X = (SHORT)pStateInfo->WindowPosX;
    _dwWindowOrigin.Y = (SHORT)pStateInfo->WindowPosY;
    _dwFontSize = pStateInfo->FontSize;
    _uFontFamily = pStateInfo->FontFamily;
    _uFontWeight = pStateInfo->FontWeight;
    StringCchCopyW(_FaceName, ARRAYSIZE(_FaceName), pStateInfo->FaceName);
    _uCursorSize = pStateInfo->CursorSize;
    _bFullScreen = pStateInfo->FullScreen;
    _bQuickEdit = pStateInfo->QuickEdit;
    _bAutoPosition = pStateInfo->AutoPosition;
    _bInsertMode = pStateInfo->InsertMode;
    _bHistoryNoDup = pStateInfo->HistoryNoDup;
    _uHistoryBufferSize = pStateInfo->HistoryBufferSize;
    _uNumberOfHistoryBuffers = pStateInfo->NumberOfHistoryBuffers;
    for (size_t i ...",1,<empty>,,192,9,CPPASTProblemDeclaration,,<empty>
371791,UNKNOWN,1,,SHORT,23,<empty>,,243,1,CPPASTTypeId,,<empty>
371800,UNKNOWN,1,,SHORT,23,<empty>,,244,1,CPPASTTypeId,,<empty>
371929,UNKNOWN,1,,unsigned int,34,<empty>,,267,1,CPPASTTypeId,,<empty>
373089,UNKNOWN,-1,,void InitFromStateInfo(_In_ PCONSOLE_STATE_INFO pStateInfo);,5,<empty>,,45,6,CPPASTProblemDeclaration,,<empty>
373605,UNKNOWN,5,,"[[nodiscard]] HRESULT ConsoleServerInitialization(_In_ HANDLE Server, const ConsoleArguments* const args)
try
{
    auto& Globals = ServiceLocator::LocateGlobals();

    if (!Globals.pDeviceComm)
    {
        // in rare circumstances (such as in the fuzzing harness), there will already be a device comm
        Globals.pDeviceComm = new ConDrvDeviceComm(Server);
    }

    Globals.launchArgs = *args;

    Globals.uiOEMCP = GetOEMCP();
    Globals.uiWindowsCP = GetACP();

    Globals.pFontDefaultList = new RenderFontDefaults();

    FontInfoBase::s_SetFontDefaultList(Globals.pFontDefaultList);

    // Check if this conhost is allowed to delegate its activities to another.
    // If so, look up the registered default console handler.
    if (Globals.delegationPair.IsUndecided())
    {
        Globals.delegationPair = DelegationConfig::s_GetDelegationPair();

        TraceLoggingWrite(g_hConhostV2EventTraceProvider,
                          ""SrvInit_FoundDelegationConsole"",
          ...",1,<empty>,,45,5,CPPASTProblemDeclaration,,<empty>
373606,UNKNOWN,6,,"CATCH_RETURN()

static bool s_IsOnDesktop()
{
    // Persist this across calls so we don't dig it out a whole bunch of times. Once is good enough for the system.
    static auto fAlreadyQueried = false;
    static auto fIsDesktop = false;

    if (!fAlreadyQueried)
    {
        Microsoft::Console::Interactivity::ApiLevel level;
        const auto status = Microsoft::Console::Interactivity::ApiDetector::DetectNtUserWindow(&level);
        LOG_IF_NTSTATUS_FAILED(status);

        if (SUCCEEDED_NTSTATUS(status))
        {
            switch (level)
            {
            case Microsoft::Console::Interactivity::ApiLevel::OneCore:
                fIsDesktop = false;
                break;
            case Microsoft::Console::Interactivity::ApiLevel::Win32:
                fIsDesktop = true;
                break;
            }
        }

        fAlreadyQueried = true;
    }

    return fIsDesktop;
}",1,<empty>,,105,6,CPPASTProblemDeclaration,,<empty>
373607,UNKNOWN,7,,"[[nodiscard]] NTSTATUS SetUpConsole(_Inout_ Settings* pStartupSettings,
                                    _In_ DWORD TitleLength,
                                    _In_reads_bytes_(TitleLength) LPWSTR Title,
                                    _In_ LPCWSTR CurDir,
                                    _In_ LPCWSTR AppName)
{
    // We will find and locate all relevant preference settings and then create the console here.
    // The precedence order for settings is:
    // 0. Launch arguments passed on the commandline.
    // 1. STARTUPINFO settings
    // 2a. Shortcut/Link settings
    // 2b. Registry specific settings
    // 3. Registry default settings
    // 4. Hardcoded default settings
    // To establish this hierarchy, we will need to load the settings and apply them in reverse order.

    // 4. Initializing Settings will establish hard-coded defaults.
    // Set to reference of global console information since that's the only place we need to hold the settings.
    auto& s...",1,<empty>,,138,7,CPPASTProblemDeclaration,,<empty>
373608,UNKNOWN,8,,"[[nodiscard]] NTSTATUS RemoveConsole(_In_ ConsoleProcessHandle* ProcessData)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    LockConsole();
    auto Status = STATUS_SUCCESS;

    CommandHistory::s_Free((HANDLE)ProcessData);

    const auto fRecomputeOwner = ProcessData->fRootProcess;
    gci.ProcessHandleList.FreeProcessData(ProcessData);

    if (fRecomputeOwner)
    {
        auto pWindow = ServiceLocator::LocateConsoleWindow();
        if (pWindow != nullptr)
        {
            pWindow->SetOwner();
        }
    }

    UnlockConsole();

    return Status;
}",1,<empty>,,266,8,CPPASTProblemDeclaration,,<empty>
373609,UNKNOWN,9,,DWORD,1,<empty>,,291,9,CPPASTProblemDeclaration,,<empty>
373619,UNKNOWN,12,,"HRESULT ConsoleCreateIoThread(_In_ HANDLE Server,
                              const ConsoleArguments* const args,
                              HANDLE driverInputEvent,
                              PCONSOLE_API_MSG connectMessage)
{
    auto& g = ServiceLocator::LocateGlobals();
    RETURN_IF_FAILED(ConsoleServerInitialization(Server, args));
    RETURN_IF_FAILED(g.hConsoleInputInitEvent.create(wil::EventOptions::None));

    if (driverInputEvent != INVALID_HANDLE_VALUE)
    {
        // Store the driver input event. It's already been told that it exists by whomever started us.
        g.hInputEvent.reset(driverInputEvent);
    }
    else
    {
        // Set up and tell the driver about the input available event.
        RETURN_IF_FAILED(g.hInputEvent.create(wil::EventOptions::ManualReset));

        CD_IO_SERVER_INFORMATION ServerInformation;
        ServerInformation.InputAvailableEvent = ServiceLocator::LocateGlobals().hInputEvent.get();
        RETURN_IF_FAILED(g.pDeviceComm...",1,<empty>,,343,12,CPPASTProblemDeclaration,,<empty>
373620,UNKNOWN,13,,"[[nodiscard]] HRESULT ConsoleEstablishHandoff([[maybe_unused]] _In_ HANDLE Server,
                                              [[maybe_unused]] HANDLE driverInputEvent,
                                              [[maybe_unused]] HANDLE hostSignalPipe,
                                              [[maybe_unused]] HANDLE hostProcessHandle,
                                              [[maybe_unused]] PCONSOLE_API_MSG connectMessage)
try
{
    // Create a telemetry instance here - this singleton is responsible for
    // setting up the g_hConhostV2EventTraceProvider, which is otherwise not
    // initialized in the defterm handoff at this point.
    (void)Telemetry::Instance();

#if !TIL_FEATURE_RECEIVEINCOMINGHANDOFF_ENABLED
    TraceLoggingWrite(g_hConhostV2EventTraceProvider,
                      ""SrvInit_ReceiveHandoff_Disabled"",
                      TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                      TraceLoggingKeyword(TIL_KEYWORD_TRACE));
    return HRESULT...",1,<empty>,,424,13,CPPASTProblemDeclaration,,<empty>
373621,UNKNOWN,14,,"CATCH_RETURN()

// Routine Description:
// - Creates the I/O thread for handling and processing messages from the console driver
//   as the server side of a console session.
// - This entrypoint is for all start scenarios that are not receiving a hand-off
//   from another console server. For example, getting started by kernelbase.dll from
//   the operating system as a client application realizes it needs a console server,
//   getting started to be a ConPTY host inside the OS, or being double clicked either
//   inside the OS as `conhost.exe` or outside as `OpenConsole.exe`.
// Arguments:
// - Server - The server side handle to the console driver to let us pick up messages to process for the clients.
// - args - A structure of arguments that may have been passed in on the command-line, typically only used to control the ConPTY configuration.
// Return Value:
// - S_OK if the thread starts up correctly or any number of thread, registry, windowing, or just about any other
//   fail...",1,<empty>,,617,14,CPPASTProblemDeclaration,,<empty>
373622,UNKNOWN,15,,"PWSTR TranslateConsoleTitle(_In_ PCWSTR pwszConsoleTitle, const BOOL fUnexpand, const BOOL fSubstitute)
{
    LPWSTR Tmp = nullptr;

    size_t cbConsoleTitle;
    size_t cbSystemRoot;

    auto pwszSysRoot = new (std::nothrow) wchar_t[MAX_PATH];
    if (nullptr != pwszSysRoot)
    {
        if (0 != GetWindowsDirectoryW(pwszSysRoot, MAX_PATH))
        {
            if (SUCCEEDED(StringCbLengthW(pwszConsoleTitle, STRSAFE_MAX_CCH, &cbConsoleTitle)) &&
                SUCCEEDED(StringCbLengthW(pwszSysRoot, MAX_PATH, &cbSystemRoot)))
            {
                const auto cchSystemRoot = (int)(cbSystemRoot / sizeof(WCHAR));
                const auto cchConsoleTitle = (int)(cbConsoleTitle / sizeof(WCHAR));
                cbConsoleTitle += sizeof(WCHAR); // account for nullptr terminator

                if (fUnexpand &&
                    cchConsoleTitle >= cchSystemRoot &&
#pragma prefast(suppress : 26018, ""We've guaranteed that cchSystemRoot is equal to or smaller than cchConsole...",1,<empty>,,653,15,CPPASTProblemDeclaration,,<empty>
373623,UNKNOWN,16,,"[[nodiscard]] NTSTATUS GetConsoleLangId(const UINT uiOutputCP, _Out_ LANGID* const pLangId)
{
    auto Status = STATUS_NOT_SUPPORTED;

    // -- WARNING -- LOAD BEARING CODE --
    // Only attempt to return the Lang ID if the Windows ACP on console launch was an East Asian Code Page.
    // -
    // As of right now, this is a load bearing check and causes a domino effect of errors during OEM preinstallation if removed
    // resulting in a crash on launch of CMD.exe
    // (and consequently any scripts OEMs use to customize an image during the auditUser preinstall step inside their unattend.xml files.)
    // I have no reason to believe that removing this check causes any problems on any other SKU or scenario types.
    // -
    // Returning STATUS_NOT_SUPPORTED will skip a call to SetThreadLocale inside the Windows loader. This has the effect of not
    // setting the appropriate locale on the client end of the pipe, but also avoids the error.
    // Returning STATUS_SUCCESS will t...",1,<empty>,,725,16,CPPASTProblemDeclaration,,<empty>
373627,UNKNOWN,-1,,"try
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        LockConsole();
        auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

        // This fails a lot and it's totally expected. It only works for a few East Asian code pages.
        // As such, just return it. Do NOT use a wil macro here. It is very noisy.
        return HRESULT_FROM_NT(GetConsoleLangId(gci.OutputCP, &langId));
    }
    CATCH_RETURN();",5,<empty>,,784,1,CPPASTProblemStatement,,<empty>
373630,UNKNOWN,18,,"[[nodiscard]] NTSTATUS ConsoleInitializeConnectInfo(_In_ PCONSOLE_API_MSG Message, _Out_ PCONSOLE_API_CONNECTINFO Cac)
{
    CONSOLE_SERVER_MSG Data = { 0 };
    // Try to receive the data sent by the client.
    auto Status = NTSTATUS_FROM_HRESULT(Message->ReadMessageInput(0, &Data, sizeof(Data)));
    if (FAILED_NTSTATUS(Status))
    {
        return Status;
    }

    // Validate that strings are within the buffers and null-terminated.
    if ((Data.ApplicationNameLength > (sizeof(Data.ApplicationName) - sizeof(WCHAR))) ||
        (Data.TitleLength > (sizeof(Data.Title) - sizeof(WCHAR))) ||
        (Data.CurrentDirectoryLength > (sizeof(Data.CurrentDirectory) - sizeof(WCHAR))) ||
        (Data.ApplicationName[Data.ApplicationNameLength / sizeof(WCHAR)] != UNICODE_NULL) ||
        (Data.Title[Data.TitleLength / sizeof(WCHAR)] != UNICODE_NULL) || (Data.CurrentDirectory[Data.CurrentDirectoryLength / sizeof(WCHAR)] != UNICODE_NULL))
    {
        return STATUS_INVALID_BUFFER_SIZE;
  ...",1,<empty>,,806,18,CPPASTProblemDeclaration,,<empty>
373746,UNKNOWN,1,,Renderer*,72,<empty>,,892,1,CPPASTTypeId,,<empty>
373947,UNKNOWN,21,,DWORD,1,<empty>,,1012,21,CPPASTProblemDeclaration,,<empty>
373985,UNKNOWN,1,,PCONSOLE_API_MSG,71,<empty>,,1026,1,CPPASTTypeId,,<empty>
374105,UNKNOWN,1,,"[[nodiscard]] NTSTATUS GetConsoleLangId(const UINT uiOutputCP, _Out_ LANGID* const pLangId);",1,<empty>,,21,1,CPPASTProblemDeclaration,,<empty>
374106,UNKNOWN,2,,"PWSTR TranslateConsoleTitle(_In_ PCWSTR pwszConsoleTitle, const BOOL fUnexpand, const BOOL fSubstitute);",1,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
374107,UNKNOWN,3,,"[[nodiscard]] NTSTATUS ConsoleInitializeConnectInfo(_In_ PCONSOLE_API_MSG Message, _Out_ PCONSOLE_API_CONNECTINFO Cac);",1,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
374113,UNKNOWN,5,,[[nodiscard]] NTSTATUS RemoveConsole(_In_ ConsoleProcessHandle* ProcessData);,1,<empty>,,27,5,CPPASTProblemDeclaration,,<empty>
374119,UNKNOWN,7,,"[[nodiscard]] HRESULT ConsoleEstablishHandoff(_In_ HANDLE Server,
                                              HANDLE driverInputEvent,
                                              HANDLE hostSignalPipe,
                                              HANDLE hostProcessHandle,
                                              PCONSOLE_API_MSG connectMessage);",1,<empty>,,31,7,CPPASTProblemDeclaration,,<empty>
374321,UNKNOWN,3,,"[[nodiscard]] NTSTATUS GetChar(_Inout_ InputBuffer* const pInputBuffer,
                               _Out_ wchar_t* const pwchOut,
                               const bool Wait,
                               _Out_opt_ bool* const pCommandLineEditingKeys,
                               _Out_opt_ bool* const pPopupKeys,
                               _Out_opt_ DWORD* const pdwKeyState) noexcept
{
    if (nullptr != pCommandLineEditingKeys)
    {
        *pCommandLineEditingKeys = false;
    }

    if (nullptr != pPopupKeys)
    {
        *pPopupKeys = false;
    }

    if (nullptr != pdwKeyState)
    {
        *pdwKeyState = 0;
    }

    for (;;)
    {
        InputEventQueue events;
        const auto Status = pInputBuffer->Read(events, 1, false, Wait, true, true);
        if (FAILED_NTSTATUS(Status))
        {
            return Status;
        }
        if (events.empty())
        {
            assert(!Wait);
            return STATUS_UNSUCCESSFUL;
        }

        const aut...",1,<empty>,,122,3,CPPASTProblemDeclaration,,<empty>
374322,UNKNOWN,4,,"[[nodiscard]] static NTSTATUS _ReadPendingInput(InputBuffer& inputBuffer,
                                                std::span<char> buffer,
                                                size_t& bytesRead,
                                                INPUT_READ_HANDLE_DATA& readHandleState,
                                                const bool unicode)
try
{
    bytesRead = 0;

    const auto pending = readHandleState.GetPendingInput();
    auto input = pending;

    // This is basically the continuation of COOKED_READ_DATA::_handlePostCharInputLoop.
    if (readHandleState.IsMultilineInput())
    {
        const auto firstLineEnd = input.find(UNICODE_LINEFEED) + 1;
        input = input.substr(0, std::min(input.size(), firstLineEnd));
    }

    const auto inputSizeBefore = input.size();
    std::span writer{ buffer };
    inputBuffer.Consume(unicode, input, writer);

    // Since we truncated `input` to only include the first line,
    // we need to restore `input` ...",1,<empty>,,263,4,CPPASTProblemDeclaration,,<empty>
374323,UNKNOWN,5,,"[[nodiscard]] NTSTATUS ReadCharacterInput(InputBuffer& inputBuffer,
                                          std::span<char> buffer,
                                          size_t& bytesRead,
                                          INPUT_READ_HANDLE_DATA& readHandleState,
                                          const bool unicode)
try
{
    UNREFERENCED_PARAMETER(readHandleState);

    bytesRead = 0;

    const auto charSize = unicode ? sizeof(wchar_t) : sizeof(char);
    std::span writer{ buffer };

    if (writer.size() < charSize)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    inputBuffer.ConsumeCached(unicode, writer);

    auto noDataReadYet = writer.size() == buffer.size();
    auto status = STATUS_SUCCESS;

    while (writer.size() >= charSize)
    {
        wchar_t wch;
        // We don't need to wait for input if `ConsumeCached` read something already, which is
        // indicated by the writer having been advanced (= it's shorter than the original buffer...",1,<empty>,,399,5,CPPASTProblemDeclaration,,<empty>
374409,UNKNOWN,1,,"[[nodiscard]] NTSTATUS GetChar(_Inout_ InputBuffer* const pInputBuffer,
                               _Out_ wchar_t* const pwchOut,
                               const bool Wait,
                               _Out_opt_ bool* const pCommandLineEditingKeys,
                               _Out_opt_ bool* const pPopupKeys,
                               _Out_opt_ DWORD* const pdwKeyState) noexcept;",1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
374443,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(g_hConhostV2EventTraceProvider,
                             ""Microsoft.Windows.Console.Host"",
                             // {fe1ff234-1f09-50a8-d38d-c44fab43e818}
                             (0xfe1ff234, 0x1f09, 0x50a8, 0xd3, 0x8d, 0xc4, 0x4f, 0xab, 0x43, 0xe8, 0x18),
                             TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,15,1,CPPASTProblemDeclaration,,<empty>
374605,UNKNOWN,21,,"bool Telemetry::FindProcessName(const WCHAR* pszProcessName, _Out_ size_t* iPosition) const
{
    auto iMin = 0;
    auto iMid = 0;
    auto iMax = _uiNumberProcessFileNames - 1;
    auto result = 0;

    while (iMin <= iMax)
    {
        iMid = (iMax + iMin) / 2;
        // Use a case-insensitive comparison.  We do support running Linux binaries now, but we haven't seen them connect
        // as processes, and even if they did, we don't care about the difference in running emacs vs. Emacs.
        result = _wcsnicmp(pszProcessName, _wchProcessFileNames + _rgiProcessFileNameIndex[_rgiAlphabeticalIndex[iMid]], MAX_PATH);
        if (result < 0)
        {
            iMax = iMid - 1;
        }
        else if (result > 0)
        {
            iMin = iMid + 1;
        }
        else
        {
            // Found the string.
            *iPosition = iMid;
            return true;
        }
    }

    // Let them know which position to insert the string at.
    *iPosition = (result >...",1,<empty>,,180,21,CPPASTProblemDeclaration,,<empty>
374756,UNKNOWN,1,,BYTE*,57,<empty>,,279,1,CPPASTTypeId,,<empty>
374763,UNKNOWN,1,,BYTE,39,<empty>,,280,1,CPPASTTypeId,,<empty>
374866,UNKNOWN,1,,UINT,95,<empty>,,324,1,CPPASTTypeId,,<empty>
374881,UNKNOWN,1,,int,67,<empty>,,328,1,CPPASTTypeId,,<empty>
374886,UNKNOWN,1,,int,67,<empty>,,329,1,CPPASTTypeId,,<empty>
374943,UNKNOWN,1,,UINT32 const*,62,<empty>,,348,1,CPPASTTypeId,,<empty>
375592,UNKNOWN,24,,"void Telemetry::LogRipMessage(_In_z_ const char* pszMessage, ...) const
{
    // Code needed for passing variable parameters to the vsprintf function.
    va_list args;
    va_start(args, pszMessage);
    char szMessageEvaluated[200] = """";
    auto cCharsWritten = vsprintf_s(szMessageEvaluated, ARRAYSIZE(szMessageEvaluated), pszMessage, args);
    va_end(args);

#if DBG
    OutputDebugStringA(szMessageEvaluated);
#endif

    if (cCharsWritten > 0)
    {
        // clang-format off
#pragma prefast(suppress: __WARNING_NONCONST_LOCAL, ""Activity can't be const, since it's set to a random value on startup."")
        // clang-format on
        TraceLoggingWriteTagged(_activity,
                                ""RipMessage"",
                                TraceLoggingString(szMessageEvaluated, ""Message""));
    }
}",1,<empty>,,493,24,CPPASTProblemDeclaration,,<empty>
375683,UNKNOWN,-1,,"void LogRipMessage(_In_z_ const char* pszMessage, ...) const;",5,<empty>,,50,19,CPPASTProblemDeclaration,,<empty>
375784,UNKNOWN,-1,,"bool FindProcessName(const WCHAR* pszProcessName, _Out_ size_t* iPosition) const;",5,<empty>,,133,28,CPPASTProblemDeclaration,,<empty>
375931,UNKNOWN,6,,"void Tracing::s_TraceChars(_In_z_ const char* pszMessage, ...)
{
    va_list args;
    va_start(args, pszMessage);
    char szBuffer[256] = """";
    vsprintf_s(szBuffer, ARRAYSIZE(szBuffer), pszMessage, args);
    va_end(args);

    TraceLoggingWrite(
        g_hConhostV2EventTraceProvider,
        ""CharsTrace"",
        TraceLoggingString(szBuffer),
        TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
        TraceLoggingKeyword(TIL_KEYWORD_TRACE),
        TraceLoggingKeyword(TraceKeywords::Chars));

    if (s_ulDebugFlag & TraceKeywords::Chars)
    {
        OutputDebugStringA(szBuffer);
    }
}",1,<empty>,,45,6,CPPASTProblemDeclaration,,<empty>
375932,UNKNOWN,7,,"void Tracing::s_TraceOutput(_In_z_ const char* pszMessage, ...)
{
    va_list args;
    va_start(args, pszMessage);
    char szBuffer[256] = """";
    vsprintf_s(szBuffer, ARRAYSIZE(szBuffer), pszMessage, args);
    va_end(args);

    TraceLoggingWrite(
        g_hConhostV2EventTraceProvider,
        ""OutputTrace"",
        TraceLoggingString(szBuffer),
        TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
        TraceLoggingKeyword(TIL_KEYWORD_TRACE),
        TraceLoggingKeyword(TraceKeywords::Output));

    if (s_ulDebugFlag & TraceKeywords::Output)
    {
        OutputDebugStringA(szBuffer);
    }
}",1,<empty>,,67,7,CPPASTProblemDeclaration,,<empty>
376254,UNKNOWN,10,,"void Tracing::s_TraceCookedRead(_In_ ConsoleProcessHandle* const pConsoleProcessHandle, const std::wstring_view& text)
{
    if (TraceLoggingProviderEnabled(g_hConhostV2EventTraceProvider, 0, TraceKeywords::CookedRead))
    {
        const auto length = ::base::saturated_cast<ULONG>(text.size());
        TraceLoggingWrite(
            g_hConhostV2EventTraceProvider,
            ""CookedRead"",
            TraceLoggingPid(pConsoleProcessHandle->dwProcessId, ""AttachedProcessId""),
            TraceLoggingCountedWideString(text.data(), length, ""ReadBuffer""),
            TraceLoggingULong(length, ""ReadBufferLength""),
            TraceLoggingFileTime(pConsoleProcessHandle->GetProcessCreationTime(), ""AttachedProcessCreationTime""),
            TraceLoggingKeyword(TIL_KEYWORD_TRACE),
            TraceLoggingKeyword(TraceKeywords::CookedRead));
    }
}",1,<empty>,,176,10,CPPASTProblemDeclaration,,<empty>
376255,UNKNOWN,11,,"void Tracing::s_TraceConsoleAttachDetach(_In_ ConsoleProcessHandle* const pConsoleProcessHandle, _In_ bool bIsAttach)
{
    if (TraceLoggingProviderEnabled(g_hConhostV2EventTraceProvider, 0, TraceKeywords::ConsoleAttachDetach))
    {
        auto bIsUserInteractive = Telemetry::Instance().IsUserInteractive();

        TraceLoggingWrite(
            g_hConhostV2EventTraceProvider,
            ""ConsoleAttachDetach"",
            TraceLoggingPid(pConsoleProcessHandle->dwProcessId, ""AttachedProcessId""),
            TraceLoggingFileTime(pConsoleProcessHandle->GetProcessCreationTime(), ""AttachedProcessCreationTime""),
            TraceLoggingBool(bIsAttach, ""IsAttach""),
            TraceLoggingBool(bIsUserInteractive, ""IsUserInteractive""),
            TraceLoggingKeyword(TIL_KEYWORD_TRACE),
            TraceLoggingKeyword(TraceKeywords::ConsoleAttachDetach));
    }
}",1,<empty>,,193,11,CPPASTProblemDeclaration,,<empty>
376330,UNKNOWN,-1,,"static void s_TraceChars(_In_z_ const char* pszMessage, ...);",5,<empty>,,48,2,CPPASTProblemDeclaration,,<empty>
376331,UNKNOWN,-1,,"static void s_TraceOutput(_In_z_ const char* pszMessage, ...);",5,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
376342,UNKNOWN,-1,,"static void s_TraceCookedRead(_In_ ConsoleProcessHandle* const pConsoleProcessHandle, const std::wstring_view& text);",5,<empty>,,54,6,CPPASTProblemDeclaration,,<empty>
376343,UNKNOWN,-1,,"static void s_TraceConsoleAttachDetach(_In_ ConsoleProcessHandle* const pConsoleProcessHandle, _In_ bool bIsAttach);",5,<empty>,,55,7,CPPASTProblemDeclaration,,<empty>
376469,UNKNOWN,4,,"TEST_METHOD(TestMatchAndCopy)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:exeName"", L""{test.exe}"")
            TEST_METHOD_PROPERTY(L""Data:aliasName"", L""{foo}"")
            TEST_METHOD_PROPERTY(L""Data:originalString"", L""{ foo one two three four five six seven eight nine ten eleven twelve }"")
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{"" // Each of these is a human-generated test of macro before and after.
                                 L""bar=bar%,"" // The character % will be turned into an \r\n
                                 L""bar $1=bar one%,""
                                 L""bar $2=bar two%,""
                                 L""bar $3=bar three%,""
                                 L""bar $4=bar four%,""
                                 L""bar $5=bar five%,""
                                 L""bar $6=bar six%,""
                                 L""bar $7=bar seven%,""
                        ...",5,<empty>,,61,4,CPPASTProblemDeclaration,,<empty>
376470,UNKNOWN,5,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""exeName"", exeName));",9,<empty>,,100,5,CPPASTProblemDeclaration,,<empty>
376472,UNKNOWN,7,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""aliasName"", aliasName));",9,<empty>,,103,7,CPPASTProblemDeclaration,,<empty>
376474,UNKNOWN,9,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""originalString"", originalString));",9,<empty>,,106,9,CPPASTProblemDeclaration,,<empty>
376488,UNKNOWN,17,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,118,17,CPPASTProblemDeclaration,,<empty>
376515,UNKNOWN,25,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,128,25,CPPASTProblemDeclaration,,<empty>
376516,UNKNOWN,26,,"VERIFY_ARE_EQUAL(linesExpected, linesActual);",9,<empty>,,129,26,CPPASTProblemDeclaration,,<empty>
376517,UNKNOWN,27,,},5,<empty>,,130,27,CPPASTProblemDeclaration,,<empty>
376518,UNKNOWN,28,,"TEST_METHOD(TestMatchAndCopyInvalidExeName)
    {
        const auto pwszSource = L""Source"";",5,<empty>,,132,28,CPPASTProblemDeclaration,,<empty>
376534,UNKNOWN,34,,VERIFY_IS_TRUE(buffer.empty());,9,<empty>,,138,34,CPPASTProblemDeclaration,,<empty>
376535,UNKNOWN,35,,"VERIFY_ARE_EQUAL(1u, dwLines);",9,<empty>,,139,35,CPPASTProblemDeclaration,,<empty>
376536,UNKNOWN,36,,},5,<empty>,,140,36,CPPASTProblemDeclaration,,<empty>
376537,UNKNOWN,37,,"TEST_METHOD(TestMatchAndCopyExeNotFound)
    {
        const auto pwszSource = L""Source"";",5,<empty>,,142,37,CPPASTProblemDeclaration,,<empty>
376555,UNKNOWN,44,,VERIFY_IS_TRUE(buffer.empty());,9,<empty>,,148,44,CPPASTProblemDeclaration,,<empty>
376556,UNKNOWN,45,,"VERIFY_ARE_EQUAL(1u, dwLines);",9,<empty>,,149,45,CPPASTProblemDeclaration,,<empty>
376557,UNKNOWN,46,,},5,<empty>,,150,46,CPPASTProblemDeclaration,,<empty>
376558,UNKNOWN,47,,"TEST_METHOD(TestMatchAndCopyAliasNotFound)
    {
        const auto pwszSource = L""Source"";",5,<empty>,,152,47,CPPASTProblemDeclaration,,<empty>
376589,UNKNOWN,59,,VERIFY_IS_TRUE(buffer.empty());,9,<empty>,,164,59,CPPASTProblemDeclaration,,<empty>
376590,UNKNOWN,60,,"VERIFY_ARE_EQUAL(1u, dwLines);",9,<empty>,,165,60,CPPASTProblemDeclaration,,<empty>
376591,UNKNOWN,61,,},5,<empty>,,166,61,CPPASTProblemDeclaration,,<empty>
376592,UNKNOWN,62,,"TEST_METHOD(TestMatchAndCopyLeadingSpaces)
    {
        const auto pwszSource = L"" Source"";",5,<empty>,,168,62,CPPASTProblemDeclaration,,<empty>
376623,UNKNOWN,74,,VERIFY_IS_TRUE(buffer.empty());,9,<empty>,,181,74,CPPASTProblemDeclaration,,<empty>
376624,UNKNOWN,75,,"VERIFY_ARE_EQUAL(1u, dwLines);",9,<empty>,,182,75,CPPASTProblemDeclaration,,<empty>
376625,UNKNOWN,76,,},5,<empty>,,183,76,CPPASTProblemDeclaration,,<empty>
376626,UNKNOWN,77,,"TEST_METHOD(Tokenize)
    {
        std::wstring tokenStr(L""one two three"");",5,<empty>,,185,77,CPPASTProblemDeclaration,,<empty>
376628,UNKNOWN,79,,"tokensExpected.emplace_back(L""one"");",9,<empty>,,189,79,CPPASTProblemDeclaration,,<empty>
376629,UNKNOWN,80,,"tokensExpected.emplace_back(L""two"");",9,<empty>,,190,80,CPPASTProblemDeclaration,,<empty>
376630,UNKNOWN,81,,"tokensExpected.emplace_back(L""three"");",9,<empty>,,191,81,CPPASTProblemDeclaration,,<empty>
376639,UNKNOWN,84,,"VERIFY_ARE_EQUAL(tokensExpected.size(), tokensActual.size());",9,<empty>,,195,84,CPPASTProblemDeclaration,,<empty>
376640,UNKNOWN,85,,for (size_t i = 0;,9,<empty>,,197,85,CPPASTProblemDeclaration,,<empty>
376641,UNKNOWN,86,,i < tokensExpected.size();,28,<empty>,,197,86,CPPASTProblemDeclaration,,<empty>
376642,UNKNOWN,87,,"i++)
        {
            VERIFY_ARE_EQUAL(String(tokensExpected[i].data()), String(tokensActual[i].data()));
        }",55,<empty>,,197,87,CPPASTProblemDeclaration,,<empty>
376643,UNKNOWN,88,,},5,<empty>,,201,88,CPPASTProblemDeclaration,,<empty>
376644,UNKNOWN,89,,"TEST_METHOD(TokenizeNothing)
    {
        std::wstring tokenStr(L""alias"");",5,<empty>,,203,89,CPPASTProblemDeclaration,,<empty>
376646,UNKNOWN,91,,tokensExpected.emplace_back(tokenStr);,9,<empty>,,207,91,CPPASTProblemDeclaration,,<empty>
376655,UNKNOWN,94,,"VERIFY_ARE_EQUAL(tokensExpected.size(), tokensActual.size());",9,<empty>,,211,94,CPPASTProblemDeclaration,,<empty>
376656,UNKNOWN,95,,for (size_t i = 0;,9,<empty>,,213,95,CPPASTProblemDeclaration,,<empty>
376657,UNKNOWN,96,,i < tokensExpected.size();,28,<empty>,,213,96,CPPASTProblemDeclaration,,<empty>
376658,UNKNOWN,97,,"i++)
        {
            VERIFY_ARE_EQUAL(String(tokensExpected[i].data()), String(tokensActual[i].data()));
        }",55,<empty>,,213,97,CPPASTProblemDeclaration,,<empty>
376659,UNKNOWN,98,,},5,<empty>,,217,98,CPPASTProblemDeclaration,,<empty>
376660,UNKNOWN,99,,"TEST_METHOD(GetArgString)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""alias arg1 arg2 arg3=arg1 arg2 arg3,""
                                 L""aliasOnly=""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,219,99,CPPASTProblemDeclaration,,<empty>
376662,UNKNOWN,101,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,231,101,CPPASTProblemDeclaration,,<empty>
376671,UNKNOWN,104,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,235,104,CPPASTProblemDeclaration,,<empty>
376672,UNKNOWN,105,,},5,<empty>,,236,105,CPPASTProblemDeclaration,,<empty>
376673,UNKNOWN,106,,"TEST_METHOD(NumberedArgMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""1=one,""
                                 L""2=two,""
                                 L""3=three,""
                                 L""4=four,""
                                 L""5=five,""
                                 L""6=six,""
                                 L""7=seven,""
                                 L""8=eight,""
                                 L""9=nine,""
                                 L""A=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,238,106,CPPASTProblemDeclaration,,<empty>
376675,UNKNOWN,108,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,259,108,CPPASTProblemDeclaration,,<empty>
376677,UNKNOWN,110,,"tokens.emplace_back(L""alias"");",9,<empty>,,262,110,CPPASTProblemDeclaration,,<empty>
376678,UNKNOWN,111,,"tokens.emplace_back(L""one"");",9,<empty>,,263,111,CPPASTProblemDeclaration,,<empty>
376679,UNKNOWN,112,,"tokens.emplace_back(L""two"");",9,<empty>,,264,112,CPPASTProblemDeclaration,,<empty>
376680,UNKNOWN,113,,"tokens.emplace_back(L""three"");",9,<empty>,,265,113,CPPASTProblemDeclaration,,<empty>
376681,UNKNOWN,114,,"tokens.emplace_back(L""four"");",9,<empty>,,266,114,CPPASTProblemDeclaration,,<empty>
376682,UNKNOWN,115,,"tokens.emplace_back(L""five"");",9,<empty>,,267,115,CPPASTProblemDeclaration,,<empty>
376683,UNKNOWN,116,,"tokens.emplace_back(L""six"");",9,<empty>,,268,116,CPPASTProblemDeclaration,,<empty>
376684,UNKNOWN,117,,"tokens.emplace_back(L""seven"");",9,<empty>,,269,117,CPPASTProblemDeclaration,,<empty>
376685,UNKNOWN,118,,"tokens.emplace_back(L""eight"");",9,<empty>,,270,118,CPPASTProblemDeclaration,,<empty>
376686,UNKNOWN,119,,"tokens.emplace_back(L""nine"");",9,<empty>,,271,119,CPPASTProblemDeclaration,,<empty>
376687,UNKNOWN,120,,"tokens.emplace_back(L""ten"");",9,<empty>,,272,120,CPPASTProblemDeclaration,,<empty>
376709,UNKNOWN,126,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,280,126,CPPASTProblemDeclaration,,<empty>
376710,UNKNOWN,127,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,281,127,CPPASTProblemDeclaration,,<empty>
376711,UNKNOWN,128,,},5,<empty>,,282,128,CPPASTProblemDeclaration,,<empty>
376712,UNKNOWN,129,,"TEST_METHOD(WildcardArgMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""*=one two three,""
                                 L""A=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,284,129,CPPASTProblemDeclaration,,<empty>
376714,UNKNOWN,131,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,297,131,CPPASTProblemDeclaration,,<empty>
376739,UNKNOWN,139,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,307,139,CPPASTProblemDeclaration,,<empty>
376740,UNKNOWN,140,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,308,140,CPPASTProblemDeclaration,,<empty>
376741,UNKNOWN,141,,},5,<empty>,,309,141,CPPASTProblemDeclaration,,<empty>
376742,UNKNOWN,142,,"TEST_METHOD(InputRedirMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""L=<,""
                                 L""l=<,""
                                 L""A=,""
                                 L""a=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,311,142,CPPASTProblemDeclaration,,<empty>
376744,UNKNOWN,144,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,326,144,CPPASTProblemDeclaration,,<empty>
376765,UNKNOWN,150,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,334,150,CPPASTProblemDeclaration,,<empty>
376766,UNKNOWN,151,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,335,151,CPPASTProblemDeclaration,,<empty>
376767,UNKNOWN,152,,},5,<empty>,,336,152,CPPASTProblemDeclaration,,<empty>
376768,UNKNOWN,153,,"TEST_METHOD(OutputRedirMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""G=>,""
                                 L""g=>,""
                                 L""A=,""
                                 L""a=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,338,153,CPPASTProblemDeclaration,,<empty>
376770,UNKNOWN,155,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,353,155,CPPASTProblemDeclaration,,<empty>
376791,UNKNOWN,161,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,361,161,CPPASTProblemDeclaration,,<empty>
376792,UNKNOWN,162,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,362,162,CPPASTProblemDeclaration,,<empty>
376793,UNKNOWN,163,,},5,<empty>,,363,163,CPPASTProblemDeclaration,,<empty>
376794,UNKNOWN,164,,"TEST_METHOD(PipeRedirMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""B=|,""
                                 L""b=|,""
                                 L""A=,""
                                 L""a=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,365,164,CPPASTProblemDeclaration,,<empty>
376796,UNKNOWN,166,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,380,166,CPPASTProblemDeclaration,,<empty>
376817,UNKNOWN,172,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,388,172,CPPASTProblemDeclaration,,<empty>
376818,UNKNOWN,173,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,389,173,CPPASTProblemDeclaration,,<empty>
376819,UNKNOWN,174,,},5,<empty>,,390,174,CPPASTProblemDeclaration,,<empty>
376820,UNKNOWN,175,,"TEST_METHOD(NextCommandMacro)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:targetExpectedPair"",
                                 L""{""
                                 L""T=%,""
                                 L""t=%,""
                                 L""A=,""
                                 L""a=,""
                                 L""0=,""
                                 L""}"")
        END_TEST_METHOD_PROPERTIES()

        std::wstring target;",5,<empty>,,392,175,CPPASTProblemDeclaration,,<empty>
376822,UNKNOWN,177,,"_RetrieveTargetExpectedPair(target, expected);",9,<empty>,,407,177,CPPASTProblemDeclaration,,<empty>
376858,UNKNOWN,188,,"VERIFY_ARE_EQUAL(returnExpected, returnActual);",9,<empty>,,421,188,CPPASTProblemDeclaration,,<empty>
376859,UNKNOWN,189,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,422,189,CPPASTProblemDeclaration,,<empty>
376860,UNKNOWN,190,,"VERIFY_ARE_EQUAL(lineCountExpected, lineCountActual);",9,<empty>,,423,190,CPPASTProblemDeclaration,,<empty>
376861,UNKNOWN,191,,},5,<empty>,,424,191,CPPASTProblemDeclaration,,<empty>
376862,UNKNOWN,192,,"TEST_METHOD(AppendCrLf)
    {
        std::wstring actual;",5,<empty>,,426,192,CPPASTProblemDeclaration,,<empty>
376882,UNKNOWN,200,,"VERIFY_ARE_EQUAL(String(expected.data()), String(actual.data()));",9,<empty>,,435,200,CPPASTProblemDeclaration,,<empty>
376883,UNKNOWN,201,,"VERIFY_ARE_EQUAL(lineCountExpected, lineCountActual);",9,<empty>,,436,201,CPPASTProblemDeclaration,,<empty>
376884,UNKNOWN,202,,},5,<empty>,,437,202,CPPASTProblemDeclaration,,<empty>
376885,UNKNOWN,203,,};,1,<empty>,,438,203,CPPASTProblemDeclaration,,<empty>
377200,UNKNOWN,5,,"TEST_METHOD(ApiSetConsoleInputModeImplValidNonExtended)
    {
        Log::Comment(L""Set some perfectly valid, non-extended flags."");",5,<empty>,,109,5,CPPASTProblemDeclaration,,<empty>
377201,UNKNOWN,6,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,112,6,CPPASTProblemDeclaration,,<empty>
377202,UNKNOWN,7,,"Log::Comment(L""Success code should result from setting valid flags."");",9,<empty>,,113,7,CPPASTProblemDeclaration,,<empty>
377203,UNKNOWN,8,,"Log::Comment(L""Flags should be set exactly as given."");",9,<empty>,,114,8,CPPASTProblemDeclaration,,<empty>
377204,UNKNOWN,9,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT);",9,<empty>,,115,9,CPPASTProblemDeclaration,,<empty>
377205,UNKNOWN,10,,},5,<empty>,,116,10,CPPASTProblemDeclaration,,<empty>
377206,UNKNOWN,11,,"TEST_METHOD(ApiSetConsoleInputModeImplValidExtended)
    {
        Log::Comment(L""Set some perfectly valid, extended flags."");",5,<empty>,,118,11,CPPASTProblemDeclaration,,<empty>
377207,UNKNOWN,12,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,121,12,CPPASTProblemDeclaration,,<empty>
377208,UNKNOWN,13,,"Log::Comment(L""Success code should result from setting valid flags."");",9,<empty>,,122,13,CPPASTProblemDeclaration,,<empty>
377209,UNKNOWN,14,,"Log::Comment(L""Flags should be set exactly as given."");",9,<empty>,,123,14,CPPASTProblemDeclaration,,<empty>
377210,UNKNOWN,15,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS | ENABLE_QUICK_EDIT_MODE | ENABLE_AUTO_POSITION);",9,<empty>,,124,15,CPPASTProblemDeclaration,,<empty>
377211,UNKNOWN,16,,},5,<empty>,,125,16,CPPASTProblemDeclaration,,<empty>
377212,UNKNOWN,17,,"TEST_METHOD(ApiSetConsoleInputModeImplExtendedTurnOff)
    {
        Log::Comment(L""Try to turn off extended flags."");",5,<empty>,,127,17,CPPASTProblemDeclaration,,<empty>
377213,UNKNOWN,18,,PrepVerifySetConsoleInputModeImpl(ENABLE_EXTENDED_FLAGS | ENABLE_QUICK_EDIT_MODE | ENABLE_AUTO_POSITION);,9,<empty>,,130,18,CPPASTProblemDeclaration,,<empty>
377214,UNKNOWN,19,,"Log::Comment(L""Success code should result from setting valid flags."");",9,<empty>,,131,19,CPPASTProblemDeclaration,,<empty>
377215,UNKNOWN,20,,"Log::Comment(L""Flags should be set exactly as given."");",9,<empty>,,132,20,CPPASTProblemDeclaration,,<empty>
377216,UNKNOWN,21,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS);",9,<empty>,,133,21,CPPASTProblemDeclaration,,<empty>
377217,UNKNOWN,22,,},5,<empty>,,134,22,CPPASTProblemDeclaration,,<empty>
377218,UNKNOWN,23,,"TEST_METHOD(ApiSetConsoleInputModeImplInvalid)
    {
        Log::Comment(L""Set some invalid flags."");",5,<empty>,,136,23,CPPASTProblemDeclaration,,<empty>
377219,UNKNOWN,24,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,139,24,CPPASTProblemDeclaration,,<empty>
377220,UNKNOWN,25,,"Log::Comment(L""Should get invalid argument code because we set invalid flags."");",9,<empty>,,140,25,CPPASTProblemDeclaration,,<empty>
377221,UNKNOWN,26,,"Log::Comment(L""Flags should be set anyway despite invalid code."");",9,<empty>,,141,26,CPPASTProblemDeclaration,,<empty>
377222,UNKNOWN,27,,"VerifySetConsoleInputModeImpl(E_INVALIDARG, 0x8000000);",9,<empty>,,142,27,CPPASTProblemDeclaration,,<empty>
377223,UNKNOWN,28,,},5,<empty>,,143,28,CPPASTProblemDeclaration,,<empty>
377224,UNKNOWN,29,,"TEST_METHOD(ApiSetConsoleInputModeImplInsertNoCookedRead)
    {
        Log::Comment(L""Turn on insert mode without cooked read data."");",5,<empty>,,145,29,CPPASTProblemDeclaration,,<empty>
377225,UNKNOWN,30,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,148,30,CPPASTProblemDeclaration,,<empty>
377226,UNKNOWN,31,,"Log::Comment(L""Success code should result from setting valid flags."");",9,<empty>,,149,31,CPPASTProblemDeclaration,,<empty>
377227,UNKNOWN,32,,"Log::Comment(L""Flags should be set exactly as given."");",9,<empty>,,150,32,CPPASTProblemDeclaration,,<empty>
377228,UNKNOWN,33,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS | ENABLE_INSERT_MODE);",9,<empty>,,151,33,CPPASTProblemDeclaration,,<empty>
377229,UNKNOWN,34,,"Log::Comment(L""Turn back off and verify."");",9,<empty>,,152,34,CPPASTProblemDeclaration,,<empty>
377230,UNKNOWN,35,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,153,35,CPPASTProblemDeclaration,,<empty>
377231,UNKNOWN,36,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS);",9,<empty>,,154,36,CPPASTProblemDeclaration,,<empty>
377232,UNKNOWN,37,,},5,<empty>,,155,37,CPPASTProblemDeclaration,,<empty>
377233,UNKNOWN,38,,"TEST_METHOD(ApiSetConsoleInputModeImplInsertCookedRead)
    {
        Log::Comment(L""Turn on insert mode with cooked read data."");",5,<empty>,,157,38,CPPASTProblemDeclaration,,<empty>
377234,UNKNOWN,39,,m_state->PrepareReadHandle();,9,<empty>,,160,39,CPPASTProblemDeclaration,,<empty>
377243,UNKNOWN,42,,m_state->PrepareCookedReadData();,9,<empty>,,162,42,CPPASTProblemDeclaration,,<empty>
377252,UNKNOWN,45,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,165,45,CPPASTProblemDeclaration,,<empty>
377253,UNKNOWN,46,,"Log::Comment(L""Success code should result from setting valid flags."");",9,<empty>,,166,46,CPPASTProblemDeclaration,,<empty>
377254,UNKNOWN,47,,"Log::Comment(L""Flags should be set exactly as given."");",9,<empty>,,167,47,CPPASTProblemDeclaration,,<empty>
377255,UNKNOWN,48,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS | ENABLE_INSERT_MODE);",9,<empty>,,168,48,CPPASTProblemDeclaration,,<empty>
377256,UNKNOWN,49,,"Log::Comment(L""Turn back off and verify."");",9,<empty>,,169,49,CPPASTProblemDeclaration,,<empty>
377257,UNKNOWN,50,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,170,50,CPPASTProblemDeclaration,,<empty>
377258,UNKNOWN,51,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_EXTENDED_FLAGS);",9,<empty>,,171,51,CPPASTProblemDeclaration,,<empty>
377259,UNKNOWN,52,,},5,<empty>,,172,52,CPPASTProblemDeclaration,,<empty>
377260,UNKNOWN,53,,"TEST_METHOD(ApiSetConsoleInputModeImplEchoOnLineOff)
    {
        Log::Comment(L""Set ECHO on with LINE off. It's invalid, but it should get set anyway and return an error code."");",5,<empty>,,174,53,CPPASTProblemDeclaration,,<empty>
377261,UNKNOWN,54,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,177,54,CPPASTProblemDeclaration,,<empty>
377262,UNKNOWN,55,,"Log::Comment(L""Setting ECHO without LINE should return an invalid argument code."");",9,<empty>,,178,55,CPPASTProblemDeclaration,,<empty>
377263,UNKNOWN,56,,"Log::Comment(L""Input mode should be set anyway despite FAILED return code."");",9,<empty>,,179,56,CPPASTProblemDeclaration,,<empty>
377264,UNKNOWN,57,,"VerifySetConsoleInputModeImpl(E_INVALIDARG, ENABLE_ECHO_INPUT);",9,<empty>,,180,57,CPPASTProblemDeclaration,,<empty>
377265,UNKNOWN,58,,},5,<empty>,,181,58,CPPASTProblemDeclaration,,<empty>
377266,UNKNOWN,59,,"TEST_METHOD(ApiSetConsoleInputModeExtendedFlagBehaviors)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,183,59,CPPASTProblemDeclaration,,<empty>
377267,UNKNOWN,60,,"Log::Comment(L""Verify that we can set various extended flags even without the ENABLE_EXTENDED_FLAGS flag."");",9,<empty>,,186,60,CPPASTProblemDeclaration,,<empty>
377268,UNKNOWN,61,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,187,61,CPPASTProblemDeclaration,,<empty>
377269,UNKNOWN,62,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_INSERT_MODE);",9,<empty>,,188,62,CPPASTProblemDeclaration,,<empty>
377270,UNKNOWN,63,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,189,63,CPPASTProblemDeclaration,,<empty>
377271,UNKNOWN,64,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_QUICK_EDIT_MODE);",9,<empty>,,190,64,CPPASTProblemDeclaration,,<empty>
377272,UNKNOWN,65,,PrepVerifySetConsoleInputModeImpl(0);,9,<empty>,,191,65,CPPASTProblemDeclaration,,<empty>
377273,UNKNOWN,66,,"VerifySetConsoleInputModeImpl(S_OK, ENABLE_AUTO_POSITION);",9,<empty>,,192,66,CPPASTProblemDeclaration,,<empty>
377274,UNKNOWN,67,,"Log::Comment(L""Verify that we cannot unset various extended flags without the ENABLE_EXTENDED_FLAGS flag."");",9,<empty>,,194,67,CPPASTProblemDeclaration,,<empty>
377275,UNKNOWN,68,,PrepVerifySetConsoleInputModeImpl(ENABLE_INSERT_MODE | ENABLE_QUICK_EDIT_MODE | ENABLE_AUTO_POSITION);,9,<empty>,,195,68,CPPASTProblemDeclaration,,<empty>
377292,UNKNOWN,73,,"VERIFY_ARE_EQUAL(S_OK, hr);",9,<empty>,,199,73,CPPASTProblemDeclaration,,<empty>
377293,UNKNOWN,74,,"VERIFY_ARE_EQUAL(true, !!gci.GetInsertMode());",9,<empty>,,200,74,CPPASTProblemDeclaration,,<empty>
377294,UNKNOWN,75,,"VERIFY_ARE_EQUAL(true, WI_IsFlagSet(gci.Flags, CONSOLE_QUICK_EDIT_MODE));",9,<empty>,,201,75,CPPASTProblemDeclaration,,<empty>
377295,UNKNOWN,76,,"VERIFY_ARE_EQUAL(true, WI_IsFlagSet(gci.Flags, CONSOLE_AUTO_POSITION));",9,<empty>,,202,76,CPPASTProblemDeclaration,,<empty>
377296,UNKNOWN,77,,},5,<empty>,,203,77,CPPASTProblemDeclaration,,<empty>
377297,UNKNOWN,78,,"TEST_METHOD(ApiSetConsoleInputModeImplPSReadlineScenario)
    {
        Log::Comment(L""Set Powershell PSReadline expected modes."");",5,<empty>,,205,78,CPPASTProblemDeclaration,,<empty>
377298,UNKNOWN,79,,PrepVerifySetConsoleInputModeImpl(0x1F7);,9,<empty>,,208,79,CPPASTProblemDeclaration,,<empty>
377299,UNKNOWN,80,,"Log::Comment(L""Should return an invalid argument code because ECHO is set without LINE."");",9,<empty>,,209,80,CPPASTProblemDeclaration,,<empty>
377300,UNKNOWN,81,,"Log::Comment(L""Input mode should be set anyway despite FAILED return code."");",9,<empty>,,210,81,CPPASTProblemDeclaration,,<empty>
377301,UNKNOWN,82,,"VerifySetConsoleInputModeImpl(E_INVALIDARG, 0x1E4);",9,<empty>,,211,82,CPPASTProblemDeclaration,,<empty>
377302,UNKNOWN,83,,},5,<empty>,,212,83,CPPASTProblemDeclaration,,<empty>
377303,UNKNOWN,84,,"TEST_METHOD(ApiGetConsoleTitleA)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,214,84,CPPASTProblemDeclaration,,<empty>
377304,UNKNOWN,85,,"gci.SetTitle(L""Test window title."");",9,<empty>,,219,85,CPPASTProblemDeclaration,,<empty>
377327,UNKNOWN,94,,"VERIFY_SUCCEEDED(_pApiRoutines->GetConsoleTitleAImpl(std::span<char>(pszTitle, ARRAYSIZE(pszTitle)), cchWritten, cchNeeded));",9,<empty>,,225,94,CPPASTProblemDeclaration,,<empty>
377328,UNKNOWN,95,,"VERIFY_ARE_NOT_EQUAL(0u, cchWritten);",9,<empty>,,227,95,CPPASTProblemDeclaration,,<empty>
377329,UNKNOWN,96,,"VERIFY_ARE_EQUAL(gci.GetTitle().length() + 1, cchWritten);",9,<empty>,,229,96,CPPASTProblemDeclaration,,<empty>
377330,UNKNOWN,97,,"VERIFY_ARE_EQUAL(gci.GetTitle().length(), cchNeeded);",9,<empty>,,230,97,CPPASTProblemDeclaration,,<empty>
377331,UNKNOWN,98,,VERIFY_ARE_EQUAL(std::string_view{ pszExpected,9,<empty>,,231,98,CPPASTProblemDeclaration,,<empty>
377332,UNKNOWN,99,,},56,<empty>,,231,99,CPPASTProblemDeclaration,,<empty>
377333,UNKNOWN,100,,", std::string_view{ pszTitle }",57,<empty>,,231,100,CPPASTProblemDeclaration,,<empty>
377334,UNKNOWN,101,,);,87,<empty>,,231,101,CPPASTProblemDeclaration,,<empty>
377335,UNKNOWN,102,,},5,<empty>,,232,102,CPPASTProblemDeclaration,,<empty>
377336,UNKNOWN,103,,"TEST_METHOD(ApiGetConsoleTitleW)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,234,103,CPPASTProblemDeclaration,,<empty>
377337,UNKNOWN,104,,"gci.SetTitle(L""Test window title."");",9,<empty>,,237,104,CPPASTProblemDeclaration,,<empty>
377349,UNKNOWN,111,,"VERIFY_SUCCEEDED(_pApiRoutines->GetConsoleTitleWImpl(std::span<wchar_t>(pwszTitle, ARRAYSIZE(pwszTitle)), cchWritten, cchNeeded));",9,<empty>,,242,111,CPPASTProblemDeclaration,,<empty>
377350,UNKNOWN,112,,"VERIFY_ARE_NOT_EQUAL(0u, cchWritten);",9,<empty>,,244,112,CPPASTProblemDeclaration,,<empty>
377358,UNKNOWN,115,,"VERIFY_ARE_EQUAL(title.length(), cchWritten);",9,<empty>,,249,115,CPPASTProblemDeclaration,,<empty>
377359,UNKNOWN,116,,"VERIFY_ARE_EQUAL(title.length(), cchNeeded);",9,<empty>,,250,116,CPPASTProblemDeclaration,,<empty>
377360,UNKNOWN,117,,"VERIFY_ARE_EQUAL(WEX::Common::String(title.data(), gsl::narrow_cast<int>(title.size())), WEX::Common::String(pwszTitle));",9,<empty>,,251,117,CPPASTProblemDeclaration,,<empty>
377361,UNKNOWN,118,,},5,<empty>,,252,118,CPPASTProblemDeclaration,,<empty>
377362,UNKNOWN,119,,"TEST_METHOD(ApiGetConsoleOriginalTitleA)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,254,119,CPPASTProblemDeclaration,,<empty>
377363,UNKNOWN,120,,"gci.SetOriginalTitle(L""Test original window title."");",9,<empty>,,257,120,CPPASTProblemDeclaration,,<empty>
377406,UNKNOWN,128,,"VERIFY_WIN32_BOOL_SUCCEEDED(WideCharToMultiByte(gci.OutputCP,
                                                        0,
                                                        originalTitle.data(),
                                                        gsl::narrow_cast<int>(originalTitle.size()),
                                                        pszExpected.get(),
                                                        iBytesNeeded,
                                                        nullptr,
                                                        nullptr));",9,<empty>,,273,128,CPPASTProblemDeclaration,,<empty>
377407,UNKNOWN,129,,pszExpected[iBytesNeeded] = '\0';,9,<empty>,,283,129,CPPASTProblemDeclaration,,<empty>
377419,UNKNOWN,136,,"VERIFY_SUCCEEDED(_pApiRoutines->GetConsoleOriginalTitleAImpl(std::span<char>(pszTitle, ARRAYSIZE(pszTitle)), cchWritten, cchNeeded));",9,<empty>,,288,136,CPPASTProblemDeclaration,,<empty>
377420,UNKNOWN,137,,"VERIFY_ARE_NOT_EQUAL(0u, cchWritten);",9,<empty>,,290,137,CPPASTProblemDeclaration,,<empty>
377421,UNKNOWN,138,,"VERIFY_ARE_EQUAL(gci.GetOriginalTitle().length() + 1, cchWritten);",9,<empty>,,292,138,CPPASTProblemDeclaration,,<empty>
377422,UNKNOWN,139,,"VERIFY_ARE_EQUAL(gci.GetOriginalTitle().length(), cchNeeded);",9,<empty>,,293,139,CPPASTProblemDeclaration,,<empty>
377423,UNKNOWN,140,,"VERIFY_ARE_EQUAL(WEX::Common::String(pszExpected.get()), WEX::Common::String(pszTitle));",9,<empty>,,294,140,CPPASTProblemDeclaration,,<empty>
377424,UNKNOWN,141,,},5,<empty>,,295,141,CPPASTProblemDeclaration,,<empty>
377425,UNKNOWN,142,,"TEST_METHOD(ApiGetConsoleOriginalTitleW)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,297,142,CPPASTProblemDeclaration,,<empty>
377426,UNKNOWN,143,,"gci.SetOriginalTitle(L""Test original window title."");",9,<empty>,,300,143,CPPASTProblemDeclaration,,<empty>
377438,UNKNOWN,150,,"VERIFY_SUCCEEDED(_pApiRoutines->GetConsoleOriginalTitleWImpl(std::span<wchar_t>(pwszTitle, ARRAYSIZE(pwszTitle)), cchWritten, cchNeeded));",9,<empty>,,305,150,CPPASTProblemDeclaration,,<empty>
377439,UNKNOWN,151,,"VERIFY_ARE_NOT_EQUAL(0u, cchWritten);",9,<empty>,,307,151,CPPASTProblemDeclaration,,<empty>
377447,UNKNOWN,154,,"VERIFY_ARE_EQUAL(originalTitle.length(), cchWritten);",9,<empty>,,311,154,CPPASTProblemDeclaration,,<empty>
377448,UNKNOWN,155,,"VERIFY_ARE_EQUAL(originalTitle.length(), cchNeeded);",9,<empty>,,312,155,CPPASTProblemDeclaration,,<empty>
377449,UNKNOWN,156,,"VERIFY_ARE_EQUAL(WEX::Common::String(originalTitle.data(), gsl::narrow_cast<int>(originalTitle.size())), WEX::Common::String(pwszTitle));",9,<empty>,,313,156,CPPASTProblemDeclaration,,<empty>
377450,UNKNOWN,157,,},5,<empty>,,314,157,CPPASTProblemDeclaration,,<empty>
377485,UNKNOWN,159,,"TEST_METHOD(ApiWriteConsoleA)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:fInduceWait"", L""{false, true}"")
            TEST_METHOD_PROPERTY(L""Data:dwCodePage"", L""{437, 932, 65001}"")
            TEST_METHOD_PROPERTY(L""Data:dwIncrement"", L""{0, 1, 2}"")
        END_TEST_METHOD_PROPERTIES();",5,<empty>,,322,159,CPPASTProblemDeclaration,,<empty>
377487,UNKNOWN,161,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""fInduceWait"", fInduceWait), L""Get whether or not we should exercise this function off a wait state."");",9,<empty>,,331,161,CPPASTProblemDeclaration,,<empty>
377489,UNKNOWN,163,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""dwCodePage"", dwCodePage), L""Get the codepage for the test. Check a single byte, a double byte, and UTF-8."");",9,<empty>,,334,163,CPPASTProblemDeclaration,,<empty>
377491,UNKNOWN,165,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""dwIncrement"", dwIncrement),
                         L""Get how many chars we should feed in at a time. This validates lead bytes and bytes held across calls."");",9,<empty>,,337,165,CPPASTProblemDeclaration,,<empty>
377508,UNKNOWN,170,,gci.LockConsole();,9,<empty>,,343,170,CPPASTProblemDeclaration,,<empty>
377517,UNKNOWN,173,,gci.OutputCP = dwCodePage;,9,<empty>,,347,173,CPPASTProblemDeclaration,,<empty>
377520,UNKNOWN,176,,"switch (dwCodePage)
        {
        case CP_USA: // US English ANSI
            pszTestText = ""Test Text"";
            break;
        case CP_JAPANESE: // Japanese Shift-JIS
            pszTestText = ""J\x82\xa0\x82\xa2"";
            break;
        case CP_UTF8:
            pszTestText = ""Test \xe3\x82\xab Text"";
            break;
        default:
            VERIFY_FAIL(L""Test is not ready for this codepage."");
            return;
        }",9,<empty>,,351,176,CPPASTProblemDeclaration,,<empty>
377535,UNKNOWN,181,,for (size_t i = 0;,9,<empty>,,374,181,CPPASTProblemDeclaration,,<empty>
377536,UNKNOWN,182,,i < cchTestText;,28,<empty>,,374,182,CPPASTProblemDeclaration,,<empty>
377537,UNKNOWN,183,,"i += cchIncrement)
        {
            Log::Comment(WEX::Common::String().Format(L""Iteration %d of loop with increment %d"", i, cchIncrement));
            if (fInduceWait)
            {
                Log::Comment(L""Blocking global output state to induce waits."");
                s_AdjustOutputWait(true);
            }

            size_t cchRead = 0;
            std::unique_ptr<IWaitRoutine> waiter;

            // The increment is either the specified length or the remaining text in the string (if that is smaller).
            const auto cchWriteLength = std::min(cchIncrement, cchTestText - i);

            // Run the test method
            const auto hr = _pApiRoutines->WriteConsoleAImpl(si, { pszTestText + i, cchWriteLength }, cchRead, false, waiter);

            VERIFY_ARE_EQUAL(S_OK, hr, L""Successful result code from writing."");
            if (!fInduceWait)
            {
                VERIFY_IS_NULL(waiter.get(), L""We should have no waiter for this case."");
           ...",45,<empty>,,374,183,CPPASTProblemDeclaration,,<empty>
377538,UNKNOWN,184,,},5,<empty>,,419,184,CPPASTProblemDeclaration,,<empty>
377539,UNKNOWN,185,,"TEST_METHOD(ApiWriteConsoleW)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:fInduceWait"", L""{false, true}"")
        END_TEST_METHOD_PROPERTIES();",5,<empty>,,421,185,CPPASTProblemDeclaration,,<empty>
377541,UNKNOWN,187,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""fInduceWait"", fInduceWait), L""Get whether or not we should exercise this function off a wait state."");",9,<empty>,,428,187,CPPASTProblemDeclaration,,<empty>
377558,UNKNOWN,192,,gci.LockConsole();,9,<empty>,,433,192,CPPASTProblemDeclaration,,<empty>
377570,UNKNOWN,197,,"if (fInduceWait)
        {
            Log::Comment(L""Blocking global output state to induce waits."");
            s_AdjustOutputWait(true);
        }",9,<empty>,,438,197,CPPASTProblemDeclaration,,<empty>
377588,UNKNOWN,203,,"VERIFY_ARE_EQUAL(S_OK, hr, L""Successful result code from writing."");",9,<empty>,,448,203,CPPASTProblemDeclaration,,<empty>
377589,UNKNOWN,204,,"if (!fInduceWait)
        {
            VERIFY_IS_NULL(waiter.get(), L""We should have no waiter for this case."");
            VERIFY_ARE_EQUAL(testText.size(), cchRead, L""We should have the same character count back as 'written' that we gave in."");
        }",9,<empty>,,449,204,CPPASTProblemDeclaration,,<empty>
377590,UNKNOWN,205,,"else
        {
            VERIFY_IS_NOT_NULL(waiter.get(), L""We should have a waiter for this case."");
            // The cchRead is irrelevant at this point as it's not going to be returned until we're off the wait.

            Log::Comment(L""Unblocking global output state so the wait can be serviced."");
            s_AdjustOutputWait(false);
            Log::Comment(L""Dispatching the wait."");
            auto Status = STATUS_SUCCESS;
            size_t dwNumBytes = 0;
            DWORD dwControlKeyState = 0; // unused but matches the pattern for read.
            void* pOutputData = nullptr; // unused for writes but used for read.
            const BOOL bNotifyResult = waiter->Notify(WaitTerminationReason::NoReason, TRUE, &Status, &dwNumBytes, &dwControlKeyState, &pOutputData);

            VERIFY_IS_TRUE(!!bNotifyResult, L""Wait completion on notify should be successful."");
            VERIFY_ARE_EQUAL(STATUS_SUCCESS, Status, L""We should have a successful return code to pass to ...",9,<empty>,,454,205,CPPASTProblemDeclaration,,<empty>
377591,UNKNOWN,206,,},5,<empty>,,474,206,CPPASTProblemDeclaration,,<empty>
377937,UNKNOWN,209,,"TEST_METHOD(ApiScrollConsoleScreenBufferW)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""data:setMargins"", L""{false, true}"")
            TEST_METHOD_PROPERTY(L""data:checkClipped"", L""{false, true}"")
        END_TEST_METHOD_PROPERTIES();",5,<empty>,,595,209,CPPASTProblemDeclaration,,<empty>
377939,UNKNOWN,211,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""setMargins"", setMargins), L""Get whether or not we should set the DECSTBM margins."");",9,<empty>,,603,211,CPPASTProblemDeclaration,,<empty>
377941,UNKNOWN,213,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""checkClipped"", checkClipped), L""Get whether or not we should check all the options using a clipping rectangle."");",9,<empty>,,605,213,CPPASTProblemDeclaration,,<empty>
377958,UNKNOWN,218,,"si.GetTextBuffer().ResizeTraditional({ 5, 5 }",9,<empty>,,610,218,CPPASTProblemDeclaration,,<empty>
377959,UNKNOWN,219,,);,54,<empty>,,610,219,CPPASTProblemDeclaration,,<empty>
377966,UNKNOWN,222,,"stateMachine.ProcessString(setMargins ? L""\x1b[2;4r"" : L""\x1b[r"");",9,<empty>,,615,222,CPPASTProblemDeclaration,,<empty>
377975,UNKNOWN,225,,gci.LockConsole();,9,<empty>,,619,225,CPPASTProblemDeclaration,,<empty>
377985,UNKNOWN,229,,fill.Char.UnicodeChar = L'A';,9,<empty>,,623,229,CPPASTProblemDeclaration,,<empty>
377986,UNKNOWN,230,,fill.Attributes = FOREGROUND_RED;,9,<empty>,,624,230,CPPASTProblemDeclaration,,<empty>
378020,UNKNOWN,241,,"Log::Comment(L""Fill screen with green Zs. Scroll all up by two, backfilling with red As. Confirm every cell."");",9,<empty>,,636,241,CPPASTProblemDeclaration,,<empty>
378021,UNKNOWN,242,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,637,242,CPPASTProblemDeclaration,,<empty>
378023,UNKNOWN,244,,background.Char.UnicodeChar = L'Z';,9,<empty>,,640,244,CPPASTProblemDeclaration,,<empty>
378024,UNKNOWN,245,,background.Attributes = FOREGROUND_GREEN;,9,<empty>,,641,245,CPPASTProblemDeclaration,,<empty>
378025,UNKNOWN,246,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,643,246,CPPASTProblemDeclaration,,<empty>
378026,UNKNOWN,247,,);,76,<empty>,,643,247,CPPASTProblemDeclaration,,<empty>
378027,UNKNOWN,248,,"if (checkClipped)
        {
            // for scrolling up and down, we're going to clip to only modify the left half of the buffer
            auto clipRectDimensions = bufferSize.Dimensions();
            clipRectDimensions.width /= 2;

            clipViewport = Viewport::FromDimensions({ 0, 0 }, clipRectDimensions);
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,645,248,CPPASTProblemDeclaration,,<empty>
378028,UNKNOWN,249,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,656,249,CPPASTProblemDeclaration,,<empty>
378029,UNKNOWN,250,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,657,250,CPPASTProblemDeclaration,,<empty>
378030,UNKNOWN,251,,"Log::Comment(L""Fill screen with green Zs. Scroll all down by two, backfilling with red As. Confirm every cell."");",9,<empty>,,659,251,CPPASTProblemDeclaration,,<empty>
378031,UNKNOWN,252,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,661,252,CPPASTProblemDeclaration,,<empty>
378032,UNKNOWN,253,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,662,253,CPPASTProblemDeclaration,,<empty>
378033,UNKNOWN,254,,);,76,<empty>,,662,254,CPPASTProblemDeclaration,,<empty>
378040,UNKNOWN,257,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,666,257,CPPASTProblemDeclaration,,<empty>
378041,UNKNOWN,258,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,667,258,CPPASTProblemDeclaration,,<empty>
378042,UNKNOWN,259,,"if (checkClipped)
        {
            // for scrolling left and right, we're going to clip to only modify the top half of the buffer
            auto clipRectDimensions = bufferSize.Dimensions();
            clipRectDimensions.height /= 2;

            clipViewport = Viewport::FromDimensions({ 0, 0 }, clipRectDimensions);
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,669,259,CPPASTProblemDeclaration,,<empty>
378043,UNKNOWN,260,,"Log::Comment(L""Fill screen with green Zs. Scroll all left by two, backfilling with red As. Confirm every cell."");",9,<empty>,,679,260,CPPASTProblemDeclaration,,<empty>
378044,UNKNOWN,261,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,681,261,CPPASTProblemDeclaration,,<empty>
378045,UNKNOWN,262,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,682,262,CPPASTProblemDeclaration,,<empty>
378046,UNKNOWN,263,,);,76,<empty>,,682,263,CPPASTProblemDeclaration,,<empty>
378054,UNKNOWN,266,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,686,266,CPPASTProblemDeclaration,,<empty>
378055,UNKNOWN,267,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,687,267,CPPASTProblemDeclaration,,<empty>
378056,UNKNOWN,268,,"Log::Comment(L""Fill screen with green Zs. Scroll all right by two, backfilling with red As. Confirm every cell."");",9,<empty>,,689,268,CPPASTProblemDeclaration,,<empty>
378057,UNKNOWN,269,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,691,269,CPPASTProblemDeclaration,,<empty>
378058,UNKNOWN,270,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,692,270,CPPASTProblemDeclaration,,<empty>
378059,UNKNOWN,271,,);,76,<empty>,,692,271,CPPASTProblemDeclaration,,<empty>
378066,UNKNOWN,274,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,696,274,CPPASTProblemDeclaration,,<empty>
378067,UNKNOWN,275,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,697,275,CPPASTProblemDeclaration,,<empty>
378068,UNKNOWN,276,,"Log::Comment(L""Fill screen with green Zs. Move everything down and right by two, backfilling with red As. Confirm every cell."");",9,<empty>,,699,276,CPPASTProblemDeclaration,,<empty>
378069,UNKNOWN,277,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,701,277,CPPASTProblemDeclaration,,<empty>
378070,UNKNOWN,278,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,702,278,CPPASTProblemDeclaration,,<empty>
378071,UNKNOWN,279,,);,76,<empty>,,702,279,CPPASTProblemDeclaration,,<empty>
378078,UNKNOWN,282,,"if (checkClipped)
        {
            // Clip out the left most and top most column.
            clipViewport = Viewport::FromDimensions({ 1, 1 }, { 4, 4 });
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,706,282,CPPASTProblemDeclaration,,<empty>
378079,UNKNOWN,283,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,712,283,CPPASTProblemDeclaration,,<empty>
378080,UNKNOWN,284,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,713,284,CPPASTProblemDeclaration,,<empty>
378081,UNKNOWN,285,,"Log::Comment(L""Fill screen with green Zs. Move everything up and left by two, backfilling with red As. Confirm every cell."");",9,<empty>,,715,285,CPPASTProblemDeclaration,,<empty>
378082,UNKNOWN,286,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,717,286,CPPASTProblemDeclaration,,<empty>
378083,UNKNOWN,287,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,718,287,CPPASTProblemDeclaration,,<empty>
378084,UNKNOWN,288,,);,76,<empty>,,718,288,CPPASTProblemDeclaration,,<empty>
378093,UNKNOWN,291,,"if (checkClipped)
        {
            // Clip out the bottom most and right most column
            clipViewport = Viewport::FromDimensions({ 0, 0 }, { 4, 4 });
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,722,291,CPPASTProblemDeclaration,,<empty>
378094,UNKNOWN,292,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,728,292,CPPASTProblemDeclaration,,<empty>
378095,UNKNOWN,293,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,729,293,CPPASTProblemDeclaration,,<empty>
378096,UNKNOWN,294,,"Log::Comment(L""Scroll everything completely off the screen."");",9,<empty>,,731,294,CPPASTProblemDeclaration,,<empty>
378097,UNKNOWN,295,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,733,295,CPPASTProblemDeclaration,,<empty>
378098,UNKNOWN,296,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,734,296,CPPASTProblemDeclaration,,<empty>
378099,UNKNOWN,297,,);,76,<empty>,,734,297,CPPASTProblemDeclaration,,<empty>
378107,UNKNOWN,300,,"if (checkClipped)
        {
            // for scrolling up and down, we're going to clip to only modify the left half of the buffer
            auto clipRectDimensions = bufferSize.Dimensions();
            clipRectDimensions.width /= 2;

            clipViewport = Viewport::FromDimensions({ 0, 0 }, clipRectDimensions);
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,738,300,CPPASTProblemDeclaration,,<empty>
378108,UNKNOWN,301,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,747,301,CPPASTProblemDeclaration,,<empty>
378109,UNKNOWN,302,,"ValidateScreen(si, background, fill, destination, clipViewport);",9,<empty>,,748,302,CPPASTProblemDeclaration,,<empty>
378110,UNKNOWN,303,,"Log::Comment(L""Scroll everything completely off the screen but use a null fill and confirm it is replaced with default attribute spaces."");",9,<empty>,,750,303,CPPASTProblemDeclaration,,<empty>
378111,UNKNOWN,304,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,752,304,CPPASTProblemDeclaration,,<empty>
378112,UNKNOWN,305,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,753,305,CPPASTProblemDeclaration,,<empty>
378113,UNKNOWN,306,,);,76,<empty>,,753,306,CPPASTProblemDeclaration,,<empty>
378127,UNKNOWN,311,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, nullFill.Char.UnicodeChar, nullFill.Attributes));",9,<empty>,,759,311,CPPASTProblemDeclaration,,<empty>
378129,UNKNOWN,313,,fillExpected.Char.UnicodeChar = UNICODE_SPACE;,9,<empty>,,762,313,CPPASTProblemDeclaration,,<empty>
378130,UNKNOWN,314,,fillExpected.Attributes = si.GetAttributes().GetLegacyAttributes();,9,<empty>,,763,314,CPPASTProblemDeclaration,,<empty>
378131,UNKNOWN,315,,"ValidateScreen(si, background, fillExpected, destination, clipViewport);",9,<empty>,,764,315,CPPASTProblemDeclaration,,<empty>
378132,UNKNOWN,316,,"if (checkClipped)
        {
            // If we're doing clipping here, we're going to clip the scrolled area (after Bs are filled onto field of Zs)
            // to only the 3rd and 4th columns of the pattern.
            clipViewport = Viewport::FromDimensions({ 2, 0 }, { 2, 5 });
            clipRectangle = clipViewport.value().ToInclusive();
        }",9,<empty>,,766,316,CPPASTProblemDeclaration,,<empty>
378133,UNKNOWN,317,,"Log::Comment(L""Scroll a small portion of the screen in an overlapping fashion."");",9,<empty>,,774,317,CPPASTProblemDeclaration,,<empty>
378134,UNKNOWN,318,,scroll.top = 1;,9,<empty>,,775,318,CPPASTProblemDeclaration,,<empty>
378135,UNKNOWN,319,,scroll.bottom = 2;,9,<empty>,,776,319,CPPASTProblemDeclaration,,<empty>
378136,UNKNOWN,320,,scroll.left = 1;,9,<empty>,,777,320,CPPASTProblemDeclaration,,<empty>
378137,UNKNOWN,321,,scroll.right = 2;,9,<empty>,,778,321,CPPASTProblemDeclaration,,<empty>
378138,UNKNOWN,322,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,780,322,CPPASTProblemDeclaration,,<empty>
378139,UNKNOWN,323,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,781,323,CPPASTProblemDeclaration,,<empty>
378140,UNKNOWN,324,,);,76,<empty>,,781,324,CPPASTProblemDeclaration,,<empty>
378142,UNKNOWN,326,,scrollRect.Char.UnicodeChar = L'B';,9,<empty>,,792,326,CPPASTProblemDeclaration,,<empty>
378143,UNKNOWN,327,,scrollRect.Attributes = FOREGROUND_BLUE;,9,<empty>,,793,327,CPPASTProblemDeclaration,,<empty>
378144,UNKNOWN,328,,"si.GetActiveBuffer().WriteRect(OutputCellIterator(scrollRect), Viewport::FromInclusive(scroll));",9,<empty>,,794,328,CPPASTProblemDeclaration,,<empty>
378159,UNKNOWN,331,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,807,331,CPPASTProblemDeclaration,,<empty>
378160,UNKNOWN,332,,"ValidateComplexScreen(si, background, fill, scrollRect, Viewport::FromInclusive(scroll), destination, clipViewport);",9,<empty>,,823,332,CPPASTProblemDeclaration,,<empty>
378161,UNKNOWN,333,,"Log::Comment(L""Scroll a small portion of the screen in a non-overlapping fashion."");",9,<empty>,,825,333,CPPASTProblemDeclaration,,<empty>
378162,UNKNOWN,334,,si.GetActiveBuffer().ClearTextData();,9,<empty>,,827,334,CPPASTProblemDeclaration,,<empty>
378163,UNKNOWN,335,,"si.GetActiveBuffer().Write(OutputCellIterator(background), { 0, 0 }",9,<empty>,,828,335,CPPASTProblemDeclaration,,<empty>
378164,UNKNOWN,336,,);,76,<empty>,,828,336,CPPASTProblemDeclaration,,<empty>
378165,UNKNOWN,337,,"si.GetActiveBuffer().WriteRect(OutputCellIterator(scrollRect), Viewport::FromInclusive(scroll));",9,<empty>,,838,337,CPPASTProblemDeclaration,,<empty>
378180,UNKNOWN,340,,"VERIFY_SUCCEEDED(_pApiRoutines->ScrollConsoleScreenBufferWImpl(si, scroll, destination, clipRectangle, fill.Char.UnicodeChar, fill.Attributes));",9,<empty>,,851,340,CPPASTProblemDeclaration,,<empty>
378181,UNKNOWN,341,,"ValidateComplexScreen(si, background, fill, scrollRect, Viewport::FromInclusive(scroll), destination, clipViewport);",9,<empty>,,867,341,CPPASTProblemDeclaration,,<empty>
378182,UNKNOWN,342,,},5,<empty>,,868,342,CPPASTProblemDeclaration,,<empty>
378183,UNKNOWN,343,,};,1,<empty>,,869,343,CPPASTProblemDeclaration,,<empty>
378236,UNKNOWN,6,,"TEST_METHOD_SETUP(MethodSetup)
    {
        m_state->FillTextBuffer();",5,<empty>,,57,6,CPPASTProblemDeclaration,,<empty>
378237,UNKNOWN,7,,return true;,9,<empty>,,60,7,CPPASTProblemDeclaration,,<empty>
378238,UNKNOWN,8,,},5,<empty>,,61,8,CPPASTProblemDeclaration,,<empty>
378239,UNKNOWN,9,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        return true;",5,<empty>,,63,9,CPPASTProblemDeclaration,,<empty>
378240,UNKNOWN,10,,},5,<empty>,,66,10,CPPASTProblemDeclaration,,<empty>
378329,UNKNOWN,14,,"TEST_METHOD(TestRetrieveFromBuffer)
    {
        // NOTE: This test requires innate knowledge of how the common buffer text is emitted in order to test all cases
        // Please see CommonState.hpp for information on the buffer state per row, the row contents, etc.

        std::vector<til::inclusive_rect> selection;",5,<empty>,,91,14,CPPASTProblemDeclaration,,<empty>
378336,UNKNOWN,17,,"VERIFY_ARE_EQUAL((til::CoordType)wcslen(text[0].data()), selection[0].right - selection[0].left + 1);",9,<empty>,,102,17,CPPASTProblemDeclaration,,<empty>
378346,UNKNOWN,20,,tempPtr += text[0].size();,9,<empty>,,106,20,CPPASTProblemDeclaration,,<empty>
378347,UNKNOWN,21,,tempPtr -= 2;,9,<empty>,,107,21,CPPASTProblemDeclaration,,<empty>
378348,UNKNOWN,22,,"VERIFY_ARE_EQUAL(String(tempPtr), String(L""\r\n""));",9,<empty>,,108,22,CPPASTProblemDeclaration,,<empty>
378349,UNKNOWN,23,,tempPtr = text[0].data();,9,<empty>,,111,23,CPPASTProblemDeclaration,,<empty>
378350,UNKNOWN,24,,tempPtr += selection[0].right - selection[0].left - 2;,9,<empty>,,112,24,CPPASTProblemDeclaration,,<empty>
378351,UNKNOWN,25,,tempPtr++;,9,<empty>,,113,25,CPPASTProblemDeclaration,,<empty>
378352,UNKNOWN,26,,"VERIFY_IS_NULL(wcsrchr(tempPtr, L' '));",9,<empty>,,114,26,CPPASTProblemDeclaration,,<empty>
378353,UNKNOWN,27,,tempPtr = text[3].data();,9,<empty>,,117,27,CPPASTProblemDeclaration,,<empty>
378354,UNKNOWN,28,,tempPtr += text[3].size();,9,<empty>,,118,28,CPPASTProblemDeclaration,,<empty>
378355,UNKNOWN,29,,tempPtr -= 2;,9,<empty>,,119,29,CPPASTProblemDeclaration,,<empty>
378356,UNKNOWN,30,,"VERIFY_ARE_NOT_EQUAL(String(tempPtr), String(L""\r\n""));",9,<empty>,,120,30,CPPASTProblemDeclaration,,<empty>
378357,UNKNOWN,31,,},5,<empty>,,121,31,CPPASTProblemDeclaration,,<empty>
378358,UNKNOWN,32,,"TEST_METHOD(TestRetrieveLineSelectionFromBuffer)
    {
        // NOTE: This test requires innate knowledge of how the common buffer text is emitted in order to test all cases
        // Please see CommonState.hpp for information on the buffer state per row, the row contents, etc.

        std::vector<til::inclusive_rect> selection;",5,<empty>,,124,32,CPPASTProblemDeclaration,,<empty>
378374,UNKNOWN,37,,tempPtr += text[2].size();,9,<empty>,,135,37,CPPASTProblemDeclaration,,<empty>
378375,UNKNOWN,38,,tempPtr -= 2;,9,<empty>,,136,38,CPPASTProblemDeclaration,,<empty>
378376,UNKNOWN,39,,"VERIFY_ARE_EQUAL(String(tempPtr), String(L""\r\n""));",9,<empty>,,137,39,CPPASTProblemDeclaration,,<empty>
378377,UNKNOWN,40,,tempPtr = text[2].data();,9,<empty>,,140,40,CPPASTProblemDeclaration,,<empty>
378378,UNKNOWN,41,,"VERIFY_IS_NULL(wcsrchr(tempPtr, L' '));",9,<empty>,,141,41,CPPASTProblemDeclaration,,<empty>
378379,UNKNOWN,42,,tempPtr = text[1].data();,9,<empty>,,145,42,CPPASTProblemDeclaration,,<empty>
378380,UNKNOWN,43,,tempPtr += text[1].size();,9,<empty>,,146,43,CPPASTProblemDeclaration,,<empty>
378381,UNKNOWN,44,,tempPtr -= 2;,9,<empty>,,147,44,CPPASTProblemDeclaration,,<empty>
378382,UNKNOWN,45,,"VERIFY_ARE_NOT_EQUAL(String(tempPtr), String(L""\r\n""));",9,<empty>,,148,45,CPPASTProblemDeclaration,,<empty>
378383,UNKNOWN,46,,tempPtr = text[1].data();,9,<empty>,,151,46,CPPASTProblemDeclaration,,<empty>
378391,UNKNOWN,50,,},5,<empty>,,154,50,CPPASTProblemDeclaration,,<empty>
378392,UNKNOWN,51,,"TEST_METHOD(CanConvertText)
    {
        static constexpr std::wstring_view input{ L""HeLlO WoRlD"" };",5,<empty>,,156,51,CPPASTProblemDeclaration,,<empty>
378415,UNKNOWN,1,,WORD,42,<empty>,,161,1,CPPASTTypeId,,<empty>
378440,UNKNOWN,61,,"for (auto wch : input)
        {
            const auto state = OneCoreSafeVkKeyScanW(wch);
            const auto vk = LOBYTE(state);
            const auto sc = static_cast<WORD>(OneCoreSafeMapVirtualKeyW(vk, MAPVK_VK_TO_VSC));
            const auto shift = WI_IsFlagSet(state, 0x100);
            auto event = SynthesizeKeyEvent(true, 1, vk, sc, wch, shift ? SHIFT_PRESSED : 0);

            if (shift)
            {
                expectedEvents.push_back(shiftDown);
            }

            expectedEvents.push_back(event);
            event.Event.KeyEvent.bKeyDown = FALSE;
            expectedEvents.push_back(event);

            if (shift)
            {
                expectedEvents.push_back(shiftUp);
            }
        }",9,<empty>,,167,61,CPPASTProblemDeclaration,,<empty>
378441,UNKNOWN,62,,"VERIFY_ARE_EQUAL(expectedEvents.size(), events.size());",9,<empty>,,190,62,CPPASTProblemDeclaration,,<empty>
378442,UNKNOWN,63,,for (size_t i = 0;,9,<empty>,,192,63,CPPASTProblemDeclaration,,<empty>
378443,UNKNOWN,64,,i < events.size();,28,<empty>,,192,64,CPPASTProblemDeclaration,,<empty>
378444,UNKNOWN,65,,"++i)
        {
            VERIFY_ARE_EQUAL(expectedEvents[i], events[i]);
        }",47,<empty>,,192,65,CPPASTProblemDeclaration,,<empty>
378445,UNKNOWN,66,,},5,<empty>,,196,66,CPPASTProblemDeclaration,,<empty>
378446,UNKNOWN,67,,"TEST_METHOD(CanConvertCharsRequiringAltGr)
    {
        const std::wstring wstr = L""\x20ac"";",5,<empty>,,198,67,CPPASTProblemDeclaration,,<empty>
378463,UNKNOWN,1,,WORD,50,<empty>,,204,1,CPPASTTypeId,,<empty>
378467,UNKNOWN,74,,"if (keyState == -1 || HIBYTE(keyState) == 0 /* no modifiers required */)
        {
            Log::Comment(L""This test only works on keyboard layouts where the Euro symbol exists and requires AltGr."");
            Log::Result(WEX::Logging::TestResults::Skipped);
            return;
        }",9,<empty>,,206,74,CPPASTProblemDeclaration,,<empty>
378487,UNKNOWN,78,,"expectedEvents.push_back(SynthesizeKeyEvent(true, 1, VK_MENU, altScanCode, L'\0', (ENHANCED_KEY | LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED)));",9,<empty>,,222,78,CPPASTProblemDeclaration,,<empty>
378488,UNKNOWN,79,,"expectedEvents.push_back(SynthesizeKeyEvent(true, 1, virtualKeyCode, virtualScanCode, wstr[0], (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED)));",9,<empty>,,223,79,CPPASTProblemDeclaration,,<empty>
378489,UNKNOWN,80,,"expectedEvents.push_back(SynthesizeKeyEvent(false, 1, virtualKeyCode, virtualScanCode, wstr[0], (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED)));",9,<empty>,,224,80,CPPASTProblemDeclaration,,<empty>
378490,UNKNOWN,81,,"expectedEvents.push_back(SynthesizeKeyEvent(false, 1, VK_MENU, altScanCode, L'\0', ENHANCED_KEY));",9,<empty>,,225,81,CPPASTProblemDeclaration,,<empty>
378491,UNKNOWN,82,,"VERIFY_ARE_EQUAL(expectedEvents.size(), events.size());",9,<empty>,,227,82,CPPASTProblemDeclaration,,<empty>
378492,UNKNOWN,83,,for (size_t i = 0;,9,<empty>,,229,83,CPPASTProblemDeclaration,,<empty>
378493,UNKNOWN,84,,i < events.size();,28,<empty>,,229,84,CPPASTProblemDeclaration,,<empty>
378494,UNKNOWN,85,,"++i)
        {
            VERIFY_ARE_EQUAL(expectedEvents[i], events[i]);
        }",47,<empty>,,229,85,CPPASTProblemDeclaration,,<empty>
378495,UNKNOWN,86,,},5,<empty>,,233,86,CPPASTProblemDeclaration,,<empty>
378496,UNKNOWN,87,,"TEST_METHOD(CanConvertCharsOutsideKeyboardLayout)
    {
        const std::wstring wstr = L""\xbc"";",5,<empty>,,235,87,CPPASTProblemDeclaration,,<empty>
378507,UNKNOWN,91,,),39,<empty>,,239,91,CPPASTProblemDeclaration,,<empty>
378508,UNKNOWN,92,,.getConsoleInformation().OutputCP = outputCodepage;,40,<empty>,,239,92,CPPASTProblemDeclaration,,<empty>
378528,UNKNOWN,96,,"if constexpr (Feature_UseNumpadEventsForClipboardInput::IsEnabled())
        {
            // Inside Windows, where numpad events are enabled, this generated numpad events.
            // should be converted to:
            // 1. left alt keydown
            // 2. 1st numpad keydown
            // 3. 1st numpad keyup
            // 4. 2nd numpad keydown
            // 5. 2nd numpad keyup
            // 6. left alt keyup
            expectedEvents.push_back(SynthesizeKeyEvent(true, 1, VK_MENU, altScanCode, L'\0', LEFT_ALT_PRESSED));
            expectedEvents.push_back(SynthesizeKeyEvent(true, 1, 0x66, 0x4D, L'\0', LEFT_ALT_PRESSED));
            expectedEvents.push_back(SynthesizeKeyEvent(false, 1, 0x66, 0x4D, L'\0', LEFT_ALT_PRESSED));
            expectedEvents.push_back(SynthesizeKeyEvent(true, 1, 0x63, 0x51, L'\0', LEFT_ALT_PRESSED));
            expectedEvents.push_back(SynthesizeKeyEvent(false, 1, 0x63, 0x51, L'\0', LEFT_ALT_PRESSED));
            expectedEvents.push_back(Synt...",9,<empty>,,244,96,CPPASTProblemDeclaration,,<empty>
378529,UNKNOWN,97,,"else
        {
            // Outside Windows, without numpad events, we just emit the key with a nonzero UnicodeChar
            expectedEvents.push_back(SynthesizeKeyEvent(true, 1, 0, 0, wstr[0], 0));
            expectedEvents.push_back(SynthesizeKeyEvent(false, 1, 0, 0, wstr[0], 0));
        }",9,<empty>,,261,97,CPPASTProblemDeclaration,,<empty>
378530,UNKNOWN,98,,"VERIFY_ARE_EQUAL(expectedEvents.size(), events.size());",9,<empty>,,268,98,CPPASTProblemDeclaration,,<empty>
378531,UNKNOWN,99,,for (size_t i = 0;,9,<empty>,,270,99,CPPASTProblemDeclaration,,<empty>
378532,UNKNOWN,100,,i < events.size();,28,<empty>,,270,100,CPPASTProblemDeclaration,,<empty>
378533,UNKNOWN,101,,"++i)
        {
            VERIFY_ARE_EQUAL(expectedEvents[i], events[i]);
        }",47,<empty>,,270,101,CPPASTProblemDeclaration,,<empty>
378534,UNKNOWN,102,,},5,<empty>,,274,102,CPPASTProblemDeclaration,,<empty>
378535,UNKNOWN,103,,};,1,<empty>,,275,103,CPPASTProblemDeclaration,,<empty>
378699,UNKNOWN,9,,"TEST_METHOD(AmbiguousCache)
    {
        // Set up a detector with fallback.
        CodepointWidthDetector widthDetector;",5,<empty>,,65,9,CPPASTProblemDeclaration,,<empty>
378700,UNKNOWN,10,,"widthDetector.SetFallbackMethod(std::bind(&FallbackMethod, std::placeholders::_1));",9,<empty>,,69,10,CPPASTProblemDeclaration,,<empty>
378701,UNKNOWN,11,,"VERIFY_ARE_EQUAL(0u, widthDetector._fallbackCache.size());",9,<empty>,,72,11,CPPASTProblemDeclaration,,<empty>
378702,UNKNOWN,12,,widthDetector.IsWide(ambiguous);,9,<empty>,,75,12,CPPASTProblemDeclaration,,<empty>
378703,UNKNOWN,13,,"VERIFY_ARE_EQUAL(1u, widthDetector._fallbackCache.size());",9,<empty>,,78,13,CPPASTProblemDeclaration,,<empty>
378713,UNKNOWN,16,,"VERIFY_ARE_EQUAL(ambiguous[0], it->first);",9,<empty>,,82,16,CPPASTProblemDeclaration,,<empty>
378714,UNKNOWN,17,,"VERIFY_ARE_EQUAL(FallbackMethod(ambiguous) ? 2u : 1u, it->second);",9,<empty>,,83,17,CPPASTProblemDeclaration,,<empty>
378715,UNKNOWN,18,,widthDetector.NotifyFontChanged();,9,<empty>,,86,18,CPPASTProblemDeclaration,,<empty>
378716,UNKNOWN,19,,"VERIFY_ARE_EQUAL(0u, widthDetector._fallbackCache.size());",9,<empty>,,87,19,CPPASTProblemDeclaration,,<empty>
378717,UNKNOWN,20,,},5,<empty>,,88,20,CPPASTProblemDeclaration,,<empty>
378718,UNKNOWN,21,,};,1,<empty>,,89,21,CPPASTProblemDeclaration,,<empty>
378940,UNKNOWN,2,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,106,2,CPPASTProblemDeclaration,,<empty>
378948,UNKNOWN,5,,delete g.pRender;,9,<empty>,,111,5,CPPASTProblemDeclaration,,<empty>
378949,UNKNOWN,6,,"VERIFY_ARE_EQUAL(0u, expectedOutput.size(), L""Tests should drain all the output they push into the expected output buffer."");",9,<empty>,,113,6,CPPASTProblemDeclaration,,<empty>
378950,UNKNOWN,7,,return true;,9,<empty>,,115,7,CPPASTProblemDeclaration,,<empty>
378951,UNKNOWN,8,,},5,<empty>,,116,8,CPPASTProblemDeclaration,,<empty>
378959,UNKNOWN,16,,"private:
    bool _writeCallback(const char* const pch, const size_t cch);",1,<empty>,,126,16,CPPASTProblemDeclaration,,<empty>
378966,UNKNOWN,20,,};,1,<empty>,,131,20,CPPASTProblemDeclaration,,<empty>
378999,UNKNOWN,1,,size_t,5,<empty>,,140,1,CPPASTTypeId,,<empty>
379862,UNKNOWN,-1,,),34,<empty>,,373,2,CPPASTProblemStatement,,<empty>
379866,UNKNOWN,-1,,),86,<empty>,,374,4,CPPASTProblemStatement,,<empty>
379870,UNKNOWN,-1,,),58,<empty>,,375,6,CPPASTProblemStatement,,<empty>
379872,UNKNOWN,-1,,),32,<empty>,,376,8,CPPASTProblemStatement,,<empty>
381694,UNKNOWN,-1,,"TEST_METHOD(TestUnicodeRasterFontCellMungeOnRead)
    {
        const size_t cchTestSize = 20;",5,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
381698,UNKNOWN,-1,,for (size_t i = 0;,9,<empty>,,42,6,CPPASTProblemDeclaration,,<empty>
381699,UNKNOWN,-1,,i < ARRAYSIZE(rgci);,28,<empty>,,42,7,CPPASTProblemDeclaration,,<empty>
381700,UNKNOWN,-1,,"i++)
        {
            rgci[i].Char.UnicodeChar = wch;
            rgci[i].Attributes = wAttrTest;
            wch++;
        }",49,<empty>,,42,8,CPPASTProblemDeclaration,,<empty>
381702,UNKNOWN,-1,,for (size_t i = 5;,9,<empty>,,52,10,CPPASTProblemDeclaration,,<empty>
381703,UNKNOWN,-1,,i < 15;,28,<empty>,,52,11,CPPASTProblemDeclaration,,<empty>
381704,UNKNOWN,-1,,"i += 2)
        {
            rgci[i].Char.UnicodeChar = wchDouble;
            rgci[i].Attributes = COMMON_LVB_LEADING_BYTE | wAttrTest;
            rgci[i + 1].Char.UnicodeChar = wchDouble;
            rgci[i + 1].Attributes = COMMON_LVB_TRAILING_BYTE | wAttrTest;
            wchDouble++;
        }",36,<empty>,,52,12,CPPASTProblemDeclaration,,<empty>
381712,UNKNOWN,-1,,"if (VERIFY_ARE_EQUAL(ARRAYSIZE(rgci), dwResult, L""Ensure the length claims that we are the same before and after.""))
        {
            Log::Comment(L""Ensure the letters are now as expected."");
            // the expected behavior is to reduce the LEADING/TRAILING double copies into a single copy
            WCHAR wchExpected[]{ 'a', 'b', 'c', 'd', 'e', 0x30AB, 0x30AC, 0x30AD, 0x30AE, 0x30AF, 'p', 'q', 'r', 's', 't' };
            for (size_t i = 0; i < ARRAYSIZE(wchExpected); i++)
            {
                VERIFY_ARE_EQUAL(wchExpected[i], rgci[i].Char.UnicodeChar);

                // and simultaneously strip the LEADING/TRAILING attributes
                // no other attributes should be affected (test against color flags we set).
                VERIFY_ARE_EQUAL(wAttrTest, rgci[i].Attributes);
            }

            // and all extra portions of the array should be zeroed.
            for (auto i = ARRAYSIZE(wchExpected); i < ARRAYSIZE(rgci); i++)
            {
        ...",9,<empty>,,68,15,CPPASTProblemDeclaration,,<empty>
381736,UNKNOWN,2,,},5,<empty>,,89,2,CPPASTProblemDeclaration,,<empty>
381737,UNKNOWN,3,,};,1,<empty>,,90,3,CPPASTProblemDeclaration,,<empty>
381760,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        // Get a fresh storage for each test since it's stored internally as a persistent static for the lifetime of the session.
        CommandHistory::s_ClearHistoryListStorage();",5,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
381761,UNKNOWN,3,,return true;,9,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
381762,UNKNOWN,4,,},5,<empty>,,39,4,CPPASTProblemDeclaration,,<empty>
381763,UNKNOWN,5,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        return true;",5,<empty>,,41,5,CPPASTProblemDeclaration,,<empty>
381764,UNKNOWN,6,,},5,<empty>,,44,6,CPPASTProblemDeclaration,,<empty>
381765,UNKNOWN,7,,"TEST_METHOD(AllocateAndFreeOneApp)
    {
        const std::wstring app{ L""testapp1.exe"" };",5,<empty>,,46,7,CPPASTProblemDeclaration,,<empty>
381781,UNKNOWN,13,,"VERIFY_IS_TRUE(WI_IsFlagSet(history->Flags, CommandHistory::CLE_ALLOCATED));",9,<empty>,,54,13,CPPASTProblemDeclaration,,<empty>
381782,UNKNOWN,14,,"VERIFY_ARE_EQUAL(1ul, CommandHistory::s_historyLists.size());",9,<empty>,,55,14,CPPASTProblemDeclaration,,<empty>
381784,UNKNOWN,16,,"VERIFY_IS_TRUE(WI_IsFlagClear(history->Flags, CommandHistory::CLE_ALLOCATED), L""Shouldn't actually be gone, just deallocated."");",9,<empty>,,59,16,CPPASTProblemDeclaration,,<empty>
381785,UNKNOWN,17,,"VERIFY_ARE_EQUAL(1ul, CommandHistory::s_historyLists.size());",9,<empty>,,60,17,CPPASTProblemDeclaration,,<empty>
381786,UNKNOWN,18,,},5,<empty>,,61,18,CPPASTProblemDeclaration,,<empty>
381787,UNKNOWN,19,,"TEST_METHOD(AllocateTooManyApps)
    {
        VERIFY_IS_LESS_THAN(s_NumberOfBuffers, _manyApps.size(), L""Make sure we declared too many apps for the necessary size."");",5,<empty>,,63,19,CPPASTProblemDeclaration,,<empty>
381788,UNKNOWN,20,,for (size_t i = 0;,9,<empty>,,67,20,CPPASTProblemDeclaration,,<empty>
381789,UNKNOWN,21,,i < _manyApps.size();,28,<empty>,,67,21,CPPASTProblemDeclaration,,<empty>
381790,UNKNOWN,22,,"i++)
        {
            CommandHistory::s_Allocate(_manyApps[i], _MakeHandle(i));
        }",50,<empty>,,67,22,CPPASTProblemDeclaration,,<empty>
381791,UNKNOWN,23,,"VERIFY_ARE_EQUAL(s_NumberOfBuffers, CommandHistory::s_CountOfHistories(), L""We should have maxed out histories."");",9,<empty>,,72,23,CPPASTProblemDeclaration,,<empty>
381792,UNKNOWN,24,,"Log::Comment(L""Since they were all in use, the last app shouldn't have made an entry"");",9,<empty>,,74,24,CPPASTProblemDeclaration,,<empty>
381793,UNKNOWN,25,,for (size_t i = 0;,9,<empty>,,75,25,CPPASTProblemDeclaration,,<empty>
381794,UNKNOWN,26,,i < _manyApps.size() - 1;,28,<empty>,,75,26,CPPASTProblemDeclaration,,<empty>
381795,UNKNOWN,27,,"i++)
        {
            VERIFY_IS_NOT_NULL(CommandHistory::s_FindByExe(_manyApps[i]));
        }",54,<empty>,,75,27,CPPASTProblemDeclaration,,<empty>
381796,UNKNOWN,28,,"VERIFY_IS_NULL(CommandHistory::s_FindByExe(_manyApps[4]), L""Verify we can't find the last app."");",9,<empty>,,80,28,CPPASTProblemDeclaration,,<empty>
381797,UNKNOWN,29,,},5,<empty>,,81,29,CPPASTProblemDeclaration,,<empty>
381798,UNKNOWN,30,,"TEST_METHOD(EnsureHistoryRestoredAfterClientLeavesAndRejoins)
    {
        const auto h = _MakeHandle(0);",5,<empty>,,83,30,CPPASTProblemDeclaration,,<empty>
381799,UNKNOWN,31,,"Log::Comment(L""Allocate a history and fill it with items."");",9,<empty>,,86,31,CPPASTProblemDeclaration,,<empty>
381812,UNKNOWN,35,,for (size_t i = 0;,9,<empty>,,90,35,CPPASTProblemDeclaration,,<empty>
381813,UNKNOWN,36,,i < s_BufferSize;,28,<empty>,,90,36,CPPASTProblemDeclaration,,<empty>
381814,UNKNOWN,37,,"i++)
        {
            VERIFY_SUCCEEDED(history->Add(_manyHistoryItems[i], false));
        }",46,<empty>,,90,37,CPPASTProblemDeclaration,,<empty>
381815,UNKNOWN,38,,"VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands(), L""Ensure that it is filled."");",9,<empty>,,95,38,CPPASTProblemDeclaration,,<empty>
381816,UNKNOWN,39,,"Log::Comment(L""Free it and recreate it with the same name."");",9,<empty>,,97,39,CPPASTProblemDeclaration,,<empty>
381818,UNKNOWN,41,,"history = CommandHistory::s_Allocate(_manyApps[0], _MakeHandle(14));",9,<empty>,,101,41,CPPASTProblemDeclaration,,<empty>
381820,UNKNOWN,43,,"VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands(), L""Ensure that we still have full commands after freeing and reallocating, same app name, different handle ID"");",9,<empty>,,104,43,CPPASTProblemDeclaration,,<empty>
381821,UNKNOWN,44,,},5,<empty>,,105,44,CPPASTProblemDeclaration,,<empty>
381822,UNKNOWN,45,,"TEST_METHOD(TooManyAppsDoesNotTakeList)
    {
        Log::Comment(L""Fill up the number of buffers and each history list to the max."");",5,<empty>,,107,45,CPPASTProblemDeclaration,,<empty>
381823,UNKNOWN,46,,for (size_t i = 0;,9,<empty>,,110,46,CPPASTProblemDeclaration,,<empty>
381824,UNKNOWN,47,,i < s_NumberOfBuffers;,28,<empty>,,110,47,CPPASTProblemDeclaration,,<empty>
381825,UNKNOWN,48,,"i++)
        {
            auto history = CommandHistory::s_Allocate(_manyApps[i], _MakeHandle(i));
            VERIFY_IS_NOT_NULL(history);
            for (size_t j = 0; j < s_BufferSize; j++)
            {
                VERIFY_SUCCEEDED(history->Add(_manyHistoryItems[j], false));
            }
            VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands());
        }",51,<empty>,,110,48,CPPASTProblemDeclaration,,<empty>
381826,UNKNOWN,49,,"VERIFY_ARE_EQUAL(s_NumberOfBuffers, CommandHistory::s_historyLists.size());",9,<empty>,,120,49,CPPASTProblemDeclaration,,<empty>
381827,UNKNOWN,50,,"Log::Comment(L""Add one more app and it should re-use a buffer but it should be clear."");",9,<empty>,,122,50,CPPASTProblemDeclaration,,<empty>
381841,UNKNOWN,54,,"VERIFY_ARE_EQUAL(s_NumberOfBuffers, CommandHistory::s_historyLists.size());",9,<empty>,,125,54,CPPASTProblemDeclaration,,<empty>
381842,UNKNOWN,55,,},5,<empty>,,126,55,CPPASTProblemDeclaration,,<empty>
381843,UNKNOWN,56,,"TEST_METHOD(AppNamesMatchInsensitive)
    {
        auto history = CommandHistory::s_Allocate(L""testApp"", _MakeHandle(777));",5,<empty>,,128,56,CPPASTProblemDeclaration,,<empty>
381845,UNKNOWN,58,,"VERIFY_IS_TRUE(history->IsAppNameMatch(L""TEsTaPP""));",9,<empty>,,132,58,CPPASTProblemDeclaration,,<empty>
381846,UNKNOWN,59,,},5,<empty>,,133,59,CPPASTProblemDeclaration,,<empty>
381847,UNKNOWN,60,,"TEST_METHOD(ReallocUp)
    {
        Log::Comment(L""Allocate and fill with too many items."");",5,<empty>,,135,60,CPPASTProblemDeclaration,,<empty>
381861,UNKNOWN,64,,for (size_t j = 0;,9,<empty>,,140,64,CPPASTProblemDeclaration,,<empty>
381862,UNKNOWN,65,,j < _manyHistoryItems.size();,28,<empty>,,140,65,CPPASTProblemDeclaration,,<empty>
381863,UNKNOWN,66,,"j++)
        {
            VERIFY_SUCCEEDED(history->Add(_manyHistoryItems[j], false));
        }",58,<empty>,,140,66,CPPASTProblemDeclaration,,<empty>
381864,UNKNOWN,67,,"VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands());",9,<empty>,,144,67,CPPASTProblemDeclaration,,<empty>
381865,UNKNOWN,68,,"Log::Comment(L""Retrieve items/order."");",9,<empty>,,146,68,CPPASTProblemDeclaration,,<empty>
381867,UNKNOWN,70,,for (CommandHistory::Index i = 0;,9,<empty>,,148,70,CPPASTProblemDeclaration,,<empty>
381868,UNKNOWN,71,,i < history->GetNumberOfCommands();,43,<empty>,,148,71,CPPASTProblemDeclaration,,<empty>
381869,UNKNOWN,72,,"i++)
        {
            commandsStored.emplace_back(history->GetNth(i));
        }",79,<empty>,,148,72,CPPASTProblemDeclaration,,<empty>
381870,UNKNOWN,73,,"Log::Comment(L""Reallocate larger and ensure items and order are preserved."");",9,<empty>,,153,73,CPPASTProblemDeclaration,,<empty>
381871,UNKNOWN,74,,history->Realloc((CommandHistory::Index)_manyHistoryItems.size());,9,<empty>,,154,74,CPPASTProblemDeclaration,,<empty>
381872,UNKNOWN,75,,"VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands());",9,<empty>,,155,75,CPPASTProblemDeclaration,,<empty>
381873,UNKNOWN,76,,for (CommandHistory::Index i = 0;,9,<empty>,,156,76,CPPASTProblemDeclaration,,<empty>
381874,UNKNOWN,77,,i < (CommandHistory::Index)commandsStored.size();,43,<empty>,,156,77,CPPASTProblemDeclaration,,<empty>
381875,UNKNOWN,78,,"i++)
        {
            VERIFY_ARE_EQUAL(String(commandsStored[i].data()), String(history->GetNth(i).data()));
        }",93,<empty>,,156,78,CPPASTProblemDeclaration,,<empty>
381876,UNKNOWN,79,,"Log::Comment(L""Fill up the larger buffer and ensure they fit this time."");",9,<empty>,,161,79,CPPASTProblemDeclaration,,<empty>
381877,UNKNOWN,80,,for (size_t j = 0;,9,<empty>,,162,80,CPPASTProblemDeclaration,,<empty>
381878,UNKNOWN,81,,j < _manyHistoryItems.size();,28,<empty>,,162,81,CPPASTProblemDeclaration,,<empty>
381879,UNKNOWN,82,,"j++)
        {
            VERIFY_SUCCEEDED(history->Add(_manyHistoryItems[j], false));
        }",58,<empty>,,162,82,CPPASTProblemDeclaration,,<empty>
381880,UNKNOWN,83,,"VERIFY_ARE_EQUAL((CommandHistory::Index)_manyHistoryItems.size(), history->GetNumberOfCommands());",9,<empty>,,166,83,CPPASTProblemDeclaration,,<empty>
381881,UNKNOWN,84,,},5,<empty>,,167,84,CPPASTProblemDeclaration,,<empty>
381882,UNKNOWN,85,,"TEST_METHOD(ReallocDown)
    {
        Log::Comment(L""Allocate and fill with just enough items."");",5,<empty>,,169,85,CPPASTProblemDeclaration,,<empty>
381896,UNKNOWN,89,,for (size_t j = 0;,9,<empty>,,174,89,CPPASTProblemDeclaration,,<empty>
381897,UNKNOWN,90,,j < s_BufferSize;,28,<empty>,,174,90,CPPASTProblemDeclaration,,<empty>
381898,UNKNOWN,91,,"j++)
        {
            VERIFY_SUCCEEDED(history->Add(_manyHistoryItems[j], false));
        }",46,<empty>,,174,91,CPPASTProblemDeclaration,,<empty>
381899,UNKNOWN,92,,"VERIFY_ARE_EQUAL(s_BufferSize, history->GetNumberOfCommands());",9,<empty>,,178,92,CPPASTProblemDeclaration,,<empty>
381900,UNKNOWN,93,,"Log::Comment(L""Retrieve items/order."");",9,<empty>,,180,93,CPPASTProblemDeclaration,,<empty>
381902,UNKNOWN,95,,for (CommandHistory::Index i = 0;,9,<empty>,,182,95,CPPASTProblemDeclaration,,<empty>
381903,UNKNOWN,96,,i < history->GetNumberOfCommands();,43,<empty>,,182,96,CPPASTProblemDeclaration,,<empty>
381904,UNKNOWN,97,,"i++)
        {
            commandsStored.emplace_back(history->GetNth(i));
        }",79,<empty>,,182,97,CPPASTProblemDeclaration,,<empty>
381905,UNKNOWN,98,,"Log::Comment(L""Reallocate smaller and ensure items and order are preserved. Items at end of list should be trimmed."");",9,<empty>,,187,98,CPPASTProblemDeclaration,,<empty>
381906,UNKNOWN,99,,history->Realloc(5);,9,<empty>,,188,99,CPPASTProblemDeclaration,,<empty>
381907,UNKNOWN,100,,for (CommandHistory::Index i = 0;,9,<empty>,,189,100,CPPASTProblemDeclaration,,<empty>
381908,UNKNOWN,101,,i < 5;,43,<empty>,,189,101,CPPASTProblemDeclaration,,<empty>
381909,UNKNOWN,102,,"i++)
        {
            VERIFY_ARE_EQUAL(String(commandsStored[i].data()), String(history->GetNth(i).data()));
        }",50,<empty>,,189,102,CPPASTProblemDeclaration,,<empty>
381910,UNKNOWN,103,,},5,<empty>,,193,103,CPPASTProblemDeclaration,,<empty>
381911,UNKNOWN,104,,"TEST_METHOD(AddSequentialDuplicates)
    {
        auto history = CommandHistory::s_Allocate(_manyApps[0], _MakeHandle(0));",5,<empty>,,195,104,CPPASTProblemDeclaration,,<empty>
381913,UNKNOWN,106,,"VERIFY_SUCCEEDED(history->Add(L""dir"", false));",9,<empty>,,201,106,CPPASTProblemDeclaration,,<empty>
381914,UNKNOWN,107,,"VERIFY_SUCCEEDED(history->Add(L""dir"", false));",9,<empty>,,202,107,CPPASTProblemDeclaration,,<empty>
381915,UNKNOWN,108,,"VERIFY_ARE_EQUAL(1, history->GetNumberOfCommands());",9,<empty>,,204,108,CPPASTProblemDeclaration,,<empty>
381916,UNKNOWN,109,,},5,<empty>,,205,109,CPPASTProblemDeclaration,,<empty>
381917,UNKNOWN,110,,"TEST_METHOD(AddSequentialNoDuplicates)
    {
        auto history = CommandHistory::s_Allocate(_manyApps[0], _MakeHandle(0));",5,<empty>,,207,110,CPPASTProblemDeclaration,,<empty>
381919,UNKNOWN,112,,"VERIFY_SUCCEEDED(history->Add(L""dir"", true));",9,<empty>,,213,112,CPPASTProblemDeclaration,,<empty>
381920,UNKNOWN,113,,"VERIFY_SUCCEEDED(history->Add(L""dir"", true));",9,<empty>,,214,113,CPPASTProblemDeclaration,,<empty>
381921,UNKNOWN,114,,"VERIFY_ARE_EQUAL(1, history->GetNumberOfCommands());",9,<empty>,,216,114,CPPASTProblemDeclaration,,<empty>
381922,UNKNOWN,115,,},5,<empty>,,217,115,CPPASTProblemDeclaration,,<empty>
381923,UNKNOWN,116,,"TEST_METHOD(AddNonsequentialDuplicates)
    {
        auto history = CommandHistory::s_Allocate(_manyApps[0], _MakeHandle(0));",5,<empty>,,219,116,CPPASTProblemDeclaration,,<empty>
381925,UNKNOWN,118,,"VERIFY_SUCCEEDED(history->Add(L""dir"", false));",9,<empty>,,225,118,CPPASTProblemDeclaration,,<empty>
381926,UNKNOWN,119,,"VERIFY_SUCCEEDED(history->Add(L""cd"", false));",9,<empty>,,226,119,CPPASTProblemDeclaration,,<empty>
381927,UNKNOWN,120,,"VERIFY_SUCCEEDED(history->Add(L""dir"", false));",9,<empty>,,227,120,CPPASTProblemDeclaration,,<empty>
381928,UNKNOWN,121,,"VERIFY_ARE_EQUAL(3, history->GetNumberOfCommands());",9,<empty>,,229,121,CPPASTProblemDeclaration,,<empty>
381929,UNKNOWN,122,,},5,<empty>,,230,122,CPPASTProblemDeclaration,,<empty>
381930,UNKNOWN,123,,"TEST_METHOD(AddNonsequentialNoDuplicates)
    {
        auto history = CommandHistory::s_Allocate(_manyApps[0], _MakeHandle(0));",5,<empty>,,232,123,CPPASTProblemDeclaration,,<empty>
381932,UNKNOWN,125,,"VERIFY_SUCCEEDED(history->Add(L""dir"", true));",9,<empty>,,238,125,CPPASTProblemDeclaration,,<empty>
381933,UNKNOWN,126,,"VERIFY_SUCCEEDED(history->Add(L""cd"", false));",9,<empty>,,239,126,CPPASTProblemDeclaration,,<empty>
381934,UNKNOWN,127,,"VERIFY_SUCCEEDED(history->Add(L""dir"", true));",9,<empty>,,240,127,CPPASTProblemDeclaration,,<empty>
381935,UNKNOWN,128,,"VERIFY_ARE_EQUAL(2, history->GetNumberOfCommands());",9,<empty>,,242,128,CPPASTProblemDeclaration,,<empty>
381936,UNKNOWN,129,,},5,<empty>,,243,129,CPPASTProblemDeclaration,,<empty>
381937,UNKNOWN,130,,"private:
    const std::array<std::wstring, 5> _manyApps = {
        L""foo.exe"",
        L""bar.exe"",
        L""baz.exe"",
        L""apple.exe"",
        L""banana.exe""
    };",1,<empty>,,245,130,CPPASTProblemDeclaration,,<empty>
381967,UNKNOWN,1,,HANDLE,33,<empty>,,274,1,CPPASTTypeId,,<empty>
381975,UNKNOWN,138,,};,1,<empty>,,276,138,CPPASTProblemDeclaration,,<empty>
382004,UNKNOWN,-1,,"TEST_METHOD(TestGetConsoleLangId)
    {
        using Microsoft::Console::Interactivity::ServiceLocator;",5,<empty>,,35,11,CPPASTProblemDeclaration,,<empty>
382005,UNKNOWN,-1,,"BEGIN_TEST_METHOD_PROPERTIES()
            // https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
            // The interesting ones for us are:
            // Japanese Shift JIS = 932
            // Chinese Simplified GB2312 = 936
            // Korean Unified Hangul = 949
            // Chinese Traditional Big5 = 950
            TEST_METHOD_PROPERTY(L""Data:uiStartupCP"", L""{437, 850, 932, 936, 949, 950}"")
            TEST_METHOD_PROPERTY(L""Data:uiOutputCP"", L""{437, 850, 932, 936, 949, 950}"")
        END_TEST_METHOD_PROPERTIES()

        // if ServiceLocator::LocateGlobals().uiWindowsCP = a CJK one
        // we should get SUCCESS and a matching result to our input
        // for any other ServiceLocator::LocateGlobals().uiWindowsCP we should get STATUS_NOT_SUPPORTED and do nothing with the langid.

        VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiStartupCP"", ServiceLocator::LocateGlobals().uiWindowsCP));",9,<empty>,,38,12,CPPASTProblemDeclaration,,<empty>
382007,UNKNOWN,-1,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiOutputCP"", outputCP));",9,<empty>,,56,14,CPPASTProblemDeclaration,,<empty>
382010,UNKNOWN,-1,,"if (s_uiOEMJapaneseCP == ServiceLocator::LocateGlobals().uiWindowsCP ||
            s_uiOEMSimplifiedChineseCP == ServiceLocator::LocateGlobals().uiWindowsCP ||
            s_uiOEMKoreanCP == ServiceLocator::LocateGlobals().uiWindowsCP ||
            s_uiOEMTraditionalChineseCP == ServiceLocator::LocateGlobals().uiWindowsCP)
        {
            VERIFY_ARE_EQUAL(STATUS_SUCCESS, status);

            LANGID langIdExpected;
            switch (outputCP)
            {
            case s_uiOEMJapaneseCP:
                langIdExpected = s_langIdJapanese;
                break;
            case s_uiOEMSimplifiedChineseCP:
                langIdExpected = s_langIdSimplifiedChinese;
                break;
            case s_uiOEMKoreanCP:
                langIdExpected = s_langIdKorean;
                break;
            case s_uiOEMTraditionalChineseCP:
                langIdExpected = s_langIdTraditionalChinese;
                break;
            default:
                langIdExpected ...",9,<empty>,,61,17,CPPASTProblemDeclaration,,<empty>
382011,UNKNOWN,-1,,"else
        {
            VERIFY_ARE_EQUAL(STATUS_NOT_SUPPORTED, status);
        }",9,<empty>,,90,18,CPPASTProblemDeclaration,,<empty>
382062,UNKNOWN,2,,},5,<empty>,,94,2,CPPASTProblemDeclaration,,<empty>
382063,UNKNOWN,3,,};,1,<empty>,,95,3,CPPASTProblemDeclaration,,<empty>
382097,UNKNOWN,2,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
382098,UNKNOWN,3,,"WI_ClearFlag(gci.Flags, CONSOLE_OUTPUT_SUSPENDED);",9,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
382099,UNKNOWN,4,,return true;,9,<empty>,,37,4,CPPASTProblemDeclaration,,<empty>
382100,UNKNOWN,5,,},5,<empty>,,38,5,CPPASTProblemDeclaration,,<empty>
382179,UNKNOWN,9,,"TEST_METHOD(CanGetNumberOfReadyEvents)
    {
        InputBuffer inputBuffer;",5,<empty>,,60,9,CPPASTProblemDeclaration,,<empty>
382190,UNKNOWN,12,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(record), 0u);",9,<empty>,,64,12,CPPASTProblemDeclaration,,<empty>
382191,UNKNOWN,13,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 1u);",9,<empty>,,65,13,CPPASTProblemDeclaration,,<empty>
382193,UNKNOWN,15,,record2.EventType = MENU_EVENT;,9,<empty>,,68,15,CPPASTProblemDeclaration,,<empty>
382194,UNKNOWN,16,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(record2), 0u);",9,<empty>,,69,16,CPPASTProblemDeclaration,,<empty>
382195,UNKNOWN,17,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 2u);",9,<empty>,,70,17,CPPASTProblemDeclaration,,<empty>
382196,UNKNOWN,18,,},5,<empty>,,71,18,CPPASTProblemDeclaration,,<empty>
382197,UNKNOWN,19,,"TEST_METHOD(CanInsertIntoInputBufferIndividually)
    {
        InputBuffer inputBuffer;",5,<empty>,,73,19,CPPASTProblemDeclaration,,<empty>
382198,UNKNOWN,20,,for (size_t i = 0;,9,<empty>,,76,20,CPPASTProblemDeclaration,,<empty>
382199,UNKNOWN,21,,i < RECORD_INSERT_COUNT;,28,<empty>,,76,21,CPPASTProblemDeclaration,,<empty>
382200,UNKNOWN,22,,"++i)
        {
            INPUT_RECORD record;
            record.EventType = MENU_EVENT;
            VERIFY_IS_GREATER_THAN(inputBuffer.Write(record), 0u);
            VERIFY_ARE_EQUAL(record, inputBuffer._storage.back());
        }",53,<empty>,,76,22,CPPASTProblemDeclaration,,<empty>
382201,UNKNOWN,23,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,83,23,CPPASTProblemDeclaration,,<empty>
382202,UNKNOWN,24,,},5,<empty>,,84,24,CPPASTProblemDeclaration,,<empty>
382203,UNKNOWN,25,,"TEST_METHOD(CanBulkInsertIntoInputBuffer)
    {
        InputBuffer inputBuffer;",5,<empty>,,86,25,CPPASTProblemDeclaration,,<empty>
382206,UNKNOWN,28,,record.EventType = MENU_EVENT;,9,<empty>,,91,28,CPPASTProblemDeclaration,,<empty>
382207,UNKNOWN,29,,for (size_t i = 0;,9,<empty>,,92,29,CPPASTProblemDeclaration,,<empty>
382208,UNKNOWN,30,,i < RECORD_INSERT_COUNT;,28,<empty>,,92,30,CPPASTProblemDeclaration,,<empty>
382209,UNKNOWN,31,,"++i)
        {
            events.push_back(record);
        }",53,<empty>,,92,31,CPPASTProblemDeclaration,,<empty>
382210,UNKNOWN,32,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(events), 0u);",9,<empty>,,96,32,CPPASTProblemDeclaration,,<empty>
382211,UNKNOWN,33,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,97,33,CPPASTProblemDeclaration,,<empty>
382212,UNKNOWN,34,,for (size_t i = 0;,9,<empty>,,99,34,CPPASTProblemDeclaration,,<empty>
382213,UNKNOWN,35,,i < RECORD_INSERT_COUNT;,28,<empty>,,99,35,CPPASTProblemDeclaration,,<empty>
382214,UNKNOWN,36,,"++i)
        {
            VERIFY_ARE_EQUAL(inputBuffer._storage[i], record);
        }",53,<empty>,,99,36,CPPASTProblemDeclaration,,<empty>
382215,UNKNOWN,37,,},5,<empty>,,103,37,CPPASTProblemDeclaration,,<empty>
382216,UNKNOWN,38,,"TEST_METHOD(InputBufferCoalescesMouseEvents)
    {
        InputBuffer inputBuffer;",5,<empty>,,105,38,CPPASTProblemDeclaration,,<empty>
382218,UNKNOWN,40,,mouseRecord.EventType = MOUSE_EVENT;,9,<empty>,,110,40,CPPASTProblemDeclaration,,<empty>
382219,UNKNOWN,41,,mouseRecord.Event.MouseEvent.dwEventFlags = MOUSE_MOVED;,9,<empty>,,111,41,CPPASTProblemDeclaration,,<empty>
382220,UNKNOWN,42,,for (size_t i = 0;,9,<empty>,,114,42,CPPASTProblemDeclaration,,<empty>
382221,UNKNOWN,43,,i < RECORD_INSERT_COUNT;,28,<empty>,,114,43,CPPASTProblemDeclaration,,<empty>
382222,UNKNOWN,44,,"++i)
        {
            mouseRecord.Event.MouseEvent.dwMousePosition.X = static_cast<SHORT>(i + 1);
            mouseRecord.Event.MouseEvent.dwMousePosition.Y = static_cast<SHORT>(i + 1) * 2;
            VERIFY_IS_GREATER_THAN(inputBuffer.Write(mouseRecord), 0u);
        }",53,<empty>,,114,44,CPPASTProblemDeclaration,,<empty>
382223,UNKNOWN,45,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 1u);",9,<empty>,,122,45,CPPASTProblemDeclaration,,<empty>
382237,UNKNOWN,48,,"VERIFY_ARE_EQUAL(pMouseEvent.dwMousePosition.X, static_cast<SHORT>(RECORD_INSERT_COUNT));",9,<empty>,,125,48,CPPASTProblemDeclaration,,<empty>
382238,UNKNOWN,49,,"VERIFY_ARE_EQUAL(pMouseEvent.dwMousePosition.Y, static_cast<SHORT>(RECORD_INSERT_COUNT * 2));",9,<empty>,,126,49,CPPASTProblemDeclaration,,<empty>
382240,UNKNOWN,51,,keyRecord.EventType = KEY_EVENT;,9,<empty>,,131,51,CPPASTProblemDeclaration,,<empty>
382241,UNKNOWN,52,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(keyRecord), 0u);",9,<empty>,,132,52,CPPASTProblemDeclaration,,<empty>
382242,UNKNOWN,53,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(mouseRecord), 0u);",9,<empty>,,133,53,CPPASTProblemDeclaration,,<empty>
382243,UNKNOWN,54,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 3u);",9,<empty>,,136,54,CPPASTProblemDeclaration,,<empty>
382244,UNKNOWN,55,,},5,<empty>,,137,55,CPPASTProblemDeclaration,,<empty>
382245,UNKNOWN,56,,"TEST_METHOD(InputBufferDoesNotCoalesceBulkMouseEvents)
    {
        Log::Comment(L""The input buffer should not coalesce mouse events if more than one event is sent at a time"");",5,<empty>,,139,56,CPPASTProblemDeclaration,,<empty>
382251,UNKNOWN,61,,for (size_t i = 0;,9,<empty>,,147,61,CPPASTProblemDeclaration,,<empty>
382252,UNKNOWN,62,,i < RECORD_INSERT_COUNT;,28,<empty>,,147,62,CPPASTProblemDeclaration,,<empty>
382253,UNKNOWN,63,,"++i)
        {
            mouseRecords[i].EventType = MOUSE_EVENT;
            mouseRecords[i].Event.MouseEvent.dwEventFlags = MOUSE_MOVED;
            events.push_back(mouseRecords[i]);
        }",53,<empty>,,147,63,CPPASTProblemDeclaration,,<empty>
382254,UNKNOWN,64,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(mouseRecords[0]), 0u);",9,<empty>,,154,64,CPPASTProblemDeclaration,,<empty>
382255,UNKNOWN,65,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(events), 0u);",9,<empty>,,156,65,CPPASTProblemDeclaration,,<empty>
382256,UNKNOWN,66,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT + 1);",9,<empty>,,158,66,CPPASTProblemDeclaration,,<empty>
382257,UNKNOWN,67,,"VERIFY_ARE_EQUAL(inputBuffer._storage.front(), mouseRecords[0]);",9,<empty>,,160,67,CPPASTProblemDeclaration,,<empty>
382258,UNKNOWN,68,,for (size_t i = 0;,9,<empty>,,161,68,CPPASTProblemDeclaration,,<empty>
382259,UNKNOWN,69,,i < RECORD_INSERT_COUNT;,28,<empty>,,161,69,CPPASTProblemDeclaration,,<empty>
382260,UNKNOWN,70,,"++i)
        {
            VERIFY_ARE_EQUAL(inputBuffer._storage[i + 1], mouseRecords[i]);
        }",53,<empty>,,161,70,CPPASTProblemDeclaration,,<empty>
382261,UNKNOWN,71,,},5,<empty>,,165,71,CPPASTProblemDeclaration,,<empty>
382262,UNKNOWN,72,,"TEST_METHOD(InputBufferCoalescesKeyEvents)
    {
        Log::Comment(L""The input buffer should coalesce identical key events if they are send one at a time"");",5,<empty>,,167,72,CPPASTProblemDeclaration,,<empty>
382274,UNKNOWN,76,,inputBuffer.Flush();,9,<empty>,,175,76,CPPASTProblemDeclaration,,<empty>
382275,UNKNOWN,77,,for (size_t i = 0;,9,<empty>,,176,77,CPPASTProblemDeclaration,,<empty>
382276,UNKNOWN,78,,i < RECORD_INSERT_COUNT;,28,<empty>,,176,78,CPPASTProblemDeclaration,,<empty>
382277,UNKNOWN,79,,"++i)
        {
            VERIFY_IS_GREATER_THAN(inputBuffer.Write(record), 0u);
        }",53,<empty>,,176,79,CPPASTProblemDeclaration,,<empty>
382278,UNKNOWN,80,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 1u);",9,<empty>,,182,80,CPPASTProblemDeclaration,,<empty>
382280,UNKNOWN,82,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents, 1, true, false, false, false));",9,<empty>,,187,82,CPPASTProblemDeclaration,,<empty>
382281,UNKNOWN,83,,VERIFY_IS_FALSE(outEvents.empty());,9,<empty>,,189,83,CPPASTProblemDeclaration,,<empty>
382293,UNKNOWN,86,,"VERIFY_ARE_EQUAL(pKeyEvent.wRepeatCount, RECORD_INSERT_COUNT);",9,<empty>,,191,86,CPPASTProblemDeclaration,,<empty>
382294,UNKNOWN,87,,},5,<empty>,,192,87,CPPASTProblemDeclaration,,<empty>
382295,UNKNOWN,88,,"TEST_METHOD(InputBufferDoesNotCoalesceBulkKeyEvents)
    {
        Log::Comment(L""The input buffer should not coalesce key events if more than one event is sent at a time"");",5,<empty>,,194,88,CPPASTProblemDeclaration,,<empty>
382301,UNKNOWN,93,,for (size_t i = 0;,9,<empty>,,202,93,CPPASTProblemDeclaration,,<empty>
382302,UNKNOWN,94,,i < RECORD_INSERT_COUNT;,28,<empty>,,202,94,CPPASTProblemDeclaration,,<empty>
382303,UNKNOWN,95,,"++i)
        {
            keyRecords[i] = MakeKeyEvent(true, 1, L'a', 0, L'a', 0);
            events.push_back(keyRecords[i]);
        }",53,<empty>,,202,95,CPPASTProblemDeclaration,,<empty>
382304,UNKNOWN,96,,inputBuffer.Flush();,9,<empty>,,207,96,CPPASTProblemDeclaration,,<empty>
382305,UNKNOWN,97,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(keyRecords[0]), 0u);",9,<empty>,,209,97,CPPASTProblemDeclaration,,<empty>
382306,UNKNOWN,98,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(events), 0u);",9,<empty>,,211,98,CPPASTProblemDeclaration,,<empty>
382307,UNKNOWN,99,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT + 1);",9,<empty>,,213,99,CPPASTProblemDeclaration,,<empty>
382308,UNKNOWN,100,,"VERIFY_ARE_EQUAL(inputBuffer._storage.front(), keyRecords[0]);",9,<empty>,,215,100,CPPASTProblemDeclaration,,<empty>
382309,UNKNOWN,101,,for (size_t i = 0;,9,<empty>,,216,101,CPPASTProblemDeclaration,,<empty>
382310,UNKNOWN,102,,i < RECORD_INSERT_COUNT;,28,<empty>,,216,102,CPPASTProblemDeclaration,,<empty>
382311,UNKNOWN,103,,"++i)
        {
            VERIFY_ARE_EQUAL(inputBuffer._storage[i + 1], keyRecords[i]);
        }",53,<empty>,,216,103,CPPASTProblemDeclaration,,<empty>
382312,UNKNOWN,104,,},5,<empty>,,220,104,CPPASTProblemDeclaration,,<empty>
382313,UNKNOWN,105,,"TEST_METHOD(InputBufferDoesNotCoalesceFullWidthChars)
    {
        InputBuffer inputBuffer;",5,<empty>,,222,105,CPPASTProblemDeclaration,,<empty>
382328,UNKNOWN,110,,inputBuffer.Flush();,9,<empty>,,229,110,CPPASTProblemDeclaration,,<empty>
382329,UNKNOWN,111,,for (size_t i = 0;,9,<empty>,,230,111,CPPASTProblemDeclaration,,<empty>
382330,UNKNOWN,112,,i < RECORD_INSERT_COUNT;,28,<empty>,,230,112,CPPASTProblemDeclaration,,<empty>
382331,UNKNOWN,113,,"++i)
        {
            VERIFY_IS_GREATER_THAN(inputBuffer.Write(record), 0u);
            VERIFY_ARE_EQUAL(inputBuffer._storage.back(), record);
        }",53,<empty>,,230,113,CPPASTProblemDeclaration,,<empty>
382332,UNKNOWN,114,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,237,114,CPPASTProblemDeclaration,,<empty>
382333,UNKNOWN,115,,},5,<empty>,,238,115,CPPASTProblemDeclaration,,<empty>
382334,UNKNOWN,116,,"TEST_METHOD(CanFlushAllOutput)
    {
        InputBuffer inputBuffer;",5,<empty>,,240,116,CPPASTProblemDeclaration,,<empty>
382337,UNKNOWN,119,,record.EventType = MENU_EVENT;,9,<empty>,,247,119,CPPASTProblemDeclaration,,<empty>
382338,UNKNOWN,120,,for (size_t i = 0;,9,<empty>,,248,120,CPPASTProblemDeclaration,,<empty>
382339,UNKNOWN,121,,i < RECORD_INSERT_COUNT;,28,<empty>,,248,121,CPPASTProblemDeclaration,,<empty>
382340,UNKNOWN,122,,"++i)
        {
            events.push_back(record);
        }",53,<empty>,,248,122,CPPASTProblemDeclaration,,<empty>
382341,UNKNOWN,123,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(events), 0u);",9,<empty>,,252,123,CPPASTProblemDeclaration,,<empty>
382342,UNKNOWN,124,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,253,124,CPPASTProblemDeclaration,,<empty>
382343,UNKNOWN,125,,inputBuffer.Flush();,9,<empty>,,256,125,CPPASTProblemDeclaration,,<empty>
382344,UNKNOWN,126,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,257,126,CPPASTProblemDeclaration,,<empty>
382345,UNKNOWN,127,,},5,<empty>,,258,127,CPPASTProblemDeclaration,,<empty>
382346,UNKNOWN,128,,"TEST_METHOD(CanFlushAllButKeys)
    {
        InputBuffer inputBuffer;",5,<empty>,,260,128,CPPASTProblemDeclaration,,<empty>
382353,UNKNOWN,132,,for (size_t i = 0;,9,<empty>,,267,132,CPPASTProblemDeclaration,,<empty>
382354,UNKNOWN,133,,i < RECORD_INSERT_COUNT;,28,<empty>,,267,133,CPPASTProblemDeclaration,,<empty>
382355,UNKNOWN,134,,"++i)
        {
            records[i].EventType = (i % 2 == 0) ? MENU_EVENT : KEY_EVENT;
            inEvents.push_back(records[i]);
        }",53,<empty>,,267,134,CPPASTProblemDeclaration,,<empty>
382356,UNKNOWN,135,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inEvents), 0u);",9,<empty>,,272,135,CPPASTProblemDeclaration,,<empty>
382357,UNKNOWN,136,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,273,136,CPPASTProblemDeclaration,,<empty>
382358,UNKNOWN,137,,inputBuffer.FlushAllButKeys();,9,<empty>,,276,137,CPPASTProblemDeclaration,,<empty>
382359,UNKNOWN,138,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT / 2);",9,<empty>,,277,138,CPPASTProblemDeclaration,,<empty>
382367,UNKNOWN,142,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           false,
                                           false,
                                           false,
                                           false));",9,<empty>,,282,142,CPPASTProblemDeclaration,,<empty>
382368,UNKNOWN,143,,"VERIFY_ARE_EQUAL(amountToRead, outEvents.size());",9,<empty>,,288,143,CPPASTProblemDeclaration,,<empty>
382369,UNKNOWN,144,,for (size_t i = 0;,9,<empty>,,290,144,CPPASTProblemDeclaration,,<empty>
382370,UNKNOWN,145,,i < outEvents.size();,28,<empty>,,290,145,CPPASTProblemDeclaration,,<empty>
382371,UNKNOWN,146,,"++i)
        {
            VERIFY_ARE_EQUAL(outEvents[i].EventType, KEY_EVENT);
        }",50,<empty>,,290,146,CPPASTProblemDeclaration,,<empty>
382372,UNKNOWN,147,,},5,<empty>,,294,147,CPPASTProblemDeclaration,,<empty>
382373,UNKNOWN,148,,"TEST_METHOD(CanReadInput)
    {
        InputBuffer inputBuffer;",5,<empty>,,296,148,CPPASTProblemDeclaration,,<empty>
382378,UNKNOWN,152,,for (unsigned int i = 0;,9,<empty>,,303,152,CPPASTProblemDeclaration,,<empty>
382379,UNKNOWN,153,,i < RECORD_INSERT_COUNT;,34,<empty>,,303,153,CPPASTProblemDeclaration,,<empty>
382380,UNKNOWN,154,,"++i)
        {
            records[i] = MakeKeyEvent(TRUE, 1, static_cast<WCHAR>(L'A' + i), 0, static_cast<WCHAR>(L'A' + i), 0);
            inEvents.push_back(records[i]);
        }",59,<empty>,,303,154,CPPASTProblemDeclaration,,<empty>
382381,UNKNOWN,155,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inEvents), 0u);",9,<empty>,,308,155,CPPASTProblemDeclaration,,<empty>
382387,UNKNOWN,159,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           false,
                                           false,
                                           false,
                                           false));",9,<empty>,,313,159,CPPASTProblemDeclaration,,<empty>
382388,UNKNOWN,160,,"VERIFY_ARE_EQUAL(amountToRead, outEvents.size());",9,<empty>,,319,160,CPPASTProblemDeclaration,,<empty>
382389,UNKNOWN,161,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,320,161,CPPASTProblemDeclaration,,<empty>
382390,UNKNOWN,162,,for (size_t i = 0;,9,<empty>,,321,162,CPPASTProblemDeclaration,,<empty>
382391,UNKNOWN,163,,i < RECORD_INSERT_COUNT;,28,<empty>,,321,163,CPPASTProblemDeclaration,,<empty>
382392,UNKNOWN,164,,"++i)
        {
            VERIFY_ARE_EQUAL(records[i], outEvents[i]);
        }",53,<empty>,,321,164,CPPASTProblemDeclaration,,<empty>
382393,UNKNOWN,165,,},5,<empty>,,325,165,CPPASTProblemDeclaration,,<empty>
382394,UNKNOWN,166,,"TEST_METHOD(CanPeekAtEvents)
    {
        InputBuffer inputBuffer;",5,<empty>,,327,166,CPPASTProblemDeclaration,,<empty>
382399,UNKNOWN,170,,for (unsigned int i = 0;,9,<empty>,,334,170,CPPASTProblemDeclaration,,<empty>
382400,UNKNOWN,171,,i < RECORD_INSERT_COUNT;,34,<empty>,,334,171,CPPASTProblemDeclaration,,<empty>
382401,UNKNOWN,172,,"++i)
        {
            records[i] = MakeKeyEvent(TRUE, 1, static_cast<WCHAR>(L'A' + i), 0, static_cast<WCHAR>(L'A' + i), 0);
            inEvents.push_back(records[i]);
        }",59,<empty>,,334,172,CPPASTProblemDeclaration,,<empty>
382402,UNKNOWN,173,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inEvents), 0u);",9,<empty>,,339,173,CPPASTProblemDeclaration,,<empty>
382408,UNKNOWN,177,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           true,
                                           false,
                                           false,
                                           false));",9,<empty>,,344,177,CPPASTProblemDeclaration,,<empty>
382409,UNKNOWN,178,,"VERIFY_ARE_EQUAL(amountToRead, outEvents.size());",9,<empty>,,351,178,CPPASTProblemDeclaration,,<empty>
382410,UNKNOWN,179,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,352,179,CPPASTProblemDeclaration,,<empty>
382411,UNKNOWN,180,,for (unsigned int i = 0;,9,<empty>,,353,180,CPPASTProblemDeclaration,,<empty>
382412,UNKNOWN,181,,i < RECORD_INSERT_COUNT;,34,<empty>,,353,181,CPPASTProblemDeclaration,,<empty>
382413,UNKNOWN,182,,"++i)
        {
            VERIFY_ARE_EQUAL(records[i], outEvents[i]);
        }",59,<empty>,,353,182,CPPASTProblemDeclaration,,<empty>
382414,UNKNOWN,183,,},5,<empty>,,357,183,CPPASTProblemDeclaration,,<empty>
382415,UNKNOWN,184,,"TEST_METHOD(EmptyingBufferDuringReadSetsResetWaitEvent)
    {
        Log::Comment(L""hInputEvent should be reset if a read to the buffer completely empties it"");",5,<empty>,,359,184,CPPASTProblemDeclaration,,<empty>
382421,UNKNOWN,189,,for (unsigned int i = 0;,9,<empty>,,368,189,CPPASTProblemDeclaration,,<empty>
382422,UNKNOWN,190,,i < RECORD_INSERT_COUNT;,34,<empty>,,368,190,CPPASTProblemDeclaration,,<empty>
382423,UNKNOWN,191,,"++i)
        {
            records[i] = MakeKeyEvent(TRUE, 1, static_cast<WCHAR>(L'A' + i), 0, static_cast<WCHAR>(L'A' + i), 0);
            inEvents.push_back(records[i]);
        }",59,<empty>,,368,191,CPPASTProblemDeclaration,,<empty>
382424,UNKNOWN,192,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inEvents), 0u);",9,<empty>,,373,192,CPPASTProblemDeclaration,,<empty>
382434,UNKNOWN,195,,waitEvent.SetEvent();,9,<empty>,,376,195,CPPASTProblemDeclaration,,<empty>
382436,UNKNOWN,197,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           1,
                                           false,
                                           false,
                                           true,
                                           false));",9,<empty>,,380,197,CPPASTProblemDeclaration,,<empty>
382437,UNKNOWN,198,,"VERIFY_ARE_EQUAL(outEvents.size(), 1u);",9,<empty>,,386,198,CPPASTProblemDeclaration,,<empty>
382438,UNKNOWN,199,,VERIFY_IS_TRUE(waitEvent.is_signaled());,9,<empty>,,387,199,CPPASTProblemDeclaration,,<empty>
382439,UNKNOWN,200,,waitEvent.SetEvent();,9,<empty>,,390,200,CPPASTProblemDeclaration,,<empty>
382440,UNKNOWN,201,,outEvents.clear();,9,<empty>,,391,201,CPPASTProblemDeclaration,,<empty>
382441,UNKNOWN,202,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           RECORD_INSERT_COUNT - 1,
                                           false,
                                           false,
                                           true,
                                           false));",9,<empty>,,392,202,CPPASTProblemDeclaration,,<empty>
382442,UNKNOWN,203,,"VERIFY_ARE_EQUAL(outEvents.size(), RECORD_INSERT_COUNT - 1);",9,<empty>,,398,203,CPPASTProblemDeclaration,,<empty>
382443,UNKNOWN,204,,VERIFY_IS_FALSE(waitEvent.is_signaled());,9,<empty>,,399,204,CPPASTProblemDeclaration,,<empty>
382444,UNKNOWN,205,,},5,<empty>,,400,205,CPPASTProblemDeclaration,,<empty>
382445,UNKNOWN,206,,"TEST_METHOD(ReadingDbcsCharsPadsOutputArray)
    {
        Log::Comment(L""During a non-unicode read, the input buffer should count twice for each dbcs key event"");",5,<empty>,,402,206,CPPASTProblemDeclaration,,<empty>
382465,UNKNOWN,211,,codepage = CP_JAPANESE;,9,<empty>,,411,211,CPPASTProblemDeclaration,,<empty>
382471,UNKNOWN,215,,inRecords[0].EventType = MOUSE_EVENT;,9,<empty>,,417,215,CPPASTProblemDeclaration,,<empty>
382472,UNKNOWN,216,,"inRecords[1] = MakeKeyEvent(TRUE, 1, L'A', 0, L'A', 0);",9,<empty>,,418,216,CPPASTProblemDeclaration,,<empty>
382473,UNKNOWN,217,,"inRecords[2] = MakeKeyEvent(TRUE, 1, 0x3042, 0, 0x3042, 0);",9,<empty>,,419,217,CPPASTProblemDeclaration,,<empty>
382474,UNKNOWN,218,,inRecords[3].EventType = MOUSE_EVENT;,9,<empty>,,420,218,CPPASTProblemDeclaration,,<empty>
382479,UNKNOWN,221,,outRecordsExpected[0].EventType = MOUSE_EVENT;,9,<empty>,,423,221,CPPASTProblemDeclaration,,<empty>
382480,UNKNOWN,222,,"outRecordsExpected[1] = MakeKeyEvent(TRUE, 1, L'A', 0, L'A', 0);",9,<empty>,,424,222,CPPASTProblemDeclaration,,<empty>
382481,UNKNOWN,223,,"outRecordsExpected[2] = MakeKeyEvent(TRUE, 1, 0x3042, 0, 0x82, 0);",9,<empty>,,425,223,CPPASTProblemDeclaration,,<empty>
382482,UNKNOWN,224,,"outRecordsExpected[3] = MakeKeyEvent(TRUE, 1, 0x3042, 0, 0xa0, 0);",9,<empty>,,426,224,CPPASTProblemDeclaration,,<empty>
382483,UNKNOWN,225,,outRecordsExpected[4].EventType = MOUSE_EVENT;,9,<empty>,,427,225,CPPASTProblemDeclaration,,<empty>
382484,UNKNOWN,226,,inputBuffer.Flush();,9,<empty>,,429,226,CPPASTProblemDeclaration,,<empty>
382485,UNKNOWN,227,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inRecords), 0u);",9,<empty>,,430,227,CPPASTProblemDeclaration,,<empty>
382487,UNKNOWN,229,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           outRecordsExpected.size(),
                                           false,
                                           false,
                                           false,
                                           false));",9,<empty>,,434,229,CPPASTProblemDeclaration,,<empty>
382488,UNKNOWN,230,,"VERIFY_ARE_EQUAL(outEvents.size(), outRecordsExpected.size());",9,<empty>,,440,230,CPPASTProblemDeclaration,,<empty>
382489,UNKNOWN,231,,for (size_t i = 0;,9,<empty>,,441,231,CPPASTProblemDeclaration,,<empty>
382490,UNKNOWN,232,,i < outEvents.size();,28,<empty>,,441,232,CPPASTProblemDeclaration,,<empty>
382491,UNKNOWN,233,,"++i)
        {
            VERIFY_ARE_EQUAL(outEvents[i], outRecordsExpected[i]);
        }",50,<empty>,,441,233,CPPASTProblemDeclaration,,<empty>
382492,UNKNOWN,234,,},5,<empty>,,445,234,CPPASTProblemDeclaration,,<empty>
382493,UNKNOWN,235,,"TEST_METHOD(CanPrependEvents)
    {
        InputBuffer inputBuffer;",5,<empty>,,447,235,CPPASTProblemDeclaration,,<empty>
382498,UNKNOWN,239,,for (unsigned int i = 0;,9,<empty>,,454,239,CPPASTProblemDeclaration,,<empty>
382499,UNKNOWN,240,,i < RECORD_INSERT_COUNT;,34,<empty>,,454,240,CPPASTProblemDeclaration,,<empty>
382500,UNKNOWN,241,,"++i)
        {
            records[i] = MakeKeyEvent(TRUE, 1, static_cast<WCHAR>(L'A' + i), 0, static_cast<WCHAR>(L'A' + i), 0);
            inEvents.push_back(records[i]);
        }",59,<empty>,,454,241,CPPASTProblemDeclaration,,<empty>
382501,UNKNOWN,242,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(inEvents), 0u);",9,<empty>,,459,242,CPPASTProblemDeclaration,,<empty>
382502,UNKNOWN,243,,inEvents.clear();,9,<empty>,,462,243,CPPASTProblemDeclaration,,<empty>
382506,UNKNOWN,246,,for (unsigned int i = 0;,9,<empty>,,464,246,CPPASTProblemDeclaration,,<empty>
382507,UNKNOWN,247,,i < RECORD_INSERT_COUNT;,34,<empty>,,464,247,CPPASTProblemDeclaration,,<empty>
382508,UNKNOWN,248,,"++i)
        {
            prependRecords[i] = MakeKeyEvent(TRUE, 1, static_cast<WCHAR>(L'a' + i), 0, static_cast<WCHAR>(L'a' + i), 0);
            inEvents.push_back(prependRecords[i]);
        }",59,<empty>,,464,248,CPPASTProblemDeclaration,,<empty>
382517,UNKNOWN,251,,"VERIFY_ARE_EQUAL(eventsWritten, RECORD_INSERT_COUNT);",9,<empty>,,470,251,CPPASTProblemDeclaration,,<empty>
382523,UNKNOWN,255,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           false,
                                           false,
                                           false,
                                           false));",9,<empty>,,475,255,CPPASTProblemDeclaration,,<empty>
382524,UNKNOWN,256,,"VERIFY_ARE_EQUAL(amountToRead, outEvents.size());",9,<empty>,,481,256,CPPASTProblemDeclaration,,<empty>
382525,UNKNOWN,257,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), RECORD_INSERT_COUNT);",9,<empty>,,482,257,CPPASTProblemDeclaration,,<empty>
382526,UNKNOWN,258,,for (unsigned int i = 0;,9,<empty>,,483,258,CPPASTProblemDeclaration,,<empty>
382527,UNKNOWN,259,,i < RECORD_INSERT_COUNT;,34,<empty>,,483,259,CPPASTProblemDeclaration,,<empty>
382528,UNKNOWN,260,,"++i)
        {
            VERIFY_ARE_EQUAL(prependRecords[i], outEvents[i]);
        }",59,<empty>,,483,260,CPPASTProblemDeclaration,,<empty>
382529,UNKNOWN,261,,outEvents.clear();,9,<empty>,,488,261,CPPASTProblemDeclaration,,<empty>
382530,UNKNOWN,262,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           false,
                                           false,
                                           false,
                                           false));",9,<empty>,,490,262,CPPASTProblemDeclaration,,<empty>
382531,UNKNOWN,263,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,496,263,CPPASTProblemDeclaration,,<empty>
382532,UNKNOWN,264,,"VERIFY_ARE_EQUAL(amountToRead, outEvents.size());",9,<empty>,,497,264,CPPASTProblemDeclaration,,<empty>
382533,UNKNOWN,265,,for (unsigned int i = 0;,9,<empty>,,498,265,CPPASTProblemDeclaration,,<empty>
382534,UNKNOWN,266,,i < RECORD_INSERT_COUNT;,34,<empty>,,498,266,CPPASTProblemDeclaration,,<empty>
382535,UNKNOWN,267,,"++i)
        {
            VERIFY_ARE_EQUAL(records[i], outEvents[i]);
        }",59,<empty>,,498,267,CPPASTProblemDeclaration,,<empty>
382536,UNKNOWN,268,,},5,<empty>,,502,268,CPPASTProblemDeclaration,,<empty>
382537,UNKNOWN,269,,"TEST_METHOD(CanReinitializeInputBuffer)
    {
        InputBuffer inputBuffer;",5,<empty>,,504,269,CPPASTProblemDeclaration,,<empty>
382545,UNKNOWN,273,,record.EventType = MENU_EVENT;,9,<empty>,,511,273,CPPASTProblemDeclaration,,<empty>
382546,UNKNOWN,274,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(record), 0u);",9,<empty>,,512,274,CPPASTProblemDeclaration,,<empty>
382547,UNKNOWN,275,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 1u);",9,<empty>,,513,275,CPPASTProblemDeclaration,,<empty>
382548,UNKNOWN,276,,inputBuffer.InputMode = 0x0;,9,<empty>,,514,276,CPPASTProblemDeclaration,,<empty>
382549,UNKNOWN,277,,inputBuffer.ReinitializeInputBuffer();,9,<empty>,,515,277,CPPASTProblemDeclaration,,<empty>
382550,UNKNOWN,278,,"VERIFY_ARE_EQUAL(originalInputMode, inputBuffer.InputMode);",9,<empty>,,518,278,CPPASTProblemDeclaration,,<empty>
382551,UNKNOWN,279,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,519,279,CPPASTProblemDeclaration,,<empty>
382552,UNKNOWN,280,,},5,<empty>,,520,280,CPPASTProblemDeclaration,,<empty>
382553,UNKNOWN,281,,"TEST_METHOD(HandleConsoleSuspensionEventsRemovesPauseKeys)
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,522,281,CPPASTProblemDeclaration,,<empty>
382565,UNKNOWN,285,,"VERIFY_IS_FALSE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,529,285,CPPASTProblemDeclaration,,<empty>
382566,UNKNOWN,286,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,530,286,CPPASTProblemDeclaration,,<empty>
382567,UNKNOWN,287,,"VERIFY_ARE_EQUAL(inputBuffer.Write(pauseRecord), 0u);",9,<empty>,,532,287,CPPASTProblemDeclaration,,<empty>
382568,UNKNOWN,288,,"VERIFY_IS_TRUE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,535,288,CPPASTProblemDeclaration,,<empty>
382569,UNKNOWN,289,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,536,289,CPPASTProblemDeclaration,,<empty>
382580,UNKNOWN,292,,"VERIFY_ARE_EQUAL(inputBuffer.Write(unpauseRecord), 0u);",9,<empty>,,540,292,CPPASTProblemDeclaration,,<empty>
382581,UNKNOWN,293,,"VERIFY_IS_FALSE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,542,293,CPPASTProblemDeclaration,,<empty>
382582,UNKNOWN,294,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,543,294,CPPASTProblemDeclaration,,<empty>
382583,UNKNOWN,295,,},5,<empty>,,544,295,CPPASTProblemDeclaration,,<empty>
382584,UNKNOWN,296,,"TEST_METHOD(SystemKeysDontUnpauseConsole)
    {
        const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,546,296,CPPASTProblemDeclaration,,<empty>
382596,UNKNOWN,300,,"VERIFY_IS_FALSE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,553,300,CPPASTProblemDeclaration,,<empty>
382597,UNKNOWN,301,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,554,301,CPPASTProblemDeclaration,,<empty>
382598,UNKNOWN,302,,"VERIFY_ARE_EQUAL(inputBuffer.Write(pauseRecord), 0u);",9,<empty>,,557,302,CPPASTProblemDeclaration,,<empty>
382599,UNKNOWN,303,,"VERIFY_IS_TRUE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,560,303,CPPASTProblemDeclaration,,<empty>
382600,UNKNOWN,304,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 0u);",9,<empty>,,561,304,CPPASTProblemDeclaration,,<empty>
382611,UNKNOWN,307,,"VERIFY_IS_GREATER_THAN(inputBuffer.Write(systemRecord), 0u);",9,<empty>,,566,307,CPPASTProblemDeclaration,,<empty>
382612,UNKNOWN,308,,"VERIFY_IS_TRUE(WI_IsFlagSet(gci.Flags, CONSOLE_OUTPUT_SUSPENDED));",9,<empty>,,568,308,CPPASTProblemDeclaration,,<empty>
382613,UNKNOWN,309,,"VERIFY_ARE_EQUAL(inputBuffer.GetNumberOfReadyEvents(), 1u);",9,<empty>,,569,309,CPPASTProblemDeclaration,,<empty>
382619,UNKNOWN,313,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           amountToRead,
                                           true,
                                           false,
                                           false,
                                           false));",9,<empty>,,573,313,CPPASTProblemDeclaration,,<empty>
382620,UNKNOWN,314,,},5,<empty>,,579,314,CPPASTProblemDeclaration,,<empty>
382621,UNKNOWN,315,,"TEST_METHOD(WritingToEmptyBufferSignalsWaitEvent)
    {
        InputBuffer inputBuffer;",5,<empty>,,581,315,CPPASTProblemDeclaration,,<empty>
382641,UNKNOWN,323,,inputBuffer.Flush();,9,<empty>,,588,323,CPPASTProblemDeclaration,,<empty>
382643,UNKNOWN,325,,storage.push_back(std::move(inputEvent));,9,<empty>,,591,325,CPPASTProblemDeclaration,,<empty>
382644,UNKNOWN,326,,"inputBuffer._WriteBuffer(storage, eventsWritten, waitEvent);",9,<empty>,,592,326,CPPASTProblemDeclaration,,<empty>
382660,UNKNOWN,332,,waitEvent = false;,9,<empty>,,598,332,CPPASTProblemDeclaration,,<empty>
382661,UNKNOWN,333,,storage.clear();,9,<empty>,,599,333,CPPASTProblemDeclaration,,<empty>
382662,UNKNOWN,334,,storage.push_back(std::move(inputEvent2));,9,<empty>,,600,334,CPPASTProblemDeclaration,,<empty>
382663,UNKNOWN,335,,"inputBuffer._WriteBuffer(storage, eventsWritten, waitEvent);",9,<empty>,,601,335,CPPASTProblemDeclaration,,<empty>
382665,UNKNOWN,337,,},5,<empty>,,604,337,CPPASTProblemDeclaration,,<empty>
382666,UNKNOWN,338,,"TEST_METHOD(StreamReadingDeCoalesces)
    {
        InputBuffer inputBuffer;",5,<empty>,,606,338,CPPASTProblemDeclaration,,<empty>
382682,UNKNOWN,344,,"VERIFY_ARE_EQUAL(inputBuffer.Write(record), 1u);",9,<empty>,,613,344,CPPASTProblemDeclaration,,<empty>
382683,UNKNOWN,345,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           1,
                                           false,
                                           false,
                                           true,
                                           true));",9,<empty>,,614,345,CPPASTProblemDeclaration,,<empty>
382684,UNKNOWN,346,,"VERIFY_ARE_EQUAL(outEvents.size(), 1u);",9,<empty>,,620,346,CPPASTProblemDeclaration,,<empty>
382685,UNKNOWN,347,,"VERIFY_ARE_EQUAL(inputBuffer._storage.size(), 1u);",9,<empty>,,621,347,CPPASTProblemDeclaration,,<empty>
382686,UNKNOWN,348,,"VERIFY_ARE_EQUAL(inputBuffer._storage.front().Event.KeyEvent.wRepeatCount, repeatCount - 1);",9,<empty>,,622,348,CPPASTProblemDeclaration,,<empty>
382687,UNKNOWN,349,,"VERIFY_ARE_EQUAL(outEvents.front().Event.KeyEvent.wRepeatCount, 1u);",9,<empty>,,623,349,CPPASTProblemDeclaration,,<empty>
382688,UNKNOWN,350,,},5,<empty>,,624,350,CPPASTProblemDeclaration,,<empty>
382689,UNKNOWN,351,,"TEST_METHOD(StreamPeekingDeCoalesces)
    {
        InputBuffer inputBuffer;",5,<empty>,,626,351,CPPASTProblemDeclaration,,<empty>
382705,UNKNOWN,357,,"VERIFY_ARE_EQUAL(inputBuffer.Write(record), 1u);",9,<empty>,,633,357,CPPASTProblemDeclaration,,<empty>
382706,UNKNOWN,358,,"VERIFY_NT_SUCCESS(inputBuffer.Read(outEvents,
                                           1,
                                           true,
                                           false,
                                           true,
                                           true));",9,<empty>,,634,358,CPPASTProblemDeclaration,,<empty>
382707,UNKNOWN,359,,"VERIFY_ARE_EQUAL(outEvents.size(), 1u);",9,<empty>,,640,359,CPPASTProblemDeclaration,,<empty>
382708,UNKNOWN,360,,"VERIFY_ARE_EQUAL(inputBuffer._storage.size(), 1u);",9,<empty>,,641,360,CPPASTProblemDeclaration,,<empty>
382709,UNKNOWN,361,,"VERIFY_ARE_EQUAL(inputBuffer._storage.front().Event.KeyEvent.wRepeatCount, repeatCount);",9,<empty>,,642,361,CPPASTProblemDeclaration,,<empty>
382710,UNKNOWN,362,,"VERIFY_ARE_EQUAL(outEvents.front().Event.KeyEvent.wRepeatCount, 1u);",9,<empty>,,643,362,CPPASTProblemDeclaration,,<empty>
382711,UNKNOWN,363,,},5,<empty>,,644,363,CPPASTProblemDeclaration,,<empty>
382712,UNKNOWN,364,,};,1,<empty>,,645,364,CPPASTProblemDeclaration,,<empty>
382747,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        return true;",5,<empty>,,44,2,CPPASTProblemDeclaration,,<empty>
382748,UNKNOWN,3,,},5,<empty>,,47,3,CPPASTProblemDeclaration,,<empty>
382749,UNKNOWN,4,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        return true;",5,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
382750,UNKNOWN,5,,},5,<empty>,,52,5,CPPASTProblemDeclaration,,<empty>
382751,UNKNOWN,6,,"TEST_METHOD(TestFailedHandleAllocationWhenNotShared)
    {
        Log::Comment(L""Create a new output buffer modeled from the default/active one."");",5,<empty>,,54,6,CPPASTProblemDeclaration,,<empty>
382770,UNKNOWN,12,,"VERIFY_NT_SUCCESS(SCREEN_INFORMATION::CreateInstance(existingOutput.GetViewport().Dimensions(),
                                                             existingOutput.GetCurrentFont(),
                                                             existingOutput.GetBufferSize().Dimensions(),
                                                             existingOutput.GetAttributes(),
                                                             existingOutput.GetPopupAttributes(),
                                                             existingOutput.GetTextBuffer().GetCursor().GetSize(),
                                                             &newOutput));",9,<empty>,,62,12,CPPASTProblemDeclaration,,<empty>
382775,UNKNOWN,1,,ConsoleObjectHeader*,46,<empty>,,70,1,CPPASTTypeId,,<empty>
382777,UNKNOWN,15,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulOpenCount);",9,<empty>,,72,15,CPPASTProblemDeclaration,,<empty>
382778,UNKNOWN,16,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulReaderCount);",9,<empty>,,73,16,CPPASTProblemDeclaration,,<empty>
382779,UNKNOWN,17,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulReadShareCount);",9,<empty>,,74,17,CPPASTProblemDeclaration,,<empty>
382780,UNKNOWN,18,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulWriterCount);",9,<empty>,,75,18,CPPASTProblemDeclaration,,<empty>
382781,UNKNOWN,19,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulWriteShareCount);",9,<empty>,,76,19,CPPASTProblemDeclaration,,<empty>
382783,UNKNOWN,21,,"VERIFY_SUCCEEDED(newOutput->AllocateIoHandle(ConsoleHandleData::HandleType::Output,
                                                     GENERIC_READ | GENERIC_WRITE,
                                                     0,
                                                     unsharedHandle));",9,<empty>,,79,21,CPPASTProblemDeclaration,,<empty>
382784,UNKNOWN,22,,unsharedHandle.release();,9,<empty>,,83,22,CPPASTProblemDeclaration,,<empty>
382785,UNKNOWN,23,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulOpenCount);",9,<empty>,,85,23,CPPASTProblemDeclaration,,<empty>
382786,UNKNOWN,24,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulReaderCount);",9,<empty>,,86,24,CPPASTProblemDeclaration,,<empty>
382787,UNKNOWN,25,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulReadShareCount);",9,<empty>,,87,25,CPPASTProblemDeclaration,,<empty>
382788,UNKNOWN,26,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulWriterCount);",9,<empty>,,88,26,CPPASTProblemDeclaration,,<empty>
382789,UNKNOWN,27,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulWriteShareCount);",9,<empty>,,89,27,CPPASTProblemDeclaration,,<empty>
382791,UNKNOWN,29,,"VERIFY_ARE_EQUAL(HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), newOutput->AllocateIoHandle(ConsoleHandleData::HandleType::Output, GENERIC_READ | GENERIC_WRITE, 0, secondHandleAttempt));",9,<empty>,,92,29,CPPASTProblemDeclaration,,<empty>
382792,UNKNOWN,30,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulOpenCount);",9,<empty>,,94,30,CPPASTProblemDeclaration,,<empty>
382793,UNKNOWN,31,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulReaderCount);",9,<empty>,,95,31,CPPASTProblemDeclaration,,<empty>
382794,UNKNOWN,32,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulReadShareCount);",9,<empty>,,96,32,CPPASTProblemDeclaration,,<empty>
382795,UNKNOWN,33,,"VERIFY_ARE_EQUAL(1ul, newOutputAsHeader->_ulWriterCount);",9,<empty>,,97,33,CPPASTProblemDeclaration,,<empty>
382796,UNKNOWN,34,,"VERIFY_ARE_EQUAL(0ul, newOutputAsHeader->_ulWriteShareCount);",9,<empty>,,98,34,CPPASTProblemDeclaration,,<empty>
382797,UNKNOWN,35,,},5,<empty>,,99,35,CPPASTProblemDeclaration,,<empty>
382798,UNKNOWN,36,,};,1,<empty>,,100,36,CPPASTProblemDeclaration,,<empty>
382875,UNKNOWN,4,,"TEST_METHOD(CharacterFillUnlimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,78,4,CPPASTProblemDeclaration,,<empty>
382895,UNKNOWN,11,,for (size_t i = 0;,9,<empty>,,91,11,CPPASTProblemDeclaration,,<empty>
382896,UNKNOWN,12,,i < SHORT_MAX;,28,<empty>,,91,12,CPPASTProblemDeclaration,,<empty>
382897,UNKNOWN,13,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",43,<empty>,,91,13,CPPASTProblemDeclaration,,<empty>
382899,UNKNOWN,15,,},5,<empty>,,99,15,CPPASTProblemDeclaration,,<empty>
382900,UNKNOWN,16,,"TEST_METHOD(AttributeFillLimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,101,16,CPPASTProblemDeclaration,,<empty>
382922,UNKNOWN,25,,for (size_t i = 0;,9,<empty>,,116,25,CPPASTProblemDeclaration,,<empty>
382923,UNKNOWN,26,,i < limit;,28,<empty>,,116,26,CPPASTProblemDeclaration,,<empty>
382924,UNKNOWN,27,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",39,<empty>,,116,27,CPPASTProblemDeclaration,,<empty>
382926,UNKNOWN,29,,},5,<empty>,,124,29,CPPASTProblemDeclaration,,<empty>
382927,UNKNOWN,30,,"TEST_METHOD(AttributeFillUnlimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,126,30,CPPASTProblemDeclaration,,<empty>
382944,UNKNOWN,37,,for (size_t i = 0;,9,<empty>,,139,37,CPPASTProblemDeclaration,,<empty>
382945,UNKNOWN,38,,i < SHORT_MAX;,28,<empty>,,139,38,CPPASTProblemDeclaration,,<empty>
382946,UNKNOWN,39,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",43,<empty>,,139,39,CPPASTProblemDeclaration,,<empty>
382948,UNKNOWN,41,,},5,<empty>,,147,41,CPPASTProblemDeclaration,,<empty>
382949,UNKNOWN,42,,"TEST_METHOD(TextAndAttributeFillLimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,149,42,CPPASTProblemDeclaration,,<empty>
382979,UNKNOWN,53,,for (size_t i = 0;,9,<empty>,,166,53,CPPASTProblemDeclaration,,<empty>
382980,UNKNOWN,54,,i < limit;,28,<empty>,,166,54,CPPASTProblemDeclaration,,<empty>
382981,UNKNOWN,55,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",39,<empty>,,166,55,CPPASTProblemDeclaration,,<empty>
382983,UNKNOWN,57,,},5,<empty>,,174,57,CPPASTProblemDeclaration,,<empty>
382984,UNKNOWN,58,,"TEST_METHOD(TextAndAttributeFillUnlimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,176,58,CPPASTProblemDeclaration,,<empty>
383009,UNKNOWN,67,,for (size_t i = 0;,9,<empty>,,191,67,CPPASTProblemDeclaration,,<empty>
383010,UNKNOWN,68,,i < SHORT_MAX;,28,<empty>,,191,68,CPPASTProblemDeclaration,,<empty>
383011,UNKNOWN,69,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",43,<empty>,,191,69,CPPASTProblemDeclaration,,<empty>
383013,UNKNOWN,71,,},5,<empty>,,199,71,CPPASTProblemDeclaration,,<empty>
383014,UNKNOWN,72,,"TEST_METHOD(CharInfoFillLimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,201,72,CPPASTProblemDeclaration,,<empty>
383016,UNKNOWN,74,,ci.Char.UnicodeChar = L'Q';,9,<empty>,,206,74,CPPASTProblemDeclaration,,<empty>
383017,UNKNOWN,75,,ci.Attributes = FOREGROUND_RED | BACKGROUND_BLUE;,9,<empty>,,207,75,CPPASTProblemDeclaration,,<empty>
383044,UNKNOWN,82,,for (size_t i = 0;,9,<empty>,,218,82,CPPASTProblemDeclaration,,<empty>
383045,UNKNOWN,83,,i < limit;,28,<empty>,,218,83,CPPASTProblemDeclaration,,<empty>
383046,UNKNOWN,84,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",39,<empty>,,218,84,CPPASTProblemDeclaration,,<empty>
383048,UNKNOWN,86,,},5,<empty>,,226,86,CPPASTProblemDeclaration,,<empty>
383049,UNKNOWN,87,,"TEST_METHOD(CharInfoFillUnlimited)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,228,87,CPPASTProblemDeclaration,,<empty>
383051,UNKNOWN,89,,ci.Char.UnicodeChar = L'Q';,9,<empty>,,233,89,CPPASTProblemDeclaration,,<empty>
383052,UNKNOWN,90,,ci.Attributes = FOREGROUND_RED | BACKGROUND_BLUE;,9,<empty>,,234,90,CPPASTProblemDeclaration,,<empty>
383074,UNKNOWN,95,,for (size_t i = 0;,9,<empty>,,243,95,CPPASTProblemDeclaration,,<empty>
383075,UNKNOWN,96,,i < SHORT_MAX;,28,<empty>,,243,96,CPPASTProblemDeclaration,,<empty>
383076,UNKNOWN,97,,"i++)
        {
            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",43,<empty>,,243,97,CPPASTProblemDeclaration,,<empty>
383078,UNKNOWN,99,,},5,<empty>,,251,99,CPPASTProblemDeclaration,,<empty>
383079,UNKNOWN,100,,"TEST_METHOD(StringData)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,253,100,CPPASTProblemDeclaration,,<empty>
383086,UNKNOWN,105,,"for (const auto& wch : testText)
        {
            OutputCellView expected({ &wch, 1 },
                                    {},
                                    InvalidTextAttribute,
                                    TextAttributeBehavior::Current);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,261,105,CPPASTProblemDeclaration,,<empty>
383088,UNKNOWN,107,,},5,<empty>,,274,107,CPPASTProblemDeclaration,,<empty>
383089,UNKNOWN,108,,"TEST_METHOD(FullWidthStringData)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,276,108,CPPASTProblemDeclaration,,<empty>
383096,UNKNOWN,113,,"for (const auto& wch : testText)
        {
            auto expected = OutputCellView({ &wch, 1 },
                                           DbcsAttribute::Leading,
                                           InvalidTextAttribute,
                                           TextAttributeBehavior::Current);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;

            expected = OutputCellView({ &wch, 1 },
                                      DbcsAttribute::Trailing,
                                      InvalidTextAttribute,
                                      TextAttributeBehavior::Current);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,284,113,CPPASTProblemDeclaration,,<empty>
383098,UNKNOWN,115,,},5,<empty>,,306,115,CPPASTProblemDeclaration,,<empty>
383099,UNKNOWN,116,,"TEST_METHOD(StringDataWithColor)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,308,116,CPPASTProblemDeclaration,,<empty>
383112,UNKNOWN,123,,"for (const auto& wch : testText)
        {
            OutputCellView expected({ &wch, 1 },
                                    {},
                                    color,
                                    TextAttributeBehavior::Stored);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,317,123,CPPASTProblemDeclaration,,<empty>
383114,UNKNOWN,125,,},5,<empty>,,330,125,CPPASTProblemDeclaration,,<empty>
383115,UNKNOWN,126,,"TEST_METHOD(FullWidthStringDataWithColor)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,332,126,CPPASTProblemDeclaration,,<empty>
383128,UNKNOWN,133,,"for (const auto& wch : testText)
        {
            auto expected = OutputCellView({ &wch, 1 },
                                           DbcsAttribute::Leading,
                                           color,
                                           TextAttributeBehavior::Stored);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;

            expected = OutputCellView({ &wch, 1 },
                                      DbcsAttribute::Trailing,
                                      color,
                                      TextAttributeBehavior::Stored);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,341,133,CPPASTProblemDeclaration,,<empty>
383130,UNKNOWN,135,,},5,<empty>,,363,135,CPPASTProblemDeclaration,,<empty>
383131,UNKNOWN,136,,"TEST_METHOD(LegacyColorDataRun)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,365,136,CPPASTProblemDeclaration,,<empty>
383159,UNKNOWN,143,,"for (const auto& color : colors)
        {
            auto expected = OutputCellView({},
                                           {},
                                           TextAttribute{ color },
                                           TextAttributeBehavior::StoredOnly);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,374,143,CPPASTProblemDeclaration,,<empty>
383161,UNKNOWN,145,,},5,<empty>,,387,145,CPPASTProblemDeclaration,,<empty>
383162,UNKNOWN,146,,"TEST_METHOD(LegacyCharInfoRun)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,389,146,CPPASTProblemDeclaration,,<empty>
383164,UNKNOWN,148,,for (auto i = 0;,9,<empty>,,395,148,CPPASTProblemDeclaration,,<empty>
383165,UNKNOWN,149,,i < 5;,26,<empty>,,395,149,CPPASTProblemDeclaration,,<empty>
383166,UNKNOWN,150,,"i++)
        {
            CHAR_INFO ci;
            ci.Char.UnicodeChar = static_cast<wchar_t>(L'A' + i);
            ci.Attributes = gsl::narrow<WORD>(i);

            charInfos.push_back(ci);
        }",33,<empty>,,395,150,CPPASTProblemDeclaration,,<empty>
383182,UNKNOWN,155,,"for (const auto& ci : charInfos)
        {
            auto expected = OutputCellView({ &ci.Char.UnicodeChar, 1 },
                                           {},
                                           TextAttribute{ ci.Attributes },
                                           TextAttributeBehavior::Stored);

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,408,155,CPPASTProblemDeclaration,,<empty>
383184,UNKNOWN,157,,},5,<empty>,,421,157,CPPASTProblemDeclaration,,<empty>
383185,UNKNOWN,158,,"TEST_METHOD(OutputCellRun)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,423,158,CPPASTProblemDeclaration,,<empty>
383187,UNKNOWN,160,,for (auto i = 0;,9,<empty>,,429,160,CPPASTProblemDeclaration,,<empty>
383188,UNKNOWN,161,,i < 5;,26,<empty>,,429,161,CPPASTProblemDeclaration,,<empty>
383189,UNKNOWN,162,,"i++)
        {
            const std::wstring pair(L""\xd834\xdd1e"");
            OutputCell cell(pair, {}, TextAttribute{ gsl::narrow<WORD>(i) });
            cells.push_back(cell);
        }",33,<empty>,,429,162,CPPASTProblemDeclaration,,<empty>
383205,UNKNOWN,167,,"for (const auto& cell : cells)
        {
            auto expected = OutputCellView(cell.Chars(),
                                           cell.DbcsAttr(),
                                           cell.TextAttr(),
                                           cell.TextAttrBehavior());

            VERIFY_IS_TRUE(it);
            VERIFY_ARE_EQUAL(expected, *it);
            it++;
        }",9,<empty>,,440,167,CPPASTProblemDeclaration,,<empty>
383207,UNKNOWN,169,,},5,<empty>,,453,169,CPPASTProblemDeclaration,,<empty>
383208,UNKNOWN,170,,"TEST_METHOD(DistanceStandard)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,455,170,CPPASTProblemDeclaration,,<empty>
383223,UNKNOWN,179,,"for (const auto& wch : testText)
        {
            wch; // unused
            VERIFY_IS_TRUE(it);
            it++;

            expected++;
        }",9,<empty>,,466,179,CPPASTProblemDeclaration,,<empty>
383225,UNKNOWN,181,,"VERIFY_ARE_EQUAL(expected, it.GetCellDistance(original));",9,<empty>,,476,181,CPPASTProblemDeclaration,,<empty>
383226,UNKNOWN,182,,"VERIFY_ARE_EQUAL(expected, it.GetInputDistance(original));",9,<empty>,,477,182,CPPASTProblemDeclaration,,<empty>
383227,UNKNOWN,183,,},5,<empty>,,478,183,CPPASTProblemDeclaration,,<empty>
383228,UNKNOWN,184,,"TEST_METHOD(DistanceFullWidth)
    {
        SetVerifyOutput settings(VerifyOutputSettings::LogOnlyFailures);",5,<empty>,,480,184,CPPASTProblemDeclaration,,<empty>
383247,UNKNOWN,195,,"for (const auto& wch : testText)
        {
            wch; // unused
            VERIFY_IS_TRUE(it);
            const auto value = *it;
            it++;

            if (value.DbcsAttr() == DbcsAttribute::Leading || value.DbcsAttr() == DbcsAttribute::Trailing)
            {
                VERIFY_IS_TRUE(it);
                it++;
                cellsExpected++;
            }

            cellsExpected++;
            inputExpected++;
        }",9,<empty>,,492,195,CPPASTProblemDeclaration,,<empty>
383249,UNKNOWN,197,,"VERIFY_ARE_EQUAL(cellsExpected, it.GetCellDistance(original));",9,<empty>,,511,197,CPPASTProblemDeclaration,,<empty>
383250,UNKNOWN,198,,"VERIFY_ARE_EQUAL(inputExpected, it.GetInputDistance(original));",9,<empty>,,512,198,CPPASTProblemDeclaration,,<empty>
383251,UNKNOWN,199,,},5,<empty>,,513,199,CPPASTProblemDeclaration,,<empty>
383252,UNKNOWN,200,,};,1,<empty>,,514,200,CPPASTProblemDeclaration,,<empty>
384407,UNKNOWN,1,,size_t,78,<empty>,,7733,1,CPPASTTypeId,,<empty>
384437,UNKNOWN,1,,size_t,78,<empty>,,7737,1,CPPASTTypeId,,<empty>
384483,UNKNOWN,1,,size_t,78,<empty>,,7743,1,CPPASTTypeId,,<empty>
384513,UNKNOWN,1,,size_t,78,<empty>,,7747,1,CPPASTTypeId,,<empty>
384535,UNKNOWN,1,,size_t,72,<empty>,,7750,1,CPPASTTypeId,,<empty>
384685,UNKNOWN,1,,size_t,82,<empty>,,7827,1,CPPASTTypeId,,<empty>
384787,UNKNOWN,1,,size_t,82,<empty>,,7892,1,CPPASTTypeId,,<empty>
384839,UNKNOWN,1,,size_t,82,<empty>,,7908,1,CPPASTTypeId,,<empty>
384928,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        // Set up some sane defaults
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,66,2,CPPASTProblemDeclaration,,<empty>
384929,UNKNOWN,3,,"gci.SetColorTableEntry(TextColor::DEFAULT_FOREGROUND, INVALID_COLOR);",9,<empty>,,70,3,CPPASTProblemDeclaration,,<empty>
384930,UNKNOWN,4,,"gci.SetColorTableEntry(TextColor::DEFAULT_BACKGROUND, INVALID_COLOR);",9,<empty>,,71,4,CPPASTProblemDeclaration,,<empty>
384931,UNKNOWN,5,,gci.SetFillAttribute(0x07);,9,<empty>,,72,5,CPPASTProblemDeclaration,,<empty>
384932,UNKNOWN,6,,gci.CalculateDefaultColorIndices();,9,<empty>,,73,6,CPPASTProblemDeclaration,,<empty>
384933,UNKNOWN,7,,m_state->PrepareNewTextBufferInfo();,9,<empty>,,75,7,CPPASTProblemDeclaration,,<empty>
384941,UNKNOWN,10,,VERIFY_IS_FALSE(currentBuffer._IsAltBuffer());,9,<empty>,,78,10,CPPASTProblemDeclaration,,<empty>
384942,UNKNOWN,11,,"VERIFY_SUCCEEDED(currentBuffer.SetViewportOrigin(true, { 0, 0 }",9,<empty>,,79,11,CPPASTProblemDeclaration,,<empty>
384943,UNKNOWN,12,,", true));",72,<empty>,,79,12,CPPASTProblemDeclaration,,<empty>
384955,UNKNOWN,15,,"currentBuffer.SetViewport(Viewport::FromDimensions(defaultSize), true);",9,<empty>,,82,15,CPPASTProblemDeclaration,,<empty>
384956,UNKNOWN,16,,"VERIFY_ARE_EQUAL(til::point(0, 0), currentBuffer.GetTextBuffer().GetCursor().GetPosition());",9,<empty>,,83,16,CPPASTProblemDeclaration,,<empty>
384957,UNKNOWN,17,,currentBuffer.UpdateBottom();,9,<empty>,,85,17,CPPASTProblemDeclaration,,<empty>
384958,UNKNOWN,18,,return true;,9,<empty>,,87,18,CPPASTProblemDeclaration,,<empty>
384959,UNKNOWN,19,,},5,<empty>,,88,19,CPPASTProblemDeclaration,,<empty>
384960,UNKNOWN,20,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,90,20,CPPASTProblemDeclaration,,<empty>
384961,UNKNOWN,21,,return true;,9,<empty>,,94,21,CPPASTProblemDeclaration,,<empty>
384962,UNKNOWN,22,,},5,<empty>,,95,22,CPPASTProblemDeclaration,,<empty>
385077,UNKNOWN,133,,};,1,<empty>,,267,133,CPPASTProblemDeclaration,,<empty>
388025,UNKNOWN,-1,,),34,<empty>,,1041,2,CPPASTProblemStatement,,<empty>
388029,UNKNOWN,-1,,),138,<empty>,,1042,4,CPPASTProblemStatement,,<empty>
388031,UNKNOWN,-1,,),32,<empty>,,1043,6,CPPASTProblemStatement,,<empty>
388044,UNKNOWN,1,,wchar_t,33,<empty>,,1047,1,CPPASTTypeId,,<empty>
388253,UNKNOWN,-1,,),34,<empty>,,1087,2,CPPASTProblemStatement,,<empty>
388257,UNKNOWN,-1,,),58,<empty>,,1088,4,CPPASTProblemStatement,,<empty>
388259,UNKNOWN,-1,,),32,<empty>,,1089,6,CPPASTProblemStatement,,<empty>
388723,UNKNOWN,-1,,),34,<empty>,,1214,2,CPPASTProblemStatement,,<empty>
388727,UNKNOWN,-1,,),58,<empty>,,1215,4,CPPASTProblemStatement,,<empty>
388731,UNKNOWN,-1,,),64,<empty>,,1216,6,CPPASTProblemStatement,,<empty>
388735,UNKNOWN,-1,,),64,<empty>,,1217,8,CPPASTProblemStatement,,<empty>
388737,UNKNOWN,-1,,),32,<empty>,,1218,10,CPPASTProblemStatement,,<empty>
389032,UNKNOWN,-1,,),34,<empty>,,1285,2,CPPASTProblemStatement,,<empty>
389036,UNKNOWN,-1,,),58,<empty>,,1286,4,CPPASTProblemStatement,,<empty>
389038,UNKNOWN,-1,,),32,<empty>,,1287,6,CPPASTProblemStatement,,<empty>
389524,UNKNOWN,-1,,),34,<empty>,,1420,2,CPPASTProblemStatement,,<empty>
389528,UNKNOWN,-1,,),58,<empty>,,1421,4,CPPASTProblemStatement,,<empty>
389532,UNKNOWN,-1,,),59,<empty>,,1422,6,CPPASTProblemStatement,,<empty>
389534,UNKNOWN,-1,,),32,<empty>,,1423,8,CPPASTProblemStatement,,<empty>
392559,UNKNOWN,-1,,),34,<empty>,,2092,2,CPPASTProblemStatement,,<empty>
392563,UNKNOWN,-1,,),75,<empty>,,2093,4,CPPASTProblemStatement,,<empty>
392567,UNKNOWN,-1,,),64,<empty>,,2094,6,CPPASTProblemStatement,,<empty>
392571,UNKNOWN,-1,,),64,<empty>,,2095,8,CPPASTProblemStatement,,<empty>
392860,UNKNOWN,-1,,),34,<empty>,,2171,2,CPPASTProblemStatement,,<empty>
392864,UNKNOWN,-1,,),61,<empty>,,2172,4,CPPASTProblemStatement,,<empty>
392868,UNKNOWN,-1,,),61,<empty>,,2173,6,CPPASTProblemStatement,,<empty>
396140,UNKNOWN,-1,,),34,<empty>,,2906,2,CPPASTProblemStatement,,<empty>
396144,UNKNOWN,-1,,),67,<empty>,,2907,4,CPPASTProblemStatement,,<empty>
398160,UNKNOWN,-1,,),34,<empty>,,3386,2,CPPASTProblemStatement,,<empty>
398164,UNKNOWN,-1,,),72,<empty>,,3387,4,CPPASTProblemStatement,,<empty>
398168,UNKNOWN,-1,,),86,<empty>,,3388,6,CPPASTProblemStatement,,<empty>
399733,UNKNOWN,-1,,),34,<empty>,,3737,5,CPPASTProblemStatement,,<empty>
399737,UNKNOWN,-1,,),68,<empty>,,3738,7,CPPASTProblemStatement,,<empty>
399741,UNKNOWN,-1,,),67,<empty>,,3739,9,CPPASTProblemStatement,,<empty>
399743,UNKNOWN,-1,,),32,<empty>,,3740,11,CPPASTProblemStatement,,<empty>
399751,UNKNOWN,1,,int&,60,<empty>,,3742,1,CPPASTTypeId,,<empty>
400554,UNKNOWN,-1,,),34,<empty>,,3955,2,CPPASTProblemStatement,,<empty>
400558,UNKNOWN,-1,,),74,<empty>,,3956,4,CPPASTProblemStatement,,<empty>
401168,UNKNOWN,-1,,),34,<empty>,,4155,2,CPPASTProblemStatement,,<empty>
401172,UNKNOWN,-1,,),74,<empty>,,4156,4,CPPASTProblemStatement,,<empty>
401782,UNKNOWN,-1,,),34,<empty>,,4355,2,CPPASTProblemStatement,,<empty>
401786,UNKNOWN,-1,,),57,<empty>,,4356,4,CPPASTProblemStatement,,<empty>
401796,UNKNOWN,1,,int&,52,<empty>,,4366,1,CPPASTTypeId,,<empty>
402735,UNKNOWN,-1,,),34,<empty>,,4580,2,CPPASTProblemStatement,,<empty>
402739,UNKNOWN,-1,,),61,<empty>,,4581,4,CPPASTProblemStatement,,<empty>
402743,UNKNOWN,-1,,),67,<empty>,,4582,6,CPPASTProblemStatement,,<empty>
402747,UNKNOWN,-1,,),70,<empty>,,4583,8,CPPASTProblemStatement,,<empty>
402749,UNKNOWN,-1,,),32,<empty>,,4584,10,CPPASTProblemStatement,,<empty>
405921,UNKNOWN,-1,,),34,<empty>,,5306,2,CPPASTProblemStatement,,<empty>
405925,UNKNOWN,-1,,),66,<empty>,,5307,4,CPPASTProblemStatement,,<empty>
405927,UNKNOWN,-1,,),32,<empty>,,5308,6,CPPASTProblemStatement,,<empty>
406432,UNKNOWN,-1,,),34,<empty>,,5427,2,CPPASTProblemStatement,,<empty>
406436,UNKNOWN,-1,,),62,<empty>,,5428,4,CPPASTProblemStatement,,<empty>
406440,UNKNOWN,-1,,),62,<empty>,,5429,6,CPPASTProblemStatement,,<empty>
409074,UNKNOWN,-1,,),34,<empty>,,6029,2,CPPASTProblemStatement,,<empty>
409078,UNKNOWN,-1,,),63,<empty>,,6030,4,CPPASTProblemStatement,,<empty>
409082,UNKNOWN,-1,,),61,<empty>,,6031,6,CPPASTProblemStatement,,<empty>
409086,UNKNOWN,-1,,),63,<empty>,,6032,8,CPPASTProblemStatement,,<empty>
409090,UNKNOWN,-1,,),66,<empty>,,6033,10,CPPASTProblemStatement,,<empty>
409094,UNKNOWN,-1,,),72,<empty>,,6034,12,CPPASTProblemStatement,,<empty>
409098,UNKNOWN,-1,,),61,<empty>,,6035,14,CPPASTProblemStatement,,<empty>
409102,UNKNOWN,-1,,),65,<empty>,,6036,16,CPPASTProblemStatement,,<empty>
409106,UNKNOWN,-1,,),66,<empty>,,6037,18,CPPASTProblemStatement,,<empty>
409108,UNKNOWN,-1,,),32,<empty>,,6038,20,CPPASTProblemStatement,,<empty>
409446,UNKNOWN,-1,,),34,<empty>,,6195,2,CPPASTProblemStatement,,<empty>
409450,UNKNOWN,-1,,),63,<empty>,,6196,4,CPPASTProblemStatement,,<empty>
409454,UNKNOWN,-1,,),61,<empty>,,6197,6,CPPASTProblemStatement,,<empty>
409458,UNKNOWN,-1,,),63,<empty>,,6198,8,CPPASTProblemStatement,,<empty>
409462,UNKNOWN,-1,,),66,<empty>,,6199,10,CPPASTProblemStatement,,<empty>
409466,UNKNOWN,-1,,),72,<empty>,,6200,12,CPPASTProblemStatement,,<empty>
409470,UNKNOWN,-1,,),61,<empty>,,6201,14,CPPASTProblemStatement,,<empty>
409474,UNKNOWN,-1,,),65,<empty>,,6202,16,CPPASTProblemStatement,,<empty>
409478,UNKNOWN,-1,,),66,<empty>,,6203,18,CPPASTProblemStatement,,<empty>
409482,UNKNOWN,-1,,),72,<empty>,,6204,20,CPPASTProblemStatement,,<empty>
409486,UNKNOWN,-1,,),72,<empty>,,6205,22,CPPASTProblemStatement,,<empty>
409488,UNKNOWN,-1,,),32,<empty>,,6206,24,CPPASTProblemStatement,,<empty>
415133,UNKNOWN,-1,,),34,<empty>,,7567,2,CPPASTProblemStatement,,<empty>
415137,UNKNOWN,-1,,),64,<empty>,,7568,4,CPPASTProblemStatement,,<empty>
415139,UNKNOWN,-1,,),32,<empty>,,7569,6,CPPASTProblemStatement,,<empty>
415562,UNKNOWN,-1,,),34,<empty>,,7688,2,CPPASTProblemStatement,,<empty>
415566,UNKNOWN,-1,,),55,<empty>,,7689,4,CPPASTProblemStatement,,<empty>
415570,UNKNOWN,-1,,),55,<empty>,,7690,6,CPPASTProblemStatement,,<empty>
415575,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dx, L""The change in width of the buffer"")",5,<empty>,,7693,1,CPPASTProblemStatement,,<empty>
415579,UNKNOWN,1,,"INIT_TEST_PROPERTY(int, dy, L""The change in height of the buffer"")",5,<empty>,,7694,1,CPPASTProblemStatement,,<empty>
416244,UNKNOWN,-1,,),34,<empty>,,7929,2,CPPASTProblemStatement,,<empty>
416248,UNKNOWN,-1,,),64,<empty>,,7930,4,CPPASTProblemStatement,,<empty>
416252,UNKNOWN,-1,,),72,<empty>,,7931,6,CPPASTProblemStatement,,<empty>
416257,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, inConpty, L""Should we pretend to be in conpty mode?"")",5,<empty>,,7934,1,CPPASTProblemStatement,,<empty>
416261,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, reEnterAltBuffer, L""Should we re-enter the alt buffer when we're already in it?"")",5,<empty>,,7935,1,CPPASTProblemStatement,,<empty>
416689,UNKNOWN,-1,,),34,<empty>,,8039,2,CPPASTProblemStatement,,<empty>
416693,UNKNOWN,-1,,),67,<empty>,,8040,4,CPPASTProblemStatement,,<empty>
416703,UNKNOWN,1,,int&,56,<empty>,,8054,1,CPPASTTypeId,,<empty>
417394,UNKNOWN,-1,,),34,<empty>,,8217,2,CPPASTProblemStatement,,<empty>
417398,UNKNOWN,-1,,),58,<empty>,,8218,4,CPPASTProblemStatement,,<empty>
417402,UNKNOWN,-1,,),144,<empty>,,8219,6,CPPASTProblemStatement,,<empty>
417850,UNKNOWN,-1,,),34,<empty>,,8324,2,CPPASTProblemStatement,,<empty>
417854,UNKNOWN,-1,,),96,<empty>,,8325,4,CPPASTProblemStatement,,<empty>
417858,UNKNOWN,-1,,),64,<empty>,,8326,6,CPPASTProblemStatement,,<empty>
418264,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        m_state->PrepareNewTextBufferInfo();",5,<empty>,,45,2,CPPASTProblemDeclaration,,<empty>
418265,UNKNOWN,3,,m_state->FillTextBuffer();,9,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
418266,UNKNOWN,4,,return true;,9,<empty>,,50,4,CPPASTProblemDeclaration,,<empty>
418267,UNKNOWN,5,,},5,<empty>,,51,5,CPPASTProblemDeclaration,,<empty>
418268,UNKNOWN,6,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,53,6,CPPASTProblemDeclaration,,<empty>
418273,UNKNOWN,8,,),29,<empty>,,56,8,CPPASTProblemDeclaration,,<empty>
418274,UNKNOWN,9,,.ClearSelection();,30,<empty>,,56,9,CPPASTProblemDeclaration,,<empty>
418275,UNKNOWN,10,,return true;,9,<empty>,,57,10,CPPASTProblemDeclaration,,<empty>
418276,UNKNOWN,11,,},5,<empty>,,58,11,CPPASTProblemDeclaration,,<empty>
418429,UNKNOWN,13,,"TEST_METHOD(ForwardCaseSensitive)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,96,13,CPPASTProblemDeclaration,,<empty>
418431,UNKNOWN,15,,"s.ResetIfStale(gci.renderData, L""AB"", false, false);",9,<empty>,,101,15,CPPASTProblemDeclaration,,<empty>
418432,UNKNOWN,16,,"DoFoundChecks(s, {}",9,<empty>,,102,16,CPPASTProblemDeclaration,,<empty>
418433,UNKNOWN,17,,", 1);",28,<empty>,,102,17,CPPASTProblemDeclaration,,<empty>
418434,UNKNOWN,18,,},5,<empty>,,103,18,CPPASTProblemDeclaration,,<empty>
418435,UNKNOWN,19,,"TEST_METHOD(ForwardCaseSensitiveJapanese)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,105,19,CPPASTProblemDeclaration,,<empty>
418437,UNKNOWN,21,,"s.ResetIfStale(gci.renderData, L""\x304b"", false, false);",9,<empty>,,109,21,CPPASTProblemDeclaration,,<empty>
418438,UNKNOWN,22,,"DoFoundChecks(s, { 2, 0 }",9,<empty>,,110,22,CPPASTProblemDeclaration,,<empty>
418439,UNKNOWN,23,,", 1);",34,<empty>,,110,23,CPPASTProblemDeclaration,,<empty>
418440,UNKNOWN,24,,},5,<empty>,,111,24,CPPASTProblemDeclaration,,<empty>
418441,UNKNOWN,25,,"TEST_METHOD(ForwardCaseInsensitive)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,113,25,CPPASTProblemDeclaration,,<empty>
418443,UNKNOWN,27,,"s.ResetIfStale(gci.renderData, L""ab"", false, true);",9,<empty>,,118,27,CPPASTProblemDeclaration,,<empty>
418444,UNKNOWN,28,,"DoFoundChecks(s, {}",9,<empty>,,119,28,CPPASTProblemDeclaration,,<empty>
418445,UNKNOWN,29,,", 1);",28,<empty>,,119,29,CPPASTProblemDeclaration,,<empty>
418446,UNKNOWN,30,,},5,<empty>,,120,30,CPPASTProblemDeclaration,,<empty>
418447,UNKNOWN,31,,"TEST_METHOD(ForwardCaseInsensitiveJapanese)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,122,31,CPPASTProblemDeclaration,,<empty>
418449,UNKNOWN,33,,"s.ResetIfStale(gci.renderData, L""\x304b"", false, true);",9,<empty>,,126,33,CPPASTProblemDeclaration,,<empty>
418450,UNKNOWN,34,,"DoFoundChecks(s, { 2, 0 }",9,<empty>,,127,34,CPPASTProblemDeclaration,,<empty>
418451,UNKNOWN,35,,", 1);",34,<empty>,,127,35,CPPASTProblemDeclaration,,<empty>
418452,UNKNOWN,36,,},5,<empty>,,128,36,CPPASTProblemDeclaration,,<empty>
418453,UNKNOWN,37,,"TEST_METHOD(BackwardCaseSensitive)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,130,37,CPPASTProblemDeclaration,,<empty>
418455,UNKNOWN,39,,"s.ResetIfStale(gci.renderData, L""AB"", true, false);",9,<empty>,,134,39,CPPASTProblemDeclaration,,<empty>
418456,UNKNOWN,40,,"DoFoundChecks(s, { 0, 3 }",9,<empty>,,135,40,CPPASTProblemDeclaration,,<empty>
418457,UNKNOWN,41,,", -1);",34,<empty>,,135,41,CPPASTProblemDeclaration,,<empty>
418458,UNKNOWN,42,,},5,<empty>,,136,42,CPPASTProblemDeclaration,,<empty>
418459,UNKNOWN,43,,"TEST_METHOD(BackwardCaseSensitiveJapanese)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,138,43,CPPASTProblemDeclaration,,<empty>
418461,UNKNOWN,45,,"s.ResetIfStale(gci.renderData, L""\x304b"", true, false);",9,<empty>,,142,45,CPPASTProblemDeclaration,,<empty>
418462,UNKNOWN,46,,"DoFoundChecks(s, { 2, 3 }",9,<empty>,,143,46,CPPASTProblemDeclaration,,<empty>
418463,UNKNOWN,47,,", -1);",34,<empty>,,143,47,CPPASTProblemDeclaration,,<empty>
418464,UNKNOWN,48,,},5,<empty>,,144,48,CPPASTProblemDeclaration,,<empty>
418465,UNKNOWN,49,,"TEST_METHOD(BackwardCaseInsensitive)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,146,49,CPPASTProblemDeclaration,,<empty>
418467,UNKNOWN,51,,"s.ResetIfStale(gci.renderData, L""ab"", true, true);",9,<empty>,,150,51,CPPASTProblemDeclaration,,<empty>
418468,UNKNOWN,52,,"DoFoundChecks(s, { 0, 3 }",9,<empty>,,151,52,CPPASTProblemDeclaration,,<empty>
418469,UNKNOWN,53,,", -1);",34,<empty>,,151,53,CPPASTProblemDeclaration,,<empty>
418470,UNKNOWN,54,,},5,<empty>,,152,54,CPPASTProblemDeclaration,,<empty>
418471,UNKNOWN,55,,"TEST_METHOD(BackwardCaseInsensitiveJapanese)
    {
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,154,55,CPPASTProblemDeclaration,,<empty>
418473,UNKNOWN,57,,"s.ResetIfStale(gci.renderData, L""\x304b"", true, true);",9,<empty>,,158,57,CPPASTProblemDeclaration,,<empty>
418474,UNKNOWN,58,,"DoFoundChecks(s, { 2, 3 }",9,<empty>,,159,58,CPPASTProblemDeclaration,,<empty>
418475,UNKNOWN,59,,", -1);",34,<empty>,,159,59,CPPASTProblemDeclaration,,<empty>
418476,UNKNOWN,60,,},5,<empty>,,160,60,CPPASTProblemDeclaration,,<empty>
418477,UNKNOWN,61,,};,1,<empty>,,161,61,CPPASTProblemDeclaration,,<empty>
418517,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        return true;",5,<empty>,,51,2,CPPASTProblemDeclaration,,<empty>
418518,UNKNOWN,3,,},5,<empty>,,54,3,CPPASTProblemDeclaration,,<empty>
418519,UNKNOWN,4,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        return true;",5,<empty>,,56,4,CPPASTProblemDeclaration,,<empty>
418520,UNKNOWN,5,,},5,<empty>,,59,5,CPPASTProblemDeclaration,,<empty>
418585,UNKNOWN,1,,til::CoordType,52,<empty>,,73,1,CPPASTTypeId,,<empty>
418622,UNKNOWN,7,,"TEST_METHOD(TestGetSelectionRects_BoxMode)
    {
        m_pSelection->_fSelectionVisible = true;",5,<empty>,,84,7,CPPASTProblemDeclaration,,<empty>
418623,UNKNOWN,8,,m_pSelection->_srSelectionRect.top = 0;,9,<empty>,,89,8,CPPASTProblemDeclaration,,<empty>
418624,UNKNOWN,9,,m_pSelection->_srSelectionRect.bottom = 3;,9,<empty>,,90,9,CPPASTProblemDeclaration,,<empty>
418625,UNKNOWN,10,,m_pSelection->_srSelectionRect.left = 1;,9,<empty>,,91,10,CPPASTProblemDeclaration,,<empty>
418626,UNKNOWN,11,,m_pSelection->_srSelectionRect.right = 10;,9,<empty>,,92,11,CPPASTProblemDeclaration,,<empty>
418627,UNKNOWN,12,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.left;,9,<empty>,,95,12,CPPASTProblemDeclaration,,<empty>
418628,UNKNOWN,13,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.top;,9,<empty>,,96,13,CPPASTProblemDeclaration,,<empty>
418629,UNKNOWN,14,,m_pSelection->_fLineSelection = false;,9,<empty>,,99,14,CPPASTProblemDeclaration,,<empty>
418630,UNKNOWN,15,,m_pSelection->_fUseAlternateSelection = false;,9,<empty>,,100,15,CPPASTProblemDeclaration,,<empty>
418631,UNKNOWN,16,,VerifyGetSelectionRects_BoxMode();,9,<empty>,,102,16,CPPASTProblemDeclaration,,<empty>
418632,UNKNOWN,17,,m_pSelection->_fLineSelection = true;,9,<empty>,,105,17,CPPASTProblemDeclaration,,<empty>
418633,UNKNOWN,18,,m_pSelection->_fUseAlternateSelection = true;,9,<empty>,,106,18,CPPASTProblemDeclaration,,<empty>
418634,UNKNOWN,19,,VerifyGetSelectionRects_BoxMode();,9,<empty>,,108,19,CPPASTProblemDeclaration,,<empty>
418635,UNKNOWN,20,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.right;,9,<empty>,,112,20,CPPASTProblemDeclaration,,<empty>
418636,UNKNOWN,21,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.top;,9,<empty>,,113,21,CPPASTProblemDeclaration,,<empty>
418637,UNKNOWN,22,,VerifyGetSelectionRects_BoxMode();,9,<empty>,,115,22,CPPASTProblemDeclaration,,<empty>
418638,UNKNOWN,23,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.left;,9,<empty>,,118,23,CPPASTProblemDeclaration,,<empty>
418639,UNKNOWN,24,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.bottom;,9,<empty>,,119,24,CPPASTProblemDeclaration,,<empty>
418640,UNKNOWN,25,,VerifyGetSelectionRects_BoxMode();,9,<empty>,,121,25,CPPASTProblemDeclaration,,<empty>
418641,UNKNOWN,26,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.right;,9,<empty>,,124,26,CPPASTProblemDeclaration,,<empty>
418642,UNKNOWN,27,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.bottom;,9,<empty>,,125,27,CPPASTProblemDeclaration,,<empty>
418643,UNKNOWN,28,,VerifyGetSelectionRects_BoxMode();,9,<empty>,,127,28,CPPASTProblemDeclaration,,<empty>
418644,UNKNOWN,29,,},5,<empty>,,128,29,CPPASTProblemDeclaration,,<empty>
418777,UNKNOWN,1,,til::CoordType,56,<empty>,,172,1,CPPASTTypeId,,<empty>
418974,UNKNOWN,31,,"TEST_METHOD(TestGetSelectionRects_LineMode)
    {
        m_pSelection->_fSelectionVisible = true;",5,<empty>,,239,31,CPPASTProblemDeclaration,,<empty>
418975,UNKNOWN,32,,m_pSelection->_srSelectionRect.top = 0;,9,<empty>,,245,32,CPPASTProblemDeclaration,,<empty>
418976,UNKNOWN,33,,m_pSelection->_srSelectionRect.bottom = 3;,9,<empty>,,246,33,CPPASTProblemDeclaration,,<empty>
418977,UNKNOWN,34,,m_pSelection->_srSelectionRect.left = 1;,9,<empty>,,247,34,CPPASTProblemDeclaration,,<empty>
418978,UNKNOWN,35,,m_pSelection->_srSelectionRect.right = 10;,9,<empty>,,248,35,CPPASTProblemDeclaration,,<empty>
418979,UNKNOWN,36,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.left;,9,<empty>,,251,36,CPPASTProblemDeclaration,,<empty>
418980,UNKNOWN,37,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.top;,9,<empty>,,252,37,CPPASTProblemDeclaration,,<empty>
418981,UNKNOWN,38,,m_pSelection->_fLineSelection = true;,9,<empty>,,255,38,CPPASTProblemDeclaration,,<empty>
418982,UNKNOWN,39,,m_pSelection->_fUseAlternateSelection = false;,9,<empty>,,256,39,CPPASTProblemDeclaration,,<empty>
418983,UNKNOWN,40,,VerifyGetSelectionRects_LineMode();,9,<empty>,,258,40,CPPASTProblemDeclaration,,<empty>
418984,UNKNOWN,41,,m_pSelection->_fLineSelection = false;,9,<empty>,,261,41,CPPASTProblemDeclaration,,<empty>
418985,UNKNOWN,42,,m_pSelection->_fUseAlternateSelection = true;,9,<empty>,,262,42,CPPASTProblemDeclaration,,<empty>
418986,UNKNOWN,43,,VerifyGetSelectionRects_LineMode();,9,<empty>,,264,43,CPPASTProblemDeclaration,,<empty>
418987,UNKNOWN,44,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.right;,9,<empty>,,268,44,CPPASTProblemDeclaration,,<empty>
418988,UNKNOWN,45,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.top;,9,<empty>,,269,45,CPPASTProblemDeclaration,,<empty>
418989,UNKNOWN,46,,VerifyGetSelectionRects_LineMode();,9,<empty>,,271,46,CPPASTProblemDeclaration,,<empty>
418990,UNKNOWN,47,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.left;,9,<empty>,,274,47,CPPASTProblemDeclaration,,<empty>
418991,UNKNOWN,48,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.bottom;,9,<empty>,,275,48,CPPASTProblemDeclaration,,<empty>
418992,UNKNOWN,49,,VerifyGetSelectionRects_LineMode();,9,<empty>,,277,49,CPPASTProblemDeclaration,,<empty>
418993,UNKNOWN,50,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.right;,9,<empty>,,280,50,CPPASTProblemDeclaration,,<empty>
418994,UNKNOWN,51,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.bottom;,9,<empty>,,281,51,CPPASTProblemDeclaration,,<empty>
418995,UNKNOWN,52,,VerifyGetSelectionRects_LineMode();,9,<empty>,,283,52,CPPASTProblemDeclaration,,<empty>
418996,UNKNOWN,53,,m_pSelection->_srSelectionRect.top = 2;,9,<empty>,,286,53,CPPASTProblemDeclaration,,<empty>
418997,UNKNOWN,54,,m_pSelection->_srSelectionRect.bottom = 2;,9,<empty>,,287,54,CPPASTProblemDeclaration,,<empty>
418998,UNKNOWN,55,,m_pSelection->_srSelectionRect.left = 1;,9,<empty>,,288,55,CPPASTProblemDeclaration,,<empty>
418999,UNKNOWN,56,,m_pSelection->_srSelectionRect.right = 10;,9,<empty>,,289,56,CPPASTProblemDeclaration,,<empty>
419000,UNKNOWN,57,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.left;,9,<empty>,,292,57,CPPASTProblemDeclaration,,<empty>
419001,UNKNOWN,58,,VERIFY_IS_TRUE(m_pSelection->_srSelectionRect.bottom == m_pSelection->_srSelectionRect.top);,9,<empty>,,293,58,CPPASTProblemDeclaration,,<empty>
419002,UNKNOWN,59,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.bottom;,9,<empty>,,294,59,CPPASTProblemDeclaration,,<empty>
419003,UNKNOWN,60,,VerifyGetSelectionRects_LineMode();,9,<empty>,,296,60,CPPASTProblemDeclaration,,<empty>
419004,UNKNOWN,61,,m_pSelection->_coordSelectionAnchor.x = m_pSelection->_srSelectionRect.right;,9,<empty>,,299,61,CPPASTProblemDeclaration,,<empty>
419005,UNKNOWN,62,,VERIFY_IS_TRUE(m_pSelection->_srSelectionRect.bottom == m_pSelection->_srSelectionRect.top);,9,<empty>,,300,62,CPPASTProblemDeclaration,,<empty>
419006,UNKNOWN,63,,m_pSelection->_coordSelectionAnchor.y = m_pSelection->_srSelectionRect.top;,9,<empty>,,301,63,CPPASTProblemDeclaration,,<empty>
419007,UNKNOWN,64,,VerifyGetSelectionRects_LineMode();,9,<empty>,,303,64,CPPASTProblemDeclaration,,<empty>
419008,UNKNOWN,65,,},5,<empty>,,304,65,CPPASTProblemDeclaration,,<empty>
419135,UNKNOWN,1,,size_t,38,<empty>,,337,1,CPPASTTypeId,,<empty>
419182,UNKNOWN,67,,};,1,<empty>,,345,67,CPPASTProblemDeclaration,,<empty>
419212,UNKNOWN,69,,"TEST_METHOD(TestWordByWordPrevious)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
        END_TEST_METHOD_PROPERTIES()

        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,384,69,CPPASTProblemDeclaration,,<empty>
419223,UNKNOWN,74,,screenInfo.Write(OutputCellIterator(text));,9,<empty>,,394,74,CPPASTProblemDeclaration,,<empty>
419264,UNKNOWN,86,,"do
        {
            // We expect the result to be left of where we started.
            // It will point at the character just right of the space (or the beginning of the line).
            auto resultExpected = point;

            do
            {
                resultExpected.x--;
            } while (resultExpected.x > 0 && text.at(resultExpected.x - 1) != UNICODE_SPACE);

            point = sel.WordByWordSelection(true, bufferSize, anchor, point);

            VERIFY_ARE_EQUAL(resultExpected, point);

        }",9,<empty>,,413,86,CPPASTProblemDeclaration,,<empty>
419265,UNKNOWN,87,,while (point.x > left.x);,11,<empty>,,428,87,CPPASTProblemDeclaration,,<empty>
419266,UNKNOWN,88,,},5,<empty>,,429,88,CPPASTProblemDeclaration,,<empty>
419267,UNKNOWN,89,,"TEST_METHOD(TestWordByWordNext)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""IsolationLevel"", L""Method"")
        END_TEST_METHOD_PROPERTIES()

        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();",5,<empty>,,431,89,CPPASTProblemDeclaration,,<empty>
419278,UNKNOWN,94,,screenInfo.Write(OutputCellIterator(text));,9,<empty>,,441,94,CPPASTProblemDeclaration,,<empty>
419319,UNKNOWN,106,,"do
        {
            // We expect the result to be right of where we started.

            auto resultExpected = point;

            do
            {
                resultExpected.x++;
            } while (resultExpected.x + 1 < right.x && text.at(resultExpected.x + 1) != UNICODE_SPACE);
            resultExpected.x++;

            // when we reach the end, word by word selection will seek forward to the end of the buffer, so update
            // the expected to the end in that circumstance
            if (resultExpected.x >= right.x)
            {
                resultExpected.x = bufferSize.RightInclusive();
                resultExpected.y = bufferSize.BottomInclusive();
            }

            point = sel.WordByWordSelection(false, bufferSize, anchor, point);

            VERIFY_ARE_EQUAL(resultExpected, point);

        }",9,<empty>,,460,106,CPPASTProblemDeclaration,,<empty>
419320,UNKNOWN,107,,while (point.y < bufferSize.BottomInclusive());,11,<empty>,,484,107,CPPASTProblemDeclaration,,<empty>
419321,UNKNOWN,108,,},5,<empty>,,485,108,CPPASTProblemDeclaration,,<empty>
419322,UNKNOWN,109,,};,1,<empty>,,486,109,CPPASTProblemDeclaration,,<empty>
419505,UNKNOWN,11,,"TEST_METHOD_SETUP(MethodSetup)
    {
        m_state->PrepareNewTextBufferInfo();",5,<empty>,,99,11,CPPASTProblemDeclaration,,<empty>
419506,UNKNOWN,12,,return true;,9,<empty>,,103,12,CPPASTProblemDeclaration,,<empty>
419507,UNKNOWN,13,,},5,<empty>,,104,13,CPPASTProblemDeclaration,,<empty>
419508,UNKNOWN,14,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,106,14,CPPASTProblemDeclaration,,<empty>
419509,UNKNOWN,15,,return true;,9,<empty>,,110,15,CPPASTProblemDeclaration,,<empty>
419510,UNKNOWN,16,,},5,<empty>,,111,16,CPPASTProblemDeclaration,,<empty>
419936,UNKNOWN,58,,};,1,<empty>,,317,58,CPPASTProblemDeclaration,,<empty>
420317,UNKNOWN,1,,std::wstring_view,32,<empty>,,492,1,CPPASTTypeId,,<empty>
420384,UNKNOWN,1,,int,51,<empty>,,501,1,CPPASTTypeId,,<empty>
420395,UNKNOWN,1,,int,104,<empty>,,501,1,CPPASTTypeId,,<empty>
420745,UNKNOWN,2,,"TEST_METHOD_SETUP(MethodSetup)
    {
        m_state->PrepareNewTextBufferInfo();",5,<empty>,,56,2,CPPASTProblemDeclaration,,<empty>
420746,UNKNOWN,3,,return true;,9,<empty>,,60,3,CPPASTProblemDeclaration,,<empty>
420747,UNKNOWN,4,,},5,<empty>,,61,4,CPPASTProblemDeclaration,,<empty>
420748,UNKNOWN,5,,"TEST_METHOD_CLEANUP(MethodCleanup)
    {
        m_state->CleanupNewTextBufferInfo();",5,<empty>,,63,5,CPPASTProblemDeclaration,,<empty>
420749,UNKNOWN,6,,return true;,9,<empty>,,67,6,CPPASTProblemDeclaration,,<empty>
420750,UNKNOWN,7,,},5,<empty>,,68,7,CPPASTProblemDeclaration,,<empty>
420832,UNKNOWN,63,,};,1,<empty>,,164,63,CPPASTProblemDeclaration,,<empty>
426699,UNKNOWN,-1,,),34,<empty>,,1691,2,CPPASTProblemStatement,,<empty>
426703,UNKNOWN,-1,,),63,<empty>,,1692,4,CPPASTProblemStatement,,<empty>
426707,UNKNOWN,-1,,),63,<empty>,,1693,6,CPPASTProblemStatement,,<empty>
427983,UNKNOWN,-1,,e,21,<empty>,,2071,3,CPPASTProblemStatement,,<empty>
428187,UNKNOWN,1,,size_t,44,<empty>,,2130,1,CPPASTTypeId,,<empty>
428479,UNKNOWN,-1,,),34,<empty>,,2197,15,CPPASTProblemStatement,,<empty>
428483,UNKNOWN,-1,,),73,<empty>,,2198,17,CPPASTProblemStatement,,<empty>
428865,UNKNOWN,-1,,),34,<empty>,,2306,15,CPPASTProblemStatement,,<empty>
428869,UNKNOWN,-1,,),70,<empty>,,2307,17,CPPASTProblemStatement,,<empty>
429039,UNKNOWN,-1,,),34,<empty>,,2352,4,CPPASTProblemStatement,,<empty>
429043,UNKNOWN,-1,,),65,<empty>,,2353,6,CPPASTProblemStatement,,<empty>
429232,UNKNOWN,-1,,),34,<empty>,,2415,15,CPPASTProblemStatement,,<empty>
429236,UNKNOWN,-1,,),70,<empty>,,2416,17,CPPASTProblemStatement,,<empty>
429415,UNKNOWN,-1,,),34,<empty>,,2457,2,CPPASTProblemStatement,,<empty>
429419,UNKNOWN,-1,,),67,<empty>,,2458,4,CPPASTProblemStatement,,<empty>
429423,UNKNOWN,-1,,),70,<empty>,,2459,6,CPPASTProblemStatement,,<empty>
429427,UNKNOWN,-1,,),67,<empty>,,2460,8,CPPASTProblemStatement,,<empty>
429431,UNKNOWN,-1,,),78,<empty>,,2461,10,CPPASTProblemStatement,,<empty>
430360,UNKNOWN,-1,,),38,<empty>,,34,2,CPPASTProblemStatement,,<empty>
430364,UNKNOWN,-1,,),117,<empty>,,35,4,CPPASTProblemStatement,,<empty>
430368,UNKNOWN,-1,,),68,<empty>,,36,6,CPPASTProblemStatement,,<empty>
430372,UNKNOWN,-1,,),70,<empty>,,37,8,CPPASTProblemStatement,,<empty>
430503,UNKNOWN,2,,};,1,<empty>,,114,2,CPPASTProblemDeclaration,,<empty>
430579,UNKNOWN,1,,unsigned int,37,<empty>,,61,1,CPPASTTypeId,,<empty>
430584,UNKNOWN,1,,unsigned int,38,<empty>,,62,1,CPPASTTypeId,,<empty>
430596,UNKNOWN,1,,unsigned char*,48,<empty>,,65,1,CPPASTTypeId,,<empty>
430623,UNKNOWN,2,,"TEST_METHOD(WaitsForAdditionalInputAfterPartialSequenceTest)
    {
        Log::Comment(L""Testing that nothing is returned when parsing a partial sequence until the sequence is complete"");",5,<empty>,,72,2,CPPASTProblemDeclaration,,<empty>
430660,UNKNOWN,17,,for (auto i = 0;,9,<empty>,,84,17,CPPASTProblemDeclaration,,<empty>
430661,UNKNOWN,18,,i < 2;,26,<empty>,,84,18,CPPASTProblemDeclaration,,<empty>
430662,UNKNOWN,19,,"++i)
        {
            VERIFY_SUCCEEDED(parser.Parse(shi + i, count, consumed, output, generated));
            VERIFY_ARE_EQUAL(consumed, (unsigned int)1);
            VERIFY_ARE_EQUAL(generated, (unsigned int)0);
            VERIFY_ARE_EQUAL(output.get(), nullptr);
            count = 1;
        }",33,<empty>,,84,19,CPPASTProblemDeclaration,,<empty>
430663,UNKNOWN,20,,"VERIFY_SUCCEEDED(parser.Parse(shi + 2, count, consumed, output, generated));",9,<empty>,,93,20,CPPASTProblemDeclaration,,<empty>
430664,UNKNOWN,21,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)1);",9,<empty>,,94,21,CPPASTProblemDeclaration,,<empty>
430665,UNKNOWN,22,,"VERIFY_ARE_EQUAL(generated, (unsigned int)1);",9,<empty>,,95,22,CPPASTProblemDeclaration,,<empty>
430666,UNKNOWN,23,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,96,23,CPPASTProblemDeclaration,,<empty>
430671,UNKNOWN,1,,unsigned char*,48,<empty>,,98,1,CPPASTTypeId,,<empty>
430676,UNKNOWN,26,,for (auto i = 0;,9,<empty>,,99,26,CPPASTProblemDeclaration,,<empty>
430677,UNKNOWN,27,,i < ARRAYSIZE(wideShi);,26,<empty>,,99,27,CPPASTProblemDeclaration,,<empty>
430678,UNKNOWN,28,,"++i)
        {
            VERIFY_ARE_EQUAL(wideShi[i], pReturnedBytes[i]);
        }",50,<empty>,,99,28,CPPASTProblemDeclaration,,<empty>
430679,UNKNOWN,29,,},5,<empty>,,103,29,CPPASTProblemDeclaration,,<empty>
430680,UNKNOWN,30,,"TEST_METHOD(ReturnsInitialPartOfSequenceThatEndsWithPartialTest)
    {
        Log::Comment(L""Testing that a valid portion of a sequence is returned when it ends with a partial sequence"");",5,<empty>,,105,30,CPPASTProblemDeclaration,,<empty>
430722,UNKNOWN,45,,"VERIFY_SUCCEEDED(parser.Parse(sushi, count, consumed, output, generated));",9,<empty>,,117,45,CPPASTProblemDeclaration,,<empty>
430723,UNKNOWN,46,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)4);",9,<empty>,,119,46,CPPASTProblemDeclaration,,<empty>
430724,UNKNOWN,47,,"VERIFY_ARE_EQUAL(generated, (unsigned int)1);",9,<empty>,,120,47,CPPASTProblemDeclaration,,<empty>
430725,UNKNOWN,48,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,121,48,CPPASTProblemDeclaration,,<empty>
430730,UNKNOWN,1,,unsigned char*,48,<empty>,,123,1,CPPASTTypeId,,<empty>
430735,UNKNOWN,51,,for (auto i = 0;,9,<empty>,,124,51,CPPASTProblemDeclaration,,<empty>
430736,UNKNOWN,52,,i < 2;,26,<empty>,,124,52,CPPASTProblemDeclaration,,<empty>
430737,UNKNOWN,53,,"++i)
        {
            VERIFY_ARE_EQUAL(wideSushi[i], pReturnedBytes[i]);
        }",33,<empty>,,124,53,CPPASTProblemDeclaration,,<empty>
430738,UNKNOWN,54,,count = 1;,9,<empty>,,130,54,CPPASTProblemDeclaration,,<empty>
430739,UNKNOWN,55,,consumed = 0;,9,<empty>,,131,55,CPPASTProblemDeclaration,,<empty>
430740,UNKNOWN,56,,generated = 0;,9,<empty>,,132,56,CPPASTProblemDeclaration,,<empty>
430741,UNKNOWN,57,,output.reset(nullptr);,9,<empty>,,133,57,CPPASTProblemDeclaration,,<empty>
430742,UNKNOWN,58,,"VERIFY_SUCCEEDED(parser.Parse(sushi + 4, count, consumed, output, generated));",9,<empty>,,134,58,CPPASTProblemDeclaration,,<empty>
430743,UNKNOWN,59,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)1);",9,<empty>,,135,59,CPPASTProblemDeclaration,,<empty>
430744,UNKNOWN,60,,"VERIFY_ARE_EQUAL(generated, (unsigned int)0);",9,<empty>,,136,60,CPPASTProblemDeclaration,,<empty>
430745,UNKNOWN,61,,"VERIFY_ARE_EQUAL(output.get(), nullptr);",9,<empty>,,137,61,CPPASTProblemDeclaration,,<empty>
430746,UNKNOWN,62,,count = 1;,9,<empty>,,140,62,CPPASTProblemDeclaration,,<empty>
430747,UNKNOWN,63,,consumed = 0;,9,<empty>,,141,63,CPPASTProblemDeclaration,,<empty>
430748,UNKNOWN,64,,generated = 0;,9,<empty>,,142,64,CPPASTProblemDeclaration,,<empty>
430749,UNKNOWN,65,,output.reset(nullptr);,9,<empty>,,143,65,CPPASTProblemDeclaration,,<empty>
430750,UNKNOWN,66,,"VERIFY_SUCCEEDED(parser.Parse(sushi + 5, count, consumed, output, generated));",9,<empty>,,144,66,CPPASTProblemDeclaration,,<empty>
430751,UNKNOWN,67,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)1);",9,<empty>,,145,67,CPPASTProblemDeclaration,,<empty>
430752,UNKNOWN,68,,"VERIFY_ARE_EQUAL(generated, (unsigned int)1);",9,<empty>,,146,68,CPPASTProblemDeclaration,,<empty>
430753,UNKNOWN,69,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,147,69,CPPASTProblemDeclaration,,<empty>
430754,UNKNOWN,70,,pReturnedBytes = reinterpret_cast<unsigned char*>(output.get());,9,<empty>,,149,70,CPPASTProblemDeclaration,,<empty>
430755,UNKNOWN,71,,for (auto i = 0;,9,<empty>,,150,71,CPPASTProblemDeclaration,,<empty>
430756,UNKNOWN,72,,i < 2;,26,<empty>,,150,72,CPPASTProblemDeclaration,,<empty>
430757,UNKNOWN,73,,"++i)
        {
            VERIFY_ARE_EQUAL(wideSushi[i + 2], pReturnedBytes[i]);
        }",33,<empty>,,150,73,CPPASTProblemDeclaration,,<empty>
430758,UNKNOWN,74,,},5,<empty>,,154,74,CPPASTProblemDeclaration,,<empty>
430759,UNKNOWN,75,,"TEST_METHOD(MergesMultiplePartialSequencesTest)
    {
        Log::Comment(L""Testing that partial sequences sent individually will be merged together"");",5,<empty>,,156,75,CPPASTProblemDeclaration,,<empty>
430831,UNKNOWN,90,,"VERIFY_SUCCEEDED(parser.Parse(doomoArigatoo, count, consumed, output, generated));",9,<empty>,,191,90,CPPASTProblemDeclaration,,<empty>
430832,UNKNOWN,91,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)4);",9,<empty>,,192,91,CPPASTProblemDeclaration,,<empty>
430833,UNKNOWN,92,,"VERIFY_ARE_EQUAL(generated, (unsigned int)1);",9,<empty>,,193,92,CPPASTProblemDeclaration,,<empty>
430834,UNKNOWN,93,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,194,93,CPPASTProblemDeclaration,,<empty>
430839,UNKNOWN,1,,unsigned char*,48,<empty>,,196,1,CPPASTTypeId,,<empty>
430844,UNKNOWN,96,,for (auto i = 0;,9,<empty>,,197,96,CPPASTProblemDeclaration,,<empty>
430845,UNKNOWN,97,,i < 2;,26,<empty>,,197,97,CPPASTProblemDeclaration,,<empty>
430846,UNKNOWN,98,,"++i)
        {
            VERIFY_ARE_EQUAL(wideDoomoArigatoo[i], pReturnedBytes[i]);
        }",33,<empty>,,197,98,CPPASTProblemDeclaration,,<empty>
430847,UNKNOWN,99,,count = 16;,9,<empty>,,203,99,CPPASTProblemDeclaration,,<empty>
430848,UNKNOWN,100,,consumed = 0;,9,<empty>,,204,100,CPPASTProblemDeclaration,,<empty>
430849,UNKNOWN,101,,generated = 0;,9,<empty>,,205,101,CPPASTProblemDeclaration,,<empty>
430850,UNKNOWN,102,,output.reset(nullptr);,9,<empty>,,206,102,CPPASTProblemDeclaration,,<empty>
430851,UNKNOWN,103,,"VERIFY_SUCCEEDED(parser.Parse(doomoArigatoo + 4, count, consumed, output, generated));",9,<empty>,,207,103,CPPASTProblemDeclaration,,<empty>
430852,UNKNOWN,104,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)16);",9,<empty>,,208,104,CPPASTProblemDeclaration,,<empty>
430853,UNKNOWN,105,,"VERIFY_ARE_EQUAL(generated, (unsigned int)5);",9,<empty>,,209,105,CPPASTProblemDeclaration,,<empty>
430854,UNKNOWN,106,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,210,106,CPPASTProblemDeclaration,,<empty>
430855,UNKNOWN,107,,pReturnedBytes = reinterpret_cast<unsigned char*>(output.get());,9,<empty>,,212,107,CPPASTProblemDeclaration,,<empty>
430856,UNKNOWN,108,,for (auto i = 0;,9,<empty>,,213,108,CPPASTProblemDeclaration,,<empty>
430857,UNKNOWN,109,,i < 10;,26,<empty>,,213,109,CPPASTProblemDeclaration,,<empty>
430858,UNKNOWN,110,,"++i)
        {
            VERIFY_ARE_EQUAL(wideDoomoArigatoo[i + 2], pReturnedBytes[i]);
        }",34,<empty>,,213,110,CPPASTProblemDeclaration,,<empty>
430859,UNKNOWN,111,,count = 4;,9,<empty>,,219,111,CPPASTProblemDeclaration,,<empty>
430860,UNKNOWN,112,,consumed = 0;,9,<empty>,,220,112,CPPASTProblemDeclaration,,<empty>
430861,UNKNOWN,113,,generated = 0;,9,<empty>,,221,113,CPPASTProblemDeclaration,,<empty>
430862,UNKNOWN,114,,output.reset(nullptr);,9,<empty>,,222,114,CPPASTProblemDeclaration,,<empty>
430863,UNKNOWN,115,,"VERIFY_SUCCEEDED(parser.Parse(doomoArigatoo + 20, count, consumed, output, generated));",9,<empty>,,223,115,CPPASTProblemDeclaration,,<empty>
430864,UNKNOWN,116,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)4);",9,<empty>,,224,116,CPPASTProblemDeclaration,,<empty>
430865,UNKNOWN,117,,"VERIFY_ARE_EQUAL(generated, (unsigned int)2);",9,<empty>,,225,117,CPPASTProblemDeclaration,,<empty>
430866,UNKNOWN,118,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,226,118,CPPASTProblemDeclaration,,<empty>
430867,UNKNOWN,119,,pReturnedBytes = reinterpret_cast<unsigned char*>(output.get());,9,<empty>,,228,119,CPPASTProblemDeclaration,,<empty>
430868,UNKNOWN,120,,for (auto i = 0;,9,<empty>,,229,120,CPPASTProblemDeclaration,,<empty>
430869,UNKNOWN,121,,i < 4;,26,<empty>,,229,121,CPPASTProblemDeclaration,,<empty>
430870,UNKNOWN,122,,"++i)
        {
            VERIFY_ARE_EQUAL(wideDoomoArigatoo[i + 12], pReturnedBytes[i]);
        }",33,<empty>,,229,122,CPPASTProblemDeclaration,,<empty>
430871,UNKNOWN,123,,},5,<empty>,,233,123,CPPASTProblemDeclaration,,<empty>
430872,UNKNOWN,124,,"TEST_METHOD(RemovesInvalidSequencesTest)
    {
        Log::Comment(L""Testing that invalid sequences are removed and don't stop the parsing of the rest"");",5,<empty>,,235,124,CPPASTProblemDeclaration,,<empty>
430917,UNKNOWN,139,,"VERIFY_SUCCEEDED(parser.Parse(sushi, count, consumed, output, generated));",9,<empty>,,255,139,CPPASTProblemDeclaration,,<empty>
430918,UNKNOWN,140,,"VERIFY_ARE_EQUAL(consumed, (unsigned int)9);",9,<empty>,,256,140,CPPASTProblemDeclaration,,<empty>
430919,UNKNOWN,141,,"VERIFY_ARE_EQUAL(generated, (unsigned int)2);",9,<empty>,,257,141,CPPASTProblemDeclaration,,<empty>
430920,UNKNOWN,142,,"VERIFY_ARE_NOT_EQUAL(output.get(), nullptr);",9,<empty>,,258,142,CPPASTProblemDeclaration,,<empty>
430925,UNKNOWN,1,,unsigned char*,48,<empty>,,260,1,CPPASTTypeId,,<empty>
430930,UNKNOWN,145,,for (auto i = 0;,9,<empty>,,261,145,CPPASTProblemDeclaration,,<empty>
430931,UNKNOWN,146,,i < ARRAYSIZE(wideSushi);,26,<empty>,,261,146,CPPASTProblemDeclaration,,<empty>
430932,UNKNOWN,147,,"++i)
        {
            VERIFY_ARE_EQUAL(wideSushi[i], pReturnedBytes[i]);
        }",52,<empty>,,261,147,CPPASTProblemDeclaration,,<empty>
430933,UNKNOWN,148,,},5,<empty>,,265,148,CPPASTProblemDeclaration,,<empty>
430934,UNKNOWN,149,,"TEST_METHOD(NonMinimalFormTest)
    {
        Log::Comment(L""Testing that non-minimal forms of a character are tolerated don't stop the rest"");",5,<empty>,,267,149,CPPASTProblemDeclaration,,<empty>
431028,UNKNOWN,166,,"VERIFY_SUCCEEDED(parser.Parse(data, count, consumed, output, generated));",9,<empty>,,304,166,CPPASTProblemDeclaration,,<empty>
431029,UNKNOWN,167,,"VERIFY_ARE_EQUAL(count, consumed);",9,<empty>,,305,167,CPPASTProblemDeclaration,,<empty>
431030,UNKNOWN,168,,"VERIFY_ARE_EQUAL(wideCount, generated);",9,<empty>,,306,168,CPPASTProblemDeclaration,,<empty>
431031,UNKNOWN,169,,VERIFY_IS_NOT_NULL(output.get());,9,<empty>,,307,169,CPPASTProblemDeclaration,,<empty>
431057,UNKNOWN,174,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,311,174,CPPASTProblemDeclaration,,<empty>
431058,UNKNOWN,175,,},5,<empty>,,312,175,CPPASTProblemDeclaration,,<empty>
431059,UNKNOWN,176,,"TEST_METHOD(PartialBytesAreDroppedOnCodePageChangeTest)
    {
        Log::Comment(L""Testing that a saved partial sequence is cleared when the codepage changes"");",5,<empty>,,314,176,CPPASTProblemDeclaration,,<empty>
431093,UNKNOWN,191,,"VERIFY_SUCCEEDED(parser.Parse(partialSequence, count, consumed, output, generated));",9,<empty>,,325,191,CPPASTProblemDeclaration,,<empty>
431094,UNKNOWN,192,,"VERIFY_ARE_EQUAL(parser._currentState, Utf8ToWideCharParser::_State::BeginPartialParse);",9,<empty>,,326,192,CPPASTProblemDeclaration,,<empty>
431095,UNKNOWN,193,,"VERIFY_ARE_EQUAL(parser._bytesStored, inputSize);",9,<empty>,,327,193,CPPASTProblemDeclaration,,<empty>
431096,UNKNOWN,194,,parser.SetCodePage(utf8CodePage);,9,<empty>,,330,194,CPPASTProblemDeclaration,,<empty>
431097,UNKNOWN,195,,"VERIFY_ARE_EQUAL(parser._currentState, Utf8ToWideCharParser::_State::BeginPartialParse);",9,<empty>,,331,195,CPPASTProblemDeclaration,,<empty>
431098,UNKNOWN,196,,"VERIFY_ARE_EQUAL(parser._bytesStored, inputSize);",9,<empty>,,332,196,CPPASTProblemDeclaration,,<empty>
431099,UNKNOWN,197,,parser.SetCodePage(USACodePage);,9,<empty>,,334,197,CPPASTProblemDeclaration,,<empty>
431100,UNKNOWN,198,,"VERIFY_ARE_EQUAL(parser._currentState, Utf8ToWideCharParser::_State::Ready);",9,<empty>,,335,198,CPPASTProblemDeclaration,,<empty>
431101,UNKNOWN,199,,"VERIFY_ARE_EQUAL(parser._bytesStored, (unsigned int)0);",9,<empty>,,336,199,CPPASTProblemDeclaration,,<empty>
431102,UNKNOWN,200,,},5,<empty>,,337,200,CPPASTProblemDeclaration,,<empty>
431103,UNKNOWN,201,,"TEST_METHOD(_IsLeadByteTest)
    {
        Log::Comment(L""Testing that _IsLeadByte properly differentiates correct from incorrect sequences"");",5,<empty>,,339,201,CPPASTProblemDeclaration,,<empty>
431110,UNKNOWN,204,,VERIFY_IS_TRUE(parser._IsLeadByte(0xC0));,9,<empty>,,343,204,CPPASTProblemDeclaration,,<empty>
431111,UNKNOWN,205,,VERIFY_IS_TRUE(parser._IsLeadByte(0xE0));,9,<empty>,,344,205,CPPASTProblemDeclaration,,<empty>
431112,UNKNOWN,206,,VERIFY_IS_TRUE(parser._IsLeadByte(0xF0));,9,<empty>,,345,206,CPPASTProblemDeclaration,,<empty>
431113,UNKNOWN,207,,VERIFY_IS_FALSE(parser._IsLeadByte(0x00));,9,<empty>,,346,207,CPPASTProblemDeclaration,,<empty>
431114,UNKNOWN,208,,VERIFY_IS_FALSE(parser._IsLeadByte(0x80));,9,<empty>,,347,208,CPPASTProblemDeclaration,,<empty>
431115,UNKNOWN,209,,VERIFY_IS_FALSE(parser._IsLeadByte(0x83));,9,<empty>,,348,209,CPPASTProblemDeclaration,,<empty>
431116,UNKNOWN,210,,VERIFY_IS_FALSE(parser._IsLeadByte(0x7E));,9,<empty>,,349,210,CPPASTProblemDeclaration,,<empty>
431117,UNKNOWN,211,,VERIFY_IS_FALSE(parser._IsLeadByte(0x21));,9,<empty>,,350,211,CPPASTProblemDeclaration,,<empty>
431118,UNKNOWN,212,,VERIFY_IS_FALSE(parser._IsLeadByte(0xF8));,9,<empty>,,351,212,CPPASTProblemDeclaration,,<empty>
431119,UNKNOWN,213,,VERIFY_IS_FALSE(parser._IsLeadByte(0xFC));,9,<empty>,,352,213,CPPASTProblemDeclaration,,<empty>
431120,UNKNOWN,214,,VERIFY_IS_FALSE(parser._IsLeadByte(0xFE));,9,<empty>,,353,214,CPPASTProblemDeclaration,,<empty>
431121,UNKNOWN,215,,VERIFY_IS_FALSE(parser._IsLeadByte(0xFF));,9,<empty>,,354,215,CPPASTProblemDeclaration,,<empty>
431122,UNKNOWN,216,,},5,<empty>,,355,216,CPPASTProblemDeclaration,,<empty>
431123,UNKNOWN,217,,"TEST_METHOD(_IsContinuationByteTest)
    {
        Log::Comment(L""Testing that _IsContinuationByte properly differentiates correct from incorrect sequences"");",5,<empty>,,357,217,CPPASTProblemDeclaration,,<empty>
431130,UNKNOWN,220,,for (BYTE i = 0x00;,9,<empty>,,361,220,CPPASTProblemDeclaration,,<empty>
431131,UNKNOWN,221,,i < 0xFF;,29,<empty>,,361,221,CPPASTProblemDeclaration,,<empty>
431132,UNKNOWN,222,,"++i)
        {
            if (IsBitSet(i, 0x80) && !IsBitSet(i, 0x40))
            {
                VERIFY_IS_TRUE(parser._IsContinuationByte(i), NoThrowString().Format(L""Byte is 0x%02x"", i));
            }
            else
            {
                VERIFY_IS_FALSE(parser._IsContinuationByte(i), NoThrowString().Format(L""Byte is 0x%02x"", i));
            }
        }",39,<empty>,,361,222,CPPASTProblemDeclaration,,<empty>
431133,UNKNOWN,223,,VERIFY_IS_FALSE(parser._IsContinuationByte(0xFF));,9,<empty>,,372,223,CPPASTProblemDeclaration,,<empty>
431134,UNKNOWN,224,,},5,<empty>,,373,224,CPPASTProblemDeclaration,,<empty>
431135,UNKNOWN,225,,"TEST_METHOD(_IsAsciiByteTest)
    {
        Log::Comment(L""Testing that _IsAsciiByte properly differentiates correct from incorrect sequences"");",5,<empty>,,375,225,CPPASTProblemDeclaration,,<empty>
431142,UNKNOWN,228,,for (BYTE i = 0x00;,9,<empty>,,379,228,CPPASTProblemDeclaration,,<empty>
431143,UNKNOWN,229,,i < 0x80;,29,<empty>,,379,229,CPPASTProblemDeclaration,,<empty>
431144,UNKNOWN,230,,"++i)
        {
            VERIFY_IS_TRUE(parser._IsAsciiByte(i), NoThrowString().Format(L""Byte is 0x%02x"", i));
        }",39,<empty>,,379,230,CPPASTProblemDeclaration,,<empty>
431145,UNKNOWN,231,,for (BYTE i = 0xFF;,9,<empty>,,383,231,CPPASTProblemDeclaration,,<empty>
431146,UNKNOWN,232,,i > 0x7F;,29,<empty>,,383,232,CPPASTProblemDeclaration,,<empty>
431147,UNKNOWN,233,,"--i)
        {
            VERIFY_IS_FALSE(parser._IsAsciiByte(i), NoThrowString().Format(L""Byte is 0x%02x"", i));
        }",39,<empty>,,383,233,CPPASTProblemDeclaration,,<empty>
431148,UNKNOWN,234,,},5,<empty>,,387,234,CPPASTProblemDeclaration,,<empty>
431149,UNKNOWN,235,,"TEST_METHOD(_Utf8SequenceSizeTest)
    {
        Log::Comment(L""Testing that _Utf8SequenceSize correctly counts the number of MSB 1's"");",5,<empty>,,389,235,CPPASTProblemDeclaration,,<empty>
431156,UNKNOWN,238,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0x00), (unsigned int)0);",9,<empty>,,393,238,CPPASTProblemDeclaration,,<empty>
431157,UNKNOWN,239,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0x80), (unsigned int)1);",9,<empty>,,394,239,CPPASTProblemDeclaration,,<empty>
431158,UNKNOWN,240,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xC2), (unsigned int)2);",9,<empty>,,395,240,CPPASTProblemDeclaration,,<empty>
431159,UNKNOWN,241,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xE3), (unsigned int)3);",9,<empty>,,396,241,CPPASTProblemDeclaration,,<empty>
431160,UNKNOWN,242,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xF0), (unsigned int)4);",9,<empty>,,397,242,CPPASTProblemDeclaration,,<empty>
431161,UNKNOWN,243,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xF3), (unsigned int)4);",9,<empty>,,398,243,CPPASTProblemDeclaration,,<empty>
431162,UNKNOWN,244,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xF8), (unsigned int)5);",9,<empty>,,399,244,CPPASTProblemDeclaration,,<empty>
431163,UNKNOWN,245,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xFC), (unsigned int)6);",9,<empty>,,400,245,CPPASTProblemDeclaration,,<empty>
431164,UNKNOWN,246,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xFD), (unsigned int)6);",9,<empty>,,401,246,CPPASTProblemDeclaration,,<empty>
431165,UNKNOWN,247,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xFE), (unsigned int)7);",9,<empty>,,402,247,CPPASTProblemDeclaration,,<empty>
431166,UNKNOWN,248,,"VERIFY_ARE_EQUAL(parser._Utf8SequenceSize(0xFF), (unsigned int)8);",9,<empty>,,403,248,CPPASTProblemDeclaration,,<empty>
431167,UNKNOWN,249,,},5,<empty>,,404,249,CPPASTProblemDeclaration,,<empty>
431168,UNKNOWN,250,,};,1,<empty>,,405,250,CPPASTProblemDeclaration,,<empty>
431216,UNKNOWN,1,,til::CoordType,18,<empty>,,58,1,CPPASTTypeId,,<empty>
431296,UNKNOWN,6,,"TEST_METHOD(TestCompareCoords)
    {
        auto result = 5;",5,<empty>,,81,6,CPPASTProblemDeclaration,,<empty>
431300,UNKNOWN,10,,coordMaxBuffer.width = SHORT_MAX;,9,<empty>,,89,10,CPPASTProblemDeclaration,,<empty>
431301,UNKNOWN,11,,coordMaxBuffer.height = SHORT_MAX;,9,<empty>,,90,11,CPPASTProblemDeclaration,,<empty>
431302,UNKNOWN,12,,"Log::Comment(L""#1: 0 case. Coords equal"");",9,<empty>,,92,12,CPPASTProblemDeclaration,,<empty>
431303,UNKNOWN,13,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,93,13,CPPASTProblemDeclaration,,<empty>
431304,UNKNOWN,14,,"LogCoordinates(coordA, coordB);",9,<empty>,,94,14,CPPASTProblemDeclaration,,<empty>
431305,UNKNOWN,15,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,95,15,CPPASTProblemDeclaration,,<empty>
431306,UNKNOWN,16,,"VERIFY_ARE_EQUAL(result, 0);",9,<empty>,,96,16,CPPASTProblemDeclaration,,<empty>
431307,UNKNOWN,17,,"Log::Comment(L""#2: -1 case. A comes before B"");",9,<empty>,,98,17,CPPASTProblemDeclaration,,<empty>
431308,UNKNOWN,18,,"Log::Comment(L""A. A left of B, same line"");",9,<empty>,,99,18,CPPASTProblemDeclaration,,<empty>
431309,UNKNOWN,19,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,100,19,CPPASTProblemDeclaration,,<empty>
431310,UNKNOWN,20,,SubtractRandom(coordA.x);,9,<empty>,,101,20,CPPASTProblemDeclaration,,<empty>
431311,UNKNOWN,21,,"LogCoordinates(coordA, coordB);",9,<empty>,,102,21,CPPASTProblemDeclaration,,<empty>
431312,UNKNOWN,22,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,103,22,CPPASTProblemDeclaration,,<empty>
431313,UNKNOWN,23,,"VERIFY_IS_LESS_THAN(result, 0);",9,<empty>,,104,23,CPPASTProblemDeclaration,,<empty>
431314,UNKNOWN,24,,"Log::Comment(L""B. A above B, same column"");",9,<empty>,,106,24,CPPASTProblemDeclaration,,<empty>
431315,UNKNOWN,25,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,107,25,CPPASTProblemDeclaration,,<empty>
431316,UNKNOWN,26,,SubtractRandom(coordA.y);,9,<empty>,,108,26,CPPASTProblemDeclaration,,<empty>
431317,UNKNOWN,27,,"LogCoordinates(coordA, coordB);",9,<empty>,,109,27,CPPASTProblemDeclaration,,<empty>
431318,UNKNOWN,28,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,110,28,CPPASTProblemDeclaration,,<empty>
431319,UNKNOWN,29,,"VERIFY_IS_LESS_THAN(result, 0);",9,<empty>,,111,29,CPPASTProblemDeclaration,,<empty>
431320,UNKNOWN,30,,"Log::Comment(L""C. A up and to the left of B."");",9,<empty>,,113,30,CPPASTProblemDeclaration,,<empty>
431321,UNKNOWN,31,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,114,31,CPPASTProblemDeclaration,,<empty>
431322,UNKNOWN,32,,SubtractRandom(coordA.y);,9,<empty>,,115,32,CPPASTProblemDeclaration,,<empty>
431323,UNKNOWN,33,,SubtractRandom(coordA.x);,9,<empty>,,116,33,CPPASTProblemDeclaration,,<empty>
431324,UNKNOWN,34,,"LogCoordinates(coordA, coordB);",9,<empty>,,117,34,CPPASTProblemDeclaration,,<empty>
431325,UNKNOWN,35,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,118,35,CPPASTProblemDeclaration,,<empty>
431326,UNKNOWN,36,,"VERIFY_IS_LESS_THAN(result, 0);",9,<empty>,,119,36,CPPASTProblemDeclaration,,<empty>
431327,UNKNOWN,37,,"Log::Comment(L""D. A up and to the right of B."");",9,<empty>,,121,37,CPPASTProblemDeclaration,,<empty>
431328,UNKNOWN,38,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,122,38,CPPASTProblemDeclaration,,<empty>
431329,UNKNOWN,39,,SubtractRandom(coordA.y);,9,<empty>,,123,39,CPPASTProblemDeclaration,,<empty>
431330,UNKNOWN,40,,SubtractRandom(coordB.x);,9,<empty>,,124,40,CPPASTProblemDeclaration,,<empty>
431331,UNKNOWN,41,,"LogCoordinates(coordA, coordB);",9,<empty>,,125,41,CPPASTProblemDeclaration,,<empty>
431332,UNKNOWN,42,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,126,42,CPPASTProblemDeclaration,,<empty>
431333,UNKNOWN,43,,"VERIFY_IS_LESS_THAN(result, 0);",9,<empty>,,127,43,CPPASTProblemDeclaration,,<empty>
431334,UNKNOWN,44,,"Log::Comment(L""#3: 1 case. A comes after B"");",9,<empty>,,129,44,CPPASTProblemDeclaration,,<empty>
431335,UNKNOWN,45,,"Log::Comment(L""A. A right of B, same line"");",9,<empty>,,130,45,CPPASTProblemDeclaration,,<empty>
431336,UNKNOWN,46,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,131,46,CPPASTProblemDeclaration,,<empty>
431337,UNKNOWN,47,,SubtractRandom(coordB.x);,9,<empty>,,132,47,CPPASTProblemDeclaration,,<empty>
431338,UNKNOWN,48,,"LogCoordinates(coordA, coordB);",9,<empty>,,133,48,CPPASTProblemDeclaration,,<empty>
431339,UNKNOWN,49,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,134,49,CPPASTProblemDeclaration,,<empty>
431340,UNKNOWN,50,,"VERIFY_IS_GREATER_THAN(result, 0);",9,<empty>,,135,50,CPPASTProblemDeclaration,,<empty>
431341,UNKNOWN,51,,"Log::Comment(L""B. A below B, same column"");",9,<empty>,,137,51,CPPASTProblemDeclaration,,<empty>
431342,UNKNOWN,52,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,138,52,CPPASTProblemDeclaration,,<empty>
431343,UNKNOWN,53,,SubtractRandom(coordB.y);,9,<empty>,,139,53,CPPASTProblemDeclaration,,<empty>
431344,UNKNOWN,54,,"LogCoordinates(coordA, coordB);",9,<empty>,,140,54,CPPASTProblemDeclaration,,<empty>
431345,UNKNOWN,55,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,141,55,CPPASTProblemDeclaration,,<empty>
431346,UNKNOWN,56,,"VERIFY_IS_GREATER_THAN(result, 0);",9,<empty>,,142,56,CPPASTProblemDeclaration,,<empty>
431347,UNKNOWN,57,,"Log::Comment(L""C. A down and to the left of B"");",9,<empty>,,144,57,CPPASTProblemDeclaration,,<empty>
431348,UNKNOWN,58,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,145,58,CPPASTProblemDeclaration,,<empty>
431349,UNKNOWN,59,,SubtractRandom(coordB.y);,9,<empty>,,146,59,CPPASTProblemDeclaration,,<empty>
431350,UNKNOWN,60,,SubtractRandom(coordA.x);,9,<empty>,,147,60,CPPASTProblemDeclaration,,<empty>
431351,UNKNOWN,61,,"LogCoordinates(coordA, coordB);",9,<empty>,,148,61,CPPASTProblemDeclaration,,<empty>
431352,UNKNOWN,62,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,149,62,CPPASTProblemDeclaration,,<empty>
431353,UNKNOWN,63,,"VERIFY_IS_GREATER_THAN(result, 0);",9,<empty>,,150,63,CPPASTProblemDeclaration,,<empty>
431354,UNKNOWN,64,,"Log::Comment(L""D. A down and to the right of B"");",9,<empty>,,152,64,CPPASTProblemDeclaration,,<empty>
431355,UNKNOWN,65,,"FillBothCoordsSameRandom(&coordA, &coordB);",9,<empty>,,153,65,CPPASTProblemDeclaration,,<empty>
431356,UNKNOWN,66,,SubtractRandom(coordB.y);,9,<empty>,,154,66,CPPASTProblemDeclaration,,<empty>
431357,UNKNOWN,67,,SubtractRandom(coordB.x);,9,<empty>,,155,67,CPPASTProblemDeclaration,,<empty>
431358,UNKNOWN,68,,"LogCoordinates(coordA, coordB);",9,<empty>,,156,68,CPPASTProblemDeclaration,,<empty>
431359,UNKNOWN,69,,"result = Utils::s_CompareCoords(coordMaxBuffer, coordA, coordB);",9,<empty>,,157,69,CPPASTProblemDeclaration,,<empty>
431360,UNKNOWN,70,,"VERIFY_IS_GREATER_THAN(result, 0);",9,<empty>,,158,70,CPPASTProblemDeclaration,,<empty>
431361,UNKNOWN,71,,},5,<empty>,,159,71,CPPASTProblemDeclaration,,<empty>
431362,UNKNOWN,72,,};,1,<empty>,,160,72,CPPASTProblemDeclaration,,<empty>
431378,UNKNOWN,1,,"class ViewportTests
{
    TEST_CLASS(ViewportTests);

    TEST_METHOD(CreateEmpty)
    {
        const auto v = Viewport::Empty();

        VERIFY_ARE_EQUAL(0, v.Left());
        VERIFY_ARE_EQUAL(-1, v.RightInclusive());
        VERIFY_ARE_EQUAL(0, v.RightExclusive());
        VERIFY_ARE_EQUAL(0, v.Top());
        VERIFY_ARE_EQUAL(-1, v.BottomInclusive());
        VERIFY_ARE_EQUAL(0, v.BottomExclusive());
        VERIFY_ARE_EQUAL(0, v.Height());
        VERIFY_ARE_EQUAL(0, v.Width());
        VERIFY_ARE_EQUAL(til::point{}, v.Origin());",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
431379,UNKNOWN,2,,VERIFY_ARE_EQUAL(til::size{,9,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
431380,UNKNOWN,3,,},36,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
431381,UNKNOWN,4,,", v.Dimensions());",37,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
431382,UNKNOWN,5,,},5,<empty>,,34,5,CPPASTProblemDeclaration,,<empty>
431383,UNKNOWN,6,,"TEST_METHOD(CreateFromInclusive)
    {
        til::inclusive_rect rect;",5,<empty>,,36,6,CPPASTProblemDeclaration,,<empty>
431384,UNKNOWN,7,,rect.top = 3;,9,<empty>,,39,7,CPPASTProblemDeclaration,,<empty>
431385,UNKNOWN,8,,rect.bottom = 5;,9,<empty>,,40,8,CPPASTProblemDeclaration,,<empty>
431386,UNKNOWN,9,,rect.left = 10;,9,<empty>,,41,9,CPPASTProblemDeclaration,,<empty>
431387,UNKNOWN,10,,rect.right = 20;,9,<empty>,,42,10,CPPASTProblemDeclaration,,<empty>
431389,UNKNOWN,12,,origin.x = rect.left;,9,<empty>,,45,12,CPPASTProblemDeclaration,,<empty>
431390,UNKNOWN,13,,origin.y = rect.top;,9,<empty>,,46,13,CPPASTProblemDeclaration,,<empty>
431392,UNKNOWN,15,,dimensions.width = rect.right - rect.left + 1;,9,<empty>,,49,15,CPPASTProblemDeclaration,,<empty>
431393,UNKNOWN,16,,dimensions.height = rect.bottom - rect.top + 1;,9,<empty>,,50,16,CPPASTProblemDeclaration,,<empty>
431402,UNKNOWN,19,,"VERIFY_ARE_EQUAL(rect.left, v.Left());",9,<empty>,,54,19,CPPASTProblemDeclaration,,<empty>
431403,UNKNOWN,20,,"VERIFY_ARE_EQUAL(rect.right, v.RightInclusive());",9,<empty>,,55,20,CPPASTProblemDeclaration,,<empty>
431404,UNKNOWN,21,,"VERIFY_ARE_EQUAL(rect.right + 1, v.RightExclusive());",9,<empty>,,56,21,CPPASTProblemDeclaration,,<empty>
431405,UNKNOWN,22,,"VERIFY_ARE_EQUAL(rect.top, v.Top());",9,<empty>,,57,22,CPPASTProblemDeclaration,,<empty>
431406,UNKNOWN,23,,"VERIFY_ARE_EQUAL(rect.bottom, v.BottomInclusive());",9,<empty>,,58,23,CPPASTProblemDeclaration,,<empty>
431407,UNKNOWN,24,,"VERIFY_ARE_EQUAL(rect.bottom + 1, v.BottomExclusive());",9,<empty>,,59,24,CPPASTProblemDeclaration,,<empty>
431408,UNKNOWN,25,,"VERIFY_ARE_EQUAL(dimensions.height, v.Height());",9,<empty>,,60,25,CPPASTProblemDeclaration,,<empty>
431409,UNKNOWN,26,,"VERIFY_ARE_EQUAL(dimensions.width, v.Width());",9,<empty>,,61,26,CPPASTProblemDeclaration,,<empty>
431410,UNKNOWN,27,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,62,27,CPPASTProblemDeclaration,,<empty>
431411,UNKNOWN,28,,"VERIFY_ARE_EQUAL(dimensions, v.Dimensions());",9,<empty>,,63,28,CPPASTProblemDeclaration,,<empty>
431412,UNKNOWN,29,,},5,<empty>,,64,29,CPPASTProblemDeclaration,,<empty>
431413,UNKNOWN,30,,"TEST_METHOD(CreateFromExclusive)
    {
        til::rect rect;",5,<empty>,,66,30,CPPASTProblemDeclaration,,<empty>
431414,UNKNOWN,31,,rect.top = 3;,9,<empty>,,69,31,CPPASTProblemDeclaration,,<empty>
431415,UNKNOWN,32,,rect.bottom = 5;,9,<empty>,,70,32,CPPASTProblemDeclaration,,<empty>
431416,UNKNOWN,33,,rect.left = 10;,9,<empty>,,71,33,CPPASTProblemDeclaration,,<empty>
431417,UNKNOWN,34,,rect.right = 20;,9,<empty>,,72,34,CPPASTProblemDeclaration,,<empty>
431419,UNKNOWN,36,,origin.x = rect.left;,9,<empty>,,75,36,CPPASTProblemDeclaration,,<empty>
431420,UNKNOWN,37,,origin.y = rect.top;,9,<empty>,,76,37,CPPASTProblemDeclaration,,<empty>
431422,UNKNOWN,39,,dimensions.width = rect.right - rect.left;,9,<empty>,,79,39,CPPASTProblemDeclaration,,<empty>
431423,UNKNOWN,40,,dimensions.height = rect.bottom - rect.top;,9,<empty>,,80,40,CPPASTProblemDeclaration,,<empty>
431432,UNKNOWN,43,,"VERIFY_ARE_EQUAL(rect.left, v.Left());",9,<empty>,,84,43,CPPASTProblemDeclaration,,<empty>
431433,UNKNOWN,44,,"VERIFY_ARE_EQUAL(rect.right - 1, v.RightInclusive());",9,<empty>,,85,44,CPPASTProblemDeclaration,,<empty>
431434,UNKNOWN,45,,"VERIFY_ARE_EQUAL(rect.right, v.RightExclusive());",9,<empty>,,86,45,CPPASTProblemDeclaration,,<empty>
431435,UNKNOWN,46,,"VERIFY_ARE_EQUAL(rect.top, v.Top());",9,<empty>,,87,46,CPPASTProblemDeclaration,,<empty>
431436,UNKNOWN,47,,"VERIFY_ARE_EQUAL(rect.bottom - 1, v.BottomInclusive());",9,<empty>,,88,47,CPPASTProblemDeclaration,,<empty>
431437,UNKNOWN,48,,"VERIFY_ARE_EQUAL(rect.bottom, v.BottomExclusive());",9,<empty>,,89,48,CPPASTProblemDeclaration,,<empty>
431438,UNKNOWN,49,,"VERIFY_ARE_EQUAL(dimensions.height, v.Height());",9,<empty>,,90,49,CPPASTProblemDeclaration,,<empty>
431439,UNKNOWN,50,,"VERIFY_ARE_EQUAL(dimensions.width, v.Width());",9,<empty>,,91,50,CPPASTProblemDeclaration,,<empty>
431440,UNKNOWN,51,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,92,51,CPPASTProblemDeclaration,,<empty>
431441,UNKNOWN,52,,"VERIFY_ARE_EQUAL(dimensions, v.Dimensions());",9,<empty>,,93,52,CPPASTProblemDeclaration,,<empty>
431442,UNKNOWN,53,,},5,<empty>,,94,53,CPPASTProblemDeclaration,,<empty>
431443,UNKNOWN,54,,"TEST_METHOD(CreateFromDimensionsWidthHeight)
    {
        til::inclusive_rect rect;",5,<empty>,,96,54,CPPASTProblemDeclaration,,<empty>
431444,UNKNOWN,55,,rect.top = 3;,9,<empty>,,99,55,CPPASTProblemDeclaration,,<empty>
431445,UNKNOWN,56,,rect.bottom = 5;,9,<empty>,,100,56,CPPASTProblemDeclaration,,<empty>
431446,UNKNOWN,57,,rect.left = 10;,9,<empty>,,101,57,CPPASTProblemDeclaration,,<empty>
431447,UNKNOWN,58,,rect.right = 20;,9,<empty>,,102,58,CPPASTProblemDeclaration,,<empty>
431449,UNKNOWN,60,,origin.x = rect.left;,9,<empty>,,105,60,CPPASTProblemDeclaration,,<empty>
431450,UNKNOWN,61,,origin.y = rect.top;,9,<empty>,,106,61,CPPASTProblemDeclaration,,<empty>
431452,UNKNOWN,63,,dimensions.width = rect.right - rect.left + 1;,9,<empty>,,109,63,CPPASTProblemDeclaration,,<empty>
431453,UNKNOWN,64,,dimensions.height = rect.bottom - rect.top + 1;,9,<empty>,,110,64,CPPASTProblemDeclaration,,<empty>
431468,UNKNOWN,67,,"VERIFY_ARE_EQUAL(rect.left, v.Left());",9,<empty>,,114,67,CPPASTProblemDeclaration,,<empty>
431469,UNKNOWN,68,,"VERIFY_ARE_EQUAL(rect.right, v.RightInclusive());",9,<empty>,,115,68,CPPASTProblemDeclaration,,<empty>
431470,UNKNOWN,69,,"VERIFY_ARE_EQUAL(rect.right + 1, v.RightExclusive());",9,<empty>,,116,69,CPPASTProblemDeclaration,,<empty>
431471,UNKNOWN,70,,"VERIFY_ARE_EQUAL(rect.top, v.Top());",9,<empty>,,117,70,CPPASTProblemDeclaration,,<empty>
431472,UNKNOWN,71,,"VERIFY_ARE_EQUAL(rect.bottom, v.BottomInclusive());",9,<empty>,,118,71,CPPASTProblemDeclaration,,<empty>
431473,UNKNOWN,72,,"VERIFY_ARE_EQUAL(rect.bottom + 1, v.BottomExclusive());",9,<empty>,,119,72,CPPASTProblemDeclaration,,<empty>
431474,UNKNOWN,73,,"VERIFY_ARE_EQUAL(dimensions.height, v.Height());",9,<empty>,,120,73,CPPASTProblemDeclaration,,<empty>
431475,UNKNOWN,74,,"VERIFY_ARE_EQUAL(dimensions.width, v.Width());",9,<empty>,,121,74,CPPASTProblemDeclaration,,<empty>
431476,UNKNOWN,75,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,122,75,CPPASTProblemDeclaration,,<empty>
431477,UNKNOWN,76,,"VERIFY_ARE_EQUAL(dimensions, v.Dimensions());",9,<empty>,,123,76,CPPASTProblemDeclaration,,<empty>
431478,UNKNOWN,77,,},5,<empty>,,124,77,CPPASTProblemDeclaration,,<empty>
431479,UNKNOWN,78,,"TEST_METHOD(CreateFromDimensions)
    {
        til::inclusive_rect rect;",5,<empty>,,126,78,CPPASTProblemDeclaration,,<empty>
431480,UNKNOWN,79,,rect.top = 3;,9,<empty>,,129,79,CPPASTProblemDeclaration,,<empty>
431481,UNKNOWN,80,,rect.bottom = 5;,9,<empty>,,130,80,CPPASTProblemDeclaration,,<empty>
431482,UNKNOWN,81,,rect.left = 10;,9,<empty>,,131,81,CPPASTProblemDeclaration,,<empty>
431483,UNKNOWN,82,,rect.right = 20;,9,<empty>,,132,82,CPPASTProblemDeclaration,,<empty>
431485,UNKNOWN,84,,origin.x = rect.left;,9,<empty>,,135,84,CPPASTProblemDeclaration,,<empty>
431486,UNKNOWN,85,,origin.y = rect.top;,9,<empty>,,136,85,CPPASTProblemDeclaration,,<empty>
431488,UNKNOWN,87,,dimensions.width = rect.right - rect.left + 1;,9,<empty>,,139,87,CPPASTProblemDeclaration,,<empty>
431489,UNKNOWN,88,,dimensions.height = rect.bottom - rect.top + 1;,9,<empty>,,140,88,CPPASTProblemDeclaration,,<empty>
431499,UNKNOWN,91,,"VERIFY_ARE_EQUAL(rect.left, v.Left());",9,<empty>,,144,91,CPPASTProblemDeclaration,,<empty>
431500,UNKNOWN,92,,"VERIFY_ARE_EQUAL(rect.right, v.RightInclusive());",9,<empty>,,145,92,CPPASTProblemDeclaration,,<empty>
431501,UNKNOWN,93,,"VERIFY_ARE_EQUAL(rect.right + 1, v.RightExclusive());",9,<empty>,,146,93,CPPASTProblemDeclaration,,<empty>
431502,UNKNOWN,94,,"VERIFY_ARE_EQUAL(rect.top, v.Top());",9,<empty>,,147,94,CPPASTProblemDeclaration,,<empty>
431503,UNKNOWN,95,,"VERIFY_ARE_EQUAL(rect.bottom, v.BottomInclusive());",9,<empty>,,148,95,CPPASTProblemDeclaration,,<empty>
431504,UNKNOWN,96,,"VERIFY_ARE_EQUAL(rect.bottom + 1, v.BottomExclusive());",9,<empty>,,149,96,CPPASTProblemDeclaration,,<empty>
431505,UNKNOWN,97,,"VERIFY_ARE_EQUAL(dimensions.height, v.Height());",9,<empty>,,150,97,CPPASTProblemDeclaration,,<empty>
431506,UNKNOWN,98,,"VERIFY_ARE_EQUAL(dimensions.width, v.Width());",9,<empty>,,151,98,CPPASTProblemDeclaration,,<empty>
431507,UNKNOWN,99,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,152,99,CPPASTProblemDeclaration,,<empty>
431508,UNKNOWN,100,,"VERIFY_ARE_EQUAL(dimensions, v.Dimensions());",9,<empty>,,153,100,CPPASTProblemDeclaration,,<empty>
431509,UNKNOWN,101,,},5,<empty>,,154,101,CPPASTProblemDeclaration,,<empty>
431510,UNKNOWN,102,,"TEST_METHOD(CreateFromDimensionsNoOrigin)
    {
        til::inclusive_rect rect;",5,<empty>,,156,102,CPPASTProblemDeclaration,,<empty>
431511,UNKNOWN,103,,rect.top = 0;,9,<empty>,,159,103,CPPASTProblemDeclaration,,<empty>
431512,UNKNOWN,104,,rect.left = 0;,9,<empty>,,160,104,CPPASTProblemDeclaration,,<empty>
431513,UNKNOWN,105,,rect.bottom = 5;,9,<empty>,,161,105,CPPASTProblemDeclaration,,<empty>
431514,UNKNOWN,106,,rect.right = 20;,9,<empty>,,162,106,CPPASTProblemDeclaration,,<empty>
431516,UNKNOWN,108,,origin.x = rect.left;,9,<empty>,,165,108,CPPASTProblemDeclaration,,<empty>
431517,UNKNOWN,109,,origin.y = rect.top;,9,<empty>,,166,109,CPPASTProblemDeclaration,,<empty>
431519,UNKNOWN,111,,dimensions.width = rect.right - rect.left + 1;,9,<empty>,,169,111,CPPASTProblemDeclaration,,<empty>
431520,UNKNOWN,112,,dimensions.height = rect.bottom - rect.top + 1;,9,<empty>,,170,112,CPPASTProblemDeclaration,,<empty>
431529,UNKNOWN,115,,"VERIFY_ARE_EQUAL(rect.left, v.Left());",9,<empty>,,174,115,CPPASTProblemDeclaration,,<empty>
431530,UNKNOWN,116,,"VERIFY_ARE_EQUAL(rect.right, v.RightInclusive());",9,<empty>,,175,116,CPPASTProblemDeclaration,,<empty>
431531,UNKNOWN,117,,"VERIFY_ARE_EQUAL(rect.right + 1, v.RightExclusive());",9,<empty>,,176,117,CPPASTProblemDeclaration,,<empty>
431532,UNKNOWN,118,,"VERIFY_ARE_EQUAL(rect.top, v.Top());",9,<empty>,,177,118,CPPASTProblemDeclaration,,<empty>
431533,UNKNOWN,119,,"VERIFY_ARE_EQUAL(rect.bottom, v.BottomInclusive());",9,<empty>,,178,119,CPPASTProblemDeclaration,,<empty>
431534,UNKNOWN,120,,"VERIFY_ARE_EQUAL(rect.bottom + 1, v.BottomExclusive());",9,<empty>,,179,120,CPPASTProblemDeclaration,,<empty>
431535,UNKNOWN,121,,"VERIFY_ARE_EQUAL(dimensions.height, v.Height());",9,<empty>,,180,121,CPPASTProblemDeclaration,,<empty>
431536,UNKNOWN,122,,"VERIFY_ARE_EQUAL(dimensions.width, v.Width());",9,<empty>,,181,122,CPPASTProblemDeclaration,,<empty>
431537,UNKNOWN,123,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,182,123,CPPASTProblemDeclaration,,<empty>
431538,UNKNOWN,124,,"VERIFY_ARE_EQUAL(dimensions, v.Dimensions());",9,<empty>,,183,124,CPPASTProblemDeclaration,,<empty>
431539,UNKNOWN,125,,},5,<empty>,,184,125,CPPASTProblemDeclaration,,<empty>
431540,UNKNOWN,126,,"TEST_METHOD(CreateFromCoord)
    {
        til::point origin;",5,<empty>,,186,126,CPPASTProblemDeclaration,,<empty>
431541,UNKNOWN,127,,origin.x = 12;,9,<empty>,,189,127,CPPASTProblemDeclaration,,<empty>
431542,UNKNOWN,128,,origin.y = 24;,9,<empty>,,190,128,CPPASTProblemDeclaration,,<empty>
431551,UNKNOWN,131,,"VERIFY_ARE_EQUAL(origin.x, v.Left());",9,<empty>,,194,131,CPPASTProblemDeclaration,,<empty>
431552,UNKNOWN,132,,"VERIFY_ARE_EQUAL(origin.x, v.RightInclusive());",9,<empty>,,195,132,CPPASTProblemDeclaration,,<empty>
431553,UNKNOWN,133,,"VERIFY_ARE_EQUAL(origin.x + 1, v.RightExclusive());",9,<empty>,,196,133,CPPASTProblemDeclaration,,<empty>
431554,UNKNOWN,134,,"VERIFY_ARE_EQUAL(origin.y, v.Top());",9,<empty>,,197,134,CPPASTProblemDeclaration,,<empty>
431555,UNKNOWN,135,,"VERIFY_ARE_EQUAL(origin.y, v.BottomInclusive());",9,<empty>,,198,135,CPPASTProblemDeclaration,,<empty>
431556,UNKNOWN,136,,"VERIFY_ARE_EQUAL(origin.y + 1, v.BottomExclusive());",9,<empty>,,199,136,CPPASTProblemDeclaration,,<empty>
431557,UNKNOWN,137,,"VERIFY_ARE_EQUAL(1, v.Height());",9,<empty>,,200,137,CPPASTProblemDeclaration,,<empty>
431558,UNKNOWN,138,,"VERIFY_ARE_EQUAL(1, v.Width());",9,<empty>,,201,138,CPPASTProblemDeclaration,,<empty>
431559,UNKNOWN,139,,"VERIFY_ARE_EQUAL(origin, v.Origin());",9,<empty>,,202,139,CPPASTProblemDeclaration,,<empty>
431560,UNKNOWN,140,,"VERIFY_ARE_EQUAL(til::size(1, 1), v.Dimensions());",9,<empty>,,204,140,CPPASTProblemDeclaration,,<empty>
431561,UNKNOWN,141,,},5,<empty>,,206,141,CPPASTProblemDeclaration,,<empty>
431562,UNKNOWN,142,,"TEST_METHOD(IsInBoundsCoord)
    {
        til::inclusive_rect r;",5,<empty>,,208,142,CPPASTProblemDeclaration,,<empty>
431563,UNKNOWN,143,,r.top = 3;,9,<empty>,,211,143,CPPASTProblemDeclaration,,<empty>
431564,UNKNOWN,144,,r.bottom = 5;,9,<empty>,,212,144,CPPASTProblemDeclaration,,<empty>
431565,UNKNOWN,145,,r.left = 10;,9,<empty>,,213,145,CPPASTProblemDeclaration,,<empty>
431566,UNKNOWN,146,,r.right = 20;,9,<empty>,,214,146,CPPASTProblemDeclaration,,<empty>
431576,UNKNOWN,150,,c.x = r.left;,9,<empty>,,219,150,CPPASTProblemDeclaration,,<empty>
431577,UNKNOWN,151,,c.y = r.top;,9,<empty>,,220,151,CPPASTProblemDeclaration,,<empty>
431578,UNKNOWN,152,,"VERIFY_IS_TRUE(v.IsInBounds(c), L""Top left corner in bounds."");",9,<empty>,,221,152,CPPASTProblemDeclaration,,<empty>
431579,UNKNOWN,153,,c.y = r.bottom;,9,<empty>,,223,153,CPPASTProblemDeclaration,,<empty>
431580,UNKNOWN,154,,"VERIFY_IS_TRUE(v.IsInBounds(c), L""Bottom left corner in bounds."");",9,<empty>,,224,154,CPPASTProblemDeclaration,,<empty>
431581,UNKNOWN,155,,c.x = r.right;,9,<empty>,,226,155,CPPASTProblemDeclaration,,<empty>
431582,UNKNOWN,156,,"VERIFY_IS_TRUE(v.IsInBounds(c), L""Bottom right corner in bounds."");",9,<empty>,,227,156,CPPASTProblemDeclaration,,<empty>
431583,UNKNOWN,157,,c.y = r.top;,9,<empty>,,229,157,CPPASTProblemDeclaration,,<empty>
431584,UNKNOWN,158,,"VERIFY_IS_TRUE(v.IsInBounds(c), L""Top right corner in bounds."");",9,<empty>,,230,158,CPPASTProblemDeclaration,,<empty>
431585,UNKNOWN,159,,c.x++;,9,<empty>,,232,159,CPPASTProblemDeclaration,,<empty>
431586,UNKNOWN,160,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One right out the top right is out of bounds."");",9,<empty>,,233,160,CPPASTProblemDeclaration,,<empty>
431587,UNKNOWN,161,,c.x--;,9,<empty>,,235,161,CPPASTProblemDeclaration,,<empty>
431588,UNKNOWN,162,,c.y--;,9,<empty>,,236,162,CPPASTProblemDeclaration,,<empty>
431589,UNKNOWN,163,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One up out the top right is out of bounds."");",9,<empty>,,237,163,CPPASTProblemDeclaration,,<empty>
431590,UNKNOWN,164,,c.x = r.left;,9,<empty>,,239,164,CPPASTProblemDeclaration,,<empty>
431591,UNKNOWN,165,,c.y = r.top;,9,<empty>,,240,165,CPPASTProblemDeclaration,,<empty>
431592,UNKNOWN,166,,c.x--;,9,<empty>,,241,166,CPPASTProblemDeclaration,,<empty>
431593,UNKNOWN,167,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One left out the top left is out of bounds."");",9,<empty>,,242,167,CPPASTProblemDeclaration,,<empty>
431594,UNKNOWN,168,,c.x++;,9,<empty>,,244,168,CPPASTProblemDeclaration,,<empty>
431595,UNKNOWN,169,,c.y--;,9,<empty>,,245,169,CPPASTProblemDeclaration,,<empty>
431596,UNKNOWN,170,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One up out the top left is out of bounds."");",9,<empty>,,246,170,CPPASTProblemDeclaration,,<empty>
431597,UNKNOWN,171,,c.x = r.left;,9,<empty>,,248,171,CPPASTProblemDeclaration,,<empty>
431598,UNKNOWN,172,,c.y = r.bottom;,9,<empty>,,249,172,CPPASTProblemDeclaration,,<empty>
431599,UNKNOWN,173,,c.x--;,9,<empty>,,250,173,CPPASTProblemDeclaration,,<empty>
431600,UNKNOWN,174,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One left out the bottom left is out of bounds."");",9,<empty>,,251,174,CPPASTProblemDeclaration,,<empty>
431601,UNKNOWN,175,,c.x++;,9,<empty>,,253,175,CPPASTProblemDeclaration,,<empty>
431602,UNKNOWN,176,,c.y++;,9,<empty>,,254,176,CPPASTProblemDeclaration,,<empty>
431603,UNKNOWN,177,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One down out the bottom left is out of bounds."");",9,<empty>,,255,177,CPPASTProblemDeclaration,,<empty>
431604,UNKNOWN,178,,c.x = r.right;,9,<empty>,,257,178,CPPASTProblemDeclaration,,<empty>
431605,UNKNOWN,179,,c.y = r.bottom;,9,<empty>,,258,179,CPPASTProblemDeclaration,,<empty>
431606,UNKNOWN,180,,c.x++;,9,<empty>,,259,180,CPPASTProblemDeclaration,,<empty>
431607,UNKNOWN,181,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One right out the bottom right is out of bounds."");",9,<empty>,,260,181,CPPASTProblemDeclaration,,<empty>
431608,UNKNOWN,182,,c.x--;,9,<empty>,,262,182,CPPASTProblemDeclaration,,<empty>
431609,UNKNOWN,183,,c.y++;,9,<empty>,,263,183,CPPASTProblemDeclaration,,<empty>
431610,UNKNOWN,184,,"VERIFY_IS_FALSE(v.IsInBounds(c), L""One down out the bottom right is out of bounds."");",9,<empty>,,264,184,CPPASTProblemDeclaration,,<empty>
431611,UNKNOWN,185,,},5,<empty>,,265,185,CPPASTProblemDeclaration,,<empty>
431612,UNKNOWN,186,,"TEST_METHOD(IsInBoundsViewport)
    {
        til::inclusive_rect rect;",5,<empty>,,267,186,CPPASTProblemDeclaration,,<empty>
431613,UNKNOWN,187,,rect.top = 3;,9,<empty>,,270,187,CPPASTProblemDeclaration,,<empty>
431614,UNKNOWN,188,,rect.bottom = 5;,9,<empty>,,271,188,CPPASTProblemDeclaration,,<empty>
431615,UNKNOWN,189,,rect.left = 10;,9,<empty>,,272,189,CPPASTProblemDeclaration,,<empty>
431616,UNKNOWN,190,,rect.right = 20;,9,<empty>,,273,190,CPPASTProblemDeclaration,,<empty>
431637,UNKNOWN,197,,"VERIFY_IS_TRUE(view.IsInBounds(test), L""Same size/position viewport is in bounds."");",9,<empty>,,280,197,CPPASTProblemDeclaration,,<empty>
431638,UNKNOWN,198,,rect.top++;,9,<empty>,,282,198,CPPASTProblemDeclaration,,<empty>
431639,UNKNOWN,199,,rect.bottom--;,9,<empty>,,283,199,CPPASTProblemDeclaration,,<empty>
431640,UNKNOWN,200,,rect.left++;,9,<empty>,,284,200,CPPASTProblemDeclaration,,<empty>
431641,UNKNOWN,201,,rect.right--;,9,<empty>,,285,201,CPPASTProblemDeclaration,,<empty>
431642,UNKNOWN,202,,test = Viewport::FromInclusive(rect);,9,<empty>,,286,202,CPPASTProblemDeclaration,,<empty>
431643,UNKNOWN,203,,"VERIFY_IS_TRUE(view.IsInBounds(test), L""Viewport inscribed inside viewport is in bounds."");",9,<empty>,,287,203,CPPASTProblemDeclaration,,<empty>
431644,UNKNOWN,204,,rect = original;,9,<empty>,,289,204,CPPASTProblemDeclaration,,<empty>
431645,UNKNOWN,205,,rect.top--;,9,<empty>,,290,205,CPPASTProblemDeclaration,,<empty>
431646,UNKNOWN,206,,test = Viewport::FromInclusive(rect);,9,<empty>,,291,206,CPPASTProblemDeclaration,,<empty>
431647,UNKNOWN,207,,"VERIFY_IS_FALSE(view.IsInBounds(test), L""Viewport that is one taller upwards is out of bounds."");",9,<empty>,,292,207,CPPASTProblemDeclaration,,<empty>
431648,UNKNOWN,208,,rect = original;,9,<empty>,,294,208,CPPASTProblemDeclaration,,<empty>
431649,UNKNOWN,209,,rect.bottom++;,9,<empty>,,295,209,CPPASTProblemDeclaration,,<empty>
431650,UNKNOWN,210,,test = Viewport::FromInclusive(rect);,9,<empty>,,296,210,CPPASTProblemDeclaration,,<empty>
431651,UNKNOWN,211,,"VERIFY_IS_FALSE(view.IsInBounds(test), L""Viewport that is one taller downwards is out of bounds."");",9,<empty>,,297,211,CPPASTProblemDeclaration,,<empty>
431652,UNKNOWN,212,,rect = original;,9,<empty>,,299,212,CPPASTProblemDeclaration,,<empty>
431653,UNKNOWN,213,,rect.left--;,9,<empty>,,300,213,CPPASTProblemDeclaration,,<empty>
431654,UNKNOWN,214,,test = Viewport::FromInclusive(rect);,9,<empty>,,301,214,CPPASTProblemDeclaration,,<empty>
431655,UNKNOWN,215,,"VERIFY_IS_FALSE(view.IsInBounds(test), L""Viewport that is one wider leftwards is out of bounds."");",9,<empty>,,302,215,CPPASTProblemDeclaration,,<empty>
431656,UNKNOWN,216,,rect = original;,9,<empty>,,304,216,CPPASTProblemDeclaration,,<empty>
431657,UNKNOWN,217,,rect.right++;,9,<empty>,,305,217,CPPASTProblemDeclaration,,<empty>
431658,UNKNOWN,218,,test = Viewport::FromInclusive(rect);,9,<empty>,,306,218,CPPASTProblemDeclaration,,<empty>
431659,UNKNOWN,219,,"VERIFY_IS_FALSE(view.IsInBounds(test), L""Viewport that is one wider rightwards is out of bounds."");",9,<empty>,,307,219,CPPASTProblemDeclaration,,<empty>
431660,UNKNOWN,220,,rect = original;,9,<empty>,,309,220,CPPASTProblemDeclaration,,<empty>
431661,UNKNOWN,221,,rect.left++;,9,<empty>,,310,221,CPPASTProblemDeclaration,,<empty>
431662,UNKNOWN,222,,rect.right++;,9,<empty>,,311,222,CPPASTProblemDeclaration,,<empty>
431663,UNKNOWN,223,,rect.top++;,9,<empty>,,312,223,CPPASTProblemDeclaration,,<empty>
431664,UNKNOWN,224,,rect.bottom++;,9,<empty>,,313,224,CPPASTProblemDeclaration,,<empty>
431665,UNKNOWN,225,,test = Viewport::FromInclusive(rect);,9,<empty>,,314,225,CPPASTProblemDeclaration,,<empty>
431666,UNKNOWN,226,,"VERIFY_IS_FALSE(view.IsInBounds(test), L""Viewport offset at the origin but same size is out of bounds."");",9,<empty>,,315,226,CPPASTProblemDeclaration,,<empty>
431667,UNKNOWN,227,,},5,<empty>,,316,227,CPPASTProblemDeclaration,,<empty>
431668,UNKNOWN,228,,"TEST_METHOD(ClampCoord)
    {
        til::inclusive_rect rect;",5,<empty>,,318,228,CPPASTProblemDeclaration,,<empty>
431669,UNKNOWN,229,,rect.top = 3;,9,<empty>,,321,229,CPPASTProblemDeclaration,,<empty>
431670,UNKNOWN,230,,rect.bottom = 5;,9,<empty>,,322,230,CPPASTProblemDeclaration,,<empty>
431671,UNKNOWN,231,,rect.left = 10;,9,<empty>,,323,231,CPPASTProblemDeclaration,,<empty>
431672,UNKNOWN,232,,rect.right = 20;,9,<empty>,,324,232,CPPASTProblemDeclaration,,<empty>
431682,UNKNOWN,236,,pos.x = rect.left;,9,<empty>,,329,236,CPPASTProblemDeclaration,,<empty>
431683,UNKNOWN,237,,pos.y = rect.top;,9,<empty>,,330,237,CPPASTProblemDeclaration,,<empty>
431688,UNKNOWN,240,,view.Clamp(pos);,9,<empty>,,333,240,CPPASTProblemDeclaration,,<empty>
431689,UNKNOWN,241,,"VERIFY_ARE_EQUAL(before, pos, L""Verify clamp did nothing for position in top left corner."");",9,<empty>,,334,241,CPPASTProblemDeclaration,,<empty>
431690,UNKNOWN,242,,pos.x = rect.left;,9,<empty>,,336,242,CPPASTProblemDeclaration,,<empty>
431691,UNKNOWN,243,,pos.y = rect.bottom;,9,<empty>,,337,243,CPPASTProblemDeclaration,,<empty>
431692,UNKNOWN,244,,before = pos;,9,<empty>,,338,244,CPPASTProblemDeclaration,,<empty>
431693,UNKNOWN,245,,view.Clamp(pos);,9,<empty>,,339,245,CPPASTProblemDeclaration,,<empty>
431694,UNKNOWN,246,,"VERIFY_ARE_EQUAL(before, pos, L""Verify clamp did nothing for position in bottom left corner."");",9,<empty>,,340,246,CPPASTProblemDeclaration,,<empty>
431695,UNKNOWN,247,,pos.x = rect.right;,9,<empty>,,342,247,CPPASTProblemDeclaration,,<empty>
431696,UNKNOWN,248,,pos.y = rect.bottom;,9,<empty>,,343,248,CPPASTProblemDeclaration,,<empty>
431697,UNKNOWN,249,,before = pos;,9,<empty>,,344,249,CPPASTProblemDeclaration,,<empty>
431698,UNKNOWN,250,,view.Clamp(pos);,9,<empty>,,345,250,CPPASTProblemDeclaration,,<empty>
431699,UNKNOWN,251,,"VERIFY_ARE_EQUAL(before, pos, L""Verify clamp did nothing for position in bottom right corner."");",9,<empty>,,346,251,CPPASTProblemDeclaration,,<empty>
431700,UNKNOWN,252,,pos.x = rect.right;,9,<empty>,,348,252,CPPASTProblemDeclaration,,<empty>
431701,UNKNOWN,253,,pos.y = rect.top;,9,<empty>,,349,253,CPPASTProblemDeclaration,,<empty>
431702,UNKNOWN,254,,before = pos;,9,<empty>,,350,254,CPPASTProblemDeclaration,,<empty>
431703,UNKNOWN,255,,view.Clamp(pos);,9,<empty>,,351,255,CPPASTProblemDeclaration,,<empty>
431704,UNKNOWN,256,,"VERIFY_ARE_EQUAL(before, pos, L""Verify clamp did nothing for position in top right corner."");",9,<empty>,,352,256,CPPASTProblemDeclaration,,<empty>
431706,UNKNOWN,258,,expected.x = rect.right;,9,<empty>,,355,258,CPPASTProblemDeclaration,,<empty>
431707,UNKNOWN,259,,expected.y = rect.top;,9,<empty>,,356,259,CPPASTProblemDeclaration,,<empty>
431708,UNKNOWN,260,,pos = expected;,9,<empty>,,358,260,CPPASTProblemDeclaration,,<empty>
431709,UNKNOWN,261,,pos.x++;,9,<empty>,,359,261,CPPASTProblemDeclaration,,<empty>
431710,UNKNOWN,262,,pos.y--;,9,<empty>,,360,262,CPPASTProblemDeclaration,,<empty>
431711,UNKNOWN,263,,before = pos;,9,<empty>,,361,263,CPPASTProblemDeclaration,,<empty>
431712,UNKNOWN,264,,view.Clamp(pos);,9,<empty>,,363,264,CPPASTProblemDeclaration,,<empty>
431713,UNKNOWN,265,,"VERIFY_ARE_NOT_EQUAL(before, pos, L""Verify clamp modified position out the top right corner back."");",9,<empty>,,364,265,CPPASTProblemDeclaration,,<empty>
431714,UNKNOWN,266,,"VERIFY_ARE_EQUAL(expected, pos, L""Verify position was clamped into the top right corner."");",9,<empty>,,365,266,CPPASTProblemDeclaration,,<empty>
431715,UNKNOWN,267,,expected.x = rect.left;,9,<empty>,,367,267,CPPASTProblemDeclaration,,<empty>
431716,UNKNOWN,268,,expected.y = rect.top;,9,<empty>,,368,268,CPPASTProblemDeclaration,,<empty>
431717,UNKNOWN,269,,pos = expected;,9,<empty>,,370,269,CPPASTProblemDeclaration,,<empty>
431718,UNKNOWN,270,,pos.x--;,9,<empty>,,371,270,CPPASTProblemDeclaration,,<empty>
431719,UNKNOWN,271,,pos.y--;,9,<empty>,,372,271,CPPASTProblemDeclaration,,<empty>
431720,UNKNOWN,272,,before = pos;,9,<empty>,,373,272,CPPASTProblemDeclaration,,<empty>
431721,UNKNOWN,273,,view.Clamp(pos);,9,<empty>,,375,273,CPPASTProblemDeclaration,,<empty>
431722,UNKNOWN,274,,"VERIFY_ARE_NOT_EQUAL(before, pos, L""Verify clamp modified position out the top left corner back."");",9,<empty>,,376,274,CPPASTProblemDeclaration,,<empty>
431723,UNKNOWN,275,,"VERIFY_ARE_EQUAL(expected, pos, L""Verify position was clamped into the top left corner."");",9,<empty>,,377,275,CPPASTProblemDeclaration,,<empty>
431724,UNKNOWN,276,,expected.x = rect.left;,9,<empty>,,379,276,CPPASTProblemDeclaration,,<empty>
431725,UNKNOWN,277,,expected.y = rect.bottom;,9,<empty>,,380,277,CPPASTProblemDeclaration,,<empty>
431726,UNKNOWN,278,,pos = expected;,9,<empty>,,382,278,CPPASTProblemDeclaration,,<empty>
431727,UNKNOWN,279,,pos.x--;,9,<empty>,,383,279,CPPASTProblemDeclaration,,<empty>
431728,UNKNOWN,280,,pos.y++;,9,<empty>,,384,280,CPPASTProblemDeclaration,,<empty>
431729,UNKNOWN,281,,before = pos;,9,<empty>,,385,281,CPPASTProblemDeclaration,,<empty>
431730,UNKNOWN,282,,view.Clamp(pos);,9,<empty>,,387,282,CPPASTProblemDeclaration,,<empty>
431731,UNKNOWN,283,,"VERIFY_ARE_NOT_EQUAL(before, pos, L""Verify clamp modified position out the bottom left corner back."");",9,<empty>,,388,283,CPPASTProblemDeclaration,,<empty>
431732,UNKNOWN,284,,"VERIFY_ARE_EQUAL(expected, pos, L""Verify position was clamped into the bottom left corner."");",9,<empty>,,389,284,CPPASTProblemDeclaration,,<empty>
431733,UNKNOWN,285,,expected.x = rect.right;,9,<empty>,,391,285,CPPASTProblemDeclaration,,<empty>
431734,UNKNOWN,286,,expected.y = rect.bottom;,9,<empty>,,392,286,CPPASTProblemDeclaration,,<empty>
431735,UNKNOWN,287,,pos = expected;,9,<empty>,,394,287,CPPASTProblemDeclaration,,<empty>
431736,UNKNOWN,288,,pos.x++;,9,<empty>,,395,288,CPPASTProblemDeclaration,,<empty>
431737,UNKNOWN,289,,pos.y++;,9,<empty>,,396,289,CPPASTProblemDeclaration,,<empty>
431738,UNKNOWN,290,,before = pos;,9,<empty>,,397,290,CPPASTProblemDeclaration,,<empty>
431739,UNKNOWN,291,,view.Clamp(pos);,9,<empty>,,399,291,CPPASTProblemDeclaration,,<empty>
431740,UNKNOWN,292,,"VERIFY_ARE_NOT_EQUAL(before, pos, L""Verify clamp modified position out the bottom right corner back."");",9,<empty>,,400,292,CPPASTProblemDeclaration,,<empty>
431741,UNKNOWN,293,,"VERIFY_ARE_EQUAL(expected, pos, L""Verify position was clamped into the bottom right corner."");",9,<empty>,,401,293,CPPASTProblemDeclaration,,<empty>
431749,UNKNOWN,296,,"VERIFY_THROWS_SPECIFIC(invalidView.Clamp(pos),
                               wil::ResultException,
                               [](wil::ResultException& e) { return e.GetErrorCode() == E_NOT_VALID_STATE; }",9,<empty>,,404,296,CPPASTProblemDeclaration,,<empty>
431750,UNKNOWN,297,,);,109,<empty>,,406,297,CPPASTProblemDeclaration,,<empty>
431751,UNKNOWN,298,,},5,<empty>,,407,298,CPPASTProblemDeclaration,,<empty>
431752,UNKNOWN,299,,"TEST_METHOD(ClampViewport)
    {
        // Create the rectangle/view we will clamp to.
        til::inclusive_rect rect;",5,<empty>,,409,299,CPPASTProblemDeclaration,,<empty>
431753,UNKNOWN,300,,rect.top = 3;,9,<empty>,,413,300,CPPASTProblemDeclaration,,<empty>
431754,UNKNOWN,301,,rect.bottom = 5;,9,<empty>,,414,301,CPPASTProblemDeclaration,,<empty>
431755,UNKNOWN,302,,rect.left = 10;,9,<empty>,,415,302,CPPASTProblemDeclaration,,<empty>
431756,UNKNOWN,303,,rect.right = 20;,9,<empty>,,416,303,CPPASTProblemDeclaration,,<empty>
431765,UNKNOWN,306,,"Log::Comment(L""Make a rectangle that is larger than and fully encompasses our clamping rectangle."");",9,<empty>,,420,306,CPPASTProblemDeclaration,,<empty>
431767,UNKNOWN,308,,testRect.top = rect.top - 3;,9,<empty>,,422,308,CPPASTProblemDeclaration,,<empty>
431768,UNKNOWN,309,,testRect.bottom = rect.bottom + 3;,9,<empty>,,423,309,CPPASTProblemDeclaration,,<empty>
431769,UNKNOWN,310,,testRect.left = rect.left - 3;,9,<empty>,,424,310,CPPASTProblemDeclaration,,<empty>
431770,UNKNOWN,311,,testRect.right = rect.right + 3;,9,<empty>,,425,311,CPPASTProblemDeclaration,,<empty>
431787,UNKNOWN,316,,"VERIFY_ARE_EQUAL(view, actual, L""All sides should get reduced down to the size of the given rect."");",9,<empty>,,430,316,CPPASTProblemDeclaration,,<empty>
431788,UNKNOWN,317,,"Log::Comment(L""Make a rectangle that is fully inscribed inside our clamping rectangle."");",9,<empty>,,432,317,CPPASTProblemDeclaration,,<empty>
431789,UNKNOWN,318,,testRect.top = rect.top + 1;,9,<empty>,,433,318,CPPASTProblemDeclaration,,<empty>
431790,UNKNOWN,319,,testRect.bottom = rect.bottom - 1;,9,<empty>,,434,319,CPPASTProblemDeclaration,,<empty>
431791,UNKNOWN,320,,testRect.left = rect.left + 1;,9,<empty>,,435,320,CPPASTProblemDeclaration,,<empty>
431792,UNKNOWN,321,,testRect.right = rect.right - 1;,9,<empty>,,436,321,CPPASTProblemDeclaration,,<empty>
431793,UNKNOWN,322,,testView = Viewport::FromInclusive(testRect);,9,<empty>,,437,322,CPPASTProblemDeclaration,,<empty>
431794,UNKNOWN,323,,actual = view.Clamp(testView);,9,<empty>,,439,323,CPPASTProblemDeclaration,,<empty>
431795,UNKNOWN,324,,"VERIFY_ARE_EQUAL(testView, actual, L""Verify that nothing changed because this rectangle already sat fully inside the clamping rectangle."");",9,<empty>,,440,324,CPPASTProblemDeclaration,,<empty>
431796,UNKNOWN,325,,"Log::Comment(L""Craft a rectangle where the left is outside the right, right is outside the left, top is outside the bottom, and bottom is outside the top."");",9,<empty>,,442,325,CPPASTProblemDeclaration,,<empty>
431797,UNKNOWN,326,,testRect.top = rect.bottom + 10;,9,<empty>,,443,326,CPPASTProblemDeclaration,,<empty>
431798,UNKNOWN,327,,testRect.bottom = rect.top - 10;,9,<empty>,,444,327,CPPASTProblemDeclaration,,<empty>
431799,UNKNOWN,328,,testRect.left = rect.right + 10;,9,<empty>,,445,328,CPPASTProblemDeclaration,,<empty>
431800,UNKNOWN,329,,testRect.right = rect.left - 10;,9,<empty>,,446,329,CPPASTProblemDeclaration,,<empty>
431801,UNKNOWN,330,,testView = Viewport::FromInclusive(testRect);,9,<empty>,,447,330,CPPASTProblemDeclaration,,<empty>
431802,UNKNOWN,331,,"Log::Comment(L""We expect it to be pulled back so each coordinate is in bounds, but the rectangle is still invalid (since left will be > right)."");",9,<empty>,,449,331,CPPASTProblemDeclaration,,<empty>
431804,UNKNOWN,333,,expected.top = rect.bottom;,9,<empty>,,451,333,CPPASTProblemDeclaration,,<empty>
431805,UNKNOWN,334,,expected.bottom = rect.top;,9,<empty>,,452,334,CPPASTProblemDeclaration,,<empty>
431806,UNKNOWN,335,,expected.left = rect.right;,9,<empty>,,453,335,CPPASTProblemDeclaration,,<empty>
431807,UNKNOWN,336,,expected.right = rect.left;,9,<empty>,,454,336,CPPASTProblemDeclaration,,<empty>
431816,UNKNOWN,339,,actual = view.Clamp(testView);,9,<empty>,,457,339,CPPASTProblemDeclaration,,<empty>
431817,UNKNOWN,340,,"VERIFY_ARE_EQUAL(expectedView, actual, L""Every dimension should be pulled just inside the clamping rectangle."");",9,<empty>,,458,340,CPPASTProblemDeclaration,,<empty>
431818,UNKNOWN,341,,},5,<empty>,,459,341,CPPASTProblemDeclaration,,<empty>
431819,UNKNOWN,342,,"TEST_METHOD(IncrementInBounds)
    {
        auto success = false;",5,<empty>,,461,342,CPPASTProblemDeclaration,,<empty>
431821,UNKNOWN,344,,edges.left = 10;,9,<empty>,,466,344,CPPASTProblemDeclaration,,<empty>
431822,UNKNOWN,345,,edges.right = 19;,9,<empty>,,467,345,CPPASTProblemDeclaration,,<empty>
431823,UNKNOWN,346,,edges.top = 20;,9,<empty>,,468,346,CPPASTProblemDeclaration,,<empty>
431824,UNKNOWN,347,,edges.bottom = 29;,9,<empty>,,469,347,CPPASTProblemDeclaration,,<empty>
431835,UNKNOWN,352,,original.x = screen.x = 15;,9,<empty>,,476,352,CPPASTProblemDeclaration,,<empty>
431836,UNKNOWN,353,,original.y = screen.y = 25;,9,<empty>,,477,353,CPPASTProblemDeclaration,,<empty>
431837,UNKNOWN,354,,success = v.IncrementInBounds(screen);,9,<empty>,,479,354,CPPASTProblemDeclaration,,<empty>
431839,UNKNOWN,356,,"VERIFY_ARE_EQUAL(screen.x, original.x + 1);",9,<empty>,,482,356,CPPASTProblemDeclaration,,<empty>
431840,UNKNOWN,357,,"VERIFY_ARE_EQUAL(screen.y, original.y);",9,<empty>,,483,357,CPPASTProblemDeclaration,,<empty>
431841,UNKNOWN,358,,original.x = screen.x = edges.right;,9,<empty>,,486,358,CPPASTProblemDeclaration,,<empty>
431842,UNKNOWN,359,,original.y = screen.y = 25;,9,<empty>,,487,359,CPPASTProblemDeclaration,,<empty>
431843,UNKNOWN,360,,success = v.IncrementInBounds(screen);,9,<empty>,,489,360,CPPASTProblemDeclaration,,<empty>
431845,UNKNOWN,362,,"VERIFY_ARE_EQUAL(screen.x, edges.left);",9,<empty>,,492,362,CPPASTProblemDeclaration,,<empty>
431846,UNKNOWN,363,,"VERIFY_ARE_EQUAL(screen.y, original.y + 1);",9,<empty>,,493,363,CPPASTProblemDeclaration,,<empty>
431847,UNKNOWN,364,,original.x = screen.x = edges.right;,9,<empty>,,496,364,CPPASTProblemDeclaration,,<empty>
431848,UNKNOWN,365,,original.y = screen.y = edges.bottom;,9,<empty>,,497,365,CPPASTProblemDeclaration,,<empty>
431849,UNKNOWN,366,,success = v.IncrementInBounds(screen);,9,<empty>,,499,366,CPPASTProblemDeclaration,,<empty>
431851,UNKNOWN,368,,"VERIFY_ARE_EQUAL(screen.x, edges.right);",9,<empty>,,502,368,CPPASTProblemDeclaration,,<empty>
431852,UNKNOWN,369,,"VERIFY_ARE_EQUAL(screen.y, edges.bottom);",9,<empty>,,503,369,CPPASTProblemDeclaration,,<empty>
431853,UNKNOWN,370,,},5,<empty>,,504,370,CPPASTProblemDeclaration,,<empty>
431854,UNKNOWN,371,,"TEST_METHOD(IncrementInBoundsCircular)
    {
        auto success = false;",5,<empty>,,506,371,CPPASTProblemDeclaration,,<empty>
431856,UNKNOWN,373,,edges.left = 10;,9,<empty>,,511,373,CPPASTProblemDeclaration,,<empty>
431857,UNKNOWN,374,,edges.right = 19;,9,<empty>,,512,374,CPPASTProblemDeclaration,,<empty>
431858,UNKNOWN,375,,edges.top = 20;,9,<empty>,,513,375,CPPASTProblemDeclaration,,<empty>
431859,UNKNOWN,376,,edges.bottom = 29;,9,<empty>,,514,376,CPPASTProblemDeclaration,,<empty>
431870,UNKNOWN,381,,original.x = screen.x = 15;,9,<empty>,,521,381,CPPASTProblemDeclaration,,<empty>
431871,UNKNOWN,382,,original.y = screen.y = 25;,9,<empty>,,522,382,CPPASTProblemDeclaration,,<empty>
431872,UNKNOWN,383,,success = v.IncrementInBoundsCircular(screen);,9,<empty>,,524,383,CPPASTProblemDeclaration,,<empty>
431874,UNKNOWN,385,,"VERIFY_ARE_EQUAL(screen.x, original.x + 1);",9,<empty>,,527,385,CPPASTProblemDeclaration,,<empty>
431875,UNKNOWN,386,,"VERIFY_ARE_EQUAL(screen.y, original.y);",9,<empty>,,528,386,CPPASTProblemDeclaration,,<empty>
431876,UNKNOWN,387,,original.x = screen.x = edges.right;,9,<empty>,,531,387,CPPASTProblemDeclaration,,<empty>
431877,UNKNOWN,388,,original.y = screen.y = 25;,9,<empty>,,532,388,CPPASTProblemDeclaration,,<empty>
431878,UNKNOWN,389,,success = v.IncrementInBoundsCircular(screen);,9,<empty>,,534,389,CPPASTProblemDeclaration,,<empty>
431880,UNKNOWN,391,,"VERIFY_ARE_EQUAL(screen.x, edges.left);",9,<empty>,,537,391,CPPASTProblemDeclaration,,<empty>
431881,UNKNOWN,392,,"VERIFY_ARE_EQUAL(screen.y, original.y + 1);",9,<empty>,,538,392,CPPASTProblemDeclaration,,<empty>
431882,UNKNOWN,393,,original.x = screen.x = edges.right;,9,<empty>,,541,393,CPPASTProblemDeclaration,,<empty>
431883,UNKNOWN,394,,original.y = screen.y = edges.bottom;,9,<empty>,,542,394,CPPASTProblemDeclaration,,<empty>
431884,UNKNOWN,395,,success = v.IncrementInBoundsCircular(screen);,9,<empty>,,544,395,CPPASTProblemDeclaration,,<empty>
431886,UNKNOWN,397,,"VERIFY_ARE_EQUAL(screen.x, edges.left);",9,<empty>,,547,397,CPPASTProblemDeclaration,,<empty>
431887,UNKNOWN,398,,"VERIFY_ARE_EQUAL(screen.y, edges.top);",9,<empty>,,548,398,CPPASTProblemDeclaration,,<empty>
431888,UNKNOWN,399,,},5,<empty>,,549,399,CPPASTProblemDeclaration,,<empty>
431889,UNKNOWN,400,,"TEST_METHOD(DecrementInBounds)
    {
        auto success = false;",5,<empty>,,551,400,CPPASTProblemDeclaration,,<empty>
431891,UNKNOWN,402,,edges.left = 10;,9,<empty>,,556,402,CPPASTProblemDeclaration,,<empty>
431892,UNKNOWN,403,,edges.right = 19;,9,<empty>,,557,403,CPPASTProblemDeclaration,,<empty>
431893,UNKNOWN,404,,edges.top = 20;,9,<empty>,,558,404,CPPASTProblemDeclaration,,<empty>
431894,UNKNOWN,405,,edges.bottom = 29;,9,<empty>,,559,405,CPPASTProblemDeclaration,,<empty>
431905,UNKNOWN,410,,original.x = screen.x = 15;,9,<empty>,,566,410,CPPASTProblemDeclaration,,<empty>
431906,UNKNOWN,411,,original.y = screen.y = 25;,9,<empty>,,567,411,CPPASTProblemDeclaration,,<empty>
431907,UNKNOWN,412,,success = v.DecrementInBounds(screen);,9,<empty>,,569,412,CPPASTProblemDeclaration,,<empty>
431909,UNKNOWN,414,,"VERIFY_ARE_EQUAL(screen.x, original.x - 1);",9,<empty>,,572,414,CPPASTProblemDeclaration,,<empty>
431910,UNKNOWN,415,,"VERIFY_ARE_EQUAL(screen.y, original.y);",9,<empty>,,573,415,CPPASTProblemDeclaration,,<empty>
431911,UNKNOWN,416,,original.x = screen.x = edges.left;,9,<empty>,,576,416,CPPASTProblemDeclaration,,<empty>
431912,UNKNOWN,417,,original.y = screen.y = 25;,9,<empty>,,577,417,CPPASTProblemDeclaration,,<empty>
431913,UNKNOWN,418,,success = v.DecrementInBounds(screen);,9,<empty>,,579,418,CPPASTProblemDeclaration,,<empty>
431915,UNKNOWN,420,,"VERIFY_ARE_EQUAL(screen.x, edges.right);",9,<empty>,,582,420,CPPASTProblemDeclaration,,<empty>
431916,UNKNOWN,421,,"VERIFY_ARE_EQUAL(screen.y, original.y - 1);",9,<empty>,,583,421,CPPASTProblemDeclaration,,<empty>
431917,UNKNOWN,422,,original.x = screen.x = edges.left;,9,<empty>,,586,422,CPPASTProblemDeclaration,,<empty>
431918,UNKNOWN,423,,original.y = screen.y = edges.top;,9,<empty>,,587,423,CPPASTProblemDeclaration,,<empty>
431919,UNKNOWN,424,,success = v.DecrementInBounds(screen);,9,<empty>,,589,424,CPPASTProblemDeclaration,,<empty>
431921,UNKNOWN,426,,"VERIFY_ARE_EQUAL(screen.x, edges.left);",9,<empty>,,592,426,CPPASTProblemDeclaration,,<empty>
431922,UNKNOWN,427,,"VERIFY_ARE_EQUAL(screen.y, edges.top);",9,<empty>,,593,427,CPPASTProblemDeclaration,,<empty>
431923,UNKNOWN,428,,},5,<empty>,,594,428,CPPASTProblemDeclaration,,<empty>
431924,UNKNOWN,429,,"TEST_METHOD(DecrementInBoundsCircular)
    {
        auto success = false;",5,<empty>,,596,429,CPPASTProblemDeclaration,,<empty>
431926,UNKNOWN,431,,edges.left = 10;,9,<empty>,,601,431,CPPASTProblemDeclaration,,<empty>
431927,UNKNOWN,432,,edges.right = 19;,9,<empty>,,602,432,CPPASTProblemDeclaration,,<empty>
431928,UNKNOWN,433,,edges.top = 20;,9,<empty>,,603,433,CPPASTProblemDeclaration,,<empty>
431929,UNKNOWN,434,,edges.bottom = 29;,9,<empty>,,604,434,CPPASTProblemDeclaration,,<empty>
431940,UNKNOWN,439,,original.x = screen.x = 15;,9,<empty>,,611,439,CPPASTProblemDeclaration,,<empty>
431941,UNKNOWN,440,,original.y = screen.y = 25;,9,<empty>,,612,440,CPPASTProblemDeclaration,,<empty>
431942,UNKNOWN,441,,success = v.DecrementInBoundsCircular(screen);,9,<empty>,,614,441,CPPASTProblemDeclaration,,<empty>
431944,UNKNOWN,443,,"VERIFY_ARE_EQUAL(screen.x, original.x - 1);",9,<empty>,,617,443,CPPASTProblemDeclaration,,<empty>
431945,UNKNOWN,444,,"VERIFY_ARE_EQUAL(screen.y, original.y);",9,<empty>,,618,444,CPPASTProblemDeclaration,,<empty>
431946,UNKNOWN,445,,original.x = screen.x = edges.left;,9,<empty>,,621,445,CPPASTProblemDeclaration,,<empty>
431947,UNKNOWN,446,,original.y = screen.y = 25;,9,<empty>,,622,446,CPPASTProblemDeclaration,,<empty>
431948,UNKNOWN,447,,success = v.DecrementInBoundsCircular(screen);,9,<empty>,,624,447,CPPASTProblemDeclaration,,<empty>
431950,UNKNOWN,449,,"VERIFY_ARE_EQUAL(screen.x, edges.right);",9,<empty>,,627,449,CPPASTProblemDeclaration,,<empty>
431951,UNKNOWN,450,,"VERIFY_ARE_EQUAL(screen.y, original.y - 1);",9,<empty>,,628,450,CPPASTProblemDeclaration,,<empty>
431952,UNKNOWN,451,,original.x = screen.x = edges.left;,9,<empty>,,631,451,CPPASTProblemDeclaration,,<empty>
431953,UNKNOWN,452,,original.y = screen.y = edges.top;,9,<empty>,,632,452,CPPASTProblemDeclaration,,<empty>
431954,UNKNOWN,453,,success = v.DecrementInBoundsCircular(screen);,9,<empty>,,634,453,CPPASTProblemDeclaration,,<empty>
431956,UNKNOWN,455,,"VERIFY_ARE_EQUAL(screen.x, edges.right);",9,<empty>,,637,455,CPPASTProblemDeclaration,,<empty>
431957,UNKNOWN,456,,"VERIFY_ARE_EQUAL(screen.y, edges.bottom);",9,<empty>,,638,456,CPPASTProblemDeclaration,,<empty>
431958,UNKNOWN,457,,},5,<empty>,,639,457,CPPASTProblemDeclaration,,<empty>
431968,UNKNOWN,1,,til::CoordType,18,<empty>,,647,1,CPPASTTypeId,,<empty>
431978,UNKNOWN,459,,"TEST_METHOD(MoveInBounds)
    {
        const auto cTestLoopInstances = 100;",5,<empty>,,653,459,CPPASTProblemDeclaration,,<empty>
431983,UNKNOWN,462,,VERIFY_IS_TRUE(sRowWidth > 0);,9,<empty>,,658,462,CPPASTProblemDeclaration,,<empty>
431985,UNKNOWN,464,,srectEdges.top = srectEdges.left = 0;,9,<empty>,,662,464,CPPASTProblemDeclaration,,<empty>
431986,UNKNOWN,465,,srectEdges.bottom = srectEdges.right = sRowWidth - 1;,9,<empty>,,663,465,CPPASTProblemDeclaration,,<empty>
431995,UNKNOWN,468,,for (UINT i = 0;,9,<empty>,,668,468,CPPASTProblemDeclaration,,<empty>
431996,UNKNOWN,469,,i < cTestLoopInstances;,26,<empty>,,668,469,CPPASTProblemDeclaration,,<empty>
431997,UNKNOWN,470,,"i++)
        {
            til::point coordPos;
            coordPos.x = RandomCoord() % 20;
            coordPos.y = RandomCoord() % 20;

            auto sAddAmount = RandomCoord() % (sRowWidth * sRowWidth);

            til::point coordFinal;
            coordFinal.x = (coordPos.x + sAddAmount) % sRowWidth;
            coordFinal.y = coordPos.y + ((coordPos.x + sAddAmount) / sRowWidth);

            Log::Comment(String().Format(L""Add To Position: (%d, %d)  Amount to add: %d"", coordPos.y, coordPos.x, sAddAmount));

            // Movement result is expected to be true, unless there's an error.
            auto fExpectedResult = true;

            // if we've calculated past the final row, then the function will reset to the original position and the output will be false.
            if (coordFinal.y >= sRowWidth)
            {
                coordFinal = coordPos;
                fExpectedResult = false;
            }

            const bool fActualResult = v.MoveInBounds(sAddAmo...",50,<empty>,,668,470,CPPASTProblemDeclaration,,<empty>
431998,UNKNOWN,471,,},5,<empty>,,700,471,CPPASTProblemDeclaration,,<empty>
431999,UNKNOWN,472,,"TEST_METHOD(CompareInBounds)
    {
        til::inclusive_rect edges;",5,<empty>,,702,472,CPPASTProblemDeclaration,,<empty>
432000,UNKNOWN,473,,edges.left = 10;,9,<empty>,,705,473,CPPASTProblemDeclaration,,<empty>
432001,UNKNOWN,474,,edges.right = 19;,9,<empty>,,706,474,CPPASTProblemDeclaration,,<empty>
432002,UNKNOWN,475,,edges.top = 20;,9,<empty>,,707,475,CPPASTProblemDeclaration,,<empty>
432003,UNKNOWN,476,,edges.bottom = 29;,9,<empty>,,708,476,CPPASTProblemDeclaration,,<empty>
432014,UNKNOWN,481,,first.x = 12;,9,<empty>,,713,481,CPPASTProblemDeclaration,,<empty>
432015,UNKNOWN,482,,first.y = 24;,9,<empty>,,714,482,CPPASTProblemDeclaration,,<empty>
432016,UNKNOWN,483,,second = first;,9,<empty>,,715,483,CPPASTProblemDeclaration,,<empty>
432017,UNKNOWN,484,,second.x += 2;,9,<empty>,,716,484,CPPASTProblemDeclaration,,<empty>
432018,UNKNOWN,485,,"VERIFY_ARE_EQUAL(-2, v.CompareInBounds(first, second), L""Second and first on same row. Second is right of first."");",9,<empty>,,718,485,CPPASTProblemDeclaration,,<empty>
432019,UNKNOWN,486,,"VERIFY_ARE_EQUAL(2, v.CompareInBounds(second, first), L""Reverse params, should get opposite direction, same magnitude."");",9,<empty>,,719,486,CPPASTProblemDeclaration,,<empty>
432020,UNKNOWN,487,,first.x = edges.left;,9,<empty>,,721,487,CPPASTProblemDeclaration,,<empty>
432021,UNKNOWN,488,,first.y = 24;,9,<empty>,,722,488,CPPASTProblemDeclaration,,<empty>
432022,UNKNOWN,489,,second.x = edges.right;,9,<empty>,,724,489,CPPASTProblemDeclaration,,<empty>
432023,UNKNOWN,490,,second.y = first.y - 1;,9,<empty>,,725,490,CPPASTProblemDeclaration,,<empty>
432024,UNKNOWN,491,,"VERIFY_ARE_EQUAL(1, v.CompareInBounds(first, second), L""Second is up a line at the right edge from first at the line below on the left edge."");",9,<empty>,,727,491,CPPASTProblemDeclaration,,<empty>
432025,UNKNOWN,492,,"VERIFY_ARE_EQUAL(-1, v.CompareInBounds(second, first), L""Reverse params, should get opposite direction, same magnitude."");",9,<empty>,,728,492,CPPASTProblemDeclaration,,<empty>
432026,UNKNOWN,493,,},5,<empty>,,729,493,CPPASTProblemDeclaration,,<empty>
432027,UNKNOWN,494,,"TEST_METHOD(Offset)
    {
        til::inclusive_rect edges;",5,<empty>,,731,494,CPPASTProblemDeclaration,,<empty>
432028,UNKNOWN,495,,edges.top = 0;,9,<empty>,,734,495,CPPASTProblemDeclaration,,<empty>
432029,UNKNOWN,496,,edges.left = 0;,9,<empty>,,735,496,CPPASTProblemDeclaration,,<empty>
432030,UNKNOWN,497,,edges.right = 10;,9,<empty>,,736,497,CPPASTProblemDeclaration,,<empty>
432031,UNKNOWN,498,,edges.bottom = 10;,9,<empty>,,737,498,CPPASTProblemDeclaration,,<empty>
432040,UNKNOWN,501,,"Log::Comment(L""Move down and to the right first."");",9,<empty>,,741,501,CPPASTProblemDeclaration,,<empty>
432048,UNKNOWN,505,,expectedEdges.top = edges.top + adjust.y;,9,<empty>,,744,505,CPPASTProblemDeclaration,,<empty>
432049,UNKNOWN,506,,expectedEdges.bottom = edges.bottom + adjust.y;,9,<empty>,,745,506,CPPASTProblemDeclaration,,<empty>
432050,UNKNOWN,507,,expectedEdges.left = edges.left + adjust.x;,9,<empty>,,746,507,CPPASTProblemDeclaration,,<empty>
432051,UNKNOWN,508,,expectedEdges.right = edges.right + adjust.x;,9,<empty>,,747,508,CPPASTProblemDeclaration,,<empty>
432069,UNKNOWN,513,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,752,513,CPPASTProblemDeclaration,,<empty>
432070,UNKNOWN,514,,"Log::Comment(L""Now try moving up and to the left."");",9,<empty>,,754,514,CPPASTProblemDeclaration,,<empty>
432079,UNKNOWN,517,,expectedEdges.top = edges.top + adjust.y;,9,<empty>,,757,517,CPPASTProblemDeclaration,,<empty>
432080,UNKNOWN,518,,expectedEdges.bottom = edges.bottom + adjust.y;,9,<empty>,,758,518,CPPASTProblemDeclaration,,<empty>
432081,UNKNOWN,519,,expectedEdges.left = edges.left + adjust.x;,9,<empty>,,759,519,CPPASTProblemDeclaration,,<empty>
432082,UNKNOWN,520,,expectedEdges.right = edges.right + adjust.x;,9,<empty>,,760,520,CPPASTProblemDeclaration,,<empty>
432083,UNKNOWN,521,,expected = Viewport::FromInclusive(expectedEdges);,9,<empty>,,762,521,CPPASTProblemDeclaration,,<empty>
432084,UNKNOWN,522,,"actual = Viewport::Offset(original, adjust);",9,<empty>,,763,522,CPPASTProblemDeclaration,,<empty>
432085,UNKNOWN,523,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,764,523,CPPASTProblemDeclaration,,<empty>
432086,UNKNOWN,524,,},5,<empty>,,765,524,CPPASTProblemDeclaration,,<empty>
432087,UNKNOWN,525,,"TEST_METHOD(Union)
    {
        til::inclusive_rect srOne;",5,<empty>,,767,525,CPPASTProblemDeclaration,,<empty>
432088,UNKNOWN,526,,srOne.left = 4;,9,<empty>,,770,526,CPPASTProblemDeclaration,,<empty>
432089,UNKNOWN,527,,srOne.right = 10;,9,<empty>,,771,527,CPPASTProblemDeclaration,,<empty>
432090,UNKNOWN,528,,srOne.top = 6;,9,<empty>,,772,528,CPPASTProblemDeclaration,,<empty>
432091,UNKNOWN,529,,srOne.bottom = 14;,9,<empty>,,773,529,CPPASTProblemDeclaration,,<empty>
432101,UNKNOWN,533,,srTwo.left = 5;,9,<empty>,,777,533,CPPASTProblemDeclaration,,<empty>
432102,UNKNOWN,534,,srTwo.right = 13;,9,<empty>,,778,534,CPPASTProblemDeclaration,,<empty>
432103,UNKNOWN,535,,srTwo.top = 2;,9,<empty>,,779,535,CPPASTProblemDeclaration,,<empty>
432104,UNKNOWN,536,,srTwo.bottom = 10;,9,<empty>,,780,536,CPPASTProblemDeclaration,,<empty>
432114,UNKNOWN,540,,srExpected.left = srOne.left < srTwo.left ? srOne.left : srTwo.left;,9,<empty>,,784,540,CPPASTProblemDeclaration,,<empty>
432115,UNKNOWN,541,,srExpected.right = srOne.right > srTwo.right ? srOne.right : srTwo.right;,9,<empty>,,785,541,CPPASTProblemDeclaration,,<empty>
432116,UNKNOWN,542,,srExpected.top = srOne.top < srTwo.top ? srOne.top : srTwo.top;,9,<empty>,,786,542,CPPASTProblemDeclaration,,<empty>
432117,UNKNOWN,543,,srExpected.bottom = srOne.bottom > srTwo.bottom ? srOne.bottom : srTwo.bottom;,9,<empty>,,787,543,CPPASTProblemDeclaration,,<empty>
432135,UNKNOWN,548,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,792,548,CPPASTProblemDeclaration,,<empty>
432136,UNKNOWN,549,,},5,<empty>,,793,549,CPPASTProblemDeclaration,,<empty>
432137,UNKNOWN,550,,"TEST_METHOD(Intersect)
    {
        til::inclusive_rect srOne;",5,<empty>,,795,550,CPPASTProblemDeclaration,,<empty>
432138,UNKNOWN,551,,srOne.left = 4;,9,<empty>,,798,551,CPPASTProblemDeclaration,,<empty>
432139,UNKNOWN,552,,srOne.right = 10;,9,<empty>,,799,552,CPPASTProblemDeclaration,,<empty>
432140,UNKNOWN,553,,srOne.top = 6;,9,<empty>,,800,553,CPPASTProblemDeclaration,,<empty>
432141,UNKNOWN,554,,srOne.bottom = 14;,9,<empty>,,801,554,CPPASTProblemDeclaration,,<empty>
432151,UNKNOWN,558,,srTwo.left = 5;,9,<empty>,,805,558,CPPASTProblemDeclaration,,<empty>
432152,UNKNOWN,559,,srTwo.right = 13;,9,<empty>,,806,559,CPPASTProblemDeclaration,,<empty>
432153,UNKNOWN,560,,srTwo.top = 2;,9,<empty>,,807,560,CPPASTProblemDeclaration,,<empty>
432154,UNKNOWN,561,,srTwo.bottom = 10;,9,<empty>,,808,561,CPPASTProblemDeclaration,,<empty>
432164,UNKNOWN,565,,srExpected.left = srOne.left > srTwo.left ? srOne.left : srTwo.left;,9,<empty>,,812,565,CPPASTProblemDeclaration,,<empty>
432165,UNKNOWN,566,,srExpected.right = srOne.right < srTwo.right ? srOne.right : srTwo.right;,9,<empty>,,813,566,CPPASTProblemDeclaration,,<empty>
432166,UNKNOWN,567,,srExpected.top = srOne.top > srTwo.top ? srOne.top : srTwo.top;,9,<empty>,,814,567,CPPASTProblemDeclaration,,<empty>
432167,UNKNOWN,568,,srExpected.bottom = srOne.bottom < srTwo.bottom ? srOne.bottom : srTwo.bottom;,9,<empty>,,815,568,CPPASTProblemDeclaration,,<empty>
432185,UNKNOWN,573,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,820,573,CPPASTProblemDeclaration,,<empty>
432186,UNKNOWN,574,,},5,<empty>,,821,574,CPPASTProblemDeclaration,,<empty>
432187,UNKNOWN,575,,"TEST_METHOD(SubtractFour)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,823,575,CPPASTProblemDeclaration,,<empty>
432188,UNKNOWN,576,,srOriginal.top = 0;,9,<empty>,,826,576,CPPASTProblemDeclaration,,<empty>
432189,UNKNOWN,577,,srOriginal.left = 0;,9,<empty>,,827,577,CPPASTProblemDeclaration,,<empty>
432190,UNKNOWN,578,,srOriginal.bottom = 10;,9,<empty>,,828,578,CPPASTProblemDeclaration,,<empty>
432191,UNKNOWN,579,,srOriginal.right = 10;,9,<empty>,,829,579,CPPASTProblemDeclaration,,<empty>
432201,UNKNOWN,583,,srRemove.top = 3;,9,<empty>,,833,583,CPPASTProblemDeclaration,,<empty>
432202,UNKNOWN,584,,srRemove.left = 3;,9,<empty>,,834,584,CPPASTProblemDeclaration,,<empty>
432203,UNKNOWN,585,,srRemove.bottom = 6;,9,<empty>,,835,585,CPPASTProblemDeclaration,,<empty>
432204,UNKNOWN,586,,srRemove.right = 6;,9,<empty>,,836,586,CPPASTProblemDeclaration,,<empty>
432214,UNKNOWN,590,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srOriginal.top, srOriginal.right, srRemove.top - 1 }",9,<empty>,,842,590,CPPASTProblemDeclaration,,<empty>
432215,UNKNOWN,591,,));,126,<empty>,,842,591,CPPASTProblemDeclaration,,<empty>
432216,UNKNOWN,592,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srRemove.bottom + 1, srOriginal.right, srOriginal.bottom }",9,<empty>,,844,592,CPPASTProblemDeclaration,,<empty>
432217,UNKNOWN,593,,));,132,<empty>,,844,593,CPPASTProblemDeclaration,,<empty>
432218,UNKNOWN,594,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srRemove.top, srRemove.left - 1, srRemove.bottom }",9,<empty>,,846,594,CPPASTProblemDeclaration,,<empty>
432219,UNKNOWN,595,,));,124,<empty>,,846,595,CPPASTProblemDeclaration,,<empty>
432220,UNKNOWN,596,,"expected.emplace_back(Viewport::FromInclusive({ srRemove.right + 1, srRemove.top, srOriginal.right, srRemove.bottom }",9,<empty>,,848,596,CPPASTProblemDeclaration,,<empty>
432221,UNKNOWN,597,,));,126,<empty>,,848,597,CPPASTProblemDeclaration,,<empty>
432231,UNKNOWN,600,,"VERIFY_ARE_EQUAL(expected.size(), actual.size(), L""Same number of viewports in expected and actual"");",9,<empty>,,852,600,CPPASTProblemDeclaration,,<empty>
432232,UNKNOWN,601,,"Log::Comment(L""Now validate that each viewport has the expected area."");",9,<empty>,,853,601,CPPASTProblemDeclaration,,<empty>
432233,UNKNOWN,602,,for (size_t i = 0;,9,<empty>,,854,602,CPPASTProblemDeclaration,,<empty>
432234,UNKNOWN,603,,i < expected.size();,28,<empty>,,854,603,CPPASTProblemDeclaration,,<empty>
432235,UNKNOWN,604,,"i++)
        {
            const auto& exp = expected.at(i);
            const auto& act = actual.at(i);
            VERIFY_ARE_EQUAL(exp, act);
        }",49,<empty>,,854,604,CPPASTProblemDeclaration,,<empty>
432236,UNKNOWN,605,,},5,<empty>,,860,605,CPPASTProblemDeclaration,,<empty>
432237,UNKNOWN,606,,"TEST_METHOD(SubtractThree)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,862,606,CPPASTProblemDeclaration,,<empty>
432238,UNKNOWN,607,,srOriginal.top = 0;,9,<empty>,,865,607,CPPASTProblemDeclaration,,<empty>
432239,UNKNOWN,608,,srOriginal.left = 0;,9,<empty>,,866,608,CPPASTProblemDeclaration,,<empty>
432240,UNKNOWN,609,,srOriginal.bottom = 10;,9,<empty>,,867,609,CPPASTProblemDeclaration,,<empty>
432241,UNKNOWN,610,,srOriginal.right = 10;,9,<empty>,,868,610,CPPASTProblemDeclaration,,<empty>
432251,UNKNOWN,614,,srRemove.top = 3;,9,<empty>,,872,614,CPPASTProblemDeclaration,,<empty>
432252,UNKNOWN,615,,srRemove.left = 3;,9,<empty>,,873,615,CPPASTProblemDeclaration,,<empty>
432253,UNKNOWN,616,,srRemove.bottom = 6;,9,<empty>,,874,616,CPPASTProblemDeclaration,,<empty>
432254,UNKNOWN,617,,srRemove.right = 15;,9,<empty>,,875,617,CPPASTProblemDeclaration,,<empty>
432264,UNKNOWN,621,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srOriginal.top, srOriginal.right, srRemove.top - 1 }",9,<empty>,,881,621,CPPASTProblemDeclaration,,<empty>
432265,UNKNOWN,622,,));,126,<empty>,,881,622,CPPASTProblemDeclaration,,<empty>
432266,UNKNOWN,623,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srRemove.bottom + 1, srOriginal.right, srOriginal.bottom }",9,<empty>,,883,623,CPPASTProblemDeclaration,,<empty>
432267,UNKNOWN,624,,));,132,<empty>,,883,624,CPPASTProblemDeclaration,,<empty>
432268,UNKNOWN,625,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srRemove.top, srRemove.left - 1, srRemove.bottom }",9,<empty>,,885,625,CPPASTProblemDeclaration,,<empty>
432269,UNKNOWN,626,,));,124,<empty>,,885,626,CPPASTProblemDeclaration,,<empty>
432279,UNKNOWN,629,,"VERIFY_ARE_EQUAL(expected.size(), actual.size(), L""Same number of viewports in expected and actual"");",9,<empty>,,889,629,CPPASTProblemDeclaration,,<empty>
432280,UNKNOWN,630,,"Log::Comment(L""Now validate that each viewport has the expected area."");",9,<empty>,,890,630,CPPASTProblemDeclaration,,<empty>
432281,UNKNOWN,631,,for (size_t i = 0;,9,<empty>,,891,631,CPPASTProblemDeclaration,,<empty>
432282,UNKNOWN,632,,i < expected.size();,28,<empty>,,891,632,CPPASTProblemDeclaration,,<empty>
432283,UNKNOWN,633,,"i++)
        {
            const auto& exp = expected.at(i);
            const auto& act = actual.at(i);
            VERIFY_ARE_EQUAL(exp, act);
        }",49,<empty>,,891,633,CPPASTProblemDeclaration,,<empty>
432284,UNKNOWN,634,,},5,<empty>,,897,634,CPPASTProblemDeclaration,,<empty>
432285,UNKNOWN,635,,"TEST_METHOD(SubtractTwo)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,899,635,CPPASTProblemDeclaration,,<empty>
432286,UNKNOWN,636,,srOriginal.top = 0;,9,<empty>,,902,636,CPPASTProblemDeclaration,,<empty>
432287,UNKNOWN,637,,srOriginal.left = 0;,9,<empty>,,903,637,CPPASTProblemDeclaration,,<empty>
432288,UNKNOWN,638,,srOriginal.bottom = 10;,9,<empty>,,904,638,CPPASTProblemDeclaration,,<empty>
432289,UNKNOWN,639,,srOriginal.right = 10;,9,<empty>,,905,639,CPPASTProblemDeclaration,,<empty>
432299,UNKNOWN,643,,srRemove.top = 3;,9,<empty>,,909,643,CPPASTProblemDeclaration,,<empty>
432300,UNKNOWN,644,,srRemove.left = 3;,9,<empty>,,910,644,CPPASTProblemDeclaration,,<empty>
432301,UNKNOWN,645,,srRemove.bottom = 15;,9,<empty>,,911,645,CPPASTProblemDeclaration,,<empty>
432302,UNKNOWN,646,,srRemove.right = 15;,9,<empty>,,912,646,CPPASTProblemDeclaration,,<empty>
432312,UNKNOWN,650,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srOriginal.top, srOriginal.right, srRemove.top - 1 }",9,<empty>,,918,650,CPPASTProblemDeclaration,,<empty>
432313,UNKNOWN,651,,));,126,<empty>,,918,651,CPPASTProblemDeclaration,,<empty>
432314,UNKNOWN,652,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srRemove.top, srRemove.left - 1, srOriginal.bottom }",9,<empty>,,920,652,CPPASTProblemDeclaration,,<empty>
432315,UNKNOWN,653,,));,126,<empty>,,920,653,CPPASTProblemDeclaration,,<empty>
432325,UNKNOWN,656,,"VERIFY_ARE_EQUAL(expected.size(), actual.size(), L""Same number of viewports in expected and actual"");",9,<empty>,,924,656,CPPASTProblemDeclaration,,<empty>
432326,UNKNOWN,657,,"Log::Comment(L""Now validate that each viewport has the expected area."");",9,<empty>,,925,657,CPPASTProblemDeclaration,,<empty>
432327,UNKNOWN,658,,for (size_t i = 0;,9,<empty>,,926,658,CPPASTProblemDeclaration,,<empty>
432328,UNKNOWN,659,,i < expected.size();,28,<empty>,,926,659,CPPASTProblemDeclaration,,<empty>
432329,UNKNOWN,660,,"i++)
        {
            const auto& exp = expected.at(i);
            const auto& act = actual.at(i);
            VERIFY_ARE_EQUAL(exp, act);
        }",49,<empty>,,926,660,CPPASTProblemDeclaration,,<empty>
432330,UNKNOWN,661,,},5,<empty>,,932,661,CPPASTProblemDeclaration,,<empty>
432331,UNKNOWN,662,,"TEST_METHOD(SubtractOne)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,934,662,CPPASTProblemDeclaration,,<empty>
432332,UNKNOWN,663,,srOriginal.top = 0;,9,<empty>,,937,663,CPPASTProblemDeclaration,,<empty>
432333,UNKNOWN,664,,srOriginal.left = 0;,9,<empty>,,938,664,CPPASTProblemDeclaration,,<empty>
432334,UNKNOWN,665,,srOriginal.bottom = 10;,9,<empty>,,939,665,CPPASTProblemDeclaration,,<empty>
432335,UNKNOWN,666,,srOriginal.right = 10;,9,<empty>,,940,666,CPPASTProblemDeclaration,,<empty>
432345,UNKNOWN,670,,srRemove.top = 3;,9,<empty>,,944,670,CPPASTProblemDeclaration,,<empty>
432346,UNKNOWN,671,,srRemove.left = -12;,9,<empty>,,945,671,CPPASTProblemDeclaration,,<empty>
432347,UNKNOWN,672,,srRemove.bottom = 15;,9,<empty>,,946,672,CPPASTProblemDeclaration,,<empty>
432348,UNKNOWN,673,,srRemove.right = 15;,9,<empty>,,947,673,CPPASTProblemDeclaration,,<empty>
432358,UNKNOWN,677,,"expected.emplace_back(Viewport::FromInclusive({ srOriginal.left, srOriginal.top, srOriginal.right, srRemove.top - 1 }",9,<empty>,,953,677,CPPASTProblemDeclaration,,<empty>
432359,UNKNOWN,678,,));,126,<empty>,,953,678,CPPASTProblemDeclaration,,<empty>
432376,UNKNOWN,683,,"VERIFY_ARE_EQUAL(expected.size(), actual.size(), L""Same number of viewports in expected and actual"");",9,<empty>,,959,683,CPPASTProblemDeclaration,,<empty>
432377,UNKNOWN,684,,"Log::Comment(L""Now validate that each viewport has the expected area."");",9,<empty>,,960,684,CPPASTProblemDeclaration,,<empty>
432378,UNKNOWN,685,,for (size_t i = 0;,9,<empty>,,961,685,CPPASTProblemDeclaration,,<empty>
432379,UNKNOWN,686,,i < expected.size();,28,<empty>,,961,686,CPPASTProblemDeclaration,,<empty>
432380,UNKNOWN,687,,"i++)
        {
            const auto& exp = expected.at(i);
            const auto& act = actual.at(i);
            VERIFY_ARE_EQUAL(exp, act);
        }",49,<empty>,,961,687,CPPASTProblemDeclaration,,<empty>
432381,UNKNOWN,688,,},5,<empty>,,967,688,CPPASTProblemDeclaration,,<empty>
432382,UNKNOWN,689,,"TEST_METHOD(SubtractZero)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,969,689,CPPASTProblemDeclaration,,<empty>
432383,UNKNOWN,690,,srOriginal.top = 0;,9,<empty>,,972,690,CPPASTProblemDeclaration,,<empty>
432384,UNKNOWN,691,,srOriginal.left = 0;,9,<empty>,,973,691,CPPASTProblemDeclaration,,<empty>
432385,UNKNOWN,692,,srOriginal.bottom = 10;,9,<empty>,,974,692,CPPASTProblemDeclaration,,<empty>
432386,UNKNOWN,693,,srOriginal.right = 10;,9,<empty>,,975,693,CPPASTProblemDeclaration,,<empty>
432396,UNKNOWN,697,,srRemove.top = 12;,9,<empty>,,979,697,CPPASTProblemDeclaration,,<empty>
432397,UNKNOWN,698,,srRemove.left = 12;,9,<empty>,,980,698,CPPASTProblemDeclaration,,<empty>
432398,UNKNOWN,699,,srRemove.bottom = 15;,9,<empty>,,981,699,CPPASTProblemDeclaration,,<empty>
432399,UNKNOWN,700,,srRemove.right = 15;,9,<empty>,,982,700,CPPASTProblemDeclaration,,<empty>
432409,UNKNOWN,704,,expected.emplace_back(original);,9,<empty>,,986,704,CPPASTProblemDeclaration,,<empty>
432419,UNKNOWN,707,,"VERIFY_ARE_EQUAL(expected.size(), actual.size(), L""Same number of viewports in expected and actual"");",9,<empty>,,990,707,CPPASTProblemDeclaration,,<empty>
432420,UNKNOWN,708,,"Log::Comment(L""Now validate that each viewport has the expected area."");",9,<empty>,,991,708,CPPASTProblemDeclaration,,<empty>
432421,UNKNOWN,709,,for (size_t i = 0;,9,<empty>,,992,709,CPPASTProblemDeclaration,,<empty>
432422,UNKNOWN,710,,i < expected.size();,28,<empty>,,992,710,CPPASTProblemDeclaration,,<empty>
432423,UNKNOWN,711,,"i++)
        {
            const auto& exp = expected.at(i);
            const auto& act = actual.at(i);
            VERIFY_ARE_EQUAL(exp, act);
        }",49,<empty>,,992,711,CPPASTProblemDeclaration,,<empty>
432424,UNKNOWN,712,,},5,<empty>,,998,712,CPPASTProblemDeclaration,,<empty>
432425,UNKNOWN,713,,"TEST_METHOD(SubtractSame)
    {
        til::inclusive_rect srOriginal;",5,<empty>,,1000,713,CPPASTProblemDeclaration,,<empty>
432426,UNKNOWN,714,,srOriginal.top = 0;,9,<empty>,,1003,714,CPPASTProblemDeclaration,,<empty>
432427,UNKNOWN,715,,srOriginal.left = 0;,9,<empty>,,1004,715,CPPASTProblemDeclaration,,<empty>
432428,UNKNOWN,716,,srOriginal.bottom = 10;,9,<empty>,,1005,716,CPPASTProblemDeclaration,,<empty>
432429,UNKNOWN,717,,srOriginal.right = 10;,9,<empty>,,1006,717,CPPASTProblemDeclaration,,<empty>
432451,UNKNOWN,724,,"VERIFY_ARE_EQUAL(0u, actual.size(), L""There should be no viewports returned"");",9,<empty>,,1012,724,CPPASTProblemDeclaration,,<empty>
432452,UNKNOWN,725,,},5,<empty>,,1013,725,CPPASTProblemDeclaration,,<empty>
432453,UNKNOWN,726,,};,1,<empty>,,1014,726,CPPASTProblemDeclaration,,<empty>
432491,UNKNOWN,-1,,),31,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
432492,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""IsolationLevel"", L""Class"")
    END_TEST_CLASS()

    // General Tests:
    TEST_METHOD(NoOpStartTest);",9,<empty>,,27,3,CPPASTProblemDeclaration,,<empty>
435088,UNKNOWN,1,,til::CoordType,81,<empty>,,777,1,CPPASTTypeId,,<empty>
436454,UNKNOWN,1,,til::CoordType,81,<empty>,,1454,1,CPPASTTypeId,,<empty>
436627,UNKNOWN,1,,til::CoordType,83,<empty>,,1578,1,CPPASTTypeId,,<empty>
436657,UNKNOWN,1,,til::CoordType,83,<empty>,,1583,1,CPPASTTypeId,,<empty>
436931,UNKNOWN,9,,"TEST_METHOD_SETUP(MethodSetup)
    {
        qExpectedInput.clear();",5,<empty>,,56,9,CPPASTProblemDeclaration,,<empty>
436932,UNKNOWN,10,,return true;,9,<empty>,,59,10,CPPASTProblemDeclaration,,<empty>
436933,UNKNOWN,11,,},5,<empty>,,60,11,CPPASTProblemDeclaration,,<empty>
437022,UNKNOWN,35,,};,1,<empty>,,120,35,CPPASTProblemDeclaration,,<empty>
437072,UNKNOWN,1,,size_t,40,<empty>,,136,1,CPPASTTypeId,,<empty>
438003,UNKNOWN,-1,,),34,<empty>,,801,2,CPPASTProblemStatement,,<empty>
438007,UNKNOWN,-1,,),61,<empty>,,802,4,CPPASTProblemStatement,,<empty>
438011,UNKNOWN,-1,,),66,<empty>,,803,6,CPPASTProblemStatement,,<empty>
438015,UNKNOWN,-1,,),72,<empty>,,804,8,CPPASTProblemStatement,,<empty>
438019,UNKNOWN,-1,,),63,<empty>,,805,10,CPPASTProblemStatement,,<empty>
438023,UNKNOWN,-1,,),61,<empty>,,806,12,CPPASTProblemStatement,,<empty>
438027,UNKNOWN,-1,,),65,<empty>,,807,14,CPPASTProblemStatement,,<empty>
438031,UNKNOWN,-1,,),66,<empty>,,808,16,CPPASTProblemStatement,,<empty>
438033,UNKNOWN,-1,,),32,<empty>,,809,18,CPPASTProblemStatement,,<empty>
438334,UNKNOWN,-1,,),34,<empty>,,909,2,CPPASTProblemStatement,,<empty>
438338,UNKNOWN,-1,,),93,<empty>,,910,4,CPPASTProblemStatement,,<empty>
438340,UNKNOWN,-1,,),32,<empty>,,911,6,CPPASTProblemStatement,,<empty>
439311,UNKNOWN,-1,,),34,<empty>,,1477,2,CPPASTProblemStatement,,<empty>
439315,UNKNOWN,-1,,),70,<empty>,,1478,4,CPPASTProblemStatement,,<empty>
439317,UNKNOWN,-1,,),32,<empty>,,1479,6,CPPASTProblemStatement,,<empty>
439947,UNKNOWN,-1,,),34,<empty>,,1731,2,CPPASTProblemStatement,,<empty>
439951,UNKNOWN,-1,,),58,<empty>,,1732,4,CPPASTProblemStatement,,<empty>
440142,UNKNOWN,11,,"[[nodiscard]] HRESULT Utf8ToWideCharParser::Parse(_In_reads_(cchBuffer) const byte* const pBytes,
                                                  _In_ const unsigned int cchBuffer,
                                                  _Out_ unsigned int& cchConsumed,
                                                  _Inout_ std::unique_ptr<wchar_t[]>& converted,
                                                  _Out_ unsigned int& cchConverted)
{
    cchConsumed = 0;
    cchConverted = 0;

    // we can't parse anything if we weren't given any data to parse
    if (cchBuffer == 0)
    {
        return S_OK;
    }
    // we shouldn't be parsing if the current codepage isn't UTF8
    if (_currentCodePage != CP_UTF8)
    {
        _currentState = _State::Error;
    }
    auto hr = S_OK;
    try
    {
        auto loop = true;
        unsigned int wideCharCount = 0;
        _convertedWideChars.reset(nullptr);
        while (loop)
        {
            switch (_currentState)
            {
...",1,<empty>,,68,11,CPPASTProblemDeclaration,,<empty>
440143,UNKNOWN,12,,"bool Utf8ToWideCharParser::_IsLeadByte(_In_ byte ch)
{
    auto sequenceSize = _Utf8SequenceSize(ch);
    return !_IsContinuationByte(ch) &&
           !_IsAsciiByte(ch) &&
           sequenceSize > 1 &&
           sequenceSize <= _UTF8_BYTE_SEQUENCE_MAX;
}",1,<empty>,,142,12,CPPASTProblemDeclaration,,<empty>
440144,UNKNOWN,13,,"bool Utf8ToWideCharParser::_IsContinuationByte(_In_ byte ch)
{
    return (ch & ContinuationByteMask) == ContinuationBytePrefix;
}",1,<empty>,,159,13,CPPASTProblemDeclaration,,<empty>
440145,UNKNOWN,14,,"bool Utf8ToWideCharParser::_IsAsciiByte(_In_ byte ch)
{
    return !IsBitSet(ch, NonAsciiBytePrefix);
}",1,<empty>,,171,14,CPPASTProblemDeclaration,,<empty>
440146,UNKNOWN,15,,"bool Utf8ToWideCharParser::_IsValidMultiByteSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb)
{
    if (!_IsLeadByte(*pLeadByte))
    {
        return false;
    }
    const auto sequenceSize = _Utf8SequenceSize(*pLeadByte);
    if (sequenceSize > cb)
    {
        return false;
    }
    // i starts at 1 so that we skip the lead byte
    for (unsigned int i = 1; i < sequenceSize; ++i)
    {
        const auto ch = *(pLeadByte + i);
        if (!_IsContinuationByte(ch))
        {
            return false;
        }
    }
    return true;
}",1,<empty>,,187,15,CPPASTProblemDeclaration,,<empty>
440147,UNKNOWN,16,,"bool Utf8ToWideCharParser::_IsPartialMultiByteSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb)
{
    if (!_IsLeadByte(*pLeadByte))
    {
        return false;
    }
    const auto sequenceSize = _Utf8SequenceSize(*pLeadByte);
    if (sequenceSize <= cb)
    {
        return false;
    }
    // i starts at 1 so that we skip the lead byte
    for (unsigned int i = 1; i < cb; ++i)
    {
        const auto ch = *(pLeadByte + i);
        if (!_IsContinuationByte(ch))
        {
            return false;
        }
    }
    return true;
}",1,<empty>,,222,16,CPPASTProblemDeclaration,,<empty>
440148,UNKNOWN,17,,"unsigned int Utf8ToWideCharParser::_Utf8SequenceSize(_In_ byte ch)
{
    unsigned int msbOnes = 0;
    while (IsBitSet(ch, MostSignificantBitMask))
    {
        ++msbOnes;
        ch <<= 1;
    }
    return msbOnes;
}",1,<empty>,,269,17,CPPASTProblemDeclaration,,<empty>
440149,UNKNOWN,18,,"unsigned int Utf8ToWideCharParser::_ParseFullRange(_In_reads_(cb) const byte* const pInputChars, const unsigned int cb)
{
    auto bufferSize = MultiByteToWideChar(_currentCodePage,
                                          MB_ERR_INVALID_CHARS,
                                          reinterpret_cast<LPCCH>(pInputChars),
                                          cb,
                                          nullptr,
                                          0);
    if (bufferSize == 0)
    {
        auto err = GetLastError();
        LOG_WIN32(err);
        if (err == ERROR_NO_UNICODE_TRANSLATION)
        {
            _currentState = _State::BeginPartialParse;
        }
        else
        {
            _currentState = _State::Error;
        }
    }
    else
    {
        _convertedWideChars = std::make_unique<wchar_t[]>(bufferSize);
        bufferSize = MultiByteToWideChar(_currentCodePage,
                                         0,
                                         re...",1,<empty>,,293,18,CPPASTProblemDeclaration,,<empty>
440150,UNKNOWN,19,,"unsigned int Utf8ToWideCharParser::_InvolvedParse(_In_reads_(cb) const byte* const pInputChars, const unsigned int cb)
{
    // Do safe math to add up the count and error if it won't fit.
    unsigned int count;
    const auto hr = UIntAdd(cb, _bytesStored, &count);
    if (FAILED(hr))
    {
        LOG_HR(hr);
        _currentState = _State::Error;
        return 0;
    }

    // Allocate space and copy.
    auto combinedInputBytes = std::make_unique<byte[]>(count);
    std::copy(_utf8CodePointPieces, _utf8CodePointPieces + _bytesStored, combinedInputBytes.get());
    std::copy(pInputChars, pInputChars + cb, combinedInputBytes.get() + _bytesStored);
    _bytesStored = 0;
    auto validSequence = _RemoveInvalidSequences(combinedInputBytes.get(), count);
    // the input may have only been a partial sequence so we need to
    // check that there are actually any bytes that we can convert
    // right now
    if (validSequence.second == 0 && _bytesStored > 0)
    {
        _currentSta...",1,<empty>,,354,19,CPPASTProblemDeclaration,,<empty>
440151,UNKNOWN,20,,"std::pair<std::unique_ptr<byte[]>, unsigned int> Utf8ToWideCharParser::_RemoveInvalidSequences(_In_reads_(cb) const byte* const pInputChars, const unsigned int cb)
{
    auto validSequence = std::make_unique<byte[]>(cb);
    unsigned int validSequenceLocation = 0; // index into validSequence
    unsigned int currentByteInput = 0; // index into pInputChars
    while (currentByteInput < cb)
    {
        if (_IsAsciiByte(pInputChars[currentByteInput]))
        {
            validSequence[validSequenceLocation] = pInputChars[currentByteInput];
            ++validSequenceLocation;
            ++currentByteInput;
        }
        else if (_IsContinuationByte(pInputChars[currentByteInput]))
        {
            while (currentByteInput < cb && _IsContinuationByte(pInputChars[currentByteInput]))
            {
                ++currentByteInput;
            }
        }
        else if (_IsLeadByte(pInputChars[currentByteInput]))
        {
            if (_IsValidMultiByteSequence(&pInputCh...",1,<empty>,,435,20,CPPASTProblemDeclaration,,<empty>
440152,UNKNOWN,21,,"void Utf8ToWideCharParser::_StorePartialSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb)
{
    const auto maxLength = std::min(cb, _UTF8_BYTE_SEQUENCE_MAX);
    std::copy(pLeadByte, pLeadByte + maxLength, _utf8CodePointPieces);
    _bytesStored = maxLength;
}",1,<empty>,,501,21,CPPASTProblemDeclaration,,<empty>
440186,UNKNOWN,-1,,"[[nodiscard]] HRESULT Parse(_In_reads_(cchBuffer) const byte* const pBytes,
                                _In_ const unsigned int cchBuffer,
                                _Out_ unsigned int& cchConsumed,
                                _Inout_ std::unique_ptr<wchar_t[]>& converted,
                                _Out_ unsigned int& cchConverted);",5,<empty>,,24,3,CPPASTProblemDeclaration,,<empty>
440193,UNKNOWN,-1,,bool _IsLeadByte(_In_ byte ch);,5,<empty>,,40,5,CPPASTProblemDeclaration,,<empty>
440194,UNKNOWN,-1,,bool _IsContinuationByte(_In_ byte ch);,5,<empty>,,41,6,CPPASTProblemDeclaration,,<empty>
440195,UNKNOWN,-1,,bool _IsAsciiByte(_In_ byte ch);,5,<empty>,,42,7,CPPASTProblemDeclaration,,<empty>
440196,UNKNOWN,-1,,"bool _IsValidMultiByteSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb);",5,<empty>,,43,8,CPPASTProblemDeclaration,,<empty>
440197,UNKNOWN,-1,,"bool _IsPartialMultiByteSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb);",5,<empty>,,44,9,CPPASTProblemDeclaration,,<empty>
440198,UNKNOWN,-1,,unsigned int _Utf8SequenceSize(_In_ byte ch);,5,<empty>,,45,10,CPPASTProblemDeclaration,,<empty>
440199,UNKNOWN,-1,,"unsigned int _ParseFullRange(_In_reads_(cb) const byte* const _InputChars, const unsigned int cb);",5,<empty>,,46,11,CPPASTProblemDeclaration,,<empty>
440200,UNKNOWN,-1,,"unsigned int _InvolvedParse(_In_reads_(cb) const byte* const pInputChars, const unsigned int cb);",5,<empty>,,47,12,CPPASTProblemDeclaration,,<empty>
440201,UNKNOWN,-1,,"std::pair<std::unique_ptr<byte[]>, unsigned int> _RemoveInvalidSequences(_In_reads_(cb) const byte* const pInputChars,
                                                                             const unsigned int cb);",5,<empty>,,48,13,CPPASTProblemDeclaration,,<empty>
440202,UNKNOWN,-1,,"void _StorePartialSequence(_In_reads_(cb) const byte* const pLeadByte, const unsigned int cb);",5,<empty>,,50,14,CPPASTProblemDeclaration,,<empty>
440272,UNKNOWN,1,,til::CoordType,13,<empty>,,28,1,CPPASTTypeId,,<empty>
440278,UNKNOWN,4,,"WORD ConvertStringToDec(_In_ PCWSTR pwchToConvert, _Out_opt_ PCWSTR* const ppwchEnd) noexcept
{
    WORD val = 0;

    while (*pwchToConvert != L'\0')
    {
        auto ch = *pwchToConvert;
        if (L'0' <= ch && ch <= L'9')
        {
            val = (val * 10) + (ch - L'0');
        }
        else
        {
            break;
        }

        pwchToConvert++;
    }

    if (nullptr != ppwchEnd)
    {
        *ppwchEnd = pwchToConvert;
    }

    return val;
}",1,<empty>,,31,4,CPPASTProblemDeclaration,,<empty>
440355,UNKNOWN,6,,"UINT s_LoadStringEx(_In_ HINSTANCE hModule, _In_ UINT wID, _Out_writes_(cchBufferMax) LPWSTR lpBuffer, _In_ UINT cchBufferMax, _In_ WORD wLangId)
{
    // Make sure the parms are valid.
    if (lpBuffer == nullptr)
    {
        return 0;
    }

    UINT cch = 0;

    // String Tables are broken up into 16 string segments.  Find the segment containing the string we are interested in.
    const auto hResInfo = FindResourceEx(hModule, RT_STRING, (LPTSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)), wLangId);
    if (hResInfo != nullptr)
    {
        // Load that segment.
        const auto hStringSeg = (HRSRC)LoadResource(hModule, (HRSRC)hResInfo);

        // Lock the resource.
        LPTSTR lpsz;
        if (hStringSeg != nullptr && (lpsz = (LPTSTR)LockResource(hStringSeg)) != nullptr)
        {
            // Move past the other strings in this segment. (16 strings in a segment -> & 0x0F)
            wID &= 0x0F;
            for (;;)
            {
                // PASCAL like string co...",1,<empty>,,92,6,CPPASTProblemDeclaration,,<empty>
440552,UNKNOWN,4,,"WORD ConvertStringToDec(_In_ PCWSTR pwchToConvert, _Out_opt_ PCWSTR* const ppwchEnd) noexcept;",1,<empty>,,28,4,CPPASTProblemDeclaration,,<empty>
440558,UNKNOWN,6,,"static UINT s_LoadStringEx(_In_ HINSTANCE hModule,
                           _In_ UINT wID,
                           _Out_writes_(cchBufferMax) LPWSTR lpBuffer,
                           _In_ UINT cchBufferMax,
                           _In_ WORD wLangId);",1,<empty>,,31,6,CPPASTProblemDeclaration,,<empty>
440594,UNKNOWN,1,,"WriteData::WriteData(SCREEN_INFORMATION& siContext,
                     _In_reads_bytes_(cbContext) PCWCHAR pwchContext,
                     const size_t cbContext,
                     const UINT uiOutputCodepage,
                     const bool requiresVtQuirk) :
    IWaitRoutine(ReplyDataType::Write),
    _siContext(siContext),
    _pwchContext(THROW_IF_NULL_ALLOC(reinterpret_cast<wchar_t*>(new byte[cbContext]))),
    _cbContext(cbContext),
    _uiOutputCodepage(uiOutputCodepage),
    _requiresVtQuirk(requiresVtQuirk),
    _fLeadByteCaptured(false),
    _fLeadByteConsumed(false),
    _cchUtf8Consumed(0)
{
    memmove(_pwchContext, pwchContext, _cbContext);
}",1,<empty>,,24,1,CPPASTProblemDeclaration,,<empty>
440626,UNKNOWN,5,,"bool WriteData::Notify(const WaitTerminationReason TerminationReason,
                       const bool fIsUnicode,
                       _Out_ NTSTATUS* const pReplyStatus,
                       _Out_ size_t* const pNumBytes,
                       _Out_ DWORD* const pControlKeyState,
                       _Out_ void* const /*pOutputData*/)
{
    *pNumBytes = _cbContext;
    *pControlKeyState = 0;

    if (WI_IsFlagSet(TerminationReason, WaitTerminationReason::ThreadDying))
    {
        *pReplyStatus = STATUS_THREAD_IS_TERMINATING;
        return true;
    }

    // if we get to here, this routine was called by the input
    // thread, which grabs the current console lock.

    // This routine should be called by a thread owning the same lock on the
    // same console as we're reading from.

    FAIL_FAST_IF(!(Microsoft::Console::Interactivity::ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked()));

    std::unique_ptr<WriteData> waiter;
    auto cbContex...",1,<empty>,,100,5,CPPASTProblemDeclaration,,<empty>
440643,UNKNOWN,-1,,"WriteData(SCREEN_INFORMATION& siContext,
              _In_reads_bytes_(cbContext) PCWCHAR pwchContext,
              const size_t cbContext,
              const UINT uiOutputCodepage,
              const bool requiresVtQuirk);",5,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
440665,UNKNOWN,-1,,"bool Notify(const WaitTerminationReason TerminationReason,
                const bool fIsUnicode,
                _Out_ NTSTATUS* const pReplyStatus,
                _Out_ size_t* const pNumBytes,
                _Out_ DWORD* const pControlKeyState,
                _Out_ void* const pOutputData);",5,<empty>,,40,6,CPPASTProblemDeclaration,,<empty>
441799,UNKNOWN,-1,,"__declspec(noinline) inline void WINAPI ReportFailureToFallbackProvider(bool alreadyReported, const wil::FailureInfo& failure) noexcept
    try
    {
        if (failure.hr == 0x80131515L)
        {
            // XAML requires that we reply with this HR for the accessibility code in XamlUiaTextRange to work.
            // Unfortunately, due to C++/WinRT, we have to _throw_ it. That results in us ending up here,
            // trying to report the error to telemetry. It's not an actual error, per se, so we don't
            // want to log it. It's also incredibly noisy, which results in bugs getting filed on us.
            // See https://github.com/microsoft/cppwinrt/issues/798 for more discussion about throwing HRESULTs.
            return;
        }

        if (!alreadyReported && FallbackProvider)
        {
#pragma warning(suppress : 26477) // Use 'nullptr' rather than 0 or NULL
            TraceLoggingWrite(
                FallbackProvider,
                ""FallbackError"",
 ...",5,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
441800,UNKNOWN,-1,,"catch (...)
    {
        // Don't log anything. We just failed to trace, where will we go now?
    }",5,<empty>,,55,3,CPPASTProblemDeclaration,,<empty>
442018,UNKNOWN,1,,"CONPTY_EXPORT HRESULT WINAPI ConptyCreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON* phPC);",1,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
442019,UNKNOWN,2,,"CONPTY_EXPORT HRESULT WINAPI ConptyCreatePseudoConsoleAsUser(HANDLE hToken, COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON* phPC);",1,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
442020,UNKNOWN,3,,"CONPTY_EXPORT HRESULT WINAPI ConptyResizePseudoConsole(HPCON hPC, COORD size);",1,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
442021,UNKNOWN,4,,CONPTY_EXPORT HRESULT WINAPI ConptyClearPseudoConsole(HPCON hPC);,1,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
442022,UNKNOWN,5,,"CONPTY_EXPORT HRESULT WINAPI ConptyShowHidePseudoConsole(HPCON hPC, bool show);",1,<empty>,,34,5,CPPASTProblemDeclaration,,<empty>
442023,UNKNOWN,6,,"CONPTY_EXPORT HRESULT WINAPI ConptyReparentPseudoConsole(HPCON hPC, HWND newParent);",1,<empty>,,35,6,CPPASTProblemDeclaration,,<empty>
442024,UNKNOWN,7,,CONPTY_EXPORT HRESULT WINAPI ConptyReleasePseudoConsole(HPCON hPC);,1,<empty>,,36,7,CPPASTProblemDeclaration,,<empty>
442025,UNKNOWN,8,,CONPTY_EXPORT VOID WINAPI ConptyClosePseudoConsole(HPCON hPC);,1,<empty>,,38,8,CPPASTProblemDeclaration,,<empty>
442026,UNKNOWN,9,,"CONPTY_EXPORT VOID WINAPI ConptyClosePseudoConsoleTimeout(HPCON hPC, DWORD dwMilliseconds);",1,<empty>,,39,9,CPPASTProblemDeclaration,,<empty>
442027,UNKNOWN,10,,"CONPTY_EXPORT HRESULT WINAPI ConptyPackPseudoConsole(HANDLE hServerProcess, HANDLE hRef, HANDLE hSignal, HPCON* phPC);",1,<empty>,,41,10,CPPASTProblemDeclaration,,<empty>
442156,UNKNOWN,1,,unsigned long,32,<empty>,,94,1,CPPASTTypeId,,<empty>
442163,UNKNOWN,1,,unsigned long,33,<empty>,,95,1,CPPASTTypeId,,<empty>
442367,UNKNOWN,1,,std::make_signed_t<U>,40,<empty>,,64,1,CPPASTTypeId,,<empty>
442387,UNKNOWN,1,,U,40,<empty>,,65,1,CPPASTTypeId,,<empty>
444213,UNKNOWN,1,,"typedef LONG (APIENTRY *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);",1,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
444321,UNKNOWN,1,,float,75,<empty>,,67,1,CPPASTTypeId,,<empty>
444371,UNKNOWN,1,,std::atomic<T>*,34,<empty>,,13,1,CPPASTTypeId,,<empty>
444375,UNKNOWN,1,,T*,72,<empty>,,13,1,CPPASTTypeId,,<empty>
444388,UNKNOWN,1,,std::atomic<T>*,40,<empty>,,20,1,CPPASTTypeId,,<empty>
444398,UNKNOWN,1,,std::atomic<T>*,37,<empty>,,27,1,CPPASTTypeId,,<empty>
445334,UNKNOWN,1,,size_t,50,<empty>,,495,1,CPPASTTypeId,,<empty>
445483,UNKNOWN,1,,const TargetType*,38,<empty>,,38,1,CPPASTTypeId,,<empty>
445496,UNKNOWN,-1,,>,63,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
445535,UNKNOWN,1,,const TargetType*,38,<empty>,,52,1,CPPASTTypeId,,<empty>
445906,UNKNOWN,1,,int,48,<empty>,,211,1,CPPASTTypeId,,<empty>
445917,UNKNOWN,1,,int,48,<empty>,,212,1,CPPASTTypeId,,<empty>
445928,UNKNOWN,1,,int,48,<empty>,,213,1,CPPASTTypeId,,<empty>
445943,UNKNOWN,1,,int,52,<empty>,,216,1,CPPASTTypeId,,<empty>
446118,UNKNOWN,-1,,return ((UnderlyingType{ 1 } << static_cast<UnderlyingType>(positions)) | ...);,17,<empty>,,133,1,CPPASTProblemStatement,,<empty>
446323,UNKNOWN,-1,,),85,<empty>,,81,2,CPPASTProblemDeclaration,,<empty>
446324,UNKNOWN,-1,,"WI_NOEXCEPT
            {
                return wil::AdaptFixedSizeToAllocatedResult<string_type, initialBufferLength>(result, [&](_Out_writes_(valueLength) PWSTR value, size_t valueLength, _Out_ size_t* valueLengthNeededWithNul) -> HRESULT {
                    auto length = gsl::narrow<DWORD>(valueLength * sizeof(wchar_t));
                    const auto status = ::RegQueryValueExW(key, valueName, nullptr, nullptr, reinterpret_cast<BYTE*>(value), &length);
                    // length will receive the number of bytes including trailing null byte. Convert to a number of wchar_t's.
                    // AdaptFixedSizeToAllocatedResult will then resize buffer to valueLengthNeededWithNull.
                    // We're rounding up to prevent infinite loops if the data isn't a REG_SZ and length isn't divisible by 2.
                    *valueLengthNeededWithNul = (length + sizeof(wchar_t) - 1) / sizeof(wchar_t);
                    return status == ERROR_MORE_DATA ? S_OK : HRESULT_FR...",87,<empty>,,81,3,CPPASTProblemDeclaration,,<empty>
446332,UNKNOWN,-1,,),88,<empty>,,96,5,CPPASTProblemDeclaration,,<empty>
446333,UNKNOWN,-1,,"WI_NOEXCEPT
            {
                const auto hr = wil_env::TryRegQueryValueExW<string_type, initialBufferLength>(key, valueName, result);
                RETURN_HR_IF(hr, FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_ENVVAR_NOT_FOUND)));
                return S_OK;
            }",90,<empty>,,96,6,CPPASTProblemDeclaration,,<empty>
446347,UNKNOWN,-1,,h,99,<empty>,,128,4,CPPASTProblemStatement,,<empty>
446348,UNKNOWN,-1,,">(path, [&](_Out_writes_(valueLength) PWSTR value, size_t valueLength, _Out_ size_t* valueLengthNeededWithNull) -> HRESULT {
                    // Note that GetShortPathNameW() is not limited to MAX_PATH
                    // but it does take a fixed size buffer.
                    *valueLengthNeededWithNull = ::GetShortPathNameW(file, value, static_cast<DWORD>(valueLength));
                    RETURN_LAST_ERROR_IF(*valueLengthNeededWithNull == 0);
                    WI_ASSERT((*value != L'\0') == (*valueLengthNeededWithNull < valueLength));
                    if (*valueLengthNeededWithNull < valueLength)
                    {
                        (*valueLengthNeededWithNull)++; // it fit, account for the null
                    }
                    return S_OK;
                }",100,<empty>,,128,5,CPPASTProblemStatement,,<empty>
446349,UNKNOWN,-1,,);,18,<empty>,,139,6,CPPASTProblemStatement,,<empty>
446612,UNKNOWN,1,,const wchar_t*,69,<empty>,,234,1,CPPASTTypeId,,<empty>
446655,UNKNOWN,1,,const wchar_t*,69,<empty>,,240,1,CPPASTTypeId,,<empty>
447812,UNKNOWN,-1,,auto operator<=>(const generation_t&) const = default;,9,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
447944,UNKNOWN,1,,const void*,38,<empty>,,47,1,CPPASTTypeId,,<empty>
448006,UNKNOWN,1,,uint64_t,33,<empty>,,116,1,CPPASTTypeId,,<empty>
448013,UNKNOWN,1,,uint64_t,71,<empty>,,116,1,CPPASTTypeId,,<empty>
448092,UNKNOWN,1,,const uint8_t*,34,<empty>,,152,1,CPPASTTypeId,,<empty>
448320,UNKNOWN,1,,const void*,37,<empty>,,216,1,CPPASTTypeId,,<empty>
448371,UNKNOWN,1,,const void*,33,<empty>,,242,1,CPPASTTypeId,,<empty>
448396,UNKNOWN,1,,const void*,33,<empty>,,252,1,CPPASTTypeId,,<empty>
448592,UNKNOWN,1,,decltype(counter)*,42,<empty>,,62,1,CPPASTTypeId,,<empty>
448669,UNKNOWN,1,,T,33,<empty>,,20,1,CPPASTTypeId,,<empty>
448784,UNKNOWN,1,,U,28,<empty>,,87,1,CPPASTTypeId,,<empty>
449670,UNKNOWN,-1,,"typedef BOOLEAN(APIENTRY* RtlGenRandom)(PVOID RandomBuffer, ULONG RandomBufferLength);",9,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
451384,UNKNOWN,1,,difference_type,56,<empty>,,94,1,CPPASTTypeId,,<empty>
451428,UNKNOWN,1,,difference_type,56,<empty>,,121,1,CPPASTTypeId,,<empty>
451449,UNKNOWN,1,,difference_type,45,<empty>,,135,1,CPPASTTypeId,,<empty>
452713,UNKNOWN,1,,size_type,73,<empty>,,945,1,CPPASTTypeId,,<empty>
452921,UNKNOWN,-1,,"template<typename It>
        rle_scanner(It b, It e) -> rle_scanner<It>;",9,<empty>,,1033,54,CPPASTProblemDeclaration,,<empty>
453209,UNKNOWN,1,,int64_t,47,<empty>,,117,1,CPPASTTypeId,,<empty>
453212,UNKNOWN,1,,int64_t,77,<empty>,,117,1,CPPASTTypeId,,<empty>
453624,UNKNOWN,-1,,"[[nodiscard]] constexpr std::strong_ordering operator<=>(const small_vector_const_iterator& right) const noexcept
        {
#if _ITERATOR_DEBUG_LEVEL >= 1
            _STL_VERIFY(_begin == right._begin && _end == right._end, ""cannot compare incompatible iterators"");
#endif // _ITERATOR_DEBUG_LEVEL >= 1
            return _ptr <=> right._ptr;
        }",9,<empty>,,178,25,CPPASTProblemDeclaration,,<empty>
453674,UNKNOWN,1,,reference,31,<empty>,,233,1,CPPASTTypeId,,<empty>
453685,UNKNOWN,1,,pointer,31,<empty>,,239,1,CPPASTTypeId,,<empty>
453818,UNKNOWN,1,,reference,31,<empty>,,304,1,CPPASTTypeId,,<empty>
453831,UNKNOWN,1,,pointer,31,<empty>,,312,1,CPPASTTypeId,,<empty>
453971,UNKNOWN,1,,size_t,76,<empty>,,413,1,CPPASTTypeId,,<empty>
454552,UNKNOWN,1,,T*,36,<empty>,,740,1,CPPASTTypeId,,<empty>
454565,UNKNOWN,1,,T*,36,<empty>,,744,1,CPPASTTypeId,,<empty>
454575,UNKNOWN,1,,std::align_val_t,85,<empty>,,744,1,CPPASTTypeId,,<empty>
454602,UNKNOWN,1,,std::align_val_t,53,<empty>,,756,1,CPPASTTypeId,,<empty>
455622,UNKNOWN,1,,T*,36,<empty>,,118,1,CPPASTTypeId,,<empty>
455632,UNKNOWN,1,,T*,36,<empty>,,122,1,CPPASTTypeId,,<empty>
455639,UNKNOWN,1,,std::align_val_t,73,<empty>,,122,1,CPPASTTypeId,,<empty>
455669,UNKNOWN,1,,std::align_val_t,52,<empty>,,136,1,CPPASTTypeId,,<empty>
456034,UNKNOWN,1,,size_t,33,<empty>,,396,1,CPPASTTypeId,,<empty>
456232,UNKNOWN,1,,size_type,42,<empty>,,486,1,CPPASTTypeId,,<empty>
456488,UNKNOWN,1,,size_type,42,<empty>,,589,1,CPPASTTypeId,,<empty>
456774,UNKNOWN,-1,,"template<typename First, typename... Rest>
    static_map(First, Rest...) -> static_map<std::conditional_t<std::conjunction_v<std::is_same<First, Rest>...>, typename First::first_type, void>, typename First::second_type, 1 + sizeof...(Rest)>;",5,<empty>,,101,4,CPPASTProblemDeclaration,,<empty>
456775,UNKNOWN,-1,,"template<typename First, typename... Rest>
    presorted_static_map(First, Rest...) -> presorted_static_map<std::conditional_t<std::conjunction_v<std::is_same<First, Rest>...>, typename First::first_type, void>, typename First::second_type, 1 + sizeof...(Rest)>;",5,<empty>,,104,5,CPPASTProblemDeclaration,,<empty>
456857,UNKNOWN,-1,,_TIL_INLINEPREFIX,5,<empty>,,8,1,CPPASTProblemDeclaration,,<empty>
456897,UNKNOWN,-1,,_TIL_INLINEPREFIX,5,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
457058,UNKNOWN,-1,,_TIL_INLINEPREFIX,5,<empty>,,53,6,CPPASTProblemDeclaration,,<empty>
457072,UNKNOWN,-1,,_TIL_INLINEPREFIX,5,<empty>,,64,8,CPPASTProblemDeclaration,,<empty>
457086,UNKNOWN,-1,,_TIL_INLINEPREFIX,5,<empty>,,75,10,CPPASTProblemDeclaration,,<empty>
457237,UNKNOWN,-1,,"template<typename T, typename Traits>
    _TIL_INLINEPREFIX constexpr unsigned long to_ulong(const std::basic_string_view<T, Traits>& str, unsigned long base = 0) noexcept
    {
        static constexpr unsigned long maximumValue = ULONG_MAX / 16;

        // We don't have to test ptr for nullability, as we only access it under either condition:
        // * str.length() > 0, for determining the base
        // * ptr != end, when parsing the characters; if ptr is null, length will be 0 and thus end == ptr
#pragma warning(push)
#pragma warning(disable : 26429) // Symbol 'ptr' is never tested for nullness, it can be marked as not_null
#pragma warning(disable : 26481) // Don't use pointer arithmetic. Use span instead
        auto ptr = str.data();
        const auto end = ptr + str.length();
        unsigned long accumulator = 0;
        unsigned long value = ULONG_MAX;

        if (!base)
        {
            base = 10;

            if (str.length() > 1 && *ptr == '0')
            {
...",5,<empty>,,123,22,CPPASTProblemDeclaration,,<empty>
457957,UNKNOWN,-1,,"static void __stdcall _timer_callback(PTP_CALLBACK_INSTANCE /*instance*/, PVOID context, PTP_TIMER /*timer*/) noexcept
        try
        {
            static_cast<throttled_func*>(context)->_trailing_edge();
        }
        CATCH_LOG()

        void _leading_edge()
        {
            if constexpr (leading)
            {
                _func();
            }

            SetThreadpoolTimerEx(_timer.get(), &_delay, 0, 0);
        }",9,<empty>,,161,11,CPPASTProblemDeclaration,,<empty>
458406,UNKNOWN,-1,,"try
        {
            out.clear();
            RETURN_HR_IF(S_OK, in.empty());

            int lengthRequired{};
            // The worst ratio of UTF-8 code units to UTF-16 code units is 1 to 1 if UTF-8 consists of ASCII only.
            RETURN_HR_IF(E_ABORT, !base::MakeCheckedNum(in.length()).AssignIfValid(&lengthRequired));
            out.resize(in.length()); // avoid to call MultiByteToWideChar twice only to get the required size
            const int lengthOut = MultiByteToWideChar(CP_UTF8, 0ul, in.data(), lengthRequired, out.data(), lengthRequired);
            out.resize(gsl::narrow_cast<size_t>(lengthOut));

            return lengthOut == 0 ? E_UNEXPECTED : S_OK;
        }
        CATCH_RETURN();",9,<empty>,,64,1,CPPASTProblemStatement,,<empty>
458414,UNKNOWN,-1,,"try
        {
            out.clear();
            RETURN_HR_IF(S_OK, in.empty());

            int capa16{};
            // The worst ratio of UTF-8 code units to UTF-16 code units is 1 to 1 if UTF-8 consists of ASCII only.
            RETURN_HR_IF(E_ABORT, !base::CheckAdd(in.length(), state.have).AssignIfValid(&capa16));

            out.resize(gsl::narrow_cast<size_t>(capa16));
            auto len8{ gsl::narrow_cast<int>(in.length()) };
            int len16{};
            auto cursor8{ in.data() };
            if (state.have)
            {
                const auto copyable{ std::min<int>(state.want, len8) };
                std::move(cursor8, cursor8 + copyable, &state.partials[state.have]);
                state.have += gsl::narrow_cast<uint8_t>(copyable);
                state.want -= gsl::narrow_cast<uint8_t>(copyable);
                if (state.want) // we still didn't get enough data to complete the code point, however this is not an error
                {
             ...",9,<empty>,,98,1,CPPASTProblemStatement,,<empty>
458421,UNKNOWN,-1,,"try
        {
            out.clear();
            RETURN_HR_IF(S_OK, in.empty());

            int lengthIn{};
            int lengthRequired{};
            // Code Point U+0000..U+FFFF: 1 UTF-16 code unit --> 1..3 UTF-8 code units.
            // Code Points >U+FFFF: 2 UTF-16 code units --> 4 UTF-8 code units.
            // Thus, the worst ratio of UTF-16 code units to UTF-8 code units is 1 to 3.
            RETURN_HR_IF(E_ABORT, !base::MakeCheckedNum(in.length()).AssignIfValid(&lengthIn) || !base::CheckMul(lengthIn, 3).AssignIfValid(&lengthRequired));
            out.resize(gsl::narrow_cast<size_t>(lengthRequired)); // avoid to call WideCharToMultiByte twice only to get the required size
            const int lengthOut = WideCharToMultiByte(CP_UTF8, 0ul, in.data(), lengthIn, out.data(), lengthRequired, nullptr, nullptr);
            out.resize(gsl::narrow_cast<size_t>(lengthOut));

            return lengthOut == 0 ? E_UNEXPECTED : S_OK;
        }
        CATCH_RETURN();",9,<empty>,,188,1,CPPASTProblemStatement,,<empty>
458429,UNKNOWN,-1,,"try
        {
            out.clear();
            RETURN_HR_IF(S_OK, in.empty());

            int len16{};
            int capa8{};
            // The worst ratio of UTF-16 code units to UTF-8 code units is 1 to 3.
            RETURN_HR_IF(E_ABORT, !base::MakeCheckedNum(in.length()).AssignIfValid(&len16) || !base::CheckAdd(len16, gsl::narrow_cast<int>(state.partials[0]) != 0).AssignIfValid(&capa8) || !base::CheckMul(capa8, 3).AssignIfValid(&capa8));

            out.resize(gsl::narrow_cast<size_t>(capa8));
            int len8{};
            auto cursor16{ in.data() };
            if (state.partials[0])
            {
                state.partials[1] = *cursor16;
                len8 = WideCharToMultiByte(CP_UTF8, 0UL, &state.partials[0], 2, out.data(), capa8, nullptr, nullptr);
                RETURN_HR_IF(E_UNEXPECTED, !len8);

                state.reset();
                capa8 -= len8;
                --len16;
                ++cursor16;
            }

            if (len16)
...",9,<empty>,,225,1,CPPASTProblemStatement,,<empty>
459092,UNKNOWN,1,,"[[nodiscard]] NTSTATUS ApiDetector::DetectNtUserWindow(_Out_ ApiLevel* level)
{
    // N.B.: Testing for the API set implies the function is present.
    return DetectApiSupport(EXT_API_SET_NTUSER_WINDOW, nullptr, level);
}",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
459093,UNKNOWN,2,,"[[nodiscard]] NTSTATUS ApiDetector::DetectApiSupport(_In_ LPCWSTR lpApiHost, _In_ LPCSTR lpProcedure, _Out_ ApiLevel* level)
{
    if (!level)
    {
        return STATUS_INVALID_PARAMETER;
    }

    auto status = STATUS_SUCCESS;
    HMODULE hModule = nullptr;

    status = TryLoadWellKnownLibrary(lpApiHost, &hModule);
    if (SUCCEEDED_NTSTATUS(status) && lpProcedure)
    {
        status = TryLocateProcedure(hModule, lpProcedure);
    }

    SetLevelAndFreeIfNecessary(status, hModule, level);

    return STATUS_SUCCESS;
}",1,<empty>,,40,2,CPPASTProblemDeclaration,,<empty>
459094,UNKNOWN,3,,"[[nodiscard]] NTSTATUS ApiDetector::TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                            _Outptr_result_nullonfailure_ HMODULE* phModule)
{
    auto status = STATUS_SUCCESS;

    // N.B.: Suppose we attempt to load user32.dll and locate CreateWindowExW
    //       on a Nano Server system with reverse forwarders enabled. Since the
    //       reverse forwarder modules have the same name as their regular
    //       counterparts, the loader will claim to have found the module. In
    //       addition, since reverse forwarders contain all the functions of
    //       their regular counterparts, just stubbed to return or set the last
    //       error to STATUS_NOT_IMPLEMENTED, GetProcAddress will indeed
    //       indicate that the procedure exists. Hence, we need to search for
    //       modules skipping over the reverse forwarders.
    //
    //       This however has the side-effect of not working on downlevel.
    // ...",1,<empty>,,61,3,CPPASTProblemDeclaration,,<empty>
459095,UNKNOWN,4,,"[[nodiscard]] NTSTATUS ApiDetector::TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                            _In_ DWORD dwLoaderFlags,
                                                            _Outptr_result_nullonfailure_ HMODULE* phModule)
{
    HMODULE hModule = nullptr;

    hModule = LoadLibraryExW(lpLibrary,
                             nullptr,
                             dwLoaderFlags);
    if (hModule)
    {
        *phModule = hModule;

        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_UNSUCCESSFUL;
    }
}",1,<empty>,,107,4,CPPASTProblemDeclaration,,<empty>
459096,UNKNOWN,5,,"[[nodiscard]] NTSTATUS ApiDetector::TryLocateProcedure(_In_ HMODULE hModule, _In_ LPCSTR lpProcedure)
{
    auto proc = GetProcAddress(hModule, lpProcedure);

    if (proc)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_UNSUCCESSFUL;
    }
}",1,<empty>,,128,5,CPPASTProblemDeclaration,,<empty>
459097,UNKNOWN,6,,"void ApiDetector::SetLevelAndFreeIfNecessary(_In_ NTSTATUS status, _In_ HMODULE hModule, _Out_ ApiLevel* level)
{
    if (SUCCEEDED_NTSTATUS(status))
    {
        *level = ApiLevel::Win32;
    }
    else
    {
        FreeLibrary(hModule);

        *level = ApiLevel::OneCore;
    }
}",1,<empty>,,142,6,CPPASTProblemDeclaration,,<empty>
459112,UNKNOWN,-1,,[[nodiscard]] static NTSTATUS DetectNtUserWindow(_Out_ ApiLevel* level);,9,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
459113,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS DetectApiSupport(_In_ LPCWSTR lpLibrary, _In_ LPCSTR lpApi, _Out_ ApiLevel* level);",9,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
459114,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR library, _Outptr_result_nullonfailure_ HMODULE* module);",9,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
459115,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS TryLocateProcedure(_In_ HMODULE hModule, _In_ LPCSTR lpProcedure);",9,<empty>,,24,4,CPPASTProblemDeclaration,,<empty>
459116,UNKNOWN,-1,,"static void SetLevelAndFreeIfNecessary(_In_ NTSTATUS status, _In_ HMODULE hModule, _Out_ ApiLevel* level);",9,<empty>,,25,5,CPPASTProblemDeclaration,,<empty>
459117,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS TryLoadWellKnownLibrary(_In_ LPCWSTR lpLibrary,
                                                              _In_ DWORD dwLoaderFlags,
                                                              _Outptr_result_nullonfailure_ HMODULE* phModule);",9,<empty>,,26,6,CPPASTProblemDeclaration,,<empty>
459553,UNKNOWN,1,,unsigned char,60,<empty>,,141,1,CPPASTTypeId,,<empty>
459659,UNKNOWN,3,,DWORD,1,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
459667,UNKNOWN,1,,HostSignalInputThread*,40,<empty>,,44,1,CPPASTTypeId,,<empty>
459966,UNKNOWN,-1,,static DWORD WINAPI StaticThreadProc(LPVOID lpParameter);,9,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
460039,UNKNOWN,1,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<IConsoleControl> newControl;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                newControl = std::make_unique<Microsoft::Console::Interactivity::Win32::ConsoleControl>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                newControl = std::make_unique<Microsoft::Console::Interactivity::OneCore::ConsoleControl>();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = NTSTATUS_FROM_HRESULT(wil::ResultFromCaughtException());
        }

 ...",1,<empty>,,34,1,CPPASTProblemDeclaration,,<empty>
460040,UNKNOWN,2,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<IConsoleInputThread> newThread;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                newThread = std::make_unique<Microsoft::Console::Interactivity::Win32::ConsoleInputThread>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                newThread = std::make_unique<Microsoft::Console::Interactivity::OneCore::ConsoleInputThread>();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = NTSTATUS_FROM_HRESULT(wil::ResultFromCaughtException(...",1,<empty>,,76,2,CPPASTProblemDeclaration,,<empty>
460041,UNKNOWN,3,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<IHighDpiApi> newApi;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                newApi = std::make_unique<Microsoft::Console::Interactivity::Win32::WindowDpiApi>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                newApi.reset();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = NTSTATUS_FROM_HRESULT(wil::ResultFromCaughtException());
        }

        if (SUCCEEDED_NTSTATUS(status))
        {
            api.swap(newApi);
        }
    }

    ret...",1,<empty>,,118,3,CPPASTProblemDeclaration,,<empty>
460042,UNKNOWN,4,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<IWindowMetrics> newMetrics;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                newMetrics = std::make_unique<Microsoft::Console::Interactivity::Win32::WindowMetrics>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                newMetrics = std::make_unique<Microsoft::Console::Interactivity::OneCore::WindowMetrics>();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = NTSTATUS_FROM_HRESULT(wil::ResultFromCaughtException());
        }

      ...",1,<empty>,,160,4,CPPASTProblemDeclaration,,<empty>
460043,UNKNOWN,5,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<IAccessibilityNotifier> newNotifier;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                newNotifier = std::make_unique<Microsoft::Console::Interactivity::Win32::AccessibilityNotifier>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                newNotifier = std::make_unique<Microsoft::Console::Interactivity::OneCore::AccessibilityNotifier>();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = NTSTATUS_FROM_HRESULT(wil::Res...",1,<empty>,,202,5,CPPASTProblemDeclaration,,<empty>
460044,UNKNOWN,6,,"[[nodiscard]] NTSTATUS InteractivityFactory::CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider)
{
    auto status = STATUS_SUCCESS;

    ApiLevel level;
    status = ApiDetector::DetectNtUserWindow(&level);

    if (SUCCEEDED_NTSTATUS(status))
    {
        std::unique_ptr<ISystemConfigurationProvider> NewProvider;
        try
        {
            switch (level)
            {
            case ApiLevel::Win32:
                NewProvider = std::make_unique<Microsoft::Console::Interactivity::Win32::SystemConfigurationProvider>();
                break;

#ifdef BUILD_ONECORE_INTERACTIVITY
            case ApiLevel::OneCore:
                NewProvider = std::make_unique<Microsoft::Console::Interactivity::OneCore::SystemConfigurationProvider>();
                break;
#endif
            default:
                status = STATUS_INVALID_LEVEL;
                break;
            }
        }
        catch (...)
        {
            status = ...",1,<empty>,,244,6,CPPASTProblemDeclaration,,<empty>
460139,UNKNOWN,1,,LPCWSTR,57,<empty>,,338,1,CPPASTTypeId,,<empty>
460185,UNKNOWN,8,,"[[nodiscard]] LRESULT CALLBACK InteractivityFactory::s_PseudoWindowProc(_In_ HWND hWnd, _In_ UINT Message, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
    // Save the pointer here to the specific window instance when one is created
    if (Message == WM_CREATE)
    {
        const CREATESTRUCT* const pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);

        InteractivityFactory* const pFactory = reinterpret_cast<InteractivityFactory*>(pCreateStruct->lpCreateParams);
        SetWindowLongPtrW(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pFactory));
    }

    // Dispatch the message to the specific class instance
    InteractivityFactory* const pFactory = reinterpret_cast<InteractivityFactory*>(GetWindowLongPtrW(hWnd, GWLP_USERDATA));
    if (pFactory != nullptr)
    {
        return pFactory->PseudoWindowProc(hWnd, Message, wParam, lParam);
    }

    // If we get this far, call the default window proc
    return DefWindowProcW(hWnd, Message, wParam, lParam);
}",1,<empty>,,389,8,CPPASTProblemDeclaration,,<empty>
460186,UNKNOWN,9,,"[[nodiscard]] LRESULT CALLBACK InteractivityFactory::PseudoWindowProc(_In_ HWND hWnd, _In_ UINT Message, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
    switch (Message)
    {
    // NOTE: To the future reader, all window messages that are talked about but unused were tested
    //       during prototyping and didn't give quite the results needed to determine show/hide window
    //       state. The notes are left here for future expeditions into message queues.
    // case WM_QUERYOPEN:
    // It can be fun to toggle WM_QUERYOPEN but DefWindowProc returns TRUE.
    case WM_SIZE:
    {
        // Curiously, at least on Windows 10 (and rarely on Windows 11), if you
        // minimize the Terminal by clicking on the taskbar, then alt-tab to try
        // and restore the window, the Taskbar will decide to call
        // SwitchToWindow on us, the invisible, owned window of the main window.
        // When that happens, we'll get a WM_SIZE(SIZE_RESTORED, lParam=0). The
        // main w...",1,<empty>,,420,9,CPPASTProblemDeclaration,,<empty>
460236,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control);,9,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
460237,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread);,9,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
460238,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api);,9,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
460239,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics);,9,<empty>,,26,4,CPPASTProblemDeclaration,,<empty>
460240,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier);,9,<empty>,,27,5,CPPASTProblemDeclaration,,<empty>
460241,UNKNOWN,-1,,[[nodiscard]] NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider);,9,<empty>,,28,6,CPPASTProblemDeclaration,,<empty>
460248,UNKNOWN,-1,,"[[nodiscard]] static LRESULT CALLBACK s_PseudoWindowProc(_In_ HWND hwnd,
                                                                 _In_ UINT uMsg,
                                                                 _In_ WPARAM wParam,
                                                                 _In_ LPARAM lParam);",9,<empty>,,33,8,CPPASTProblemDeclaration,,<empty>
460249,UNKNOWN,-1,,"[[nodiscard]] LRESULT CALLBACK PseudoWindowProc(_In_ HWND,
                                                        _In_ UINT uMsg,
                                                        _In_ WPARAM wParam,
                                                        _In_ LPARAM lParam);",9,<empty>,,37,9,CPPASTProblemDeclaration,,<empty>
460291,UNKNOWN,2,,"IFACEMETHODIMP PseudoConsoleWindowAccessibilityProvider::get_ProviderOptions(_Out_ ProviderOptions* pOptions)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pOptions);
    *pOptions = ProviderOptions_ServerSideProvider;
    return S_OK;
}",1,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
460292,UNKNOWN,3,,"IFACEMETHODIMP PseudoConsoleWindowAccessibilityProvider::GetPatternProvider(_In_ PATTERNID /*iid*/,
                                                                            _COM_Outptr_result_maybenull_ IUnknown** ppInterface)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppInterface);
    *ppInterface = nullptr;
    return S_OK;
}",1,<empty>,,24,3,CPPASTProblemDeclaration,,<empty>
460293,UNKNOWN,4,,"IFACEMETHODIMP PseudoConsoleWindowAccessibilityProvider::GetPropertyValue(_In_ PROPERTYID propertyId,
                                                                          _Out_ VARIANT* pVariant)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pVariant);

    pVariant->vt = VT_EMPTY;

    // Returning the default will leave the property as the default
    // so we only really need to touch it for the properties we want to implement
    switch (propertyId)
    {
    case UIA_ControlTypePropertyId:
    {
        pVariant->vt = VT_I4;
        pVariant->lVal = UIA_WindowControlTypeId;
        break;
    }
    case UIA_NamePropertyId:
    {
        static constexpr auto AutomationPropertyName = L""Internal Console Management Window"";
        pVariant->bstrVal = SysAllocString(AutomationPropertyName);
        if (pVariant->bstrVal != nullptr)
        {
            pVariant->vt = VT_BSTR;
        }
        break;
    }
    case UIA_IsControlElementPropertyId:
    case UIA_IsContentElementPropert...",1,<empty>,,32,4,CPPASTProblemDeclaration,,<empty>
460294,UNKNOWN,5,,"IFACEMETHODIMP PseudoConsoleWindowAccessibilityProvider::get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppProvider);
    RETURN_HR_IF_NULL(gsl::narrow_cast<HRESULT>(UIA_E_ELEMENTNOTAVAILABLE), _pseudoConsoleHwnd);
    return UiaHostProviderFromHwnd(_pseudoConsoleHwnd, ppProvider);
}",1,<empty>,,74,5,CPPASTProblemDeclaration,,<empty>
460339,UNKNOWN,-1,,IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) override;,9,<empty>,,24,8,CPPASTProblemDeclaration,,<empty>
460340,UNKNOWN,-1,,"IFACEMETHODIMP GetPatternProvider(_In_ PATTERNID iid,
                                          _COM_Outptr_result_maybenull_ IUnknown** ppInterface) override;",9,<empty>,,25,9,CPPASTProblemDeclaration,,<empty>
460341,UNKNOWN,-1,,"IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) override;",9,<empty>,,27,10,CPPASTProblemDeclaration,,<empty>
460342,UNKNOWN,-1,,IFACEMETHODIMP get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider) override;,9,<empty>,,29,11,CPPASTProblemDeclaration,,<empty>
460401,UNKNOWN,1,,NTSTATUS,40,<empty>,,39,1,CPPASTTypeId,,<empty>
460412,UNKNOWN,1,,NTSTATUS,40,<empty>,,44,1,CPPASTTypeId,,<empty>
460419,UNKNOWN,3,,"[[nodiscard]] NTSTATUS RemoteConsoleControl::NotifyConsoleApplication(_In_ DWORD dwProcessId)
{
    HostSignalNotifyAppData data{};
    data.sizeInBytes = sizeof(data);
    data.processId = dwProcessId;

    return _SendTypedPacket(_pipe.get(), HostSignals::NotifyApp, data);
}",1,<empty>,,50,3,CPPASTProblemDeclaration,,<empty>
460420,UNKNOWN,4,,"[[nodiscard]] NTSTATUS RemoteConsoleControl::SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground)
{
    // GH#13211 - Apparently this API doesn't need to be forwarded to conhost at
    // all. Instead, just perform the ConsoleControl operation here, in proc.
    // This lets us avoid all sorts of strange handle duplicating weirdness.
    return _control.SetForeground(hProcess, fForeground);
}",1,<empty>,,59,4,CPPASTProblemDeclaration,,<empty>
460421,UNKNOWN,5,,"[[nodiscard]] NTSTATUS RemoteConsoleControl::EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags)
{
    HostSignalEndTaskData data{};
    data.sizeInBytes = sizeof(data);
    data.processId = dwProcessId;
    data.eventType = dwEventType;
    data.ctrlFlags = ulCtrlFlags;

    return _SendTypedPacket(_pipe.get(), HostSignals::EndTask, data);
}",1,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
460455,UNKNOWN,-1,,[[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);,9,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
460456,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);",9,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
460457,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);",9,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
460590,UNKNOWN,18,,"[[nodiscard]] NTSTATUS ServiceLocator::CreateConsoleInputThread(_Outptr_result_nullonfailure_ IConsoleInputThread** thread)
{
    auto status = STATUS_SUCCESS;

    if (s_consoleInputThread)
    {
        status = STATUS_INVALID_HANDLE;
    }
    else
    {
        if (s_interactivityFactory.get() == nullptr)
        {
            status = ServiceLocator::LoadInteractivityFactory();
        }
        if (SUCCEEDED_NTSTATUS(status))
        {
            status = s_interactivityFactory->CreateConsoleInputThread(s_consoleInputThread);

            if (SUCCEEDED_NTSTATUS(status))
            {
                *thread = s_consoleInputThread.get();
            }
        }
    }

    return status;
}",1,<empty>,,127,18,CPPASTProblemDeclaration,,<empty>
460617,UNKNOWN,20,,"[[nodiscard]] NTSTATUS ServiceLocator::SetConsoleControlInstance(_In_ std::unique_ptr<IConsoleControl>&& control)
{
    if (s_consoleControl)
    {
        NT_RETURN_NTSTATUS(STATUS_INVALID_HANDLE);
    }
    else if (!control)
    {
        NT_RETURN_NTSTATUS(STATUS_INVALID_PARAMETER);
    }
    else
    {
        s_consoleControl = std::move(control);
    }

    return STATUS_SUCCESS;
}",1,<empty>,,177,20,CPPASTProblemDeclaration,,<empty>
460618,UNKNOWN,21,,"[[nodiscard]] NTSTATUS ServiceLocator::SetConsoleWindowInstance(_In_ IConsoleWindow* window)
{
    auto status = STATUS_SUCCESS;

    if (s_consoleWindow)
    {
        status = STATUS_INVALID_HANDLE;
    }
    else if (!window)
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        s_consoleWindow.reset(window);
    }

    return status;
}",1,<empty>,,195,21,CPPASTProblemDeclaration,,<empty>
460935,UNKNOWN,1,,"UINT OneCoreSafeMapVirtualKeyW(_In_ UINT uCode, _In_ UINT uMapType)
{
    auto ret{ MapVirtualKeyW(uCode, uMapType) };
#ifdef BUILD_ONECORE_INTERACTIVITY
    if (ret == 0)
    {
        const auto lastError{ GetLastError() };
        if (lastError == ERROR_PROC_NOT_FOUND || lastError == ERROR_DELAY_LOAD_FAILED)
        {
            if (auto conIoSrvComm{ Microsoft::Console::Interactivity::OneCore::ConIoSrvComm::GetConIoSrvComm() })
            {
                SetLastError(0);
                ret = conIoSrvComm->ConIoMapVirtualKeyW(uCode, uMapType);
            }
        }
    }
#endif
    return ret;
}",1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
460936,UNKNOWN,2,,"SHORT OneCoreSafeVkKeyScanW(_In_ WCHAR ch)
{
    auto ret{ VkKeyScanW(ch) };
#ifdef BUILD_ONECORE_INTERACTIVITY
    if (ret == -1)
    {
        const auto lastError{ GetLastError() };
        if (lastError == ERROR_PROC_NOT_FOUND || lastError == ERROR_DELAY_LOAD_FAILED)
        {
            if (auto conIoSrvComm{ Microsoft::Console::Interactivity::OneCore::ConIoSrvComm::GetConIoSrvComm() })
            {
                SetLastError(0);
                ret = conIoSrvComm->ConIoVkKeyScanW(ch);
            }
        }
    }
#endif
    return ret;
}",1,<empty>,,37,2,CPPASTProblemDeclaration,,<empty>
460937,UNKNOWN,3,,"SHORT OneCoreSafeGetKeyState(_In_ int nVirtKey)
{
    auto ret{ GetKeyState(nVirtKey) };
#ifdef BUILD_ONECORE_INTERACTIVITY
    if (ret == 0)
    {
        const auto lastError{ GetLastError() };
        if (lastError == ERROR_PROC_NOT_FOUND || lastError == ERROR_DELAY_LOAD_FAILED)
        {
            if (auto conIoSrvComm{ Microsoft::Console::Interactivity::OneCore::ConIoSrvComm::GetConIoSrvComm() })
            {
                SetLastError(0);
                ret = conIoSrvComm->ConIoGetKeyState(nVirtKey);
            }
        }
    }
#endif
    return ret;
}",1,<empty>,,57,3,CPPASTProblemDeclaration,,<empty>
461000,UNKNOWN,-1,,virtual void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) = 0;,9,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
461001,UNKNOWN,-1,,"virtual void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) = 0;",9,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
461002,UNKNOWN,-1,,"virtual void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) = 0;",9,<empty>,,34,5,CPPASTProblemDeclaration,,<empty>
461003,UNKNOWN,-1,,"virtual void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) = 0;",9,<empty>,,35,6,CPPASTProblemDeclaration,,<empty>
461004,UNKNOWN,-1,,"virtual void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) = 0;",9,<empty>,,36,7,CPPASTProblemDeclaration,,<empty>
461009,UNKNOWN,-1,,virtual void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) = 0;,9,<empty>,,38,9,CPPASTProblemDeclaration,,<empty>
461010,UNKNOWN,-1,,virtual void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) = 0;,9,<empty>,,39,10,CPPASTProblemDeclaration,,<empty>
461138,UNKNOWN,-1,,virtual BOOL GetCursorPosition(_Out_ til::point* lpPoint) = 0;,9,<empty>,,42,9,CPPASTProblemDeclaration,,<empty>
461139,UNKNOWN,-1,,virtual BOOL GetClientRectangle(_Out_ til::rect* lpRect) = 0;,9,<empty>,,43,10,CPPASTProblemDeclaration,,<empty>
461140,UNKNOWN,-1,,virtual BOOL MapRect(_Inout_ til::rect* lpRect) = 0;,9,<empty>,,44,11,CPPASTProblemDeclaration,,<empty>
461141,UNKNOWN,-1,,virtual BOOL ConvertScreenToClient(_Inout_ til::point* lpPoint) = 0;,9,<empty>,,45,12,CPPASTProblemDeclaration,,<empty>
461175,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT SignalUia(_In_ EVENTID id) = 0;,9,<empty>,,61,20,CPPASTProblemDeclaration,,<empty>
461232,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateConsoleControl(_Inout_ std::unique_ptr<IConsoleControl>& control) = 0;,9,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
461233,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateConsoleInputThread(_Inout_ std::unique_ptr<IConsoleInputThread>& thread) = 0;,9,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
461234,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateHighDpiApi(_Inout_ std::unique_ptr<IHighDpiApi>& api) = 0;,9,<empty>,,38,4,CPPASTProblemDeclaration,,<empty>
461235,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateWindowMetrics(_Inout_ std::unique_ptr<IWindowMetrics>& metrics) = 0;,9,<empty>,,39,5,CPPASTProblemDeclaration,,<empty>
461236,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateAccessibilityNotifier(_Inout_ std::unique_ptr<IAccessibilityNotifier>& notifier) = 0;,9,<empty>,,40,6,CPPASTProblemDeclaration,,<empty>
461237,UNKNOWN,-1,,[[nodiscard]] virtual NTSTATUS CreateSystemConfigurationProvider(_Inout_ std::unique_ptr<ISystemConfigurationProvider>& provider) = 0;,9,<empty>,,41,7,CPPASTProblemDeclaration,,<empty>
461292,UNKNOWN,-1,,"virtual void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                         _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                         _Inout_ PDWORD pdwTitleLength,
                                         _In_ PCWSTR pwszCurrDir,
                                         _In_ PCWSTR pwszAppName,
                                         _Inout_opt_ IconInfo* iconInfo) = 0;",9,<empty>,,41,8,CPPASTProblemDeclaration,,<empty>
461364,UNKNOWN,-1,,[[nodiscard]] static NTSTATUS SetConsoleControlInstance(_In_ std::unique_ptr<IConsoleControl>&& control);,9,<empty>,,45,5,CPPASTProblemDeclaration,,<empty>
461373,UNKNOWN,1,,T*,32,<empty>,,50,1,CPPASTTypeId,,<empty>
461377,UNKNOWN,-1,,[[nodiscard]] static NTSTATUS CreateConsoleInputThread(_Outptr_result_nullonfailure_ IConsoleInputThread** thread);,9,<empty>,,53,8,CPPASTProblemDeclaration,,<empty>
461386,UNKNOWN,1,,T*,32,<empty>,,58,1,CPPASTTypeId,,<empty>
461390,UNKNOWN,-1,,[[nodiscard]] static NTSTATUS SetConsoleWindowInstance(_In_ IConsoleWindow* window);,9,<empty>,,61,11,CPPASTProblemDeclaration,,<empty>
461399,UNKNOWN,1,,T*,32,<empty>,,66,1,CPPASTTypeId,,<empty>
461414,UNKNOWN,1,,T*,32,<empty>,,73,1,CPPASTTypeId,,<empty>
461426,UNKNOWN,1,,T*,32,<empty>,,80,1,CPPASTTypeId,,<empty>
461477,UNKNOWN,1,,"UINT OneCoreSafeMapVirtualKeyW(_In_ UINT uCode, _In_ UINT uMapType);",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
461478,UNKNOWN,2,,SHORT OneCoreSafeVkKeyScanW(_In_ WCHAR ch);,1,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
461479,UNKNOWN,3,,SHORT OneCoreSafeGetKeyState(_In_ int nVirtKey);,1,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
461489,UNKNOWN,1,,"void AccessibilityNotifier::NotifyConsoleCaretEvent(_In_ const til::rect& /*rectangle*/) noexcept
{
}",1,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
461540,UNKNOWN,-1,,void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle) noexcept override;,9,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
461541,UNKNOWN,-1,,"void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position) noexcept override;",9,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
461542,UNKNOWN,-1,,"void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y) noexcept override;",9,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
461543,UNKNOWN,-1,,"void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute) noexcept override;",9,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
461544,UNKNOWN,-1,,"void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY) noexcept override;",9,<empty>,,30,5,CPPASTProblemDeclaration,,<empty>
461549,UNKNOWN,-1,,void NotifyConsoleStartApplicationEvent(_In_ DWORD processId) noexcept override;,9,<empty>,,32,7,CPPASTProblemDeclaration,,<empty>
461550,UNKNOWN,-1,,void NotifyConsoleEndApplicationEvent(_In_ DWORD processId) noexcept override;,9,<empty>,,33,8,CPPASTProblemDeclaration,,<empty>
461656,UNKNOWN,8,,"[[nodiscard]] HRESULT BgfxEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,66,8,CPPASTProblemDeclaration,,<empty>
461663,UNKNOWN,10,,"[[nodiscard]] HRESULT BgfxEngine::EndPaint() noexcept
try
{
    const auto Status = ConIoSrvComm::GetConIoSrvComm()->RequestUpdateDisplay(0);

    if (SUCCEEDED_NTSTATUS(Status))
    {
        for (SIZE_T i = 0; i < _displayHeight; i++)
        {
            const auto OldRunBase = _sharedViewBase + (i * 2 * _runLength);
            const auto NewRunBase = OldRunBase + _runLength;
            memcpy_s(OldRunBase, _runLength, NewRunBase, _runLength);
        }
    }

    return HRESULT_FROM_NT(Status);
}
CATCH_RETURN()

// Routine Description:
// - Used to perform longer running presentation steps outside the lock so the other threads can continue.
// - Not currently used by BgfxEngine.
// Arguments:
// - <none>
// Return Value:
// - S_FALSE since we do nothing.
[[nodiscard]] HRESULT BgfxEngine::Present() noexcept
{
    return S_FALSE;
}",1,<empty>,,77,10,CPPASTProblemDeclaration,,<empty>
461688,UNKNOWN,1,,PCD_IO_CHARACTER,46,<empty>,,117,1,CPPASTTypeId,,<empty>
461734,UNKNOWN,-1,,"try
    {
        const auto y = gsl::narrow_cast<SIZE_T>(coord.y);
        const auto NewRun = reinterpret_cast<PCD_IO_CHARACTER>(_sharedViewBase + (y * 2 * _runLength) + _runLength);

        for (SIZE_T i = 0; i < clusters.size() && i < _displayWidth; i++)
        {
            NewRun[coord.x + i].Character = til::at(clusters, i).GetTextAsSingle();
            NewRun[coord.x + i].Attribute = _currentLegacyColorAttribute;
        }

        return S_OK;
    }
    CATCH_RETURN()",5,<empty>,,134,1,CPPASTProblemStatement,,<empty>
461755,UNKNOWN,16,,"[[nodiscard]] HRESULT BgfxEngine::PaintCursor(const CursorOptions& options) noexcept
try
{
    // TODO: MSFT: 11448021 - Modify BGFX to support rendering full-width
    // characters and a full-width cursor.
    CD_IO_CURSOR_INFORMATION CursorInfo;
    CursorInfo.Row = gsl::narrow<USHORT>(options.coordCursor.y);
    CursorInfo.Column = gsl::narrow<USHORT>(options.coordCursor.x);
    CursorInfo.Height = options.ulCursorHeightPercent;
    CursorInfo.IsVisible = TRUE;

    const auto Status = ConIoSrvComm::GetConIoSrvComm()->RequestSetCursor(&CursorInfo);

    return HRESULT_FROM_NT(Status);
}
CATCH_RETURN()

[[nodiscard]] HRESULT BgfxEngine::UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                       const RenderSettings& /*renderSettings*/,
                                                       const gsl::not_null<IRenderData*> /*pData*/,
                                                       const bool /*usingSoftFont*/,
         ...",1,<empty>,,164,16,CPPASTProblemDeclaration,,<empty>
461807,UNKNOWN,1,,SIZE_T,79,<empty>,,221,1,CPPASTTypeId,,<empty>
461827,UNKNOWN,1,,SIZE_T,78,<empty>,,222,1,CPPASTTypeId,,<empty>
461836,UNKNOWN,22,,"[[nodiscard]] HRESULT BgfxEngine::GetFontSize(_Out_ til::size* pFontSize) noexcept
{
    *pFontSize = _fontSize;
    return S_OK;
}",1,<empty>,,230,22,CPPASTProblemDeclaration,,<empty>
461837,UNKNOWN,23,,"[[nodiscard]] HRESULT BgfxEngine::IsGlyphWideByFont(const std::wstring_view /*glyph*/, _Out_ bool* const pResult) noexcept
{
    *pResult = false;
    return S_OK;
}",1,<empty>,,236,23,CPPASTProblemDeclaration,,<empty>
461838,UNKNOWN,24,,"[[nodiscard]] HRESULT BgfxEngine::_DoUpdateTitle(_In_ const std::wstring_view /*newTitle*/) noexcept
{
    return S_OK;
}",1,<empty>,,249,24,CPPASTProblemDeclaration,,<empty>
461888,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;,9,<empty>,,41,8,CPPASTProblemDeclaration,,<empty>
461973,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* pFontSize) noexcept override;,9,<empty>,,71,24,CPPASTProblemDeclaration,,<empty>
461974,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept override;",9,<empty>,,72,25,CPPASTProblemDeclaration,,<empty>
461975,UNKNOWN,-1,,[[nodiscard]] HRESULT _DoUpdateTitle(_In_ const std::wstring_view newTitle) noexcept override;,9,<empty>,,75,26,CPPASTProblemDeclaration,,<empty>
462123,UNKNOWN,1,,_RTL_CONSTANT_STRING_remove_const_template_class<RTL_CONSTANT_STRING(CIS_ALPC_PORT_NAME)>::T *,38,<empty>,,89,1,CPPASTTypeId,,<empty>
462152,UNKNOWN,1,,PALPC_MESSAGE_ATTRIBUTES,63,<empty>,,116,1,CPPASTTypeId,,<empty>
462853,UNKNOWN,13,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const
{
    CIS_MSG Message{};
    Message.Type = CIS_MSG_TYPE_GETDISPLAYSIZE;

    auto Status = SendRequestReceiveReply(&Message);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        *pCdDisplaySize = Message.GetDisplaySizeParams.DisplaySize;
        Status = Message.GetDisplaySizeParams.ReturnValue;
    }

    return Status;
}",1,<empty>,,460,13,CPPASTProblemDeclaration,,<empty>
462854,UNKNOWN,14,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const
{
    CIS_MSG Message{};
    Message.Type = CIS_MSG_TYPE_GETFONTSIZE;

    auto Status = SendRequestReceiveReply(&Message);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        *pCdFontSize = Message.GetFontSizeParams.FontSize;
        Status = Message.GetFontSizeParams.ReturnValue;
    }

    return Status;
}",1,<empty>,,475,14,CPPASTProblemDeclaration,,<empty>
462855,UNKNOWN,15,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const
{
    CIS_MSG Message{};
    Message.Type = CIS_MSG_TYPE_SETCURSOR;
    Message.SetCursorParams.CursorInformation = *pCdCursorInformation;

    auto Status = SendRequestReceiveReply(&Message);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        Status = Message.SetCursorParams.ReturnValue;
    }

    return Status;
}",1,<empty>,,490,15,CPPASTProblemDeclaration,,<empty>
462856,UNKNOWN,16,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestUpdateDisplay(_In_ til::CoordType RowIndex) const
{
    CIS_MSG Message{};
    Message.Type = CIS_MSG_TYPE_UPDATEDISPLAY;
    Message.UpdateDisplayParams.RowIndex = gsl::narrow<SHORT>(RowIndex);

    auto Status = SendRequestReceiveReply(&Message);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        Status = Message.UpdateDisplayParams.ReturnValue;
    }

    return Status;
}",1,<empty>,,505,16,CPPASTProblemDeclaration,,<empty>
462857,UNKNOWN,17,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue)
{
    NTSTATUS Status;

    Status = EnsureConnection();
    if (SUCCEEDED_NTSTATUS(Status))
    {
        CIS_MSG Message = { 0 };
        Message.Type = CIS_MSG_TYPE_MAPVIRTUALKEY;
        Message.MapVirtualKeyParams.Code = uCode;
        Message.MapVirtualKeyParams.MapType = uMapType;

        Status = SendRequestReceiveReply(&Message);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            *puReturnValue = Message.MapVirtualKeyParams.ReturnValue;
        }
    }

    return Status;
}",1,<empty>,,520,17,CPPASTProblemDeclaration,,<empty>
462858,UNKNOWN,18,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue)
{
    NTSTATUS Status;

    Status = EnsureConnection();
    if (SUCCEEDED_NTSTATUS(Status))
    {
        CIS_MSG Message = { 0 };
        Message.Type = CIS_MSG_TYPE_VKKEYSCAN;
        Message.VkKeyScanParams.Character = wCharacter;

        Status = SendRequestReceiveReply(&Message);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            *psReturnValue = Message.VkKeyScanParams.ReturnValue;
        }
    }

    return Status;
}",1,<empty>,,542,18,CPPASTProblemDeclaration,,<empty>
462859,UNKNOWN,19,,"[[nodiscard]] NTSTATUS ConIoSrvComm::RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* psReturnValue)
{
    NTSTATUS Status;

    Status = EnsureConnection();
    if (SUCCEEDED_NTSTATUS(Status))
    {
        CIS_MSG Message = { 0 };
        Message.Type = CIS_MSG_TYPE_GETKEYSTATE;
        Message.GetKeyStateParams.VirtualKey = iVirtualKey;

        Status = SendRequestReceiveReply(&Message);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            *psReturnValue = Message.GetKeyStateParams.ReturnValue;
        }
    }

    return Status;
}",1,<empty>,,563,19,CPPASTProblemDeclaration,,<empty>
463121,UNKNOWN,-1,,[[nodiscard]] NTSTATUS RequestGetDisplaySize(_Inout_ PCD_IO_DISPLAY_SIZE pCdDisplaySize) const;,9,<empty>,,39,6,CPPASTProblemDeclaration,,<empty>
463122,UNKNOWN,-1,,[[nodiscard]] NTSTATUS RequestGetFontSize(_Inout_ PCD_IO_FONT_SIZE pCdFontSize) const;,9,<empty>,,40,7,CPPASTProblemDeclaration,,<empty>
463123,UNKNOWN,-1,,[[nodiscard]] NTSTATUS RequestSetCursor(_In_ const CD_IO_CURSOR_INFORMATION* const pCdCursorInformation) const;,9,<empty>,,41,8,CPPASTProblemDeclaration,,<empty>
463124,UNKNOWN,-1,,[[nodiscard]] NTSTATUS RequestUpdateDisplay(_In_ til::CoordType RowIndex) const;,9,<empty>,,42,9,CPPASTProblemDeclaration,,<empty>
463125,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS RequestMapVirtualKey(_In_ UINT uCode, _In_ UINT uMapType, _Out_ UINT* puReturnValue);",9,<empty>,,44,10,CPPASTProblemDeclaration,,<empty>
463126,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS RequestVkKeyScan(_In_ WCHAR wCharacter, _Out_ SHORT* psReturnValue);",9,<empty>,,45,11,CPPASTProblemDeclaration,,<empty>
463127,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS RequestGetKeyState(_In_ int iVirtualKey, _Out_ SHORT* psReturnValue);",9,<empty>,,46,12,CPPASTProblemDeclaration,,<empty>
463227,UNKNOWN,3,,"[[nodiscard]] NTSTATUS ConsoleControl::EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags)
{
    USER_API_MSG m{};
    const auto a = &m.u.EndTask;

    RtlZeroMemory(a, sizeof(*a));
    a->ProcessId = ULongToHandle(dwProcessId); // This is actually a PID, even though the struct expects a HANDLE.
    a->ConsoleEventCode = dwEventType;
    a->ConsoleFlags = ulCtrlFlags;

    return CsrClientCallServer(reinterpret_cast<PCSR_API_MSG>(&m),
                               nullptr,
                               CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX, UserpEndTask),
                               sizeof(*a));
}",1,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
463249,UNKNOWN,-1,,[[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId) noexcept override;,9,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
463250,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground) noexcept override;",9,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
463251,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags) override;",9,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
463278,UNKNOWN,1,,DWORD,1,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
463748,UNKNOWN,-1,,BOOL MapRect(_Inout_ til::rect* lpRect) noexcept override;,9,<empty>,,40,10,CPPASTProblemDeclaration,,<empty>
463787,UNKNOWN,-1,,[[nodiscard]] HRESULT SignalUia(_In_ EVENTID id) noexcept override;,9,<empty>,,54,19,CPPASTProblemDeclaration,,<empty>
463849,UNKNOWN,7,,"void SystemConfigurationProvider::GetSettingsFromLink(
    _Inout_ Settings* pLinkSettings,
    _Inout_updates_bytes_(*pdwTitleLength) LPWSTR /*pwszTitle*/,
    _Inout_ PDWORD /*pdwTitleLength*/,
    _In_ PCWSTR /*pwszCurrDir*/,
    _In_ PCWSTR /*pwszAppName*/,
    _Inout_opt_ IconInfo* /*iconInfo*/)
{
    // While both OneCore console renderers use TrueType fonts, there is no
    // advanced font support on that platform. Namely, there is no way to pick
    // neither the font nor the font size. Since this choice of TrueType font
    // is made implicitly by the renderers, the rest of the console is not aware
    // of it and the renderer procedure goes on to translate output text so that
    // it be renderable with raster fonts, which messes up the final output.
    // Hence, we make it seem like the console is in fact configured to use a
    // TrueType font by the user.

    pLinkSettings->SetFaceName(DEFAULT_TT_FONT_FACENAME);
    pLinkSettings->SetFontFamily(TMPF_TRUETYPE);

...",1,<empty>,,47,7,CPPASTProblemDeclaration,,<empty>
463887,UNKNOWN,-1,,"void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo) override;",9,<empty>,,36,7,CPPASTProblemDeclaration,,<empty>
464196,UNKNOWN,1,,"void AccessibilityNotifier::NotifyConsoleCaretEvent(_In_ const til::rect& rectangle)
{
    const auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow != nullptr)
    {
        CONSOLE_CARET_INFO caretInfo;
        caretInfo.hwnd = pWindow->GetWindowHandle();
        caretInfo.rc = rectangle.to_win32_rect();

        LOG_IF_FAILED(ServiceLocator::LocateConsoleControl<ConsoleControl>()->Control(ConsoleControl::ControlType::ConsoleSetCaretInfo,
                                                                                      &caretInfo,
                                                                                      sizeof(caretInfo)));
    }
}",1,<empty>,,14,1,CPPASTProblemDeclaration,,<empty>
464197,UNKNOWN,2,,"void AccessibilityNotifier::NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    DWORD dwFlags = 0;

    if (flags == ConsoleCaretEventFlags::CaretSelection)
    {
        dwFlags = CONSOLE_CARET_SELECTION;
    }
    else if (flags == ConsoleCaretEventFlags::CaretVisible)
    {
        dwFlags = CONSOLE_CARET_VISIBLE;
    }

    // UIA event notification
    static til::point previousCursorLocation;
    const auto pWindow = ServiceLocator::LocateConsoleWindow();

    if (pWindow != nullptr)
    {
        NotifyWinEvent(EVENT_CONSOLE_CARET,
                       pWindow->GetWindowHandle(),
                       dwFlags,
                       position);

        const auto& screenInfo = gci.GetActiveOutputBuffer();
        const auto& cursor = screenInfo.GetTextBuffer().GetCursor();
        const auto currentCursorPosition = cursor.GetPosition();
        if (currentCursorP...",1,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
464198,UNKNOWN,3,,"void AccessibilityNotifier::NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y)
{
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow)
    {
        NotifyWinEvent(EVENT_CONSOLE_UPDATE_SCROLL,
                       pWindow->GetWindowHandle(),
                       x,
                       y);
    }
}",1,<empty>,,65,3,CPPASTProblemDeclaration,,<empty>
464199,UNKNOWN,4,,"void AccessibilityNotifier::NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute)
{
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow)
    {
        NotifyWinEvent(EVENT_CONSOLE_UPDATE_SIMPLE,
                       pWindow->GetWindowHandle(),
                       start,
                       charAndAttribute);
    }
}",1,<empty>,,77,4,CPPASTProblemDeclaration,,<empty>
464200,UNKNOWN,5,,"void AccessibilityNotifier::NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY)
{
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow)
    {
        NotifyWinEvent(EVENT_CONSOLE_UPDATE_REGION,
                       pWindow->GetWindowHandle(),
                       startXY,
                       endXY);
    }
}",1,<empty>,,89,5,CPPASTProblemDeclaration,,<empty>
464223,UNKNOWN,7,,"void AccessibilityNotifier::NotifyConsoleStartApplicationEvent(_In_ DWORD processId)
{
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow)
    {
        NotifyWinEvent(EVENT_CONSOLE_START_APPLICATION,
                       pWindow->GetWindowHandle(),
                       processId,
                       0);
    }
}",1,<empty>,,113,7,CPPASTProblemDeclaration,,<empty>
464224,UNKNOWN,8,,"void AccessibilityNotifier::NotifyConsoleEndApplicationEvent(_In_ DWORD processId)
{
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow)
    {
        NotifyWinEvent(EVENT_CONSOLE_END_APPLICATION,
                       pWindow->GetWindowHandle(),
                       processId,
                       0);
    }
}",1,<empty>,,125,8,CPPASTProblemDeclaration,,<empty>
464243,UNKNOWN,-1,,void NotifyConsoleCaretEvent(_In_ const til::rect& rectangle);,9,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
464244,UNKNOWN,-1,,"void NotifyConsoleCaretEvent(_In_ ConsoleCaretEventFlags flags, _In_ LONG position);",9,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
464245,UNKNOWN,-1,,"void NotifyConsoleUpdateScrollEvent(_In_ LONG x, _In_ LONG y);",9,<empty>,,32,4,CPPASTProblemDeclaration,,<empty>
464246,UNKNOWN,-1,,"void NotifyConsoleUpdateSimpleEvent(_In_ LONG start, _In_ LONG charAndAttribute);",9,<empty>,,33,5,CPPASTProblemDeclaration,,<empty>
464247,UNKNOWN,-1,,"void NotifyConsoleUpdateRegionEvent(_In_ LONG startXY, _In_ LONG endXY);",9,<empty>,,34,6,CPPASTProblemDeclaration,,<empty>
464252,UNKNOWN,-1,,void NotifyConsoleStartApplicationEvent(_In_ DWORD processId);,9,<empty>,,36,8,CPPASTProblemDeclaration,,<empty>
464253,UNKNOWN,-1,,void NotifyConsoleEndApplicationEvent(_In_ DWORD processId);,9,<empty>,,37,9,CPPASTProblemDeclaration,,<empty>
464297,UNKNOWN,-1,,"try
    {
        // registry settings may tell us to always copy the color/formatting
        auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
        fAlsoCopyFormatting = fAlsoCopyFormatting || gci.GetCopyColor();

        // store selection in clipboard
        StoreSelectionToClipboard(fAlsoCopyFormatting);
        Selection::Instance().ClearSelection(); // clear selection in console
    }
    CATCH_LOG();",5,<empty>,,34,1,CPPASTProblemStatement,,<empty>
464349,UNKNOWN,1,,const wchar_t*,34,<empty>,,73,1,CPPASTTypeId,,<empty>
464381,UNKNOWN,4,,"void Clipboard::StringPaste(_In_reads_(cchData) const wchar_t* const pData,
                            const size_t cchData)
{
    if (pData == nullptr)
    {
        return;
    }

    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    try
    {
        const auto vtInputMode = gci.pInputBuffer->IsInVirtualTerminalInputMode();
        const auto bracketedPasteMode = gci.GetBracketedPasteMode();
        auto inEvents = TextToKeyEvents(pData, cchData, vtInputMode && bracketedPasteMode);
        gci.pInputBuffer->Write(inEvents);
    }
    catch (...)
    {
        LOG_HR(wil::ResultFromCaughtException());
    }
}",1,<empty>,,100,4,CPPASTProblemDeclaration,,<empty>
464486,UNKNOWN,8,,"InputEventQueue Clipboard::TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                           const size_t cchData,
                                           const bool bracketedPaste)
{
    THROW_HR_IF_NULL(E_INVALIDARG, pData);

    InputEventQueue keyEvents;
    const auto pushControlSequence = [&](const std::wstring_view sequence) {
        std::for_each(sequence.begin(), sequence.end(), [&](const auto wch) {
            keyEvents.push_back(SynthesizeKeyEvent(true, 1, 0, 0, wch, 0));
            keyEvents.push_back(SynthesizeKeyEvent(false, 1, 0, 0, wch, 0));
        });
    };

    // When a bracketed paste is requested, we need to wrap the text with
    // control sequences which indicate that the content has been pasted.
    if (bracketedPaste)
    {
        pushControlSequence(L""\x1b[200~"");
    }

    for (size_t i = 0; i < cchData; ++i)
    {
        auto currentChar = pData[i];

        const auto charAllowed = FilterCharacterOnPas...",1,<empty>,,184,8,CPPASTProblemDeclaration,,<empty>
464703,UNKNOWN,10,,"bool Clipboard::FilterCharacterOnPaste(_Inout_ WCHAR* const pwch)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto fAllowChar = true;
    if (gci.GetFilterOnPaste() &&
        (WI_IsFlagSet(gci.pInputBuffer->InputMode, ENABLE_PROCESSED_INPUT)))
    {
        switch (*pwch)
        {
            // swallow tabs to prevent inadvertent tab expansion
        case UNICODE_TAB:
        {
            fAllowChar = false;
            break;
        }

        // Replace Unicode space with standard space
        case UNICODE_NBSP:
        case UNICODE_NARROW_NBSP:
        {
            *pwch = UNICODE_SPACE;
            break;
        }

        // Replace ""smart quotes"" with ""dumb ones""
        case UNICODE_LEFT_SMARTQUOTE:
        case UNICODE_RIGHT_SMARTQUOTE:
        {
            *pwch = UNICODE_QUOTE;
            break;
        }

        // Replace Unicode dashes with a standard hyphen
        case UNICODE_EM_DASH:
        case UNICODE_EN_DASH:
...",1,<empty>,,333,10,CPPASTProblemDeclaration,,<empty>
464717,UNKNOWN,1,,"[[nodiscard]] NTSTATUS ConsoleControl::NotifyConsoleApplication(_In_ DWORD dwProcessId)
{
    CONSOLE_PROCESS_INFO cpi;
    cpi.dwProcessID = dwProcessId;
    cpi.dwFlags = CPI_NEWPROCESSWINDOW;

    return Control(ControlType::ConsoleNotifyConsoleApplication,
                   &cpi,
                   sizeof(CONSOLE_PROCESS_INFO));
}",1,<empty>,,18,1,CPPASTProblemDeclaration,,<empty>
464718,UNKNOWN,2,,"[[nodiscard]] NTSTATUS ConsoleControl::SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground)
{
    CONSOLESETFOREGROUND Flags;
    Flags.hProcess = hProcess;
    Flags.bForeground = fForeground;

    return Control(ControlType::ConsoleSetForeground,
                   &Flags,
                   sizeof(Flags));
}",1,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
464719,UNKNOWN,3,,"[[nodiscard]] NTSTATUS ConsoleControl::EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags)
{
    auto pConsoleWindow = ServiceLocator::LocateConsoleWindow();

    CONSOLEENDTASK ConsoleEndTaskParams;
    ConsoleEndTaskParams.ProcessId = ULongToHandle(dwProcessId); // This is actually a PID, even though the struct expects a HANDLE.
    ConsoleEndTaskParams.ConsoleEventCode = dwEventType;
    ConsoleEndTaskParams.ConsoleFlags = ulCtrlFlags;
    ConsoleEndTaskParams.hwnd = pConsoleWindow == nullptr ? nullptr : pConsoleWindow->GetWindowHandle();

    return Control(ControlType::ConsoleEndTask,
                   &ConsoleEndTaskParams,
                   sizeof(ConsoleEndTaskParams));
}",1,<empty>,,40,3,CPPASTProblemDeclaration,,<empty>
464754,UNKNOWN,5,,"[[nodiscard]] NTSTATUS ConsoleControl::Control(_In_ ControlType ConsoleCommand,
                                               _In_reads_bytes_(ConsoleInformationLength) PVOID ConsoleInformation,
                                               _In_ DWORD ConsoleInformationLength)
{
#ifdef CON_USERPRIVAPI_INDIRECT
    if (_hUser32 != nullptr)
    {
        typedef NTSTATUS(WINAPI * PfnConsoleControl)(ControlType Command, PVOID Information, DWORD Length);

        static auto pfn = (PfnConsoleControl)GetProcAddress(_hUser32, ""ConsoleControl"");

        if (pfn != nullptr)
        {
            return pfn(ConsoleCommand, ConsoleInformation, ConsoleInformationLength);
        }
    }

    return STATUS_UNSUCCESSFUL;
#else
    return ConsoleControl(ConsoleCommand, ConsoleInformation, ConsoleInformationLength);
#endif
}",1,<empty>,,71,5,CPPASTProblemDeclaration,,<empty>
464755,UNKNOWN,6,,"BOOL ConsoleControl::EnterReaderModeHelper(_In_ HWND hwnd)
{
#ifdef CON_USERPRIVAPI_INDIRECT
    if (_hUser32 != nullptr)
    {
        typedef BOOL(WINAPI * PfnEnterReaderModeHelper)(HWND hwnd);

        static auto pfn = (PfnEnterReaderModeHelper)GetProcAddress(_hUser32, ""EnterReaderModeHelper"");

        if (pfn != nullptr)
        {
            return pfn(hwnd);
        }
    }

    return FALSE;
#else
    return EnterReaderModeHelper(hwnd);
#endif
}",1,<empty>,,94,6,CPPASTProblemDeclaration,,<empty>
464756,UNKNOWN,7,,"BOOL ConsoleControl::TranslateMessageEx(const MSG* pmsg,
                                        _In_ UINT flags)
{
#ifdef CON_USERPRIVAPI_INDIRECT
    if (_hUser32 != nullptr)
    {
        typedef BOOL(WINAPI * PfnTranslateMessageEx)(const MSG* pmsg, UINT flags);

        static auto pfn = (PfnTranslateMessageEx)GetProcAddress(_hUser32, ""TranslateMessageEx"");

        if (pfn != nullptr)
        {
            return pfn(pmsg, flags);
        }
    }

    return FALSE;
#else
    return TranslateMessageEx(pmsg, flags);
#endif
}",1,<empty>,,115,7,CPPASTProblemDeclaration,,<empty>
464800,UNKNOWN,-1,,[[nodiscard]] NTSTATUS NotifyConsoleApplication(_In_ DWORD dwProcessId);,9,<empty>,,48,2,CPPASTProblemDeclaration,,<empty>
464801,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS SetForeground(_In_ HANDLE hProcess, _In_ BOOL fForeground);",9,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
464802,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS EndTask(_In_ DWORD dwProcessId, _In_ DWORD dwEventType, _In_ ULONG ulCtrlFlags);",9,<empty>,,50,4,CPPASTProblemDeclaration,,<empty>
464810,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS Control(_In_ ConsoleControl::ControlType ConsoleCommand,
                                       _In_reads_bytes_(ConsoleInformationLength) PVOID ConsoleInformation,
                                       _In_ DWORD ConsoleInformationLength);",9,<empty>,,54,6,CPPASTProblemDeclaration,,<empty>
464811,UNKNOWN,-1,,BOOL EnterReaderModeHelper(_In_ HWND hwnd);,9,<empty>,,58,7,CPPASTProblemDeclaration,,<empty>
464812,UNKNOWN,-1,,"BOOL TranslateMessageEx(const MSG* pmsg,
                                _In_ UINT flags);",9,<empty>,,60,8,CPPASTProblemDeclaration,,<empty>
464984,UNKNOWN,7,,"void SystemConfigurationProvider::GetSettingsFromLink(
    _Inout_ Settings* pLinkSettings,
    _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
    _Inout_ PDWORD pdwTitleLength,
    _In_ PCWSTR pwszCurrDir,
    _In_ PCWSTR pwszAppName,
    _Inout_opt_ IconInfo* iconInfo)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    WCHAR wszLinkTarget[MAX_PATH] = { 0 };
    WCHAR wszIconLocation[MAX_PATH] = { 0 };
    auto iIconIndex = 0;

    pLinkSettings->SetCodePage(ServiceLocator::LocateGlobals().uiOEMCP);

    // Did we get started from a link?
    if (pLinkSettings->GetStartupFlags() & STARTF_TITLEISLINKNAME)
    {
        auto initializedCom = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

        // GH#9458: If it's RPC_E_CHANGED_MODE, that's okay, we're doing a
        // defterm and have already started COM. We can continue on here.
        if (SUCCEEDED(initializedCom) || initializedCom == RPC_E_CHANGED_MODE)
        {
            // Don't...",1,<empty>,,58,7,CPPASTProblemDeclaration,,<empty>
465027,UNKNOWN,-1,,"void GetSettingsFromLink(_Inout_ Settings* pLinkSettings,
                                 _Inout_updates_bytes_(*pdwTitleLength) LPWSTR pwszTitle,
                                 _Inout_ PDWORD pdwTitleLength,
                                 _In_ PCWSTR pwszCurrDir,
                                 _In_ PCWSTR pwszAppName,
                                 _Inout_opt_ IconInfo* iconInfo);",9,<empty>,,36,8,CPPASTProblemDeclaration,,<empty>
465273,UNKNOWN,4,,"til::rect WindowMetrics::GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested)
{
    // prepare rectangle
    auto rc = *prcSuggested;

    // First get the monitor pointer from either the active window or the default location (0,0,0,0)
    HMONITOR hMonitor = nullptr;

    // NOTE: We must use the nearest monitor because sometimes the system moves the window around into strange spots while performing snap and Win+D operations.
    // Those operations won't work correctly if we use MONITOR_DEFAULTTOPRIMARY.
    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow == nullptr || rc != til::rect{})
    {
        // For invalid window handles or when we were passed a non-zero suggestion rectangle, get the monitor from the rect.
        hMonitor = MonitorFromRect(rc.as_win32_rect(), MONITOR_DEFAULTTONEAREST);
    }
    else
    {
        // Otherwise, get the monitor from the window handle.
        hMonitor = MonitorFromWindow(pWind...",1,<empty>,,83,4,CPPASTProblemDeclaration,,<empty>
465274,UNKNOWN,5,,"BOOL WindowMetrics::AdjustWindowRectEx(_Inout_ til::rect* prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle)
{
    return AdjustWindowRectEx(prc, dwStyle, fMenu, dwExStyle, ServiceLocator::LocateGlobals().dpi);
}",1,<empty>,,167,5,CPPASTProblemDeclaration,,<empty>
465275,UNKNOWN,6,,"BOOL WindowMetrics::AdjustWindowRectEx(_Inout_ til::rect* prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle, const int iDpi)
{
    return ServiceLocator::LocateHighDpiApi<WindowDpiApi>()->AdjustWindowRectExForDpi(prc->as_win32_rect(), dwStyle, fMenu, dwExStyle, iDpi);
}",1,<empty>,,182,6,CPPASTProblemDeclaration,,<empty>
465276,UNKNOWN,7,,"void WindowMetrics::ConvertClientRectToWindowRect(_Inout_ til::rect* const prc)
{
    ConvertRect(prc, ConvertRectangle::CLIENT_TO_WINDOW);
}",1,<empty>,,196,7,CPPASTProblemDeclaration,,<empty>
465277,UNKNOWN,8,,"void WindowMetrics::ConvertWindowRectToClientRect(_Inout_ til::rect* const prc)
{
    ConvertRect(prc, ConvertRectangle::WINDOW_TO_CLIENT);
}",1,<empty>,,210,8,CPPASTProblemDeclaration,,<empty>
465278,UNKNOWN,9,,"BOOL WindowMetrics::UnadjustWindowRectEx(_Inout_ til::rect* prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle)
{
    til::rect rc;
    auto fRc = AdjustWindowRectEx(&rc, dwStyle, fMenu, dwExStyle);
    if (fRc)
    {
        prc->left -= rc.left;
        prc->top -= rc.top;
        prc->right -= rc.right;
        prc->bottom -= rc.bottom;
    }
    return fRc;
}",1,<empty>,,226,9,CPPASTProblemDeclaration,,<empty>
465279,UNKNOWN,10,,"void WindowMetrics::ConvertRect(_Inout_ til::rect* const prc, const ConvertRectangle crDirection)
{
    // collect up current window style (if available) for adjustment
    DWORD dwStyle = 0;
    DWORD dwExStyle = 0;

    auto pWindow = ServiceLocator::LocateConsoleWindow();
    if (pWindow != nullptr)
    {
        dwStyle = GetWindowStyle(pWindow->GetWindowHandle());
        dwExStyle = GetWindowExStyle(pWindow->GetWindowHandle());
    }
    else
    {
        dwStyle = CONSOLE_WINDOW_FLAGS;
        dwExStyle = CONSOLE_WINDOW_EX_FLAGS;
    }

    switch (crDirection)
    {
    case CLIENT_TO_WINDOW:
    {
        // ask system to adjust our client rectangle into a window rectangle using the given style
        AdjustWindowRectEx(prc, dwStyle, false, dwExStyle);
        break;
    }
    case WINDOW_TO_CLIENT:
    {
        // ask system to adjust our window rectangle into a client rectangle using the given style
        UnadjustWindowRectEx(prc, dwStyle, false, dwExStyle);
        ...",1,<empty>,,248,10,CPPASTProblemDeclaration,,<empty>
465308,UNKNOWN,-1,,"til::rect GetMaxWindowRectInPixels(const til::rect* const prcSuggested, _Out_opt_ UINT* pDpiSuggested);",9,<empty>,,29,5,CPPASTProblemDeclaration,,<empty>
465309,UNKNOWN,-1,,"BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle);",9,<empty>,,31,6,CPPASTProblemDeclaration,,<empty>
465310,UNKNOWN,-1,,"BOOL AdjustWindowRectEx(_Inout_ til::rect* prc,
                                const DWORD dwStyle,
                                const BOOL fMenu,
                                const DWORD dwExStyle,
                                const int iDpi);",9,<empty>,,35,7,CPPASTProblemDeclaration,,<empty>
465311,UNKNOWN,-1,,void ConvertClientRectToWindowRect(_Inout_ til::rect* const prc);,9,<empty>,,41,8,CPPASTProblemDeclaration,,<empty>
465312,UNKNOWN,-1,,void ConvertWindowRectToClientRect(_Inout_ til::rect* const prc);,9,<empty>,,42,9,CPPASTProblemDeclaration,,<empty>
465316,UNKNOWN,-1,,"BOOL UnadjustWindowRectEx(_Inout_ til::rect* prc,
                                  const DWORD dwStyle,
                                  const BOOL fMenu,
                                  const DWORD dwExStyle);",9,<empty>,,51,11,CPPASTProblemDeclaration,,<empty>
465317,UNKNOWN,-1,,"void ConvertRect(_Inout_ til::rect* const prc, const ConvertRectangle crDirection);",9,<empty>,,56,12,CPPASTProblemDeclaration,,<empty>
465336,UNKNOWN,-1,,void Copy(_In_ const bool fAlsoCopyFormatting = false);,9,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
465337,UNKNOWN,-1,,"void StringPaste(_In_reads_(cchData) PCWCHAR pwchData,
                         const size_t cchData);",9,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
465362,UNKNOWN,-1,,"InputEventQueue TextToKeyEvents(_In_reads_(cchData) const wchar_t* const pData,
                                        const size_t cchData,
                                        const bool bracketedPaste = false);",9,<empty>,,43,9,CPPASTProblemDeclaration,,<empty>
465363,UNKNOWN,-1,,void StoreSelectionToClipboard(_In_ const bool fAlsoCopyFormatting);,9,<empty>,,47,10,CPPASTProblemDeclaration,,<empty>
465364,UNKNOWN,-1,,bool FilterCharacterOnPaste(_Inout_ WCHAR* const pwch);,9,<empty>,,49,11,CPPASTProblemDeclaration,,<empty>
465386,UNKNOWN,6,,"void StoreKeyInfo(_In_ PMSG msg)
{
    UINT i;

    for (i = 0; i < CONSOLE_MAX_KEY_INFO; i++)
    {
        if (ConsoleKeyInfo[i].hWnd == CONSOLE_FREE_KEY_INFO || ConsoleKeyInfo[i].hWnd == msg->hwnd)
        {
            break;
        }
    }

    if (i != CONSOLE_MAX_KEY_INFO)
    {
        ConsoleKeyInfo[i].hWnd = msg->hwnd;
        ConsoleKeyInfo[i].wVirtualKeyCode = LOWORD(msg->wParam);
        ConsoleKeyInfo[i].wVirtualScanCode = (BYTE)(HIWORD(msg->lParam));
    }
    else
    {
        RIPMSG0(RIP_WARNING, ""ConsoleKeyInfo buffer is full"");
    }
}",1,<empty>,,25,6,CPPASTProblemDeclaration,,<empty>
465387,UNKNOWN,7,,"void RetrieveKeyInfo(_In_ HWND hWnd, _Out_ PWORD pwVirtualKeyCode, _Inout_ PWORD pwVirtualScanCode, _In_ BOOL FreeKeyInfo)
{
    UINT i;

    for (i = 0; i < CONSOLE_MAX_KEY_INFO; i++)
    {
        if (ConsoleKeyInfo[i].hWnd == hWnd)
        {
            break;
        }
    }

    if (i != CONSOLE_MAX_KEY_INFO)
    {
        *pwVirtualKeyCode = ConsoleKeyInfo[i].wVirtualKeyCode;
        *pwVirtualScanCode = ConsoleKeyInfo[i].wVirtualScanCode;
        if (FreeKeyInfo)
        {
            ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
        }
    }
    else
    {
        *pwVirtualKeyCode = (WORD)OneCoreSafeMapVirtualKeyW(*pwVirtualScanCode, 3);
    }
}",1,<empty>,,49,7,CPPASTProblemDeclaration,,<empty>
465430,UNKNOWN,1,,void StoreKeyInfo(_In_ PMSG msg);,1,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
465431,UNKNOWN,2,,"void RetrieveKeyInfo(_In_ HWND hWnd, _Out_ PWORD pwVirtualKeyCode, _Inout_ PWORD pwVirtualScanCode, _In_ BOOL FreeKeyInfo);",1,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
465464,UNKNOWN,1,,INT_PTR,1,<empty>,,20,1,CPPASTProblemDeclaration,,<empty>
465716,UNKNOWN,1,,LPARAM,98,<empty>,,98,1,CPPASTTypeId,,<empty>
465762,UNKNOWN,4,,"[[nodiscard]] HRESULT Icon::GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon)
{
    auto hr = S_OK;

    if (nullptr != phIcon)
    {
        hr = _GetAvailableIconFromReference(_hIcon, _hDefaultIcon, phIcon);
    }

    if (SUCCEEDED(hr))
    {
        if (nullptr != phSmIcon)
        {
            hr = _GetAvailableIconFromReference(_hSmIcon, _hDefaultSmIcon, phSmIcon);
        }
    }

    return hr;
}",1,<empty>,,52,4,CPPASTProblemDeclaration,,<empty>
465822,UNKNOWN,1,,LPARAM,107,<empty>,,104,1,CPPASTTypeId,,<empty>
465835,UNKNOWN,1,,LPARAM,109,<empty>,,105,1,CPPASTTypeId,,<empty>
465841,UNKNOWN,6,,"[[nodiscard]] HRESULT Icon::LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex)
{
    auto hr = S_OK;

    // Return value is count of icons extracted, which is redundant with filling the pointers.
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms648069(v=vs.85).aspx
    ExtractIconExW(pwszIconLocation, nIconIndex, &_hIcon, &_hSmIcon, 1);

    // If the large icon failed, then ensure that we use the defaults.
    if (_hIcon == nullptr)
    {
        _DestroyNonDefaultIcons(); // ensure handles are destroyed/null
        hr = E_FAIL;
    }

    return hr;
}",1,<empty>,,120,6,CPPASTProblemDeclaration,,<empty>
465864,UNKNOWN,1,,LPARAM,51,<empty>,,156,1,CPPASTTypeId,,<empty>
465871,UNKNOWN,1,,LPARAM,53,<empty>,,157,1,CPPASTTypeId,,<empty>
465909,UNKNOWN,1,,HICON,32,<empty>,,189,1,CPPASTTypeId,,<empty>
465946,UNKNOWN,10,,"[[nodiscard]] HRESULT Icon::_GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon)
{
    auto hr = S_OK;

    // expecting hIconRef to be pointing to either the regular or small custom handles
    FAIL_FAST_IF(!(&hIconRef == &_hIcon || &hIconRef == &_hSmIcon));

    // expecting hDefaultIconRef to be pointing to either the regular or small default handles
    FAIL_FAST_IF(!(&hDefaultIconRef == &_hDefaultIcon || &hDefaultIconRef == &_hDefaultSmIcon));

    if (hIconRef != nullptr)
    {
        *phIcon = hIconRef;
    }
    else
    {
        hr = _GetDefaultIconFromReference(hDefaultIconRef, phIcon);
    }

    return hr;
}",1,<empty>,,233,10,CPPASTProblemDeclaration,,<empty>
465947,UNKNOWN,11,,"[[nodiscard]] HRESULT Icon::_GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon)
{
    // expecting hIconRef to be pointing to either the regular or small default handles
    FAIL_FAST_IF(!(&hIconRef == &_hDefaultIcon || &hIconRef == &_hDefaultSmIcon));

    auto hr = _Initialize();

    if (SUCCEEDED(hr))
    {
        *phIcon = hIconRef;
    }

    return hr;
}",1,<empty>,,262,11,CPPASTProblemDeclaration,,<empty>
465948,UNKNOWN,12,,"[[nodiscard]] HRESULT Icon::_SetIconFromReference(_In_ HICON& hIconRef, const HICON hNewIcon)
{
    // expecting hIconRef to be pointing to either the regular or small custom handles
    FAIL_FAST_IF(!(&hIconRef == &_hIcon || &hIconRef == &_hSmIcon));

    auto hr = S_OK;

    // Only set icon if something changed
    if (hNewIcon != hIconRef)
    {
        // If we had an existing custom icon, free it.
        _FreeIconFromReference(hIconRef);

        // If we were given a non-null icon, store it.
        if (hNewIcon != nullptr)
        {
            hIconRef = hNewIcon;
        }

        // Otherwise, we'll default back to using the default icon. Get method will handle this.
    }

    return hr;
}",1,<empty>,,285,12,CPPASTProblemDeclaration,,<empty>
465949,UNKNOWN,13,,"void Icon::_FreeIconFromReference(_In_ HICON& hIconRef)
{
    // expecting hIconRef to be pointing to either the regular or small custom handles
    FAIL_FAST_IF(!(&hIconRef == &_hIcon || &hIconRef == &_hSmIcon));

    if (hIconRef != nullptr)
    {
        DestroyIcon(hIconRef);
        hIconRef = nullptr;
    }
}",1,<empty>,,317,13,CPPASTProblemDeclaration,,<empty>
465959,UNKNOWN,-1,,"class Icon sealed
    {
    public:
        static Icon& Instance();

        [[nodiscard]] HRESULT GetIcons(_Out_opt_ HICON* const phIcon, _Out_opt_ HICON* const phSmIcon);
        [[nodiscard]] HRESULT SetIcons(const HICON hIcon, const HICON hSmIcon);

        [[nodiscard]] HRESULT LoadIconsFromPath(_In_ PCWSTR pwszIconLocation, const int nIconIndex);

        [[nodiscard]] HRESULT ApplyWindowMessageWorkaround(const HWND hwnd);

    protected:
        Icon();
        ~Icon();
        Icon(const Icon&) = delete;
        void operator=(const Icon&) = delete;

    private:
        [[nodiscard]] HRESULT _Initialize();

        void _DestroyNonDefaultIcons();

        // Helper methods
        [[nodiscard]] HRESULT _GetAvailableIconFromReference(_In_ HICON& hIconRef, _In_ HICON& hDefaultIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _GetDefaultIconFromReference(_In_ HICON& hIconRef, _Out_ HICON* const phIcon);
        [[nodiscard]] HRESULT _SetIconFromReference(_In_...",5,<empty>,,20,1,CPPASTProblemDeclaration,,<empty>
465991,UNKNOWN,1,,CONST,1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
465996,UNKNOWN,4,,CONST,1,<empty>,,24,4,CPPASTProblemDeclaration,,<empty>
466092,UNKNOWN,1,,UINT_PTR,30,<empty>,,74,1,CPPASTTypeId,,<empty>
466521,UNKNOWN,1,,APPLET_PROC,36,<empty>,,267,1,CPPASTTypeId,,<empty>
466524,UNKNOWN,1,,HMODULE,64,<empty>,,267,1,CPPASTTypeId,,<empty>
466558,UNKNOWN,1,,HMODULE,46,<empty>,,275,1,CPPASTTypeId,,<empty>
466750,UNKNOWN,1,,unsigned int,42,<empty>,,317,1,CPPASTTypeId,,<empty>
467345,UNKNOWN,1,,CursorType,41,<empty>,,461,1,CPPASTTypeId,,<empty>
467893,UNKNOWN,-1,,"class Menu sealed
    {
    public:
        Menu(_In_ HMENU hMenu,
             _In_ HMENU hHeirMenu);
        [[nodiscard]] static NTSTATUS CreateInstance(_In_ HWND hWnd);
        static Menu* Instance();
        ~Menu();

        void Initialize();

        static void s_ShowPropertiesDialog(const HWND hwnd, const BOOL Defaults);
        [[nodiscard]] static HRESULT s_GetConsoleState(_Out_ CONSOLE_STATE_INFO* const pStateInfo);

        static HMENU s_GetMenuHandle();
        static HMENU s_GetHeirMenuHandle();

    private:
        static void s_PropertiesUpdate(_In_ PCONSOLE_STATE_INFO pStateInfo);

        static Menu* s_Instance;

        HMENU _hMenu; // handle to system menu
        HMENU _hHeirMenu; // handle to menu we append to system menu
    };",5,<empty>,,25,1,CPPASTProblemDeclaration,,<empty>
467924,UNKNOWN,1,,"HRESULT ScreenInfoUiaProvider::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                                      _In_ WindowUiaProvider* const pUiaParent)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pUiaParent);
    RETURN_HR_IF_NULL(E_INVALIDARG, pData);

    RETURN_IF_FAILED(ScreenInfoUiaProviderBase::RuntimeClassInitialize(pData));
    _pUiaParent = pUiaParent;
    return S_OK;
}",1,<empty>,,15,1,CPPASTProblemDeclaration,,<empty>
467925,UNKNOWN,2,,"IFACEMETHODIMP ScreenInfoUiaProvider::Navigate(_In_ NavigateDirection direction,
                                               _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider)
{
    RETURN_HR_IF(E_INVALIDARG, ppProvider == nullptr);
    *ppProvider = nullptr;

    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    /*ApiMsgNavigate apiMsg;
    apiMsg.Direction = direction;
    Tracing::s_TraceUia(this, ApiCall::Navigate, &apiMsg);*/

    if (direction == NavigateDirection_Parent)
    {
        try
        {
            _pUiaParent->QueryInterface(IID_PPV_ARGS(ppProvider));
        }
        catch (...)
        {
            *ppProvider = nullptr;
            return wil::ResultFromCaughtException();
        }
        RETURN_IF_NULL_ALLOC(*ppProvider);
    }

    // For the other directions the default of nullptr is correct
    return S_OK;
}",1,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
467926,UNKNOWN,3,,"IFACEMETHODIMP ScreenInfoUiaProvider::get_BoundingRectangle(_Out_ UiaRect* pRect)
{
    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    //Tracing::s_TraceUia(this, ApiCall::GetBoundingRectangle, nullptr);

    auto rc = _pUiaParent->GetWindowRect();

    pRect->left = rc.left;
    pRect->top = rc.top;
    pRect->width = rc.right - rc.left;
    pRect->height = rc.bottom - rc.top;

    return S_OK;
}",1,<empty>,,55,3,CPPASTProblemDeclaration,,<empty>
467927,UNKNOWN,4,,"IFACEMETHODIMP ScreenInfoUiaProvider::get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider)
{
    RETURN_HR_IF(E_INVALIDARG, ppProvider == nullptr);
    *ppProvider = nullptr;

    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    //Tracing::s_TraceUia(this, ApiCall::GetFragmentRoot, nullptr);
    try
    {
        _pUiaParent->QueryInterface(IID_PPV_ARGS(ppProvider));
    }
    catch (...)
    {
        *ppProvider = nullptr;
        return wil::ResultFromCaughtException();
    }
    RETURN_IF_NULL_ALLOC(*ppProvider);
    return S_OK;
}",1,<empty>,,70,4,CPPASTProblemDeclaration,,<empty>
467947,UNKNOWN,7,,"HRESULT ScreenInfoUiaProvider::GetSelectionRange(_In_ IRawElementProviderSimple* pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;

    const auto start = _pData->GetSelectionAnchor();

    // we need to make end exclusive
    auto end = _pData->GetSelectionEnd();
    _pData->GetTextBuffer().GetSize().IncrementInBounds(end, true);

    // TODO GH #4509: Box Selection is misrepresented here as a line selection.
    UiaTextRange* result;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(&result, _pData, pProvider, start, end, _pData->IsBlockSelection(), wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,100,7,CPPASTProblemDeclaration,,<empty>
467948,UNKNOWN,8,,"HRESULT ScreenInfoUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    UiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(&result, _pData, pProvider, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,118,8,CPPASTProblemDeclaration,,<empty>
467949,UNKNOWN,9,,"HRESULT ScreenInfoUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                               const Cursor& cursor,
                                               const std::wstring_view wordDelimiters,
                                               _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    UiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(&result, _pData, pProvider, cursor, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,128,9,CPPASTProblemDeclaration,,<empty>
467950,UNKNOWN,10,,"HRESULT ScreenInfoUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                               const til::point start,
                                               const til::point end,
                                               const std::wstring_view wordDelimiters,
                                               _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    UiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(&result, _pData, pProvider, start, end, false, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,141,10,CPPASTProblemDeclaration,,<empty>
467951,UNKNOWN,11,,"HRESULT ScreenInfoUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                               const UiaPoint point,
                                               const std::wstring_view wordDelimiters,
                                               _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    UiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(&result, _pData, pProvider, point, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,155,11,CPPASTProblemDeclaration,,<empty>
467975,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ WindowUiaProvider* const pUiaParent);",9,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
467976,UNKNOWN,-1,,"IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override;",9,<empty>,,40,3,CPPASTProblemDeclaration,,<empty>
467977,UNKNOWN,-1,,IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;,9,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
467978,UNKNOWN,-1,,IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;,9,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
467988,UNKNOWN,-1,,"HRESULT GetSelectionRange(_In_ IRawElementProviderSimple* pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,49,8,CPPASTProblemDeclaration,,<empty>
467989,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,52,9,CPPASTProblemDeclaration,,<empty>
467990,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const Cursor& cursor,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,55,10,CPPASTProblemDeclaration,,<empty>
467991,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const til::point start,
                                const til::point end,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,61,11,CPPASTProblemDeclaration,,<empty>
467992,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const UiaPoint point,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,68,12,CPPASTProblemDeclaration,,<empty>
468007,UNKNOWN,1,,"HRESULT UiaTextRange::RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ IRawElementProviderSimple* const pProvider, _In_ const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, wordDelimiters);
}",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
468008,UNKNOWN,2,,"HRESULT UiaTextRange::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                             _In_ IRawElementProviderSimple* const pProvider,
                                             const Cursor& cursor,
                                             const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, cursor, wordDelimiters);
}",1,<empty>,,22,2,CPPASTProblemDeclaration,,<empty>
468009,UNKNOWN,3,,"HRESULT UiaTextRange::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                             _In_ IRawElementProviderSimple* const pProvider,
                                             const til::point start,
                                             const til::point end,
                                             bool blockRange,
                                             const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, start, end, blockRange, wordDelimiters);
}",1,<empty>,,31,3,CPPASTProblemDeclaration,,<empty>
468010,UNKNOWN,4,,"HRESULT UiaTextRange::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                             _In_ IRawElementProviderSimple* const pProvider,
                                             const UiaPoint point,
                                             const std::wstring_view wordDelimiters)
{
    RETURN_IF_FAILED(UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, wordDelimiters));
    Initialize(point);
    return S_OK;
}",1,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
468022,UNKNOWN,6,,"IFACEMETHODIMP UiaTextRange::Clone(_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal)
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<UiaTextRange>(ppRetVal, *this));

#if defined(_DEBUG) && defined(UiaTextRangeBase_DEBUG_MSGS)
    OutputDebugString(L""Clone\n"");
    std::wstringstream ss;
    ss << _id << L"" cloned to "" << (static_cast<UiaTextRangeBase*>(*ppRetVal))->_id;
    std::wstring str = ss.str();
    OutputDebugString(str.c_str());
    OutputDebugString(L""\n"");
#endif
    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    // tracing
    /*ApiMsgClone apiMsg;
    apiMsg.CloneId = static_cast<UiaTextRangeBase*>(*ppRetVal)->GetId();
    Tracing::s_TraceUia(this, ApiCall::Clone, &apiMsg);*/

    return S_OK;
}",1,<empty>,,57,6,CPPASTProblemDeclaration,,<empty>
468051,UNKNOWN,1,,ScreenInfoUiaProvider*,39,<empty>,,92,1,CPPASTTypeId,,<empty>
468078,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
468079,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
468080,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const til::point start,
                                       _In_ const til::point end,
                                       _In_ bool blockRange = false,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,41,4,CPPASTProblemDeclaration,,<empty>
468081,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const UiaPoint point,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter);",9,<empty>,,49,5,CPPASTProblemDeclaration,,<empty>
468087,UNKNOWN,-1,,IFACEMETHODIMP Clone(_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override;,9,<empty>,,56,7,CPPASTProblemDeclaration,,<empty>
475305,UNKNOWN,1,,void,14,<empty>,,129,1,CPPASTTypeId,,<empty>
475441,UNKNOWN,1,,void,14,<empty>,,182,1,CPPASTTypeId,,<empty>
475502,UNKNOWN,-1,,"IFACEMETHODIMP Navigate(_In_ NavigateDirection /*direction*/,
                            _COM_Outptr_result_maybenull_ IRawElementProviderFragment** /*ppProvider*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,214,1,CPPASTProblemDeclaration,,<empty>
475503,UNKNOWN,-1,,"IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* /*pRect*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,220,2,CPPASTProblemDeclaration,,<empty>
475504,UNKNOWN,-1,,"IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** /*ppProvider*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,225,3,CPPASTProblemDeclaration,,<empty>
475511,UNKNOWN,-1,,"HRESULT GetSelectionRange(_In_ IRawElementProviderSimple* /*pProvider*/, const std::wstring_view /*wordDelimiters*/, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** /*ppUtr*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,235,5,CPPASTProblemDeclaration,,<empty>
475512,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const /*pProvider*/, const std::wstring_view /*wordDelimiters*/, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** /*ppUtr*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,241,6,CPPASTProblemDeclaration,,<empty>
475513,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const /*pProvider*/,
                            const Cursor& /*cursor*/,
                            const std::wstring_view /*wordDelimiters*/,
                            _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** /*ppUtr*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,247,7,CPPASTProblemDeclaration,,<empty>
475514,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const /*pProvider*/,
                            const til::point /*start*/,
                            const til::point /*end*/,
                            const std::wstring_view /*wordDelimiters*/,
                            _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** /*ppUtr*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,256,8,CPPASTProblemDeclaration,,<empty>
475515,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const /*pProvider*/,
                            const UiaPoint /*point*/,
                            const std::wstring_view /*wordDelimiters*/,
                            _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** /*ppUtr*/) override
    {
        return E_NOTIMPL;
    }",5,<empty>,,266,9,CPPASTProblemDeclaration,,<empty>
475548,UNKNOWN,7,,"TEST_METHOD(DegenerateRangesDetected)
    {
        // make a degenerate range and verify that it reports degenerate
        Microsoft::WRL::ComPtr<UiaTextRange> degenerate;",5,<empty>,,390,7,CPPASTProblemDeclaration,,<empty>
475549,UNKNOWN,8,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&degenerate,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        origin));",9,<empty>,,394,8,CPPASTProblemDeclaration,,<empty>
475550,UNKNOWN,9,,VERIFY_IS_TRUE(degenerate->IsDegenerate());,9,<empty>,,399,9,CPPASTProblemDeclaration,,<empty>
475551,UNKNOWN,10,,"VERIFY_ARE_EQUAL(degenerate->_start, degenerate->_end);",9,<empty>,,400,10,CPPASTProblemDeclaration,,<empty>
475561,UNKNOWN,14,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&notDegenerate,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        end));",9,<empty>,,405,14,CPPASTProblemDeclaration,,<empty>
475562,UNKNOWN,15,,VERIFY_IS_FALSE(notDegenerate->IsDegenerate());,9,<empty>,,410,15,CPPASTProblemDeclaration,,<empty>
475563,UNKNOWN,16,,"VERIFY_ARE_NOT_EQUAL(notDegenerate->_start, notDegenerate->_end);",9,<empty>,,411,16,CPPASTProblemDeclaration,,<empty>
475564,UNKNOWN,17,,},5,<empty>,,412,17,CPPASTProblemDeclaration,,<empty>
475565,UNKNOWN,18,,"TEST_METHOD(CompareRange)
    {
        Microsoft::WRL::ComPtr<UiaTextRange> utr1;",5,<empty>,,414,18,CPPASTProblemDeclaration,,<empty>
475566,UNKNOWN,19,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr1,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        origin));",9,<empty>,,417,19,CPPASTProblemDeclaration,,<empty>
475568,UNKNOWN,21,,THROW_IF_FAILED(utr1->Clone(&utr2));,9,<empty>,,425,21,CPPASTProblemDeclaration,,<empty>
475570,UNKNOWN,23,,"Log::Comment(L""_start and _end should match"");",9,<empty>,,428,23,CPPASTProblemDeclaration,,<empty>
475571,UNKNOWN,24,,"THROW_IF_FAILED(utr1->Compare(utr2.Get(), &comparison));",9,<empty>,,429,24,CPPASTProblemDeclaration,,<empty>
475581,UNKNOWN,28,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr2,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        end));",9,<empty>,,434,28,CPPASTProblemDeclaration,,<empty>
475582,UNKNOWN,29,,"Log::Comment(L""_end is different"");",9,<empty>,,440,29,CPPASTProblemDeclaration,,<empty>
475583,UNKNOWN,30,,"THROW_IF_FAILED(utr1->Compare(utr2.Get(), &comparison));",9,<empty>,,441,30,CPPASTProblemDeclaration,,<empty>
475585,UNKNOWN,32,,},5,<empty>,,443,32,CPPASTProblemDeclaration,,<empty>
475586,UNKNOWN,33,,"TEST_METHOD(CompareEndpoints)
    {
        Microsoft::WRL::ComPtr<UiaTextRange> utr1;",5,<empty>,,445,33,CPPASTProblemDeclaration,,<empty>
475587,UNKNOWN,34,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr1,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        origin));",9,<empty>,,448,34,CPPASTProblemDeclaration,,<empty>
475589,UNKNOWN,36,,THROW_IF_FAILED(utr1->Clone(&utr2));,9,<empty>,,455,36,CPPASTProblemDeclaration,,<empty>
475591,UNKNOWN,38,,"Log::Comment(L""For a degenerate range, comparing _start and _end should return 0"");",9,<empty>,,458,38,CPPASTProblemDeclaration,,<empty>
475592,UNKNOWN,39,,VERIFY_IS_TRUE(utr1->IsDegenerate());,9,<empty>,,459,39,CPPASTProblemDeclaration,,<empty>
475593,UNKNOWN,40,,"THROW_IF_FAILED(utr1->CompareEndpoints(TextPatternRangeEndpoint_Start, utr1.Get(), TextPatternRangeEndpoint_End, &comparison));",9,<empty>,,460,40,CPPASTProblemDeclaration,,<empty>
475594,UNKNOWN,41,,"Log::Comment(L""_start and _end should match"");",9,<empty>,,462,41,CPPASTProblemDeclaration,,<empty>
475595,UNKNOWN,42,,"THROW_IF_FAILED(utr1->CompareEndpoints(TextPatternRangeEndpoint_Start, utr2.Get(), TextPatternRangeEndpoint_Start, &comparison));",9,<empty>,,463,42,CPPASTProblemDeclaration,,<empty>
475596,UNKNOWN,43,,VERIFY_IS_TRUE(comparison == 0);,9,<empty>,,464,43,CPPASTProblemDeclaration,,<empty>
475597,UNKNOWN,44,,"THROW_IF_FAILED(utr1->CompareEndpoints(TextPatternRangeEndpoint_End, utr2.Get(), TextPatternRangeEndpoint_End, &comparison));",9,<empty>,,465,44,CPPASTProblemDeclaration,,<empty>
475598,UNKNOWN,45,,VERIFY_IS_TRUE(comparison == 0);,9,<empty>,,466,45,CPPASTProblemDeclaration,,<empty>
475607,UNKNOWN,48,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr2,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        origin,
                                                                        end));",9,<empty>,,470,48,CPPASTProblemDeclaration,,<empty>
475608,UNKNOWN,49,,"Log::Comment(L""_start should match"");",9,<empty>,,476,49,CPPASTProblemDeclaration,,<empty>
475609,UNKNOWN,50,,"THROW_IF_FAILED(utr1->CompareEndpoints(TextPatternRangeEndpoint_Start, utr2.Get(), TextPatternRangeEndpoint_Start, &comparison));",9,<empty>,,477,50,CPPASTProblemDeclaration,,<empty>
475610,UNKNOWN,51,,VERIFY_IS_TRUE(comparison == 0);,9,<empty>,,478,51,CPPASTProblemDeclaration,,<empty>
475611,UNKNOWN,52,,"Log::Comment(L""_start and end should be 2 units apart. Sign depends on order of comparison."");",9,<empty>,,480,52,CPPASTProblemDeclaration,,<empty>
475612,UNKNOWN,53,,"THROW_IF_FAILED(utr1->CompareEndpoints(TextPatternRangeEndpoint_End, utr2.Get(), TextPatternRangeEndpoint_End, &comparison));",9,<empty>,,481,53,CPPASTProblemDeclaration,,<empty>
475613,UNKNOWN,54,,VERIFY_IS_TRUE(comparison == -2);,9,<empty>,,482,54,CPPASTProblemDeclaration,,<empty>
475614,UNKNOWN,55,,"THROW_IF_FAILED(utr2->CompareEndpoints(TextPatternRangeEndpoint_End, utr1.Get(), TextPatternRangeEndpoint_End, &comparison));",9,<empty>,,483,55,CPPASTProblemDeclaration,,<empty>
475615,UNKNOWN,56,,VERIFY_IS_TRUE(comparison == 2);,9,<empty>,,484,56,CPPASTProblemDeclaration,,<empty>
475616,UNKNOWN,57,,},5,<empty>,,485,57,CPPASTProblemDeclaration,,<empty>
475617,UNKNOWN,58,,"TEST_METHOD(ExpandToEnclosingUnit)
    {
        // Let's start by filling the text buffer with something useful:
        for (auto i = 0;",5,<empty>,,487,58,CPPASTProblemDeclaration,,<empty>
475618,UNKNOWN,59,,i < _pTextBuffer->TotalRowCount();,26,<empty>,,490,59,CPPASTProblemDeclaration,,<empty>
475619,UNKNOWN,60,,"++i)
        {
            auto& row = _pTextBuffer->GetMutableRowByOffset(i);
            const auto width = row.size();

            for (uint16_t x = 0; x < width; ++x)
            {
                const std::wstring_view glyph{ x % 5 == 0 ? L"" "" : L""x"" };
                row.ReplaceCharacters(x, 1, glyph);
            }
        }",61,<empty>,,490,60,CPPASTProblemDeclaration,,<empty>
475682,UNKNOWN,69,,"for (auto textUnit : supportedUnits)
        {
            const auto boundaries = textUnitBoundaries.at(textUnit);

            // Test 1
            Log::Comment(NoThrowString().Format(L""%s - Test 1"", toString(textUnit)));
            verifyExpansion(textUnit, boundaries.start, boundaries.start);

            // Test 2 (impossible for TextUnit_Character)
            if (textUnit != TextUnit_Character)
            {
                Log::Comment(NoThrowString().Format(L""%s - Test 2"", toString(textUnit)));
                const til::point end = { boundaries.start.x + 1, boundaries.start.y };
                verifyExpansion(textUnit, boundaries.start, end);
            }

            // Test 3
            Log::Comment(NoThrowString().Format(L""%s - Test 3"", toString(textUnit)));
            verifyExpansion(textUnit, boundaries.start, boundaries.end);

            // Test 4 (impossible for TextUnit_Character and TextUnit_Document)
            if (textUnit != TextUnit_Character && textUn...",9,<empty>,,568,69,CPPASTProblemDeclaration,,<empty>
475683,UNKNOWN,70,,},5,<empty>,,630,70,CPPASTProblemDeclaration,,<empty>
475684,UNKNOWN,71,,"TEST_METHOD(MoveEndpointByRange)
    {
        const til::point start{ 0, 1 };",5,<empty>,,632,71,CPPASTProblemDeclaration,,<empty>
475692,UNKNOWN,75,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr,
                                                                        _pUiaData,
                                                                        &_dummyProvider,
                                                                        start,
                                                                        end));",9,<empty>,,637,75,CPPASTProblemDeclaration,,<empty>
475697,UNKNOWN,79,,"Log::Comment(L""Move target's end to utr1's start"");",9,<empty>,,653,79,CPPASTProblemDeclaration,,<empty>
475698,UNKNOWN,80,,"{
            resetTargetUTR();
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_End,
                                                        utr.Get(),
                                                        TextPatternRangeEndpoint_Start));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), origin);
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_End), utr->GetEndpoint(TextPatternRangeEndpoint_Start));
        }",9,<empty>,,654,80,CPPASTProblemDeclaration,,<empty>
475699,UNKNOWN,81,,"Log::Comment(L""Move target's start/end to utr1's start/end respectively"");",9,<empty>,,663,81,CPPASTProblemDeclaration,,<empty>
475700,UNKNOWN,82,,"{
            resetTargetUTR();
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_End,
                                                        utr.Get(),
                                                        TextPatternRangeEndpoint_End));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), origin);
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_End), utr->GetEndpoint(TextPatternRangeEndpoint_End));

            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_Start,
                                                        utr.Get(),
                                                        TextPatternRangeEndpoint_Start));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), utr->GetEndpoint(TextPatternRangeEndpoint_Start));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_End), utr->GetEndpoint(TextPatternRangeEndpoint_End...",9,<empty>,,664,82,CPPASTProblemDeclaration,,<empty>
475701,UNKNOWN,83,,"Log::Comment(L""(Clone utr1) Collapse onto itself"");",9,<empty>,,679,83,CPPASTProblemDeclaration,,<empty>
475702,UNKNOWN,84,,"{
            // Move start to end
            ComPtr<ITextRangeProvider> temp;
            THROW_IF_FAILED(utr->Clone(&temp));
            target = static_cast<UiaTextRange*>(temp.Get());
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_Start,
                                                        target.Get(),
                                                        TextPatternRangeEndpoint_End));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), utr->GetEndpoint(TextPatternRangeEndpoint_End));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_End), utr->GetEndpoint(TextPatternRangeEndpoint_End));

            // Move end to start
            THROW_IF_FAILED(utr->Clone(&temp));
            target = static_cast<UiaTextRange*>(temp.Get());
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_End,
                                                        target.Get(),
   ...",9,<empty>,,680,84,CPPASTProblemDeclaration,,<empty>
475703,UNKNOWN,85,,"Log::Comment(L""Cross endpoints (force degenerate range)"");",9,<empty>,,701,85,CPPASTProblemDeclaration,,<empty>
475704,UNKNOWN,86,,"{
            // move start past end
            resetTargetUTR();
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_Start,
                                                        utr.Get(),
                                                        TextPatternRangeEndpoint_End));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), utr->GetEndpoint(TextPatternRangeEndpoint_End));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_End), utr->GetEndpoint(TextPatternRangeEndpoint_End));
            VERIFY_IS_TRUE(target->IsDegenerate());

            // move end past start
            THROW_IF_FAILED(target->MoveEndpointByRange(TextPatternRangeEndpoint_End,
                                                        utr.Get(),
                                                        TextPatternRangeEndpoint_Start));
            VERIFY_ARE_EQUAL(target->GetEndpoint(TextPatternRangeEndpoint_Start), utr->GetEndpoi...",9,<empty>,,702,86,CPPASTProblemDeclaration,,<empty>
475705,UNKNOWN,87,,},5,<empty>,,720,87,CPPASTProblemDeclaration,,<empty>
475706,UNKNOWN,88,,"TEST_METHOD(CanMoveByCharacter)
    {
        const auto lastColumnIndex = _pScreenInfo->GetBufferSize().RightInclusive();",5,<empty>,,722,88,CPPASTProblemDeclaration,,<empty>
475829,UNKNOWN,94,,"for (const auto& test : testData)
        {
            Log::Comment(test.comment.data());
            int amountMoved;

            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.start, test.end));
            THROW_IF_FAILED(utr->Move(TextUnit::TextUnit_Character, test.moveAmt, &amountMoved));

            VERIFY_ARE_EQUAL(test.expected.moveAmt, amountMoved);
            VERIFY_ARE_EQUAL(test.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(test.expected.end, utr->_end);
        }",9,<empty>,,796,94,CPPASTProblemDeclaration,,<empty>
475830,UNKNOWN,95,,},5,<empty>,,808,95,CPPASTProblemDeclaration,,<empty>
475831,UNKNOWN,96,,"TEST_METHOD(CanMoveByLine)
    {
        const auto lastColumnIndex = _pScreenInfo->GetBufferSize().Width() - 1;",5,<empty>,,810,96,CPPASTProblemDeclaration,,<empty>
475962,UNKNOWN,102,,"for (const auto& test : testData)
        {
            Log::Comment(test.comment.data());
            int amountMoved;

            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.start, test.end));
            THROW_IF_FAILED(utr->Move(TextUnit::TextUnit_Line, test.moveAmt, &amountMoved));

            VERIFY_ARE_EQUAL(test.expected.moveAmt, amountMoved);
            VERIFY_ARE_EQUAL(test.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(test.expected.end, utr->_end);
        }",9,<empty>,,884,102,CPPASTProblemDeclaration,,<empty>
475963,UNKNOWN,103,,},5,<empty>,,896,103,CPPASTProblemDeclaration,,<empty>
475964,UNKNOWN,104,,"TEST_METHOD(CanMoveEndpointByUnitCharacter)
    {
        const auto lastColumnIndex = _pScreenInfo->GetBufferSize().Width() - 1;",5,<empty>,,898,104,CPPASTProblemDeclaration,,<empty>
476203,UNKNOWN,110,,"for (const auto& test : testData)
        {
            Log::Comment(test.comment.data());
            int amountMoved;

            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.start, test.end));
            THROW_IF_FAILED(utr->MoveEndpointByUnit(test.endpoint, TextUnit::TextUnit_Character, test.moveAmt, &amountMoved));

            VERIFY_ARE_EQUAL(test.expected.moveAmt, amountMoved);
            VERIFY_ARE_EQUAL(test.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(test.expected.end, utr->_end);
        }",9,<empty>,,1029,110,CPPASTProblemDeclaration,,<empty>
476204,UNKNOWN,111,,},5,<empty>,,1041,111,CPPASTProblemDeclaration,,<empty>
476205,UNKNOWN,112,,"TEST_METHOD(CanMoveEndpointByUnitLine)
    {
        const auto lastColumnIndex = _pScreenInfo->GetBufferSize().Width() - 1;",5,<empty>,,1043,112,CPPASTProblemDeclaration,,<empty>
476426,UNKNOWN,120,,"for (const auto& test : testData)
        {
            Log::Comment(test.comment.data());
            int amountMoved;

            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.start, test.end));
            THROW_IF_FAILED(utr->MoveEndpointByUnit(test.endpoint, TextUnit::TextUnit_Line, test.moveAmt, &amountMoved));

            VERIFY_ARE_EQUAL(test.expected.moveAmt, amountMoved);
            VERIFY_ARE_EQUAL(test.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(test.expected.end, utr->_end);
        }",9,<empty>,,1168,120,CPPASTProblemDeclaration,,<empty>
476427,UNKNOWN,121,,},5,<empty>,,1180,121,CPPASTProblemDeclaration,,<empty>
476428,UNKNOWN,122,,"TEST_METHOD(CanMoveEndpointByUnitDocument)
    {
        const auto bottomRow = _pTextBuffer->TotalRowCount() - 1;",5,<empty>,,1182,122,CPPASTProblemDeclaration,,<empty>
476566,UNKNOWN,128,,"for (auto test : testData)
        {
            Log::Comment(test.comment.c_str());
            int amountMoved;

            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.start, test.end));
            THROW_IF_FAILED(utr->MoveEndpointByUnit(test.endpoint, TextUnit::TextUnit_Document, test.moveAmt, &amountMoved));

            VERIFY_ARE_EQUAL(test.expected.moveAmt, amountMoved);
            VERIFY_ARE_EQUAL(test.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(test.expected.end, utr->_end);
        }",9,<empty>,,1274,128,CPPASTProblemDeclaration,,<empty>
476567,UNKNOWN,129,,},5,<empty>,,1286,129,CPPASTProblemDeclaration,,<empty>
476568,UNKNOWN,130,,"TEST_METHOD(ExpansionAtExclusiveEnd)
    {
        // GH#7664: When attempting to expand to an enclosing unit
        // at the end exclusive, the UTR should refuse to move past
        // the end.
        const auto lastNonspaceCharPos{ _pTextBuffer->GetLastNonSpaceCharacter() };",5,<empty>,,1288,130,CPPASTProblemDeclaration,,<empty>
476579,UNKNOWN,133,,"BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:textUnit"", L""{0, 1, 2, 3, 4, 5, 6}"")
        END_TEST_METHOD_PROPERTIES();",9,<empty>,,1299,133,CPPASTProblemDeclaration,,<empty>
476581,UNKNOWN,135,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""textUnit"", textUnit), L""Get textUnit variant"");",9,<empty>,,1304,135,CPPASTProblemDeclaration,,<empty>
476583,UNKNOWN,137,,"Log::Comment(NoThrowString().Format(L""%s"", toString(static_cast<TextUnit>(textUnit))));",9,<empty>,,1307,137,CPPASTProblemDeclaration,,<empty>
476584,UNKNOWN,138,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, bufferEnd, endExclusive));",9,<empty>,,1310,138,CPPASTProblemDeclaration,,<empty>
476585,UNKNOWN,139,,THROW_IF_FAILED(utr->ExpandToEnclosingUnit(static_cast<TextUnit>(textUnit)));,9,<empty>,,1311,139,CPPASTProblemDeclaration,,<empty>
476586,UNKNOWN,140,,"VERIFY_ARE_EQUAL(documentEnd, utr->_end);",9,<empty>,,1313,140,CPPASTProblemDeclaration,,<empty>
476587,UNKNOWN,141,,},5,<empty>,,1314,141,CPPASTProblemDeclaration,,<empty>
476588,UNKNOWN,142,,"TEST_METHOD(MovementAtExclusiveEnd)
    {
        // GH#7663: When attempting to move from end exclusive,
        // the UTR should refuse to move past the end.
        const auto endInclusive{ bufferEnd };",5,<empty>,,1316,142,CPPASTProblemDeclaration,,<empty>
476589,UNKNOWN,143,,_pTextBuffer->Reset();,9,<empty>,,1323,143,CPPASTProblemDeclaration,,<empty>
476596,UNKNOWN,146,,"_pTextBuffer->Write({ L""temp"" }",9,<empty>,,1325,146,CPPASTProblemDeclaration,,<empty>
476597,UNKNOWN,147,,", writeTarget);",40,<empty>,,1325,147,CPPASTProblemDeclaration,,<empty>
476656,UNKNOWN,158,,"BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:textUnit"", L""{0, 1, 2, 3, 4, 5, 6}"")
            TEST_METHOD_PROPERTY(L""Data:degenerate"", L""{false, true}"")
            TEST_METHOD_PROPERTY(L""Data:atDocumentEnd"", L""{false, true}"")
        END_TEST_METHOD_PROPERTIES();",9,<empty>,,1339,158,CPPASTProblemDeclaration,,<empty>
476660,UNKNOWN,162,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""textUnit"", unit), L""Get TextUnit variant"");",9,<empty>,,1348,162,CPPASTProblemDeclaration,,<empty>
476661,UNKNOWN,163,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""degenerate"", degenerate), L""Get degenerate variant"");",9,<empty>,,1349,163,CPPASTProblemDeclaration,,<empty>
476662,UNKNOWN,164,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""atDocumentEnd"", atDocumentEnd), L""Get atDocumentEnd variant"");",9,<empty>,,1350,164,CPPASTProblemDeclaration,,<empty>
476668,UNKNOWN,1,,TextUnit,36,<empty>,,1351,1,CPPASTTypeId,,<empty>
476672,UNKNOWN,169,,"Log::Comment(NoThrowString().Format(L""Forward by %s"", toString(textUnit)));",9,<empty>,,1355,169,CPPASTProblemDeclaration,,<empty>
476681,UNKNOWN,172,,"if (degenerate)
        {
            // UTR: (exclusive, exclusive) range
            const auto utrStart{ atDocumentEnd ? documentEndExclusive : endExclusive };
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, utrStart, utrEnd));
        }",9,<empty>,,1359,172,CPPASTProblemDeclaration,,<empty>
476682,UNKNOWN,173,,"else
        {
            // UTR: (inclusive, exclusive) range
            const auto utrStart{ atDocumentEnd ? documentEndInclusive : endInclusive };
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, utrStart, utrEnd));
        }",9,<empty>,,1365,173,CPPASTProblemDeclaration,,<empty>
476683,UNKNOWN,174,,"THROW_IF_FAILED(utr->Move(textUnit, 1, &moveAmt));",9,<empty>,,1371,174,CPPASTProblemDeclaration,,<empty>
476684,UNKNOWN,175,,"VERIFY_ARE_EQUAL(documentEndExclusive, utr->_end);",9,<empty>,,1373,175,CPPASTProblemDeclaration,,<empty>
476685,UNKNOWN,176,,"VERIFY_ARE_EQUAL(0, moveAmt);",9,<empty>,,1374,176,CPPASTProblemDeclaration,,<empty>
476686,UNKNOWN,177,,"Log::Comment(NoThrowString().Format(L""Expand by %s"", toString(textUnit)));",9,<empty>,,1377,177,CPPASTProblemDeclaration,,<empty>
476687,UNKNOWN,178,,THROW_IF_FAILED(utr->ExpandToEnclosingUnit(textUnit));,9,<empty>,,1378,178,CPPASTProblemDeclaration,,<empty>
476688,UNKNOWN,179,,"if (textUnit <= TextUnit::TextUnit_Character)
        {
            VERIFY_ARE_EQUAL(documentEndInclusive, utr->_start);
            VERIFY_ARE_EQUAL(documentEndExclusive, utr->_end);
        }",9,<empty>,,1379,179,CPPASTProblemDeclaration,,<empty>
476689,UNKNOWN,180,,"else if (textUnit <= TextUnit::TextUnit_Word)
        {
            VERIFY_ARE_EQUAL(writeTarget, utr->_start);
            VERIFY_ARE_EQUAL(documentEndExclusive, utr->_end);
        }",9,<empty>,,1384,180,CPPASTProblemDeclaration,,<empty>
476690,UNKNOWN,181,,"else if (textUnit <= TextUnit::TextUnit_Line)
        {
            VERIFY_ARE_EQUAL(lastLineStart, utr->_start);
            VERIFY_ARE_EQUAL(documentEndExclusive, utr->_end);
        }",9,<empty>,,1389,181,CPPASTProblemDeclaration,,<empty>
476691,UNKNOWN,182,,"else // textUnit <= TextUnit::TextUnit_Document:
        {
            VERIFY_ARE_EQUAL(origin, utr->_start);
            VERIFY_ARE_EQUAL(documentEndExclusive, utr->_end);
        }",9,<empty>,,1394,182,CPPASTProblemDeclaration,,<empty>
476692,UNKNOWN,183,,"if (degenerate)
        {
            // UTR: (exclusive, exclusive) range
            const auto utrStart{ atDocumentEnd ? documentEndExclusive : endExclusive };
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, utrStart, utrEnd));
        }",9,<empty>,,1401,183,CPPASTProblemDeclaration,,<empty>
476693,UNKNOWN,184,,"else
        {
            // UTR: (inclusive, exclusive) range
            const auto utrStart{ atDocumentEnd ? documentEndInclusive : endInclusive };
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, utrStart, utrEnd));
        }",9,<empty>,,1407,184,CPPASTProblemDeclaration,,<empty>
476694,UNKNOWN,185,,"Log::Comment(NoThrowString().Format(L""Backwards by %s"", toString(textUnit)));",9,<empty>,,1415,185,CPPASTProblemDeclaration,,<empty>
476695,UNKNOWN,186,,"THROW_IF_FAILED(utr->Move(textUnit, -1, &moveAmt));",9,<empty>,,1416,186,CPPASTProblemDeclaration,,<empty>
476696,UNKNOWN,187,,"if (textUnit <= TextUnit::TextUnit_Character)
        {
            // Special case: _end will always be endInclusive, because...
            // -  degenerate --> it moves with _start to stay degenerate
            // - !degenerate --> it excludes the last char, to select the second to last char
            VERIFY_ARE_EQUAL(-1, moveAmt);
            VERIFY_ARE_EQUAL(degenerate || !atDocumentEnd ? documentEndInclusive : secondToLastCharacterPos, utr->_start);
            VERIFY_ARE_EQUAL(documentEndInclusive, utr->_end);
        }",9,<empty>,,1419,187,CPPASTProblemDeclaration,,<empty>
476697,UNKNOWN,188,,"else if (textUnit <= TextUnit::TextUnit_Word)
        {
            VERIFY_ARE_EQUAL(-1, moveAmt);
            VERIFY_ARE_EQUAL(degenerate || !atDocumentEnd ? writeTarget : origin, utr->_start);
            VERIFY_ARE_EQUAL(writeTarget, utr->_end);
        }",9,<empty>,,1428,188,CPPASTProblemDeclaration,,<empty>
476698,UNKNOWN,189,,"else if (textUnit <= TextUnit::TextUnit_Line)
        {
            VERIFY_ARE_EQUAL(-1, moveAmt);
            VERIFY_ARE_EQUAL(degenerate || !atDocumentEnd ? lastLineStart : secondToLastLinePos, utr->_start);
            VERIFY_ARE_EQUAL(lastLineStart, utr->_end);
        }",9,<empty>,,1434,189,CPPASTProblemDeclaration,,<empty>
476699,UNKNOWN,190,,"else // textUnit <= TextUnit::TextUnit_Document:
        {
            VERIFY_ARE_EQUAL(degenerate || !atDocumentEnd ? -1 : 0, moveAmt);
            VERIFY_ARE_EQUAL(origin, utr->_start);
            VERIFY_ARE_EQUAL(degenerate || !atDocumentEnd ? origin : documentEndExclusive, utr->_end);
        }",9,<empty>,,1440,190,CPPASTProblemDeclaration,,<empty>
476700,UNKNOWN,191,,},5,<empty>,,1446,191,CPPASTProblemDeclaration,,<empty>
476701,UNKNOWN,192,,"TEST_METHOD(MoveToPreviousWord)
    {
        // See GH#7742 for more details.

        const auto originExclusive{ point_offset_by_char(origin, bufferSize, 1) };",5,<empty>,,1448,192,CPPASTProblemDeclaration,,<empty>
476702,UNKNOWN,193,,"_pTextBuffer->Write({ L""My name is Carlos"" }",9,<empty>,,1454,193,CPPASTProblemDeclaration,,<empty>
476703,UNKNOWN,194,,", origin);",53,<empty>,,1454,194,CPPASTProblemDeclaration,,<empty>
476705,UNKNOWN,196,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, origin, origin));",9,<empty>,,1458,196,CPPASTProblemDeclaration,,<empty>
476707,UNKNOWN,198,,"THROW_IF_FAILED(utr->Move(TextUnit::TextUnit_Word, 1, &moveAmt));",9,<empty>,,1462,198,CPPASTProblemDeclaration,,<empty>
476708,UNKNOWN,199,,"VERIFY_ARE_EQUAL(1, moveAmt);",9,<empty>,,1463,199,CPPASTProblemDeclaration,,<empty>
476709,UNKNOWN,200,,VERIFY_IS_TRUE(utr->IsDegenerate());,9,<empty>,,1464,200,CPPASTProblemDeclaration,,<empty>
476711,UNKNOWN,202,,THROW_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit::TextUnit_Word));,9,<empty>,,1468,202,CPPASTProblemDeclaration,,<empty>
476712,UNKNOWN,203,,"THROW_IF_FAILED(utr->GetText(-1, &text));",9,<empty>,,1469,203,CPPASTProblemDeclaration,,<empty>
476713,UNKNOWN,204,,"VERIFY_ARE_EQUAL(L""name "", std::wstring_view{ text }",9,<empty>,,1470,204,CPPASTProblemDeclaration,,<empty>
476714,UNKNOWN,205,,);,61,<empty>,,1470,205,CPPASTProblemDeclaration,,<empty>
476721,UNKNOWN,208,,"THROW_IF_FAILED(utr->MoveEndpointByRange(TextPatternRangeEndpoint::TextPatternRangeEndpoint_End, utr.Get(), TextPatternRangeEndpoint::TextPatternRangeEndpoint_Start));",9,<empty>,,1474,208,CPPASTProblemDeclaration,,<empty>
476722,UNKNOWN,209,,"VERIFY_ARE_EQUAL(expectedStart, utr->_start);",9,<empty>,,1475,209,CPPASTProblemDeclaration,,<empty>
476723,UNKNOWN,210,,VERIFY_IS_TRUE(utr->IsDegenerate());,9,<empty>,,1476,210,CPPASTProblemDeclaration,,<empty>
476724,UNKNOWN,211,,"THROW_IF_FAILED(utr->Move(TextUnit::TextUnit_Word, -1, &moveAmt));",9,<empty>,,1479,211,CPPASTProblemDeclaration,,<empty>
476725,UNKNOWN,212,,"VERIFY_ARE_EQUAL(-1, moveAmt);",9,<empty>,,1480,212,CPPASTProblemDeclaration,,<empty>
476726,UNKNOWN,213,,THROW_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit::TextUnit_Character));,9,<empty>,,1483,213,CPPASTProblemDeclaration,,<empty>
476727,UNKNOWN,214,,"THROW_IF_FAILED(utr->GetText(-1, &text));",9,<empty>,,1484,214,CPPASTProblemDeclaration,,<empty>
476728,UNKNOWN,215,,"VERIFY_ARE_EQUAL(L""M"", std::wstring_view{ text }",9,<empty>,,1485,215,CPPASTProblemDeclaration,,<empty>
476729,UNKNOWN,216,,);,57,<empty>,,1485,216,CPPASTProblemDeclaration,,<empty>
476730,UNKNOWN,217,,},5,<empty>,,1486,217,CPPASTProblemDeclaration,,<empty>
476731,UNKNOWN,218,,"TEST_METHOD(ScrollIntoView)
    {
        const auto viewportSize{ _pUiaData->GetViewport() };",5,<empty>,,1488,218,CPPASTProblemDeclaration,,<empty>
476816,UNKNOWN,221,,"BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:alignToTop"", L""{false, true}"")
        END_TEST_METHOD_PROPERTIES();",9,<empty>,,1506,221,CPPASTProblemDeclaration,,<empty>
476818,UNKNOWN,223,,"VERIFY_SUCCEEDED(TestData::TryGetValue(L""alignToTop"", alignToTop), L""Get alignToTop variant"");",9,<empty>,,1511,223,CPPASTProblemDeclaration,,<empty>
476820,UNKNOWN,225,,"for (const auto test : testData)
        {
            Log::Comment(test.comment.c_str());
            const til::point pos{ bufferSize.left, test.yPos };
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, pos, pos));
            VERIFY_SUCCEEDED(utr->ScrollIntoView(alignToTop));
        }",9,<empty>,,1514,225,CPPASTProblemDeclaration,,<empty>
476821,UNKNOWN,226,,},5,<empty>,,1521,226,CPPASTProblemDeclaration,,<empty>
476822,UNKNOWN,227,,"TEST_METHOD(GetAttributeValue)
    {
        Log::Comment(L""Check supported attributes"");",5,<empty>,,1523,227,CPPASTProblemDeclaration,,<empty>
476825,UNKNOWN,230,,for (auto uiaAttributeId = UIA_AnimationStyleAttributeId;,9,<empty>,,1532,230,CPPASTProblemDeclaration,,<empty>
476826,UNKNOWN,231,,uiaAttributeId <= UIA_AfterParagraphSpacingAttributeId;,67,<empty>,,1532,231,CPPASTProblemDeclaration,,<empty>
476827,UNKNOWN,232,,"++uiaAttributeId)
        {
            Microsoft::WRL::ComPtr<UiaTextRange> utr;
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider));
            THROW_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit_Character));

            Log::Comment(NoThrowString().Format(L""Attribute ID: %d"", uiaAttributeId));
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(uiaAttributeId, &result));

            switch (uiaAttributeId)
            {
            case UIA_FontNameAttributeId:
            {
                VERIFY_ARE_EQUAL(VT_BSTR, result.vt);
                break;
            }
            case UIA_BackgroundColorAttributeId:
            case UIA_FontWeightAttributeId:
            case UIA_ForegroundColorAttributeId:
            case UIA_StrikethroughStyleAttributeId:
            case UIA_UnderlineStyleAttributeId:
            {
                VERIFY_ARE_EQUAL(VT_I4, result.vt);
                break;
  ...",123,<empty>,,1532,232,CPPASTProblemDeclaration,,<empty>
476834,UNKNOWN,237,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider));",9,<empty>,,1583,237,CPPASTProblemDeclaration,,<empty>
476835,UNKNOWN,238,,THROW_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit_Character));,9,<empty>,,1584,238,CPPASTProblemDeclaration,,<empty>
476836,UNKNOWN,239,,"{
            Log::Comment(L""Test Background"");
            const auto rawBackgroundColor{ RGB(255, 0, 0) };
            attr.SetBackground(rawBackgroundColor);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_BackgroundColorAttributeId, &result));

            const auto realBackgroundColor{ _pUiaData->GetAttributeColors(attr).second & 0x00ffffff };
            VERIFY_ARE_EQUAL(realBackgroundColor, static_cast<COLORREF>(result.lVal));
        }",9,<empty>,,1585,239,CPPASTProblemDeclaration,,<empty>
476837,UNKNOWN,240,,"{
            Log::Comment(L""Test Font Weight"");
            attr.SetIntense(true);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_FontWeightAttributeId, &result));
            VERIFY_ARE_EQUAL(FW_BOLD, result.lVal);

            attr.SetIntense(false);
            updateBuffer(attr);
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_FontWeightAttributeId, &result));
            VERIFY_ARE_EQUAL(FW_NORMAL, result.lVal);
            ;
        }",9,<empty>,,1596,240,CPPASTProblemDeclaration,,<empty>
476838,UNKNOWN,241,,"{
            Log::Comment(L""Test Foreground"");
            const auto rawForegroundColor{ RGB(255, 0, 0) };
            attr.SetForeground(rawForegroundColor);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_ForegroundColorAttributeId, &result));

            const auto realForegroundColor{ _pUiaData->GetAttributeColors(attr).first & 0x00ffffff };
            VERIFY_ARE_EQUAL(realForegroundColor, static_cast<COLORREF>(result.lVal));
        }",9,<empty>,,1610,241,CPPASTProblemDeclaration,,<empty>
476839,UNKNOWN,242,,"{
            Log::Comment(L""Test Italic"");
            attr.SetItalic(true);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_IsItalicAttributeId, &result));
            VERIFY_IS_TRUE(result.boolVal);

            attr.SetItalic(false);
            updateBuffer(attr);
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_IsItalicAttributeId, &result));
            VERIFY_IS_FALSE(result.boolVal);
        }",9,<empty>,,1621,242,CPPASTProblemDeclaration,,<empty>
476840,UNKNOWN,243,,"{
            Log::Comment(L""Test Strikethrough"");
            attr.SetCrossedOut(true);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_StrikethroughStyleAttributeId, &result));
            VERIFY_ARE_EQUAL(TextDecorationLineStyle_Single, result.lVal);

            attr.SetCrossedOut(false);
            updateBuffer(attr);
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_StrikethroughStyleAttributeId, &result));
            VERIFY_ARE_EQUAL(TextDecorationLineStyle_None, result.lVal);
        }",9,<empty>,,1634,243,CPPASTProblemDeclaration,,<empty>
476841,UNKNOWN,244,,"{
            Log::Comment(L""Test Underline"");

            // Single underline
            attr.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);
            updateBuffer(attr);
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_UnderlineStyleAttributeId, &result));
            VERIFY_ARE_EQUAL(TextDecorationLineStyle_Single, result.lVal);

            // Double underline (new style supersedes the old one)
            attr.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);
            updateBuffer(attr);
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_UnderlineStyleAttributeId, &result));
            VERIFY_ARE_EQUAL(TextDecorationLineStyle_Double, result.lVal);

            // No underline
            attr.SetUnderlineStyle(UnderlineStyle::NoUnderline);
            updateBuffer(attr);
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_UnderlineStyleAttributeId, &result));
            VERIFY_ARE_EQUAL(TextDecorationLineStyle_None, ...",9,<empty>,,1647,244,CPPASTProblemDeclaration,,<empty>
476842,UNKNOWN,245,,"{
            Log::Comment(L""Test Font Name (special)"");
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_FontNameAttributeId, &result));
            const std::wstring actualFontName{ result.bstrVal };
            const auto expectedFontName{ _pUiaData->GetFontInfo().GetFaceName() };
            VERIFY_ARE_EQUAL(expectedFontName, actualFontName);
        }",9,<empty>,,1669,245,CPPASTProblemDeclaration,,<empty>
476843,UNKNOWN,246,,"{
            Log::Comment(L""Test Read Only (special)"");
            VARIANT result;
            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_IsReadOnlyAttributeId, &result));
            VERIFY_IS_FALSE(result.boolVal);
        }",9,<empty>,,1677,246,CPPASTProblemDeclaration,,<empty>
476844,UNKNOWN,247,,"{
            // ""Mixed"" is when the desired attribute value is inconsistent across the range.
            // We'll make our life easier by setting an attribute on a character,
            // but getting the attribute for the entire line.
            Log::Comment(L""Test Mixed"");
            VARIANT result;
            THROW_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit_Line));

            // set first cell as underlined, but second cell as not underlined
            attr.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);
            _pTextBuffer->Write({ attr }, { 0, 0 });
            attr.SetUnderlineStyle(UnderlineStyle::NoUnderline);
            _pTextBuffer->Write({ attr }, { 1, 0 });

            VERIFY_SUCCEEDED(utr->GetAttributeValue(UIA_UnderlineStyleAttributeId, &result));

            // Expected: mixed
            Microsoft::WRL::ComPtr<IUnknown> mixedVal;
            THROW_IF_FAILED(UiaGetReservedMixedAttributeValue(&mixedVal));
            VERIFY_ARE_EQUAL(VT_UNKNOWN...",9,<empty>,,1683,247,CPPASTProblemDeclaration,,<empty>
476845,UNKNOWN,248,,},5,<empty>,,1705,248,CPPASTProblemDeclaration,,<empty>
476846,UNKNOWN,249,,"TEST_METHOD(FindAttribute)
    {
        Microsoft::WRL::ComPtr<UiaTextRange> utr;",5,<empty>,,1707,249,CPPASTProblemDeclaration,,<empty>
476859,UNKNOWN,254,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, startPos, endPos));",9,<empty>,,1712,254,CPPASTProblemDeclaration,,<empty>
476860,UNKNOWN,255,,"{
            Log::Comment(L""Test Font Name (special)"");

            // Populate query with font name currently in use.
            const auto fontName{ _pUiaData->GetFontInfo().GetFaceName() };
            VARIANT var{};
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(fontName.data());

            Microsoft::WRL::ComPtr<ITextRangeProvider> result;
            VERIFY_SUCCEEDED(utr->FindAttribute(UIA_FontNameAttributeId, var, false, result.GetAddressOf()));

            // Expecting the same text range endpoints
            BOOL isEqual;
            THROW_IF_FAILED(utr->Compare(result.Get(), &isEqual));
            VERIFY_IS_TRUE(isEqual);

            // Now perform the same test, but searching backwards
            Log::Comment(L""Test Font Name (special) - Backwards"");
            Microsoft::WRL::ComPtr<ITextRangeProvider> resultBackwards;
            VERIFY_SUCCEEDED(utr->FindAttribute(UIA_FontNameAttributeId, var, true, resultBackwards.GetAddressOf()));

...",9,<empty>,,1713,255,CPPASTProblemDeclaration,,<empty>
476861,UNKNOWN,256,,"{
            Log::Comment(L""Test Read Only (special)"");

            VARIANT var{};
            var.vt = VT_BOOL;
            var.boolVal = false;

            Microsoft::WRL::ComPtr<ITextRangeProvider> result;
            VERIFY_SUCCEEDED(utr->FindAttribute(UIA_IsReadOnlyAttributeId, var, false, result.GetAddressOf()));

            // Expecting the same text range endpoints
            BOOL isEqual;
            THROW_IF_FAILED(utr->Compare(result.Get(), &isEqual));
            VERIFY_IS_TRUE(isEqual);

            // Now perform the same test, but searching backwards
            Log::Comment(L""Test Read Only (special) - Backwards"");
            Microsoft::WRL::ComPtr<ITextRangeProvider> resultBackwards;
            VERIFY_SUCCEEDED(utr->FindAttribute(UIA_IsReadOnlyAttributeId, var, true, resultBackwards.GetAddressOf()));

            // Expecting the same text range endpoints
            THROW_IF_FAILED(result->Compare(resultBackwards.Get(), &isEqual));
            VERIFY_IS_TRUE...",9,<empty>,,1739,256,CPPASTProblemDeclaration,,<empty>
476862,UNKNOWN,257,,"{
            Log::Comment(L""Test IsItalic (standard attribute)"");

            // Since all of the other attributes operate very similarly,
            //  we're just going to pick one of them and test that.
            // The ""GetAttribute"" tests provide code coverage for
            //  retrieving an attribute verification function.
            // This test is intended to provide code coverage for
            //  finding a text range with the desired attribute.

            // Set up the buffer's attributes.
            TextAttribute italicAttr;
            italicAttr.SetItalic(true);
            auto iter{ _pUiaData->GetTextBuffer().GetCellDataAt(startPos) };
            for (auto i = 0; i < 5; ++i)
            {
                _pTextBuffer->Write({ L""X"", italicAttr }, iter.Pos());
                ++iter;
            }

            // set the expected end (exclusive)
            const auto expectedEndPos{ iter.Pos() };

            VARIANT var{};
            var.vt = VT_BOOL;
 ...",9,<empty>,,1763,257,CPPASTProblemDeclaration,,<empty>
476863,UNKNOWN,258,,},5,<empty>,,1808,258,CPPASTProblemDeclaration,,<empty>
476864,UNKNOWN,259,,"TEST_METHOD(BlockRange)
    {
        // This test replicates GH#7960.
        // It was caused by _blockRange being uninitialized, resulting in it occasionally being set to true.
        // Additionally, all of the ctors _except_ the copy ctor initialized it. So this would be more apparent
        // when calling Clone.
        Microsoft::WRL::ComPtr<UiaTextRange> utr;",5,<empty>,,1810,259,CPPASTProblemDeclaration,,<empty>
476865,UNKNOWN,260,,"THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider));",9,<empty>,,1817,260,CPPASTProblemDeclaration,,<empty>
476866,UNKNOWN,261,,VERIFY_IS_FALSE(utr->_blockRange);,9,<empty>,,1818,261,CPPASTProblemDeclaration,,<empty>
476868,UNKNOWN,263,,THROW_IF_FAILED(utr->Clone(&clone1));,9,<empty>,,1821,263,CPPASTProblemDeclaration,,<empty>
476873,UNKNOWN,1,,UiaTextRange*,38,<empty>,,1823,1,CPPASTTypeId,,<empty>
476878,UNKNOWN,266,,VERIFY_IS_FALSE(cloneUtr1->_blockRange);,9,<empty>,,1824,266,CPPASTProblemDeclaration,,<empty>
476879,UNKNOWN,267,,cloneUtr1->_blockRange = true;,9,<empty>,,1825,267,CPPASTProblemDeclaration,,<empty>
476881,UNKNOWN,269,,cloneUtr1->Clone(&clone2);,9,<empty>,,1828,269,CPPASTProblemDeclaration,,<empty>
476886,UNKNOWN,1,,UiaTextRange*,38,<empty>,,1829,1,CPPASTTypeId,,<empty>
476891,UNKNOWN,272,,VERIFY_IS_TRUE(cloneUtr2->_blockRange);,9,<empty>,,1830,272,CPPASTProblemDeclaration,,<empty>
476892,UNKNOWN,273,,},5,<empty>,,1831,273,CPPASTProblemDeclaration,,<empty>
476893,UNKNOWN,274,,"TEST_METHOD(Movement)
    {
        // Helpful variables
        const auto firstChar{ point_offset_by_char(origin, bufferSize, 1) };",5,<empty>,,1833,274,CPPASTProblemDeclaration,,<empty>
476933,UNKNOWN,283,,"{
            auto i = 0;
            auto iter{ _pTextBuffer->GetCellDataAt(origin) };
            const auto segment{ bufferSize.width() / 5 };
            while (iter.Pos() != documentEnd)
            {
                auto fill{ true };
                if (i % segment == 0)
                {
                    fill = !fill;
                }

                if (fill)
                {
                    _pTextBuffer->Write({ L""X"" }, iter.Pos());
                }

                ++i;
                ++iter;
            }
        }",9,<empty>,,1850,283,CPPASTProblemDeclaration,,<empty>
476966,UNKNOWN,289,,},5,<empty>,,1898,289,CPPASTProblemDeclaration,,<empty>
476967,UNKNOWN,290,,"TEST_METHOD(GeneratedMovementTests)
    {
        // Populate the buffer with...
        // - 10 segments of alternating text
        // - up to half of the buffer (vertically)
        // It'll look something like this
        // +------------------------------+
        // |XXX   XXX   XXX   XXX   XXX   |
        // |XXX   XXX   XXX   XXX   XXX   |
        // |XXX   XXX   XXX   XXX   XXX   |
        // |XXX   XXX   XXX   XXX   XXX   |
        // |XXX   XXX   XXX   XXX   XXX   |
        // |                              |
        // |                              |
        // |                              |
        // |                              |
        // |                              |
        // +------------------------------+
        {
            auto i = 0;",5,<empty>,,1900,290,CPPASTProblemDeclaration,,<empty>
476995,UNKNOWN,297,,"while (iter.Pos() != docEnd)
            {
                if (iter.Pos().x == bufferSize.left)
                {
                    fill = true;
                }
                else if (i % segment == 0)
                {
                    fill = !fill;
                }

                _pTextBuffer->Write({ fill ? L""X"" : L"" "" }, iter.Pos());

                ++i;
                ++iter;
            }",13,<empty>,,1923,297,CPPASTProblemDeclaration,,<empty>
476996,UNKNOWN,298,,},9,<empty>,,1939,298,CPPASTProblemDeclaration,,<empty>
476997,UNKNOWN,299,,"BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""DataSource"", L""Export:GeneratedMovementTestDataSource"")
        END_TEST_METHOD_PROPERTIES()

        WEX::TestExecution::DisableVerifyExceptions disableVerifyExceptions{};",9,<empty>,,1941,299,CPPASTProblemDeclaration,,<empty>
477013,UNKNOWN,304,,"TestData::TryGetValue(L""index"", i);",9,<empty>,,1949,304,CPPASTProblemDeclaration,,<empty>
477021,UNKNOWN,307,,"Log::Comment(NoThrowString().Format(L""[%zu.0] Test case \""%.*s\"""", i, testCase.name.size(), testCase.name.data()));",9,<empty>,,1952,307,CPPASTProblemDeclaration,,<empty>
477022,UNKNOWN,308,,"if (testCase.skip)
        {
            Log::Result(WEX::Logging::TestResults::Result::Skipped);
        }",9,<empty>,,1953,308,CPPASTProblemDeclaration,,<empty>
477023,UNKNOWN,309,,"else
        {
            Microsoft::WRL::ComPtr<UiaTextRange> utr;
            int amountMoved;
            THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, testCase.input.start, testCase.input.end));
            THROW_IF_FAILED(utr->Move(testCase.input.unit, testCase.input.moveAmount, &amountMoved));

            VERIFY_ARE_EQUAL(testCase.expected.moveAmount, amountMoved);
            VERIFY_ARE_EQUAL(testCase.expected.start, utr->_start);
            VERIFY_ARE_EQUAL(testCase.expected.end, utr->_end);
        }",9,<empty>,,1957,309,CPPASTProblemDeclaration,,<empty>
477024,UNKNOWN,310,,},5,<empty>,,1968,310,CPPASTProblemDeclaration,,<empty>
477025,UNKNOWN,311,,};,1,<empty>,,1969,311,CPPASTProblemDeclaration,,<empty>
477089,UNKNOWN,1,,void*,17,<empty>,,63,1,CPPASTTypeId,,<empty>
477096,UNKNOWN,1,,void*,17,<empty>,,64,1,CPPASTTypeId,,<empty>
477103,UNKNOWN,1,,void*,17,<empty>,,65,1,CPPASTTypeId,,<empty>
477116,UNKNOWN,5,,"[[nodiscard]] NTSTATUS Window::CreateInstance(_In_ Settings* const pSettings,
                                              _In_ SCREEN_INFORMATION* const pScreen)
{
    auto status = s_RegisterWindowClass();

    if (SUCCEEDED_NTSTATUS(status))
    {
        auto pNewWindow = new (std::nothrow) Window();

        status = NT_TESTNULL(pNewWindow);

        if (SUCCEEDED_NTSTATUS(status))
        {
            status = pNewWindow->_MakeWindow(pSettings, pScreen);

            if (SUCCEEDED_NTSTATUS(status))
            {
                LOG_IF_FAILED(ServiceLocator::SetConsoleWindowInstance(pNewWindow));
            }
        }
    }

    return status;
}",1,<empty>,,90,5,CPPASTProblemDeclaration,,<empty>
477322,UNKNOWN,8,,"[[nodiscard]] NTSTATUS Window::_MakeWindow(_In_ Settings* const pSettings,
                                           _In_ SCREEN_INFORMATION* const pScreen)
{
    auto& g = ServiceLocator::LocateGlobals();
    auto& gci = g.getConsoleInformation();
    auto status = STATUS_SUCCESS;

    if (pSettings == nullptr)
    {
        status = STATUS_INVALID_PARAMETER_1;
    }
    else if (pScreen == nullptr)
    {
        status = STATUS_INVALID_PARAMETER_2;
    }

    // Ensure we have appropriate system metrics before we start constructing the window.
    _UpdateSystemMetrics();

    const auto useDx = pSettings->GetUseDx();
    try
    {
        switch (useDx)
        {
#if TIL_FEATURE_CONHOSTDXENGINE_ENABLED
        case UseDx::DxEngine:
            pDxEngine = new DxEngine();
            // TODO: MSFT:21255595 make this less gross
            // Manually set the Dx Engine to Hwnd mode. When we're trying to
            // determine the initial window size, which happens BEFORE the
    ...",1,<empty>,,199,8,CPPASTProblemDeclaration,,<empty>
477561,UNKNOWN,13,,"void Window::UpdateWindowPosition(_In_ const til::point ptNewPos) const
{
    SetWindowPos(GetWindowHandle(),
                 nullptr,
                 ptNewPos.x,
                 ptNewPos.y,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER);
}",1,<empty>,,512,13,CPPASTProblemDeclaration,,<empty>
478407,UNKNOWN,-1,,O,14,<empty>,,891,3,CPPASTProblemStatement,,<empty>
478419,UNKNOWN,1,,UINT,30,<empty>,,893,1,CPPASTTypeId,,<empty>
478498,UNKNOWN,22,,"void Window::s_ConvertWindowPosToWindowRect(const LPWINDOWPOS lpWindowPos, _Out_ til::rect* prc)
{
    prc->left = lpWindowPos->x;
    prc->top = lpWindowPos->y;
    prc->right = lpWindowPos->x + lpWindowPos->cx;
    prc->bottom = lpWindowPos->y + lpWindowPos->cy;
}",1,<empty>,,914,22,CPPASTProblemDeclaration,,<empty>
478499,UNKNOWN,23,,"void Window::_CalculateWindowRect(const til::size coordWindowInChars, _Inout_ til::rect* prectWindow) const
{
    auto& g = ServiceLocator::LocateGlobals();
    const auto& siAttached = GetScreenInfo();
    const auto coordFontSize = siAttached.GetScreenFontSize();
    const auto hWnd = GetWindowHandle();
    const auto coordBufferSize = siAttached.GetBufferSize().Dimensions();
    const auto iDpi = g.dpi;

    s_CalculateWindowRect(coordWindowInChars, iDpi, coordFontSize, coordBufferSize, hWnd, prectWindow);
}",1,<empty>,,929,23,CPPASTProblemDeclaration,,<empty>
478500,UNKNOWN,24,,"void Window::s_CalculateWindowRect(const til::size coordWindowInChars,
                                   const int iDpi,
                                   const til::size coordFontSize,
                                   const til::size coordBufferSize,
                                   _In_opt_ HWND const hWnd,
                                   _Inout_ til::rect* const prectWindow)
{
    til::size sizeWindow;

    // Initially use the given size in characters * font size to get client area pixel size
    sizeWindow.width = coordWindowInChars.width * coordFontSize.width;
    sizeWindow.height = coordWindowInChars.height * coordFontSize.height;

    // Create a proposed rectangle
    til::rect rectProposed = { prectWindow->left, prectWindow->top, prectWindow->left + sizeWindow.width, prectWindow->top + sizeWindow.height };

    // Now adjust the client area into a window size
    // 1. Start with default window style
    DWORD dwStyle = CONSOLE_WINDOW_FLAGS;
    DWORD dwExStyle =...",1,<empty>,,957,24,CPPASTProblemDeclaration,,<empty>
478630,UNKNOWN,1,,BYTE,23,<empty>,,1102,1,CPPASTTypeId,,<empty>
479031,UNKNOWN,40,,"[[nodiscard]] LRESULT Window::s_RegPersistWindowPos(_In_ PCWSTR const pwszTitle,
                                                    const BOOL fAutoPos,
                                                    const Window* const pWindow)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    HKEY hCurrentUserKey, hConsoleKey, hTitleKey;
    // Open the current user registry key.
    auto Status = RegistrySerialization::s_OpenCurrentUserConsoleTitleKey(pwszTitle, &hCurrentUserKey, &hConsoleKey, &hTitleKey);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        // Save window size
        auto windowRect = pWindow->GetWindowRect();
        const auto windowDimensions = gci.GetActiveOutputBuffer().GetViewport().Dimensions();
        DWORD dwValue = MAKELONG(windowDimensions.width, windowDimensions.height);
        Status = RegistrySerialization::s_UpdateValue(hConsoleKey,
                                                      hTitleKey,
                           ...",1,<empty>,,1275,40,CPPASTProblemDeclaration,,<empty>
479032,UNKNOWN,41,,"[[nodiscard]] LRESULT Window::s_RegPersistWindowOpacity(_In_ PCWSTR const pwszTitle, const Window* const pWindow)
{
    HKEY hCurrentUserKey, hConsoleKey, hTitleKey;

    // Open the current user registry key.
    auto Status = RegistrySerialization::s_OpenCurrentUserConsoleTitleKey(pwszTitle, &hCurrentUserKey, &hConsoleKey, &hTitleKey);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        // Save window opacity
        DWORD dwValue;
        dwValue = pWindow->GetWindowOpacity();
        Status = RegistrySerialization::s_UpdateValue(hConsoleKey,
                                                      hTitleKey,
                                                      CONSOLE_REGISTRY_WINDOWALPHA,
                                                      REG_DWORD,
                                                      reinterpret_cast<BYTE*>(&dwValue),
                                                      static_cast<DWORD>(sizeof(dwValue)));

        if (hTitleKey != hConsoleKey)
        {
   ...",1,<empty>,,1339,41,CPPASTProblemDeclaration,,<empty>
479059,UNKNOWN,43,,"[[nodiscard]] HRESULT Window::SignalUia(_In_ EVENTID id)
{
    if (_pUiaProvider != nullptr)
    {
        return _pUiaProvider->Signal(id);
    }
    return S_FALSE;
}",1,<empty>,,1383,43,CPPASTProblemDeclaration,,<empty>
479085,UNKNOWN,46,,"BOOL Window::GetCursorPosition(_Out_ til::point* lpPoint)
{
    return GetCursorPos(lpPoint->as_win32_point());
}",1,<empty>,,1407,46,CPPASTProblemDeclaration,,<empty>
479086,UNKNOWN,47,,"BOOL Window::GetClientRectangle(_Out_ til::rect* lpRect)
{
    return GetClientRect(_hWnd, lpRect->as_win32_rect());
}",1,<empty>,,1412,47,CPPASTProblemDeclaration,,<empty>
479087,UNKNOWN,48,,"BOOL Window::MapRect(_Inout_ til::rect* lpRect)
{
    return MapWindowPoints(_hWnd, nullptr, lpRect->as_win32_points(), 2) != 0;
}",1,<empty>,,1417,48,CPPASTProblemDeclaration,,<empty>
479088,UNKNOWN,49,,"BOOL Window::ConvertScreenToClient(_Inout_ til::point* lpPoint)
{
    return ScreenToClient(_hWnd, lpPoint->as_win32_point());
}",1,<empty>,,1422,49,CPPASTProblemDeclaration,,<empty>
479113,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS CreateInstance(_In_ Settings* const pSettings,
                                                     _In_ SCREEN_INFORMATION* const pScreen);",9,<empty>,,38,1,CPPASTProblemDeclaration,,<empty>
479197,UNKNOWN,-1,,void UpdateWindowPosition(_In_ const til::point ptNewPos) const;,9,<empty>,,71,20,CPPASTProblemDeclaration,,<empty>
479226,UNKNOWN,-1,,[[nodiscard]] HRESULT SignalUia(_In_ EVENTID id);,9,<empty>,,86,28,CPPASTProblemDeclaration,,<empty>
479231,UNKNOWN,-1,,BOOL GetCursorPosition(_Out_ til::point* lpPoint);,9,<empty>,,89,30,CPPASTProblemDeclaration,,<empty>
479232,UNKNOWN,-1,,BOOL GetClientRectangle(_Out_ til::rect* lpRect);,9,<empty>,,90,31,CPPASTProblemDeclaration,,<empty>
479233,UNKNOWN,-1,,BOOL MapRect(_Inout_ til::rect* lpRect);,9,<empty>,,91,32,CPPASTProblemDeclaration,,<empty>
479234,UNKNOWN,-1,,BOOL ConvertScreenToClient(_Inout_ til::point* lpPoint);,9,<empty>,,92,33,CPPASTProblemDeclaration,,<empty>
479257,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS _MakeWindow(_In_ Settings* const pSettings,
                                           _In_ SCREEN_INFORMATION* const pScreen);",9,<empty>,,106,39,CPPASTProblemDeclaration,,<empty>
479281,UNKNOWN,-1,,"[[nodiscard]] static LRESULT CALLBACK s_ConsoleWindowProc(_In_ HWND hwnd,
                                                                  _In_ UINT uMsg,
                                                                  _In_ WPARAM wParam,
                                                                  _In_ LPARAM lParam);",9,<empty>,,129,50,CPPASTProblemDeclaration,,<empty>
479282,UNKNOWN,-1,,"[[nodiscard]] LRESULT CALLBACK ConsoleWindowProc(_In_ HWND,
                                                         _In_ UINT uMsg,
                                                         _In_ WPARAM wParam,
                                                         _In_ LPARAM lParam);",9,<empty>,,133,51,CPPASTProblemDeclaration,,<empty>
479309,UNKNOWN,-1,,"[[nodiscard]] static LRESULT s_RegPersistWindowPos(_In_ PCWSTR const pwszTitle,
                                                           const BOOL fAutoPos,
                                                           const Window* const pWindow);",9,<empty>,,151,58,CPPASTProblemDeclaration,,<empty>
479310,UNKNOWN,-1,,"[[nodiscard]] static LRESULT s_RegPersistWindowOpacity(_In_ PCWSTR const pwszTitle,
                                                               const Window* const pWindow);",9,<empty>,,154,59,CPPASTProblemDeclaration,,<empty>
479328,UNKNOWN,-1,,"void _CalculateWindowRect(const til::size coordWindowInChars,
                                  _Inout_ til::rect* const prectWindow) const;",9,<empty>,,172,68,CPPASTProblemDeclaration,,<empty>
479329,UNKNOWN,-1,,"static void s_CalculateWindowRect(const til::size coordWindowInChars,
                                          const int iDpi,
                                          const til::size coordFontSize,
                                          const til::size coordBufferSize,
                                          _In_opt_ HWND const hWnd,
                                          _Inout_ til::rect* const prectWindow);",9,<empty>,,174,69,CPPASTProblemDeclaration,,<empty>
479336,UNKNOWN,-1,,"static void s_ConvertWindowPosToWindowRect(const LPWINDOWPOS lpWindowPos,
                                                   _Out_ til::rect* const prc);",9,<empty>,,186,73,CPPASTProblemDeclaration,,<empty>
479373,UNKNOWN,1,,"HRESULT WindowUiaProvider::RuntimeClassInitialize(_In_ IConsoleWindow* baseWindow) noexcept
try
{
    _baseWindow = baseWindow;

    auto& g = ServiceLocator::LocateGlobals();
    auto& gci = g.getConsoleInformation();
    Render::IRenderData* renderData = &gci.renderData;

    RETURN_IF_FAILED(WRL::MakeAndInitialize<ScreenInfoUiaProvider>(&_pScreenInfoProvider, renderData, this));

    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    //Tracing::s_TraceUia(pWindowProvider, ApiCall::Create, nullptr);

    return S_OK;
}",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
479374,UNKNOWN,2,,CATCH_RETURN();,1,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
479375,UNKNOWN,3,,"[[nodiscard]] HRESULT WindowUiaProvider::Signal(_In_ EVENTID id)
{
    auto hr = S_OK;

    // ScreenInfoUiaProvider is responsible for signaling selection
    // changed events and text changed events
    if (id == UIA_Text_TextSelectionChangedEventId ||
        id == UIA_Text_TextChangedEventId)
    {
        if (_pScreenInfoProvider)
        {
            hr = _pScreenInfoProvider->Signal(id);
        }
        else
        {
            hr = E_POINTER;
        }
        return hr;
    }

    if (_signalEventFiring.find(id) != _signalEventFiring.end() &&
        _signalEventFiring[id] == true)
    {
        return hr;
    }

    try
    {
        _signalEventFiring[id] = true;
    }
    CATCH_RETURN();

    hr = UiaRaiseAutomationEvent(this, id);
    _signalEventFiring[id] = false;

    return hr;
}",1,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
479378,UNKNOWN,-1,,"try
    {
        return _pScreenInfoProvider->Signal(UIA_AutomationFocusChangedEventId);
    }
    CATCH_RETURN();",5,<empty>,,74,1,CPPASTProblemStatement,,<empty>
479381,UNKNOWN,5,,"IFACEMETHODIMP WindowUiaProvider::get_ProviderOptions(_Out_ ProviderOptions* pOptions)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pOptions);
    RETURN_IF_FAILED(_EnsureValidHwnd());

    *pOptions = ProviderOptions_ServerSideProvider;
    return S_OK;
}",1,<empty>,,85,5,CPPASTProblemDeclaration,,<empty>
479382,UNKNOWN,6,,"IFACEMETHODIMP WindowUiaProvider::GetPatternProvider(_In_ PATTERNID /*patternId*/,
                                                     _COM_Outptr_result_maybenull_ IUnknown** ppInterface)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppInterface);
    *ppInterface = nullptr;
    RETURN_IF_FAILED(_EnsureValidHwnd());

    return S_OK;
}",1,<empty>,,96,6,CPPASTProblemDeclaration,,<empty>
479383,UNKNOWN,7,,"IFACEMETHODIMP WindowUiaProvider::GetPropertyValue(_In_ PROPERTYID propertyId, _Out_ VARIANT* pVariant)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pVariant);
    RETURN_IF_FAILED(_EnsureValidHwnd());

    pVariant->vt = VT_EMPTY;

    // Returning the default will leave the property as the default
    // so we only really need to touch it for the properties we want to implement
    if (propertyId == UIA_ControlTypePropertyId)
    {
        pVariant->vt = VT_I4;
        pVariant->lVal = UIA_WindowControlTypeId;
    }
    else if (propertyId == UIA_AutomationIdPropertyId)
    {
        pVariant->bstrVal = SysAllocString(AutomationIdPropertyName);
        if (pVariant->bstrVal != nullptr)
        {
            pVariant->vt = VT_BSTR;
        }
    }
    else if (propertyId == UIA_IsControlElementPropertyId)
    {
        pVariant->vt = VT_BOOL;
        pVariant->boolVal = VARIANT_TRUE;
    }
    else if (propertyId == UIA_IsContentElementPropertyId)
    {
        pVariant->vt = VT_BOOL;
   ...",1,<empty>,,108,7,CPPASTProblemDeclaration,,<empty>
479384,UNKNOWN,8,,"IFACEMETHODIMP WindowUiaProvider::get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppProvider);
    try
    {
        const auto hwnd = GetWindowHandle();
        return UiaHostProviderFromHwnd(hwnd, ppProvider);
    }
    catch (...)
    {
        return gsl::narrow_cast<HRESULT>(UIA_E_ELEMENTNOTAVAILABLE);
    }
}",1,<empty>,,165,8,CPPASTProblemDeclaration,,<empty>
479385,UNKNOWN,9,,"IFACEMETHODIMP WindowUiaProvider::Navigate(_In_ NavigateDirection direction, _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider)
{
    RETURN_IF_FAILED(_EnsureValidHwnd());
    *ppProvider = nullptr;
    auto hr = S_OK;

    if (direction == NavigateDirection_FirstChild || direction == NavigateDirection_LastChild)
    {
        RETURN_IF_FAILED(_pScreenInfoProvider.CopyTo(ppProvider));

        // signal that the focus changed
        LOG_IF_FAILED(_pScreenInfoProvider->Signal(UIA_AutomationFocusChangedEventId));
    }

    // For the other directions (parent, next, previous) the default of nullptr is correct
    return hr;
}",1,<empty>,,182,9,CPPASTProblemDeclaration,,<empty>
479386,UNKNOWN,10,,"IFACEMETHODIMP WindowUiaProvider::GetRuntimeId(_Outptr_result_maybenull_ SAFEARRAY** ppRuntimeId)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRuntimeId);
    RETURN_IF_FAILED(_EnsureValidHwnd());
    // Root defers this to host, others must implement it...
    *ppRuntimeId = nullptr;

    return S_OK;
}",1,<empty>,,200,10,CPPASTProblemDeclaration,,<empty>
479387,UNKNOWN,11,,"IFACEMETHODIMP WindowUiaProvider::get_BoundingRectangle(_Out_ UiaRect* pRect)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pRect);
    RETURN_IF_FAILED(_EnsureValidHwnd());

    RETURN_HR_IF_NULL((HRESULT)UIA_E_ELEMENTNOTAVAILABLE, _baseWindow);

    const auto rc = _baseWindow->GetWindowRect();

    pRect->left = rc.left;
    pRect->top = rc.top;

    LONG longWidth = 0;
    RETURN_IF_FAILED(LongSub(rc.right, rc.left, &longWidth));
    pRect->width = longWidth;
    LONG longHeight = 0;
    RETURN_IF_FAILED(LongSub(rc.bottom, rc.top, &longHeight));
    pRect->height = longHeight;

    return S_OK;
}",1,<empty>,,210,11,CPPASTProblemDeclaration,,<empty>
479388,UNKNOWN,12,,"IFACEMETHODIMP WindowUiaProvider::GetEmbeddedFragmentRoots(_Outptr_result_maybenull_ SAFEARRAY** ppRoots)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRoots);
    RETURN_IF_FAILED(_EnsureValidHwnd());

    *ppRoots = nullptr;
    return S_OK;
}",1,<empty>,,232,12,CPPASTProblemDeclaration,,<empty>
479398,UNKNOWN,14,,"IFACEMETHODIMP WindowUiaProvider::get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppProvider);
    RETURN_IF_FAILED(_EnsureValidHwnd());

    RETURN_IF_FAILED(QueryInterface(IID_PPV_ARGS(ppProvider)));
    return S_OK;
}",1,<empty>,,247,14,CPPASTProblemDeclaration,,<empty>
479399,UNKNOWN,15,,"IFACEMETHODIMP WindowUiaProvider::ElementProviderFromPoint(_In_ double /*x*/,
                                                           _In_ double /*y*/,
                                                           _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider)
{
    RETURN_IF_FAILED(_EnsureValidHwnd());

    RETURN_IF_FAILED(_pScreenInfoProvider.CopyTo(ppProvider));

    return S_OK;
}",1,<empty>,,260,15,CPPASTProblemDeclaration,,<empty>
479400,UNKNOWN,16,,"IFACEMETHODIMP WindowUiaProvider::GetFocus(_COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider)
{
    RETURN_IF_FAILED(_EnsureValidHwnd());
    return _pScreenInfoProvider->QueryInterface(IID_PPV_ARGS(ppProvider));
}",1,<empty>,,271,16,CPPASTProblemDeclaration,,<empty>
479419,UNKNOWN,-1,,"try
    {
        const auto hwnd = GetWindowHandle();
        RETURN_HR_IF((HRESULT)UIA_E_ELEMENTNOTAVAILABLE, !(IsWindow(hwnd)));
    }
    CATCH_RETURN();",5,<empty>,,293,1,CPPASTProblemStatement,,<empty>
479498,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT Signal(_In_ EVENTID id);,9,<empty>,,50,8,CPPASTProblemDeclaration,,<empty>
479503,UNKNOWN,-1,,IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) override;,9,<empty>,,54,10,CPPASTProblemDeclaration,,<empty>
479504,UNKNOWN,-1,,"IFACEMETHODIMP GetPatternProvider(_In_ PATTERNID iid,
                                          _COM_Outptr_result_maybenull_ IUnknown** ppInterface) override;",9,<empty>,,55,11,CPPASTProblemDeclaration,,<empty>
479505,UNKNOWN,-1,,"IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) override;",9,<empty>,,57,12,CPPASTProblemDeclaration,,<empty>
479506,UNKNOWN,-1,,IFACEMETHODIMP get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider) override;,9,<empty>,,59,13,CPPASTProblemDeclaration,,<empty>
479507,UNKNOWN,-1,,"virtual IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                        _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider);",9,<empty>,,62,14,CPPASTProblemDeclaration,,<empty>
479508,UNKNOWN,-1,,IFACEMETHODIMP GetRuntimeId(_Outptr_result_maybenull_ SAFEARRAY** ppRuntimeId) override;,9,<empty>,,64,15,CPPASTProblemDeclaration,,<empty>
479509,UNKNOWN,-1,,IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override;,9,<empty>,,65,16,CPPASTProblemDeclaration,,<empty>
479510,UNKNOWN,-1,,IFACEMETHODIMP GetEmbeddedFragmentRoots(_Outptr_result_maybenull_ SAFEARRAY** ppRoots) override;,9,<empty>,,66,17,CPPASTProblemDeclaration,,<empty>
479515,UNKNOWN,-1,,IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override;,9,<empty>,,68,19,CPPASTProblemDeclaration,,<empty>
479516,UNKNOWN,-1,,"virtual IFACEMETHODIMP ElementProviderFromPoint(_In_ double x,
                                                        _In_ double y,
                                                        _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider);",9,<empty>,,71,20,CPPASTProblemDeclaration,,<empty>
479517,UNKNOWN,-1,,virtual IFACEMETHODIMP GetFocus(_COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider);,9,<empty>,,74,21,CPPASTProblemDeclaration,,<empty>
479601,UNKNOWN,3,,"BOOL WindowDpiApi::SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext)
{
#ifdef CON_DPIAPI_INDIRECT
    if (_hUser32 != nullptr)
    {
        typedef int(WINAPI * PfnSetProcessDpiAwarenessContexts)(DPI_AWARENESS_CONTEXT dpiContext);

        static auto fTried = false;
        static PfnSetProcessDpiAwarenessContexts pfn = nullptr;

        if (!fTried)
        {
            pfn = (PfnSetProcessDpiAwarenessContexts)GetProcAddress(_hUser32, ""SetProcessDpiAwarenessContext"");
        }

        fTried = true;

        if (pfn != nullptr)
        {
            return pfn(dpiContext);
        }
    }

    return FALSE;
#else
    return SetProcessDpiAwarenessContext(dpiContext);
#endif
}",1,<empty>,,26,3,CPPASTProblemDeclaration,,<empty>
479602,UNKNOWN,4,,"BOOL WindowDpiApi::AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                            const DWORD dwStyle,
                                            const BOOL bMenu,
                                            const DWORD dwExStyle,
                                            const UINT dpi)
{
#ifdef CON_DPIAPI_INDIRECT
    if (_hUser32 != nullptr)
    {
        typedef BOOL(WINAPI * PfnAdjustWindowRectExForDpi)(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, int dpi);

        static auto fTried = false;
        static PfnAdjustWindowRectExForDpi pfn = nullptr;

        if (!fTried)
        {
            pfn = (PfnAdjustWindowRectExForDpi)GetProcAddress(_hUser32, ""AdjustWindowRectExForDpi"");

            fTried = true;
        }

        if (pfn != nullptr)
        {
            return pfn(lpRect, dwStyle, bMenu, dwExStyle, dpi);
        }
    }

    return AdjustWindowRectEx(lpRect, dwStyle, bMenu, dwExStyle);
#else
    return AdjustWin...",1,<empty>,,55,4,CPPASTProblemDeclaration,,<empty>
479611,UNKNOWN,-1,,typedef int(WINAPI * PfnGetDpiForWindow)(HWND hwnd);,9,<empty>,,93,1,CPPASTProblemStatement,,<empty>
479627,UNKNOWN,1,,PfnGetDpiForWindow,20,<empty>,,100,1,CPPASTTypeId,,<empty>
479655,UNKNOWN,-1,,"typedef int(WINAPI * PfnGetDpiMetrics)(int nIndex, int dpi);",9,<empty>,,122,1,CPPASTProblemStatement,,<empty>
479671,UNKNOWN,1,,PfnGetDpiMetrics,20,<empty>,,129,1,CPPASTTypeId,,<empty>
479760,UNKNOWN,-1,,BOOL SetProcessDpiAwarenessContext(_In_ DPI_AWARENESS_CONTEXT dpiContext);,9,<empty>,,56,3,CPPASTProblemDeclaration,,<empty>
479761,UNKNOWN,-1,,"BOOL AdjustWindowRectExForDpi(_Inout_ LPRECT const lpRect,
                                      const DWORD dwStyle,
                                      const BOOL bMenu,
                                      const DWORD dwExStyle,
                                      const UINT dpi);",9,<empty>,,57,4,CPPASTProblemDeclaration,,<empty>
479830,UNKNOWN,1,,"ULONG ConvertMouseButtonState(_In_ ULONG Flag, _In_ ULONG State)
{
    if (State & MK_LBUTTON)
    {
        Flag |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if (State & MK_MBUTTON)
    {
        Flag |= FROM_LEFT_2ND_BUTTON_PRESSED;
    }
    if (State & MK_RBUTTON)
    {
        Flag |= RIGHTMOST_BUTTON_PRESSED;
    }

    return Flag;
}",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
479831,UNKNOWN,2,,"VOID SetConsoleWindowOwner(const HWND hwnd, _Inout_opt_ ConsoleProcessHandle* pProcessData)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    FAIL_FAST_IF(!(gci.IsConsoleLocked()));

    DWORD dwProcessId;
    DWORD dwThreadId;
    if (nullptr != pProcessData)
    {
        dwProcessId = pProcessData->dwProcessId;
        dwThreadId = pProcessData->dwThreadId;
    }
    else
    {
        // Find a process to own the console window. If there are none then let's use conhost's.
        pProcessData = gci.ProcessHandleList.GetRootProcess();
        if (!pProcessData)
        {
            // No root process ID? Pick the oldest existing process.
            pProcessData = gci.ProcessHandleList.GetOldestProcess();
        }

        if (pProcessData != nullptr)
        {
            dwProcessId = pProcessData->dwProcessId;
            dwThreadId = pProcessData->dwThreadId;
            pProcessData->fRootProcess = true;
        }
        else
        {
 ...",1,<empty>,,62,2,CPPASTProblemDeclaration,,<empty>
479861,UNKNOWN,4,,"void HandleKeyEvent(const HWND hWnd,
                    const UINT Message,
                    const WPARAM wParam,
                    const LPARAM lParam,
                    _Inout_opt_ PBOOL pfUnlockConsole)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();

    // BOGUS for WM_CHAR/WM_DEADCHAR, in which LOWORD(wParam) is a character
    auto VirtualKeyCode = LOWORD(wParam);
    WORD VirtualScanCode = LOBYTE(HIWORD(lParam));
    const auto RepeatCount = LOWORD(lParam);
    auto ControlKeyState = GetControlKeyState(lParam);
    const BOOL bKeyDown = WI_IsFlagClear(lParam, KEY_TRANSITION_UP);
    const bool IsCharacterMessage = (Message == WM_CHAR || Message == WM_SYSCHAR || Message == WM_DEADCHAR || Message == WM_SYSDEADCHAR);

    if (bKeyDown)
    {
        // Log a telemetry flag saying the user interacted with the Console
        // Only log when the key is a down press.  Otherwise we're getting many calls with
        // Message = WM_CHAR, VirtualK...",1,<empty>,,122,4,CPPASTProblemDeclaration,,<empty>
479862,UNKNOWN,5,,"BOOL HandleSysKeyEvent(const HWND hWnd, const UINT Message, const WPARAM wParam, const LPARAM lParam, _Inout_opt_ PBOOL pfUnlockConsole)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    WORD VirtualKeyCode;

    if (Message == WM_SYSCHAR || Message == WM_SYSDEADCHAR)
    {
        VirtualKeyCode = (WORD)OneCoreSafeMapVirtualKeyW(LOBYTE(HIWORD(lParam)), MAPVK_VSC_TO_VK_EX);
    }
    else
    {
        VirtualKeyCode = LOWORD(wParam);
    }

    // Log a telemetry flag saying the user interacted with the Console
    Telemetry::Instance().SetUserInteractive();

    // check for ctrl-esc
    const auto bCtrlDown = OneCoreSafeGetKeyState(VK_CONTROL) & KEY_PRESSED;

    if (VirtualKeyCode == VK_ESCAPE &&
        bCtrlDown && !(OneCoreSafeGetKeyState(VK_MENU) & KEY_PRESSED) && !(OneCoreSafeGetKeyState(VK_SHIFT) & KEY_PRESSED))
    {
        return TRUE; // call DefWindowProc
    }

    // check for alt-f4
    if (VirtualKeyCode == VK_F4 && (OneCoreSafeG...",1,<empty>,,458,5,CPPASTProblemDeclaration,,<empty>
480752,UNKNOWN,1,,UINT,25,<empty>,,906,1,CPPASTTypeId,,<empty>
480765,UNKNOWN,1,,UINT,25,<empty>,,910,1,CPPASTTypeId,,<empty>
480800,UNKNOWN,1,,UINT,58,<empty>,,922,1,CPPASTTypeId,,<empty>
480816,UNKNOWN,8,,LRESULT,1,<empty>,,936,8,CPPASTProblemDeclaration,,<empty>
480827,UNKNOWN,1,,PMSG,19,<empty>,,938,1,CPPASTTypeId,,<empty>
480888,UNKNOWN,10,,"NTSTATUS InitWindowsSubsystem(_Out_ HHOOK* phhook)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    auto ProcessData = gci.ProcessHandleList.GetRootProcess();
    FAIL_FAST_IF(!(ProcessData != nullptr && ProcessData->fRootProcess));

    // Create and activate the main window
    auto Status = Window::CreateInstance(&gci, gci.ScreenBuffers);

    if (FAILED_NTSTATUS(Status))
    {
        RIPMSG2(RIP_WARNING, ""CreateWindowsWindow failed with status 0x%x, gle = 0x%x"", Status, GetLastError());
        return Status;
    }

    // We intentionally ignore the return value of SetWindowsHookEx. There are mixed LUID cases where this call will fail but in the past this call
    // was special cased (for CSRSS) to always succeed. Thus, we ignore failure for app compat (as not having the hook isn't fatal).
    *phhook = SetWindowsHookExW(WH_MSGFILTER, DialogHookProc, nullptr, GetCurrentThreadId());

    SetConsoleWindowOwner(ServiceLocator::LocateConsoleWindow()-...",1,<empty>,,960,10,CPPASTProblemDeclaration,,<empty>
480889,UNKNOWN,11,,DWORD,1,<empty>,,993,11,CPPASTProblemDeclaration,,<empty>
481063,UNKNOWN,1,,"void HandleKeyEvent(const HWND hWnd,
                    const UINT Message,
                    const WPARAM wParam,
                    const LPARAM lParam,
                    _Inout_opt_ PBOOL pfUnlockConsole);",1,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
481064,UNKNOWN,2,,"BOOL HandleSysKeyEvent(const HWND hWnd,
                       const UINT Message,
                       const WPARAM wParam,
                       const LPARAM lParam,
                       _Inout_opt_ PBOOL pfUnlockConsole);",1,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
481073,UNKNOWN,4,,"VOID SetConsoleWindowOwner(const HWND hwnd, _Inout_opt_ ConsoleProcessHandle* pProcessData);",1,<empty>,,27,4,CPPASTProblemDeclaration,,<empty>
481074,UNKNOWN,5,,DWORD,1,<empty>,,28,5,CPPASTProblemDeclaration,,<empty>
481135,UNKNOWN,1,,"[[nodiscard]] LRESULT CALLBACK Window::s_ConsoleWindowProc(_In_ HWND hWnd, _In_ UINT Message, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
    // Save the pointer here to the specific window instance when one is created
    if (Message == WM_CREATE)
    {
        const CREATESTRUCT* const pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);

        const auto pWindow = reinterpret_cast<Window*>(pCreateStruct->lpCreateParams);
        SetWindowLongPtrW(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pWindow));
    }

    // Dispatch the message to the specific class instance
    const auto pWindow = reinterpret_cast<Window*>(GetWindowLongPtrW(hWnd, GWLP_USERDATA));
    if (pWindow != nullptr)
    {
        return pWindow->ConsoleWindowProc(hWnd, Message, wParam, lParam);
    }

    // If we get this far, call the default window proc
    return DefWindowProcW(hWnd, Message, wParam, lParam);
}",1,<empty>,,43,1,CPPASTProblemDeclaration,,<empty>
481136,UNKNOWN,2,,"[[nodiscard]] LRESULT CALLBACK Window::ConsoleWindowProc(_In_ HWND hWnd, _In_ UINT Message, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
    auto& g = ServiceLocator::LocateGlobals();
    auto& gci = g.getConsoleInformation();
    LRESULT Status = 0;
    auto Unlock = TRUE;

    LockConsole();

    auto& ScreenInfo = GetScreenInfo();
    if (hWnd == nullptr) // TODO: this might not be possible anymore
    {
        if (Message == WM_CLOSE)
        {
            _CloseWindow();
            Status = 0;
        }
        else
        {
            Status = DefWindowProcW(hWnd, Message, wParam, lParam);
        }

        UnlockConsole();
        return Status;
    }

    switch (Message)
    {
    case WM_CREATE:
    {
        // Load all metrics we'll need.
        _UpdateSystemMetrics();

        // The system is not great and the window rect is wrong the first time for High DPI (WM_DPICHANGED scales strangely.)
        // So here we have to grab the DPI of the current window (now that ...",1,<empty>,,65,2,CPPASTProblemDeclaration,,<empty>
481152,UNKNOWN,1,,LPWINDOWPOS,31,<empty>,,792,1,CPPASTTypeId,,<empty>
481283,UNKNOWN,1,,HDROP,24,<empty>,,875,1,CPPASTTypeId,,<empty>
481353,UNKNOWN,1,,long,21,<empty>,,903,1,CPPASTTypeId,,<empty>
481356,UNKNOWN,1,,long,50,<empty>,,903,1,CPPASTTypeId,,<empty>
481648,UNKNOWN,3,,"[[nodiscard]] LRESULT CALLBACK SimpleColorControlProc(const HWND hColor, const UINT wMsg, const WPARAM wParam, const LPARAM lParam)
{
    PAINTSTRUCT ps;
    int ColorId;
    HWND hDlg;

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg)
    {
    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTTAB;
        break;
    case WM_PAINT:
        BeginPaint(hColor, &ps);
        SimpleColorDoPaint(hColor, ps, ColorId);
        EndPaint(hColor, &ps);
        break;
    default:
        return DefWindowProc(hColor, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}",1,<empty>,,46,3,CPPASTProblemDeclaration,,<empty>
481654,UNKNOWN,1,,"[[nodiscard]] LRESULT CALLBACK SimpleColorControlProc(HWND hColor, UINT wMsg, WPARAM wParam, LPARAM lParam);",1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
481677,UNKNOWN,4,,"[[nodiscard]] LRESULT CALLBACK ColorTableControlProc(HWND hColor, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rColor;
    RECT rTemp;
    HDC hdc;
    HWND hWnd;
    HWND hDlg;

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg)
    {
    case WM_SETFOCUS:
        if (ColorArray[iColor] != (BYTE)(ColorId - IDD_COLOR_1))
        {
            hWnd = GetDlgItem(hDlg, ColorArray[iColor] + IDD_COLOR_1);
            SetFocus(hWnd);
        }
        __fallthrough;
    case WM_KILLFOCUS:
        hdc = GetDC(hDlg);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_1);
        GetWindowRect(hWnd, &rColor);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_16);
        GetWindowRect(hWnd, &rTemp);
        rColor.right = rTemp.right;
        ScreenToClient(hDlg, (LPPOINT)&rColor.left);
        ScreenToClient(hDlg, (LPPOINT)&rColor.right);
        InflateRect(&rColor, 2, 2);
        DrawFocusRect(hdc, &rColor);
        Rel...",1,<empty>,,20,4,CPPASTProblemDeclaration,,<empty>
481908,UNKNOWN,1,,LPARAM,75,<empty>,,139,1,CPPASTTypeId,,<empty>
481918,UNKNOWN,6,,INT_PTR,1,<empty>,,148,6,CPPASTProblemDeclaration,,<empty>
482112,UNKNOWN,1,,HWND,27,<empty>,,212,1,CPPASTTypeId,,<empty>
482293,UNKNOWN,1,,LPPSHNOTIFY,40,<empty>,,277,1,CPPASTTypeId,,<empty>
482312,UNKNOWN,1,,BYTE,53,<empty>,,288,1,CPPASTTypeId,,<empty>
482383,UNKNOWN,1,,HWND,30,<empty>,,327,1,CPPASTTypeId,,<empty>
482404,UNKNOWN,1,,HWND,47,<empty>,,332,1,CPPASTTypeId,,<empty>
482418,UNKNOWN,1,,BYTE,38,<empty>,,339,1,CPPASTTypeId,,<empty>
482426,UNKNOWN,1,,BYTE,38,<empty>,,344,1,CPPASTTypeId,,<empty>
482429,UNKNOWN,1,,HWND,56,<empty>,,344,1,CPPASTTypeId,,<empty>
482456,UNKNOWN,1,,UINT,64,<empty>,,355,1,CPPASTTypeId,,<empty>
482476,UNKNOWN,1,,BYTE,31,<empty>,,360,1,CPPASTTypeId,,<empty>
482603,UNKNOWN,8,,"void ToggleV2ColorControls(const __in HWND hDlg)
{
    EnableWindow(GetDlgItem(hDlg, IDD_TRANSPARENCY), g_fForceV2);
    SetOpacitySlider(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDD_OPACITY_GROUPBOX), g_fForceV2);
    EnableWindow(GetDlgItem(hDlg, IDD_OPACITY_LOW_LABEL), g_fForceV2);
    EnableWindow(GetDlgItem(hDlg, IDD_OPACITY_HIGH_LABEL), g_fForceV2);
    EnableWindow(GetDlgItem(hDlg, IDD_OPACITY_VALUE), g_fForceV2);
}",1,<empty>,,398,8,CPPASTProblemDeclaration,,<empty>
482624,UNKNOWN,1,,int,78,<empty>,,417,1,CPPASTTypeId,,<empty>
482628,UNKNOWN,1,,float,84,<empty>,,417,1,CPPASTTypeId,,<empty>
482648,UNKNOWN,10,,"void SetOpacitySlider(__in HWND hDlg)
{
    if (g_fForceV2)
    {
        if (0 == g_bPreviewOpacity) //if no preview opacity has been set yet...
        {
            g_bPreviewOpacity = (gpStateInfo->bWindowTransparency >= TRANSPARENCY_RANGE_MIN) ? gpStateInfo->bWindowTransparency : BYTE_MAX;
        }
    }
    else
    {
        g_bPreviewOpacity = BYTE_MAX; //always fully opaque in V1
    }

    SendMessage(GetDlgItem(hDlg, IDD_TRANSPARENCY), TBM_SETPOS, TRUE, (LPARAM)(g_bPreviewOpacity));
    PreviewOpacity(hDlg, g_bPreviewOpacity);
}",1,<empty>,,429,10,CPPASTProblemDeclaration,,<empty>
482654,UNKNOWN,1,,void ToggleV2ColorControls(const __in HWND hDlg);,1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
482655,UNKNOWN,2,,INT_PTR,1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
482664,UNKNOWN,4,,void SetOpacitySlider(__in HWND hDlg);,1,<empty>,,19,4,CPPASTProblemDeclaration,,<empty>
482671,UNKNOWN,6,,"[[nodiscard]] LRESULT CALLBACK ColorTableControlProc(HWND hColor, UINT wMsg, WPARAM wParam, LPARAM lParam);",1,<empty>,,21,6,CPPASTProblemDeclaration,,<empty>
482687,UNKNOWN,5,,"BOOL GetStateInfo(HWND /*hDlg*/, UINT Item, __out LPINT lpValue)
{
    auto bRet = TRUE;
    int Value;

    switch (Item)
    {
    case IDD_SCRBUF_WIDTH:
        Value = gpStateInfo->ScreenBufferSize.X;
        break;
    case IDD_SCRBUF_HEIGHT:
        Value = gpStateInfo->ScreenBufferSize.Y;
        break;
    case IDD_WINDOW_WIDTH:
        Value = gpStateInfo->WindowSize.X;
        break;
    case IDD_WINDOW_HEIGHT:
        Value = gpStateInfo->WindowSize.Y;
        break;
    case IDD_WINDOW_POSX:
        Value = gpStateInfo->WindowPosX;
        break;
    case IDD_WINDOW_POSY:
        Value = gpStateInfo->WindowPosY;
        break;
    default:
        Value = 0;
        bRet = FALSE;
        break;
    }

    *lpValue = Value;
    return bRet;
}",1,<empty>,,9,5,CPPASTProblemDeclaration,,<empty>
482688,UNKNOWN,6,,INT_PTR,1,<empty>,,47,6,CPPASTProblemDeclaration,,<empty>
482979,UNKNOWN,1,,HWND,30,<empty>,,115,1,CPPASTTypeId,,<empty>
483038,UNKNOWN,1,,HWND,27,<empty>,,134,1,CPPASTTypeId,,<empty>
483056,UNKNOWN,1,,UINT,26,<empty>,,146,1,CPPASTTypeId,,<empty>
483075,UNKNOWN,1,,SHORT,50,<empty>,,149,1,CPPASTTypeId,,<empty>
483206,UNKNOWN,1,,LPPSHNOTIFY,40,<empty>,,200,1,CPPASTTypeId,,<empty>
483322,UNKNOWN,8,,"void ToggleV2LayoutControls(const __in HWND hDlg)
{
    EnableWindow(GetDlgItem(hDlg, IDD_LINE_WRAP), g_fForceV2);
    CheckDlgButton(hDlg, IDD_LINE_WRAP, g_fForceV2 ? gpStateInfo->fWrapText : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDD_SCRBUF_WIDTH), g_fForceV2 ? !gpStateInfo->fWrapText : TRUE);
}",1,<empty>,,257,8,CPPASTProblemDeclaration,,<empty>
483328,UNKNOWN,1,,void ToggleV2LayoutControls(const __in HWND hDlg);,1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
483329,UNKNOWN,2,,INT_PTR,1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
483445,UNKNOWN,1,,LONG,27,<empty>,,46,1,CPPASTTypeId,,<empty>
483454,UNKNOWN,1,,UINT,22,<empty>,,47,1,CPPASTTypeId,,<empty>
483728,UNKNOWN,3,,INT_PTR,1,<empty>,,166,3,CPPASTProblemDeclaration,,<empty>
484068,UNKNOWN,1,,HWND,66,<empty>,,266,1,CPPASTTypeId,,<empty>
484097,UNKNOWN,1,,LPNMHDR,23,<empty>,,273,1,CPPASTTypeId,,<empty>
484110,UNKNOWN,1,,PNMLINK,33,<empty>,,278,1,CPPASTTypeId,,<empty>
484139,UNKNOWN,1,,LPPSHNOTIFY,44,<empty>,,295,1,CPPASTTypeId,,<empty>
484193,UNKNOWN,1,,HWND,30,<empty>,,334,1,CPPASTTypeId,,<empty>
484211,UNKNOWN,5,,"void ToggleV2OptionsControls(const __in HWND hDlg)
{
    EnableWindow(GetDlgItem(hDlg, IDD_LINE_SELECTION), g_fForceV2);
    CheckDlgButton(hDlg, IDD_LINE_SELECTION, g_fForceV2 ? gpStateInfo->fLineSelection : FALSE);

    EnableWindow(GetDlgItem(hDlg, IDD_FILTER_ON_PASTE), g_fForceV2);
    CheckDlgButton(hDlg, IDD_FILTER_ON_PASTE, g_fForceV2 ? gpStateInfo->fFilterOnPaste : FALSE);

    EnableWindow(GetDlgItem(hDlg, IDD_CTRL_KEYS_ENABLED), g_fForceV2);
    CheckDlgButton(hDlg, IDD_CTRL_KEYS_ENABLED, g_fForceV2 ? !gpStateInfo->fCtrlKeyShortcutsDisabled : FALSE);

    EnableWindow(GetDlgItem(hDlg, IDD_EDIT_KEYS), g_fForceV2);
    CheckDlgButton(hDlg, IDD_EDIT_KEYS, g_fForceV2 ? g_fEditKeys : FALSE);

    EnableWindow(GetDlgItem(hDlg, IDD_INTERCEPT_COPY_PASTE), g_fForceV2);
    CheckDlgButton(hDlg, IDD_INTERCEPT_COPY_PASTE, g_fForceV2 ? gpStateInfo->InterceptCopyPaste : FALSE);
}",1,<empty>,,346,5,CPPASTProblemDeclaration,,<empty>
484217,UNKNOWN,1,,void ToggleV2OptionsControls(const __in HWND hDlg);,1,<empty>,,17,1,CPPASTProblemDeclaration,,<empty>
484218,UNKNOWN,2,,INT_PTR,1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
484259,UNKNOWN,-1,,"STDMETHODIMP GetClassID(_Out_ CLSID* clsid) override
    {
        *clsid = __uuidof(this);
        return S_OK;
    }",5,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
484260,UNKNOWN,-1,,"STDMETHODIMP Initialize(_In_ PCIDLIST_ABSOLUTE /*pidlFolder*/, _In_ IDataObject* pdtobj, _In_ HKEY /*hkeyProgID*/)
    {
        WCHAR szLinkFileName[MAX_PATH];
        auto hr = _ShouldAddPropertySheet(pdtobj, szLinkFileName, ARRAYSIZE(szLinkFileName));
        if (SUCCEEDED(hr))
        {
            hr = InitializeConsoleState() ? S_OK : E_FAIL;
            if (SUCCEEDED(hr))
            {
                hr = _InitializeGlobalStateInfo(szLinkFileName);
            }
        }

        return hr;
    }",5,<empty>,,39,3,CPPASTProblemDeclaration,,<empty>
484261,UNKNOWN,-1,,"STDMETHODIMP AddPages(_In_ LPFNADDPROPSHEETPAGE pfnAddPage, _In_ LPARAM lParam)
    {
        PROPSHEETPAGE psp[NUMBER_OF_PAGES] = {};
        auto hr = PopulatePropSheetPageArray(psp, ARRAYSIZE(psp), TRUE /*fRegisterCallbacks*/) ? S_OK : E_FAIL;
        if (SUCCEEDED(hr))
        {
            for (UINT ipsp = 0; ipsp < ARRAYSIZE(psp) && SUCCEEDED(hr); ipsp++)
            {
                auto hPage = CreatePropertySheetPage(&psp[ipsp]);
                hr = (hPage == nullptr) ? E_FAIL : S_OK;
                if (SUCCEEDED(hr))
                {
                    pfnAddPage(hPage, lParam);
                }
            }
        }

        return hr;
    }",5,<empty>,,56,4,CPPASTProblemDeclaration,,<empty>
484275,UNKNOWN,-1,,"HRESULT _InitializeGlobalStateInfo(_In_ PCWSTR pszLinkFileName)
    {
        g_fHostedInFileProperties = TRUE;
        gpStateInfo = &g_csi;

        // Initialize the fIsV2Console with whatever the current v2 setting is
        // in the registry. Usually this is set by conhost, but in this path,
        // we're being launched straight from explorer. See GH#2319, GH#2651
        gpStateInfo->fIsV2Console = GetConsoleBoolValue(CONSOLE_REGISTRY_FORCEV2, TRUE);

        InitRegistryValues(gpStateInfo);
        gpStateInfo->Defaults = TRUE;
        GetRegistryValues(gpStateInfo);

        PWSTR pszAllocatedFileName;
        auto hr = SHStrDup(pszLinkFileName, &pszAllocatedFileName);
        if (SUCCEEDED(hr))
        {
            hr = StringCchCopyW(pszAllocatedFileName, MAX_PATH, pszLinkFileName);
            if (SUCCEEDED(hr))
            {
                // gpStateInfo now owns lifetime of the allocated filename
                gpStateInfo->LinkTitle = pszAllocatedFileName;
    ...",5,<empty>,,86,7,CPPASTProblemDeclaration,,<empty>
484276,UNKNOWN,-1,,"HRESULT GetTargetIdList(_In_ IShellItem* psiLink, _COM_Outptr_ PIDLIST_ABSOLUTE* ppidl)
    {
        *ppidl = nullptr;

        IShellLink* psl;
        auto hr = psiLink->BindToHandler(nullptr, BHID_SFUIObject, IID_PPV_ARGS(&psl));
        if (SUCCEEDED(hr))
        {
            hr = psl->GetIDList(ppidl);
            if (SUCCEEDED(hr) && (*ppidl == nullptr))
            {
                hr = E_FAIL;
            }
            psl->Release();
        }
        return hr;
    }",5,<empty>,,135,8,CPPASTProblemDeclaration,,<empty>
484277,UNKNOWN,-1,,"HRESULT GetTargetItem(_In_ IShellItem* psiLink, _In_ REFIID riid, _COM_Outptr_ void** ppv)
    {
        *ppv = nullptr;

        PIDLIST_ABSOLUTE pidl;
        auto hr = GetTargetIdList(psiLink, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = SHCreateItemFromIDList(pidl, riid, ppv);
            ILFree(pidl);
        }
        return hr;
    }",5,<empty>,,152,9,CPPASTProblemDeclaration,,<empty>
484278,UNKNOWN,-1,,"HRESULT _GetShellItemLinkTargetExpanded(_In_ IShellItem* pShellItem,
                                            _Out_writes_(cchFilePathExtended) PWSTR pszFilePathExtended,
                                            const size_t cchFilePathExtended)
    {
        ComPtr<IShellItem> shellItemLinkTarget;
        auto hr = GetTargetItem(pShellItem, IID_PPV_ARGS(&shellItemLinkTarget));
        if (SUCCEEDED(hr))
        {
            wil::unique_cotaskmem_string linkTargetPath;
            hr = shellItemLinkTarget->GetDisplayName(SIGDN_FILESYSPATH, &linkTargetPath);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(pszFilePathExtended, cchFilePathExtended, linkTargetPath.get());
            }
        }

        return hr;
    }",5,<empty>,,167,10,CPPASTProblemDeclaration,,<empty>
484279,UNKNOWN,-1,,"HRESULT _ShouldAddPropertySheet(_In_ IDataObject* pdtobj,
                                    _Out_writes_(cchLinkFileName) PWSTR pszLinkFileName,
                                    const size_t cchLinkFileName)
    {
        ComPtr<IShellItemArray> shellItemArray;
        auto hr = SHCreateShellItemArrayFromDataObject(pdtobj, IID_PPV_ARGS(&shellItemArray));
        if (SUCCEEDED(hr))
        {
            DWORD dwItemCount;
            hr = shellItemArray->GetCount(&dwItemCount);
            if (SUCCEEDED(hr))
            {
                // only consider being available for selections of a single file
                hr = dwItemCount == 1 ? S_OK : E_FAIL;
                if (SUCCEEDED(hr))
                {
                    ComPtr<IShellItem> shellItem;
                    hr = shellItemArray->GetItemAt(0, &shellItem);
                    if (SUCCEEDED(hr))
                    {
                        // First expensive portion of this method -- reads .lnk file
             ...",5,<empty>,,186,11,CPPASTProblemDeclaration,,<empty>
485586,UNKNOWN,1,,const DelegationConfig::DelegationPackage* const,56,<empty>,,401,1,CPPASTTypeId,,<empty>
485599,UNKNOWN,17,,INT_PTR,1,<empty>,,412,17,CPPASTProblemDeclaration,,<empty>
485651,UNKNOWN,1,,LPNMHDR,23,<empty>,,432,1,CPPASTTypeId,,<empty>
485664,UNKNOWN,1,,PNMLINK,33,<empty>,,437,1,CPPASTTypeId,,<empty>
485693,UNKNOWN,1,,LPPSHNOTIFY,44,<empty>,,454,1,CPPASTTypeId,,<empty>
485744,UNKNOWN,1,,HWND,63,<empty>,,480,1,CPPASTTypeId,,<empty>
485766,UNKNOWN,1,,INT_PTR,1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
486187,UNKNOWN,1,,UINT_PTR,29,<empty>,,202,1,CPPASTTypeId,,<empty>
486224,UNKNOWN,1,,SHORT,44,<empty>,,214,1,CPPASTTypeId,,<empty>
486248,UNKNOWN,1,,SHORT,42,<empty>,,219,1,CPPASTTypeId,,<empty>
486268,UNKNOWN,1,,SHORT,44,<empty>,,224,1,CPPASTTypeId,,<empty>
486286,UNKNOWN,1,,SHORT,42,<empty>,,227,1,CPPASTTypeId,,<empty>
486306,UNKNOWN,1,,SHORT,38,<empty>,,232,1,CPPASTTypeId,,<empty>
486330,UNKNOWN,1,,SHORT,48,<empty>,,237,1,CPPASTTypeId,,<empty>
486350,UNKNOWN,1,,SHORT,38,<empty>,,242,1,CPPASTTypeId,,<empty>
486368,UNKNOWN,1,,SHORT,48,<empty>,,245,1,CPPASTTypeId,,<empty>
486771,UNKNOWN,10,,"PWSTR TranslateConsoleTitle(_In_ PCWSTR pwszConsoleTitle)
{
    auto fUnexpand = true;
    auto fSubstitute = true;

    LPWSTR Tmp = nullptr;

    size_t cbConsoleTitle;
    size_t cbSystemRoot;

    auto pwszSysRoot = new (std::nothrow) wchar_t[MAX_PATH];
    if (nullptr != pwszSysRoot)
    {
        if (0 != GetWindowsDirectoryW(pwszSysRoot, MAX_PATH))
        {
            if (SUCCEEDED(StringCbLengthW(pwszConsoleTitle, STRSAFE_MAX_CCH, &cbConsoleTitle)) &&
                SUCCEEDED(StringCbLengthW(pwszSysRoot, MAX_PATH, &cbSystemRoot)))
            {
                const auto cchSystemRoot = (int)(cbSystemRoot / sizeof(WCHAR));
                const auto cchConsoleTitle = (int)(cbConsoleTitle / sizeof(WCHAR));
                cbConsoleTitle += sizeof(WCHAR); // account for nullptr terminator

                if (fUnexpand &&
                    cchConsoleTitle >= cchSystemRoot &&
#pragma prefast(suppress : 26018, ""We've guaranteed that cchSystemRoot is equal to or smaller than...",1,<empty>,,391,10,CPPASTProblemDeclaration,,<empty>
486772,UNKNOWN,11,,"UINT CALLBACK PropSheetPageProc(_In_ HWND hWnd, _In_ UINT uMsg, _Inout_ LPPROPSHEETPAGE /*ppsp*/)
{
    static UINT cRefs = 0;
    switch (uMsg)
    {
    case PSPCB_ADDREF:
    {
        cRefs++;
        break;
    }

    case PSPCB_RELEASE:
    {
        cRefs--;
        if (cRefs == 0)
        {
            if (gpStateInfo->UpdateValues)
            {
                // only persist settings if they've changed
                SaveConsoleSettingsIfNeeded(hWnd);
            }

            UninitializeConsoleState();
        }
        break;
    }
    }

    return 1;
}",1,<empty>,,469,11,CPPASTProblemDeclaration,,<empty>
486773,UNKNOWN,12,,"BOOL PopulatePropSheetPageArray(_Out_writes_(cPsps) PROPSHEETPAGE* pPsp, const size_t cPsps, const BOOL fRegisterCallbacks)
{
    BOOL fRet = (cPsps == NUMBER_OF_PAGES);
    if (fRet)
    {
        // This has been validated above. OACR is being silly. Restate it so it can see the condition.
        __analysis_assume(cPsps == NUMBER_OF_PAGES);

        PROPSHEETPAGE* const pOptionsPage = &(pPsp[OPTIONS_PAGE_INDEX]);
        PROPSHEETPAGE* const pFontPage = &(pPsp[FONT_PAGE_INDEX]);
        PROPSHEETPAGE* const pLayoutPage = &(pPsp[LAYOUT_PAGE_INDEX]);
        PROPSHEETPAGE* const pColorsPage = &(pPsp[COLORS_PAGE_INDEX]);
        PROPSHEETPAGE* const pTerminalPage = &(pPsp[TERMINAL_PAGE_INDEX]);

        pOptionsPage->dwSize = sizeof(PROPSHEETPAGE);
        pOptionsPage->hInstance = ghInstance;
        if (g_fIsComCtlV6Present)
        {
            pOptionsPage->pszTemplate = (gpStateInfo->Defaults) ? MAKEINTRESOURCE(DID_SETTINGS) : MAKEINTRESOURCE(DID_SETTINGS2);
        }
        ...",1,<empty>,,500,12,CPPASTProblemDeclaration,,<empty>
486774,UNKNOWN,13,,"INT_PTR ConsolePropertySheet(__in HWND hWnd, __in PCONSOLE_STATE_INFO pStateInfo)
{
    PROPSHEETPAGE psp[NUMBER_OF_PAGES];
    PROPSHEETHEADER psh;
    INT_PTR Result = IDCANCEL;
    WCHAR awchBuffer[MAX_PATH] = { 0 };

    gpStateInfo = pStateInfo;

    // In v2 console, consider this an East Asian system if we're currently in a CJK charset. In v1, look at the system codepage.
    if (gpStateInfo->fIsV2Console)
    {
        g_fEastAsianSystem = IS_ANY_DBCS_CHARSET(CodePageToCharSet(gpStateInfo->CodePage));
    }
    else
    {
        g_fEastAsianSystem = IsEastAsianCP(GetOEMCP());
    }

    //
    // Initialize the state information.
    //
    if (gpStateInfo->Defaults)
    {
        InitRegistryValues(pStateInfo);
        GetRegistryValues(pStateInfo);
    }

    //
    // Initialize the font cache and current font index
    //

    InitializeFonts();
    g_currentFontIndex = FindCreateFont(gpStateInfo->FontFamily,
                                        gpStateInfo->FaceName...",1,<empty>,,576,13,CPPASTProblemDeclaration,,<empty>
486944,UNKNOWN,1,,HBRUSH,25,<empty>,,727,1,CPPASTTypeId,,<empty>
487054,UNKNOWN,1,,"void MakeAltRasterFont(
    __in UINT CodePage,
    __out COORD* AltFontSize,
    __out BYTE* AltFontFamily,
    __out ULONG* AltFontIndex,
    __out_ecount(LF_FACESIZE) LPTSTR AltFaceName);",1,<empty>,,65,1,CPPASTProblemDeclaration,,<empty>
487069,UNKNOWN,5,,"LPTTFONTLIST
SearchTTFont(
    __in_opt LPCTSTR ptszFace,
    BOOL fCodePage,
    UINT CodePage);",1,<empty>,,79,5,CPPASTProblemDeclaration,,<empty>
487108,UNKNOWN,13,,"INT_PTR ConsolePropertySheet(
    __in HWND hWnd,
    __in PCONSOLE_STATE_INFO pStateInfo);",1,<empty>,,113,13,CPPASTProblemDeclaration,,<empty>
487119,UNKNOWN,16,,INT_PTR,1,<empty>,,123,16,CPPASTProblemDeclaration,,<empty>
487128,UNKNOWN,18,,"VOID InitRegistryValues(
    __out PCONSOLE_STATE_INFO pStateInfo);",1,<empty>,,129,18,CPPASTProblemDeclaration,,<empty>
487129,UNKNOWN,19,,"DWORD GetRegistryValues(
    __out_opt PCONSOLE_STATE_INFO StateInfo);",1,<empty>,,132,19,CPPASTProblemDeclaration,,<empty>
487140,UNKNOWN,22,,"[[nodiscard]] LRESULT CALLBACK FontPreviewWndProc(
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);",1,<empty>,,141,22,CPPASTProblemDeclaration,,<empty>
487141,UNKNOWN,23,,"[[nodiscard]] LRESULT CALLBACK PreviewWndProc(
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);",1,<empty>,,147,23,CPPASTProblemDeclaration,,<empty>
487172,UNKNOWN,30,,"BOOL PopulatePropSheetPageArray(_Out_writes_(cPsps) PROPSHEETPAGE* pPsp, const size_t cPsps, const BOOL fRegisterCallbacks);",1,<empty>,,167,30,CPPASTProblemDeclaration,,<empty>
487230,UNKNOWN,51,,"BOOL GetConsoleBoolValue(__in PCWSTR pszValueName, __in BOOL fDefault);",1,<empty>,,231,51,CPPASTProblemDeclaration,,<empty>
487240,UNKNOWN,1,,"void MakeAltRasterFont(
    __in UINT CodePage,
    __out COORD* AltFontSize,
    __out BYTE* AltFontFamily,
    __out ULONG* AltFontIndex,
    __out_ecount(LF_FACESIZE) LPTSTR AltFaceName)
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    auto FontSize = FontInfo[DefaultFontIndex].Size;
    COORD FontDelta;
    auto fDbcsCharSet = IS_ANY_DBCS_CHARSET(CodePageToCharSet(CodePage));

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i = 0; i < NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet) == fDbcsCharSet)
        {
            FontDelta.X = (SHORT)abs(FontSize.X - FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    StringCchCopy(Al...",1,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
487259,UNKNOWN,1,,DWORD*,32,<empty>,,76,1,CPPASTTypeId,,<empty>
487273,UNKNOWN,1,,BYTE,13,<empty>,,81,1,CPPASTTypeId,,<empty>
487279,UNKNOWN,4,,"LPTTFONTLIST
SearchTTFont(
    __in_opt LPCTSTR ptszFace,
    BOOL fCodePage,
    UINT CodePage)
{
    return TrueTypeFontList::s_SearchByName(ptszFace, fCodePage, CodePage);
}",1,<empty>,,84,4,CPPASTProblemDeclaration,,<empty>
487428,UNKNOWN,1,,LONG,23,<empty>,,192,1,CPPASTTypeId,,<empty>
487434,UNKNOWN,1,,LPARAM,77,<empty>,,192,1,CPPASTTypeId,,<empty>
487447,UNKNOWN,1,,DWORD,61,<empty>,,195,1,CPPASTTypeId,,<empty>
487470,UNKNOWN,1,,LONG,23,<empty>,,207,1,CPPASTTypeId,,<empty>
487476,UNKNOWN,1,,LPARAM,77,<empty>,,207,1,CPPASTTypeId,,<empty>
487489,UNKNOWN,1,,DWORD,61,<empty>,,210,1,CPPASTTypeId,,<empty>
487505,UNKNOWN,1,,LONG,19,<empty>,,223,1,CPPASTTypeId,,<empty>
487515,UNKNOWN,1,,int,24,<empty>,,224,1,CPPASTTypeId,,<empty>
487552,UNKNOWN,12,,"[[nodiscard]] NTSTATUS GetTTFontFaceForCodePage(const UINT uiCodePage, // the codepage to examine (note: not charset)
                                                _Out_writes_(cchFaceName) PWSTR pszFaceName, // where to write the facename we find
                                                const size_t cchFaceName) // space available in pszFaceName
{
    return TrueTypeFontList::s_SearchByCodePage(uiCodePage, pszFaceName, cchFaceName);
}",1,<empty>,,244,12,CPPASTProblemDeclaration,,<empty>
487568,UNKNOWN,2,,I,10,<empty>,,10,2,CPPASTProblemDeclaration,,<empty>
487569,UNKNOWN,3,,"DllGetClassObject(_In_ REFCLSID rclsid, _In_ REFIID riid, _Outptr_ void** ppv)
{
    return Module<InProc>::GetModule().GetClassObject(rclsid, riid, ppv);
}",5,<empty>,,11,3,CPPASTProblemDeclaration,,<empty>
487631,UNKNOWN,10,,"int FindCreateFont(
    __in DWORD Family,
    __in_ecount(LF_FACESIZE) LPWSTR ptszFace,
    __in COORD Size,
    __in LONG Weight,
    __in UINT CodePage);",1,<empty>,,95,10,CPPASTProblemDeclaration,,<empty>
487632,UNKNOWN,11,,"BOOL DoFontEnum(
    __in_opt HDC hDC,
    __in_ecount_opt(LF_FACESIZE) LPTSTR ptszFace,
    __in_ecount_opt(nTTPoints) PSHORT pTTPoints,
    __in UINT nTTPoints);",1,<empty>,,102,11,CPPASTProblemDeclaration,,<empty>
487633,UNKNOWN,12,,"[[nodiscard]] NTSTATUS GetTTFontFaceForCodePage(const UINT uiCodePage,
                                                _Out_writes_(cchFaceName) PWSTR pszFaceName,
                                                const size_t cchFaceName);",1,<empty>,,108,12,CPPASTProblemDeclaration,,<empty>
487634,UNKNOWN,13,,"bool IsFontSizeCustom(__in PCWSTR pwszFaceName, const __in SHORT sSize);",1,<empty>,,112,13,CPPASTProblemDeclaration,,<empty>
487635,UNKNOWN,14,,void CreateSizeForAllTTFonts(const __in SHORT sSize);,1,<empty>,,113,14,CPPASTProblemDeclaration,,<empty>
487645,UNKNOWN,1,,"int FontListCreate(
    __in HWND hDlg,
    __in_ecount_opt(LF_FACESIZE) LPWSTR pwszTTFace,
    __in BOOL bNewFaceList);",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
487755,UNKNOWN,1,,HFONT,18,<empty>,,85,1,CPPASTTypeId,,<empty>
487800,UNKNOWN,23,,"BOOL IsBoldOnlyTTFont(_In_ PCWSTR pwszTTFace, _In_opt_ PCWSTR pwszAltTTFace)
{
    auto fFoundNormalWeightFont = FALSE;

    for (ULONG i = 0; i < NumberOfFonts; i++)
    {
        // only care about truetype fonts
        if (!TM_IS_TT_FONT(FontInfo[i].Family))
        {
            continue;
        }

        // only care about fonts in the correct charset
        if (g_fEastAsianSystem)
        {
            if (!IS_DBCS_OR_OEM_CHARSET(FontInfo[i].tmCharSet))
            {
                continue;
            }
        }
        else
        {
            if (IS_DBCS_OR_OEM_CHARSET(FontInfo[i].tmCharSet))
            {
                continue;
            }
        }

        // only care if this TT font's name matches
        if ((0 != lstrcmp(FontInfo[i].FaceName, pwszTTFace)) && // wrong face name and
            (!pwszAltTTFace || // either pwszAltTTFace is NULL or
             (0 != lstrcmp(FontInfo[i].FaceName, pwszAltTTFace)))) // pwszAltTTFace is wrong too
        {
  ...",1,<empty>,,105,23,CPPASTProblemDeclaration,,<empty>
487801,UNKNOWN,24,,"static void AddCustomFontSizeToListIfNeeded(const __in HWND hDlg)
{
    WCHAR wszBuf[3]; // only need space for point sizes. the max we allow is ""72""

    // check to see if we have text
    if (GetDlgItemText(hDlg, IDD_POINTSLIST, wszBuf, ARRAYSIZE(wszBuf)) > 0)
    {
        // we have text, now retrieve it as an actual size
        BOOL fTranslated;
        const auto nPointSize = (SHORT)GetDlgItemInt(hDlg, IDD_POINTSLIST, &fTranslated, TRUE);
        if (fTranslated &&
            nPointSize >= MIN_PIXEL_HEIGHT &&
            nPointSize <= MAX_PIXEL_HEIGHT &&
            IsFontSizeCustom(gpStateInfo->FaceName, nPointSize))
        {
            // we got a proper custom size. let's see if it's in our point size list
            auto iSize = (LONG)SendDlgItemMessage(hDlg, IDD_POINTSLIST, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)wszBuf);
            if (iSize == CB_ERR)
            {
                // the size isn't in our list, so we haven't created them yet. do so now.
         ...",1,<empty>,,158,24,CPPASTProblemDeclaration,,<empty>
487803,UNKNOWN,26,,Y,8,<empty>,,212,26,CPPASTProblemDeclaration,,<empty>
487804,UNKNOWN,27,,"FontDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)

/*++

    Dialog proc for the font selection dialog box.
    Returns the near offset into the far table of LOGFONT structures.

--*/

{
    HWND hWndFocus;
    HWND hWndList;
    int FontIndex = g_currentFontIndex; // init to keep compiler happy
    BOOL bLB;

    switch (wMsg)
    {
    case WM_INITDIALOG:
        /*
         * Load the font description strings
         */
        LoadString(ghInstance, IDS_RASTERFONT, wszRasterFonts, ARRAYSIZE(wszRasterFonts));
        DBGFONTS((""wszRasterFonts = \""%ls\""\n"", wszRasterFonts));

        LoadString(ghInstance, IDS_SELECTEDFONT, wszSelectedFont, ARRAYSIZE(wszSelectedFont));
        DBGFONTS((""wszSelectedFont = \""%ls\""\n"", wszSelectedFont));

        /* Save current font size as dialog window's user data */

        if (g_fEastAsianSystem)
        {
            SetWindowLongPtr(hDlg, GWLP_USERDATA, MAKELONG(FontInfo[g_currentFontIndex].tmCharSet, FontInfo...",1,<empty>,,213,27,CPPASTProblemDeclaration,,<empty>
488185,UNKNOWN,1,,LONG,27,<empty>,,666,1,CPPASTTypeId,,<empty>
488196,UNKNOWN,1,,LPARAM,27,<empty>,,666,1,CPPASTTypeId,,<empty>
488211,UNKNOWN,1,,LONG,26,<empty>,,669,1,CPPASTTypeId,,<empty>
488220,UNKNOWN,1,,LPARAM,26,<empty>,,669,1,CPPASTTypeId,,<empty>
488226,UNKNOWN,1,,DWORD,9,<empty>,,676,1,CPPASTTypeId,,<empty>
488237,UNKNOWN,1,,DWORD,9,<empty>,,676,1,CPPASTTypeId,,<empty>
488242,UNKNOWN,29,,"int FontListCreate(
    __in HWND hDlg,
    __in_ecount_opt(LF_FACESIZE) LPWSTR pwszTTFace,
    __in BOOL bNewFaceList)
{
    LONG lListIndex;
    ULONG i;
    HWND hWndShow; // List or Combo box
    HWND hWndHide; // Combo or List box
    HWND hWndFaceCombo;
    BOOL bLB;
    auto CodePage = gpStateInfo->CodePage;
    auto fFindTTFont = FALSE;
    LPWSTR pwszAltTTFace;
    LONG_PTR dwExStyle;

    FAIL_FAST_IF(!(OEMCP != 0)); // must be initialized

    bLB = ((pwszTTFace == nullptr) || (pwszTTFace[0] == TEXT('\0')));
    if (bLB)
    {
        pwszAltTTFace = nullptr;
    }
    else
    {
        if (ShouldAllowAllMonoTTFonts() || IsAvailableTTFont(pwszTTFace))
        {
            pwszAltTTFace = GetAltFaceName(pwszTTFace);
        }
        else
        {
            pwszAltTTFace = pwszTTFace;
        }
    }

    DBGFONTS((""FontListCreate %p, %s, %s new FaceList\n"", hDlg, bLB ? ""Raster"" : ""TrueType"", bNewFaceList ? ""Make"" : ""No""));

    /*
     * This only enumerates face nam...",1,<empty>,,688,29,CPPASTProblemDeclaration,,<empty>
488262,UNKNOWN,1,,int,10,<empty>,,919,1,CPPASTTypeId,,<empty>
488380,UNKNOWN,1,,LPARAM,59,<empty>,,973,1,CPPASTTypeId,,<empty>
488385,UNKNOWN,1,,BOOL,16,<empty>,,974,1,CPPASTTypeId,,<empty>
488417,UNKNOWN,1,,UINT,87,<empty>,,980,1,CPPASTTypeId,,<empty>
488437,UNKNOWN,1,,HBITMAP,25,<empty>,,988,1,CPPASTTypeId,,<empty>
488559,UNKNOWN,33,,K,12,<empty>,,1047,33,CPPASTProblemDeclaration,,<empty>
488560,UNKNOWN,34,,"FontPreviewWndProc(
        HWND hWnd,
        UINT wMessage,
        WPARAM wParam,
        LPARAM lParam)

/*  FontPreviewWndProc
 *      Handles the font preview window
 */

{
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hfontOld;
    HBRUSH hbrNew;
    HBRUSH hbrOld;
    COLORREF rgbText;
    COLORREF rgbBk;

    switch (wMessage)
    {
    case WM_ERASEBKGND:
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);

        /* Draw the font sample */
        if (GetWindowLong(hWnd, GWL_ID) == IDD_COLOR_POPUP_COLORS)
        {
            rgbText = GetNearestColor(ps.hdc, PopupTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, PopupBkColor(gpStateInfo));
        }
        else
        {
            rgbText = GetNearestColor(ps.hdc, ScreenTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, ScreenBkColor(gpStateInfo));
        }
        SetTextColor(ps.hdc, rgbText);
        SetBkColor(ps.hdc, rgbBk);
        GetClientRect(hWnd, &rect);
...",5,<empty>,,1048,34,CPPASTProblemDeclaration,,<empty>
488561,UNKNOWN,35,,"int FindCreateFont(
    __in DWORD Family,
    __in_ecount(LF_FACESIZE) LPWSTR pwszFace,
    __in COORD Size,
    __in LONG Weight,
    __in UINT CodePage)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    auto FontIndex = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    WCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE AltFontFamily;
    ULONG AltFontIndex = 0, i;
    LPWSTR pwszAltFace;

    auto CharSet = CodePageToCharSet(CodePage);

    FAIL_FAST_IF(!(OEMCP != 0));

    DBGFONTS((""FindCreateFont Family=%x %ls (%d,%d) %d %d %x\n"",
              Family,
              pwszFace,
              Size.X,
              Size.Y,
              Weight,
              CodePage,
              CharSet));

    if (g_fEastAsianSystem)
    {
        if (IS_DBCS_OR_OEM_CHARSET(CharSet))
        {
            if (pwszFace == nullptr || *pwszFace == TEXT('\0'))
            {
                pwszFace = DefaultFaceName;
            }
            if (Size.Y == 0)
       ...",1,<empty>,,1123,35,CPPASTProblemDeclaration,,<empty>
488588,UNKNOWN,1,,LONG,11,<empty>,,1382,1,CPPASTTypeId,,<empty>
488617,UNKNOWN,1,,LONG,17,<empty>,,1393,1,CPPASTTypeId,,<empty>
488698,UNKNOWN,1,,LONG,21,<empty>,,1426,1,CPPASTTypeId,,<empty>
488708,UNKNOWN,1,,int,60,<empty>,,1426,1,CPPASTTypeId,,<empty>
488742,UNKNOWN,1,,LONG,29,<empty>,,1438,1,CPPASTTypeId,,<empty>
488817,UNKNOWN,1,,LPARAM,31,<empty>,,1466,1,CPPASTTypeId,,<empty>
488820,UNKNOWN,1,,LPARAM,56,<empty>,,1466,1,CPPASTTypeId,,<empty>
488860,UNKNOWN,1,,ULONG,21,<empty>,,1498,1,CPPASTTypeId,,<empty>
488946,UNKNOWN,1,,LONG,14,<empty>,,1539,1,CPPASTTypeId,,<empty>
488967,UNKNOWN,1,,LONG,19,<empty>,,1545,1,CPPASTTypeId,,<empty>
488984,UNKNOWN,1,,LPARAM,69,<empty>,,1546,1,CPPASTTypeId,,<empty>
488996,UNKNOWN,1,,SHORT,22,<empty>,,1548,1,CPPASTTypeId,,<empty>
489078,UNKNOWN,1,,LONG,21,<empty>,,1579,1,CPPASTTypeId,,<empty>
489099,UNKNOWN,1,,ULONG,21,<empty>,,1590,1,CPPASTTypeId,,<empty>
489105,UNKNOWN,1,,ULONG,10,<empty>,,1591,1,CPPASTTypeId,,<empty>
489116,UNKNOWN,1,,ULONG,32,<empty>,,1596,1,CPPASTTypeId,,<empty>
489133,UNKNOWN,1,,DWORD_PTR,22,<empty>,,1605,1,CPPASTTypeId,,<empty>
489140,UNKNOWN,1,,DWORD_PTR,22,<empty>,,1606,1,CPPASTTypeId,,<empty>
489155,UNKNOWN,1,,va_list*,21,<empty>,,1613,1,CPPASTTypeId,,<empty>
489343,UNKNOWN,1,,HWND,35,<empty>,,60,1,CPPASTTypeId,,<empty>
489349,UNKNOWN,1,,HWND,34,<empty>,,61,1,CPPASTTypeId,,<empty>
489410,UNKNOWN,2,,BOOL,1,<empty>,,19,2,CPPASTProblemDeclaration,,<empty>
489477,UNKNOWN,1,,LPCPLINFO,25,<empty>,,73,1,CPPASTTypeId,,<empty>
489514,UNKNOWN,1,,LPNEWCPLINFO,22,<empty>,,83,1,CPPASTTypeId,,<empty>
489593,UNKNOWN,1,,LONG,17,<empty>,,101,1,CPPASTTypeId,,<empty>
489602,UNKNOWN,1,,PCONSOLE_STATE_INFO,37,<empty>,,104,1,CPPASTTypeId,,<empty>
489613,UNKNOWN,1,,LONG,13,<empty>,,112,1,CPPASTTypeId,,<empty>
489671,UNKNOWN,-1,,__field_ecount_opt(nTTPoints) PSHORT pTTPoints;,5,<empty>,,83,4,CPPASTProblemDeclaration,,<empty>
489675,UNKNOWN,8,,"PFACENODE
AddFaceNode(
    __in_ecount(LF_FACESIZE) LPCWSTR ptsz)
{
    PFACENODE pNew, *ppTmp;
    size_t cch;

    /*
     * Is it already here?
     */
    for (ppTmp = &gpFaceNames; *ppTmp; ppTmp = &((*ppTmp)->pNext))
    {
        if (0 == lstrcmp(((*ppTmp)->atch), ptsz))
        {
            // already there !
            return *ppTmp;
        }
    }

    cch = wcslen(ptsz);
    pNew = (PFACENODE)HeapAlloc(GetProcessHeap(),
                                0,
                                sizeof(FACENODE) + ((cch + 1) * sizeof(WCHAR)));
    if (pNew == nullptr)
    {
        return nullptr;
    }

    pNew->pNext = nullptr;
    pNew->dwFlag = 0;
    StringCchCopy(pNew->atch, cch + 1, ptsz);
    *ppTmp = pNew;
    return pNew;
}",1,<empty>,,87,8,CPPASTProblemDeclaration,,<empty>
489938,UNKNOWN,1,,SHORT,19,<empty>,,222,1,CPPASTTypeId,,<empty>
489949,UNKNOWN,1,,SHORT,19,<empty>,,223,1,CPPASTTypeId,,<empty>
489960,UNKNOWN,1,,SHORT,23,<empty>,,226,1,CPPASTTypeId,,<empty>
489971,UNKNOWN,1,,SHORT,23,<empty>,,227,1,CPPASTTypeId,,<empty>
490019,UNKNOWN,1,,SHORT,21,<empty>,,244,1,CPPASTTypeId,,<empty>
490314,UNKNOWN,1,,PFONT_INFO,21,<empty>,,357,1,CPPASTTypeId,,<empty>
490606,UNKNOWN,18,,"int CALLBACK FontEnumForV2Console(ENUMLOGFONT* pelf, NEWTEXTMETRIC* pntm, int nFontType, LPARAM lParam)
{
    FAIL_FAST_IF(!(ShouldAllowAllMonoTTFonts()));
    UINT i;
    LPCTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    PFACENODE pFN;
    auto pfed = (PFONTENUMDATA)lParam;

    DBGFONTS((""  FontEnum \""%ls\"" (%d,%d) weight 0x%lx(%d) %x -- %s\n"",
              ptszFace,
              pelf->elfLogFont.lfWidth,
              pelf->elfLogFont.lfHeight,
              pelf->elfLogFont.lfWeight,
              pelf->elfLogFont.lfWeight,
              pelf->elfLogFont.lfCharSet,
              pfed->bFindFaces ? ""Finding Faces"" : ""Creating Fonts""));

    // reject non-monospaced fonts
    if (!(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH))
    {
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    // reject non-modern or italic TT fonts
    if ((nFontType == TRUETYPE_FONTTYPE) &&
        (((pelf->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN) ||
         pelf->...",1,<empty>,,468,18,CPPASTProblemDeclaration,,<empty>
490608,UNKNOWN,20,,K,12,<empty>,,611,20,CPPASTProblemDeclaration,,<empty>
490609,UNKNOWN,21,,"FontEnum(
        ENUMLOGFONT* pelf,
        NEWTEXTMETRIC* pntm,
        int nFontType,
        LPARAM lParam)
{
    UINT i;
    LPCTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    PFACENODE pFN;
    auto pfed = (PFONTENUMDATA)lParam;

    DBGFONTS((""  FontEnum \""%ls\"" (%d,%d) weight 0x%lx(%d) %x -- %s\n"",
              ptszFace,
              pelf->elfLogFont.lfWidth,
              pelf->elfLogFont.lfHeight,
              pelf->elfLogFont.lfWeight,
              pelf->elfLogFont.lfWeight,
              pelf->elfLogFont.lfCharSet,
              pfed->bFindFaces ? ""Finding Faces"" : ""Creating Fonts""));

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //

    if (
        !(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
        (pelf->elfLogFont.lfItalic) ||
        !(pntm->ntmFlags & NTM_NONNEGATIVE_AC))
    {
        if (!IsAvailableTTFont(ptszFace))
        {
            DBGFONTS((""    REJECT  face (dbcs, variable pitch, italic, or neg a&c)\...",5,<empty>,,612,21,CPPASTProblemDeclaration,,<empty>
490610,UNKNOWN,22,,"BOOL DoFontEnum(
    __in_opt HDC hDC,
    __in_ecount_opt(LF_FACESIZE) LPTSTR ptszFace,
    __in_ecount_opt(nTTPoints) PSHORT pTTPoints,
    __in UINT nTTPoints)
{
    auto bDeleteDC = FALSE;
    FONTENUMDATA fed;
    LOGFONT LogFont;

    DBGFONTS((""DoFontEnum \""%ls\""\n"", ptszFace));
    if (hDC == nullptr)
    {
        hDC = CreateCompatibleDC(nullptr);
        bDeleteDC = TRUE;
    }

    fed.hDC = hDC;
    fed.bFindFaces = (ptszFace == nullptr);
    fed.ulFE = 0;
    fed.pTTPoints = pTTPoints;
    fed.nTTPoints = nTTPoints;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (ptszFace != nullptr)
    {
        StringCchCopy(LogFont.lfFaceName, LF_FACESIZE, ptszFace);

        if (NumberOfFonts == 0 && // We've yet to enumerate fonts
            g_fEastAsianSystem && // And we're currently using a CJK codepage
            !IS_ANY_DBCS_CHARSET(CodePageToCharSet(OEMCP)) && // But the system codepage *isn't* CJK
            0 == lstrcmp(pt...",1,<empty>,,777,22,CPPASTProblemDeclaration,,<empty>
490611,UNKNOWN,23,,"VOID RemoveFace(__in_ecount(LF_FACESIZE) LPCTSTR ptszFace)
{
    DWORD i;
    auto nToRemove = 0;

    DBGFONTS((""RemoveFace %ls\n"", ptszFace));
    //
    // Delete & Remove fonts with Face Name == ptszFace
    //
    for (i = 0; i < NumberOfFonts; i++)
    {
        if (0 == lstrcmp(FontInfo[i].FaceName, ptszFace))
        {
            auto bDeleted = DeleteObject(FontInfo[i].hFont);
            DBGFONTS((""RemoveFace: hFont %p was %sdeleted\n"",
                      FontInfo[i].hFont,
                      bDeleted ? """" : ""NOT ""));
            bDeleted; // to fix x86 build complaining
            FontInfo[i].hFont = nullptr;
            nToRemove++;
        }
        else if (nToRemove > 0)
        {
            /*
             * Shuffle from FontInfo[i] down nToRemove slots.
             */
            RtlMoveMemory(&FontInfo[i - nToRemove],
                          &FontInfo[i],
                          sizeof(FONT_INFO) * (NumberOfFonts - i));
            NumberOfFonts -= nT...",1,<empty>,,830,23,CPPASTProblemDeclaration,,<empty>
490612,UNKNOWN,24,,"static bool IsSizePresentInList(const __in SHORT sSizeDesired, __in_ecount(nTTPoints) PSHORT pTTPoints, __in UINT nTTPoints)
{
    auto fSizePresent = false;
    for (UINT i = 0; i < nTTPoints; i++)
    {
        if (pTTPoints[i] == sSizeDesired)
        {
            fSizePresent = true;
            break;
        }
    }
    return fSizePresent;
}",1,<empty>,,868,24,CPPASTProblemDeclaration,,<empty>
490613,UNKNOWN,25,,"bool IsFontSizeCustom(__in PCWSTR pszFaceName, const __in SHORT sSize)
{
    bool fUsingCustomFontSize;
    if (g_fEastAsianSystem && !IsAvailableTTFontCP(pszFaceName, 0))
    {
        fUsingCustomFontSize = !IsSizePresentInList(sSize, TTPointsDbcs, ARRAYSIZE(TTPointsDbcs));
    }
    else
    {
        fUsingCustomFontSize = !IsSizePresentInList(sSize, TTPoints, ARRAYSIZE(TTPoints));
    }

    return fUsingCustomFontSize;
}",1,<empty>,,884,25,CPPASTProblemDeclaration,,<empty>
490628,UNKNOWN,27,,"void CreateSizeForAllTTFonts(const __in SHORT sSize)
{
    auto hDC = CreateCompatibleDC(nullptr);

    // for each font face
    for (auto pFN = gpFaceNames; pFN; pFN = pFN->pNext)
    {
        if (pFN->dwFlag & EF_TTFONT)
        {
            // if it's a TT font, load the supplied size
            DoFontEnum(hDC, pFN->atch, (PSHORT)&sSize, 1);
        }
    }
}",1,<empty>,,907,27,CPPASTProblemDeclaration,,<empty>
490666,UNKNOWN,1,,PFONT_INFO,21,<empty>,,943,1,CPPASTTypeId,,<empty>
491607,UNKNOWN,1,,POINT*,32,<empty>,,159,1,CPPASTTypeId,,<empty>
491616,UNKNOWN,1,,POINT*,32,<empty>,,160,1,CPPASTTypeId,,<empty>
491659,UNKNOWN,1,,POINT*,32,<empty>,,207,1,CPPASTTypeId,,<empty>
491668,UNKNOWN,1,,POINT*,32,<empty>,,208,1,CPPASTTypeId,,<empty>
491733,UNKNOWN,1,,HBITMAP,19,<empty>,,228,1,CPPASTTypeId,,<empty>
491800,UNKNOWN,1,,HBRUSH,15,<empty>,,250,1,CPPASTTypeId,,<empty>
492497,UNKNOWN,10,,K,12,<empty>,,340,10,CPPASTProblemDeclaration,,<empty>
492498,UNKNOWN,11,,"PreviewWndProc(
        HWND hWnd,
        UINT wMessage,
        WPARAM wParam,
        LPARAM lParam)

/*
 * PreviewWndProc
 *      Handles the preview window
 */

{
    PAINTSTRUCT ps;
    LPCREATESTRUCT lpcs;
    RECT rcWindow;
    int cx;
    int cy;

    switch (wMessage)
    {
    case WM_CREATE:
        /*
         * Figure out space used by non-client area
         */
        SetRect(&rcWindow, 0, 0, 50, 50);
        AdjustWindowRect(&rcWindow, WS_OVERLAPPEDWINDOW, FALSE);
        NonClientSize.x = rcWindow.right - rcWindow.left - 50;
        NonClientSize.y = rcWindow.bottom - rcWindow.top - 50;

        /*
         * Compute the size of the preview ""window""
         */
        UpdatePreviewRect();

        /*
         * Scale the window so it has the same aspect ratio as the screen
         */
        lpcs = (LPCREATESTRUCT)lParam;
        cx = lpcs->cx;
        cy = AspectScale(gcyScreen, gcxScreen, cx);
        if (cy > lpcs->cy)
        {
            cy = lpcs->cy;
   ...",5,<empty>,,341,11,CPPASTProblemDeclaration,,<empty>
492566,UNKNOWN,2,,"BOOL GetConsoleBoolValue(__in PCWSTR pszValueName, __in BOOL fDefault)
{
    return SHRegGetBoolUSValue(CONSOLE_REGISTRY_STRING,
                               pszValueName,
                               FALSE /*fIgnoreHKCU*/,
                               fDefault);
}",1,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
492567,UNKNOWN,3,,"VOID InitRegistryValues(
    __out PCONSOLE_STATE_INFO pStateInfo)
{
    pStateInfo->ScreenAttributes = 0x07; // white on black
    pStateInfo->PopupAttributes = 0xf5; // purple on white
    pStateInfo->InsertMode = FALSE;
    pStateInfo->QuickEdit = FALSE;
    pStateInfo->FullScreen = FALSE;
    pStateInfo->ScreenBufferSize.X = 80;
    pStateInfo->ScreenBufferSize.Y = 25;
    pStateInfo->WindowSize.X = 80;
    pStateInfo->WindowSize.Y = 25;
    pStateInfo->WindowPosX = 0;
    pStateInfo->WindowPosY = 0;
    pStateInfo->AutoPosition = TRUE;
    pStateInfo->FontSize.X = 0;
    pStateInfo->FontSize.Y = 0;
    pStateInfo->FontFamily = 0;
    pStateInfo->FontWeight = 0;
    pStateInfo->FaceName[0] = TEXT('\0');
    pStateInfo->CursorSize = 25;
    pStateInfo->HistoryBufferSize = 25;
    pStateInfo->NumberOfHistoryBuffers = 4;
    pStateInfo->HistoryNoDup = 0;

    // clang-format off
    if (pStateInfo->fIsV2Console)
    {
        // if we're servicing a v2 console instance, default to ...",1,<empty>,,59,3,CPPASTProblemDeclaration,,<empty>
492568,UNKNOWN,4,,"DWORD GetRegistryValues(
    __out_opt PCONSOLE_STATE_INFO pStateInfo)
{
    HKEY hCurrentUserKey, hConsoleKey, hTitleKey;
    NTSTATUS Status;
    DWORD dwValue, dwRet = 0, i;
    WCHAR awchBuffer[LF_FACESIZE];

    // initial values for global v2 settings
    g_fForceV2 = GetConsoleBoolValue(CONSOLE_REGISTRY_FORCEV2, TRUE);
    g_fEditKeys = GetConsoleBoolValue(CONSOLE_REGISTRY_EXTENDEDEDITKEY, TRUE);

    //
    // Open the current user registry key and console key.
    //
    Status = RegistrySerialization::s_OpenConsoleKey(&hCurrentUserKey, &hConsoleKey);

    if (FAILED_NTSTATUS(Status))
    {
        return 0;
    }

    //
    // If there is no structure to fill out, just get the current
    // page and bail out.
    //

    if (pStateInfo == nullptr)
    {
        Status = RegistrySerialization::s_QueryValue(hConsoleKey,
                                                     CONSOLE_REGISTRY_CURRENTPAGE,
                                                     sizeof(dwValue),
  ...",1,<empty>,,162,4,CPPASTProblemDeclaration,,<empty>
492638,UNKNOWN,1,,BYTE*,54,<empty>,,707,1,CPPASTTypeId,,<empty>
492689,UNKNOWN,1,,BYTE*,57,<empty>,,739,1,CPPASTTypeId,,<empty>
492709,UNKNOWN,1,,BYTE*,57,<empty>,,746,1,CPPASTTypeId,,<empty>
492751,UNKNOWN,1,,BYTE*,65,<empty>,,757,1,CPPASTTypeId,,<empty>
492771,UNKNOWN,1,,BYTE*,57,<empty>,,771,1,CPPASTTypeId,,<empty>
492791,UNKNOWN,1,,BYTE*,57,<empty>,,778,1,CPPASTTypeId,,<empty>
492807,UNKNOWN,1,,DWORD,20,<empty>,,784,1,CPPASTTypeId,,<empty>
492821,UNKNOWN,1,,BYTE*,61,<empty>,,789,1,CPPASTTypeId,,<empty>
492849,UNKNOWN,1,,BYTE*,57,<empty>,,803,1,CPPASTTypeId,,<empty>
492877,UNKNOWN,1,,BYTE*,57,<empty>,,816,1,CPPASTTypeId,,<empty>
492915,UNKNOWN,1,,BYTE*,61,<empty>,,835,1,CPPASTTypeId,,<empty>
492943,UNKNOWN,1,,BYTE*,57,<empty>,,849,1,CPPASTTypeId,,<empty>
492963,UNKNOWN,1,,BYTE*,57,<empty>,,856,1,CPPASTTypeId,,<empty>
492983,UNKNOWN,1,,BYTE*,57,<empty>,,863,1,CPPASTTypeId,,<empty>
492998,UNKNOWN,1,,BYTE*,57,<empty>,,869,1,CPPASTTypeId,,<empty>
493027,UNKNOWN,1,,BYTE*,57,<empty>,,881,1,CPPASTTypeId,,<empty>
493047,UNKNOWN,1,,BYTE*,57,<empty>,,893,1,CPPASTTypeId,,<empty>
493067,UNKNOWN,1,,BYTE*,57,<empty>,,900,1,CPPASTTypeId,,<empty>
493087,UNKNOWN,1,,BYTE*,57,<empty>,,907,1,CPPASTTypeId,,<empty>
493107,UNKNOWN,1,,BYTE*,57,<empty>,,916,1,CPPASTTypeId,,<empty>
493127,UNKNOWN,1,,BYTE*,57,<empty>,,923,1,CPPASTTypeId,,<empty>
493147,UNKNOWN,1,,BYTE*,57,<empty>,,930,1,CPPASTTypeId,,<empty>
493167,UNKNOWN,1,,BYTE*,57,<empty>,,937,1,CPPASTTypeId,,<empty>
493187,UNKNOWN,1,,BYTE*,57,<empty>,,944,1,CPPASTTypeId,,<empty>
493213,UNKNOWN,1,,BYTE*,61,<empty>,,961,1,CPPASTTypeId,,<empty>
493233,UNKNOWN,1,,BYTE*,61,<empty>,,969,1,CPPASTTypeId,,<empty>
493253,UNKNOWN,1,,BYTE*,61,<empty>,,977,1,CPPASTTypeId,,<empty>
493273,UNKNOWN,1,,BYTE*,61,<empty>,,985,1,CPPASTTypeId,,<empty>
493293,UNKNOWN,1,,BYTE*,61,<empty>,,992,1,CPPASTTypeId,,<empty>
493313,UNKNOWN,1,,BYTE*,61,<empty>,,999,1,CPPASTTypeId,,<empty>
493340,UNKNOWN,1,,"static DWORD GetVersion(_In_ PCWSTR pwszDllName)
{
    DWORD dwVersion = 0;

    // We have to call for ComCtl32.dll without a path name so Fusion SxS will redirect us
    // if it thinks we are manifested properly and Fusion is enabled in this process space.
    const auto hinstDll = LoadLibrary(pwszDllName);

    if (nullptr != hinstDll)
    {
        const auto pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstDll, ""DllGetVersion"");

        // Because some DLLs might not implement this function, you must test for
        // it explicitly. Depending on the particular DLL, the lack of a DllGetVersion
        // function can be a useful indicator of the version.

        if (nullptr != pDllGetVersion)
        {
            DLLVERSIONINFO dvi = { 0 };
            dvi.cbSize = sizeof(dvi);

            if (SUCCEEDED((*pDllGetVersion)(&dvi)))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }

        FreeLibrar...",1,<empty>,,13,1,CPPASTProblemDeclaration,,<empty>
493884,UNKNOWN,2,,"[[nodiscard]] HRESULT DelegationConfig::s_GetAvailablePackages(std::vector<DelegationPackage>& packages, DelegationPackage& def) noexcept
try
{
    auto coinit = wil::CoInitializeEx(COINIT_APARTMENTTHREADED);

    packages.clear();
    packages.push_back({ DefaultDelegationPair });
    packages.push_back({ ConhostDelegationPair });

    // Get consoles and terminals.
    // If we fail to look up any, we should still have ONE come back to us as the hard-coded default console host.
    // The errors aren't really useful except for debugging, so log only.
    std::vector<DelegationBase> consoles;
    LOG_IF_FAILED(_lookupCatalog(DELEGATION_CONSOLE_EXTENSION_NAME, consoles));

    std::vector<DelegationBase> terminals;
    LOG_IF_FAILED(_lookupCatalog(DELEGATION_TERMINAL_EXTENSION_NAME, terminals));

    // TODO: I hate this algorithm (it's bad performance), but I couldn't
    // find an AppModel interface that would let me look up all the extensions
    // in one package.
    for (cons...",1,<empty>,,158,2,CPPASTProblemDeclaration,,<empty>
493999,UNKNOWN,1,,BYTE*,133,<empty>,,255,1,CPPASTTypeId,,<empty>
494080,UNKNOWN,6,,"[[nodiscard]] HRESULT DelegationConfig::s_Set(PCWSTR value, const CLSID clsid) noexcept
try
{
    wil::unique_hkey currentUserKey;
    wil::unique_hkey consoleKey;

    RETURN_IF_NTSTATUS_FAILED(RegistrySerialization::s_OpenConsoleKey(&currentUserKey, &consoleKey));

    // Create method for registry is a ""create if not exists, otherwise open"" function.
    wil::unique_hkey startupKey;
    RETURN_IF_NTSTATUS_FAILED(RegistrySerialization::s_CreateKey(consoleKey.get(), L""%%Startup"", &startupKey));

    wil::unique_cotaskmem_string str;
    RETURN_IF_FAILED(StringFromCLSID(clsid, &str));

    RETURN_IF_NTSTATUS_FAILED(RegistrySerialization::s_SetValue(startupKey.get(), value, REG_SZ, reinterpret_cast<BYTE*>(str.get()), gsl::narrow<DWORD>(wcslen(str.get()) * sizeof(wchar_t))));

    return S_OK;
}
CATCH_RETURN()",1,<empty>,,288,6,CPPASTProblemDeclaration,,<empty>
494887,UNKNOWN,10,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_LoadRegDword(const HKEY hKey, const _RegPropertyMap* const pPropMap, _In_ Settings* const pSettings)
{
    // find offset into destination structure for this numerical value
    const auto pbField = (PBYTE)pSettings + pPropMap->dwFieldOffset;

    // attempt to load number into this field
    // If we're not successful, it's ok. Just don't fill it.
    DWORD dwValue;
    auto Status = s_QueryValue(hKey,
                               pPropMap->pwszValueName,
                               sizeof(dwValue),
                               ToWin32RegistryType(pPropMap->propertyType),
                               (PBYTE)&dwValue,
                               nullptr);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        switch (pPropMap->propertyType)
        {
        case _RegPropertyType::Dword:
        {
            const auto pdField = (DWORD*)pbField;
            *pdField = dwValue;
            break;
        }
        case _RegPrope...",1,<empty>,,96,10,CPPASTProblemDeclaration,,<empty>
494888,UNKNOWN,11,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_LoadRegString(const HKEY hKey, const _RegPropertyMap* const pPropMap, _In_ Settings* const pSettings)
{
    // find offset into destination structure for this numerical value
    const auto pbField = (PBYTE)pSettings + pPropMap->dwFieldOffset;

    // number of characters within the field
    const auto cchField = pPropMap->cbFieldSize / sizeof(WCHAR);

    auto pwchString = new (std::nothrow) WCHAR[cchField];
    auto Status = NT_TESTNULL(pwchString);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        Status = s_QueryValue(hKey,
                              pPropMap->pwszValueName,
                              (DWORD)(cchField) * sizeof(WCHAR),
                              ToWin32RegistryType(pPropMap->propertyType),
                              (PBYTE)pwchString,
                              nullptr);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            // ensure pwchString is null terminated
            pwchString[cchFi...",1,<empty>,,156,11,CPPASTProblemDeclaration,,<empty>
494889,UNKNOWN,12,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_OpenConsoleKey(_Out_ HKEY* phCurrentUserKey, _Out_ HKEY* phConsoleKey)
{
    // Always set an output value. It will be made valid before the end if everything succeeds.
    *phCurrentUserKey = static_cast<HKEY>(INVALID_HANDLE_VALUE);
    *phConsoleKey = static_cast<HKEY>(INVALID_HANDLE_VALUE);

    wil::unique_hkey currentUserKey;
    wil::unique_hkey consoleKey;

    // Open the current user registry key.
    const auto win32Result = RegOpenCurrentUser(KEY_READ | KEY_WRITE, &currentUserKey);
    NTSTATUS Status = NTSTATUS_FROM_WIN32(win32Result);

    if (SUCCEEDED_NTSTATUS(Status))
    {
        // Open the console registry key.
        Status = s_OpenKey(currentUserKey.get(), CONSOLE_REGISTRY_STRING, &consoleKey);

        // If we can't open the console registry key, create one and open it.
        if (NTSTATUS_FROM_WIN32(ERROR_FILE_NOT_FOUND) == Status)
        {
            Status = s_CreateKey(currentUserKey.get(), CONSOLE_REGIS...",1,<empty>,,197,12,CPPASTProblemDeclaration,,<empty>
494890,UNKNOWN,13,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_OpenKey(_In_opt_ HKEY const hKey, _In_ PCWSTR const pwszSubKey, _Out_ HKEY* const phResult)
{
    const auto result = RegOpenKeyW(hKey, pwszSubKey, phResult);
    return NTSTATUS_FROM_WIN32(result);
}",1,<empty>,,241,13,CPPASTProblemDeclaration,,<empty>
494891,UNKNOWN,14,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_DeleteValue(const HKEY hKey, _In_ PCWSTR const pwszValueName)
{
    const auto result = RegDeleteKeyValueW(hKey, nullptr, pwszValueName);
    return result == ERROR_FILE_NOT_FOUND ? STATUS_SUCCESS : NTSTATUS_FROM_WIN32(result);
}",1,<empty>,,254,14,CPPASTProblemDeclaration,,<empty>
494892,UNKNOWN,15,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_CreateKey(const HKEY hKey, _In_ PCWSTR const pwszSubKey, _Out_ HKEY* const phResult)
{
    const auto result = RegCreateKeyW(hKey, pwszSubKey, phResult);
    return NTSTATUS_FROM_WIN32(result);
}",1,<empty>,,270,15,CPPASTProblemDeclaration,,<empty>
494893,UNKNOWN,16,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_SetValue(const HKEY hKey,
                                                         _In_ PCWSTR const pValueName,
                                                         const DWORD dwType,
                                                         _In_reads_bytes_(cbDataLength) BYTE* const pbData,
                                                         const DWORD cbDataLength)
{
    const auto result = RegSetKeyValueW(hKey,
                                        nullptr,
                                        pValueName,
                                        dwType,
                                        pbData,
                                        cbDataLength);
    return NTSTATUS_FROM_WIN32(result);
}",1,<empty>,,286,16,CPPASTProblemDeclaration,,<empty>
494894,UNKNOWN,17,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_QueryValue(const HKEY hKey,
                                                           _In_ PCWSTR const pwszValueName,
                                                           const DWORD cbValueLength,
                                                           const DWORD regType,
                                                           _Out_writes_bytes_(cbValueLength) BYTE* const pbData,
                                                           _Out_opt_ _Out_range_(0, cbValueLength) DWORD* const pcbDataLength)
{
    auto cbData = cbValueLength;

    DWORD actualRegType = 0;
    const auto Result = RegQueryValueExW(hKey,
                                         pwszValueName,
                                         nullptr,
                                         &actualRegType,
                                         pbData,
                                         &cbData);
    if (ERROR_FILE_NOT_FOUND != Result &&
      ...",1,<empty>,,312,17,CPPASTProblemDeclaration,,<empty>
494895,UNKNOWN,18,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_EnumValue(const HKEY hKey,
                                                          const DWORD dwIndex,
                                                          const DWORD cbValueLength,
                                                          _Out_writes_bytes_(cbValueLength) PWSTR const pwszValueName,
                                                          const DWORD cbDataLength,
                                                          _Out_writes_bytes_(cbDataLength) BYTE* const pbData)
{
    DWORD cchValueName = cbValueLength / sizeof(WCHAR);
    auto cbData = cbDataLength;

#pragma prefast(suppress : 26015, ""prefast doesn't realize that cbData == cbDataLength and cchValueName == cbValueLength/2"")
    const auto result = RegEnumValueW(hKey,
                                      dwIndex,
                                      pwszValueName,
                                      &cchValueName,
                               ...",1,<empty>,,353,18,CPPASTProblemDeclaration,,<empty>
494896,UNKNOWN,19,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_UpdateValue(const HKEY hConsoleKey,
                                                            const HKEY hKey,
                                                            _In_ PCWSTR const pwszValueName,
                                                            const DWORD dwType,
                                                            _In_reads_bytes_(cbDataLength) BYTE* pbData,
                                                            const DWORD cbDataLength)
{
    auto Status = STATUS_UNSUCCESSFUL; // This value won't be used, added to avoid compiler warnings.
    auto Data = new (std::nothrow) BYTE[cbDataLength];
    if (Data != nullptr)
    {
        // If this is not the main console key but the value is the same,
        // delete it. Otherwise, set it.
        auto fDeleteKey = false;
        if (hConsoleKey != hKey)
        {
            Status = s_QueryValue(hConsoleKey, pwszValueName, cbDataLength, dwType, Data, n...",1,<empty>,,388,19,CPPASTProblemDeclaration,,<empty>
494897,UNKNOWN,20,,"[[nodiscard]] NTSTATUS RegistrySerialization::s_OpenCurrentUserConsoleTitleKey(_In_ PCWSTR const title,
                                                                               _Out_ HKEY* phCurrentUserKey,
                                                                               _Out_ HKEY* phConsoleKey,
                                                                               _Out_ HKEY* phTitleKey)
{
    const auto win32Result = RegOpenKeyW(HKEY_CURRENT_USER,
                                         nullptr,
                                         phCurrentUserKey);
    NTSTATUS Status = NTSTATUS_FROM_WIN32(win32Result);
    if (SUCCEEDED_NTSTATUS(Status))
    {
        Status = RegistrySerialization::s_CreateKey(*phCurrentUserKey,
                                                    CONSOLE_REGISTRY_STRING,
                                                    phConsoleKey);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            Status = RegistrySerializatio...",1,<empty>,,425,20,CPPASTProblemDeclaration,,<empty>
494905,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_OpenKey(_In_opt_ HKEY const hKey, _In_ PCWSTR const pwszSubKey, _Out_ HKEY* const phResult);",5,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
494906,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_QueryValue(const HKEY hKey,
                                               _In_ PCWSTR const pwszValueName,
                                               const DWORD cbValueLength,
                                               const DWORD regType,
                                               _Out_writes_bytes_(cbValueLength) BYTE* const pbData,
                                               _Out_opt_ _Out_range_(0, cbValueLength) DWORD* const pcbDataLength);",5,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
494907,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_EnumValue(const HKEY hKey,
                                              const DWORD dwIndex,
                                              const DWORD cbValueLength,
                                              _Out_writes_bytes_(cbValueLength) PWSTR const pwszValueName,
                                              const DWORD cbDataLength,
                                              _Out_writes_bytes_(cbDataLength) BYTE* const pbData);",5,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
494908,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_OpenConsoleKey(_Out_ HKEY* phCurrentUserKey, _Out_ HKEY* phConsoleKey);",5,<empty>,,45,4,CPPASTProblemDeclaration,,<empty>
494909,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_CreateKey(const HKEY hKey, _In_ PCWSTR const pwszSubKey, _Out_ HKEY* const phResult);",5,<empty>,,47,5,CPPASTProblemDeclaration,,<empty>
494910,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_DeleteValue(const HKEY hKey, _In_ PCWSTR const pwszValueName);",5,<empty>,,49,6,CPPASTProblemDeclaration,,<empty>
494911,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_SetValue(const HKEY hKey,
                                             _In_ PCWSTR const pwszValueName,
                                             const DWORD dwType,
                                             _In_reads_bytes_(cbDataLength) BYTE* const pbData,
                                             const DWORD cbDataLength);",5,<empty>,,51,7,CPPASTProblemDeclaration,,<empty>
494912,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_UpdateValue(const HKEY hConsoleKey,
                                                const HKEY hKey,
                                                _In_ PCWSTR const pwszValueName,
                                                const DWORD dwType,
                                                _In_reads_bytes_(dwDataLength) BYTE* pbData,
                                                const DWORD dwDataLength);",5,<empty>,,57,8,CPPASTProblemDeclaration,,<empty>
494913,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_OpenCurrentUserConsoleTitleKey(_In_ PCWSTR const title,
                                                                   _Out_ HKEY* phCurrentUserKey,
                                                                   _Out_ HKEY* phConsoleKey,
                                                                   _Out_ HKEY* phTitleKey);",5,<empty>,,64,9,CPPASTProblemDeclaration,,<empty>
494936,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_LoadRegDword(const HKEY hKey, const _RegPropertyMap* const pPropMap, _In_ Settings* const pSettings);",5,<empty>,,95,18,CPPASTProblemDeclaration,,<empty>
494937,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_LoadRegString(const HKEY hKey, const _RegPropertyMap* const pPropMap, _In_ Settings* const pSettings);",5,<empty>,,96,19,CPPASTProblemDeclaration,,<empty>
494959,UNKNOWN,1,,"void ShortcutSerialization::s_InitPropVarFromBool(_In_ BOOL fVal, _Out_ PROPVARIANT* ppropvar)
{
    ppropvar->vt = VT_BOOL;
    ppropvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
}",1,<empty>,,13,1,CPPASTProblemDeclaration,,<empty>
494960,UNKNOWN,2,,"void ShortcutSerialization::s_InitPropVarFromByte(_In_ BYTE bVal, _Out_ PROPVARIANT* ppropvar)
{
    ppropvar->vt = VT_I2;
    ppropvar->iVal = bVal;
}",1,<empty>,,19,2,CPPASTProblemDeclaration,,<empty>
494961,UNKNOWN,3,,"void ShortcutSerialization::s_InitPropVarFromDword(_In_ DWORD dwVal, _Out_ PROPVARIANT* ppropvar)
{
    // A DWORD is a 4-byte unsigned int value, so use the ui4 member.
    // DO NOT use VT_UINT, that doesn't work with PROPVARIANTs.
    // see: https://docs.microsoft.com/en-us/windows/desktop/api/wtypes/ne-wtypes-varenum
    // also MSFT:18312914
    ppropvar->vt = VT_UI4;
    ppropvar->ulVal = dwVal;
}",1,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
494962,UNKNOWN,4,,"void ShortcutSerialization::s_SetLinkPropertyBoolValue(_In_ IPropertyStore* pps,
                                                       _In_ REFPROPERTYKEY refPropKey,
                                                       const BOOL fVal)
{
    PROPVARIANT propvarBool;
    s_InitPropVarFromBool(fVal, &propvarBool);
    pps->SetValue(refPropKey, propvarBool);
    PropVariantClear(&propvarBool);
}",1,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
494963,UNKNOWN,5,,"void ShortcutSerialization::s_SetLinkPropertyByteValue(_In_ IPropertyStore* pps,
                                                       _In_ REFPROPERTYKEY refPropKey,
                                                       const BYTE bVal)
{
    PROPVARIANT propvarByte;
    s_InitPropVarFromByte(bVal, &propvarByte);
    pps->SetValue(refPropKey, propvarByte);
    PropVariantClear(&propvarByte);
}",1,<empty>,,45,5,CPPASTProblemDeclaration,,<empty>
494964,UNKNOWN,6,,"void ShortcutSerialization::s_SetLinkPropertyDwordValue(_Inout_ IPropertyStore* pps,
                                                        _In_ REFPROPERTYKEY refPropKey,
                                                        const DWORD dwVal)
{
    PROPVARIANT propvarDword;
    s_InitPropVarFromDword(dwVal, &propvarDword);
    pps->SetValue(refPropKey, propvarDword);
    PropVariantClear(&propvarDword);
}",1,<empty>,,55,6,CPPASTProblemDeclaration,,<empty>
494965,UNKNOWN,7,,"[[nodiscard]] HRESULT ShortcutSerialization::s_GetPropertyBoolValue(_In_ IPropertyStore* const pPropStore,
                                                                    _In_ REFPROPERTYKEY refPropKey,
                                                                    _Out_ BOOL* const pfValue)
{
    PROPVARIANT propvar;
    auto hr = pPropStore->GetValue(refPropKey, &propvar);
    // Only retrieve the value if we actually found one. If the link didn't have
    //      the property (eg a new property was added_, then ignore it.
    if (SUCCEEDED(hr) && propvar.vt != VT_EMPTY)
    {
        hr = PropVariantToBoolean(propvar, pfValue);
    }

    return hr;
}",1,<empty>,,65,7,CPPASTProblemDeclaration,,<empty>
494966,UNKNOWN,8,,"[[nodiscard]] HRESULT ShortcutSerialization::s_GetPropertyByteValue(_In_ IPropertyStore* const pPropStore,
                                                                    _In_ REFPROPERTYKEY refPropKey,
                                                                    _Out_ BYTE* const pbValue)
{
    PROPVARIANT propvar;
    auto hr = pPropStore->GetValue(refPropKey, &propvar);
    // Only retrieve the value if we actually found one. If the link didn't have
    //      the property (eg a new property was added_, then ignore it.
    if (SUCCEEDED(hr) && propvar.vt != VT_EMPTY)
    {
        SHORT sValue;
        hr = PropVariantToInt16(propvar, &sValue);
        if (SUCCEEDED(hr))
        {
            hr = (sValue >= 0 && sValue <= BYTE_MAX) ? S_OK : E_INVALIDARG;
            if (SUCCEEDED(hr))
            {
                *pbValue = (BYTE)sValue;
            }
        }
    }

    return hr;
}",1,<empty>,,81,8,CPPASTProblemDeclaration,,<empty>
494967,UNKNOWN,9,,"[[nodiscard]] HRESULT ShortcutSerialization::s_GetPropertyDwordValue(_Inout_ IPropertyStore* const pPropStore,
                                                                     _In_ REFPROPERTYKEY refPropKey,
                                                                     _Out_ DWORD* const pdwValue)
{
    PROPVARIANT propvar;
    auto hr = pPropStore->GetValue(refPropKey, &propvar);
    // Only retrieve the value if we actually found one. If the link didn't have
    //      the property (eg a new property was added_, then ignore it.
    if (SUCCEEDED(hr) && propvar.vt != VT_EMPTY)
    {
        DWORD dwValue;
        hr = PropVariantToUInt32(propvar, &dwValue);
        if (SUCCEEDED(hr))
        {
            *pdwValue = dwValue;
        }
    }

    return hr;
}",1,<empty>,,106,9,CPPASTProblemDeclaration,,<empty>
494968,UNKNOWN,10,,"[[nodiscard]] HRESULT ShortcutSerialization::s_PopulateV1Properties(_In_ IShellLink* const pslConsole,
                                                                    _In_ PCONSOLE_STATE_INFO pStateInfo)
{
    IShellLinkDataList* pConsoleLnkDataList;
    auto hr = pslConsole->QueryInterface(IID_PPV_ARGS(&pConsoleLnkDataList));
    if (SUCCEEDED(hr))
    {
        // get/apply standard console properties
        NT_CONSOLE_PROPS* pNtConsoleProps = nullptr;
        hr = pConsoleLnkDataList->CopyDataBlock(NT_CONSOLE_PROPS_SIG, reinterpret_cast<void**>(&pNtConsoleProps));
        if (SUCCEEDED(hr))
        {
            pStateInfo->ScreenAttributes = pNtConsoleProps->wFillAttribute;
            pStateInfo->PopupAttributes = pNtConsoleProps->wPopupFillAttribute;
            pStateInfo->ScreenBufferSize = pNtConsoleProps->dwScreenBufferSize;
            pStateInfo->WindowSize = pNtConsoleProps->dwWindowSize;
            pStateInfo->WindowPosX = pNtConsoleProps->dwWindowOrigin.X;
     ...",1,<empty>,,127,10,CPPASTProblemDeclaration,,<empty>
494969,UNKNOWN,11,,"[[nodiscard]] HRESULT ShortcutSerialization::s_PopulateV2Properties(_In_ IShellLink* const pslConsole,
                                                                    _In_ PCONSOLE_STATE_INFO pStateInfo)
{
    IPropertyStore* pPropStoreLnk;
    auto hr = pslConsole->QueryInterface(IID_PPV_ARGS(&pPropStoreLnk));
    if (SUCCEEDED(hr))
    {
        hr = s_GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_WrapText, &pStateInfo->fWrapText);
        if (SUCCEEDED(hr))
        {
            hr = s_GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_FilterOnPaste, &pStateInfo->fFilterOnPaste);
        }
        if (SUCCEEDED(hr))
        {
            hr = s_GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_CtrlKeyShortcutsDisabled, &pStateInfo->fCtrlKeyShortcutsDisabled);
        }
        if (SUCCEEDED(hr))
        {
            hr = s_GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_LineSelection, &pStateInfo->fLineSelection);
        }
        if (SUCCEEDED(hr))
        {
            h...",1,<empty>,,179,11,CPPASTProblemDeclaration,,<empty>
494970,UNKNOWN,12,,"void ShortcutSerialization::s_GetLinkTitle(_In_ PCWSTR pwszShortcutFilename,
                                           _Out_writes_(cchShortcutTitle) PWSTR pwszShortcutTitle,
                                           const size_t cchShortcutTitle)
{
    auto Status = (cchShortcutTitle > 0) ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER_2;
    if (SUCCEEDED_NTSTATUS(Status))
    {
        pwszShortcutTitle[0] = L'\0';

        WCHAR szTemp[MAX_PATH];
        Status = StringCchCopyW(szTemp, ARRAYSIZE(szTemp), pwszShortcutFilename);
        if (SUCCEEDED_NTSTATUS(Status))
        {
            // Now load the localized title for the shortcut
            IShellItem* psi;
            auto hrShellItem = SHCreateItemFromParsingName(pwszShortcutFilename, nullptr, IID_PPV_ARGS(&psi));
            if (SUCCEEDED(hrShellItem))
            {
                PWSTR pwszShortcutDisplayName;
                hrShellItem = psi->GetDisplayName(SIGDN_NORMALDISPLAY, &pwszShortcutDisplayName);
            ...",1,<empty>,,241,12,CPPASTProblemDeclaration,,<empty>
494971,UNKNOWN,13,,"[[nodiscard]] HRESULT ShortcutSerialization::s_GetLoadedShellLinkForShortcut(_In_ PCWSTR pwszShortcutFileName,
                                                                             const DWORD dwMode,
                                                                             _COM_Outptr_ IShellLink** ppsl,
                                                                             _COM_Outptr_ IPersistFile** ppPf)
{
    *ppsl = nullptr;
    *ppPf = nullptr;
    IShellLink* psl;
    auto hr = SHCoCreateInstance(nullptr, &CLSID_ShellLink, nullptr, IID_PPV_ARGS(&psl));
    if (SUCCEEDED(hr))
    {
        IPersistFile* pPf;
        hr = psl->QueryInterface(IID_PPV_ARGS(&pPf));
        if (SUCCEEDED(hr))
        {
            hr = pPf->Load(pwszShortcutFileName, dwMode);
            if (SUCCEEDED(hr))
            {
                hr = psl->QueryInterface(IID_PPV_ARGS(ppsl));
                if (SUCCEEDED(hr))
                {
                    hr = pPf->QueryInterface(IID_...",1,<empty>,,285,13,CPPASTProblemDeclaration,,<empty>
494972,UNKNOWN,14,,"[[nodiscard]] NTSTATUS ShortcutSerialization::s_GetLinkConsoleProperties(_Inout_ PCONSOLE_STATE_INFO pStateInfo)
{
    IShellLink* psl;
    IPersistFile* ppf;
    auto hr = s_GetLoadedShellLinkForShortcut(pStateInfo->LinkTitle, STGM_READ, &psl, &ppf);
    if (SUCCEEDED(hr))
    {
        hr = s_PopulateV1Properties(psl, pStateInfo);
        if (SUCCEEDED(hr))
        {
            hr = s_PopulateV2Properties(psl, pStateInfo);
        }

        ppf->Release();
        psl->Release();
    }
    return (SUCCEEDED(hr)) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}",1,<empty>,,323,14,CPPASTProblemDeclaration,,<empty>
494973,UNKNOWN,15,,"[[nodiscard]] NTSTATUS ShortcutSerialization::s_GetLinkValues(_Inout_ PCONSOLE_STATE_INFO pStateInfo,
                                                              _Out_ BOOL* const pfReadConsoleProperties,
                                                              _Out_writes_opt_(cchShortcutTitle) PWSTR pwszShortcutTitle,
                                                              const size_t cchShortcutTitle,
                                                              _Out_writes_opt_(cchLinkTarget) PWSTR pwszLinkTarget,
                                                              const size_t cchLinkTarget,
                                                              _Out_writes_opt_(cchIconLocation) PWSTR pwszIconLocation,
                                                              const size_t cchIconLocation,
                                                              _Out_opt_ int* const piIcon,
                                                              _Out...",1,<empty>,,343,15,CPPASTProblemDeclaration,,<empty>
494974,UNKNOWN,16,,"[[nodiscard]] NTSTATUS ShortcutSerialization::s_SetLinkValues(_In_ PCONSOLE_STATE_INFO pStateInfo,
                                                              const BOOL fEastAsianSystem,
                                                              const BOOL fForceV2,
                                                              const bool writeTerminalSettings)
{
    IShellLinkW* psl;
    IPersistFile* ppf;
    auto hr = s_GetLoadedShellLinkForShortcut(pStateInfo->LinkTitle, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &psl, &ppf);
    if (SUCCEEDED(hr))
    {
        IShellLinkDataList* psldl;
        hr = psl->QueryInterface(IID_PPV_ARGS(&psldl));
        if (SUCCEEDED(hr))
        {
            // Now the link is loaded, generate new console settings section to replace the one in the link.
            NT_CONSOLE_PROPS props;
            ((LPDBLIST)&props)->cbSize = sizeof(props);
            ((LPDBLIST)&props)->dwSignature = NT_CONSOLE_PROPS_SIG;
            props.wFillAttribute =...",1,<empty>,,433,16,CPPASTProblemDeclaration,,<empty>
494981,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_SetLinkValues(_In_ PCONSOLE_STATE_INFO pStateInfo, const BOOL fEastAsianSystem, const BOOL fForceV2, const bool writeTerminalSettings);",5,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
494982,UNKNOWN,-1,,[[nodiscard]] static NTSTATUS s_GetLinkConsoleProperties(_Inout_ PCONSOLE_STATE_INFO pStateInfo);,5,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
494983,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_GetLinkValues(_Inout_ PCONSOLE_STATE_INFO pStateInfo,
                                                  _Out_ BOOL* const pfReadConsoleProperties,
                                                  _Out_writes_opt_(cchShortcutTitle) PWSTR pwszShortcutTitle,
                                                  const size_t cchShortcutTitle,
                                                  _Out_writes_opt_(cchLinkTarget) PWSTR pwszLinkTarget,
                                                  const size_t cchLinkTarget,
                                                  _Out_writes_opt_(cchIconLocation) PWSTR pwszIconLocation,
                                                  const size_t cchIconLocation,
                                                  _Out_opt_ int* const piIcon,
                                                  _Out_opt_ int* const piShowCmd,
                                                  _Out_opt_ WORD* const pwHotKey);",5,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
494984,UNKNOWN,-1,,"static void s_InitPropVarFromBool(_In_ BOOL fVal, _Out_ PROPVARIANT* ppropvar);",5,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
494985,UNKNOWN,-1,,"static void s_InitPropVarFromByte(_In_ BYTE bVal, _Out_ PROPVARIANT* ppropvar);",5,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
494986,UNKNOWN,-1,,"static void s_InitPropVarFromDword(_In_ DWORD dwVal, _Out_ PROPVARIANT* ppropvar);",5,<empty>,,44,6,CPPASTProblemDeclaration,,<empty>
494987,UNKNOWN,-1,,"static void s_SetLinkPropertyBoolValue(_In_ IPropertyStore* pps, _In_ REFPROPERTYKEY refPropKey, const BOOL fVal);",5,<empty>,,46,7,CPPASTProblemDeclaration,,<empty>
494988,UNKNOWN,-1,,"static void s_SetLinkPropertyByteValue(_In_ IPropertyStore* pps, _In_ REFPROPERTYKEY refPropKey, const BYTE bVal);",5,<empty>,,47,8,CPPASTProblemDeclaration,,<empty>
494989,UNKNOWN,-1,,"static void s_SetLinkPropertyDwordValue(_In_ IPropertyStore* pps, _In_ REFPROPERTYKEY refPropKey, const DWORD dwVal);",5,<empty>,,48,9,CPPASTProblemDeclaration,,<empty>
494990,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetPropertyBoolValue(_In_ IPropertyStore* const pPropStore,
                                                        _In_ REFPROPERTYKEY refPropKey,
                                                        _Out_ BOOL* const pfValue);",5,<empty>,,50,10,CPPASTProblemDeclaration,,<empty>
494991,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetPropertyByteValue(_In_ IPropertyStore* const pPropStore,
                                                        _In_ REFPROPERTYKEY refPropKey,
                                                        _Out_ BYTE* const pbValue);",5,<empty>,,53,11,CPPASTProblemDeclaration,,<empty>
494992,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetPropertyDwordValue(_In_ IPropertyStore* const pPropStore,
                                                         _In_ REFPROPERTYKEY refPropKey,
                                                         _Out_ DWORD* const pdwValue);",5,<empty>,,56,12,CPPASTProblemDeclaration,,<empty>
494993,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_PopulateV1Properties(_In_ IShellLink* const pslConsole, _In_ PCONSOLE_STATE_INFO pStateInfo);",5,<empty>,,60,13,CPPASTProblemDeclaration,,<empty>
494994,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_PopulateV2Properties(_In_ IShellLink* const pslConsole, _In_ PCONSOLE_STATE_INFO pStateInfo);",5,<empty>,,61,14,CPPASTProblemDeclaration,,<empty>
494995,UNKNOWN,-1,,"static void s_GetLinkTitle(_In_ PCWSTR pwszShortcutFilename, _Out_writes_(cchShortcutTitle) PWSTR pwszShortcutTitle, const size_t cchShortcutTitle);",5,<empty>,,63,15,CPPASTProblemDeclaration,,<empty>
494996,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_GetLoadedShellLinkForShortcut(_In_ PCWSTR pwszShortcutFileName,
                                                                 const DWORD dwMode,
                                                                 _COM_Outptr_ IShellLink** ppsl,
                                                                 _COM_Outptr_ IPersistFile** ppPf);",5,<empty>,,64,16,CPPASTProblemDeclaration,,<empty>
495009,UNKNOWN,2,,"WORD ConvertStringToDec(
    __in LPTSTR lpch)
{
    TCHAR ch;
    WORD val = 0;

    while ((ch = *lpch) != TEXT('\0'))
    {
        if (TEXT('0') <= ch && ch <= TEXT('9'))
            val = (val * 10) + (ch - TEXT('0'));
        else
            break;

        lpch++;
    }

    return val;
}",1,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
495054,UNKNOWN,1,,LPWSTR,58,<empty>,,58,1,CPPASTTypeId,,<empty>
495059,UNKNOWN,1,,PBYTE,58,<empty>,,60,1,CPPASTTypeId,,<empty>
495078,UNKNOWN,1,,TTFONTLIST*,28,<empty>,,73,1,CPPASTTypeId,,<empty>
495206,UNKNOWN,1,,LPTTFONTLIST,29,<empty>,,128,1,CPPASTTypeId,,<empty>
495228,UNKNOWN,5,,"LPTTFONTLIST TrueTypeFontList::s_SearchByName(_In_opt_ LPCWSTR pwszFace,
                                              _In_ BOOL fCodePage,
                                              _In_ UINT CodePage)
{
    auto pTemp = s_ttFontList.Next;

    if (pwszFace)
    {
        while (pTemp != nullptr)
        {
            auto pTTFontList = (LPTTFONTLIST)pTemp;

            if (wcscmp(pwszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(pwszFace, pTTFontList->FaceName2) == 0)
            {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage)
                        return pTTFontList;
                    else
                        return nullptr;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return nullptr;
}",1,<empty>,,141,5,CPPASTProblemDeclaration,,<empty>
495229,UNKNOWN,6,,"[[nodiscard]] NTSTATUS TrueTypeFontList::s_SearchByCodePage(const UINT uiCodePage,
                                                            _Out_writes_(cchFaceName) PWSTR pwszFaceName,
                                                            const size_t cchFaceName)
{
    auto status = STATUS_SUCCESS;
    auto fFontFound = FALSE;

    // Look through our list entries to see if we can find a corresponding truetype font for this codepage
    for (auto pListEntry = s_ttFontList.Next; pListEntry != nullptr && !fFontFound; pListEntry = pListEntry->Next)
    {
        auto pTTFontEntry = (LPTTFONTLIST)pListEntry;
        if (pTTFontEntry->CodePage == uiCodePage)
        {
            // found a match, use this font's primary facename
            status = StringCchCopyW(pwszFaceName, cchFaceName, pTTFontEntry->FaceName1);
            fFontFound = TRUE;
        }
    }

    if (!fFontFound)
    {
        status = StringCchCopyW(pwszFaceName, cchFaceName, DEFAULT_NON_DBCS_FONTFACE);
...",1,<empty>,,172,6,CPPASTProblemDeclaration,,<empty>
495245,UNKNOWN,-1,,"static LPTTFONTLIST s_SearchByName(_In_opt_ LPCWSTR pwszFace,
                                       _In_ BOOL fCodePage,
                                       _In_ UINT CodePage);",5,<empty>,,26,4,CPPASTProblemDeclaration,,<empty>
495246,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS s_SearchByCodePage(const UINT uiCodePage,
                                                     _Out_writes_(cchFaceName) PWSTR pwszFaceName,
                                                     const size_t cchFaceName);",5,<empty>,,30,5,CPPASTProblemDeclaration,,<empty>
495295,UNKNOWN,2,,Y,18,<empty>,,40,2,CPPASTProblemDeclaration,,<empty>
495296,UNKNOWN,3,,"PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead)
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;
    if (FirstEntry != nullptr)
    {
        ListHead->Next = FirstEntry->Next;
    }

    return FirstEntry;
}",1,<empty>,,41,3,CPPASTProblemDeclaration,,<empty>
495297,UNKNOWN,4,,"FORCEINLINE
VOID PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PSINGLE_LIST_ENTRY Entry)

{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
    return;
}",1,<empty>,,55,4,CPPASTProblemDeclaration,,<empty>
495318,UNKNOWN,1,,T,23,<empty>,,32,1,CPPASTTypeId,,<empty>
495325,UNKNOWN,1,,U,24,<empty>,,33,1,CPPASTTypeId,,<empty>
495885,UNKNOWN,9,,"[[nodiscard]] HRESULT AtlasEngine::InvalidateFlush(_In_ const bool /*circled*/, _Out_ bool* const pForcePaint) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pForcePaint);
    *pForcePaint = false;
    return S_OK;
}",1,<empty>,,140,9,CPPASTProblemDeclaration,,<empty>
495905,UNKNOWN,12,,"[[nodiscard]] HRESULT AtlasEngine::UpdateFont(const FontInfoDesired& fontInfoDesired, _Out_ FontInfo& fontInfo) noexcept
{
    return UpdateFont(fontInfoDesired, fontInfo, {}, {});
}",1,<empty>,,158,12,CPPASTProblemDeclaration,,<empty>
496009,UNKNOWN,15,,"[[nodiscard]] HRESULT AtlasEngine::UpdateViewport(const til::inclusive_rect& srNewViewport) noexcept
try
{
    const u16x2 viewportCellCount{
        gsl::narrow<u16>(std::max(1, srNewViewport.right - srNewViewport.left + 1)),
        gsl::narrow<u16>(std::max(1, srNewViewport.bottom - srNewViewport.top + 1)),
    };
    const u16x2 viewportOffset{
        gsl::narrow<u16>(srNewViewport.left),
        gsl::narrow<u16>(srNewViewport.top),
    };

    if (_api.s->viewportCellCount != viewportCellCount)
    {
        _api.s.write()->viewportCellCount = viewportCellCount;
    }
    if (_api.s->viewportOffset != viewportOffset)
    {
        _api.s.write()->viewportOffset = viewportOffset;
    }

    return S_OK;
}
CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::GetProposedFont(const FontInfoDesired& fontInfoDesired, _Out_ FontInfo& fontInfo, const int dpi) noexcept
try
{
    // One day I'm going to implement GDI for AtlasEngine...
    // Until then this code is work in progress.
#if ...",1,<empty>,,185,15,CPPASTProblemDeclaration,,<empty>
496010,UNKNOWN,16,,"CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::GetDirtyArea(std::span<const til::rect>& area) noexcept
{
    area = std::span{ &_api.dirtyRect, 1 };
    return S_OK;
}",1,<empty>,,270,16,CPPASTProblemDeclaration,,<empty>
496011,UNKNOWN,17,,"[[nodiscard]] HRESULT AtlasEngine::GetFontSize(_Out_ til::size* pFontSize) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pFontSize);
    pFontSize->width = _api.s->font->cellSize.x;
    pFontSize->height = _api.s->font->cellSize.y;
    return S_OK;
}",1,<empty>,,278,17,CPPASTProblemDeclaration,,<empty>
496012,UNKNOWN,18,,"[[nodiscard]] HRESULT AtlasEngine::IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pResult);

    wil::com_ptr<IDWriteTextFormat> textFormat;
    RETURN_IF_FAILED(_p.dwriteFactory->CreateTextFormat(
        /* fontFamilyName */ _api.s->font->fontName.c_str(),
        /* fontCollection */ _api.s->font->fontCollection.get(),
        /* fontWeight     */ static_cast<DWRITE_FONT_WEIGHT>(_api.s->font->fontWeight),
        /* fontStyle      */ DWRITE_FONT_STYLE_NORMAL,
        /* fontStretch    */ DWRITE_FONT_STRETCH_NORMAL,
        /* fontSize       */ _api.s->font->fontSize,
        /* localeName     */ L"""",
        /* textFormat     */ textFormat.put()));

    wil::com_ptr<IDWriteTextLayout> textLayout;
    RETURN_IF_FAILED(_p.dwriteFactory->CreateTextLayout(glyph.data(), gsl::narrow_cast<uint32_t>(glyph.size()), textFormat.get(), FLT_MAX, FLT_MAX, textLayout.addressof()));

    DWRITE_TEXT_METRICS metrics{};
  ...",1,<empty>,,286,18,CPPASTProblemDeclaration,,<empty>
496055,UNKNOWN,1,,f32,24,<empty>,,338,1,CPPASTTypeId,,<empty>
496064,UNKNOWN,1,,f32,62,<empty>,,338,1,CPPASTTypeId,,<empty>
496213,UNKNOWN,1,,AntialiasingMode,35,<empty>,,357,1,CPPASTTypeId,,<empty>
496300,UNKNOWN,31,,"void AtlasEngine::SetPixelShaderPath(std::wstring_view value) noexcept
try
{
    if (_api.s->misc->customPixelShaderPath != value)
    {
        _api.s.write()->misc.write()->customPixelShaderPath = value;
        _resolveTransparencySettings();
    }
}
CATCH_LOG()

void AtlasEngine::SetRetroTerminalEffect(bool enable) noexcept
{
    if (_api.s->misc->useRetroTerminalEffect != enable)
    {
        _api.s.write()->misc.write()->useRetroTerminalEffect = enable;
        _resolveTransparencySettings();
    }
}",1,<empty>,,392,31,CPPASTProblemDeclaration,,<empty>
496465,UNKNOWN,-1,,"try
    {
        _updateFont(fontInfoDesired.GetFaceName().c_str(), fontInfoDesired, fontInfo, features, axes);
        return S_OK;
    }
    CATCH_LOG();",5,<empty>,,458,1,CPPASTProblemStatement,,<empty>
496472,UNKNOWN,-1,,"try
        {
            // _resolveFontMetrics() checks `_api.s->font->fontCollection` for a pre-existing font collection,
            // before falling back to using the system font collection. This way we can inject our custom one. See GH#9375.
            // Doing it this way is a bit hacky, but it does have the benefit that we can cache a font collection
            // instance across font changes, like when zooming the font size rapidly using the scroll wheel.
            _api.s.write()->font.write()->fontCollection = FontCache::GetCached();
            _updateFont(fontInfoDesired.GetFaceName().c_str(), fontInfoDesired, fontInfo, features, axes);
            return S_OK;
        }
        CATCH_LOG();",9,<empty>,,467,1,CPPASTProblemStatement,,<empty>
496473,UNKNOWN,-1,,"try
    {
        _updateFont(nullptr, fontInfoDesired, fontInfo, features, axes);
        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,480,3,CPPASTProblemStatement,,<empty>
496997,UNKNOWN,1,,DWRITE_FONT_WEIGHT,66,<empty>,,636,1,CPPASTTypeId,,<empty>
497035,UNKNOWN,1,,f32,34,<empty>,,647,1,CPPASTTypeId,,<empty>
497057,UNKNOWN,1,,f32,62,<empty>,,650,1,CPPASTTypeId,,<empty>
497066,UNKNOWN,1,,f32,37,<empty>,,651,1,CPPASTTypeId,,<empty>
497076,UNKNOWN,1,,f32,38,<empty>,,652,1,CPPASTTypeId,,<empty>
497086,UNKNOWN,1,,f32,38,<empty>,,653,1,CPPASTTypeId,,<empty>
497096,UNKNOWN,1,,f32,48,<empty>,,654,1,CPPASTTypeId,,<empty>
497107,UNKNOWN,1,,f32,49,<empty>,,655,1,CPPASTTypeId,,<empty>
497117,UNKNOWN,1,,f32,52,<empty>,,656,1,CPPASTTypeId,,<empty>
497128,UNKNOWN,1,,f32,53,<empty>,,657,1,CPPASTTypeId,,<empty>
497185,UNKNOWN,1,,f32,40,<empty>,,674,1,CPPASTTypeId,,<empty>
497749,UNKNOWN,-1,,static constexpr D2D1_FACTORY_OPTIONS options{ .debugLevel = D2D1_DEBUG_LEVEL_INFORMATION,5,<empty>,,33,1,CPPASTProblemStatement,,<empty>
497752,UNKNOWN,2,,"THROW_IF_FAILED(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, __uuidof(_p.d2dFactory), &options, reinterpret_cast<void**>(_p.d2dFactory.addressof())));",5,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
497753,UNKNOWN,3,,"THROW_IF_FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(_p.dwriteFactory), reinterpret_cast<::IUnknown**>(_p.dwriteFactory.addressof())));",5,<empty>,,37,3,CPPASTProblemDeclaration,,<empty>
497754,UNKNOWN,4,,_p.dwriteFactory4 = _p.dwriteFactory.try_query<IDWriteFactory4>();,5,<empty>,,38,4,CPPASTProblemDeclaration,,<empty>
497755,UNKNOWN,5,,THROW_IF_FAILED(_p.dwriteFactory->GetSystemFontFallback(_p.systemFontFallback.addressof()));,5,<empty>,,40,5,CPPASTProblemDeclaration,,<empty>
497756,UNKNOWN,6,,_p.systemFontFallback1 = _p.systemFontFallback.try_query<IDWriteFontFallback1>();,5,<empty>,,41,6,CPPASTProblemDeclaration,,<empty>
497758,UNKNOWN,8,,THROW_IF_FAILED(_p.dwriteFactory->CreateTextAnalyzer(textAnalyzer.addressof()));,5,<empty>,,44,8,CPPASTProblemDeclaration,,<empty>
497759,UNKNOWN,9,,_p.textAnalyzer = textAnalyzer.query<IDWriteTextAnalyzer1>();,5,<empty>,,45,9,CPPASTProblemDeclaration,,<empty>
497760,UNKNOWN,10,,},1,<empty>,,46,10,CPPASTProblemDeclaration,,<empty>
497761,UNKNOWN,11,,"[[nodiscard]] HRESULT AtlasEngine::StartPaint() noexcept
try
{
    if (const auto hwnd = _api.s->target->hwnd)
    {
        RECT rect;
        LOG_IF_WIN32_BOOL_FALSE(GetClientRect(hwnd, &rect));
        std::ignore = SetWindowSize({ rect.right - rect.left, rect.bottom - rect.top });

        if (_api.invalidatedTitle)
        {
            LOG_IF_WIN32_BOOL_FALSE(PostMessageW(hwnd, CM_UPDATE_TITLE, 0, 0));
            _api.invalidatedTitle = false;
        }
    }

    if (_p.s != _api.s)
    {
        _handleSettingsUpdate();
    }

    if constexpr (ATLAS_DEBUG_DISABLE_PARTIAL_INVALIDATION)
    {
        _api.invalidatedRows = invalidatedRowsAll;
        _api.scrollOffset = 0;
    }

    // Clamp invalidation rects into valid value ranges.
    {
        _api.invalidatedCursorArea.left = std::min(_api.invalidatedCursorArea.left, _p.s->viewportCellCount.x);
        _api.invalidatedCursorArea.top = std::min(_api.invalidatedCursorArea.top, _p.s->viewportCellCount.y);
        _api.in...",1,<empty>,,52,11,CPPASTProblemDeclaration,,<empty>
497762,UNKNOWN,12,,"CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pForcePaint);
    *pForcePaint = false;
    return S_OK;
}",1,<empty>,,270,12,CPPASTProblemDeclaration,,<empty>
497831,UNKNOWN,18,,"[[nodiscard]] HRESULT AtlasEngine::PaintBufferLine(std::span<const Cluster> clusters, til::point coord, const bool fTrimLeft, const bool lineWrapped) noexcept
try
{
    const auto y = gsl::narrow_cast<u16>(clamp<int>(coord.y, 0, _p.s->viewportCellCount.y));

    if (_api.lastPaintBufferLineCoord.y != y)
    {
        _flushBufferLine();
    }

    const auto shift = gsl::narrow_cast<u8>(_api.lineRendition != LineRendition::SingleWidth);
    const auto x = gsl::narrow_cast<u16>(clamp<int>(coord.x - (_p.s->viewportOffset.x >> shift), 0, _p.s->viewportCellCount.x));
    auto columnEnd = x;

    // _api.bufferLineColumn contains 1 more item than _api.bufferLine, as it represents the
    // past-the-end index. It'll get appended again later once we built our new _api.bufferLine.
    if (!_api.bufferLineColumn.empty())
    {
        _api.bufferLineColumn.pop_back();
    }

    // Due to the current IRenderEngine interface (that wasn't refactored yet) we need to assemble
    // the current...",1,<empty>,,307,18,CPPASTProblemDeclaration,,<empty>
497832,UNKNOWN,19,,"CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::PaintSelection(const til::rect& rect) noexcept
try
{
    // Unfortunately there's no step after Renderer::_PaintBufferOutput that
    // would inform us that it's done with the last AtlasEngine::PaintBufferLine.
    // As such we got to call _flushBufferLine() here just to be sure.
    _flushBufferLine();

    const auto y = gsl::narrow_cast<u16>(clamp<til::CoordType>(rect.top, 0, _p.s->viewportCellCount.y));
    const auto from = gsl::narrow_cast<u16>(clamp<til::CoordType>(rect.left, 0, _p.s->viewportCellCount.x - 1));
    const auto to = gsl::narrow_cast<u16>(clamp<til::CoordType>(rect.right, from, _p.s->viewportCellCount.x));

    auto& row = *_p.rows[y];
    row.selectionFrom = from;
    row.selectionTo = to;

    _p.dirtyRectInPx.left = std::min(_p.dirtyRectInPx.left, from * _p.s->font->cellSize.x);
    _p.dirtyRectInPx.top = std::min(_p.dirtyRectInPx.top, y * _p.s->font->cellSize.y);
    _p.dirtyRectInPx.right = std::max(_p.di...",1,<empty>,,391,19,CPPASTProblemDeclaration,,<empty>
497833,UNKNOWN,20,,"CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::PaintCursor(const CursorOptions& options) noexcept
try
{
    // Unfortunately there's no step after Renderer::_PaintBufferOutput that
    // would inform us that it's done with the last AtlasEngine::PaintBufferLine.
    // As such we got to call _flushBufferLine() here just to be sure.
    _flushBufferLine();

    {
        const CursorSettings cachedOptions{
            .cursorColor = gsl::narrow_cast<u32>(options.fUseColor ? options.cursorColor | 0xff000000 : INVALID_COLOR),
            .cursorType = gsl::narrow_cast<u16>(options.cursorType),
            .heightPercentage = gsl::narrow_cast<u16>(options.ulCursorHeightPercent),
        };
        if (*_api.s->cursor != cachedOptions)
        {
            *_api.s.write()->cursor.write() = cachedOptions;
            *_p.s.write()->cursor.write() = cachedOptions;
        }
    }

    if (options.isOn)
    {
        const auto cursorWidth = 1 + (options.fIsDoubleWidth & (options.curso...",1,<empty>,,415,20,CPPASTProblemDeclaration,,<empty>
497834,UNKNOWN,21,,"CATCH_RETURN()

[[nodiscard]] HRESULT AtlasEngine::UpdateDrawingBrushes(const TextAttribute& textAttributes, const RenderSettings& renderSettings, const gsl::not_null<IRenderData*> /*pData*/, const bool usingSoftFont, const bool isSettingDefaultBrushes) noexcept
try
{
    auto [fg, bg] = renderSettings.GetAttributeColorsWithAlpha(textAttributes);
    fg |= 0xff000000;
    bg |= _api.backgroundOpaqueMixin;

    if (!isSettingDefaultBrushes)
    {
        auto attributes = FontRelevantAttributes::None;
        WI_SetFlagIf(attributes, FontRelevantAttributes::Bold, textAttributes.IsIntense() && renderSettings.GetRenderMode(RenderSettings::Mode::IntenseIsBold));
        WI_SetFlagIf(attributes, FontRelevantAttributes::Italic, textAttributes.IsItalic());

        if (_api.attributes != attributes)
        {
            _flushBufferLine();
        }

        _api.currentBackground = gsl::narrow_cast<u32>(bg);
        _api.currentForeground = gsl::narrow_cast<u32>(fg);
        _api.attribu...",1,<empty>,,468,21,CPPASTProblemDeclaration,,<empty>
497835,UNKNOWN,22,,"CATCH_RETURN()

#pragma endregion

void AtlasEngine::_handleSettingsUpdate()
{
    const auto targetChanged = _p.s->target != _api.s->target;
    const auto fontChanged = _p.s->font != _api.s->font;
    const auto cellCountChanged = _p.s->viewportCellCount != _api.s->viewportCellCount;

    _p.s = _api.s;

    if (targetChanged)
    {
        // target->useSoftwareRendering affects the selection of our IDXGIAdapter which requires us to reset _p.dxgi.
        // This will indirectly also recreate the backend, when AtlasEngine::_recreateAdapter() detects this change.
        _p.dxgi = {};
    }
    if (fontChanged)
    {
        _recreateFontDependentResources();
    }
    if (cellCountChanged)
    {
        _recreateCellCountDependentResources();
    }

    _api.invalidatedRows = invalidatedRowsAll;
}",1,<empty>,,500,22,CPPASTProblemDeclaration,,<empty>
497943,UNKNOWN,1,,size_t,48,<empty>,,564,1,CPPASTTypeId,,<empty>
497955,UNKNOWN,1,,size_t,50,<empty>,,565,1,CPPASTTypeId,,<empty>
497978,UNKNOWN,1,,f32,113,<empty>,,567,1,CPPASTTypeId,,<empty>
498053,UNKNOWN,1,,size_t,48,<empty>,,580,1,CPPASTTypeId,,<empty>
498185,UNKNOWN,1,,size_t,44,<empty>,,605,1,CPPASTTypeId,,<empty>
498635,UNKNOWN,1,,f32,68,<empty>,,686,1,CPPASTTypeId,,<empty>
498774,UNKNOWN,1,,size_t,66,<empty>,,722,1,CPPASTTypeId,,<empty>
498831,UNKNOWN,1,,IDWriteFontFace5**,55,<empty>,,740,1,CPPASTTypeId,,<empty>
498848,UNKNOWN,1,,DWRITE_FONT_WEIGHT,133,<empty>,,744,1,CPPASTTypeId,,<empty>
498926,UNKNOWN,1,,IDWriteFontFace**,67,<empty>,,763,1,CPPASTTypeId,,<empty>
499029,UNKNOWN,1,,DWRITE_FONT_FEATURE*,43,<empty>,,799,1,CPPASTTypeId,,<empty>
499092,UNKNOWN,1,,size_t,56,<empty>,,808,1,CPPASTTypeId,,<empty>
499852,UNKNOWN,1,,u16,37,<empty>,,967,1,CPPASTTypeId,,<empty>
499882,UNKNOWN,1,,f32,52,<empty>,,971,1,CPPASTTypeId,,<empty>
500082,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;,9,<empty>,,30,9,CPPASTProblemDeclaration,,<empty>
500116,UNKNOWN,-1,,"[[nodiscard]] HRESULT InvalidateFlush(_In_ const bool circled, _Out_ bool* const pForcePaint) noexcept override;",9,<empty>,,38,17,CPPASTProblemDeclaration,,<empty>
500183,UNKNOWN,-1,,"[[nodiscard]] HRESULT UpdateFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo) noexcept override;",9,<empty>,,50,29,CPPASTProblemDeclaration,,<empty>
500201,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProposedFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo, int iDpi) noexcept override;",9,<empty>,,54,33,CPPASTProblemDeclaration,,<empty>
500207,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* pFontSize) noexcept override;,9,<empty>,,56,35,CPPASTProblemDeclaration,,<empty>
500208,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(std::wstring_view glyph, _Out_ bool* pResult) noexcept override;",9,<empty>,,57,36,CPPASTProblemDeclaration,,<empty>
500603,UNKNOWN,2,,"CATCH_RETURN()

[[nodiscard]] bool AtlasEngine::RequiresContinuousRedraw() noexcept
{
    return ATLAS_DEBUG_CONTINUOUS_REDRAW || (_b && _b->RequiresContinuousRedraw());
}",1,<empty>,,76,2,CPPASTProblemDeclaration,,<empty>
501177,UNKNOWN,-1,,1,25,<empty>,,312,3,CPPASTProblemStatement,,<empty>
501439,UNKNOWN,-1,,"try
        {
            _p.swapChainChangedCallback(_p.swapChain.handle.get());
        }
        CATCH_LOG()",9,<empty>,,369,1,CPPASTProblemStatement,,<empty>
501544,UNKNOWN,-1,,"const DXGI_MATRIX_3X2_F matrix{
            ._11 = static_cast<f32>(USER_DEFAULT_SCREEN_DPI) / static_cast<f32>(_p.s->font->dpi),
            ._22 = static_cast<f32>(USER_DEFAULT_SCREEN_DPI) / static_cast<f32>(_p.s->font->dpi),",9,<empty>,,411,1,CPPASTProblemStatement,,<empty>
501558,UNKNOWN,13,,_p.swapChain.fontGeneration = _p.s->font.generation();,5,<empty>,,417,13,CPPASTProblemDeclaration,,<empty>
501559,UNKNOWN,14,,},1,<empty>,,418,14,CPPASTProblemDeclaration,,<empty>
501630,UNKNOWN,-1,,T,8,<empty>,,444,10,CPPASTProblemStatement,,<empty>
501895,UNKNOWN,1,,TIL_FAST_MATH_BEGIN,1,<empty>,,7,1,CPPASTProblemDeclaration,,<empty>
502211,UNKNOWN,8,,TIL_FAST_MATH_END,1,<empty>,,107,8,CPPASTProblemDeclaration,,<empty>
502231,UNKNOWN,1,,f32,36,<empty>,,38,1,CPPASTTypeId,,<empty>
502243,UNKNOWN,1,,f32,36,<empty>,,39,1,CPPASTTypeId,,<empty>
502255,UNKNOWN,1,,f32,36,<empty>,,40,1,CPPASTTypeId,,<empty>
502267,UNKNOWN,1,,f32,36,<empty>,,41,1,CPPASTTypeId,,<empty>
502285,UNKNOWN,1,,f32,36,<empty>,,48,1,CPPASTTypeId,,<empty>
502297,UNKNOWN,1,,f32,36,<empty>,,49,1,CPPASTTypeId,,<empty>
502309,UNKNOWN,1,,f32,36,<empty>,,50,1,CPPASTTypeId,,<empty>
502321,UNKNOWN,1,,f32,36,<empty>,,51,1,CPPASTTypeId,,<empty>
502513,UNKNOWN,1,,f32,46,<empty>,,410,1,CPPASTTypeId,,<empty>
502521,UNKNOWN,1,,f32,46,<empty>,,411,1,CPPASTTypeId,,<empty>
502639,UNKNOWN,1,,f32,49,<empty>,,431,1,CPPASTTypeId,,<empty>
502651,UNKNOWN,1,,f32,49,<empty>,,432,1,CPPASTTypeId,,<empty>
502681,UNKNOWN,1,,TIL_FAST_MATH_BEGIN,1,<empty>,,15,1,CPPASTProblemDeclaration,,<empty>
502806,UNKNOWN,1,,void**,109,<empty>,,77,1,CPPASTTypeId,,<empty>
502818,UNKNOWN,-1,,"const D2D1_RENDER_TARGET_PROPERTIES props{
                .type = D2D1_RENDER_TARGET_TYPE_DEFAULT,
                .pixelFormat = { DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED }",13,<empty>,,80,5,CPPASTProblemStatement,,<empty>
502819,UNKNOWN,-1,,",
                .dpiX = static_cast<f32>(p.s->font->dpi),
                .dpiY = static_cast<f32>(p.s->font->dpi),",93,<empty>,,82,6,CPPASTProblemStatement,,<empty>
502834,UNKNOWN,1,,ID2D1RenderTarget**,113,<empty>,,87,1,CPPASTTypeId,,<empty>
502891,UNKNOWN,6,,"if (!_dottedStrokeStyle)
    {
        static constexpr D2D1_STROKE_STYLE_PROPERTIES props{ .dashStyle = D2D1_DASH_STYLE_CUSTOM };
        static constexpr FLOAT dashes[2]{ 1, 1 };
        THROW_IF_FAILED(p.d2dFactory->CreateStrokeStyle(&props, &dashes[0], 2, _dottedStrokeStyle.addressof()));
    }",5,<empty>,,101,6,CPPASTProblemDeclaration,,<empty>
502892,UNKNOWN,7,,"if (renderTargetChanged || fontChanged)
    {
        const auto dpi = static_cast<f32>(p.s->font->dpi);
        _renderTarget->SetDpi(dpi, dpi);
        _renderTarget->SetTextAntialiasMode(static_cast<D2D1_TEXT_ANTIALIAS_MODE>(p.s->font->antialiasingMode));
    }",5,<empty>,,108,7,CPPASTProblemDeclaration,,<empty>
502893,UNKNOWN,8,,"if (renderTargetChanged || fontChanged || cellCountChanged)
    {
        const D2D1_BITMAP_PROPERTIES props{
            .pixelFormat = { DXGI_FORMAT_R8G8B8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED },
            .dpiX = static_cast<f32>(p.s->font->dpi),
            .dpiY = static_cast<f32>(p.s->font->dpi),
        };
        const D2D1_SIZE_U size{
            p.s->viewportCellCount.x,
            p.s->viewportCellCount.y,
        };
        const D2D1_MATRIX_3X2_F transform{
            .m11 = static_cast<f32>(p.s->font->cellSize.x),
            .m22 = static_cast<f32>(p.s->font->cellSize.y),
        };
        THROW_IF_FAILED(_renderTarget->CreateBitmap(size, nullptr, 0, &props, _backgroundBitmap.put()));
        THROW_IF_FAILED(_renderTarget->CreateBitmapBrush(_backgroundBitmap.get(), _backgroundBrush.put()));
        _backgroundBrush->SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
        _backgroundBrush->SetExtendModeX(D2D1_EXTEND_MODE_MIRROR);
        ...",5,<empty>,,115,8,CPPASTProblemDeclaration,,<empty>
502894,UNKNOWN,9,,"if (fontChanged || cursorChanged)
    {
        _cursorBitmap.reset();
        _cursorBitmapSize = {};
    }",5,<empty>,,139,9,CPPASTProblemDeclaration,,<empty>
502895,UNKNOWN,10,,_generation = p.s.generation();,5,<empty>,,145,10,CPPASTProblemDeclaration,,<empty>
502896,UNKNOWN,11,,_fontGeneration = p.s->font.generation();,5,<empty>,,146,11,CPPASTProblemDeclaration,,<empty>
502897,UNKNOWN,12,,_cursorGeneration = p.s->cursor.generation();,5,<empty>,,147,12,CPPASTProblemDeclaration,,<empty>
502898,UNKNOWN,13,,_viewportCellCount = p.s->viewportCellCount;,5,<empty>,,148,13,CPPASTProblemDeclaration,,<empty>
502899,UNKNOWN,14,,},1,<empty>,,149,14,CPPASTProblemDeclaration,,<empty>
502949,UNKNOWN,1,,f32,47,<empty>,,161,1,CPPASTTypeId,,<empty>
502958,UNKNOWN,1,,f32,84,<empty>,,161,1,CPPASTTypeId,,<empty>
503021,UNKNOWN,1,,f32,38,<empty>,,183,1,CPPASTTypeId,,<empty>
503129,UNKNOWN,-1,,"const DWRITE_GLYPH_RUN glyphRun{
                    .fontFace = m.fontFace.get(),
                    .fontEmSize = p.s->font->fontSize,
                    .glyphCount = gsl::narrow_cast<UINT32>(count),
                    .glyphIndices = &row->glyphIndices[off],
                    .glyphAdvances = &row->glyphAdvances[off],
                    .glyphOffsets = &row->glyphOffsets[off],",17,<empty>,,208,12,CPPASTProblemStatement,,<empty>
503244,UNKNOWN,1,,i32,87,<empty>,,245,1,CPPASTTypeId,,<empty>
503270,UNKNOWN,1,,i32,81,<empty>,,249,1,CPPASTTypeId,,<empty>
503352,UNKNOWN,17,,"if (dirtyTop < dirtyBottom)
    {
        p.dirtyRectInPx.top = std::min(p.dirtyRectInPx.top, dirtyTop);
        p.dirtyRectInPx.bottom = std::max(p.dirtyRectInPx.bottom, dirtyBottom);
    }",5,<empty>,,280,17,CPPASTProblemDeclaration,,<empty>
503353,UNKNOWN,18,,},1,<empty>,,285,18,CPPASTProblemDeclaration,,<empty>
503366,UNKNOWN,-1,,F,21,<empty>,,290,4,CPPASTProblemStatement,,<empty>
503391,UNKNOWN,1,,f32,49,<empty>,,297,1,CPPASTTypeId,,<empty>
503400,UNKNOWN,1,,f32,86,<empty>,,297,1,CPPASTTypeId,,<empty>
503440,UNKNOWN,1,,f32,44,<empty>,,307,1,CPPASTTypeId,,<empty>
503463,UNKNOWN,1,,f32,43,<empty>,,310,1,CPPASTTypeId,,<empty>
503474,UNKNOWN,1,,f32,40,<empty>,,314,1,CPPASTTypeId,,<empty>
503498,UNKNOWN,-1,,"static constexpr D2D1_MATRIX_3X2_F identity{ .m11 = 1, .m22 = 1",5,<empty>,,326,1,CPPASTProblemStatement,,<empty>
503501,UNKNOWN,21,,_renderTarget->SetTransform(&identity);,5,<empty>,,327,21,CPPASTProblemDeclaration,,<empty>
503502,UNKNOWN,22,,"if (row->lineRendition >= LineRendition::DoubleHeightTop)
    {
        _renderTarget->PopAxisAlignedClip();
    }",5,<empty>,,329,22,CPPASTProblemDeclaration,,<empty>
503503,UNKNOWN,23,,},1,<empty>,,333,23,CPPASTProblemDeclaration,,<empty>
503645,UNKNOWN,1,,f32,39,<empty>,,368,1,CPPASTTypeId,,<empty>
503655,UNKNOWN,1,,f32,38,<empty>,,369,1,CPPASTTypeId,,<empty>
503669,UNKNOWN,1,,f32,40,<empty>,,370,1,CPPASTTypeId,,<empty>
503689,UNKNOWN,1,,f32,41,<empty>,,371,1,CPPASTTypeId,,<empty>
504133,UNKNOWN,1,,f32,25,<empty>,,492,1,CPPASTTypeId,,<empty>
504150,UNKNOWN,1,,f32,25,<empty>,,493,1,CPPASTTypeId,,<empty>
504167,UNKNOWN,1,,f32,25,<empty>,,494,1,CPPASTTypeId,,<empty>
504184,UNKNOWN,1,,f32,25,<empty>,,495,1,CPPASTTypeId,,<empty>
504260,UNKNOWN,1,,f32,25,<empty>,,518,1,CPPASTTypeId,,<empty>
504277,UNKNOWN,1,,f32,25,<empty>,,519,1,CPPASTTypeId,,<empty>
504347,UNKNOWN,1,,f32,42,<empty>,,535,1,CPPASTTypeId,,<empty>
504352,UNKNOWN,1,,f32,79,<empty>,,535,1,CPPASTTypeId,,<empty>
504464,UNKNOWN,1,,CursorType,25,<empty>,,556,1,CPPASTTypeId,,<empty>
504594,UNKNOWN,1,,f32,36,<empty>,,576,1,CPPASTTypeId,,<empty>
504773,UNKNOWN,1,,f32,29,<empty>,,612,1,CPPASTTypeId,,<empty>
504788,UNKNOWN,1,,f32,29,<empty>,,613,1,CPPASTTypeId,,<empty>
504801,UNKNOWN,1,,f32,29,<empty>,,614,1,CPPASTTypeId,,<empty>
504816,UNKNOWN,1,,f32,29,<empty>,,615,1,CPPASTTypeId,,<empty>
504902,UNKNOWN,34,,TIL_FAST_MATH_END,1,<empty>,,687,34,CPPASTProblemDeclaration,,<empty>
505091,UNKNOWN,1,,D2D1_TEXT_ANTIALIAS_MODE,65,<empty>,,1378,1,CPPASTTypeId,,<empty>
505140,UNKNOWN,1,,u16,40,<empty>,,1698,1,CPPASTTypeId,,<empty>
505177,UNKNOWN,-1,,"_appendQuad() = {
                .shadingType = ShadingType::SolidLine,
                .position = { static_cast<i16>(posX), rowTop },
                .size = { width, p.s->font->cellSize.y },
                .color = r.gridlineColor,
            };",13,<empty>,,1705,1,CPPASTProblemStatement,,<empty>
505201,UNKNOWN,1,,u16,41,<empty>,,1715,1,CPPASTTypeId,,<empty>
505211,UNKNOWN,1,,i16,39,<empty>,,1717,1,CPPASTTypeId,,<empty>
505223,UNKNOWN,1,,u16,40,<empty>,,1718,1,CPPASTTypeId,,<empty>
505264,UNKNOWN,-1,,"_appendQuad() = {
                .shadingType = shadingType,
                .renditionScale = { static_cast<u8>(1 << horizontalShift), static_cast<u8>(1 << verticalShift) },
                .position = { left, static_cast<i16>(rt) },
                .size = { width, static_cast<u16>(rb - rt) },
                .color = color,
            };",13,<empty>,,1727,1,CPPASTProblemStatement,,<empty>
505295,UNKNOWN,1,,TIL_FAST_MATH_BEGIN,1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
505354,UNKNOWN,1,,u8,96,<empty>,,75,1,CPPASTTypeId,,<empty>
505389,UNKNOWN,1,,u8,104,<empty>,,81,1,CPPASTTypeId,,<empty>
505648,UNKNOWN,-1,,"static constexpr D3D11_BUFFER_DESC desc{
            .ByteWidth = sizeof(VSConstBuffer),
            .Usage = D3D11_USAGE_DEFAULT,
            .BindFlags = D3D11_BIND_CONSTANT_BUFFER,",9,<empty>,,138,1,CPPASTProblemStatement,,<empty>
505665,UNKNOWN,6,,"{
        static constexpr D3D11_BUFFER_DESC desc{
            .ByteWidth = sizeof(PSConstBuffer),
            .Usage = D3D11_USAGE_DEFAULT,
            .BindFlags = D3D11_BIND_CONSTANT_BUFFER,
        };
        THROW_IF_FAILED(p.device->CreateBuffer(&desc, nullptr, _psConstantBuffer.addressof()));
    }",5,<empty>,,146,6,CPPASTProblemDeclaration,,<empty>
505666,UNKNOWN,7,,"{
        // The final step of the ClearType blending algorithm is a lerp() between the premultiplied alpha
        // background color and straight alpha foreground color given the 3 RGB weights in alphaCorrected:
        //   lerp(background, foreground, weights)
        // Which is equivalent to:
        //   background * (1 - weights) + foreground * weights
        //
        // This COULD be implemented using dual source color blending like so:
        //   .SrcBlend = D3D11_BLEND_SRC1_COLOR
        //   .DestBlend = D3D11_BLEND_INV_SRC1_COLOR
        //   .BlendOp = D3D11_BLEND_OP_ADD
        // Because:
        //   background * (1 - weights) + foreground * weights
        //       ^             ^        ^     ^           ^
        //      Dest     INV_SRC1_COLOR |    Src      SRC1_COLOR
        //                            OP_ADD
        //
        // BUT we need simultaneous support for regular ""source over"" alpha blending
        // (SHADING_TYPE_PASSTHROUGH)  like this:
...",5,<empty>,,155,7,CPPASTProblemDeclaration,,<empty>
505667,UNKNOWN,8,,_sourceDirectory = std::filesystem::path{ __FILE__ },5,<empty>,,196,8,CPPASTProblemDeclaration,,<empty>
505668,UNKNOWN,9,,.parent_path();,57,<empty>,,196,9,CPPASTProblemDeclaration,,<empty>
505669,UNKNOWN,10,,"_sourceCodeWatcher = wil::make_folder_change_reader_nothrow(_sourceDirectory.c_str(), false, wil::FolderChangeEvents::FileName | wil::FolderChangeEvents::LastWriteTime, [this](wil::FolderChangeEvent, PCWSTR path) {
        if (til::ends_with(path, L"".hlsl""))
        {
            auto expected = INT64_MAX;
            const auto invalidationTime = std::chrono::steady_clock::now() + std::chrono::milliseconds(100);
            _sourceCodeInvalidationTime.compare_exchange_strong(expected, invalidationTime.time_since_epoch().count(), std::memory_order_relaxed);
        }
    });",5,<empty>,,197,10,CPPASTProblemDeclaration,,<empty>
505670,UNKNOWN,11,,},1,<empty>,,206,11,CPPASTProblemDeclaration,,<empty>
505770,UNKNOWN,1,,void**,105,<empty>,,267,1,CPPASTTypeId,,<empty>
506167,UNKNOWN,1,,D2D1_TEXT_ANTIALIAS_MODE,56,<empty>,,379,1,CPPASTTypeId,,<empty>
506476,UNKNOWN,-1,,"static constexpr D3D11_BUFFER_DESC desc{
                .ByteWidth = sizeof(CustomConstBuffer),
                .Usage = D3D11_USAGE_DYNAMIC,
                .BindFlags = D3D11_BIND_CONSTANT_BUFFER,
                .CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,",13,<empty>,,493,1,CPPASTProblemStatement,,<empty>
506492,UNKNOWN,-1,,"static constexpr D3D11_SAMPLER_DESC desc{
                .Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR,
                .AddressU = D3D11_TEXTURE_ADDRESS_BORDER,
                .AddressV = D3D11_TEXTURE_ADDRESS_BORDER,
                .AddressW = D3D11_TEXTURE_ADDRESS_BORDER,
                .MaxAnisotropy = 1,
                .ComparisonFunc = D3D11_COMPARISON_ALWAYS,
                .MaxLOD = D3D11_FLOAT32_MAX,",13,<empty>,,503,1,CPPASTProblemStatement,,<empty>
506508,UNKNOWN,19,,_customShaderStartTime = std::chrono::steady_clock::now();,9,<empty>,,515,19,CPPASTProblemDeclaration,,<empty>
506509,UNKNOWN,20,,},5,<empty>,,516,20,CPPASTProblemDeclaration,,<empty>
506510,UNKNOWN,21,,},1,<empty>,,517,21,CPPASTProblemDeclaration,,<empty>
506522,UNKNOWN,-1,,"const D3D11_TEXTURE2D_DESC desc{
        .Width = p.s->targetSize.x,
        .Height = p.s->targetSize.y,
        .MipLevels = 1,
        .ArraySize = 1,
        .Format = DXGI_FORMAT_B8G8R8A8_UNORM,
        .SampleDesc = { 1, 0 }",5,<empty>,,525,3,CPPASTProblemStatement,,<empty>
506523,UNKNOWN,-1,,",
        .BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,",31,<empty>,,531,4,CPPASTProblemStatement,,<empty>
506526,UNKNOWN,23,,"THROW_IF_FAILED(p.device->CreateTexture2D(&desc, nullptr, _customOffscreenTexture.addressof()));",5,<empty>,,534,23,CPPASTProblemDeclaration,,<empty>
506527,UNKNOWN,24,,"THROW_IF_FAILED(p.device->CreateShaderResourceView(_customOffscreenTexture.get(), nullptr, _customOffscreenTextureView.addressof()));",5,<empty>,,535,24,CPPASTProblemDeclaration,,<empty>
506528,UNKNOWN,25,,"THROW_IF_FAILED(p.device->CreateRenderTargetView(_customOffscreenTexture.get(), nullptr, _customRenderTargetView.addressof()));",5,<empty>,,536,25,CPPASTProblemDeclaration,,<empty>
506529,UNKNOWN,26,,},1,<empty>,,537,26,CPPASTProblemDeclaration,,<empty>
506541,UNKNOWN,-1,,"const D3D11_TEXTURE2D_DESC desc{
        .Width = p.s->viewportCellCount.x,
        .Height = p.s->viewportCellCount.y,
        .MipLevels = 1,
        .ArraySize = 1,
        .Format = DXGI_FORMAT_R8G8B8A8_UNORM,
        .SampleDesc = { 1, 0 }",5,<empty>,,545,3,CPPASTProblemStatement,,<empty>
506542,UNKNOWN,-1,,",
        .Usage = D3D11_USAGE_DYNAMIC,
        .BindFlags = D3D11_BIND_SHADER_RESOURCE,
        .CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,",31,<empty>,,551,4,CPPASTProblemStatement,,<empty>
506545,UNKNOWN,28,,"THROW_IF_FAILED(p.device->CreateTexture2D(&desc, nullptr, _backgroundBitmap.addressof()));",5,<empty>,,556,28,CPPASTProblemDeclaration,,<empty>
506546,UNKNOWN,29,,"THROW_IF_FAILED(p.device->CreateShaderResourceView(_backgroundBitmap.get(), nullptr, _backgroundBitmapView.addressof()));",5,<empty>,,557,29,CPPASTProblemDeclaration,,<empty>
506551,UNKNOWN,32,,},1,<empty>,,559,32,CPPASTProblemDeclaration,,<empty>
506817,UNKNOWN,1,,f32,34,<empty>,,600,1,CPPASTTypeId,,<empty>
506830,UNKNOWN,1,,f32,35,<empty>,,601,1,CPPASTTypeId,,<empty>
506927,UNKNOWN,35,,"void BackendD3D::_debugUpdateShaders(const RenderingPayload& p) noexcept
try
{
    const auto invalidationTime = _sourceCodeInvalidationTime.load(std::memory_order_relaxed);

    if (invalidationTime == INT64_MAX || invalidationTime > std::chrono::steady_clock::now().time_since_epoch().count())
    {
        return;
    }

    _sourceCodeInvalidationTime.store(INT64_MAX, std::memory_order_relaxed);

    static const auto compile = [](const std::filesystem::path& path, const char* target) {
        wil::com_ptr<ID3DBlob> error;
        wil::com_ptr<ID3DBlob> blob;
        const auto hr = D3DCompileFromFile(
            /* pFileName   */ path.c_str(),
            /* pDefines    */ nullptr,
            /* pInclude    */ D3D_COMPILE_STANDARD_FILE_INCLUDE,
            /* pEntrypoint */ ""main"",
            /* pTarget     */ target,
            /* Flags1      */ D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION | D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR | D3DCOMPILE_ENABLE_STRICTNESS | D3DCOMPILE...",1,<empty>,,616,35,CPPASTProblemDeclaration,,<empty>
506963,UNKNOWN,1,,u32,39,<empty>,,728,1,CPPASTTypeId,,<empty>
506987,UNKNOWN,1,,u32,41,<empty>,,729,1,CPPASTTypeId,,<empty>
507014,UNKNOWN,1,,u32,46,<empty>,,732,1,CPPASTTypeId,,<empty>
507061,UNKNOWN,1,,u16,32,<empty>,,751,1,CPPASTTypeId,,<empty>
507073,UNKNOWN,1,,u16,32,<empty>,,752,1,CPPASTTypeId,,<empty>
507163,UNKNOWN,-1,,"const D3D11_TEXTURE2D_DESC desc{
            .Width = u,
            .Height = v,
            .MipLevels = 1,
            .ArraySize = 1,
            .Format = DXGI_FORMAT_B8G8R8A8_UNORM,
            .SampleDesc = { 1, 0 }",9,<empty>,,787,1,CPPASTProblemStatement,,<empty>
507164,UNKNOWN,-1,,",
            .BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,",35,<empty>,,793,2,CPPASTProblemStatement,,<empty>
507197,UNKNOWN,39,,"{
        const auto surface = _glyphAtlas.query<IDXGISurface>();

        static constexpr D2D1_RENDER_TARGET_PROPERTIES props{
            .type = D2D1_RENDER_TARGET_TYPE_DEFAULT,
            .pixelFormat = { DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED },
        };
        // ID2D1RenderTarget and ID2D1DeviceContext are the same and I'm tired of pretending they're not.
        THROW_IF_FAILED(p.d2dFactory->CreateDxgiSurfaceRenderTarget(surface.get(), &props, reinterpret_cast<ID2D1RenderTarget**>(_d2dRenderTarget.addressof())));
        _d2dRenderTarget.try_query_to(_d2dRenderTarget4.addressof());

        _d2dRenderTarget->SetUnitMode(D2D1_UNIT_MODE_PIXELS);
        // We don't really use D2D for anything except DWrite, but it
        // can't hurt to ensure that everything it does is pixel aligned.
        _d2dRenderTarget->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
        // Ensure that D2D uses the exact same gamma as our shader uses.
        _d2dRenderTarge...",5,<empty>,,800,39,CPPASTProblemDeclaration,,<empty>
507198,UNKNOWN,40,,"if (_d2dRenderTarget4)
    {
        wil::com_ptr<ID2D1Device> device;
        _d2dRenderTarget4->GetDevice(device.addressof());

        device->SetMaximumTextureMemory(0);
        if (const auto device4 = device.try_query<ID2D1Device4>())
        {
            device4->SetMaximumColorGlyphCacheMemory(0);
        }
    }",5,<empty>,,823,40,CPPASTProblemDeclaration,,<empty>
507199,UNKNOWN,41,,"{
        static constexpr D2D1_COLOR_F color{ 1, 1, 1, 1 };
        THROW_IF_FAILED(_d2dRenderTarget->CreateSolidColorBrush(&color, nullptr, _emojiBrush.put()));
        THROW_IF_FAILED(_d2dRenderTarget->CreateSolidColorBrush(&color, nullptr, _brush.put()));
    }",5,<empty>,,835,41,CPPASTProblemDeclaration,,<empty>
507212,UNKNOWN,44,,"p.deviceContext->PSSetShaderResources(0, 2, &resources[0]);",5,<empty>,,842,44,CPPASTProblemDeclaration,,<empty>
507213,UNKNOWN,45,,_rectPackerData = Buffer<stbrp_node>{ u };,5,<empty>,,844,45,CPPASTProblemDeclaration,,<empty>
507214,UNKNOWN,46,,},1,<empty>,,845,46,CPPASTProblemDeclaration,,<empty>
507386,UNKNOWN,1,,UINT,58,<empty>,,924,1,CPPASTTypeId,,<empty>
507404,UNKNOWN,1,,size_t,42,<empty>,,931,1,CPPASTTypeId,,<empty>
507456,UNKNOWN,-1,,"const D3D11_BUFFER_DESC desc{
            .ByteWidth = gsl::narrow<UINT>(newSize),
            .Usage = D3D11_USAGE_DYNAMIC,
            .BindFlags = D3D11_BIND_VERTEX_BUFFER,
            .CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,
            .StructureByteStride = sizeof(QuadInstance),",9,<empty>,,942,1,CPPASTProblemStatement,,<empty>
507499,UNKNOWN,58,,"p.deviceContext->IASetVertexBuffers(0, 2, &vertexBuffers[0], &strides[0], &offsets[0]);",5,<empty>,,956,58,CPPASTProblemDeclaration,,<empty>
507500,UNKNOWN,59,,_instanceBufferCapacity = newCapacity;,5,<empty>,,958,59,CPPASTProblemDeclaration,,<empty>
507501,UNKNOWN,60,,},1,<empty>,,959,60,CPPASTProblemDeclaration,,<empty>
507516,UNKNOWN,-1,,"_appendQuad() = {
        .shadingType = ShadingType::Background,
        .size = p.s->targetSize,
    };",5,<empty>,,969,2,CPPASTProblemStatement,,<empty>
507588,UNKNOWN,1,,char*,28,<empty>,,983,1,CPPASTTypeId,,<empty>
507732,UNKNOWN,-1,,"const AtlasFontFaceKey fontFaceKey{
                .fontFace = m.fontFace.get(),
                .lineRendition = row->lineRendition,",13,<empty>,,1028,3,CPPASTProblemStatement,,<empty>
507778,UNKNOWN,1,,til::CoordType,42,<empty>,,1062,1,CPPASTTypeId,,<empty>
507795,UNKNOWN,1,,til::CoordType,42,<empty>,,1063,1,CPPASTTypeId,,<empty>
507858,UNKNOWN,-1,,"_appendQuad() = {
                        .shadingType = glyphEntry.data.shadingType,
                        .position = { static_cast<i16>(l), static_cast<i16>(t) },
                        .size = glyphEntry.data.size,
                        .texcoord = glyphEntry.data.texcoord,
                        .color = row->colors[x],
                    };",21,<empty>,,1071,9,CPPASTProblemStatement,,<empty>
507923,UNKNOWN,64,,"if (dirtyTop < dirtyBottom)
    {
        p.dirtyRectInPx.top = std::min(p.dirtyRectInPx.top, dirtyTop);
        p.dirtyRectInPx.bottom = std::max(p.dirtyRectInPx.bottom, dirtyBottom);
    }",5,<empty>,,1104,64,CPPASTProblemDeclaration,,<empty>
507924,UNKNOWN,65,,_d2dEndDrawing();,5,<empty>,,1110,65,CPPASTProblemDeclaration,,<empty>
507925,UNKNOWN,66,,},1,<empty>,,1111,66,CPPASTProblemDeclaration,,<empty>
508308,UNKNOWN,-1,,"const DWRITE_GLYPH_RUN glyphRun{
        .fontFace = fontFaceEntry.fontFace.get(),
        .fontEmSize = p.s->font->fontSize,
        .glyphCount = 1,
        .glyphIndices = &glyphEntry.glyphIndex,",5,<empty>,,1239,2,CPPASTProblemStatement,,<empty>
508315,UNKNOWN,1,,LineRendition,44,<empty>,,1337,1,CPPASTTypeId,,<empty>
508327,UNKNOWN,74,,"static constexpr D2D1_MATRIX_3X2_F identityTransform{ .m11 = 1, .m22 = 1",5,<empty>,,1340,74,CPPASTProblemDeclaration,,<empty>
508328,UNKNOWN,75,,};,78,<empty>,,1340,75,CPPASTProblemDeclaration,,<empty>
508333,UNKNOWN,78,,"if (needsTransform)
    {
        transform.m11 = 2.0f;
        transform.m22 = lineRendition >= LineRendition::DoubleHeightTop ? 2.0f : 1.0f;
        _d2dRenderTarget->SetTransform(&transform);
    }",5,<empty>,,1343,78,CPPASTProblemDeclaration,,<empty>
508357,UNKNOWN,87,,"{
        const auto enumerator = TranslateColorGlyphRun(p.dwriteFactory4.get(), {}, &glyphRun);

        if (!enumerator)
        {
            THROW_IF_FAILED(_d2dRenderTarget->GetGlyphRunWorldBounds({}, &glyphRun, DWRITE_MEASURING_MODE_NATURAL, &bounds));
        }
        else
        {
            isColorGlyph = true;
            _d2dRenderTarget4->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE);

            while (ColorGlyphRunMoveNext(enumerator.get()))
            {
                const auto colorGlyphRun = ColorGlyphRunGetCurrentRun(enumerator.get());
                ColorGlyphRunAccumulateBounds(_d2dRenderTarget.get(), colorGlyphRun, bounds);
            }
        }
    }",5,<empty>,,1382,87,CPPASTProblemDeclaration,,<empty>
508371,UNKNOWN,90,,"if (isBoxGlyph)
    {
        // NOTE: As mentioned above, the ""origin"" of a glyph's coordinate system is its baseline.
        bounds.left = std::max(bounds.left, 0.0f);
        bounds.top = std::max(bounds.top, static_cast<f32>(-p.s->font->baseline) * transform.m22);
        bounds.right = std::min(bounds.right, static_cast<f32>(p.s->font->cellSize.x) * transform.m11);
        bounds.bottom = std::min(bounds.bottom, static_cast<f32>(p.s->font->descender) * transform.m22);
    }",5,<empty>,,1409,90,CPPASTProblemDeclaration,,<empty>
508372,UNKNOWN,91,,"if (bounds.left >= bounds.right || bounds.top >= bounds.bottom)
    {
        return true;
    }",5,<empty>,,1419,91,CPPASTProblemDeclaration,,<empty>
508401,UNKNOWN,100,,"stbrp_rect rect{
        .w = br - bl,
        .h = bb - bt,
    };",5,<empty>,,1429,100,CPPASTProblemDeclaration,,<empty>
508402,UNKNOWN,101,,"if (!stbrp_pack_rects(&_rectPacker, &rect, 1))
    {
        _drawGlyphPrepareRetry(p);
        return false;
    }",5,<empty>,,1433,101,CPPASTProblemDeclaration,,<empty>
508408,UNKNOWN,1,,f32,21,<empty>,,1440,1,CPPASTTypeId,,<empty>
508415,UNKNOWN,1,,f32,21,<empty>,,1441,1,CPPASTTypeId,,<empty>
508421,UNKNOWN,104,,_d2dBeginDrawing();,5,<empty>,,1444,104,CPPASTProblemDeclaration,,<empty>
508422,UNKNOWN,105,,"if (isBoxGlyph)
    {
        const D2D1_RECT_F clipRect{
            static_cast<f32>(rect.x) / transform.m11,
            static_cast<f32>(rect.y) / transform.m22,
            static_cast<f32>(rect.x + rect.w) / transform.m11,
            static_cast<f32>(rect.y + rect.h) / transform.m22,
        };
        _d2dRenderTarget->PushAxisAlignedClip(&clipRect, D2D1_ANTIALIAS_MODE_ALIASED);
    }",5,<empty>,,1446,105,CPPASTProblemDeclaration,,<empty>
508431,UNKNOWN,108,,"if (needsTransform)
    {
        transform.dx = (1.0f - transform.m11) * baselineOrigin.x;
        transform.dy = (1.0f - transform.m22) * baselineOrigin.y;
        _d2dRenderTarget->SetTransform(&transform);
    }",5,<empty>,,1463,108,CPPASTProblemDeclaration,,<empty>
508432,UNKNOWN,109,,"if (!isColorGlyph)
    {
        _d2dRenderTarget->DrawGlyphRun(baselineOrigin, &glyphRun, _brush.get(), DWRITE_MEASURING_MODE_NATURAL);
    }",5,<empty>,,1470,109,CPPASTProblemDeclaration,,<empty>
508433,UNKNOWN,110,,"else
    {
        const auto enumerator = TranslateColorGlyphRun(p.dwriteFactory4.get(), baselineOrigin, &glyphRun);
        while (ColorGlyphRunMoveNext(enumerator.get()))
        {
            const auto colorGlyphRun = ColorGlyphRunGetCurrentRun(enumerator.get());
            ColorGlyphRunDraw(_d2dRenderTarget4.get(), _emojiBrush.get(), _brush.get(), colorGlyphRun);
        }
    }",5,<empty>,,1474,110,CPPASTProblemDeclaration,,<empty>
508481,UNKNOWN,119,,glyphEntry.data.shadingType = isColorGlyph ? ShadingType::TextPassthrough : _textShadingType;,5,<empty>,,1494,119,CPPASTProblemDeclaration,,<empty>
508482,UNKNOWN,120,,glyphEntry.data.overlapSplit = overlapSplit;,5,<empty>,,1495,120,CPPASTProblemDeclaration,,<empty>
508483,UNKNOWN,121,,glyphEntry.data.offset.x = bl;,5,<empty>,,1496,121,CPPASTProblemDeclaration,,<empty>
508484,UNKNOWN,122,,glyphEntry.data.offset.y = bt;,5,<empty>,,1497,122,CPPASTProblemDeclaration,,<empty>
508485,UNKNOWN,123,,glyphEntry.data.size.x = rect.w;,5,<empty>,,1498,123,CPPASTProblemDeclaration,,<empty>
508486,UNKNOWN,124,,glyphEntry.data.size.y = rect.h;,5,<empty>,,1499,124,CPPASTProblemDeclaration,,<empty>
508487,UNKNOWN,125,,glyphEntry.data.texcoord.x = rect.x;,5,<empty>,,1500,125,CPPASTProblemDeclaration,,<empty>
508488,UNKNOWN,126,,glyphEntry.data.texcoord.y = rect.y;,5,<empty>,,1501,126,CPPASTProblemDeclaration,,<empty>
508489,UNKNOWN,127,,"if (lineRendition >= LineRendition::DoubleHeightTop)
    {
        _splitDoubleHeightGlyph(p, fontFaceEntry, glyphEntry);
    }",5,<empty>,,1503,127,CPPASTProblemDeclaration,,<empty>
508490,UNKNOWN,128,,return true;,5,<empty>,,1508,128,CPPASTProblemDeclaration,,<empty>
508491,UNKNOWN,129,,},1,<empty>,,1509,129,CPPASTProblemDeclaration,,<empty>
508498,UNKNOWN,-1,,t,14,<empty>,,1513,2,CPPASTProblemStatement,,<empty>
508529,UNKNOWN,1,,LineRendition,44,<empty>,,1518,1,CPPASTTypeId,,<empty>
508554,UNKNOWN,1,,u8,46,<empty>,,1523,1,CPPASTTypeId,,<empty>
508595,UNKNOWN,1,,UINT32,25,<empty>,,1540,1,CPPASTTypeId,,<empty>
508606,UNKNOWN,1,,UINT32,25,<empty>,,1541,1,CPPASTTypeId,,<empty>
508616,UNKNOWN,-1,,"const D2D1_BITMAP_PROPERTIES1 bitmapProperties{
            .pixelFormat = { DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED }",9,<empty>,,1543,3,CPPASTProblemStatement,,<empty>
508617,UNKNOWN,-1,,",
            .dpiX = static_cast<f32>(p.s->font->dpi),
            .dpiY = static_cast<f32>(p.s->font->dpi),",89,<empty>,,1544,4,CPPASTProblemStatement,,<empty>
508656,UNKNOWN,1,,f32,21,<empty>,,1553,1,CPPASTTypeId,,<empty>
508661,UNKNOWN,1,,f32,21,<empty>,,1554,1,CPPASTTypeId,,<empty>
508666,UNKNOWN,1,,f32,21,<empty>,,1555,1,CPPASTTypeId,,<empty>
508675,UNKNOWN,1,,f32,21,<empty>,,1556,1,CPPASTTypeId,,<empty>
508683,UNKNOWN,135,,_d2dBeginDrawing();,5,<empty>,,1559,135,CPPASTProblemDeclaration,,<empty>
508684,UNKNOWN,136,,"_drawSoftFontGlyphInBitmap(p, glyphEntry);",5,<empty>,,1560,136,CPPASTProblemDeclaration,,<empty>
508685,UNKNOWN,137,,"_d2dRenderTarget->DrawBitmap(_softFontBitmap.get(), &dest, 1, interpolation, nullptr, nullptr);",5,<empty>,,1561,137,CPPASTProblemDeclaration,,<empty>
508686,UNKNOWN,138,,glyphEntry.data.shadingType = ShadingType::TextGrayscale;,5,<empty>,,1563,138,CPPASTProblemDeclaration,,<empty>
508687,UNKNOWN,139,,glyphEntry.data.overlapSplit = 0;,5,<empty>,,1564,139,CPPASTProblemDeclaration,,<empty>
508688,UNKNOWN,140,,glyphEntry.data.offset.x = 0;,5,<empty>,,1565,140,CPPASTProblemDeclaration,,<empty>
508689,UNKNOWN,141,,glyphEntry.data.offset.y = -baseline;,5,<empty>,,1566,141,CPPASTProblemDeclaration,,<empty>
508690,UNKNOWN,142,,glyphEntry.data.size.x = rect.w;,5,<empty>,,1567,142,CPPASTProblemDeclaration,,<empty>
508691,UNKNOWN,143,,glyphEntry.data.size.y = rect.h;,5,<empty>,,1568,143,CPPASTProblemDeclaration,,<empty>
508692,UNKNOWN,144,,glyphEntry.data.texcoord.x = rect.x;,5,<empty>,,1569,144,CPPASTProblemDeclaration,,<empty>
508693,UNKNOWN,145,,glyphEntry.data.texcoord.y = rect.y;,5,<empty>,,1570,145,CPPASTProblemDeclaration,,<empty>
508694,UNKNOWN,146,,"if (lineRendition >= LineRendition::DoubleHeightTop)
    {
        _splitDoubleHeightGlyph(p, fontFaceEntry, glyphEntry);
    }",5,<empty>,,1572,146,CPPASTProblemDeclaration,,<empty>
508695,UNKNOWN,147,,return true;,5,<empty>,,1577,147,CPPASTProblemDeclaration,,<empty>
508696,UNKNOWN,148,,},1,<empty>,,1578,148,CPPASTProblemDeclaration,,<empty>
508715,UNKNOWN,1,,size_t,36,<empty>,,1589,1,CPPASTTypeId,,<empty>
508729,UNKNOWN,1,,size_t,37,<empty>,,1590,1,CPPASTTypeId,,<empty>
508858,UNKNOWN,1,,UINT32,36,<empty>,,1621,1,CPPASTTypeId,,<empty>
508923,UNKNOWN,-1,,"const AtlasFontFaceKey key2{
        .fontFace = fontFaceEntry.fontFace.get(),
        .lineRendition = isTop ? LineRendition::DoubleHeightBottom : LineRendition::DoubleHeightTop,",5,<empty>,,1644,4,CPPASTProblemStatement,,<empty>
508952,UNKNOWN,156,,entry2.data = glyphEntry.data;,5,<empty>,,1651,156,CPPASTProblemDeclaration,,<empty>
508989,UNKNOWN,1,,int,96,<empty>,,1656,1,CPPASTTypeId,,<empty>
508997,UNKNOWN,163,,top.data.offset.y += p.s->font->cellSize.y;,5,<empty>,,1657,163,CPPASTProblemDeclaration,,<empty>
508998,UNKNOWN,164,,top.data.size.y = topSize;,5,<empty>,,1658,164,CPPASTProblemDeclaration,,<empty>
508999,UNKNOWN,165,,bottom.data.offset.y += topSize;,5,<empty>,,1659,165,CPPASTProblemDeclaration,,<empty>
509000,UNKNOWN,166,,"bottom.data.size.y = std::max(0, bottom.data.size.y - topSize);",5,<empty>,,1660,166,CPPASTProblemDeclaration,,<empty>
509001,UNKNOWN,167,,bottom.data.texcoord.y += topSize;,5,<empty>,,1661,167,CPPASTProblemDeclaration,,<empty>
509002,UNKNOWN,168,,"if (!top.data.size.y)
    {
        top.data.shadingType = ShadingType::Default;
    }",5,<empty>,,1665,168,CPPASTProblemDeclaration,,<empty>
509003,UNKNOWN,169,,"if (!bottom.data.size.y)
    {
        bottom.data.shadingType = ShadingType::Default;
    }",5,<empty>,,1669,169,CPPASTProblemDeclaration,,<empty>
509004,UNKNOWN,170,,},1,<empty>,,1673,170,CPPASTProblemDeclaration,,<empty>
509020,UNKNOWN,1,,u8,46,<empty>,,1679,1,CPPASTTypeId,,<empty>
509031,UNKNOWN,1,,u8,44,<empty>,,1680,1,CPPASTTypeId,,<empty>
509052,UNKNOWN,1,,i16,37,<empty>,,1683,1,CPPASTTypeId,,<empty>
509062,UNKNOWN,1,,i16,40,<empty>,,1684,1,CPPASTTypeId,,<empty>
509530,UNKNOWN,1,,u16,25,<empty>,,1822,1,CPPASTTypeId,,<empty>
509598,UNKNOWN,1,,CursorType,29,<empty>,,1840,1,CPPASTTypeId,,<empty>
509985,UNKNOWN,-1,,"_appendQuad() = {
            .shadingType = ShadingType::Cursor,
            .position = c.position,
            .size = c.size,
            .color = c.background,
        };",9,<empty>,,1901,1,CPPASTProblemStatement,,<empty>
510581,UNKNOWN,1,,i16,41,<empty>,,2087,1,CPPASTTypeId,,<empty>
510592,UNKNOWN,1,,i16,41,<empty>,,2088,1,CPPASTTypeId,,<empty>
510603,UNKNOWN,1,,u16,37,<empty>,,2089,1,CPPASTTypeId,,<empty>
510618,UNKNOWN,1,,u16,37,<empty>,,2090,1,CPPASTTypeId,,<empty>
510633,UNKNOWN,1,,u16,41,<empty>,,2091,1,CPPASTTypeId,,<empty>
510652,UNKNOWN,1,,u16,41,<empty>,,2092,1,CPPASTTypeId,,<empty>
510746,UNKNOWN,1,,i16,37,<empty>,,2106,1,CPPASTTypeId,,<empty>
510755,UNKNOWN,1,,i16,37,<empty>,,2107,1,CPPASTTypeId,,<empty>
510764,UNKNOWN,1,,u16,33,<empty>,,2108,1,CPPASTTypeId,,<empty>
510775,UNKNOWN,1,,u16,33,<empty>,,2109,1,CPPASTTypeId,,<empty>
510786,UNKNOWN,1,,u16,37,<empty>,,2110,1,CPPASTTypeId,,<empty>
510803,UNKNOWN,1,,u16,37,<empty>,,2111,1,CPPASTTypeId,,<empty>
510882,UNKNOWN,-1,,"_appendQuad() = {
                    .shadingType = ShadingType::Selection,
                    .position = {
                        p.s->font->cellSize.x * row->selectionFrom,
                        p.s->font->cellSize.y * y,
                    },
                    .size = {
                        static_cast<u16>(p.s->font->cellSize.x * (row->selectionTo - row->selectionFrom)),
                        p.s->font->cellSize.y,
                    },
                    .color = p.s->misc->selectionColor,
                };",17,<empty>,,2135,1,CPPASTProblemStatement,,<empty>
510901,UNKNOWN,-1,,"const CustomConstBuffer data{
            .time = std::chrono::duration<f32>(std::chrono::steady_clock::now() - _customShaderStartTime).count(),
            .scale = static_cast<f32>(p.s->font->dpi) / static_cast<f32>(USER_DEFAULT_SCREEN_DPI),
            .resolution = {
                static_cast<f32>(_viewportCellCount.x * p.s->font->cellSize.x),
                static_cast<f32>(_viewportCellCount.y * p.s->font->cellSize.y),
            }",9,<empty>,,2203,1,CPPASTProblemStatement,,<empty>
510902,UNKNOWN,-1,,",
            .background = colorFromU32Premultiply<f32x4>(p.s->misc->backgroundColor),",14,<empty>,,2209,2,CPPASTProblemStatement,,<empty>
510944,UNKNOWN,177,,"{
        // Before we do anything else we have to unbound _renderTargetView from being
        // a render target, otherwise we can't use it as a shader resource below.
        p.deviceContext->OMSetRenderTargets(1, _renderTargetView.addressof(), nullptr);

        // IA: Input Assembler
        p.deviceContext->IASetIndexBuffer(nullptr, DXGI_FORMAT_UNKNOWN, 0);
        p.deviceContext->IASetInputLayout(nullptr);
        p.deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
        p.deviceContext->IASetVertexBuffers(0, 0, nullptr, nullptr, nullptr);

        // VS: Vertex Shader
        p.deviceContext->VSSetShader(_customVertexShader.get(), nullptr, 0);
        p.deviceContext->VSSetConstantBuffers(0, 0, nullptr);

        // PS: Pixel Shader
        p.deviceContext->PSSetShader(_customPixelShader.get(), nullptr, 0);
        p.deviceContext->PSSetConstantBuffers(0, 1, _customShaderConstantBuffer.addressof());
        p.deviceContext->PSSetShaderResource...",5,<empty>,,2219,177,CPPASTProblemDeclaration,,<empty>
510945,UNKNOWN,178,,"p.deviceContext->Draw(4, 0);",5,<empty>,,2244,178,CPPASTProblemDeclaration,,<empty>
510946,UNKNOWN,179,,"{
        // IA: Input Assembler
        ID3D11Buffer* vertexBuffers[]{ _vertexBuffer.get(), _instanceBuffer.get() };
        static constexpr UINT strides[]{ sizeof(f32x2), sizeof(QuadInstance) };
        static constexpr UINT offsets[]{ 0, 0 };
        p.deviceContext->IASetIndexBuffer(_indexBuffer.get(), DXGI_FORMAT_R16_UINT, 0);
        p.deviceContext->IASetInputLayout(_inputLayout.get());
        p.deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
        p.deviceContext->IASetVertexBuffers(0, 2, &vertexBuffers[0], &strides[0], &offsets[0]);

        // VS: Vertex Shader
        p.deviceContext->VSSetShader(_vertexShader.get(), nullptr, 0);
        p.deviceContext->VSSetConstantBuffers(0, 1, _vsConstantBuffer.addressof());

        // PS: Pixel Shader
        ID3D11ShaderResourceView* resources[]{ _backgroundBitmapView.get(), _glyphAtlasView.get() };
        p.deviceContext->PSSetShader(_pixelShader.get(), nullptr, 0);
        p.deviceContext->PSSet...",5,<empty>,,2246,179,CPPASTProblemDeclaration,,<empty>
510947,UNKNOWN,180,,"p.dirtyRectInPx = { 0, 0, p.s->targetSize.x, p.s->targetSize.y };",5,<empty>,,2274,180,CPPASTProblemDeclaration,,<empty>
510948,UNKNOWN,181,,},1,<empty>,,2275,181,CPPASTProblemDeclaration,,<empty>
510949,UNKNOWN,182,,TIL_FAST_MATH_END,1,<empty>,,2277,182,CPPASTProblemDeclaration,,<empty>
511192,UNKNOWN,1,,bool,36,<empty>,,174,1,CPPASTTypeId,,<empty>
511784,UNKNOWN,16,,"HRESULT __stdcall TextAnalysisSink::SetScriptAnalysis(UINT32 textPosition, UINT32 textLength, const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis) noexcept
try
{
    __assume(scriptAnalysis != nullptr);
    _results.emplace_back(textPosition, textLength, *scriptAnalysis);
    return S_OK;
}
CATCH_RETURN()

HRESULT TextAnalysisSink::SetLineBreakpoints(UINT32 textPosition, UINT32 textLength, const DWRITE_LINE_BREAKPOINT* lineBreakpoints) noexcept
{
    return E_NOTIMPL;
}",1,<empty>,,155,16,CPPASTProblemDeclaration,,<empty>
512346,UNKNOWN,1,,T*,36,<empty>,,276,1,CPPASTTypeId,,<empty>
512359,UNKNOWN,1,,T*,36,<empty>,,280,1,CPPASTTypeId,,<empty>
512369,UNKNOWN,1,,std::align_val_t,85,<empty>,,280,1,CPPASTTypeId,,<empty>
512394,UNKNOWN,1,,std::align_val_t,53,<empty>,,292,1,CPPASTTypeId,,<empty>
512674,UNKNOWN,1,,FontRelevantAttributes,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512677,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512687,UNKNOWN,1,,FontRelevantAttributes,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512690,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512693,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512703,UNKNOWN,1,,FontRelevantAttributes,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512706,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512709,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512719,UNKNOWN,1,,FontRelevantAttributes,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512722,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
512725,UNKNOWN,1,,u8,5,<empty>,,418,1,CPPASTTypeId,,<empty>
513044,UNKNOWN,1,,IDWriteRenderingParams**,69,<empty>,,31,1,CPPASTTypeId,,<empty>
513298,UNKNOWN,1,,float,48,<empty>,,67,1,CPPASTTypeId,,<empty>
513302,UNKNOWN,1,,double,67,<empty>,,67,1,CPPASTTypeId,,<empty>
513312,UNKNOWN,1,,float,48,<empty>,,68,1,CPPASTTypeId,,<empty>
513316,UNKNOWN,1,,double,67,<empty>,,68,1,CPPASTTypeId,,<empty>
513326,UNKNOWN,1,,ptrdiff_t,53,<empty>,,71,1,CPPASTTypeId,,<empty>
513916,UNKNOWN,1,,BYTE*,113,<empty>,,52,1,CPPASTTypeId,,<empty>
514132,UNKNOWN,1,,::IUnknown**,113,<empty>,,15,1,CPPASTTypeId,,<empty>
514610,UNKNOWN,14,,"void FontInfoBase::s_SetFontDefaultList(_In_ Microsoft::Console::Render::IFontDefaultList* const pFontDefaultList) noexcept
{
    s_pFontDefaultList = pFontDefaultList;
}",1,<empty>,,119,14,CPPASTProblemDeclaration,,<empty>
514969,UNKNOWN,1,,FONTINFO*,39,<empty>,,119,1,CPPASTTypeId,,<empty>
515242,UNKNOWN,1,,double,33,<empty>,,184,1,CPPASTTypeId,,<empty>
515565,UNKNOWN,10,,"[[nodiscard]] HRESULT RenderEngineBase::InvalidateFlush(_In_ const bool /*circled*/, _Out_ bool* const pForcePaint) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pForcePaint);
    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,89,10,CPPASTProblemDeclaration,,<empty>
515757,UNKNOWN,1,,size_t,49,<empty>,,123,1,CPPASTTypeId,,<empty>
515772,UNKNOWN,1,,size_t,52,<empty>,,135,1,CPPASTTypeId,,<empty>
516087,UNKNOWN,15,,"void RenderSettings::ToggleBlinkRendition(Renderer& renderer) noexcept
try
{
    if (GetRenderMode(Mode::BlinkAllowed))
    {
        // This method is called with the frequency of the cursor blink rate,
        // but we only want our cells to blink at half that frequency. We thus
        // have a blink cycle that loops through four phases...
        _blinkCycle = (_blinkCycle + 1) % 4;
        // ... and two of those four render the blink attributes as faint.
        _blinkShouldBeFaint = _blinkCycle >= 2;
        // Every two cycles (when the state changes), we need to trigger a
        // redraw, but only if there are actually blink attributes in use.
        if (_blinkIsInUse && _blinkCycle % 2 == 0)
        {
            // We reset the _blinkIsInUse flag before redrawing, so we can
            // get a fresh assessment of the current blink attribute usage.
            _blinkIsInUse = false;
            renderer.TriggerRedrawAll();
        }
    }
}
CATCH_LOG()",1,<empty>,,262,15,CPPASTProblemDeclaration,,<empty>
516268,UNKNOWN,6,,"Renderer::Renderer(const RenderSettings& renderSettings,
                   IRenderData* pData,
                   _In_reads_(cEngines) IRenderEngine** const rgpEngines,
                   const size_t cEngines,
                   std::unique_ptr<RenderThread> thread) :
    _renderSettings(renderSettings),
    _pData(pData),
    _pThread{ std::move(thread) }",1,<empty>,,31,6,CPPASTProblemDeclaration,,<empty>
516269,UNKNOWN,7,,"{
    for (size_t i = 0; i < cEngines; i++)
    {
        AddRenderEngine(rgpEngines[i]);
    }
}",1,<empty>,,39,7,CPPASTProblemDeclaration,,<empty>
516354,UNKNOWN,10,,"[[nodiscard]] HRESULT Renderer::_PaintFrameForEngine(_In_ IRenderEngine* const pEngine) noexcept
try
{
    FAIL_FAST_IF_NULL(pEngine); // This is a programming error. Fail fast.

    _pData->LockConsole();
    auto unlock = wil::scope_exit([&]() {
        _pData->UnlockConsole();
    });

    // Last chance check if anything scrolled without an explicit invalidate notification since the last frame.
    _CheckViewportAndScroll();

    // Try to start painting a frame
    const auto hr = pEngine->StartPaint();
    RETURN_IF_FAILED(hr);

    // Return early if there's nothing to paint.
    // The renderer itself tracks if there's something to do with the title, the
    //      engine won't know that.
    if (S_FALSE == hr)
    {
        return S_OK;
    }

    auto endPaint = wil::scope_exit([&]() {
        LOG_IF_FAILED(pEngine->EndPaint());

        // If the engine tells us it really wants to redraw immediately,
        // tell the thread so it doesn't go to sleep and ticks again
  ...",1,<empty>,,108,10,CPPASTProblemDeclaration,,<empty>
516355,UNKNOWN,11,,"CATCH_RETURN()

void Renderer::NotifyPaintFrame() noexcept
{
    // If we're running in the unittests, we might not have a render thread.
    if (_pThread)
    {
        // The thread will provide throttling for us.
        _pThread->NotifyPaint();
    }
}",1,<empty>,,184,11,CPPASTProblemDeclaration,,<empty>
516691,UNKNOWN,-1,,"try
    {
        // Get selection rectangles
        auto rects = _GetSelectionRects();

        // Make a viewport representing the coordinates that are currently presentable.
        const til::rect viewport{ _pData->GetViewport().Dimensions() };

        // Restrict all previous selection rectangles to inside the current viewport bounds
        for (auto& sr : _previousSelection)
        {
            sr &= viewport;
        }

        FOREACH_ENGINE(pEngine)
        {
            LOG_IF_FAILED(pEngine->InvalidateSelection(_previousSelection));
            LOG_IF_FAILED(pEngine->InvalidateSelection(rects));
        }

        _previousSelection = std::move(rects);

        NotifyPaintFrame();
    }
    CATCH_LOG();",5,<empty>,,361,1,CPPASTProblemStatement,,<empty>
516957,UNKNOWN,26,,"void Renderer::TriggerFontChange(const int iDpi, const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo)
{
    FOREACH_ENGINE(pEngine)
    {
        LOG_IF_FAILED(pEngine->UpdateDpi(iDpi));
        LOG_IF_FAILED(pEngine->UpdateFont(FontInfoDesired, FontInfo));
    }

    NotifyPaintFrame();
}",1,<empty>,,528,26,CPPASTProblemDeclaration,,<empty>
517037,UNKNOWN,29,,"[[nodiscard]] HRESULT Renderer::GetProposedFont(const int iDpi, const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo)
{
    // There will only every really be two engines - the real head and the VT
    //      renderer. We won't know which is which, so iterate over them.
    //      Only return the result of the successful one if it's not S_FALSE (which is the VT renderer)
    // TODO: 14560740 - The Window might be able to get at this info in a more sane manner
    FOREACH_ENGINE(pEngine)
    {
        const auto hr = LOG_IF_FAILED(pEngine->GetProposedFont(FontInfoDesired, FontInfo, iDpi));
        // We're looking for specifically S_OK, S_FALSE is not good enough.
        if (hr == S_OK)
        {
            return hr;
        }
    }

    return E_FAIL;
}",1,<empty>,,580,29,CPPASTProblemDeclaration,,<empty>
517111,UNKNOWN,33,,"[[nodiscard]] HRESULT Renderer::_PaintBackground(_In_ IRenderEngine* const pEngine)
{
    return pEngine->PaintBackground();
}",1,<empty>,,669,33,CPPASTProblemDeclaration,,<empty>
517112,UNKNOWN,34,,"void Renderer::_PaintBufferOutput(_In_ IRenderEngine* const pEngine)
{
    // This is the subsection of the entire screen buffer that is currently being presented.
    // It can move left/right or top/bottom depending on how the viewport is scrolled
    // relative to the entire buffer.
    const auto view = _pData->GetViewport();

    // This is effectively the number of cells on the visible screen that need to be redrawn.
    // The origin is always 0, 0 because it represents the screen itself, not the underlying buffer.
    std::span<const til::rect> dirtyAreas;
    LOG_IF_FAILED(pEngine->GetDirtyArea(dirtyAreas));

    // This is to make sure any transforms are reset when this paint is finished.
    auto resetLineTransform = wil::scope_exit([&]() {
        LOG_IF_FAILED(pEngine->ResetLineTransform());
    });

    for (const auto& dirtyRect : dirtyAreas)
    {
        if (!dirtyRect)
        {
            continue;
        }

        auto dirty = Viewport::FromExclusive(dirtyRec...",1,<empty>,,682,34,CPPASTProblemDeclaration,,<empty>
517129,UNKNOWN,36,,"void Renderer::_PaintBufferOutputHelper(_In_ IRenderEngine* const pEngine,
                                        TextBufferCellIterator it,
                                        const til::point target,
                                        const bool lineWrapped)
{
    auto globalInvert{ _renderSettings.GetRenderMode(RenderSettings::Mode::ScreenReversed) };

    // If we have valid data, let's figure out how to draw it.
    if (it)
    {
        // TODO: MSFT: 20961091 -  This is a perf issue. Instead of rebuilding this and allocing memory to hold the reinterpretation,
        // we should have an iterator/view adapter for the rendering.
        // That would probably also eliminate the RenderData needing to give us the entire TextBuffer as well...
        // Retrieve the iterator for one line of information.
        til::CoordType cols = 0;

        // Retrieve the first color.
        auto color = it->TextAttr();
        // Retrieve the first pattern id
        auto pattern...",1,<empty>,,764,36,CPPASTProblemDeclaration,,<empty>
517300,UNKNOWN,38,,"void Renderer::_PaintBufferOutputGridLineHelper(_In_ IRenderEngine* const pEngine,
                                                const TextAttribute textAttribute,
                                                const size_t cchLine,
                                                const til::point coordTarget)
{
    // Convert console grid line representations into rendering engine enum representations.
    auto lines = Renderer::s_GetGridlines(textAttribute);

    // For now, we dash underline patterns and switch to regular underline on hover
    if (_isHoveredHyperlink(textAttribute) || _isInHoveredInterval(coordTarget))
    {
        lines.reset(GridLines::HyperlinkUnderline);
        lines.set(GridLines::Underline);
    }

    // Return early if there are no lines to paint.
    if (lines.any())
    {
        // Get the current foreground and underline colors to render the lines.
        const auto fg = _renderSettings.GetAttributeColors(textAttribute).first;
        const auto...",1,<empty>,,995,38,CPPASTProblemDeclaration,,<empty>
517541,UNKNOWN,42,,"void Renderer::_PaintCursor(_In_ IRenderEngine* const pEngine)
{
    const auto cursorInfo = _GetCursorInfo();
    if (cursorInfo.has_value())
    {
        LOG_IF_FAILED(pEngine->PaintCursor(cursorInfo.value()));
    }
}",1,<empty>,,1103,42,CPPASTProblemDeclaration,,<empty>
517542,UNKNOWN,43,,"[[nodiscard]] HRESULT Renderer::_PrepareRenderInfo(_In_ IRenderEngine* const pEngine)
{
    RenderFrameInfo info;
    info.cursorInfo = _GetCursorInfo();
    return pEngine->PrepareRenderInfo(info);
}",1,<empty>,,1123,43,CPPASTProblemDeclaration,,<empty>
517547,UNKNOWN,-1,,"try
    {
        // Now get the overlay's viewport and adjust it to where it is supposed to be relative to the window.
        auto srCaView = overlay.region.ToExclusive();
        srCaView.top += overlay.origin.y;
        srCaView.bottom += overlay.origin.y;
        srCaView.left += overlay.origin.x;
        srCaView.right += overlay.origin.x;

        std::span<const til::rect> dirtyAreas;
        LOG_IF_FAILED(engine.GetDirtyArea(dirtyAreas));

        for (const auto& rect : dirtyAreas)
        {
            if (const auto viewDirty = rect & srCaView)
            {
                for (auto iRow = viewDirty.top; iRow < viewDirty.bottom; iRow++)
                {
                    const til::point target{ viewDirty.left, iRow };
                    const auto source = target - overlay.origin;

                    auto it = overlay.buffer.GetCellLineDataAt(source);

                    _PaintBufferOutputHelper(&engine, it, target, false);
                }
            }
       ...",5,<empty>,,1141,1,CPPASTProblemStatement,,<empty>
517550,UNKNOWN,45,,"void Renderer::_PaintOverlays(_In_ IRenderEngine* const pEngine)
{
    try
    {
        const auto overlays = _pData->GetOverlays();

        for (const auto& overlay : overlays)
        {
            _PaintOverlay(*pEngine, overlay);
        }
    }
    CATCH_LOG();
}",1,<empty>,,1180,45,CPPASTProblemDeclaration,,<empty>
517551,UNKNOWN,46,,"void Renderer::_PaintSelection(_In_ IRenderEngine* const pEngine)
{
    try
    {
        std::span<const til::rect> dirtyAreas;
        LOG_IF_FAILED(pEngine->GetDirtyArea(dirtyAreas));

        // Get selection rectangles
        const auto rectangles = _GetSelectionRects();
        for (const auto& rect : rectangles)
        {
            for (auto& dirtyRect : dirtyAreas)
            {
                if (const auto rectCopy = rect & dirtyRect)
                {
                    LOG_IF_FAILED(pEngine->PaintSelection(rectCopy));
                }
            }
        }
    }
    CATCH_LOG();
}",1,<empty>,,1200,46,CPPASTProblemDeclaration,,<empty>
517552,UNKNOWN,47,,"[[nodiscard]] HRESULT Renderer::_UpdateDrawingBrushes(_In_ IRenderEngine* const pEngine,
                                                      const TextAttribute textAttributes,
                                                      const bool usingSoftFont,
                                                      const bool isSettingDefaultBrushes)
{
    // The last color needs to be each engine's responsibility. If it's local to this function,
    //      then on the next engine we might not update the color.
    return pEngine->UpdateDrawingBrushes(textAttributes, _renderSettings, _pData, usingSoftFont, isSettingDefaultBrushes);
}",1,<empty>,,1235,47,CPPASTProblemDeclaration,,<empty>
517553,UNKNOWN,48,,"[[nodiscard]] HRESULT Renderer::_PerformScrolling(_In_ IRenderEngine* const pEngine)
{
    return pEngine->ScrollFrame();
}",1,<empty>,,1253,48,CPPASTProblemDeclaration,,<empty>
517649,UNKNOWN,51,,"void Renderer::AddRenderEngine(_In_ IRenderEngine* const pEngine)
{
    THROW_HR_IF_NULL(E_INVALIDARG, pEngine);

    for (auto& p : _engines)
    {
        if (!p)
        {
            p = pEngine;
            return;
        }
    }

    THROW_HR_MSG(E_UNEXPECTED, ""engines array is full"");
}",1,<empty>,,1313,51,CPPASTProblemDeclaration,,<empty>
517650,UNKNOWN,52,,"void Renderer::RemoveRenderEngine(_In_ IRenderEngine* const pEngine)
{
    THROW_HR_IF_NULL(E_INVALIDARG, pEngine);

    for (auto& p : _engines)
    {
        if (p == pEngine)
        {
            p = nullptr;
            return;
        }
    }
}",1,<empty>,,1329,52,CPPASTProblemDeclaration,,<empty>
517766,UNKNOWN,-1,,"Renderer(const RenderSettings& renderSettings,
                 IRenderData* pData,
                 _In_reads_(cEngines) IRenderEngine** const pEngine,
                 const size_t cEngines,
                 std::unique_ptr<RenderThread> thread);",9,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
517836,UNKNOWN,-1,,"void TriggerFontChange(const int iDpi,
                               const FontInfoDesired& FontInfoDesired,
                               _Out_ FontInfo& FontInfo);",9,<empty>,,66,17,CPPASTProblemDeclaration,,<empty>
517844,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProposedFont(const int iDpi,
                                              const FontInfoDesired& FontInfoDesired,
                                              _Out_ FontInfo& FontInfo);",9,<empty>,,74,19,CPPASTProblemDeclaration,,<empty>
517863,UNKNOWN,-1,,void AddRenderEngine(_In_ IRenderEngine* const pEngine);,9,<empty>,,84,24,CPPASTProblemDeclaration,,<empty>
517864,UNKNOWN,-1,,void RemoveRenderEngine(_In_ IRenderEngine* const pEngine);,9,<empty>,,85,25,CPPASTProblemDeclaration,,<empty>
517906,UNKNOWN,-1,,[[nodiscard]] HRESULT _PaintFrameForEngine(_In_ IRenderEngine* const pEngine) noexcept;,9,<empty>,,99,34,CPPASTProblemDeclaration,,<empty>
517911,UNKNOWN,-1,,[[nodiscard]] HRESULT _PaintBackground(_In_ IRenderEngine* const pEngine);,9,<empty>,,101,36,CPPASTProblemDeclaration,,<empty>
517912,UNKNOWN,-1,,void _PaintBufferOutput(_In_ IRenderEngine* const pEngine);,9,<empty>,,102,37,CPPASTProblemDeclaration,,<empty>
517913,UNKNOWN,-1,,"void _PaintBufferOutputHelper(_In_ IRenderEngine* const pEngine, TextBufferCellIterator it, const til::point target, const bool lineWrapped);",9,<empty>,,103,38,CPPASTProblemDeclaration,,<empty>
517914,UNKNOWN,-1,,"void _PaintBufferOutputGridLineHelper(_In_ IRenderEngine* const pEngine, const TextAttribute textAttribute, const size_t cchLine, const til::point coordTarget);",9,<empty>,,104,39,CPPASTProblemDeclaration,,<empty>
517920,UNKNOWN,-1,,void _PaintSelection(_In_ IRenderEngine* const pEngine);,9,<empty>,,106,41,CPPASTProblemDeclaration,,<empty>
517921,UNKNOWN,-1,,void _PaintCursor(_In_ IRenderEngine* const pEngine);,9,<empty>,,107,42,CPPASTProblemDeclaration,,<empty>
517922,UNKNOWN,-1,,void _PaintOverlays(_In_ IRenderEngine* const pEngine);,9,<empty>,,108,43,CPPASTProblemDeclaration,,<empty>
517929,UNKNOWN,-1,,"[[nodiscard]] HRESULT _UpdateDrawingBrushes(_In_ IRenderEngine* const pEngine, const TextAttribute attr, const bool usingSoftFont, const bool isSettingDefaultBrushes);",9,<empty>,,110,45,CPPASTProblemDeclaration,,<empty>
517930,UNKNOWN,-1,,[[nodiscard]] HRESULT _PerformScrolling(_In_ IRenderEngine* const pEngine);,9,<empty>,,111,46,CPPASTProblemDeclaration,,<empty>
517954,UNKNOWN,-1,,[[nodiscard]] HRESULT _PrepareRenderInfo(_In_ IRenderEngine* const pEngine);,9,<empty>,,117,52,CPPASTProblemDeclaration,,<empty>
518192,UNKNOWN,4,,"DWORD WINAPI RenderThread::s_ThreadProc(_In_ LPVOID lpParameter)
{
    const auto pContext = static_cast<RenderThread*>(lpParameter);

    if (pContext != nullptr)
    {
        return pContext->_ThreadProc();
    }
    else
    {
        return (DWORD)E_INVALIDARG;
    }
}",1,<empty>,,154,4,CPPASTProblemDeclaration,,<empty>
518193,UNKNOWN,5,,DWORD,1,<empty>,,168,5,CPPASTProblemDeclaration,,<empty>
518349,UNKNOWN,-1,,static DWORD WINAPI s_ThreadProc(_In_ LPVOID lpParameter);,9,<empty>,,35,8,CPPASTProblemDeclaration,,<empty>
518350,UNKNOWN,-1,,DWORD,9,<empty>,,36,9,CPPASTProblemDeclaration,,<empty>
518406,UNKNOWN,3,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE BoxDrawingEffect::GetScale(BoxScale* scale) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, scale);
    *scale = _scale;
    return S_OK;
}",1,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
518436,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE GetScale(BoxScale* scale) noexcept override;,9,<empty>,,20,3,CPPASTProblemDeclaration,,<empty>
518529,UNKNOWN,2,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::Reset() noexcept
try
{
    _runs.clear();
    _breakpoints.clear();
    _runIndex = 0;
    _isEntireTextSimple = false;
    _textClusterColumns.clear();
    _text.clear();
    _glyphScaleCorrections.clear();
    _glyphClusters.clear();
    _glyphIndices.clear();
    _glyphDesignUnitAdvances.clear();
    _glyphAdvances.clear();
    _glyphOffsets.clear();
    return S_OK;
}",1,<empty>,,43,2,CPPASTProblemDeclaration,,<empty>
518530,UNKNOWN,3,,"CATCH_RETURN()

// Routine Description:
// - Appends text to this layout for analysis/processing.
// Arguments:
// - clusters - From the backing buffer, the text to be displayed clustered by the columns it should consume.
// Return Value:
// - S_OK or suitable memory management issue.
[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::AppendClusters(const std::span<const ::Microsoft::Console::Render::Cluster> clusters)
try
{
    _textClusterColumns.reserve(_textClusterColumns.size() + clusters.size());

    for (const auto& cluster : clusters)
    {
        const auto cols = gsl::narrow<UINT16>(cluster.GetColumns());
        const auto text = cluster.GetText();

        // Push back the number of columns for this bit of text.
        _textClusterColumns.push_back(cols);

        // If there is more than one text character here, push 0s for the rest of the columns
        // of the text run.
        _textClusterColumns.resize(_textClusterColumns.size() + base::ClampSub(text.si...",1,<empty>,,60,3,CPPASTProblemDeclaration,,<empty>
518531,UNKNOWN,4,,"CATCH_RETURN()

// Routine Description:
// - Figures out how many columns this layout should take. This will use the analyze step only.
// Arguments:
// - columns - The number of columns the layout should consume when done.
// Return Value:
// - S_OK or suitable DirectX/DirectWrite/Direct2D result code.
[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::GetColumns(_Out_ UINT32* columns)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, columns);
    *columns = 0;

    _formatInUse = _fontRenderData->DefaultTextFormat().Get();
    _fontInUse = _fontRenderData->DefaultFontFace().Get();

    RETURN_IF_FAILED(_AnalyzeTextComplexity());
    RETURN_IF_FAILED(_AnalyzeRuns());
    RETURN_IF_FAILED(_ShapeGlyphRuns());

    const auto totalAdvance = std::accumulate(_glyphAdvances.cbegin(), _glyphAdvances.cend(), 0.0f);

    *columns = static_cast<UINT32>(ceil(totalAdvance / _width));

    return S_OK;
}",1,<empty>,,90,4,CPPASTProblemDeclaration,,<empty>
518532,UNKNOWN,5,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::Draw(_In_opt_ void* clientDrawingContext,
                                                               _In_ IDWriteTextRenderer* renderer,
                                                               FLOAT originX,
                                                               FLOAT originY) noexcept
try
{
    const auto drawingContext = static_cast<const DrawingContext*>(clientDrawingContext);

    auto weight = _fontRenderData->DefaultFontWeight();
    auto style = _fontRenderData->DefaultFontStyle();
    const auto stretch = _fontRenderData->DefaultFontStretch();

    if (drawingContext->useBoldFont)
    {
        // TODO: ""relative"" bold?
        weight = DWRITE_FONT_WEIGHT_BOLD;
        // Since we are setting the font weight according to the text attribute,
        // make sure to tell the text format to ignore the user set font weight
        _fontRenderData->InhibitUserWeight(true);
    }
    else
    {
        _f...",1,<empty>,,132,5,CPPASTProblemDeclaration,,<empty>
518533,UNKNOWN,6,,"CATCH_RETURN()

// Routine Description:
// - Uses the internal text information and the analyzers/font information from construction
//   to determine the complexity of the text. If the text is determined to be entirely simple,
//   we'll have more chances to optimize the layout process.
// Arguments:
// - <none> - Uses internal state
// Return Value:
// - S_OK or suitable DirectWrite or STL error code
[[nodiscard]] HRESULT CustomTextLayout::_AnalyzeTextComplexity() noexcept
{
    try
    {
        const auto textLength = gsl::narrow<UINT32>(_text.size());

        auto isTextSimple = FALSE;
        UINT32 uiLengthRead = 0;

        // Start from the beginning.
        const UINT32 glyphStart = 0;

        _glyphIndices.resize(textLength);

        const auto hr = _fontRenderData->Analyzer()->GetTextComplexity(
            _text.c_str(),
            textLength,
            _fontInUse,
            &isTextSimple,
            &uiLengthRead,
            &_glyphIndices.at(glyphStart));

...",1,<empty>,,178,6,CPPASTProblemDeclaration,,<empty>
518536,UNKNOWN,-1,,"try
    {
        // We're going to need the text length in UINT32 format for the DWrite calls.
        // Convert it once up front.
        const auto textLength = gsl::narrow<UINT32>(_text.size());

        // Initially start out with one result that covers the entire range.
        // This result will be subdivided by the analysis processes.
        _runs.resize(1);
        auto& initialRun = _runs.front();
        initialRun.textLength = textLength;
        initialRun.bidiLevel = (_readingDirection == DWRITE_READING_DIRECTION_RIGHT_TO_LEFT);

        // Allocate enough room to have one breakpoint per code unit.
        _breakpoints.resize(_text.size());

        if (!_isEntireTextSimple || _fontRenderData->DidUserSetAxes())
        {
            // Call each of the analyzers in sequence, recording their results.
            RETURN_IF_FAILED(_fontRenderData->Analyzer()->AnalyzeLineBreakpoints(this, 0, textLength, this));
            RETURN_IF_FAILED(_fontRenderData->Analyzer()->A...",5,<empty>,,230,1,CPPASTProblemStatement,,<empty>
518543,UNKNOWN,-1,,"try
    {
        // Shapes all the glyph runs in the layout.
        const auto textLength = gsl::narrow<UINT32>(_text.size());

        // Estimate the maximum number of glyph indices needed to hold a string.
        const auto estimatedGlyphCount = _EstimateGlyphCount(textLength);

        _glyphIndices.resize(estimatedGlyphCount);
        _glyphOffsets.resize(estimatedGlyphCount);
        _glyphAdvances.resize(estimatedGlyphCount);
        _glyphClusters.resize(textLength);

        UINT32 glyphStart = 0;

        // Shape each run separately. This is needed whenever script, locale,
        // or reading direction changes.
        for (UINT32 runIndex = 0; runIndex < _runs.size(); ++runIndex)
        {
            LOG_IF_FAILED(_ShapeGlyphRun(runIndex, glyphStart));
        }

        _glyphIndices.resize(glyphStart);
        _glyphOffsets.resize(glyphStart);
        _glyphAdvances.resize(glyphStart);
    }
    CATCH_RETURN();",5,<empty>,,282,1,CPPASTProblemStatement,,<empty>
518552,UNKNOWN,-1,,"try
    {
        // Shapes a single run of text into glyphs.
        // Alternately, you could iteratively interleave shaping and line
        // breaking to reduce the number glyphs held onto at once. It's simpler
        // for this demonstration to just do shaping and line breaking as two
        // separate processes, but realize that this does have the consequence that
        // certain advanced fonts containing line specific features (like Gabriola)
        // will shape as if the line is not broken.

        Run& run = _runs.at(runIndex);
        const auto textStart = run.textStart;
        const auto textLength = run.textLength;
        auto maxGlyphCount = gsl::narrow<UINT32>(_glyphIndices.size() - glyphStart);
        UINT32 actualGlyphCount = 0;

        run.glyphStart = glyphStart;
        run.glyphCount = 0;

        if (textLength == 0)
        {
            return S_FALSE; // Nothing to do..
        }

        // Allocate space for shaping to fill with glyphs and o...",5,<empty>,,329,1,CPPASTProblemStatement,,<empty>
518559,UNKNOWN,-1,,"try
    {
        // For simple text, there is no need to correct runs.
        if (_isEntireTextSimple)
        {
            return S_OK;
        }

        // Correct each run separately. This is needed whenever script, locale,
        // or reading direction changes.
        for (UINT32 runIndex = 0; runIndex < _runs.size(); ++runIndex)
        {
            LOG_IF_FAILED(_CorrectGlyphRun(runIndex));
        }

        // If scale corrections were needed, we need to split the run.
        for (auto& c : _glyphScaleCorrections)
        {
            // Split after the adjustment first so it
            // takes a copy of all the run properties before we modify them.
            // GH 4665: This is the other half of the potential future perf item.
            //       If glyphs needing the same scale are coalesced, we could
            //       break fewer times and have fewer runs.

            // Example
            // Text:
            // ABCDEFGHIJKLMNOPQRSTUVWXYZ
            ...",5,<empty>,,506,1,CPPASTProblemStatement,,<empty>
518564,UNKNOWN,11,,"[[nodiscard]] HRESULT CustomTextLayout::_CorrectGlyphRun(const UINT32 runIndex) noexcept
try
{
    const Run& run = _runs.at(runIndex);

    if (run.textLength == 0)
    {
        return S_FALSE; // Nothing to do..
    }

    // We're going to walk through and check for advances that don't match the space that we expect to give out.

    // Glyph Indices represents the number inside the selected font where the glyph image/paths are found.
    // Text represents the original text we gave in.
    // Glyph Clusters represents the map between Text and Glyph Indices.
    //  - There is one Glyph Clusters map column per character of text.
    //  - The value of the cluster at any given position is relative to the 0 index of this run.
    //    (a.k.a. it resets to 0 for every run)
    //  - If multiple Glyph Cluster map values point to the same index, then multiple text chars were used
    //    to create the same glyph cluster.
    //  - The delta between the value from one Glyph Cluster...",1,<empty>,,643,11,CPPASTProblemDeclaration,,<empty>
518565,UNKNOWN,12,,"[[nodiscard]] HRESULT CustomTextLayout::_DrawGlyphRuns(_In_opt_ void* clientDrawingContext,
                                                       IDWriteTextRenderer* renderer,
                                                       const D2D_POINT_2F origin) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, renderer);

    try
    {
        // We're going to start from the origin given and walk to the right for each
        // sub-run that was calculated by the layout analysis.
        auto mutableOrigin = origin;

        // Draw each run separately.
        for (auto runIndex = 0; runIndex < gsl::narrow<INT32>(_runs.size()); ++runIndex)
        {
            // Get the run
            const Run& run = _runs.at(runIndex);

            if (!WI_IsFlagSet(run.bidiLevel, 1))
            {
                RETURN_IF_FAILED(_DrawGlyphRun(clientDrawingContext, renderer, mutableOrigin, run));
            }
            // This is the RTL behavior. We will advance to the last contiguous RTL run...",1,<empty>,,864,12,CPPASTProblemDeclaration,,<empty>
518566,UNKNOWN,13,,"[[nodiscard]] HRESULT CustomTextLayout::_DrawGlyphRun(_In_opt_ void* clientDrawingContext,
                                                      gsl::not_null<IDWriteTextRenderer*> renderer,
                                                      D2D_POINT_2F& mutableOrigin,
                                                      const Run& run) noexcept
{
    try
    {
        // Prepare the glyph run and description objects by converting our
        // internal storage representation into something that matches DWrite's structures.
        DWRITE_GLYPH_RUN glyphRun;
        glyphRun.bidiLevel = run.bidiLevel;
        glyphRun.fontEmSize = _formatInUse->GetFontSize() * run.fontScale;
        glyphRun.fontFace = run.fontFace.Get();
        glyphRun.glyphAdvances = &_glyphAdvances.at(run.glyphStart);
        glyphRun.glyphCount = run.glyphCount;
        glyphRun.glyphIndices = &_glyphIndices.at(run.glyphStart);
        glyphRun.glyphOffsets = &_glyphOffsets.at(run.glyphStart);
        gl...",1,<empty>,,932,13,CPPASTProblemDeclaration,,<empty>
518580,UNKNOWN,15,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::GetTextAtPosition(UINT32 textPosition,
                                                                            _Outptr_result_buffer_(*textLength) WCHAR const** textString,
                                                                            _Out_ UINT32* textLength)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, textString);
    RETURN_HR_IF_NULL(E_INVALIDARG, textLength);

    *textString = nullptr;
    *textLength = 0;

    if (textPosition < _text.size())
    {
        *textString = &_text.at(textPosition);
        *textLength = gsl::narrow<UINT32>(_text.size()) - textPosition;
    }

    return S_OK;
}",1,<empty>,,1016,15,CPPASTProblemDeclaration,,<empty>
518581,UNKNOWN,16,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::GetTextBeforePosition(UINT32 textPosition,
                                                                                _Outptr_result_buffer_(*textLength) WCHAR const** textString,
                                                                                _Out_ UINT32* textLength) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, textString);
    RETURN_HR_IF_NULL(E_INVALIDARG, textLength);

    *textString = nullptr;
    *textLength = 0;

    if (textPosition > 0 && textPosition <= _text.size())
    {
        *textString = _text.data();
        *textLength = textPosition;
    }

    return S_OK;
}",1,<empty>,,1045,16,CPPASTProblemDeclaration,,<empty>
518582,UNKNOWN,17,,"[[nodiscard]] DWRITE_READING_DIRECTION STDMETHODCALLTYPE CustomTextLayout::GetParagraphReadingDirection() noexcept
{
    return _readingDirection;
}",1,<empty>,,1071,17,CPPASTProblemDeclaration,,<empty>
518583,UNKNOWN,18,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::GetLocaleName(UINT32 textPosition,
                                                                        _Out_ UINT32* textLength,
                                                                        _Outptr_result_z_ const WCHAR** localeName) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, textLength);
    RETURN_HR_IF_NULL(E_INVALIDARG, localeName);

    *localeName = _localeName.data();
    *textLength = gsl::narrow<UINT32>(_text.size()) - textPosition;

    return S_OK;
}",1,<empty>,,1085,18,CPPASTProblemDeclaration,,<empty>
518584,UNKNOWN,19,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::GetNumberSubstitution(UINT32 textPosition,
                                                                                _Out_ UINT32* textLength,
                                                                                _COM_Outptr_ IDWriteNumberSubstitution** numberSubstitution) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, textLength);
    RETURN_HR_IF_NULL(E_INVALIDARG, numberSubstitution);

    *numberSubstitution = nullptr;
    *textLength = gsl::narrow<UINT32>(_text.size()) - textPosition;

    return S_OK;
}",1,<empty>,,1107,19,CPPASTProblemDeclaration,,<empty>
518585,UNKNOWN,20,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::SetScriptAnalysis(UINT32 textPosition,
                                                                            UINT32 textLength,
                                                                            _In_ const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis)
{
    try
    {
        _SetCurrentRun(textPosition);
        _SplitCurrentRun(textPosition);
        while (textLength > 0)
        {
            auto& run = _FetchNextRun(textLength);
            run.script = *scriptAnalysis;
        }
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1132,20,CPPASTProblemDeclaration,,<empty>
518586,UNKNOWN,21,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::SetLineBreakpoints(UINT32 textPosition,
                                                                             UINT32 textLength,
                                                                             _In_reads_(textLength) DWRITE_LINE_BREAKPOINT const* lineBreakpoints)
{
    try
    {
        if (textLength > 0)
        {
            RETURN_HR_IF_NULL(E_INVALIDARG, lineBreakpoints);
            std::copy_n(lineBreakpoints, textLength, _breakpoints.begin() + textPosition);
        }
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1161,21,CPPASTProblemDeclaration,,<empty>
518587,UNKNOWN,22,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::SetBidiLevel(UINT32 textPosition,
                                                                       UINT32 textLength,
                                                                       UINT8 /*explicitLevel*/,
                                                                       UINT8 resolvedLevel)
{
    try
    {
        _SetCurrentRun(textPosition);
        _SplitCurrentRun(textPosition);
        while (textLength > 0)
        {
            auto& run = _FetchNextRun(textLength);
            run.bidiLevel = resolvedLevel;
        }
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1189,22,CPPASTProblemDeclaration,,<empty>
518588,UNKNOWN,23,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::SetNumberSubstitution(UINT32 textPosition,
                                                                                UINT32 textLength,
                                                                                _In_ IDWriteNumberSubstitution* numberSubstitution)
{
    try
    {
        _SetCurrentRun(textPosition);
        _SplitCurrentRun(textPosition);
        while (textLength > 0)
        {
            auto& run = _FetchNextRun(textLength);
            run.isNumberSubstituted = (numberSubstitution != nullptr);
        }
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1219,23,CPPASTProblemDeclaration,,<empty>
518589,UNKNOWN,24,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::_AnalyzeFontFallback(IDWriteTextAnalysisSource* const source,
                                                                               UINT32 textPosition,
                                                                               UINT32 textLength)
{
    try
    {
        // Get the font fallback first
        ::Microsoft::WRL::ComPtr<IDWriteTextFormat1> format1;
        if (FAILED(_formatInUse->QueryInterface(IID_PPV_ARGS(&format1))))
        {
            // If IDWriteTextFormat1 does not exist, return directly as this OS version doesn't have font fallback.
            return S_FALSE;
        }
        RETURN_HR_IF_NULL(E_NOINTERFACE, format1);

        ::Microsoft::WRL::ComPtr<IDWriteFontFallback> fallback;
        RETURN_IF_FAILED(format1->GetFontFallback(&fallback));

        ::Microsoft::WRL::ComPtr<IDWriteFontCollection> collection;
        RETURN_IF_FAILED(format1->GetFontCollection(&collection));

        ...",1,<empty>,,1248,24,CPPASTProblemDeclaration,,<empty>
518590,UNKNOWN,25,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::_SetMappedFontFace(UINT32 textPosition,
                                                                             UINT32 textLength,
                                                                             const ::Microsoft::WRL::ComPtr<IDWriteFontFace>& fontFace,
                                                                             FLOAT const scale)
{
    try
    {
        _SetCurrentRun(textPosition);
        _SplitCurrentRun(textPosition);
        while (textLength > 0)
        {
            auto& run = _FetchNextRun(textLength);

            if (fontFace != nullptr)
            {
                RETURN_IF_FAILED(fontFace.As(&run.fontFace));
            }
            else
            {
                run.fontFace = _fontInUse;
            }

            // Store the font scale as well.
            run.fontScale = scale;
        }
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1364,25,CPPASTProblemDeclaration,,<empty>
518609,UNKNOWN,27,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::_CorrectBoxDrawing() noexcept
try
{
    RETURN_IF_FAILED(_AnalyzeBoxDrawing(this, 0, gsl::narrow<UINT32>(_text.size())));
    _OrderRuns();
    return S_OK;
}",1,<empty>,,1423,27,CPPASTProblemDeclaration,,<empty>
518610,UNKNOWN,28,,CATCH_RETURN();,1,<empty>,,1430,28,CPPASTProblemDeclaration,,<empty>
518611,UNKNOWN,29,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::_AnalyzeBoxDrawing(const gsl::not_null<IDWriteTextAnalysisSource*> source,
                                                                             UINT32 textPosition,
                                                                             UINT32 textLength)
try
{
    // Walk through and analyze the entire string
    while (textLength > 0)
    {
        // Get the substring of text remaining to analyze.
        const WCHAR* text;
        UINT32 length;
        RETURN_IF_FAILED(source->GetTextAtPosition(textPosition, &text, &length));

        // Put it into a view for iterator convenience.
        const std::wstring_view str(text, length);

        // Find the first box drawing character in the string from the front.
        const auto firstBox = std::find_if(str.cbegin(), str.cend(), _IsBoxDrawingCharacter);

        // If we found no box drawing characters, move on with life.
        if (firstBox == str.cend())
  ...",1,<empty>,,1441,29,CPPASTProblemDeclaration,,<empty>
518612,UNKNOWN,30,,CATCH_RETURN();,1,<empty>,,1496,30,CPPASTProblemDeclaration,,<empty>
518613,UNKNOWN,31,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE CustomTextLayout::_SetBoxEffect(UINT32 textPosition,
                                                                        UINT32 textLength)
try
{
    _SetCurrentRun(textPosition);
    _SplitCurrentRun(textPosition);

    while (textLength > 0)
    {
        auto& run = _FetchNextRun(textLength);

        if (run.fontFace == _fontRenderData->DefaultFontFace())
        {
            run.drawingEffect = _fontRenderData->DefaultBoxDrawingEffect();
        }
        else
        {
            ::Microsoft::WRL::ComPtr<IBoxDrawingEffect> eff;
            RETURN_IF_FAILED(DxFontRenderData::s_CalculateBoxEffect(_formatInUse, _width, run.fontFace.Get(), run.fontScale, &eff));

            // store data in the run
            run.drawingEffect = std::move(eff);
        }
    }

    return S_OK;
}",1,<empty>,,1505,31,CPPASTProblemDeclaration,,<empty>
518614,UNKNOWN,32,,CATCH_RETURN();,1,<empty>,,1532,32,CPPASTProblemDeclaration,,<empty>
518967,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE AppendClusters(const std::span<const ::Microsoft::Console::Render::Cluster> clusters);,9,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
518968,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE Reset() noexcept;,9,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
518969,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE GetColumns(_Out_ UINT32* columns);,9,<empty>,,30,4,CPPASTProblemDeclaration,,<empty>
518970,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE Draw(_In_opt_ void* clientDrawingContext,
                                                     _In_ IDWriteTextRenderer* renderer,
                                                     FLOAT originX,
                                                     FLOAT originY) noexcept;",9,<empty>,,33,5,CPPASTProblemDeclaration,,<empty>
518971,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetTextAtPosition(UINT32 textPosition,
                                                                  _Outptr_result_buffer_(*textLength) WCHAR const** textString,
                                                                  _Out_ UINT32* textLength) override;",9,<empty>,,39,6,CPPASTProblemDeclaration,,<empty>
518972,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetTextBeforePosition(UINT32 textPosition,
                                                                      _Outptr_result_buffer_(*textLength) WCHAR const** textString,
                                                                      _Out_ UINT32* textLength) noexcept override;",9,<empty>,,42,7,CPPASTProblemDeclaration,,<empty>
518973,UNKNOWN,-1,,[[nodiscard]] DWRITE_READING_DIRECTION STDMETHODCALLTYPE GetParagraphReadingDirection() noexcept override;,9,<empty>,,45,8,CPPASTProblemDeclaration,,<empty>
518974,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetLocaleName(UINT32 textPosition,
                                                              _Out_ UINT32* textLength,
                                                              _Outptr_result_z_ const WCHAR** localeName) noexcept override;",9,<empty>,,46,9,CPPASTProblemDeclaration,,<empty>
518975,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetNumberSubstitution(UINT32 textPosition,
                                                                      _Out_ UINT32* textLength,
                                                                      _COM_Outptr_ IDWriteNumberSubstitution** numberSubstitution) noexcept override;",9,<empty>,,49,10,CPPASTProblemDeclaration,,<empty>
518976,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE SetScriptAnalysis(UINT32 textPosition,
                                                                  UINT32 textLength,
                                                                  _In_ const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis) override;",9,<empty>,,54,11,CPPASTProblemDeclaration,,<empty>
518977,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE SetLineBreakpoints(UINT32 textPosition,
                                                                   UINT32 textLength,
                                                                   _In_reads_(textLength) DWRITE_LINE_BREAKPOINT const* lineBreakpoints) override;",9,<empty>,,57,12,CPPASTProblemDeclaration,,<empty>
518978,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE SetBidiLevel(UINT32 textPosition,
                                                             UINT32 textLength,
                                                             UINT8 explicitLevel,
                                                             UINT8 resolvedLevel) override;",9,<empty>,,60,13,CPPASTProblemDeclaration,,<empty>
518979,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE SetNumberSubstitution(UINT32 textPosition,
                                                                      UINT32 textLength,
                                                                      _In_ IDWriteNumberSubstitution* numberSubstitution) override;",9,<empty>,,64,14,CPPASTProblemDeclaration,,<empty>
519048,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE _AnalyzeFontFallback(IDWriteTextAnalysisSource* const source, UINT32 textPosition, UINT32 textLength);",9,<empty>,,128,22,CPPASTProblemDeclaration,,<empty>
519049,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE _SetMappedFontFace(UINT32 textPosition, UINT32 textLength, const ::Microsoft::WRL::ComPtr<IDWriteFontFace>& fontFace, FLOAT const scale);",9,<empty>,,129,23,CPPASTProblemDeclaration,,<empty>
519050,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE _AnalyzeBoxDrawing(const gsl::not_null<IDWriteTextAnalysisSource*> source, UINT32 textPosition, UINT32 textLength);",9,<empty>,,131,24,CPPASTProblemDeclaration,,<empty>
519051,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE _SetBoxEffect(UINT32 textPosition, UINT32 textLength);",9,<empty>,,132,25,CPPASTProblemDeclaration,,<empty>
519079,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE _CorrectBoxDrawing() noexcept;,9,<empty>,,140,32,CPPASTProblemDeclaration,,<empty>
519080,UNKNOWN,-1,,"[[nodiscard]] HRESULT _DrawGlyphRuns(_In_opt_ void* clientDrawingContext,
                                             IDWriteTextRenderer* renderer,
                                             const D2D_POINT_2F origin) noexcept;",9,<empty>,,141,33,CPPASTProblemDeclaration,,<empty>
519081,UNKNOWN,-1,,"[[nodiscard]] HRESULT _DrawGlyphRun(_In_opt_ void* clientDrawingContext,
                                            gsl::not_null<IDWriteTextRenderer*> renderer,
                                            D2D_POINT_2F& mutableOrigin,
                                            const Run& run) noexcept;",9,<empty>,,144,34,CPPASTProblemDeclaration,,<empty>
519132,UNKNOWN,1,,"[[nodiscard]] HRESULT CustomTextRenderer::IsPixelSnappingDisabled(void* /*clientDrawingContext*/,
                                                                  _Out_ BOOL* isDisabled) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, isDisabled);

    *isDisabled = false;
    return S_OK;
}",1,<empty>,,25,1,CPPASTProblemDeclaration,,<empty>
519133,UNKNOWN,2,,"[[nodiscard]] HRESULT CustomTextRenderer::GetPixelsPerDip(void* clientDrawingContext,
                                                          _Out_ FLOAT* pixelsPerDip) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pixelsPerDip);

    const DrawingContext* drawingContext = static_cast<DrawingContext*>(clientDrawingContext);
    RETURN_HR_IF_NULL(E_INVALIDARG, drawingContext);

    float dpiX, dpiY;
    drawingContext->renderTarget->GetDpi(&dpiX, &dpiY);
    *pixelsPerDip = dpiX / USER_DEFAULT_SCREEN_DPI;
    return S_OK;
}",1,<empty>,,44,2,CPPASTProblemDeclaration,,<empty>
519145,UNKNOWN,1,,DrawingContext*,56,<empty>,,72,1,CPPASTTypeId,,<empty>
519209,UNKNOWN,4,,"[[nodiscard]] HRESULT CustomTextRenderer::DrawUnderline(void* clientDrawingContext,
                                                        FLOAT baselineOriginX,
                                                        FLOAT baselineOriginY,
                                                        _In_ const DWRITE_UNDERLINE* underline,
                                                        IUnknown* clientDrawingEffect) noexcept
{
    return _FillRectangle(clientDrawingContext,
                          clientDrawingEffect,
                          baselineOriginX,
                          baselineOriginY + underline->offset,
                          underline->width,
                          underline->thickness,
                          underline->readingDirection,
                          underline->flowDirection);
}",1,<empty>,,106,4,CPPASTProblemDeclaration,,<empty>
519210,UNKNOWN,5,,"[[nodiscard]] HRESULT CustomTextRenderer::DrawStrikethrough(void* clientDrawingContext,
                                                            FLOAT baselineOriginX,
                                                            FLOAT baselineOriginY,
                                                            _In_ const DWRITE_STRIKETHROUGH* strikethrough,
                                                            IUnknown* clientDrawingEffect) noexcept
{
    return _FillRectangle(clientDrawingContext,
                          clientDrawingEffect,
                          baselineOriginX,
                          baselineOriginY + strikethrough->offset,
                          strikethrough->width,
                          strikethrough->thickness,
                          strikethrough->readingDirection,
                          strikethrough->flowDirection);
}",1,<empty>,,137,5,CPPASTProblemDeclaration,,<empty>
519225,UNKNOWN,1,,DrawingContext*,39,<empty>,,175,1,CPPASTTypeId,,<empty>
519244,UNKNOWN,1,,ID2D1Brush*,29,<empty>,,183,1,CPPASTTypeId,,<empty>
519300,UNKNOWN,8,,"[[nodiscard]] HRESULT CustomTextRenderer::DrawCursor(gsl::not_null<ID2D1DeviceContext*> d2dContext,
                                                     D2D1_RECT_F textRunBounds,
                                                     const DrawingContext& drawingContext,
                                                     const bool firstPass)
try
{
    if (!drawingContext.cursorInfo.has_value())
    {
        return S_FALSE;
    }

    const auto& options = drawingContext.cursorInfo.value();

    // if the cursor is off, do nothing - it should not be visible.
    if (!options.isOn)
    {
        return S_FALSE;
    }

    const auto fInvert = !options.fUseColor;
    // The normal, colored FullBox and legacy cursors are drawn in the first pass
    // so they go behind the text.
    // Inverted cursors are drawn in two passes.
    // All other cursors are drawn in the second pass only.
    if (!fInvert)
    {
        if (firstPass != (options.cursorType == CursorType::FullBox))
     ...",1,<empty>,,241,8,CPPASTProblemDeclaration,,<empty>
519301,UNKNOWN,9,,"[[nodiscard]] HRESULT CustomTextRenderer::EndClip(void* clientDrawingContext) noexcept
try
{
    auto drawingContext = static_cast<DrawingContext*>(clientDrawingContext);
    RETURN_HR_IF(E_INVALIDARG, !drawingContext);

    if (_clipRect.has_value())
    {
        drawingContext->renderTarget->PopAxisAlignedClip();
        _clipRect = std::nullopt;
    }

    return S_OK;
}
CATCH_RETURN()

[[nodiscard]] HRESULT CustomTextRenderer::_DrawBasicGlyphRun(DrawingContext* clientDrawingContext,
                                                             D2D1_POINT_2F baselineOrigin,
                                                             DWRITE_MEASURING_MODE measuringMode,
                                                             _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                             _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
                                                             ID2D1Brush* brush,
        ...",1,<empty>,,755,9,CPPASTProblemDeclaration,,<empty>
519302,UNKNOWN,10,,"[[nodiscard]] HRESULT CustomTextRenderer::_DrawBoxRunManually(DrawingContext* clientDrawingContext,
                                                              D2D1_POINT_2F baselineOrigin,
                                                              DWRITE_MEASURING_MODE /*measuringMode*/,
                                                              _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                              _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* /*glyphRunDescription*/,
                                                              _In_ IBoxDrawingEffect* clientDrawingEffect) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, clientDrawingContext);
    RETURN_HR_IF_NULL(E_INVALIDARG, glyphRun);
    RETURN_HR_IF_NULL(E_INVALIDARG, clientDrawingEffect);

    ::Microsoft::WRL::ComPtr<ID2D1Factory> d2dFactory;
    clientDrawingContext->renderTarget->GetFactory(d2dFactory.GetAddressOf());

    ::Microsoft::WRL::ComPtr<ID2D1PathGeometry>...",1,<empty>,,807,10,CPPASTProblemDeclaration,,<empty>
519303,UNKNOWN,11,,CATCH_RETURN();,1,<empty>,,923,11,CPPASTProblemDeclaration,,<empty>
519304,UNKNOWN,12,,"[[nodiscard]] HRESULT CustomTextRenderer::_DrawGlowGlyphRun(DrawingContext* clientDrawingContext,
                                                            D2D1_POINT_2F baselineOrigin,
                                                            DWRITE_MEASURING_MODE /*measuringMode*/,
                                                            _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                            _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* /*glyphRunDescription*/) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, clientDrawingContext);
    RETURN_HR_IF_NULL(E_INVALIDARG, glyphRun);

    // This is glow text manually
    ::Microsoft::WRL::ComPtr<ID2D1Factory> d2dFactory;
    clientDrawingContext->renderTarget->GetFactory(d2dFactory.GetAddressOf());

    ::Microsoft::WRL::ComPtr<ID2D1PathGeometry> pathGeometry;
    d2dFactory->CreatePathGeometry(pathGeometry.GetAddressOf());

    ::Microsoft::WRL::ComPtr<ID2D1GeometrySink> geometrySink;
  ...",1,<empty>,,925,12,CPPASTProblemDeclaration,,<empty>
519364,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE IsPixelSnappingDisabled(void* clientDrawingContext,
                                                                        _Out_ BOOL* isDisabled) noexcept override;",9,<empty>,,75,1,CPPASTProblemDeclaration,,<empty>
519365,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetPixelsPerDip(void* clientDrawingContext,
                                                                _Out_ FLOAT* pixelsPerDip) noexcept override;",9,<empty>,,78,2,CPPASTProblemDeclaration,,<empty>
519366,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE GetCurrentTransform(void* clientDrawingContext,
                                                                    _Out_ DWRITE_MATRIX* transform) noexcept override;",9,<empty>,,81,3,CPPASTProblemDeclaration,,<empty>
519367,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE DrawGlyphRun(void* clientDrawingContext,
                                                             FLOAT baselineOriginX,
                                                             FLOAT baselineOriginY,
                                                             DWRITE_MEASURING_MODE measuringMode,
                                                             _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                             _In_ const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
                                                             IUnknown* clientDrawingEffect) override;",9,<empty>,,85,4,CPPASTProblemDeclaration,,<empty>
519368,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE DrawUnderline(void* clientDrawingContext,
                                                              FLOAT baselineOriginX,
                                                              FLOAT baselineOriginY,
                                                              _In_ const DWRITE_UNDERLINE* underline,
                                                              IUnknown* clientDrawingEffect) noexcept override;",9,<empty>,,93,5,CPPASTProblemDeclaration,,<empty>
519369,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE DrawStrikethrough(void* clientDrawingContext,
                                                                  FLOAT baselineOriginX,
                                                                  FLOAT baselineOriginY,
                                                                  _In_ const DWRITE_STRIKETHROUGH* strikethrough,
                                                                  IUnknown* clientDrawingEffect) noexcept override;",9,<empty>,,99,6,CPPASTProblemDeclaration,,<empty>
519370,UNKNOWN,-1,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE DrawInlineObject(void* clientDrawingContext,
                                                                 FLOAT originX,
                                                                 FLOAT originY,
                                                                 IDWriteInlineObject* inlineObject,
                                                                 BOOL isSideways,
                                                                 BOOL isRightToLeft,
                                                                 IUnknown* clientDrawingEffect) noexcept override;",9,<empty>,,105,7,CPPASTProblemDeclaration,,<empty>
519371,UNKNOWN,-1,,[[nodiscard]] HRESULT STDMETHODCALLTYPE EndClip(void* clientDrawingContext) noexcept;,9,<empty>,,113,8,CPPASTProblemDeclaration,,<empty>
519392,UNKNOWN,-1,,"[[nodiscard]] HRESULT _DrawBasicGlyphRun(DrawingContext* clientDrawingContext,
                                                 D2D1_POINT_2F baselineOrigin,
                                                 DWRITE_MEASURING_MODE measuringMode,
                                                 _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                 _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
                                                 ID2D1Brush* brush,
                                                 _In_opt_ IUnknown* clientDrawingEffect);",9,<empty>,,130,11,CPPASTProblemDeclaration,,<empty>
519393,UNKNOWN,-1,,"[[nodiscard]] HRESULT _DrawBoxRunManually(DrawingContext* clientDrawingContext,
                                                  D2D1_POINT_2F baselineOrigin,
                                                  DWRITE_MEASURING_MODE measuringMode,
                                                  _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                  _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
                                                  _In_ IBoxDrawingEffect* clientDrawingEffect) noexcept;",9,<empty>,,138,12,CPPASTProblemDeclaration,,<empty>
519394,UNKNOWN,-1,,"[[nodiscard]] HRESULT _DrawGlowGlyphRun(DrawingContext* clientDrawingContext,
                                                D2D1_POINT_2F baselineOrigin,
                                                DWRITE_MEASURING_MODE measuringMode,
                                                _In_ const DWRITE_GLYPH_RUN* glyphRun,
                                                _In_opt_ const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription) noexcept;",9,<empty>,,145,13,CPPASTProblemDeclaration,,<empty>
519589,UNKNOWN,-1,,"try
    {
        face = _FindFontFace(localeName);
    }
    CATCH_LOG();",5,<empty>,,126,3,CPPASTProblemStatement,,<empty>
519596,UNKNOWN,-1,,"try
        {
            if (!face)
            {
                _fontCollection = FontCache::GetCached();
                face = _FindFontFace(localeName);
            }
        }
        CATCH_LOG();",9,<empty>,,134,1,CPPASTProblemStatement,,<empty>
519636,UNKNOWN,-1,,"try
            {
                // Try to find it with the shortened family name
                face = _FindFontFace(localeName);
            }
            CATCH_LOG();",13,<empty>,,169,5,CPPASTProblemStatement,,<empty>
519648,UNKNOWN,-1,,"try
            {
                face = _FindFontFace(localeName);
            }
            CATCH_LOG();",13,<empty>,,187,2,CPPASTProblemStatement,,<empty>
520454,UNKNOWN,-1,,"try
    {
        _userLocaleName.clear();
        _textFormatMap.clear();
        _fontFaceMap.clear();
        _boxDrawingEffect.Reset();

        // Initialize the default font info and build everything from here.
        _defaultFontInfo = DxFontInfo(
            _dwriteFactory.Get(),
            desired.GetFaceName(),
            static_cast<DWRITE_FONT_WEIGHT>(desired.GetWeight()),
            DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL);

        _SetFeatures(features);
        _SetAxes(axes);

        _BuildFontRenderData(desired, actual, dpi);
    }
    CATCH_RETURN();",5,<empty>,,185,1,CPPASTProblemStatement,,<empty>
520459,UNKNOWN,23,,"[[nodiscard]] HRESULT STDMETHODCALLTYPE DxFontRenderData::s_CalculateBoxEffect(IDWriteTextFormat* format, size_t widthPixels, IDWriteFontFace1* face, float fontScale, IBoxDrawingEffect** effect) noexcept
try
{
    // Check for bad in parameters.
    RETURN_HR_IF(E_INVALIDARG, !format);
    RETURN_HR_IF(E_INVALIDARG, !face);

    // Check the out parameter and fill it up with null.
    RETURN_HR_IF(E_INVALIDARG, !effect);
    *effect = nullptr;

    // The format is based around the main font that was specified by the user.
    // We need to know its size as well as the final spacing that was calculated around
    // it when it was first selected to get an idea of how large the bounding box is.
    const auto fontSize = format->GetFontSize();

    DWRITE_LINE_SPACING_METHOD spacingMethod;
    float lineSpacing; // total height of the cells
    float baseline; // vertical position counted down from the top where the characters ""sit""
    RETURN_IF_FAILED(format->GetLineSpacing(&spacing...",1,<empty>,,220,23,CPPASTProblemDeclaration,,<empty>
520460,UNKNOWN,24,,"CATCH_RETURN()

// Routine Description:
// - Returns whether the user set or updated any of the font features to be applied
bool DxFontRenderData::DidUserSetFeatures() const noexcept
{
    return _didUserSetFeatures;
}",1,<empty>,,449,24,CPPASTProblemDeclaration,,<empty>
520980,UNKNOWN,1,,float,35,<empty>,,708,1,CPPASTTypeId,,<empty>
521060,UNKNOWN,1,,float,43,<empty>,,744,1,CPPASTTypeId,,<empty>
521221,UNKNOWN,1,,til::CoordType,35,<empty>,,824,1,CPPASTTypeId,,<empty>
521228,UNKNOWN,1,,til::CoordType,36,<empty>,,825,1,CPPASTTypeId,,<empty>
521766,UNKNOWN,-1,,"[[nodiscard]] static HRESULT STDMETHODCALLTYPE s_CalculateBoxEffect(IDWriteTextFormat* format, size_t widthPixels, IDWriteFontFace1* face, float fontScale, IBoxDrawingEffect** effect) noexcept;",9,<empty>,,88,18,CPPASTProblemDeclaration,,<empty>
521918,UNKNOWN,3,,"TRACELOGGING_DEFINE_PROVIDER(g_hDxRenderProvider,
                             ""Microsoft.Windows.Terminal.Renderer.DirectX"",
                             // {c93e739e-ae50-5a14-78e7-f171e947535d}
                             (0xc93e739e, 0xae50, 0x5a14, 0x78, 0xe7, 0xf1, 0x71, 0xe9, 0x47, 0x53, 0x5d), );",1,<empty>,,25,3,CPPASTProblemDeclaration,,<empty>
522040,UNKNOWN,1,,IUnknown**,26,<empty>,,123,1,CPPASTTypeId,,<empty>
522276,UNKNOWN,1,,LPVOID*,79,<empty>,,326,1,CPPASTTypeId,,<empty>
522322,UNKNOWN,1,,float,28,<empty>,,339,1,CPPASTTypeId,,<empty>
522331,UNKNOWN,1,,float,29,<empty>,,340,1,CPPASTTypeId,,<empty>
522477,UNKNOWN,1,,const D3D11_INPUT_ELEMENT_DESC*,21,<empty>,,401,1,CPPASTTypeId,,<empty>
522528,UNKNOWN,1,,const void*,36,<empty>,,415,1,CPPASTTypeId,,<empty>
522695,UNKNOWN,-1,,"try
        {
            // Set the time (seconds since the shader was loaded)
            _pixelShaderSettings.Time = std::chrono::duration_cast<std::chrono::duration<float>>(std::chrono::steady_clock::now() - _shaderStartTime).count();

            // Set the UI Scale
            _pixelShaderSettings.Scale = _scale;

            // Set the display resolution
            const auto w = static_cast<float>(_displaySizePixels.width);
            const auto h = static_cast<float>(_displaySizePixels.height);
            _pixelShaderSettings.Resolution = XMFLOAT2{ w, h };

            // Set the background
            DirectX::XMFLOAT4 background{};
            background.x = _backgroundColor.r;
            background.y = _backgroundColor.g;
            background.z = _backgroundColor.b;
            background.w = _backgroundColor.a;
            _pixelShaderSettings.Background = background;

            _d3dDeviceContext->UpdateSubresource(_pixelShaderSettingsBuffer.Get(), 0, nullptr, &...",9,<empty>,,467,1,CPPASTProblemStatement,,<empty>
522736,UNKNOWN,21,,"[[nodiscard]] HRESULT DxEngine::_CreateDeviceResources(const bool createSwapChain) noexcept
try
{
    if (_haveDeviceResources)
    {
        _ReleaseDeviceResources();
    }

    auto freeOnFail = wil::scope_exit([&]() noexcept { _ReleaseDeviceResources(); });

    RETURN_IF_FAILED(CreateDXGIFactory1(IID_PPV_ARGS(&_dxgiFactory2)));

    const DWORD DeviceFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT |
                              // clang-format off
// This causes problems for folks who do not have the whole DirectX SDK installed
// when they try to run the rest of the project in debug mode.
// As such, I'm leaving this flag here for people doing DX-specific work to toggle it
// only when they need it and shutting it off otherwise.
// Find out more about the debug layer here:
// https://docs.microsoft.com/en-us/windows/desktop/direct3d11/overviews-direct3d-11-devices-layers
// You can find out how to install it here:
// https://docs.microsoft.com/en-us/windows/uwp/gaming/use-the-direct...",1,<empty>,,530,21,CPPASTProblemDeclaration,,<empty>
522768,UNKNOWN,-1,,"try
    {
        // Pull surface out of swap chain.
        RETURN_IF_FAILED(_dxgiSwapChain->GetBuffer(0, IID_PPV_ARGS(&_dxgiSurface)));

        // Make a bitmap and bind it to the swap chain surface
        const auto bitmapProperties = D2D1::BitmapProperties1(
            D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW,
            D2D1::PixelFormat(_swapChainDesc.Format, _dxgiAlphaToD2d1Alpha(_swapChainDesc.AlphaMode)));

        RETURN_IF_FAILED(_d2dDeviceContext->CreateBitmapFromDxgiSurface(_dxgiSurface.Get(), bitmapProperties, &_d2dBitmap));

        // Assign that bitmap as the target of the D2D device context. Draw commands hit the context
        // and are backed by the bitmap which is bound to the swap chain which goes on to be presented.
        // (The foot bone connected to the leg bone,
        //  The leg bone connected to the knee bone,
        //  The knee bone connected to the thigh bone
        //  ... and so on)

        _d2dDeviceContext->SetTarg...",5,<empty>,,765,1,CPPASTProblemStatement,,<empty>
522773,UNKNOWN,-1,,"try
    {
        _haveDeviceResources = false;

        // Destroy Terminal Effect resources
        _renderTargetView.Reset();
        _vertexShader.Reset();
        _pixelShader.Reset();
        _vertexLayout.Reset();
        _screenQuadVertexBuffer.Reset();
        _pixelShaderSettingsBuffer.Reset();
        _samplerState.Reset();
        _framebufferCapture.Reset();

        _d2dBrushForeground.Reset();
        _d2dBrushBackground.Reset();

        _d2dBitmap.Reset();

        _softFont.Reset();

        if (nullptr != _d2dDeviceContext.Get() && _isPainting)
        {
            _d2dDeviceContext->EndDraw();
        }

        _d2dDeviceContext.Reset();

        _dxgiSurface.Reset();
        _dxgiSwapChain.Reset();
        _swapChainFrameLatencyWaitableObject.reset();

        _d2dDevice.Reset();
        _dxgiDevice.Reset();

        if (nullptr != _d3dDeviceContext.Get())
        {
            // To ensure the swap chain goes away we must unbind any views from the
           ...",5,<empty>,,851,1,CPPASTProblemStatement,,<empty>
522834,UNKNOWN,26,,"[[nodiscard]] HRESULT DxEngine::_CreateTextLayout(
    _In_reads_(stringLength) PCWCHAR string,
    _In_ size_t stringLength,
    _Out_ IDWriteTextLayout** ppTextLayout) noexcept
try
{
    return _dwriteFactory->CreateTextLayout(string,
                                            gsl::narrow<UINT32>(stringLength),
                                            _fontRenderData->DefaultTextFormat().Get(),
                                            static_cast<float>(_displaySizePixels.width),
                                            _fontRenderData->GlyphCell().height != 0 ? _fontRenderData->GlyphCell().narrow_height<float>() : _displaySizePixels.narrow_height<float>(),
                                            ppTextLayout);
}",1,<empty>,,948,26,CPPASTProblemDeclaration,,<empty>
522835,UNKNOWN,27,,"CATCH_RETURN()

// Routine Description:
// - Sets the target window handle for our display pipeline
// - We will take over the surface of this window for drawing
// Arguments:
// - hwnd - Window handle
// Return Value:
// - S_OK
[[nodiscard]] HRESULT DxEngine::SetHwnd(const HWND hwnd) noexcept
{
    _hwndTarget = hwnd;
    _chainMode = SwapChainMode::ForHwnd;
    return S_OK;
}",1,<empty>,,961,27,CPPASTProblemDeclaration,,<empty>
522836,UNKNOWN,28,,"[[nodiscard]] HRESULT DxEngine::SetWindowSize(const til::size Pixels) noexcept
try
{
    _sizeTarget = Pixels;
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,977,28,CPPASTProblemDeclaration,,<empty>
522867,UNKNOWN,32,,"void DxEngine::SetRetroTerminalEffect(bool enable) noexcept
try
{
    if (_retroTerminalEffect != enable)
    {
        // Enable shader effects if the path isn't empty. Otherwise leave it untouched.
        _terminalEffectsEnabled = enable ? true : _terminalEffectsEnabled;
        _retroTerminalEffect = enable;
        _recreateDeviceRequested = true;
        LOG_IF_FAILED(InvalidateAll());
    }
}
CATCH_LOG()

std::wstring_view DxEngine::GetPixelShaderPath() noexcept
{
    return _pixelShaderPath;
}",1,<empty>,,1000,32,CPPASTProblemDeclaration,,<empty>
522868,UNKNOWN,33,,"void DxEngine::SetPixelShaderPath(std::wstring_view value) noexcept
try
{
    if (_pixelShaderPath != value)
    {
        // Enable shader effects if the path isn't empty. Otherwise leave it untouched.
        _terminalEffectsEnabled = value.empty() ? _terminalEffectsEnabled : true;
        _pixelShaderPath = std::wstring{ value };
        _recreateDeviceRequested = true;
        LOG_IF_FAILED(InvalidateAll());
    }
}
CATCH_LOG()

void DxEngine::SetForceFullRepaintRendering(bool enable) noexcept
try
{
    if (_forceFullRepaintRendering != enable)
    {
        _forceFullRepaintRendering = enable;
        LOG_IF_FAILED(InvalidateAll());
    }
}",1,<empty>,,1019,33,CPPASTProblemDeclaration,,<empty>
522869,UNKNOWN,34,,"CATCH_LOG()

void DxEngine::SetSoftwareRendering(bool enable) noexcept
try
{
    if (_softwareRendering != enable)
    {
        _softwareRendering = enable;
        _recreateDeviceRequested = true;
        LOG_IF_FAILED(InvalidateAll());
    }
}",1,<empty>,,1042,34,CPPASTProblemDeclaration,,<empty>
522870,UNKNOWN,35,,"CATCH_LOG()

void DxEngine::_InvalidateRectangle(const til::rect& rc)
{
    const auto size = _invalidMap.size();
    const auto topLeft = til::point{ 0, std::clamp(rc.top, 0, size.height) };
    const auto bottomRight = til::point{ size.width, std::clamp(rc.bottom, 0, size.height) };
    _invalidMap.set({ topLeft, bottomRight });
}",1,<empty>,,1054,35,CPPASTProblemDeclaration,,<empty>
522890,UNKNOWN,37,,"[[nodiscard]] HRESULT DxEngine::Invalidate(const til::rect* const psrRegion) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, psrRegion);

    if (!_allInvalid)
    {
        _InvalidateRectangle(*psrRegion);
    }

    return S_OK;
}
CATCH_RETURN()

// Routine Description:
// - Invalidates the cells of the cursor
// Arguments:
// - psrRegion - the region covered by the cursor
// Return Value:
// - S_OK
[[nodiscard]] HRESULT DxEngine::InvalidateCursor(const til::rect* const psrRegion) noexcept
{
    return Invalidate(psrRegion);
}",1,<empty>,,1075,37,CPPASTProblemDeclaration,,<empty>
522891,UNKNOWN,38,,"[[nodiscard]] HRESULT DxEngine::InvalidateSystem(const til::rect* const prcDirtyClient) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, prcDirtyClient);

    if (!_allInvalid)
    {
        // Dirty client is in pixels. Use divide specialization against glyph factor to make conversion
        // to cells.
        _InvalidateRectangle(prcDirtyClient->scale_down(_fontRenderData->GlyphCell()));
    }

    return S_OK;
}
CATCH_RETURN();",1,<empty>,,1106,38,CPPASTProblemDeclaration,,<empty>
522911,UNKNOWN,40,,"[[nodiscard]] HRESULT DxEngine::InvalidateScroll(const til::point* const pcoordDelta) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, !pcoordDelta);

    const auto deltaCells{ *pcoordDelta };

    if (!_allInvalid)
    {
        if (deltaCells != til::point{})
        {
            // Shift the contents of the map and fill in revealed area.
            _invalidMap.translate(deltaCells, true);
            _invalidScroll += deltaCells;
            _allInvalid = _IsAllInvalid();
        }
    }

    return S_OK;
}
CATCH_RETURN();",1,<empty>,,1148,40,CPPASTProblemDeclaration,,<empty>
522912,UNKNOWN,41,,"[[nodiscard]] HRESULT DxEngine::InvalidateAll() noexcept
try
{
    _invalidMap.set_all();
    _allInvalid = true;

    // Since everything is invalidated here, mark this as a ""first frame"", so
    // that we won't use incremental drawing on it. The caller of this intended
    // for _everything_ to get redrawn, so setting _firstFrame will force us to
    // redraw the entire frame. This will make sure that things like the gutters
    // get cleared correctly.
    //
    // Invalidating everything is supposed to happen with resizes of the
    // entire canvas, changes of the font, and other such adjustments.
    _firstFrame = true;
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,1176,41,CPPASTProblemDeclaration,,<empty>
522984,UNKNOWN,44,,"[[nodiscard]] HRESULT DxEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pForcePaint);

    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,1243,44,CPPASTProblemDeclaration,,<empty>
522985,UNKNOWN,45,,"[[nodiscard]] HRESULT DxEngine::StartPaint() noexcept
try
{
    RETURN_HR_IF(E_NOT_VALID_STATE, _isPainting); // invalid to start a paint while painting.

    // If full repaints are needed then we need to invalidate everything
    // so the entire frame is repainted.
    if (_FullRepaintNeeded())
    {
        RETURN_IF_FAILED(InvalidateAll());
    }

    if (TraceLoggingProviderEnabled(g_hDxRenderProvider, WINEVENT_LEVEL_VERBOSE, TIL_KEYWORD_TRACE))
    {
        const auto invalidatedStr = _invalidMap.to_string();
        const auto invalidated = invalidatedStr.c_str();

#pragma warning(suppress : 26477 26485 26494 26482 26446 26447) // We don't control TraceLoggingWrite
        TraceLoggingWrite(g_hDxRenderProvider,
                          ""Invalid"",
                          TraceLoggingWideString(invalidated),
                          TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                          TraceLoggingKeyword(TIL_KEYWORD_TRACE));
    }

    if (_isEnabled)
    ...",1,<empty>,,1257,45,CPPASTProblemDeclaration,,<empty>
522986,UNKNOWN,46,,"CATCH_RETURN()

// Routine Description:
// - Copies the front surface of the swap chain (the one being displayed)
//   to the back surface of the swap chain (the one we draw on next)
//   so we can draw on top of what's already there.
// Arguments:
// - <none>
// Return Value:
// - Any DirectX error, a memory error, etc.
[[nodiscard]] HRESULT DxEngine::_CopyFrontToBack() noexcept
{
    try
    {
        Microsoft::WRL::ComPtr<ID3D11Resource> backBuffer;
        Microsoft::WRL::ComPtr<ID3D11Resource> frontBuffer;

        RETURN_IF_FAILED(_dxgiSwapChain->GetBuffer(0, IID_PPV_ARGS(&backBuffer)));
        RETURN_IF_FAILED(_dxgiSwapChain->GetBuffer(1, IID_PPV_ARGS(&frontBuffer)));

        _d3dDeviceContext->CopyResource(backBuffer.Get(), frontBuffer.Get());
    }
    CATCH_RETURN();

    return S_OK;
}",1,<empty>,,1438,46,CPPASTProblemDeclaration,,<empty>
523039,UNKNOWN,-1,,"try
        {
            auto hr = S_OK;

            auto recreate = false;

            // On anything but the first frame, try partial presentation.
            // We'll do it first because if it fails, we'll try again with full presentation.
            if (!_firstFrame)
            {
                hr = _dxgiSwapChain->Present1(1, 0, &_presentParams);

                // These two error codes are indicated for destroy-and-recreate
                // If we were told to destroy-and-recreate, we're going to skip straight into doing that
                // and not try again with full presentation.
                recreate = hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET;

                // Log this as we actually don't expect it to happen, we just will try again
                // below for robustness of our drawing.
                if (FAILED(hr) && !recreate)
                {
                    LOG_HR(hr);
                }
            }

            // If ...",9,<empty>,,1523,2,CPPASTProblemStatement,,<empty>
523050,UNKNOWN,51,,"[[nodiscard]] HRESULT DxEngine::PaintBackground() noexcept
try
{
    D2D1_COLOR_F nothing{ 0 };
    if (_chainMode == SwapChainMode::ForHwnd)
    {
        // When we're drawing over an HWND target, we need to fully paint the background color.
        nothing = _backgroundColor;
    }

    // If the entire thing is invalid, just use one big clear operation.
    if (_invalidMap.all())
    {
        _d2dDeviceContext->Clear(nothing);
    }
    else
    {
        // Runs are counts of cells.
        // Use a transform by the size of one cell to convert cells-to-pixels
        // as we clear.
        _d2dDeviceContext->SetTransform(D2D1::Matrix3x2F::Scale(_fontRenderData->GlyphCell().to_d2d_size()));
        for (const auto& rect : _invalidMap.runs())
        {
            // Use aliased.
            // For graphics reasons, it'll look better because it will ensure that
            // the edges are cut nice and sharp (not blended by anti-aliasing).
            // For performance reasons...",1,<empty>,,1618,51,CPPASTProblemDeclaration,,<empty>
523051,UNKNOWN,52,,"CATCH_RETURN()

// Routine Description:
// - Paints lines around cells (draws in pieces of the grid)
// Arguments:
// - lines - Which grid lines (top, left, bottom, right) to draw
// - gridlineColor - The color to use for drawing the gridlines
// - underlineColor - The color to use for drawing the underlines
// - cchLine - Length of the line to draw in character cells
// - coordTarget - The X,Y character position in the grid where we should start drawing
//               - We will draw rightward (+X) from here
// Return Value:
// - S_OK or relevant DirectX error
[[nodiscard]] HRESULT DxEngine::PaintBufferGridLines(const GridLineSet lines,
                                                     const COLORREF gridlineColor,
                                                     const COLORREF underlineColor,
                                                     const size_t cchLine,
                                                     const til::point coordTarget) noexcept
try
{
    const ...",1,<empty>,,1693,52,CPPASTProblemDeclaration,,<empty>
523052,UNKNOWN,53,,"CATCH_RETURN()

// Routine Description:
// - Paints an overlay highlight on a portion of the frame to represent selected text
// Arguments:
//  - rect - Rectangle to invert or highlight to make the selection area
// Return Value:
// - S_OK or relevant DirectX error.
[[nodiscard]] HRESULT DxEngine::PaintSelection(const til::rect& rect) noexcept
try
{
    // If a clip rectangle is in place from drawing the text layer, remove it here.
    LOG_IF_FAILED(_customRenderer->EndClip(_drawingContext.get()));

    const auto existingColor = _d2dBrushForeground->GetColor();

    _d2dBrushForeground->SetColor(_selectionBackground);
    const auto resetColorOnExit = wil::scope_exit([&]() noexcept { _d2dBrushForeground->SetColor(existingColor); });

    const D2D1_RECT_F draw = rect.scale_up(_fontRenderData->GlyphCell()).to_d2d_rect();

    _d2dDeviceContext->FillRectangle(draw, _d2dBrushForeground.Get());

    return S_OK;
}",1,<empty>,,1820,53,CPPASTProblemDeclaration,,<empty>
523053,UNKNOWN,54,,"CATCH_RETURN()

// Routine Description:
// - Does nothing. Our cursor is drawn in CustomTextRenderer::DrawGlyphRun,
//   either above or below the text.
// Arguments:
// - options - unused
// Return Value:
// - S_OK
[[nodiscard]] HRESULT DxEngine::PaintCursor(const CursorOptions& /*options*/) noexcept
{
    return S_OK;
}",1,<empty>,,1845,54,CPPASTProblemDeclaration,,<empty>
523054,UNKNOWN,55,,"[[nodiscard]] HRESULT DxEngine::_PaintTerminalEffects() noexcept
try
{
    // Should have been initialized.
    RETURN_HR_IF(E_NOT_VALID_STATE, !_framebufferCapture);

    // Capture current frame in swap chain to a texture.
    ::Microsoft::WRL::ComPtr<ID3D11Texture2D> swapBuffer;
    RETURN_IF_FAILED(_dxgiSwapChain->GetBuffer(0, IID_PPV_ARGS(&swapBuffer)));
    _d3dDeviceContext->CopyResource(_framebufferCapture.Get(), swapBuffer.Get());

    // Prepare captured texture as input resource to shader program.
    D3D11_TEXTURE2D_DESC desc;
    _framebufferCapture->GetDesc(&desc);

    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
    srvDesc.Texture2D.MostDetailedMip = 0;
    srvDesc.Texture2D.MipLevels = desc.MipLevels;
    srvDesc.Format = desc.Format;

    ::Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> shaderResource;
    RETURN_IF_FAILED(_d3dDevice->CreateShaderResourceView(_framebufferCapture.Get(), &srvDesc, &shaderResou...",1,<empty>,,1864,55,CPPASTProblemDeclaration,,<empty>
523055,UNKNOWN,56,,"[[nodiscard]] HRESULT DxEngine::UpdateDrawingBrushes(const TextAttribute& textAttributes,
                                                     const RenderSettings& renderSettings,
                                                     const gsl::not_null<IRenderData*> /*pData*/,
                                                     const bool usingSoftFont,
                                                     const bool isSettingDefaultBrushes) noexcept
try
{
    const auto [colorForeground, colorBackground] = renderSettings.GetAttributeColorsWithAlpha(textAttributes);

    const auto usingCleartype = _antialiasingMode == D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
    const auto usingTransparency = _defaultBackgroundIsTransparent;
    const auto forceOpaqueBG = usingCleartype && !usingTransparency;

    _foregroundColor = _ColorFFromColorRef(OPACITY_OPAQUE | colorForeground);
    // October 2021: small changes were made to the way BG color interacts with
    // grayscale AA, esp. with regard...",1,<empty>,,1929,56,CPPASTProblemDeclaration,,<empty>
523068,UNKNOWN,58,,"[[nodiscard]] HRESULT DxEngine::UpdateFont(const FontInfoDesired& pfiFontInfoDesired, FontInfo& fiFontInfo, const std::unordered_map<std::wstring_view, uint32_t>& features, const std::unordered_map<std::wstring_view, float>& axes) noexcept
try
{
    RETURN_IF_FAILED(_fontRenderData->UpdateFont(pfiFontInfoDesired, fiFontInfo, _dpi, features, axes));

    // Prepare the text layout.
    _customLayout = WRL::Make<CustomTextLayout>(_fontRenderData.get());

    // Inform the soft font of the new cell size so it can scale appropriately.
    return _softFont.SetTargetSize(_fontRenderData->GlyphCell());
}
CATCH_RETURN();",1,<empty>,,2015,58,CPPASTProblemDeclaration,,<empty>
523170,UNKNOWN,1,,float,33,<empty>,,2055,1,CPPASTTypeId,,<empty>
523192,UNKNOWN,64,,"[[nodiscard]] HRESULT DxEngine::GetProposedFont(const FontInfoDesired& pfiFontInfoDesired,
                                                FontInfo& pfiFontInfo,
                                                const int iDpi) noexcept
try
{
    DxFontRenderData fontRenderData(_dwriteFactory);
    return fontRenderData.UpdateFont(pfiFontInfoDesired, pfiFontInfo, iDpi);
}
CATCH_RETURN();",1,<empty>,,2097,64,CPPASTProblemDeclaration,,<empty>
523193,UNKNOWN,65,,"[[nodiscard]] HRESULT DxEngine::GetDirtyArea(std::span<const til::rect>& area) noexcept
try
{
    area = _invalidMap.runs();
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,2113,65,CPPASTProblemDeclaration,,<empty>
523194,UNKNOWN,66,,"[[nodiscard]] HRESULT DxEngine::GetFontSize(_Out_ til::size* const pFontSize) noexcept
try
{
    *pFontSize = _fontRenderData->GlyphCell();
    return S_OK;
}",1,<empty>,,2127,66,CPPASTProblemDeclaration,,<empty>
523195,UNKNOWN,67,,CATCH_RETURN();,1,<empty>,,2133,67,CPPASTProblemDeclaration,,<empty>
523196,UNKNOWN,68,,"[[nodiscard]] HRESULT DxEngine::IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pResult);

    const Cluster cluster(glyph, 0); // columns don't matter, we're doing analysis not layout.

    RETURN_IF_FAILED(_customLayout->Reset());
    RETURN_IF_FAILED(_customLayout->AppendClusters({ &cluster, 1 }));

    UINT32 columns = 0;
    RETURN_IF_FAILED(_customLayout->GetColumns(&columns));

    *pResult = columns != 1;

    return S_OK;
}",1,<empty>,,2142,68,CPPASTProblemDeclaration,,<empty>
523197,UNKNOWN,69,,CATCH_RETURN();,1,<empty>,,2159,69,CPPASTProblemDeclaration,,<empty>
523198,UNKNOWN,70,,"[[nodiscard]] HRESULT DxEngine::_DoUpdateTitle(_In_ const std::wstring_view /*newTitle*/) noexcept
{
    if (_hwndTarget != INVALID_HANDLE_VALUE)
    {
        return PostMessageW(_hwndTarget, CM_UPDATE_TITLE, 0, 0) ? S_OK : E_FAIL;
    }
    return S_FALSE;
}",1,<empty>,,2167,70,CPPASTProblemDeclaration,,<empty>
523289,UNKNOWN,73,,"void DxEngine::SetAntialiasingMode(const D2D1_TEXT_ANTIALIAS_MODE antialiasingMode) noexcept
try
{
    if (_antialiasingMode != antialiasingMode)
    {
        _antialiasingMode = antialiasingMode;
        _recreateDeviceRequested = true;
        LOG_IF_FAILED(_softFont.SetAntialiasing(antialiasingMode != D2D1_TEXT_ANTIALIAS_MODE_ALIASED));
        LOG_IF_FAILED(InvalidateAll());
    }
}
CATCH_LOG()

// Method Description:
// - Update our tracker of the opacity of our background. We can only
//   effectively render cleartype text onto fully-opaque backgrounds. If we're
//   rendering onto a transparent surface (like acrylic), then cleartype won't
//   work correctly, and will actually just additively blend with the
//   background. This is here to support GH#5098.
// - We'll use this, along with whether cleartype was requested, to manually set
//   the alpha channel of the background brush to 1.0. We need to do that to
//   make cleartype work without blending. However, we don't wan...",1,<empty>,,2229,73,CPPASTProblemDeclaration,,<empty>
523290,UNKNOWN,74,,"CATCH_LOG()

// Method Description:
// - Updates our internal tracker for which hyperlink ID we are hovering over
//   This is needed for UpdateDrawingBrushes to know where we need to set a different style
// Arguments:
// - The new link ID we are hovering over
void DxEngine::UpdateHyperlinkHoveredId(const uint16_t hoveredId) noexcept
{
    _hyperlinkHoveredId = hoveredId;
}",1,<empty>,,2267,74,CPPASTProblemDeclaration,,<empty>
523291,UNKNOWN,75,,"HRESULT DxEngine::UpdateSoftFont(const std::span<const uint16_t> bitPattern,
                                 const til::size cellSize,
                                 const size_t centeringHint) noexcept
try
{
    _softFont.SetFont(bitPattern, cellSize, _fontRenderData->GlyphCell(), centeringHint);
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,2287,75,CPPASTProblemDeclaration,,<empty>
523707,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;,9,<empty>,,80,25,CPPASTProblemDeclaration,,<empty>
523831,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* pFontSize) noexcept override;,9,<empty>,,128,48,CPPASTProblemDeclaration,,<empty>
523832,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept override;",9,<empty>,,129,49,CPPASTProblemDeclaration,,<empty>
523868,UNKNOWN,-1,,[[nodiscard]] HRESULT _DoUpdateTitle(_In_ const std::wstring_view newTitle) noexcept override;,9,<empty>,,143,57,CPPASTProblemDeclaration,,<empty>
523999,UNKNOWN,-1,,"[[nodiscard]] HRESULT _CreateTextLayout(
            _In_reads_(StringLength) PCWCHAR String,
            _In_ size_t StringLength,
            _Out_ IDWriteTextLayout** ppTextLayout) noexcept;",9,<empty>,,299,148,CPPASTProblemDeclaration,,<empty>
524823,UNKNOWN,1,,float,51,<empty>,,225,1,CPPASTTypeId,,<empty>
525019,UNKNOWN,-1,,D2D1_MATRIX_5X4_F _colorMatrix{ ._14 = 1 };,9,<empty>,,49,18,CPPASTProblemDeclaration,,<empty>
525330,UNKNOWN,2,,};,1,<empty>,,100,2,CPPASTProblemDeclaration,,<empty>
525386,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;,9,<empty>,,36,10,CPPASTProblemDeclaration,,<empty>
525454,UNKNOWN,-1,,"[[nodiscard]] HRESULT UpdateFont(const FontInfoDesired& FontInfoDesired,
                                         _Out_ FontInfo& FontInfo) noexcept override;",9,<empty>,,68,23,CPPASTProblemDeclaration,,<empty>
525472,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProposedFont(const FontInfoDesired& FontDesired,
                                              _Out_ FontInfo& Font,
                                              const int iDpi) noexcept override;",9,<empty>,,76,27,CPPASTProblemDeclaration,,<empty>
525478,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* const pFontSize) noexcept override;,9,<empty>,,81,29,CPPASTProblemDeclaration,,<empty>
525479,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept override;",9,<empty>,,82,30,CPPASTProblemDeclaration,,<empty>
525480,UNKNOWN,-1,,[[nodiscard]] HRESULT _DoUpdateTitle(_In_ const std::wstring_view newTitle) noexcept override;,9,<empty>,,85,31,CPPASTProblemDeclaration,,<empty>
525604,UNKNOWN,-1,,"void _OrRect(_In_ til::rect* const pRectExisting, const til::rect* const pRectToOr) const;",9,<empty>,,186,84,CPPASTProblemDeclaration,,<empty>
525609,UNKNOWN,-1,,"[[nodiscard]] HRESULT _GetProposedFont(const FontInfoDesired& FontDesired,
                                               _Out_ FontInfo& Font,
                                               const int iDpi,
                                               _Inout_ wil::unique_hfont& hFont,
                                               _Inout_ wil::unique_hfont& hFontItalic) noexcept;",9,<empty>,,190,86,CPPASTProblemDeclaration,,<empty>
525816,UNKNOWN,7,,"HRESULT GdiEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,112,7,CPPASTProblemDeclaration,,<empty>
526004,UNKNOWN,2,,"[[nodiscard]] HRESULT GdiEngine::IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept
{
    auto isFullWidth = false;

    if (glyph.size() == 1)
    {
        const auto wch = glyph.front();
        if (_IsFontTrueType())
        {
            ABC abc;
            if (GetCharABCWidthsW(_hdcMemoryContext, wch, wch, &abc))
            {
                const int totalWidth = abc.abcA + abc.abcB + abc.abcC;

                isFullWidth = totalWidth > _GetFontSize().width;
            }
        }
        else
        {
            auto cpxWidth = 0;
            if (GetCharWidth32W(_hdcMemoryContext, wch, wch, &cpxWidth))
            {
                isFullWidth = cpxWidth > _GetFontSize().width;
            }
        }
    }
    else
    {
        // can't find a way to make gdi measure the width of utf16 surrogate pairs.
        // in the meantime, better to be too wide than too narrow.
        isFullWidth = true;
    }

    *pResult = isFullWidth;
   ...",1,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
526092,UNKNOWN,8,,"void GdiEngine::_OrRect(_In_ til::rect* pRectExisting, const til::rect* pRectToOr) const
{
    pRectExisting->left = std::min(pRectExisting->left, pRectToOr->left);
    pRectExisting->top = std::min(pRectExisting->top, pRectToOr->top);
    pRectExisting->right = std::max(pRectExisting->right, pRectToOr->right);
    pRectExisting->bottom = std::max(pRectExisting->bottom, pRectToOr->bottom);
}",1,<empty>,,146,8,CPPASTProblemDeclaration,,<empty>
526769,UNKNOWN,-1,,"try
    {
        const auto cchLine = clusters.size();

        // Exit early if there are no lines to draw.
        RETURN_HR_IF(S_OK, 0 == cchLine);

        const auto ptDraw = coord * _GetFontSize();

        const auto pPolyTextLine = &_pPolyText[_cPolyText];

        auto& polyString = _polyStrings.emplace_back();
        polyString.reserve(cchLine);

        const auto coordFontSize = _GetFontSize();

        auto& polyWidth = _polyWidths.emplace_back();
        polyWidth.reserve(cchLine);

        // If we have a soft font, we only use the character's lower 7 bits.
        const auto softFontCharMask = _lastFontType == FontType::Soft ? L'\x7F' : ~0;

        // Sum up the total widths the entire line/run is expected to take while
        // copying the pixel widths into a structure to direct GDI how many pixels to use per character.
        size_t cchCharWidths = 0;

        // Convert data from clusters into the text array and the widths array.
        for (size_t i = 0; i...",5,<empty>,,331,1,CPPASTProblemStatement,,<empty>
526943,UNKNOWN,11,,"[[nodiscard]] HRESULT GdiEngine::PaintBufferGridLines(const GridLineSet lines, const COLORREF gridlineColor, const COLORREF underlineColor, const size_t cchLine, const til::point coordTarget) noexcept
try
{
    LOG_IF_FAILED(_FlushBufferLines());

    // Convert the target from characters to pixels.
    const auto ptTarget = coordTarget * _GetFontSize();

    // Create a brush with the gridline color, and apply it.
    wil::unique_hbrush hbr(CreateSolidBrush(gridlineColor));
    RETURN_HR_IF_NULL(E_FAIL, hbr.get());
    const auto prevBrush = wil::SelectObject(_hdcMemoryContext, hbr.get());
    RETURN_HR_IF_NULL(E_FAIL, prevBrush.get());

    // Get the font size so we know the size of the rectangle lines we'll be inscribing.
    const auto fontWidth = _GetFontSize().width;
    const auto fontHeight = _GetFontSize().height;
    const auto widthOfAllCells = fontWidth * gsl::narrow_cast<til::CoordType>(cchLine);

    const auto DrawLine = [=](const til::CoordType x, const til::CoordTy...",1,<empty>,,519,11,CPPASTProblemDeclaration,,<empty>
526969,UNKNOWN,16,,"RETURN_HR_IF_NULL(E_FAIL, prevPen.get());",5,<empty>,,643,16,CPPASTProblemDeclaration,,<empty>
526970,UNKNOWN,17,,"if (lines.test(GridLines::Underline))
    {
        return DrawStrokedLine(ptTarget.x, ptTarget.y + _lineMetrics.underlineCenter, widthOfAllCells);
    }",5,<empty>,,645,17,CPPASTProblemDeclaration,,<empty>
526971,UNKNOWN,18,,"else if (lines.test(GridLines::DoubleUnderline))
    {
        RETURN_IF_FAILED(DrawStrokedLine(ptTarget.x, ptTarget.y + _lineMetrics.doubleUnderlinePosTop, widthOfAllCells));
        return DrawStrokedLine(ptTarget.x, ptTarget.y + _lineMetrics.doubleUnderlinePosBottom, widthOfAllCells);
    }",5,<empty>,,649,18,CPPASTProblemDeclaration,,<empty>
526972,UNKNOWN,19,,"else if (lines.test(GridLines::CurlyUnderline))
    {
        return DrawCurlyLine(ptTarget.x, ptTarget.y + _lineMetrics.curlyLineCenter, widthOfAllCells);
    }",5,<empty>,,654,19,CPPASTProblemDeclaration,,<empty>
526973,UNKNOWN,20,,"else if (lines.test(GridLines::DottedUnderline))
    {
        return DrawStrokedLine(ptTarget.x, ptTarget.y + _lineMetrics.underlineCenter, widthOfAllCells);
    }",5,<empty>,,658,20,CPPASTProblemDeclaration,,<empty>
526974,UNKNOWN,21,,"else if (lines.test(GridLines::DashedUnderline))
    {
        return DrawStrokedLine(ptTarget.x, ptTarget.y + _lineMetrics.underlineCenter, widthOfAllCells);
    }",5,<empty>,,662,21,CPPASTProblemDeclaration,,<empty>
526975,UNKNOWN,22,,return S_OK;,5,<empty>,,667,22,CPPASTProblemDeclaration,,<empty>
526976,UNKNOWN,23,,},1,<empty>,,668,23,CPPASTProblemDeclaration,,<empty>
526977,UNKNOWN,24,,CATCH_RETURN();,1,<empty>,,669,24,CPPASTProblemDeclaration,,<empty>
528021,UNKNOWN,8,,"[[nodiscard]] HRESULT GdiEngine::UpdateFont(const FontInfoDesired& FontDesired, _Out_ FontInfo& Font) noexcept
{
    wil::unique_hfont hFont, hFontItalic;
    RETURN_IF_FAILED(_GetProposedFont(FontDesired, Font, _iCurrentDpi, hFont, hFontItalic));

    // Select into DC
    RETURN_HR_IF_NULL(E_FAIL, SelectFont(_hdcMemoryContext, hFont.get()));

    // Save off the font metrics for various other calculations
    RETURN_HR_IF(E_FAIL, !(GetTextMetricsW(_hdcMemoryContext, &_tmFontMetrics)));

    // There is no font metric for the grid line width, so we use a small
    // multiple of the font size, which typically rounds to a pixel.
    const auto cellHeight = static_cast<float>(Font.GetSize().height);
    const auto fontSize = static_cast<float>(_tmFontMetrics.tmHeight - _tmFontMetrics.tmInternalLeading);
    const auto baseline = static_cast<float>(_tmFontMetrics.tmAscent);
    float idealGridlineWidth = std::max(1.0f, fontSize * 0.025f);
    float idealUnderlineTop = 0;
    float ide...",1,<empty>,,334,8,CPPASTProblemDeclaration,,<empty>
528073,UNKNOWN,12,,"[[nodiscard]] HRESULT GdiEngine::GetProposedFont(const FontInfoDesired& FontDesired, _Out_ FontInfo& Font, const int iDpi) noexcept
{
    wil::unique_hfont hFont, hFontItalic;
    return _GetProposedFont(FontDesired, Font, iDpi, hFont, hFontItalic);
}",1,<empty>,,548,12,CPPASTProblemDeclaration,,<empty>
528074,UNKNOWN,13,,"[[nodiscard]] HRESULT GdiEngine::_DoUpdateTitle(_In_ const std::wstring_view /*newTitle*/) noexcept
{
    // the CM_UPDATE_TITLE handler in windowproc will query the updated title.
    return PostMessageW(_hwndTargetWindow, CM_UPDATE_TITLE, 0, (LPARAM) nullptr) ? S_OK : E_FAIL;
}",1,<empty>,,561,13,CPPASTProblemDeclaration,,<empty>
528075,UNKNOWN,14,,"[[nodiscard]] HRESULT GdiEngine::_GetProposedFont(const FontInfoDesired& FontDesired,
                                                  _Out_ FontInfo& Font,
                                                  const int iDpi,
                                                  _Inout_ wil::unique_hfont& hFont,
                                                  _Inout_ wil::unique_hfont& hFontItalic) noexcept
{
    wil::unique_hdc hdcTemp(CreateCompatibleDC(_hdcMemoryContext));
    RETURN_HR_IF_NULL(E_FAIL, hdcTemp.get());

    // Get a special engine size because TT fonts can't specify X or we'll get weird scaling under some circumstances.
    auto coordFontRequested = FontDesired.GetEngineSize();

    // First, check to see if we're asking for the default raster font.
    if (FontDesired.IsDefaultRasterFont())
    {
        // We're being asked for the default raster font, which gets special handling. In particular, it's the font
        // returned by GetStockObject(OEM_FIXED_FONT).
  ...",1,<empty>,,580,14,CPPASTProblemDeclaration,,<empty>
528076,UNKNOWN,15,,"[[nodiscard]] HRESULT GdiEngine::GetFontSize(_Out_ til::size* pFontSize) noexcept
{
    *pFontSize = _GetFontSize();
    return S_OK;
}",1,<empty>,,738,15,CPPASTProblemDeclaration,,<empty>
528129,UNKNOWN,1,,"int CALLBACK EnumFontFamiliesExProc(ENUMLOGFONTEX* lpelfe, NEWTEXTMETRICEX* lpntme, int FontType, LPARAM lParam)
{
    lParam;
    FontType;
    lpntme;

    if (lpntme->ntmTm.tmPitchAndFamily & TMPF_FIXED_PITCH)
    {
        // skip non-monospace fonts
        // NOTE: this is weird/backwards and the presence of this flag means non-monospace and the absence means monospace.
        return 1;
    }

    if (lpelfe->elfFullName[0] == L'@')
    {
        return 1; // skip vertical fonts
    }

    if (FontType & DEVICE_FONTTYPE)
    {
        return 1; // skip device type fonts. we're only going to do raster and truetype.
    }

    if (FontType & RASTER_FONTTYPE)
    {
        if (wcscmp(lpelfe->elfFullName, L""Terminal"") != 0)
        {
            return 1; // skip non-""Terminal"" raster fonts.
        }
    }

    wprintf(L""Charset: %d "", lpntme->ntmTm.tmCharSet);

    wprintf(L""W: %d H: %d"", lpntme->ntmTm.tmMaxCharWidth, lpntme->ntmTm.tmHeight);

    wprintf(L""%s, %s, %s\n"", lpelf...",1,<empty>,,6,1,CPPASTProblemDeclaration,,<empty>
528168,UNKNOWN,1,,FONTENUMPROC,36,<empty>,,60,1,CPPASTTypeId,,<empty>
528454,UNKNOWN,-1,,static void s_SetFontDefaultList(_In_ Microsoft::Console::Render::IFontDefaultList* const pFontDefaultList) noexcept;,5,<empty>,,51,13,CPPASTProblemDeclaration,,<empty>
528807,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept = 0;,9,<empty>,,63,7,CPPASTProblemDeclaration,,<empty>
528841,UNKNOWN,-1,,"[[nodiscard]] virtual HRESULT InvalidateFlush(_In_ const bool circled, _Out_ bool* const pForcePaint) noexcept = 0;",9,<empty>,,71,15,CPPASTProblemDeclaration,,<empty>
528908,UNKNOWN,-1,,"[[nodiscard]] virtual HRESULT UpdateFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo) noexcept = 0;",9,<empty>,,83,27,CPPASTProblemDeclaration,,<empty>
528926,UNKNOWN,-1,,"[[nodiscard]] virtual HRESULT GetProposedFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo, int iDpi) noexcept = 0;",9,<empty>,,87,31,CPPASTProblemDeclaration,,<empty>
528932,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT GetFontSize(_Out_ til::size* pFontSize) noexcept = 0;,9,<empty>,,89,33,CPPASTProblemDeclaration,,<empty>
528933,UNKNOWN,-1,,"[[nodiscard]] virtual HRESULT IsGlyphWideByFont(std::wstring_view glyph, _Out_ bool* pResult) noexcept = 0;",9,<empty>,,90,34,CPPASTProblemDeclaration,,<empty>
529114,UNKNOWN,-1,,"[[nodiscard]] HRESULT InvalidateFlush(_In_ const bool circled, _Out_ bool* const pForcePaint) noexcept override;",9,<empty>,,46,9,CPPASTProblemDeclaration,,<empty>
529302,UNKNOWN,5,,"[[nodiscard]] HRESULT UiaEngine::InvalidateCursor(const til::rect* const psrRegion) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, psrRegion);

    // check if cursor moved
    if (*psrRegion != _prevCursorRegion)
    {
        _prevCursorRegion = *psrRegion;
        _cursorChanged = true;
    }
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,79,5,CPPASTProblemDeclaration,,<empty>
529324,UNKNOWN,-1,,"try
        {
            _selectionChanged = true;
            _prevSelection = rectangles;
        }
        CATCH_LOG_RETURN_HR(E_FAIL);",9,<empty>,,118,1,CPPASTProblemStatement,,<empty>
529342,UNKNOWN,-1,,"try
        {
            const auto prevRect = _prevSelection.at(i);
            const auto newRect = rectangles.at(i);

            // if any value is different, selection has changed
            if (prevRect.top != newRect.top || prevRect.right != newRect.right || prevRect.left != newRect.left || prevRect.bottom != newRect.bottom)
            {
                _selectionChanged = true;
                _prevSelection = rectangles;
                return S_OK;
            }
        }
        CATCH_LOG_RETURN_HR(E_FAIL);",9,<empty>,,129,1,CPPASTProblemStatement,,<empty>
529366,UNKNOWN,10,,"[[nodiscard]] HRESULT UiaEngine::NotifyNewText(const std::wstring_view newText) noexcept
try
{
    // GH#16217 - don't even buffer this text if we're disabled. We may never
    // come around to write it out.
    RETURN_HR_IF(S_FALSE, !_isEnabled);

    if (!newText.empty())
    {
        _newOutput.append(newText);
        _newOutput.push_back(L'\n');
        _textBufferChanged = true;
    }
    return S_OK;
}
CATCH_LOG_RETURN_HR(E_FAIL);",1,<empty>,,177,10,CPPASTProblemDeclaration,,<empty>
529367,UNKNOWN,11,,"[[nodiscard]] HRESULT UiaEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pForcePaint);

    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,200,11,CPPASTProblemDeclaration,,<empty>
529436,UNKNOWN,-1,,"try
        {
            _dispatcher->SignalSelectionChanged();
        }
        CATCH_LOG();",9,<empty>,,270,1,CPPASTProblemStatement,,<empty>
529440,UNKNOWN,-1,,"try
        {
            _dispatcher->SignalTextChanged();
        }
        CATCH_LOG();",9,<empty>,,278,1,CPPASTProblemStatement,,<empty>
529444,UNKNOWN,-1,,"try
        {
            _dispatcher->SignalCursorChanged();
        }
        CATCH_LOG();",9,<empty>,,286,1,CPPASTProblemStatement,,<empty>
529445,UNKNOWN,-1,,"try
    {
        // The speech API is limited to 1000 characters at a time.
        // Break up the output into 1000 character chunks to ensure
        // the output isn't cut off.
        static constexpr size_t sapiLimit{ 1000 };
        const std::wstring_view output{ _queuedOutput };
        for (size_t offset = 0; offset < output.size(); offset += sapiLimit)
        {
            _dispatcher->NotifyNewOutput(output.substr(offset, sapiLimit));
        }
    }
    CATCH_LOG();",5,<empty>,,292,5,CPPASTProblemStatement,,<empty>
529565,UNKNOWN,28,,"[[nodiscard]] HRESULT UiaEngine::GetFontSize(_Out_ til::size* const /*pFontSize*/) noexcept
{
    return S_FALSE;
}",1,<empty>,,493,28,CPPASTProblemDeclaration,,<empty>
529566,UNKNOWN,29,,"[[nodiscard]] HRESULT UiaEngine::IsGlyphWideByFont(const std::wstring_view /*glyph*/, _Out_ bool* const /*pResult*/) noexcept
{
    return S_FALSE;
}",1,<empty>,,505,29,CPPASTProblemDeclaration,,<empty>
529567,UNKNOWN,30,,"[[nodiscard]] HRESULT UiaEngine::_DoUpdateTitle(_In_ const std::wstring_view /*newTitle*/) noexcept
{
    return S_FALSE;
}",1,<empty>,,517,30,CPPASTProblemDeclaration,,<empty>
529612,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;,9,<empty>,,41,8,CPPASTProblemDeclaration,,<empty>
529691,UNKNOWN,-1,,"[[nodiscard]] HRESULT UpdateFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo) noexcept override;",9,<empty>,,56,23,CPPASTProblemDeclaration,,<empty>
529702,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProposedFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo, const int iDpi) noexcept override;",9,<empty>,,59,26,CPPASTProblemDeclaration,,<empty>
529708,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* const pFontSize) noexcept override;,9,<empty>,,61,28,CPPASTProblemDeclaration,,<empty>
529709,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept override;",9,<empty>,,62,29,CPPASTProblemDeclaration,,<empty>
530077,UNKNOWN,25,,"[[nodiscard]] HRESULT VtEngine::_ChangeTitle(_In_ const std::string& title) noexcept
{
    return _WriteFormatted(FMT_COMPILE(""\x1b]0;{}\x7""), title);
}",1,<empty>,,347,25,CPPASTProblemDeclaration,,<empty>
530314,UNKNOWN,1,,"Xterm256Engine::Xterm256Engine(_In_ wil::unique_hfile hPipe,
                               const Viewport initialViewport) :
    XtermEngine(std::move(hPipe), initialViewport, false)
{
}",1,<empty>,,11,1,CPPASTProblemDeclaration,,<empty>
530722,UNKNOWN,-1,,"Xterm256Engine(_In_ wil::unique_hfile hPipe,
                       const Microsoft::Console::Types::Viewport initialViewport);",9,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
530765,UNKNOWN,1,,"XtermEngine::XtermEngine(_In_ wil::unique_hfile hPipe,
                         const Viewport initialViewport,
                         const bool fUseAsciiOnly) :
    VtEngine(std::move(hPipe), initialViewport),
    _fUseAsciiOnly(fUseAsciiOnly),
    _needToDisableCursor(false),
    // GH#12401: Ensure a DECTCEM cursor show/hide sequence
    // is emitted on the first frame no matter what.
    _lastCursorIsVisible(Tribool::Invalid),
    _nextCursorIsVisible(true)
{
    // Set out initial cursor position to -1, -1. This will force our initial
    //      paint to manually move the cursor to 0, 0, not just ignore it.
    _lastText = VtEngine::INVALID_COORDS;
}",1,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
530899,UNKNOWN,1,,Tribool,45,<empty>,,122,1,CPPASTTypeId,,<empty>
530910,UNKNOWN,1,,Tribool,44,<empty>,,125,1,CPPASTTypeId,,<empty>
531334,UNKNOWN,7,,"[[nodiscard]] HRESULT XtermEngine::ScrollFrame() noexcept
try
{
    _trace.TraceScrollFrame(_scrollDelta);

    if (_scrollDelta.x != 0)
    {
        // No easy way to shift left-right. Everything needs repainting.
        return InvalidateAll();
    }
    if (_scrollDelta.y == 0)
    {
        // There's nothing to do here. Do nothing.
        return S_OK;
    }

    const auto dy = _scrollDelta.y;
    const auto absDy = abs(dy);

    // Save the old wrap state here. We're going to clear it so that
    // _MoveCursor will definitely move us to the right position. We'll
    // restore the state afterwards.
    const auto oldWrappedRow = _wrappedRow;
    const auto oldDelayedEolWrap = _delayedEolWrap;
    _delayedEolWrap = false;
    _wrappedRow = std::nullopt;

    if (dy < 0)
    {
        // TODO GH#5228 - We could optimize this by only doing this newline work
        // when there's more invalid than just the bottom line. If only the
        // bottom line is invalid, then the n...",1,<empty>,,349,7,CPPASTProblemDeclaration,,<empty>
531335,UNKNOWN,8,,"[[nodiscard]] HRESULT XtermEngine::InvalidateScroll(const til::point* const pcoordDelta) noexcept
try
{
    const auto delta{ *pcoordDelta };

    if (delta != til::point{ 0, 0 })
    {
        _trace.TraceInvalidateScroll(delta);

        // Scroll the current offset and invalidate the revealed area
        _invalidMap.translate(delta, true);

        _scrollDelta += delta;
    }

    return S_OK;
}
CATCH_RETURN();",1,<empty>,,473,8,CPPASTProblemDeclaration,,<empty>
531407,UNKNOWN,-1,,"try
    {
        const auto converted = ConvertToA(CP_UTF8, newTitle);
        return VtEngine::_ChangeTitle(converted);
    }
    CATCH_RETURN();",5,<empty>,,577,2,CPPASTProblemStatement,,<empty>
531421,UNKNOWN,-1,,"XtermEngine(_In_ wil::unique_hfile hPipe,
                    const Microsoft::Console::Types::Viewport initialViewport,
                    const bool fUseAsciiOnly);",9,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
531525,UNKNOWN,3,,"[[nodiscard]] HRESULT VtEngine::Invalidate(const til::rect* const psrRegion) noexcept
try
{
    _trace.TraceInvalidate(*psrRegion);
    _invalidMap.set(*psrRegion);
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
531554,UNKNOWN,5,,"[[nodiscard]] HRESULT VtEngine::InvalidateAll() noexcept
try
{
    _trace.TraceInvalidateAll(_lastViewport.ToOrigin().ToExclusive());
    _invalidMap.set_all();
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,90,5,CPPASTProblemDeclaration,,<empty>
531555,UNKNOWN,6,,"[[nodiscard]] HRESULT VtEngine::InvalidateFlush(_In_ const bool circled, _Out_ bool* const pForcePaint) noexcept
{
    *pForcePaint = true;

    // Keep track of the fact that we circled, we'll need to do some work on
    //      end paint to specifically handle this.
    _circled = circled;

    _trace.TraceTriggerCircling(*pForcePaint);
    return S_OK;
}",1,<empty>,,107,6,CPPASTProblemDeclaration,,<empty>
531556,UNKNOWN,7,,"[[nodiscard]] HRESULT VtEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    // This must be kept in sync with RequestWin32Input().
    // It ensures that we disable the modes that we requested on startup.
    // Linux shells for instance don't understand the win32-input-mode 9001.
    //
    // This can be here, instead of being appended at the end of this final rendering pass,
    // because these two states happen to have no influence on the caller's VT parsing.
    std::ignore = _Write(""\033[?9001l\033[?1004l"");

    *pForcePaint = true;
    return S_OK;
}",1,<empty>,,127,7,CPPASTProblemDeclaration,,<empty>
531579,UNKNOWN,2,,"[[nodiscard]] HRESULT VtEngine::IsGlyphWideByFont(const std::wstring_view /*glyph*/, _Out_ bool* const pResult) noexcept
{
    *pResult = false;
    return S_FALSE;
}",1,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
531580,UNKNOWN,3,,"void VtEngine::_OrRect(_Inout_ til::inclusive_rect* const pRectExisting, const til::inclusive_rect* const pRectToOr) const
{
    pRectExisting->left = std::min(pRectExisting->left, pRectToOr->left);
    pRectExisting->top = std::min(pRectExisting->top, pRectToOr->top);
    pRectExisting->right = std::max(pRectExisting->right, pRectToOr->right);
    pRectExisting->bottom = std::max(pRectExisting->bottom, pRectToOr->bottom);
}",1,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
532398,UNKNOWN,-1,,"try
    {
        RETURN_IF_FAILED(_MoveCursor(coord));

        _bufferLine.clear();
        _bufferLine.reserve(clusters.size());

        til::CoordType totalWidth = 0;
        for (const auto& cluster : clusters)
        {
            _bufferLine.append(cluster.GetText());
            totalWidth += cluster.GetColumns();
        }

        RETURN_IF_FAILED(VtEngine::_WriteTerminalAscii(_bufferLine));

        // Update our internal tracker of the cursor's position
        _lastText.x += totalWidth;

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,421,1,CPPASTProblemStatement,,<empty>
532812,UNKNOWN,3,,"VtEngine::VtEngine(_In_ wil::unique_hfile pipe,
                   const Viewport initialViewport) :
    RenderEngineBase(),
    _hFile(std::move(pipe)),
    _usingLineRenditions(false),
    _stopUsingLineRenditions(false),
    _usingSoftFont(false),
    _lastTextAttributes(INVALID_COLOR, INVALID_COLOR, INVALID_COLOR),
    _lastViewport(initialViewport),
    _pool(til::pmr::get_default_resource()),
    _invalidMap(initialViewport.Dimensions(), false, &_pool),
    _scrollDelta(0, 0),
    _quickReturn(false),
    _clearedAllThisFrame(false),
    _cursorMoved(false),
    _resized(false),
    _suppressResizeRepaint(true),
    _virtualTop(0),
    _circled(false),
    _firstPaint(true),
    _skipCursor(false),
    _terminalOwner{ nullptr }",1,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
532813,UNKNOWN,4,,",
    _newBottomLine{ false }",30,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
532814,UNKNOWN,5,,",
    _deferredCursorPos{ INVALID_COORDS }",28,<empty>,,50,5,CPPASTProblemDeclaration,,<empty>
532815,UNKNOWN,6,,",
    _trace{}",41,<empty>,,51,6,CPPASTProblemDeclaration,,<empty>
532816,UNKNOWN,7,,",
    _bufferLine{}",13,<empty>,,52,7,CPPASTProblemDeclaration,,<empty>
532817,UNKNOWN,8,,",
    _buffer{}",18,<empty>,,53,8,CPPASTProblemDeclaration,,<empty>
532818,UNKNOWN,9,,",
    _formatBuffer{}",14,<empty>,,54,9,CPPASTProblemDeclaration,,<empty>
532819,UNKNOWN,10,,",
    _conversionBuffer{}",20,<empty>,,55,10,CPPASTProblemDeclaration,,<empty>
532820,UNKNOWN,11,,",
    _pfnSetLookingForDSR{}",24,<empty>,,56,11,CPPASTProblemDeclaration,,<empty>
532821,UNKNOWN,12,,"{
#ifndef UNIT_TESTING
    // When unit testing, we can instantiate a VtEngine without a pipe.
    THROW_HR_IF(E_HANDLE, !_hFile);
#else
    // member is only defined when UNIT_TESTING is.
    _usingTestCallback = false;
#endif
}",1,<empty>,,58,12,CPPASTProblemDeclaration,,<empty>
532822,UNKNOWN,13,,"[[nodiscard]] HRESULT VtEngine::_WriteFill(const size_t n, const char c) noexcept
try
{
    _trace.TraceStringFill(n, c);
#ifdef UNIT_TESTING
    if (_usingTestCallback)
    {
        const std::string str(n, c);
        // Try to get the last error. If that wasn't set, then the test probably
        // doesn't set last error. No matter. We'll just return with E_FAIL
        // then. This is a unit test, we don't particularly care.
        const auto succeeded = _pfnTestCallback(str.data(), str.size());
        auto hr = E_FAIL;
        if (!succeeded)
        {
            const auto err = ::GetLastError();
            // If there wasn't an error in GLE, just use E_FAIL
            hr = SUCCEEDED_WIN32(err) ? hr : HRESULT_FROM_WIN32(err);
        }
        return succeeded ? S_OK : hr;
    }
#endif

    // TODO GH10001: Replace me with REP
    _buffer.append(n, c);
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,70,13,CPPASTProblemDeclaration,,<empty>
532831,UNKNOWN,-1,,"try
    {
        _buffer.append(str);

        return S_OK;
    }
    CATCH_RETURN();",5,<empty>,,128,2,CPPASTProblemStatement,,<empty>
532958,UNKNOWN,1,,char,62,<empty>,,211,1,CPPASTTypeId,,<empty>
532993,UNKNOWN,22,,"[[nodiscard]] HRESULT VtEngine::UpdateFont(const FontInfoDesired& /*pfiFontDesired*/,
                                           _Out_ FontInfo& /*pfiFont*/) noexcept
{
    return S_OK;
}",1,<empty>,,249,22,CPPASTProblemDeclaration,,<empty>
533101,UNKNOWN,25,,"[[nodiscard]] HRESULT VtEngine::GetProposedFont(const FontInfoDesired& /*pfiFontDesired*/,
                                                _Out_ FontInfo& /*pfiFont*/,
                                                const int /*iDpi*/) noexcept
{
    return S_FALSE;
}",1,<empty>,,342,25,CPPASTProblemDeclaration,,<empty>
533102,UNKNOWN,26,,"[[nodiscard]] HRESULT VtEngine::GetFontSize(_Out_ til::size* const pFontSize) noexcept
{
    *pFontSize = { 1, 1 };
    return S_FALSE;
}",1,<empty>,,355,26,CPPASTProblemDeclaration,,<empty>
533103,UNKNOWN,27,,"void VtEngine::SetTestCallback(_In_ std::function<bool(const char* const, size_t const)> pfn)
{
#ifdef UNIT_TESTING

    _pfnTestCallback = pfn;
    _usingTestCallback = true;

#else
    THROW_HR(E_FAIL);
#endif
}",1,<empty>,,368,27,CPPASTProblemDeclaration,,<empty>
533261,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(g_hConsoleVtRendererTraceProvider,
                             ""Microsoft.Windows.Console.Render.VtEngine"",
                             // tl:{c9ba2a95-d3ca-5e19-2bd6-776a0910cb9d}
                             (0xc9ba2a95, 0xd3ca, 0x5e19, 0x2b, 0xd6, 0x77, 0x6a, 0x09, 0x10, 0xcb, 0x9d),
                             TraceLoggingOptionMicrosoftTelemetry());",1,<empty>,,8,1,CPPASTProblemDeclaration,,<empty>
534062,UNKNOWN,-1,,"VtEngine(_In_ wil::unique_hfile hPipe,
                 const Microsoft::Console::Types::Viewport initialViewport);",9,<empty>,,47,3,CPPASTProblemDeclaration,,<empty>
534075,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* pForcePaint) noexcept override;,9,<empty>,,54,7,CPPASTProblemDeclaration,,<empty>
534100,UNKNOWN,-1,,"[[nodiscard]] HRESULT InvalidateFlush(_In_ const bool circled, _Out_ bool* const pForcePaint) noexcept override;",9,<empty>,,60,13,CPPASTProblemDeclaration,,<empty>
534143,UNKNOWN,-1,,"[[nodiscard]] HRESULT UpdateFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo) noexcept override;",9,<empty>,,68,21,CPPASTProblemDeclaration,,<empty>
534154,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProposedFont(const FontInfoDesired& FontInfoDesired, _Out_ FontInfo& FontInfo, int iDpi) noexcept override;",9,<empty>,,71,24,CPPASTProblemDeclaration,,<empty>
534160,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* pFontSize) noexcept override;,9,<empty>,,73,26,CPPASTProblemDeclaration,,<empty>
534161,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(std::wstring_view glyph, _Out_ bool* pResult) noexcept override;",9,<empty>,,74,27,CPPASTProblemDeclaration,,<empty>
534290,UNKNOWN,-1,,"template<typename S, typename... Args>
        [[nodiscard]] HRESULT _WriteFormatted(S&& format, Args&&... args)
        try
        {
            fmt::basic_memory_buffer<char, 64> buf;
            fmt::format_to(std::back_inserter(buf), std::forward<S>(format), std::forward<Args>(args)...);
            return _Write({ buf.data(), buf.size() });
        }
        CATCH_RETURN()

        void _OrRect(_Inout_ til::inclusive_rect* const pRectExisting, const til::inclusive_rect* const pRectToOr) const;",9,<empty>,,148,81,CPPASTProblemDeclaration,,<empty>
534543,UNKNOWN,-1,,"void SetTestCallback(_In_ std::function<bool(const char* const, size_t const)> pfn);",9,<empty>,,244,139,CPPASTProblemDeclaration,,<empty>
534735,UNKNOWN,1,,PCD_IO_ROW_INFORMATION*,45,<empty>,,91,1,CPPASTTypeId,,<empty>
534766,UNKNOWN,1,,PCD_IO_ROW_INFORMATION,56,<empty>,,97,1,CPPASTTypeId,,<empty>
534802,UNKNOWN,1,,PCD_IO_CHARACTER,61,<empty>,,106,1,CPPASTTypeId,,<empty>
534816,UNKNOWN,1,,PCD_IO_CHARACTER,61,<empty>,,107,1,CPPASTTypeId,,<empty>
534892,UNKNOWN,6,,"[[nodiscard]] HRESULT WddmConEngine::Enable() noexcept
try
{
    RETURN_LAST_ERROR_IF(_hWddmConCtx == INVALID_HANDLE_VALUE);
    return WDDMConEnableDisplayAccess(_hWddmConCtx, TRUE);
}
CATCH_RETURN()

[[nodiscard]] HRESULT WddmConEngine::Disable() noexcept
try
{
    RETURN_LAST_ERROR_IF(_hWddmConCtx == INVALID_HANDLE_VALUE);
    return WDDMConEnableDisplayAccess(_hWddmConCtx, FALSE);
}",1,<empty>,,153,6,CPPASTProblemDeclaration,,<empty>
534893,UNKNOWN,7,,"CATCH_RETURN()

[[nodiscard]] HRESULT WddmConEngine::Invalidate(const til::rect* const /*psrRegion*/) noexcept
{
    return S_OK;
}",1,<empty>,,167,7,CPPASTProblemDeclaration,,<empty>
534928,UNKNOWN,13,,"[[nodiscard]] HRESULT WddmConEngine::PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept
{
    *pForcePaint = false;
    return S_FALSE;
}",1,<empty>,,199,13,CPPASTProblemDeclaration,,<empty>
534929,UNKNOWN,14,,"[[nodiscard]] HRESULT WddmConEngine::StartPaint() noexcept
try
{
    RETURN_LAST_ERROR_IF(_hWddmConCtx == INVALID_HANDLE_VALUE);
    return WDDMConBeginUpdateDisplayBatch(_hWddmConCtx);
}
CATCH_RETURN()

[[nodiscard]] HRESULT WddmConEngine::EndPaint() noexcept
try
{
    RETURN_LAST_ERROR_IF(_hWddmConCtx == INVALID_HANDLE_VALUE);
    return WDDMConEndUpdateDisplayBatch(_hWddmConCtx);
}",1,<empty>,,205,14,CPPASTProblemDeclaration,,<empty>
534930,UNKNOWN,15,,"CATCH_RETURN()

// Routine Description:
// - Used to perform longer running presentation steps outside the lock so the other threads can continue.
// - Not currently used by WddmConEngine.
// Arguments:
// - <none>
// Return Value:
// - S_FALSE since we do nothing.

[[nodiscard]] HRESULT WddmConEngine::Present() noexcept
{
    return S_FALSE;
}",1,<empty>,,219,15,CPPASTProblemDeclaration,,<empty>
535023,UNKNOWN,-1,,"try
    {
        RETURN_LAST_ERROR_IF(_hWddmConCtx == INVALID_HANDLE_VALUE);

        for (size_t i = 0; i < clusters.size() && i < gsl::narrow_cast<size_t>(_displayWidth); i++)
        {
            const auto OldChar = &_displayState[coord.y]->Old[coord.x + i];
            const auto NewChar = &_displayState[coord.y]->New[coord.x + i];

            OldChar->Character = NewChar->Character;
            OldChar->Attribute = NewChar->Attribute;

            NewChar->Character = til::at(clusters, i).GetTextAsSingle();
            NewChar->Attribute = _currentLegacyColorAttribute;
        }

        return WDDMConUpdateDisplay(_hWddmConCtx, _displayState[coord.y], FALSE);
    }
    CATCH_RETURN();",5,<empty>,,266,1,CPPASTProblemStatement,,<empty>
535193,UNKNOWN,29,,"[[nodiscard]] HRESULT WddmConEngine::GetFontSize(_Out_ til::size* const pFontSize) noexcept
{
    // In order to retrieve the font size being used by DirectX, it is necessary
    // to modify the API set that defines the contract for WddmCon. However, the
    // intention is to subsume WddmCon into ConhostV2 directly once the issue of
    // building in the OneCore 'depot' including DirectX headers and libs is
    // resolved. The font size has no bearing on the behavior of the console
    // since it is used to determine the invalid rectangle whenever the console
    // buffer changes. However, given that no invalidation logic exists for this
    // renderer, the value returned by this function is irrelevant.
    //
    // TODO: MSFT 11851921 - Subsume WddmCon into ConhostV2 and remove the API
    //       set extension.
    *pFontSize = { DEFAULT_FONT_WIDTH, DEFAULT_FONT_HEIGHT };
    return S_OK;
}",1,<empty>,,379,29,CPPASTProblemDeclaration,,<empty>
535194,UNKNOWN,30,,"[[nodiscard]] HRESULT WddmConEngine::IsGlyphWideByFont(const std::wstring_view /*glyph*/, _Out_ bool* const pResult) noexcept
{
    *pResult = false;
    return S_OK;
}",1,<empty>,,396,30,CPPASTProblemDeclaration,,<empty>
535195,UNKNOWN,31,,"[[nodiscard]] HRESULT WddmConEngine::_DoUpdateTitle(_In_ const std::wstring_view /*newTitle*/) noexcept
{
    return S_OK;
}",1,<empty>,,409,31,CPPASTProblemDeclaration,,<empty>
535264,UNKNOWN,-1,,[[nodiscard]] HRESULT PrepareForTeardown(_Out_ bool* const pForcePaint) noexcept override;,9,<empty>,,34,14,CPPASTProblemDeclaration,,<empty>
535349,UNKNOWN,-1,,[[nodiscard]] HRESULT GetFontSize(_Out_ til::size* const pFontSize) noexcept override;,9,<empty>,,64,30,CPPASTProblemDeclaration,,<empty>
535350,UNKNOWN,-1,,"[[nodiscard]] HRESULT IsGlyphWideByFont(const std::wstring_view glyph, _Out_ bool* const pResult) noexcept override;",9,<empty>,,65,31,CPPASTProblemDeclaration,,<empty>
535351,UNKNOWN,-1,,[[nodiscard]] HRESULT _DoUpdateTitle(_In_ const std::wstring_view newTitle) noexcept override;,9,<empty>,,68,32,CPPASTProblemDeclaration,,<empty>
535369,UNKNOWN,2,,I,6,<empty>,,6,2,CPPASTProblemDeclaration,,<empty>
535370,UNKNOWN,3,,"WDDMConBeginUpdateDisplayBatch(
    _In_ HANDLE hDisplay);",1,<empty>,,7,3,CPPASTProblemDeclaration,,<empty>
535372,UNKNOWN,5,,I,6,<empty>,,11,5,CPPASTProblemDeclaration,,<empty>
535373,UNKNOWN,6,,"WDDMConCreate(
    _In_ HANDLE* phDisplay);",1,<empty>,,12,6,CPPASTProblemDeclaration,,<empty>
535375,UNKNOWN,8,,I,10,<empty>,,16,8,CPPASTProblemDeclaration,,<empty>
535376,UNKNOWN,9,,"WDDMConDestroy(
        _In_ HANDLE hDisplay);",5,<empty>,,17,9,CPPASTProblemDeclaration,,<empty>
535378,UNKNOWN,11,,I,6,<empty>,,21,11,CPPASTProblemDeclaration,,<empty>
535379,UNKNOWN,12,,"WDDMConEnableDisplayAccess(
    _In_ HANDLE phDisplay,
    _In_ BOOLEAN fEnabled);",1,<empty>,,22,12,CPPASTProblemDeclaration,,<empty>
535381,UNKNOWN,14,,I,6,<empty>,,27,14,CPPASTProblemDeclaration,,<empty>
535382,UNKNOWN,15,,"WDDMConEndUpdateDisplayBatch(
    _In_ HANDLE hDisplay);",1,<empty>,,28,15,CPPASTProblemDeclaration,,<empty>
535384,UNKNOWN,17,,I,6,<empty>,,32,17,CPPASTProblemDeclaration,,<empty>
535385,UNKNOWN,18,,"WDDMConGetDisplaySize(
    _In_ HANDLE hDisplay,
    _In_ CD_IO_DISPLAY_SIZE* pDisplaySize) noexcept;",1,<empty>,,33,18,CPPASTProblemDeclaration,,<empty>
535387,UNKNOWN,20,,I,6,<empty>,,38,20,CPPASTProblemDeclaration,,<empty>
535388,UNKNOWN,21,,"WDDMConUpdateDisplay(
    _In_ HANDLE hDisplay,
    _In_ const CD_IO_ROW_INFORMATION* pRowInformation,
    _In_ BOOLEAN fInvalidate);",1,<empty>,,39,21,CPPASTProblemDeclaration,,<empty>
535398,UNKNOWN,1,,"MIDL_INTERFACE(""e962a0bf-ba8c-4150-9939-4297b11329b6"")
IDXGISwapChainDWM : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Present(UINT SyncInterval, UINT Flags) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetBuffer(UINT Buffer, REFIID riid, void** ppSurface) = 0;
};",1,<empty>,,10,1,CPPASTProblemDeclaration,,<empty>
535399,UNKNOWN,2,,"MIDL_INTERFACE(""599628c0-c2c6-4720-8885-17abe0fd43f2"")
IDXGIFactoryDWM : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE CreateSwapChain(IUnknown * pDevice, DXGI_SWAP_CHAIN_DESC * pDesc, IDXGIOutput * pTarget, IDXGISwapChainDWM * *ppSwapChain) = 0;
};",1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
535499,UNKNOWN,3,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleCP(_Inout_ CONSOLE_API_MSG* const m,
                                                         _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL1.GetConsoleCP;

    if (a->Output)
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleOutputCP);
        m->_pApiRoutines->GetConsoleOutputCodePageImpl(a->CodePage);
    }
    else
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleCP);
        m->_pApiRoutines->GetConsoleInputCodePageImpl(a->CodePage);
    }
    return S_OK;
}",1,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
535500,UNKNOWN,4,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleMode(_Inout_ CONSOLE_API_MSG* const m,
                                                           _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleMode);
    const auto a = &m->u.consoleMsgL1.GetConsoleMode;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    TraceConsoleAPICallWithOrigin(
        ""GetConsoleMode"",
        TraceLoggingBool(pObjectHandle->IsInputHandle(), ""InputHandle""));

    if (pObjectHandle->IsInputHandle())
    {
        InputBuffer* pObj;
        RETURN_IF_FAILED(pObjectHandle->GetInputBuffer(GENERIC_READ, &pObj));
        m->_pApiRoutines->GetConsoleInputModeImpl(*pObj, a->Mode);
    }
    else
    {
        SCREEN_INFORMATION* pObj;
        RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_READ, &pObj));
        m->_pApiRoutines->GetConsoleOutputModeImpl(*pObj, a->Mode);
    }
    return...",1,<empty>,,56,4,CPPASTProblemDeclaration,,<empty>
535501,UNKNOWN,5,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleMode(_Inout_ CONSOLE_API_MSG* const m,
                                                           _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleMode);
    const auto a = &m->u.consoleMsgL1.SetConsoleMode;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    TraceConsoleAPICallWithOrigin(
        ""SetConsoleMode"",
        TraceLoggingBool(pObjectHandle->IsInputHandle(), ""InputHandle""),
        TraceLoggingHexULong(a->Mode, ""Mode""));

    if (pObjectHandle->IsInputHandle())
    {
        InputBuffer* pObj;
        RETURN_IF_FAILED(pObjectHandle->GetInputBuffer(GENERIC_WRITE, &pObj));
        return m->_pApiRoutines->SetConsoleInputModeImpl(*pObj, a->Mode);
    }
    else
    {
        SCREEN_INFORMATION* pObj;
        RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));
        return m->_pApiRouti...",1,<empty>,,84,5,CPPASTProblemDeclaration,,<empty>
535502,UNKNOWN,6,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetNumberOfInputEvents(_Inout_ CONSOLE_API_MSG* const m,
                                                                   _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetNumberOfConsoleInputEvents);
    const auto a = &m->u.consoleMsgL1.GetNumberOfConsoleInputEvents;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    InputBuffer* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetInputBuffer(GENERIC_READ, &pObj));

    return m->_pApiRoutines->GetNumberOfConsoleInputEventsImpl(*pObj, a->ReadyEvents);
}",1,<empty>,,112,6,CPPASTProblemDeclaration,,<empty>
535503,UNKNOWN,7,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleInput(_Inout_ CONSOLE_API_MSG* const m,
                                                            _Inout_ BOOL* const pbReplyPending)
{
    *pbReplyPending = FALSE;

    const auto a = &m->u.consoleMsgL1.GetConsoleInput;
    if (WI_IsFlagSet(a->Flags, CONSOLE_READ_NOREMOVE))
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::PeekConsoleInput, a->Unicode);
    }
    else
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsoleInput, a->Unicode);
    }

    a->NumRecords = 0;

    // If any flags are set that are not within our enum, it's invalid.
    if (WI_IsAnyFlagSet(a->Flags, ~CONSOLE_READ_VALID))
    {
        return E_INVALIDARG;
    }

    // Make sure we have a valid input buffer.
    const auto pHandleData = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pHandleData);
    InputBuffer* pInputBuffer;
    RETURN_IF_FAILED(pHandleData->GetInputBuffer(GENERIC_READ, &pInputBuffer))...",1,<empty>,,127,7,CPPASTProblemDeclaration,,<empty>
535504,UNKNOWN,8,,"[[nodiscard]] HRESULT ApiDispatchers::ServerReadConsole(_Inout_ CONSOLE_API_MSG* const m,
                                                        _Inout_ BOOL* const pbReplyPending)
{
    *pbReplyPending = FALSE;

    const auto a = &m->u.consoleMsgL1.ReadConsole;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsole, a->Unicode);

    a->NumBytes = 0; // we return 0 until proven otherwise.

    // Make sure we have a valid input buffer.
    const auto HandleData = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, HandleData);
    InputBuffer* pInputBuffer;
    RETURN_IF_FAILED(HandleData->GetInputBuffer(GENERIC_READ, &pInputBuffer));

    // Get output parameter buffer.
    PVOID pvBuffer;
    ULONG cbBufferSize;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvBuffer, &cbBufferSize));

    // This might need to go on the other side of the fence (inside host) because the server doesn't know what we're going to do with initial num bytes.
    // (This restriction exists ...",1,<empty>,,226,8,CPPASTProblemDeclaration,,<empty>
535505,UNKNOWN,9,,"[[nodiscard]] HRESULT ApiDispatchers::ServerWriteConsole(_Inout_ CONSOLE_API_MSG* const m,
                                                         _Inout_ BOOL* const pbReplyPending)
{
    *pbReplyPending = FALSE;

    const auto a = &m->u.consoleMsgL1.WriteConsole;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsole, a->Unicode);

    // Make sure we have a valid screen buffer.
    auto HandleData = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, HandleData);
    SCREEN_INFORMATION* pScreenInfo;
    RETURN_IF_FAILED(HandleData->GetScreenBuffer(GENERIC_WRITE, &pScreenInfo));

    // Get input parameter buffer
    PVOID pvBuffer;
    ULONG cbBufferSize;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvBuffer, &cbBufferSize));

    std::unique_ptr<IWaitRoutine> waiter;
    size_t cbRead;

    const auto requiresVtQuirk{ m->GetProcessHandle()->GetShimPolicy().IsVtColorQuirkRequired() };

    // We have to hold onto the HR from the call and return it.
    // We can't r...",1,<empty>,,342,9,CPPASTProblemDeclaration,,<empty>
535506,UNKNOWN,10,,"[[nodiscard]] HRESULT ApiDispatchers::ServerFillConsoleOutput(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.FillConsoleOutput;

    switch (a->ElementType)
    {
    case CONSOLE_ATTRIBUTE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::FillConsoleOutputAttribute);
        break;
    case CONSOLE_ASCII:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::FillConsoleOutputCharacter, false);
        break;
    case CONSOLE_REAL_UNICODE:
    case CONSOLE_FALSE_UNICODE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::FillConsoleOutputCharacter, true);
        break;
    }

    // Capture length of initial fill.
    size_t fill = a->Length;

    // Set written length to 0 in case we early return.
    a->Length = 0;

    // Make sure we have a valid screen buffer.
    auto HandleData = m->GetObjectHandle();
    RETURN_HR_IF_N...",1,<empty>,,423,10,CPPASTProblemDeclaration,,<empty>
535507,UNKNOWN,11,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleActiveScreenBuffer(_Inout_ CONSOLE_API_MSG* const m,
                                                                         _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleActiveScreenBuffer);
    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    m->_pApiRoutines->SetConsoleActiveScreenBufferImpl(*pObj);
    return S_OK;
}",1,<empty>,,498,11,CPPASTProblemDeclaration,,<empty>
535508,UNKNOWN,12,,"[[nodiscard]] HRESULT ApiDispatchers::ServerFlushConsoleInputBuffer(_Inout_ CONSOLE_API_MSG* const m,
                                                                    _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::FlushConsoleInputBuffer);
    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    InputBuffer* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetInputBuffer(GENERIC_WRITE, &pObj));

    m->_pApiRoutines->FlushConsoleInputBuffer(*pObj);
    return S_OK;
}",1,<empty>,,512,12,CPPASTProblemDeclaration,,<empty>
535509,UNKNOWN,13,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleCP(_Inout_ CONSOLE_API_MSG* const m,
                                                         _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.SetConsoleCP;

    if (a->Output)
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleOutputCP);
        return m->_pApiRoutines->SetConsoleOutputCodePageImpl(a->CodePage);
    }
    else
    {
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleCP);
        return m->_pApiRoutines->SetConsoleInputCodePageImpl(a->CodePage);
    }
}",1,<empty>,,526,13,CPPASTProblemDeclaration,,<empty>
535510,UNKNOWN,14,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleCursorInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                 _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleCursorInfo);
    const auto a = &m->u.consoleMsgL2.GetConsoleCursorInfo;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    auto visible = false;
    m->_pApiRoutines->GetConsoleCursorInfoImpl(*pObj, a->CursorSize, visible);
    a->Visible = !!visible;
    return S_OK;
}",1,<empty>,,543,14,CPPASTProblemDeclaration,,<empty>
535511,UNKNOWN,15,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleCursorInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                 _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleCursorInfo);
    const auto a = &m->u.consoleMsgL2.SetConsoleCursorInfo;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    return m->_pApiRoutines->SetConsoleCursorInfoImpl(*pObj, a->CursorSize, a->Visible);
}",1,<empty>,,561,15,CPPASTProblemDeclaration,,<empty>
535512,UNKNOWN,16,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleScreenBufferInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                       _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleScreenBufferInfoEx);
    const auto a = &m->u.consoleMsgL2.GetConsoleScreenBufferInfo;

    CONSOLE_SCREEN_BUFFER_INFOEX ex = { 0 };
    ex.cbSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX);

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_READ, &pObj));

    m->_pApiRoutines->GetConsoleScreenBufferInfoExImpl(*pObj, ex);

    a->FullscreenSupported = !!ex.bFullscreenSupported;
    const auto ColorTableSizeInBytes = RTL_NUMBER_OF_V2(ex.ColorTable) * sizeof(*ex.ColorTable);
    CopyMemory(a->ColorTable, ex.ColorTable, ColorTableSizeInBytes);
    a->CursorPosition = ex...",1,<empty>,,576,16,CPPASTProblemDeclaration,,<empty>
535513,UNKNOWN,17,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleScreenBufferInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                       _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleScreenBufferInfoEx);
    const auto a = &m->u.consoleMsgL2.SetConsoleScreenBufferInfo;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    CONSOLE_SCREEN_BUFFER_INFOEX ex = { 0 };
    ex.cbSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX);
    ex.bFullscreenSupported = a->FullscreenSupported;
    const auto ColorTableSizeInBytes = RTL_NUMBER_OF_V2(ex.ColorTable) * sizeof(*ex.ColorTable);
    CopyMemory(ex.ColorTable, a->ColorTable, ColorTableSizeInBytes);
    ex.dwCursorPosition = a->CursorPosition;
    ex.dwMaximumWindowSize = a->MaximumWindowSize;
...",1,<empty>,,609,17,CPPASTProblemDeclaration,,<empty>
535514,UNKNOWN,18,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleScreenBufferSize(_Inout_ CONSOLE_API_MSG* const m,
                                                                       _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleScreenBufferSize);
    const auto a = &m->u.consoleMsgL2.SetConsoleScreenBufferSize;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    TraceConsoleAPICallWithOrigin(
        ""SetConsoleScreenBufferSize"",
        TraceLoggingConsoleCoord(a->Size, ""BufferSize""));

    return m->_pApiRoutines->SetConsoleScreenBufferSizeImpl(*pObj, til::wrap_coord_size(a->Size));
}",1,<empty>,,646,18,CPPASTProblemDeclaration,,<empty>
535515,UNKNOWN,19,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleCursorPosition(_Inout_ CONSOLE_API_MSG* const m,
                                                                     _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleCursorPosition);
    const auto a = &m->u.consoleMsgL2.SetConsoleCursorPosition;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    return m->_pApiRoutines->SetConsoleCursorPositionImpl(*pObj, til::wrap_coord(a->CursorPosition));
}",1,<empty>,,665,19,CPPASTProblemDeclaration,,<empty>
535516,UNKNOWN,20,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetLargestConsoleWindowSize(_Inout_ CONSOLE_API_MSG* const m,
                                                                        _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetLargestConsoleWindowSize);
    const auto a = &m->u.consoleMsgL2.GetLargestConsoleWindowSize;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    auto size = til::wrap_coord_size(a->Size);
    m->_pApiRoutines->GetLargestConsoleWindowSizeImpl(*pObj, size);
    return til::unwrap_coord_size_hr(size, a->Size);
}",1,<empty>,,680,20,CPPASTProblemDeclaration,,<empty>
535517,UNKNOWN,21,,"[[nodiscard]] HRESULT ApiDispatchers::ServerScrollConsoleScreenBuffer(_Inout_ CONSOLE_API_MSG* const m,
                                                                      _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.ScrollConsoleScreenBuffer;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ScrollConsoleScreenBuffer, a->Unicode);

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    if (a->Unicode)
    {
        // GH#3126 if the client application is cmd.exe, then we might need to
        // enable a compatibility shim.
        return m->_pApiRoutines->ScrollConsoleScreenBufferWImpl(*pObj,
                                                                til::wrap_small_rect(a->ScrollRectangle),
                                                                til::wrap_coord(a->Dest...",1,<empty>,,697,21,CPPASTProblemDeclaration,,<empty>
535518,UNKNOWN,22,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleTextAttribute(_Inout_ CONSOLE_API_MSG* const m,
                                                                    _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleTextAttribute);
    const auto a = &m->u.consoleMsgL2.SetConsoleTextAttribute;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    TraceConsoleAPICallWithOrigin(
        ""SetConsoleTextAttribute"",
        TraceLoggingHexUInt16(a->Attributes, ""Attributes""));

    RETURN_HR(m->_pApiRoutines->SetConsoleTextAttributeImpl(*pObj, a->Attributes));
}",1,<empty>,,732,22,CPPASTProblemDeclaration,,<empty>
535519,UNKNOWN,23,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleWindowInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                 _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleWindowInfo);
    const auto a = &m->u.consoleMsgL2.SetConsoleWindowInfo;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    TraceConsoleAPICallWithOrigin(
        ""SetConsoleWindowInfo"",
        TraceLoggingBool(a->Absolute, ""IsWindowRectAbsolute""),
        TraceLoggingInt32(a->Window.Left, ""WindowRectLeft""),
        TraceLoggingInt32(a->Window.Right, ""WindowRectRight""),
        TraceLoggingInt32(a->Window.Top, ""WindowRectTop""),
        TraceLoggingInt32(a->Window.Bottom, ""WindowRectBottom""));

    return m->_pApiRoutines->SetConsoleWindowInfoImpl(*pObj, ...",1,<empty>,,751,23,CPPASTProblemDeclaration,,<empty>
535520,UNKNOWN,24,,"[[nodiscard]] HRESULT ApiDispatchers::ServerReadConsoleOutputString(_Inout_ CONSOLE_API_MSG* const m,
                                                                    _Inout_ BOOL* const /*pbReplyPending*/)
{
    RETURN_HR_IF(E_ACCESSDENIED, !m->GetProcessHandle()->GetPolicy().CanReadOutputBuffer());

    const auto a = &m->u.consoleMsgL2.ReadConsoleOutputString;

    switch (a->StringType)
    {
    case CONSOLE_ATTRIBUTE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsoleOutputAttribute);
        break;
    case CONSOLE_ASCII:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsoleOutputCharacter, false);
        break;
    case CONSOLE_REAL_UNICODE:
    case CONSOLE_FALSE_UNICODE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsoleOutputCharacter, true);
        break;
    }

    a->NumRecords = 0; // Set to 0 records returned in case we have failures.

    PVOID pvBuffer;
    ULONG cbBuffer;
    RETURN_IF_FAILED(m->G...",1,<empty>,,774,24,CPPASTProblemDeclaration,,<empty>
535521,UNKNOWN,25,,"[[nodiscard]] HRESULT ApiDispatchers::ServerWriteConsoleInput(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.WriteConsoleInput;

    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsoleInput, a->Unicode);

    a->NumRecords = 0;

    RETURN_HR_IF(E_ACCESSDENIED, !m->GetProcessHandle()->GetPolicy().CanWriteInputBuffer());

    PVOID pvBuffer;
    ULONG cbSize;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvBuffer, &cbSize));

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    InputBuffer* pInputBuffer;
    RETURN_IF_FAILED(pObjectHandle->GetInputBuffer(GENERIC_WRITE, &pInputBuffer));

    size_t written;
    std::span<const INPUT_RECORD> buffer(reinterpret_cast<INPUT_RECORD*>(pvBuffer), cbSize / sizeof(INPUT_RECORD));
    if (!a->Unicode)
    {
        RETURN_IF_FAILED(m->_pApiRoutines->WriteCon...",1,<empty>,,841,25,CPPASTProblemDeclaration,,<empty>
535522,UNKNOWN,26,,"[[nodiscard]] HRESULT ApiDispatchers::ServerWriteConsoleOutput(_Inout_ CONSOLE_API_MSG* const m,
                                                               _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.WriteConsoleOutput;

    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsoleOutput, a->Unicode);

    // Backup originalRegion and set the written area to a 0 size rectangle in case of failures.
    const auto originalRegion = Microsoft::Console::Types::Viewport::FromInclusive(til::wrap_small_rect(a->CharRegion));
    auto writtenRegion = Microsoft::Console::Types::Viewport::FromDimensions(originalRegion.Origin(), { 0, 0 });
    RETURN_IF_FAILED(til::unwrap_small_rect_hr(writtenRegion.ToInclusive(), a->CharRegion));

    // Get input parameter buffer
    PVOID pvBuffer;
    ULONG cbSize;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvBuffer, &cbSize));

    // Make sure we have a valid screen buffer.
    auto HandleData = m->GetObjectHand...",1,<empty>,,878,26,CPPASTProblemDeclaration,,<empty>
535523,UNKNOWN,27,,"[[nodiscard]] HRESULT ApiDispatchers::ServerWriteConsoleOutputString(_Inout_ CONSOLE_API_MSG* const m,
                                                                     _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.WriteConsoleOutputString;

    switch (a->StringType)
    {
    case CONSOLE_ATTRIBUTE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsoleOutputAttribute);
        break;
    case CONSOLE_ASCII:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsoleOutputCharacter, false);
        break;
    case CONSOLE_REAL_UNICODE:
    case CONSOLE_FALSE_UNICODE:
        Telemetry::Instance().LogApiCall(Telemetry::ApiCall::WriteConsoleOutputCharacter, true);
        break;
    }

    // Set written records to 0 in case we early return.
    a->NumRecords = 0;

    // Make sure we have a valid screen buffer.
    auto HandleData = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, HandleData);
    SCREEN_INF...",1,<empty>,,922,27,CPPASTProblemDeclaration,,<empty>
535524,UNKNOWN,28,,"[[nodiscard]] HRESULT ApiDispatchers::ServerReadConsoleOutput(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    RETURN_HR_IF(E_ACCESSDENIED, !m->GetProcessHandle()->GetPolicy().CanReadOutputBuffer());

    const auto a = &m->u.consoleMsgL2.ReadConsoleOutput;

    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::ReadConsoleOutput, a->Unicode);

    // Backup data region passed and set it to a zero size region in case we exit early for failures.
    const auto originalRegion = Microsoft::Console::Types::Viewport::FromInclusive(til::wrap_small_rect(a->CharRegion));
    const auto zeroRegion = Microsoft::Console::Types::Viewport::FromDimensions(originalRegion.Origin(), { 0, 0 });
    RETURN_IF_FAILED(til::unwrap_small_rect_hr(zeroRegion.ToInclusive(), a->CharRegion));

    PVOID pvBuffer;
    ULONG cbBuffer;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvBuffer, &cbBuffer));

    const auto pObje...",1,<empty>,,1018,28,CPPASTProblemDeclaration,,<empty>
535525,UNKNOWN,29,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleTitle(_Inout_ CONSOLE_API_MSG* const m,
                                                            _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.GetConsoleTitle;
    Telemetry::Instance().LogApiCall(a->Original ? Telemetry::ApiCall::GetConsoleOriginalTitle : Telemetry::ApiCall::GetConsoleTitle, a->Unicode);

    PVOID pvBuffer;
    ULONG cbBuffer;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvBuffer, &cbBuffer));

    auto hr = S_OK;
    if (a->Unicode)
    {
        std::span<wchar_t> buffer(reinterpret_cast<wchar_t*>(pvBuffer), cbBuffer / sizeof(wchar_t));
        size_t written;
        size_t needed;
        if (a->Original)
        {
            // This API traditionally doesn't return an HRESULT. Log and discard.
            LOG_IF_FAILED(m->_pApiRoutines->GetConsoleOriginalTitleWImpl(buffer, written, needed));
        }
        else
        {
            // This API traditionally doesn't ret...",1,<empty>,,1075,29,CPPASTProblemDeclaration,,<empty>
535526,UNKNOWN,30,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleTitle(_Inout_ CONSOLE_API_MSG* const m,
                                                            _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL2.SetConsoleTitle;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleTitle, a->Unicode);

    PVOID pvBuffer;
    ULONG cbOriginalLength;

    RETURN_IF_FAILED(m->GetInputBuffer(&pvBuffer, &cbOriginalLength));

    if (a->Unicode)
    {
        const std::wstring_view title(reinterpret_cast<wchar_t*>(pvBuffer), cbOriginalLength / sizeof(wchar_t));
        return m->_pApiRoutines->SetConsoleTitleWImpl(title);
    }
    else
    {
        const std::string_view title(reinterpret_cast<char*>(pvBuffer), cbOriginalLength);
        return m->_pApiRoutines->SetConsoleTitleAImpl(title);
    }
}",1,<empty>,,1132,30,CPPASTProblemDeclaration,,<empty>
535527,UNKNOWN,31,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleMouseInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetNumberOfConsoleMouseButtons);
    const auto a = &m->u.consoleMsgL3.GetConsoleMouseInfo;

    m->_pApiRoutines->GetNumberOfConsoleMouseButtonsImpl(a->NumButtons);
    return S_OK;
}",1,<empty>,,1155,31,CPPASTProblemDeclaration,,<empty>
535528,UNKNOWN,32,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleFontSize(_Inout_ CONSOLE_API_MSG* const m,
                                                               _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleFontSize);
    const auto a = &m->u.consoleMsgL3.GetConsoleFontSize;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_READ, &pObj));

    auto size = til::wrap_coord_size(a->FontSize);
    RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleFontSizeImpl(*pObj, a->FontIndex, size));
    return til::unwrap_coord_size_hr(size, a->FontSize);
}",1,<empty>,,1165,32,CPPASTProblemDeclaration,,<empty>
535529,UNKNOWN,33,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleCurrentFont(_Inout_ CONSOLE_API_MSG* const m,
                                                                  _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetCurrentConsoleFontEx);
    const auto a = &m->u.consoleMsgL3.GetCurrentConsoleFont;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_READ, &pObj));

    CONSOLE_FONT_INFOEX FontInfo = { 0 };
    FontInfo.cbSize = sizeof(FontInfo);

    RETURN_IF_FAILED(m->_pApiRoutines->GetCurrentConsoleFontExImpl(*pObj, a->MaximumWindow, FontInfo));

    CopyMemory(a->FaceName, FontInfo.FaceName, RTL_NUMBER_OF_V2(a->FaceName) * sizeof(a->FaceName[0]));
    a->FontFamily = FontInfo.FontFamily;
    a->FontIndex = FontInfo.nFont;
    a->FontSize = FontInfo.dwFontSize;
    a->FontWeight = FontInfo....",1,<empty>,,1182,33,CPPASTProblemDeclaration,,<empty>
535530,UNKNOWN,34,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleDisplayMode(_Inout_ CONSOLE_API_MSG* const m,
                                                                  _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleDisplayMode);
    const auto a = &m->u.consoleMsgL3.SetConsoleDisplayMode;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    auto size = til::wrap_coord_size(a->ScreenBufferDimensions);
    RETURN_IF_FAILED(m->_pApiRoutines->SetConsoleDisplayModeImpl(*pObj, a->dwFlags, size));
    return til::unwrap_coord_size_hr(size, a->ScreenBufferDimensions);
}",1,<empty>,,1208,34,CPPASTProblemDeclaration,,<empty>
535531,UNKNOWN,35,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleDisplayMode(_Inout_ CONSOLE_API_MSG* const m,
                                                                  _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleDisplayMode);
    const auto a = &m->u.consoleMsgL3.GetConsoleDisplayMode;

    // Historically this has never checked the handles. It just returns global state.

    m->_pApiRoutines->GetConsoleDisplayModeImpl(a->ModeFlags);
    return S_OK;
}",1,<empty>,,1225,35,CPPASTProblemDeclaration,,<empty>
535532,UNKNOWN,36,,"[[nodiscard]] HRESULT ApiDispatchers::ServerAddConsoleAlias(_Inout_ CONSOLE_API_MSG* const m,
                                                            _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.AddConsoleAliasW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::AddConsoleAlias, a->Unicode);

    // Read the input buffer and validate the strings.
    PVOID pvBuffer;
    ULONG cbBufferSize;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvBuffer, &cbBufferSize));

    // There are 3 strings stored back-to-back within the message payload.
    // First we verify that their size and alignment are alright and then we extract them.
    const ULONG cbInputExeName = a->ExeLength;
    const ULONG cbInputSource = a->SourceLength;
    const ULONG cbInputTarget = a->TargetLength;

    const auto alignment = a->Unicode ? alignof(wchar_t) : alignof(char);
    // ExeLength, SourceLength and TargetLength are USHORT and summing them up will not overflow a ULONG...",1,<empty>,,1237,36,CPPASTProblemDeclaration,,<empty>
535533,UNKNOWN,37,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleAlias(_Inout_ CONSOLE_API_MSG* const m,
                                                            _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleAliasW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleAlias, a->Unicode);

    PVOID pvInputBuffer;
    ULONG cbInputBufferSize;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvInputBuffer, &cbInputBufferSize));

    // There are 2 strings stored back-to-back within the message payload.
    // First we verify that their size and alignment are alright and then we extract them.
    const ULONG cbInputExeName = a->ExeLength;
    const ULONG cbInputSource = a->SourceLength;

    const auto alignment = a->Unicode ? alignof(wchar_t) : alignof(char);
    // ExeLength and SourceLength are USHORT and summing them up will not overflow a ULONG.
    const auto badLength = cbInputExeName + cbInputSource > cbInputBufferSize;
    // Since (any...",1,<empty>,,1285,37,CPPASTProblemDeclaration,,<empty>
535534,UNKNOWN,38,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleAliasesLength(_Inout_ CONSOLE_API_MSG* const m,
                                                                    _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleAliasesLengthW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleAliasesLength, a->Unicode);

    ULONG cbExeNameLength;
    PVOID pvExeName;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    size_t cbAliasesLength;
    if (a->Unicode)
    {
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));
        size_t cchAliasesLength;
        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleAliasesLengthWImpl(inputExeName, cchAliasesLength));

        RETURN_IF_FAILED(SizeTMult(cchAliasesLength, sizeof(wchar_t), &cbAliasesLength));
    }
    else
    {
        const std::string_view inputExeName(reinterpret_cast<char*>(pvExeName), ...",1,<empty>,,1359,38,CPPASTProblemDeclaration,,<empty>
535535,UNKNOWN,39,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleAliasExesLength(_Inout_ CONSOLE_API_MSG* const m,
                                                                      _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleAliasExesLengthW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleAliasExesLength, a->Unicode);

    size_t cbAliasExesLength;
    if (a->Unicode)
    {
        size_t cchAliasExesLength;
        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleAliasExesLengthWImpl(cchAliasExesLength));
        cbAliasExesLength = cchAliasExesLength * sizeof(wchar_t);
    }
    else
    {
        size_t cchAliasExesLength;
        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleAliasExesLengthAImpl(cchAliasExesLength));
        cbAliasExesLength = cchAliasExesLength;
    }

    RETURN_IF_FAILED(SizeTToULong(cbAliasExesLength, &a->AliasExesLength));

    return S_OK;
}",1,<empty>,,1392,39,CPPASTProblemDeclaration,,<empty>
535536,UNKNOWN,40,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleAliases(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleAliasesW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleAliases, a->Unicode);

    PVOID pvExeName;
    ULONG cbExeNameLength;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    PVOID pvOutputBuffer;
    DWORD cbAliasesBufferLength;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvOutputBuffer, &cbAliasesBufferLength));

    size_t cbWritten;
    if (a->Unicode)
    {
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));
        std::span<wchar_t> outputBuffer(reinterpret_cast<wchar_t*>(pvOutputBuffer), cbAliasesBufferLength / sizeof(wchar_t));
        size_t cchWritten;

        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleAliasesWImp...",1,<empty>,,1417,40,CPPASTProblemDeclaration,,<empty>
535537,UNKNOWN,41,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleAliasExes(_Inout_ CONSOLE_API_MSG* const m,
                                                                _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleAliasExesW;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleAliasExes, a->Unicode);

    PVOID pvBuffer;
    ULONG cbAliasExesBufferLength;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvBuffer, &cbAliasExesBufferLength));

    size_t cbWritten;
    if (a->Unicode)
    {
        std::span<wchar_t> outputBuffer(reinterpret_cast<wchar_t*>(pvBuffer), cbAliasExesBufferLength / sizeof(wchar_t));
        size_t cchWritten;
        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleAliasExesWImpl(outputBuffer, cchWritten));

        RETURN_IF_FAILED(SizeTMult(cchWritten, sizeof(wchar_t), &cbWritten));
    }
    else
    {
        std::span<char> outputBuffer(reinterpret_cast<char*>(pvBuffer), cbAliasExesBufferLength);
        size_t ...",1,<empty>,,1461,41,CPPASTProblemDeclaration,,<empty>
535538,UNKNOWN,42,,"[[nodiscard]] HRESULT ApiDispatchers::ServerExpungeConsoleCommandHistory(_Inout_ CONSOLE_API_MSG* const m,
                                                                         _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.ExpungeConsoleCommandHistoryW;

    PVOID pvExeName;
    ULONG cbExeNameLength;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    if (a->Unicode)
    {
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));

        return m->_pApiRoutines->ExpungeConsoleCommandHistoryWImpl(inputExeName);
    }
    else
    {
        const std::string_view inputExeName(reinterpret_cast<char*>(pvExeName), cbExeNameLength);

        return m->_pApiRoutines->ExpungeConsoleCommandHistoryAImpl(inputExeName);
    }
}",1,<empty>,,1497,42,CPPASTProblemDeclaration,,<empty>
535539,UNKNOWN,43,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleNumberOfCommands(_Inout_ CONSOLE_API_MSG* const m,
                                                                       _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.SetConsoleNumberOfCommandsW;
    PVOID pvExeName;
    ULONG cbExeNameLength;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    const size_t NumberOfCommands = a->NumCommands;
    if (a->Unicode)
    {
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));

        return m->_pApiRoutines->SetConsoleNumberOfCommandsWImpl(inputExeName, NumberOfCommands);
    }
    else
    {
        const std::string_view inputExeName(reinterpret_cast<char*>(pvExeName), cbExeNameLength);

        return m->_pApiRoutines->SetConsoleNumberOfCommandsAImpl(inputExeName, NumberOfCommands);
    }
}",1,<empty>,,1520,43,CPPASTProblemDeclaration,,<empty>
535540,UNKNOWN,44,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleCommandHistoryLength(_Inout_ CONSOLE_API_MSG* const m,
                                                                           _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleCommandHistoryLengthW;

    PVOID pvExeName;
    ULONG cbExeNameLength;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    size_t cbCommandHistoryLength;
    if (a->Unicode)
    {
        size_t cchCommandHistoryLength;
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));

        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleCommandHistoryLengthWImpl(inputExeName, cchCommandHistoryLength));

        // We must set the reply length in bytes. Convert back from characters.
        RETURN_IF_FAILED(SizeTMult(cchCommandHistoryLength, sizeof(wchar_t), &cbCommandHistoryLength));
    }
    else
    {
        size_t cchCommandHistor...",1,<empty>,,1543,44,CPPASTProblemDeclaration,,<empty>
535541,UNKNOWN,45,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleCommandHistory(_Inout_ CONSOLE_API_MSG* const m,
                                                                     _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleCommandHistoryW;

    PVOID pvExeName;
    ULONG cbExeNameLength;
    RETURN_IF_FAILED(m->GetInputBuffer(&pvExeName, &cbExeNameLength));

    PVOID pvOutputBuffer;
    ULONG cbOutputBuffer;
    RETURN_IF_FAILED(m->GetOutputBuffer(&pvOutputBuffer, &cbOutputBuffer));

    size_t cbWritten;
    if (a->Unicode)
    {
        const std::wstring_view inputExeName(reinterpret_cast<wchar_t*>(pvExeName), cbExeNameLength / sizeof(wchar_t));
        std::span<wchar_t> outputBuffer(reinterpret_cast<wchar_t*>(pvOutputBuffer), cbOutputBuffer / sizeof(wchar_t));
        size_t cchWritten;
        RETURN_IF_FAILED(m->_pApiRoutines->GetConsoleCommandHistoryWImpl(inputExeName, outputBuffer, cchWritten));

        // We must set the reply lengt...",1,<empty>,,1579,45,CPPASTProblemDeclaration,,<empty>
535542,UNKNOWN,46,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleWindow(_Inout_ CONSOLE_API_MSG* const m,
                                                             _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleWindow);
    const auto a = &m->u.consoleMsgL3.GetConsoleWindow;

    m->_pApiRoutines->GetConsoleWindowImpl(a->hwnd);
    return S_OK;
}",1,<empty>,,1621,46,CPPASTProblemDeclaration,,<empty>
535543,UNKNOWN,47,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleSelectionInfo(_Inout_ CONSOLE_API_MSG* const m,
                                                                    _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleSelectionInfo);
    const auto a = &m->u.consoleMsgL3.GetConsoleSelectionInfo;

    m->_pApiRoutines->GetConsoleSelectionInfoImpl(a->SelectionInfo);
    return S_OK;
}",1,<empty>,,1631,47,CPPASTProblemDeclaration,,<empty>
535544,UNKNOWN,48,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleHistory(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.GetConsoleHistory;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleHistoryInfo);

    CONSOLE_HISTORY_INFO info;
    info.cbSize = sizeof(info);

    m->_pApiRoutines->GetConsoleHistoryInfoImpl(info);

    a->dwFlags = info.dwFlags;
    a->HistoryBufferSize = info.HistoryBufferSize;
    a->NumberOfHistoryBuffers = info.NumberOfHistoryBuffers;

    return S_OK;
}",1,<empty>,,1641,48,CPPASTProblemDeclaration,,<empty>
535545,UNKNOWN,49,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleHistory(_Inout_ CONSOLE_API_MSG* const m,
                                                              _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL3.SetConsoleHistory;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetConsoleHistoryInfo);

    CONSOLE_HISTORY_INFO info;
    info.cbSize = sizeof(info);
    info.dwFlags = a->dwFlags;
    info.HistoryBufferSize = a->HistoryBufferSize;
    info.NumberOfHistoryBuffers = a->NumberOfHistoryBuffers;

    return m->_pApiRoutines->SetConsoleHistoryInfoImpl(info);
}",1,<empty>,,1659,49,CPPASTProblemDeclaration,,<empty>
535546,UNKNOWN,50,,"[[nodiscard]] HRESULT ApiDispatchers::ServerSetConsoleCurrentFont(_Inout_ CONSOLE_API_MSG* const m,
                                                                  _Inout_ BOOL* const /*pbReplyPending*/)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::SetCurrentConsoleFontEx);
    const auto a = &m->u.consoleMsgL3.SetCurrentConsoleFont;

    const auto pObjectHandle = m->GetObjectHandle();
    RETURN_HR_IF_NULL(E_HANDLE, pObjectHandle);

    SCREEN_INFORMATION* pObj;
    RETURN_IF_FAILED(pObjectHandle->GetScreenBuffer(GENERIC_WRITE, &pObj));

    CONSOLE_FONT_INFOEX Info;
    Info.cbSize = sizeof(Info);
    Info.dwFontSize = a->FontSize;
    CopyMemory(Info.FaceName, a->FaceName, RTL_NUMBER_OF_V2(Info.FaceName) * sizeof(Info.FaceName[0]));
    Info.FontFamily = a->FontFamily;
    Info.FontWeight = a->FontWeight;

    return m->_pApiRoutines->SetCurrentConsoleFontExImpl(*pObj, a->MaximumWindow, Info);
}",1,<empty>,,1674,50,CPPASTProblemDeclaration,,<empty>
535557,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerDeprecatedApi(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
535558,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleCP(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
535559,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,30,3,CPPASTProblemDeclaration,,<empty>
535560,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,31,4,CPPASTProblemDeclaration,,<empty>
535561,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetNumberOfInputEvents(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,32,5,CPPASTProblemDeclaration,,<empty>
535562,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleInput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,33,6,CPPASTProblemDeclaration,,<empty>
535563,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerReadConsole(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,34,7,CPPASTProblemDeclaration,,<empty>
535564,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerWriteConsole(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,35,8,CPPASTProblemDeclaration,,<empty>
535565,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleLangId(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,36,9,CPPASTProblemDeclaration,,<empty>
535566,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerFillConsoleOutput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,40,10,CPPASTProblemDeclaration,,<empty>
535567,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGenerateConsoleCtrlEvent(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,41,11,CPPASTProblemDeclaration,,<empty>
535568,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleActiveScreenBuffer(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,42,12,CPPASTProblemDeclaration,,<empty>
535569,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerFlushConsoleInputBuffer(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,43,13,CPPASTProblemDeclaration,,<empty>
535570,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleCP(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,44,14,CPPASTProblemDeclaration,,<empty>
535571,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleCursorInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,45,15,CPPASTProblemDeclaration,,<empty>
535572,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleCursorInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,46,16,CPPASTProblemDeclaration,,<empty>
535573,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleScreenBufferInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,47,17,CPPASTProblemDeclaration,,<empty>
535574,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleScreenBufferInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,48,18,CPPASTProblemDeclaration,,<empty>
535575,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleScreenBufferSize(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,49,19,CPPASTProblemDeclaration,,<empty>
535576,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleCursorPosition(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,50,20,CPPASTProblemDeclaration,,<empty>
535577,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetLargestConsoleWindowSize(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,51,21,CPPASTProblemDeclaration,,<empty>
535578,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerScrollConsoleScreenBuffer(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,52,22,CPPASTProblemDeclaration,,<empty>
535579,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleTextAttribute(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,53,23,CPPASTProblemDeclaration,,<empty>
535580,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleWindowInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,54,24,CPPASTProblemDeclaration,,<empty>
535581,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerReadConsoleOutputString(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,55,25,CPPASTProblemDeclaration,,<empty>
535582,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerWriteConsoleInput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,56,26,CPPASTProblemDeclaration,,<empty>
535583,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerWriteConsoleOutput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,57,27,CPPASTProblemDeclaration,,<empty>
535584,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerWriteConsoleOutputString(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,58,28,CPPASTProblemDeclaration,,<empty>
535585,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerReadConsoleOutput(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,59,29,CPPASTProblemDeclaration,,<empty>
535586,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleTitle(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,60,30,CPPASTProblemDeclaration,,<empty>
535587,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleTitle(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,61,31,CPPASTProblemDeclaration,,<empty>
535588,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleMouseInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,65,32,CPPASTProblemDeclaration,,<empty>
535589,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleFontSize(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,66,33,CPPASTProblemDeclaration,,<empty>
535590,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleCurrentFont(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,67,34,CPPASTProblemDeclaration,,<empty>
535591,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleDisplayMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,68,35,CPPASTProblemDeclaration,,<empty>
535592,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleDisplayMode(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,69,36,CPPASTProblemDeclaration,,<empty>
535593,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerAddConsoleAlias(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,70,37,CPPASTProblemDeclaration,,<empty>
535594,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleAlias(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,71,38,CPPASTProblemDeclaration,,<empty>
535595,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleAliasesLength(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,72,39,CPPASTProblemDeclaration,,<empty>
535596,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleAliasExesLength(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,73,40,CPPASTProblemDeclaration,,<empty>
535597,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleAliases(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,74,41,CPPASTProblemDeclaration,,<empty>
535598,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleAliasExes(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,75,42,CPPASTProblemDeclaration,,<empty>
535599,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerExpungeConsoleCommandHistory(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,78,43,CPPASTProblemDeclaration,,<empty>
535600,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleNumberOfCommands(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,79,44,CPPASTProblemDeclaration,,<empty>
535601,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleCommandHistoryLength(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,80,45,CPPASTProblemDeclaration,,<empty>
535602,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleCommandHistory(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,81,46,CPPASTProblemDeclaration,,<empty>
535603,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleWindow(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,84,47,CPPASTProblemDeclaration,,<empty>
535604,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleSelectionInfo(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,85,48,CPPASTProblemDeclaration,,<empty>
535605,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleProcessList(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,86,49,CPPASTProblemDeclaration,,<empty>
535606,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerGetConsoleHistory(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,87,50,CPPASTProblemDeclaration,,<empty>
535607,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleHistory(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,88,51,CPPASTProblemDeclaration,,<empty>
535608,UNKNOWN,-1,,"[[nodiscard]] HRESULT ServerSetConsoleCurrentFont(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const pbReplyPending);",5,<empty>,,89,52,CPPASTProblemDeclaration,,<empty>
535630,UNKNOWN,1,,"[[nodiscard]] HRESULT ApiDispatchers::ServerDeprecatedApi(_Inout_ CONSOLE_API_MSG* const m, _Inout_ BOOL* const /*pbReplyPending*/)
{
    // log if we hit a deprecated API.
    RETURN_HR_MSG(E_NOTIMPL, ""Deprecated API attempted: 0x%08x"", m->Descriptor.Function);
}",1,<empty>,,19,1,CPPASTProblemDeclaration,,<empty>
535631,UNKNOWN,2,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleProcessList(_Inout_ CONSOLE_API_MSG* const m,
                                                                  _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    const auto a = &m->u.consoleMsgL3.GetConsoleProcessList;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleProcessList);

    PVOID Buffer;
    ULONG BufferSize;
    RETURN_IF_FAILED(m->GetOutputBuffer(&Buffer, &BufferSize));

    a->dwProcessCount = BufferSize / sizeof(ULONG);

    LockConsole();
    auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

    /*
    * If there's not enough space in the array to hold all the pids, we'll
    * inform the user of that by returning a number > than a->dwProcessCount
    * (but we still return S_OK).
    */

    auto lpdwProcessList = (PDWORD)Buffer;
    size_t cProcessList = a->dwProcessCount;
    if (SUCCEEDED(gci.ProcessHandleList...",1,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
535632,UNKNOWN,3,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGetConsoleLangId(_Inout_ CONSOLE_API_MSG* const m,
                                                             _Inout_ BOOL* const /*pbReplyPending*/)
{
    const auto a = &m->u.consoleMsgL1.GetConsoleLangId;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GetConsoleLangId);

    // TODO: MSFT: 9115192 - This should probably just ask through GetOutputCP and convert it ourselves on this side.
    return m->_pApiRoutines->GetConsoleLangIdImpl(a->LangId);
}",1,<empty>,,59,3,CPPASTProblemDeclaration,,<empty>
535633,UNKNOWN,4,,"[[nodiscard]] HRESULT ApiDispatchers::ServerGenerateConsoleCtrlEvent(_Inout_ CONSOLE_API_MSG* const m,
                                                                     _Inout_ BOOL* const /*pbReplyPending*/)
{
    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    const auto a = &m->u.consoleMsgL2.GenerateConsoleCtrlEvent;
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::GenerateConsoleCtrlEvent);

    LockConsole();
    auto Unlock = wil::scope_exit([&] { UnlockConsole(); });

    // Make sure the process group id is valid.
    if (a->ProcessGroupId != 0)
    {
        ConsoleProcessHandle* ProcessHandle;
        ProcessHandle = gci.ProcessHandleList.FindProcessByGroupId(a->ProcessGroupId);
        if (ProcessHandle == nullptr)
        {
            auto ProcessId = a->ProcessGroupId;

            // We didn't find a process with that group ID.
            // Let's see if the process with that ID exists and has a parent that is a member of this con...",1,<empty>,,69,4,CPPASTProblemDeclaration,,<empty>
535765,UNKNOWN,1,,ConsoleProcessHandle*,29,<empty>,,60,1,CPPASTTypeId,,<empty>
535779,UNKNOWN,1,,ConsoleHandleData*,29,<empty>,,65,1,CPPASTTypeId,,<empty>
535789,UNKNOWN,8,,"[[nodiscard]] HRESULT _CONSOLE_API_MSG::ReadMessageInput(const ULONG cbOffset,
                                                         _Out_writes_bytes_(cbSize) PVOID pvBuffer,
                                                         const ULONG cbSize)
{
    CD_IO_OPERATION IoOperation;
    IoOperation.Identifier = Descriptor.Identifier;
    IoOperation.Buffer.Offset = State.ReadOffset + cbOffset;
    IoOperation.Buffer.Data = pvBuffer;
    IoOperation.Buffer.Size = cbSize;

    return _pDeviceComm->ReadInput(&IoOperation);
}",1,<empty>,,76,8,CPPASTProblemDeclaration,,<empty>
535790,UNKNOWN,9,,"[[nodiscard]] HRESULT _CONSOLE_API_MSG::GetInputBuffer(_Outptr_result_bytebuffer_(*pcbSize) void** const ppvBuffer,
                                                       _Out_ ULONG* const pcbSize)
try
{
    // Initialize the buffer if it hasn't been initialized yet.
    if (State.InputBuffer == nullptr)
    {
        RETURN_HR_IF(E_FAIL, State.ReadOffset > Descriptor.InputSize);

        const auto cbReadSize = Descriptor.InputSize - State.ReadOffset;

        // If we were previously called with a huge buffer we have an equally large _inputBuffer.
        // We shouldn't just keep this huge buffer around, if no one needs it anymore.
        if (_inputBuffer.capacity() > 16 * 1024 && (_inputBuffer.capacity() >> 1) > cbReadSize)
        {
            _inputBuffer.shrink_to_fit();
        }

        _inputBuffer.resize(cbReadSize);

        RETURN_IF_FAILED(ReadMessageInput(0, _inputBuffer.data(), cbReadSize));

        State.InputBuffer = _inputBuffer.data();
        State.InputBuf...",1,<empty>,,98,9,CPPASTProblemDeclaration,,<empty>
535791,UNKNOWN,10,,CATCH_RETURN();,1,<empty>,,130,10,CPPASTProblemDeclaration,,<empty>
535792,UNKNOWN,11,,"[[nodiscard]] HRESULT _CONSOLE_API_MSG::GetOutputBuffer(_Outptr_result_bytebuffer_(*pcbSize) void** const ppvBuffer,
                                                        _Out_ ULONG* const pcbSize)
try
{
    // Initialize the buffer if it hasn't been initialized yet.
    if (State.OutputBuffer == nullptr)
    {
        RETURN_HR_IF(E_FAIL, State.WriteOffset > Descriptor.OutputSize);

        auto cbWriteSize = Descriptor.OutputSize - State.WriteOffset;

        // If we were previously called with a huge buffer we have an equally large _outputBuffer.
        // We shouldn't just keep this huge buffer around, if no one needs it anymore.
        if (_outputBuffer.capacity() > 16 * 1024 && (_outputBuffer.capacity() >> 1) > cbWriteSize)
        {
            _outputBuffer.shrink_to_fit();
        }

        _outputBuffer.resize(cbWriteSize);

        // 0 it out.
        std::fill_n(_outputBuffer.data(), _outputBuffer.size(), BYTE(0));

        State.OutputBuffer = _outputBuffer.data...",1,<empty>,,141,11,CPPASTProblemDeclaration,,<empty>
535793,UNKNOWN,12,,CATCH_RETURN();,1,<empty>,,174,12,CPPASTProblemDeclaration,,<empty>
535869,UNKNOWN,1,,ULONG,40,<empty>,,204,1,CPPASTTypeId,,<empty>
535961,UNKNOWN,-1,,"[[nodiscard]] HRESULT ReadMessageInput(const ULONG cbOffset, _Out_writes_bytes_(cbSize) PVOID pvBuffer, const ULONG cbSize);",5,<empty>,,43,6,CPPASTProblemDeclaration,,<empty>
535962,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetOutputBuffer(_Outptr_result_bytebuffer_(*pcbSize) void** const ppvBuffer, _Out_ ULONG* const pcbSize);",5,<empty>,,44,7,CPPASTProblemDeclaration,,<empty>
535963,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetInputBuffer(_Outptr_result_bytebuffer_(*pcbSize) void** const ppvBuffer, _Out_ ULONG* const pcbSize);",5,<empty>,,45,8,CPPASTProblemDeclaration,,<empty>
536629,UNKNOWN,15,,"PCONSOLE_API_MSG ApiSorter::ConsoleDispatchRequest(_Inout_ PCONSOLE_API_MSG Message)
{
    // Make sure the indices are valid and retrieve the API descriptor.
    const auto LayerNumber = (Message->msgHeader.ApiNumber >> 24) - 1;
    const auto ApiNumber = Message->msgHeader.ApiNumber & 0xffffff;

    if ((LayerNumber >= std::size(ConsoleApiLayerTable)) || (ApiNumber >= ConsoleApiLayerTable[LayerNumber].Count))
    {
        Message->SetReplyStatus(STATUS_ILLEGAL_FUNCTION);
        return Message;
    }

    auto Descriptor = &ConsoleApiLayerTable[LayerNumber].Descriptor[ApiNumber];

    // Validate the argument size and call the API.
    if ((Message->Descriptor.InputSize < sizeof(CONSOLE_MSG_HEADER)) ||
        (Message->msgHeader.ApiDescriptorSize > sizeof(Message->u)) ||
        (Message->msgHeader.ApiDescriptorSize > Message->Descriptor.InputSize - sizeof(CONSOLE_MSG_HEADER)) ||
        (Message->msgHeader.ApiDescriptorSize < Descriptor->RequiredSize))
    {
        Message->Se...",1,<empty>,,141,15,CPPASTProblemDeclaration,,<empty>
536637,UNKNOWN,1,,"typedef HRESULT (*PCONSOLE_API_ROUTINE)(_Inout_ PCONSOLE_API_MSG m, _Inout_ PBOOL ReplyPending);",1,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
536639,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleDispatchRequest(_Inout_ PCONSOLE_API_MSG Message);,5,<empty>,,43,1,CPPASTProblemDeclaration,,<empty>
536649,UNKNOWN,1,,"ConDrvDeviceComm::ConDrvDeviceComm(_In_ HANDLE Server) :
    _Server(Server)
{
    THROW_HR_IF(E_HANDLE, Server == INVALID_HANDLE_VALUE);
}",1,<empty>,,7,1,CPPASTProblemDeclaration,,<empty>
536654,UNKNOWN,3,,"[[nodiscard]] HRESULT ConDrvDeviceComm::SetServerInformation(_In_ CD_IO_SERVER_INFORMATION* const pServerInfo) const
{
    return _CallIoctl(IOCTL_CONDRV_SET_SERVER_INFORMATION,
                      pServerInfo,
                      sizeof(*pServerInfo),
                      nullptr,
                      0);
}",1,<empty>,,23,3,CPPASTProblemDeclaration,,<empty>
536655,UNKNOWN,4,,"[[nodiscard]] HRESULT ConDrvDeviceComm::ReadIo(_In_opt_ PCONSOLE_API_MSG const pReplyMsg,
                                               _Out_ CONSOLE_API_MSG* const pMessage) const
{
    auto hr = _CallIoctl(IOCTL_CONDRV_READ_IO,
                         pReplyMsg == nullptr ? nullptr : &pReplyMsg->Complete,
                         pReplyMsg == nullptr ? 0 : sizeof(pReplyMsg->Complete),
                         &pMessage->Descriptor,
                         sizeof(CONSOLE_API_MSG) - FIELD_OFFSET(CONSOLE_API_MSG, Descriptor));

    if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING))
    {
        WaitForSingleObjectEx(_Server.get(), 0, FALSE);
        hr = S_OK; // TODO: MSFT: 9115192 - ??? This isn't really relevant anymore with a switch from NtDeviceIoControlFile to DeviceIoControl...
    }

    return hr;
}",1,<empty>,,39,4,CPPASTProblemDeclaration,,<empty>
536656,UNKNOWN,5,,"[[nodiscard]] HRESULT ConDrvDeviceComm::CompleteIo(_In_ CD_IO_COMPLETE* const pCompletion) const
{
    return _CallIoctl(IOCTL_CONDRV_COMPLETE_IO,
                      pCompletion,
                      sizeof(*pCompletion),
                      nullptr,
                      0);
}",1,<empty>,,63,5,CPPASTProblemDeclaration,,<empty>
536657,UNKNOWN,6,,"[[nodiscard]] HRESULT ConDrvDeviceComm::ReadInput(_In_ CD_IO_OPERATION* const pIoOperation) const
{
    return _CallIoctl(IOCTL_CONDRV_READ_INPUT,
                      pIoOperation,
                      sizeof(*pIoOperation),
                      nullptr,
                      0);
}",1,<empty>,,79,6,CPPASTProblemDeclaration,,<empty>
536658,UNKNOWN,7,,"[[nodiscard]] HRESULT ConDrvDeviceComm::WriteOutput(_In_ CD_IO_OPERATION* const pIoOperation) const
{
    return _CallIoctl(IOCTL_CONDRV_WRITE_OUTPUT,
                      pIoOperation,
                      sizeof(*pIoOperation),
                      nullptr,
                      0);
}",1,<empty>,,95,7,CPPASTProblemDeclaration,,<empty>
536670,UNKNOWN,9,,"[[nodiscard]] HRESULT ConDrvDeviceComm::_CallIoctl(_In_ DWORD dwIoControlCode,
                                                   _In_reads_bytes_opt_(cbInBufferSize) PVOID pInBuffer,
                                                   _In_ DWORD cbInBufferSize,
                                                   _Out_writes_bytes_opt_(cbOutBufferSize) PVOID pOutBuffer,
                                                   _In_ DWORD cbOutBufferSize) const
{
    // See: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216(v=vs.85).aspx
    // Written is unused but cannot be nullptr because we aren't using overlapped.
    DWORD cbWritten = 0;
    RETURN_IF_WIN32_BOOL_FALSE(DeviceIoControl(_Server.get(),
                                               dwIoControlCode,
                                               pInBuffer,
                                               cbInBufferSize,
                                               pOutBuffer,
                                 ...",1,<empty>,,131,9,CPPASTProblemDeclaration,,<empty>
536676,UNKNOWN,1,,ULONG_PTR,29,<empty>,,162,1,CPPASTTypeId,,<empty>
536685,UNKNOWN,1,,void*,29,<empty>,,172,1,CPPASTTypeId,,<empty>
536689,UNKNOWN,12,,"[[nodiscard]] HRESULT ConDrvDeviceComm::GetServerHandle(_Out_ HANDLE* pHandle) const
{
    *pHandle = _Server.get();
    return S_OK;
}",1,<empty>,,178,12,CPPASTProblemDeclaration,,<empty>
536700,UNKNOWN,-1,,ConDrvDeviceComm(_In_ HANDLE Server);,5,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
536705,UNKNOWN,-1,,[[nodiscard]] HRESULT SetServerInformation(_In_ CD_IO_SERVER_INFORMATION* const pServerInfo) const override;,5,<empty>,,30,3,CPPASTProblemDeclaration,,<empty>
536706,UNKNOWN,-1,,"[[nodiscard]] HRESULT ReadIo(_In_opt_ PCONSOLE_API_MSG const pReplyMsg,
                                 _Out_ CONSOLE_API_MSG* const pMessage) const override;",5,<empty>,,31,4,CPPASTProblemDeclaration,,<empty>
536707,UNKNOWN,-1,,[[nodiscard]] HRESULT CompleteIo(_In_ CD_IO_COMPLETE* const pCompletion) const override;,5,<empty>,,33,5,CPPASTProblemDeclaration,,<empty>
536708,UNKNOWN,-1,,[[nodiscard]] HRESULT ReadInput(_In_ CD_IO_OPERATION* const pIoOperation) const override;,5,<empty>,,35,6,CPPASTProblemDeclaration,,<empty>
536709,UNKNOWN,-1,,[[nodiscard]] HRESULT WriteOutput(_In_ CD_IO_OPERATION* const pIoOperation) const override;,5,<empty>,,36,7,CPPASTProblemDeclaration,,<empty>
536724,UNKNOWN,-1,,[[nodiscard]] HRESULT GetServerHandle(_Out_ HANDLE* pHandle) const override;,5,<empty>,,43,11,CPPASTProblemDeclaration,,<empty>
536725,UNKNOWN,-1,,"[[nodiscard]] HRESULT _CallIoctl(_In_ DWORD dwIoControlCode,
                                     _In_reads_bytes_opt_(cbInBufferSize) PVOID pInBuffer,
                                     _In_ DWORD cbInBufferSize,
                                     _Out_writes_bytes_opt_(cbOutBufferSize) PVOID pOutBuffer,
                                     _In_ DWORD cbOutBufferSize) const;",5,<empty>,,46,12,CPPASTProblemDeclaration,,<empty>
536739,UNKNOWN,-1,,"try
    {
        const std::filesystem::path processName = wil::GetModuleFileNameExW<std::wstring>(hProcess, nullptr);
        const auto clientName = processName.filename().native();

        _isCmd = til::equals_insensitive_ascii(clientName, L""cmd.exe"");

        // For powershell, we need both Windows Powershell (powershell.exe) and
        // Powershell Core (pwsh.exe). If Powershell Core is ever updated to use
        // ^[[3J for Clear-Host, then it won't ever hit the shim code path, but
        // we're keeping this for the long tail of pwsh versions that still
        // _don't_ use that sequence.
        const auto isInboxPowershell = til::equals_insensitive_ascii(clientName, L""powershell.exe"");
        const auto isPwsh = til::equals_insensitive_ascii(clientName, L""pwsh.exe"");
        _isPowershell = isInboxPowershell || isPwsh;

        // Inside Windows, we are guaranteed that we're building alongside a new (good) inbox Powershell.
        // Therefore, we can default _...",5,<empty>,,15,1,CPPASTProblemStatement,,<empty>
536814,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT SetServerInformation(_In_ CD_IO_SERVER_INFORMATION* const pServerInfo) const = 0;,5,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
536815,UNKNOWN,-1,,"[[nodiscard]] virtual HRESULT ReadIo(_In_opt_ PCONSOLE_API_MSG const pReplyMsg,
                                         _Out_ CONSOLE_API_MSG* const pMessage) const = 0;",5,<empty>,,27,3,CPPASTProblemDeclaration,,<empty>
536816,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT CompleteIo(_In_ CD_IO_COMPLETE* const pCompletion) const = 0;,5,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
536817,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT ReadInput(_In_ CD_IO_OPERATION* const pIoOperation) const = 0;,5,<empty>,,31,5,CPPASTProblemDeclaration,,<empty>
536818,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT WriteOutput(_In_ CD_IO_OPERATION* const pIoOperation) const = 0;,5,<empty>,,32,6,CPPASTProblemDeclaration,,<empty>
536833,UNKNOWN,-1,,[[nodiscard]] virtual HRESULT GetServerHandle(_Out_ HANDLE* pHandle) const = 0;,5,<empty>,,39,10,CPPASTProblemDeclaration,,<empty>
536845,UNKNOWN,1,,"[[nodiscard]] NTSTATUS
DeviceHandle::CreateClientHandle(
    _Out_ PHANDLE Handle,
    _In_ HANDLE ServerHandle,
    _In_ PCWSTR Name,
    _In_ BOOLEAN Inheritable)
{
    return _CreateHandle(Handle,
                         Name,
                         GENERIC_WRITE | GENERIC_READ | SYNCHRONIZE,
                         ServerHandle,
                         Inheritable,
                         FILE_SYNCHRONOUS_IO_NONALERT);
}",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
536846,UNKNOWN,2,,"[[nodiscard]] NTSTATUS
DeviceHandle::CreateServerHandle(
    _Out_ PHANDLE Handle,
    _In_ BOOLEAN Inheritable)
{
    return _CreateHandle(Handle,
                         L""\\Device\\ConDrv\\Server"",
                         GENERIC_ALL,
                         nullptr,
                         Inheritable,
                         0);
}",1,<empty>,,53,2,CPPASTProblemDeclaration,,<empty>
536847,UNKNOWN,3,,"[[nodiscard]] NTSTATUS
DeviceHandle::_CreateHandle(
    _Out_ PHANDLE Handle,
    _In_ PCWSTR DeviceName,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ HANDLE Parent,
    _In_ BOOLEAN Inheritable,
    _In_ ULONG OpenOptions)

{
    ULONG Flags = OBJ_CASE_INSENSITIVE;

    if (Inheritable)
    {
        WI_SetFlag(Flags, OBJ_INHERIT);
    }

    UNICODE_STRING Name;
#pragma warning(suppress : 26492) // const_cast is prohibited, but we can't avoid it for filling UNICODE_STRING.
    Name.Buffer = const_cast<wchar_t*>(DeviceName);
    Name.Length = gsl::narrow_cast<USHORT>((wcslen(DeviceName) * sizeof(wchar_t)));
    Name.MaximumLength = Name.Length + sizeof(wchar_t);

    OBJECT_ATTRIBUTES ObjectAttributes;
#pragma warning(suppress : 26477) // The QOS part of this macro in the define is 0. Can't fix that.
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               Flags,
                               Parent,
               ...",1,<empty>,,83,3,CPPASTProblemDeclaration,,<empty>
536854,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS
    CreateServerHandle(
        _Out_ PHANDLE Handle,
        _In_ BOOLEAN Inheritable);",5,<empty>,,20,1,CPPASTProblemDeclaration,,<empty>
536855,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS
    CreateClientHandle(
        _Out_ PHANDLE Handle,
        _In_ HANDLE ServerHandle,
        _In_ PCWSTR Name,
        _In_ BOOLEAN Inheritable);",5,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
536856,UNKNOWN,-1,,"[[nodiscard]] NTSTATUS
    _CreateHandle(
        _Out_ PHANDLE Handle,
        _In_ PCWSTR DeviceName,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ HANDLE Parent,
        _In_ BOOLEAN Inheritable,
        _In_ ULONG OpenOptions);",5,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
536882,UNKNOWN,2,,"[[nodiscard]] HRESULT Entrypoints::StartConsoleForCmdLine(_In_ PCWSTR pwszCmdLine,
                                                          const ConsoleArguments* const args)
{
    // Create a scope because we're going to exit thread if everything goes well.
    // This scope will ensure all C++ objects and smart pointers get a chance to destruct before ExitThread is called.
    {
        // TODO:MSFT:13271366 use the arguments from the commandline to determine if we need
        //  to create the server handle or not.

        // Create the server and reference handles and create the console object.
        wil::unique_handle ServerHandle;
        RETURN_IF_NTSTATUS_FAILED(DeviceHandle::CreateServerHandle(ServerHandle.addressof(), FALSE));

        wil::unique_handle ReferenceHandle;
        RETURN_IF_NTSTATUS_FAILED(DeviceHandle::CreateClientHandle(ReferenceHandle.addressof(),
                                                                   ServerHandle.get(),
                ...",1,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
536896,UNKNOWN,-1,,"[[nodiscard]] HRESULT StartConsoleForCmdLine(_In_ PCWSTR pwszCmdLine, const ConsoleArguments* const args);",5,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
537511,UNKNOWN,-1,,"virtual bool Notify(const WaitTerminationReason TerminationReason,
                        const bool fIsUnicode,
                        _Out_ NTSTATUS* const pReplyStatus,
                        _Out_ size_t* const pNumBytes,
                        _Out_ DWORD* const pControlKeyState,
                        _Out_ void* const pOutputData) = 0;",5,<empty>,,47,8,CPPASTProblemDeclaration,,<empty>
537550,UNKNOWN,1,,"PCONSOLE_API_MSG IoDispatchers::ConsoleCreateObject(_In_ PCONSOLE_API_MSG pMessage)
{
    NTSTATUS Status;

    auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();
    const auto CreateInformation = &pMessage->CreateObject;

    LockConsole();

    // If a generic object was requested, use the desired access to determine which type of object the caller is expecting.
    if (CreateInformation->ObjectType == CD_IO_OBJECT_TYPE_GENERIC)
    {
        if ((CreateInformation->DesiredAccess & (GENERIC_READ | GENERIC_WRITE)) == GENERIC_READ)
        {
            CreateInformation->ObjectType = CD_IO_OBJECT_TYPE_CURRENT_INPUT;
        }
        else if ((CreateInformation->DesiredAccess & (GENERIC_READ | GENERIC_WRITE)) == GENERIC_WRITE)
        {
            CreateInformation->ObjectType = CD_IO_OBJECT_TYPE_CURRENT_OUTPUT;
        }
    }

    std::unique_ptr<ConsoleHandleData> handle;
    // Check the requested type.
    switch (CreateInformation->ObjectType)
    {
    ca...",1,<empty>,,43,1,CPPASTProblemDeclaration,,<empty>
537551,UNKNOWN,2,,"PCONSOLE_API_MSG IoDispatchers::ConsoleCloseObject(_In_ PCONSOLE_API_MSG pMessage)
{
    LockConsole();

    delete pMessage->GetObjectHandle();
    pMessage->SetReplyStatus(STATUS_SUCCESS);

    UnlockConsole();
    return pMessage;
}",1,<empty>,,123,2,CPPASTProblemDeclaration,,<empty>
537964,UNKNOWN,6,,"PCONSOLE_API_MSG IoDispatchers::ConsoleHandleConnectionRequest(_In_ PCONSOLE_API_MSG pReceiveMsg)
{
    auto& Globals = ServiceLocator::LocateGlobals();
    auto& gci = Globals.getConsoleInformation();
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::AttachConsole);

    ConsoleProcessHandle* ProcessData = nullptr;
    NTSTATUS Status;

    LockConsole();

    const auto cleanup = wil::scope_exit([&]() noexcept {
        if (FAILED_NTSTATUS(Status))
        {
            pReceiveMsg->SetReplyStatus(Status);
            if (ProcessData != nullptr)
            {
                CommandHistory::s_Free(ProcessData);
                gci.ProcessHandleList.FreeProcessData(ProcessData);
            }
        }

        // FreeProcessData() above requires the console to be locked.
        UnlockConsole();
    });

    const auto dwProcessId = (DWORD)pReceiveMsg->Descriptor.Process;
    const auto dwThreadId = (DWORD)pReceiveMsg->Descriptor.Object;

    CONSOLE_API_CONNECTINFO Cac;
  ...",1,<empty>,,412,6,CPPASTProblemDeclaration,,<empty>
537965,UNKNOWN,7,,"PCONSOLE_API_MSG IoDispatchers::ConsoleClientDisconnectRoutine(_In_ PCONSOLE_API_MSG pMessage)
{
    Telemetry::Instance().LogApiCall(Telemetry::ApiCall::FreeConsole);

    const auto pProcessData = pMessage->GetProcessHandle();

    auto pNotifier = ServiceLocator::LocateAccessibilityNotifier();
    if (pNotifier)
    {
        pNotifier->NotifyConsoleEndApplicationEvent(pProcessData->dwProcessId);
    }

    Tracing::s_TraceConsoleAttachDetach(pProcessData, false);

    LOG_IF_FAILED(RemoveConsole(pProcessData));

    pMessage->SetReplyStatus(STATUS_SUCCESS);

    return pMessage;
}",1,<empty>,,563,7,CPPASTProblemDeclaration,,<empty>
537966,UNKNOWN,8,,"PCONSOLE_API_MSG IoDispatchers::ConsoleDispatchRequest(_In_ PCONSOLE_API_MSG pMessage)
{
    return ApiSorter::ConsoleDispatchRequest(pMessage);
}",1,<empty>,,590,8,CPPASTProblemDeclaration,,<empty>
537975,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleHandleConnectionRequest(_In_ PCONSOLE_API_MSG pReceiveMsg);,5,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
537976,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleDispatchRequest(_In_ PCONSOLE_API_MSG pMessage);,5,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
537977,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleCreateObject(_In_ PCONSOLE_API_MSG pMessage);,5,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
537978,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleCloseObject(_In_ PCONSOLE_API_MSG pMessage);,5,<empty>,,29,4,CPPASTProblemDeclaration,,<empty>
537979,UNKNOWN,-1,,static PCONSOLE_API_MSG ConsoleClientDisconnectRoutine(_In_ PCONSOLE_API_MSG pMessage);,5,<empty>,,30,5,CPPASTProblemDeclaration,,<empty>
538001,UNKNOWN,1,,"void IoSorter::ServiceIoOperation(_In_ CONSOLE_API_MSG* const pMsg,
                                  _Out_ CONSOLE_API_MSG** ReplyMsg)
{
    NTSTATUS Status;
    HRESULT hr;
    auto ReplyPending = FALSE;

    ZeroMemory(&pMsg->State, sizeof(pMsg->State));
    ZeroMemory(&pMsg->Complete, sizeof(CD_IO_COMPLETE));

    pMsg->Complete.Identifier = pMsg->Descriptor.Identifier;

    switch (pMsg->Descriptor.Function)
    {
    case CONSOLE_IO_USER_DEFINED:
        *ReplyMsg = IoDispatchers::ConsoleDispatchRequest(pMsg);
        break;

    case CONSOLE_IO_CONNECT:
        *ReplyMsg = IoDispatchers::ConsoleHandleConnectionRequest(pMsg);
        break;

    case CONSOLE_IO_DISCONNECT:
        *ReplyMsg = IoDispatchers::ConsoleClientDisconnectRoutine(pMsg);
        break;

    case CONSOLE_IO_CREATE_OBJECT:
        *ReplyMsg = IoDispatchers::ConsoleCreateObject(pMsg);
        break;

    case CONSOLE_IO_CLOSE_OBJECT:
        *ReplyMsg = IoDispatchers::ConsoleCloseObject(pMsg);
        brea...",1,<empty>,,18,1,CPPASTProblemDeclaration,,<empty>
538010,UNKNOWN,-1,,"static void ServiceIoOperation(_In_ CONSOLE_API_MSG* const pMsg,
                                   _Out_ CONSOLE_API_MSG** ReplyMsg);",5,<empty>,,26,1,CPPASTProblemDeclaration,,<empty>
538017,UNKNOWN,2,,"[[nodiscard]] HRESULT ConsoleCreateIoThreadLegacy(_In_ HANDLE Server, const ConsoleArguments* const args);",1,<empty>,,8,2,CPPASTProblemDeclaration,,<empty>
538146,UNKNOWN,10,,"[[nodiscard]] HRESULT ConsoleHandleData::GetInputBuffer(const ACCESS_MASK amRequested,
                                                        _Outptr_ InputBuffer** const ppInputBuffer) const
{
    *ppInputBuffer = nullptr;

    RETURN_HR_IF(E_ACCESSDENIED, WI_IsAnyFlagClear(_amAccess, amRequested));
    RETURN_HR_IF(E_HANDLE, WI_IsAnyFlagClear(_ulHandleType, HandleType::Input));

    *ppInputBuffer = static_cast<InputBuffer*>(_pvClientPointer);

    return S_OK;
}",1,<empty>,,144,10,CPPASTProblemDeclaration,,<empty>
538147,UNKNOWN,11,,"[[nodiscard]] HRESULT ConsoleHandleData::GetScreenBuffer(const ACCESS_MASK amRequested,
                                                         _Outptr_ SCREEN_INFORMATION** const ppScreenInfo) const
{
    *ppScreenInfo = nullptr;

    RETURN_HR_IF(E_ACCESSDENIED, WI_IsAnyFlagClear(_amAccess, amRequested));
    RETURN_HR_IF(E_HANDLE, WI_IsAnyFlagClear(_ulHandleType, HandleType::Output));

    *ppScreenInfo = static_cast<SCREEN_INFORMATION*>(_pvClientPointer);

    return S_OK;
}",1,<empty>,,164,11,CPPASTProblemDeclaration,,<empty>
538148,UNKNOWN,12,,"[[nodiscard]] HRESULT ConsoleHandleData::GetWaitQueue(_Outptr_ ConsoleWaitQueue** const ppWaitQueue) const
{
    auto& gci = Microsoft::Console::Interactivity::ServiceLocator::LocateGlobals().getConsoleInformation();
    if (_IsInput())
    {
        const auto pObj = static_cast<InputBuffer*>(_pvClientPointer);
        *ppWaitQueue = &pObj->WaitQueue;
        return S_OK;
    }
    else if (_IsOutput())
    {
        // TODO MSFT 9405322: shouldn't the output queue be per output object target, not global? https://osgvsowi/9405322
        *ppWaitQueue = &gci.OutputQueue;
        return S_OK;
    }
    else
    {
        return E_UNEXPECTED;
    }
}",1,<empty>,,183,12,CPPASTProblemDeclaration,,<empty>
538167,UNKNOWN,1,,InputBuffer*,37,<empty>,,229,1,CPPASTTypeId,,<empty>
538232,UNKNOWN,1,,SCREEN_INFORMATION*,36,<empty>,,268,1,CPPASTTypeId,,<empty>
538310,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetInputBuffer(const ACCESS_MASK amRequested,
                                         _Outptr_ InputBuffer** const ppInputBuffer) const;",5,<empty>,,44,8,CPPASTProblemDeclaration,,<empty>
538311,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetScreenBuffer(const ACCESS_MASK amRequested,
                                          _Outptr_ SCREEN_INFORMATION** const ppScreenInfo) const;",5,<empty>,,46,9,CPPASTProblemDeclaration,,<empty>
538312,UNKNOWN,-1,,[[nodiscard]] HRESULT GetWaitQueue(_Outptr_ ConsoleWaitQueue** const ppWaitQueue) const;,5,<empty>,,49,10,CPPASTProblemDeclaration,,<empty>
538401,UNKNOWN,-1,,"try
    {
        // Allocate all necessary state.
        auto pHandleData = std::make_unique<ConsoleHandleData>(amDesired,
                                                               ulShareMode);

        // Check the share mode.
        if (((pHandleData->IsReadAllowed()) && (_ulOpenCount > _ulReadShareCount)) ||
            ((!pHandleData->IsReadShared()) && (_ulReaderCount > 0)) ||
            ((pHandleData->IsWriteAllowed()) && (_ulOpenCount > _ulWriteShareCount)) ||
            ((!pHandleData->IsWriteShared()) && (_ulWriterCount > 0)))
        {
            return HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
        }

        // Update share/open counts and store handle information.
        _ulOpenCount++;

        if (pHandleData->IsReadAllowed())
        {
            _ulReaderCount++;
        }

        if (pHandleData->IsReadShared())
        {
            _ulReadShareCount++;
        }

        if (pHandleData->IsWriteAllowed())
        {
            _ulWriterCount+...",5,<empty>,,39,1,CPPASTProblemStatement,,<empty>
538406,UNKNOWN,3,,"[[nodiscard]] HRESULT ConsoleObjectHeader::FreeIoHandle(_In_ ConsoleHandleData* const pFree)
{
    // This absolutely should not happen and our state is corrupt/bad if we try to release past 0.
    THROW_HR_IF(E_NOT_VALID_STATE, !(_ulOpenCount > 0));

    _ulOpenCount--;

    if (pFree->IsReadAllowed())
    {
        _ulReaderCount--;
    }

    if (pFree->IsReadShared())
    {
        _ulReadShareCount--;
    }

    if (pFree->IsWriteAllowed())
    {
        _ulWriterCount--;
    }

    if (pFree->IsWriteShared())
    {
        _ulWriteShareCount--;
    }

    return S_OK;
}",1,<empty>,,94,3,CPPASTProblemDeclaration,,<empty>
538453,UNKNOWN,-1,,[[nodiscard]] HRESULT FreeIoHandle(_In_ ConsoleHandleData* const pFree);,5,<empty>,,36,4,CPPASTProblemDeclaration,,<empty>
538713,UNKNOWN,1,,"[[nodiscard]] HRESULT ConsoleProcessList::AllocProcessData(const DWORD dwProcessId,
                                                           const DWORD dwThreadId,
                                                           const ULONG ulProcessGroupId,
                                                           _Outptr_opt_ ConsoleProcessHandle** const ppProcessData)
{
    assert(ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    if (FindProcessInList(dwProcessId))
    {
        return S_FALSE;
    }

    std::unique_ptr<ConsoleProcessHandle> pProcessData;
    try
    {
        pProcessData = std::make_unique<ConsoleProcessHandle>(dwProcessId, dwThreadId, ulProcessGroupId);
        _processes.emplace_back(pProcessData.get());
    }
    CATCH_RETURN();

    wil::assign_to_opt_param(ppProcessData, pProcessData.release());

    return S_OK;
}",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
538714,UNKNOWN,2,,"void ConsoleProcessList::FreeProcessData(_In_ ConsoleProcessHandle* const pProcessData)
{
    assert(ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    const auto it = std::ranges::find(_processes, pProcessData);
    if (it != _processes.end())
    {
        _processes.erase(it);
        delete pProcessData;
    }
    else
    {
        // The pointer not existing in the process list would be similar to a heap corruption,
        // as the only code allowed to allocate a `ConsoleProcessHandle` is us, in AllocProcessData().
        // An assertion here would indicate a double-free or similar.
        assert(false);
    }
}",1,<empty>,,58,2,CPPASTProblemDeclaration,,<empty>
538746,UNKNOWN,4,,"ConsoleProcessHandle* ConsoleProcessList::FindProcessByGroupId(_In_ ULONG ulProcessGroupId) const
{
    assert(ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    for (const auto& p : _processes)
    {
        if (p->_ulProcessGroupId == ulProcessGroupId)
        {
            return p;
        }
    }

    return nullptr;
}",1,<empty>,,104,4,CPPASTProblemDeclaration,,<empty>
538804,UNKNOWN,7,,"[[nodiscard]] HRESULT ConsoleProcessList::GetProcessList(_Inout_updates_(*pcProcessList) DWORD* pProcessList,
                                                         _Inout_ size_t* const pcProcessList) const
{
    assert(ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    if (*pcProcessList < _processes.size())
    {
        *pcProcessList = _processes.size();
        return E_NOT_SUFFICIENT_BUFFER;
    }

    // Some applications, when reading the process list through the GetConsoleProcessList API,
    // are expecting the returned list of attached process IDs to be from newest to oldest.
    // As such, we have to put the newest process into the head of the list.
    auto it = _processes.crbegin();
    const auto end = _processes.crend();

    for (; it != end; ++it)
    {
        *pProcessList++ = (*it)->dwProcessId;
    }

    *pcProcessList = _processes.size();
    return S_OK;
}",1,<empty>,,167,7,CPPASTProblemDeclaration,,<empty>
538805,UNKNOWN,8,,"[[nodiscard]] HRESULT ConsoleProcessList::GetTerminationRecordsByGroupId(const DWORD dwLimitingProcessId,
                                                                         const bool fCtrlClose,
                                                                         _Out_ std::vector<ConsoleProcessTerminationRecord>& termRecords) const
{
    assert(ServiceLocator::LocateGlobals().getConsoleInformation().IsConsoleLocked());

    try
    {
        termRecords.clear();

        // Dig through known processes looking for a match
        for (const auto& p : _processes)
        {
            // If no limit was specified OR if we have a match, generate a new termination record.
            if (!dwLimitingProcessId ||
                p->_ulProcessGroupId == dwLimitingProcessId)
            {
                // If we're hard closing the window, increment the counter.
                if (fCtrlClose)
                {
                    p->_ulTerminateCount++;
                }

    ...",1,<empty>,,204,8,CPPASTProblemDeclaration,,<empty>
538890,UNKNOWN,-1,,"[[nodiscard]] HRESULT AllocProcessData(const DWORD dwProcessId,
                                           const DWORD dwThreadId,
                                           const ULONG ulProcessGroupId,
                                           _Outptr_opt_ ConsoleProcessHandle** const ppProcessData);",5,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
538891,UNKNOWN,-1,,void FreeProcessData(_In_ ConsoleProcessHandle* const ProcessData);,5,<empty>,,42,2,CPPASTProblemDeclaration,,<empty>
538897,UNKNOWN,-1,,ConsoleProcessHandle* FindProcessByGroupId(_In_ ULONG ulProcessGroupId) const;,5,<empty>,,45,4,CPPASTProblemDeclaration,,<empty>
538913,UNKNOWN,-1,,"[[nodiscard]] HRESULT GetProcessList(_Inout_updates_(*pcProcessList) DWORD* const pProcessList,
                                         _Inout_ size_t* const pcProcessList) const;",5,<empty>,,53,8,CPPASTProblemDeclaration,,<empty>
539089,UNKNOWN,1,,"ConsoleWaitBlock::ConsoleWaitBlock(_In_ ConsoleWaitQueue* const pProcessQueue,
                                   _In_ ConsoleWaitQueue* const pObjectQueue,
                                   const CONSOLE_API_MSG* const pWaitReplyMessage,
                                   _In_ IWaitRoutine* const pWaiter) :
    _pProcessQueue(THROW_HR_IF_NULL(E_INVALIDARG, pProcessQueue)),
    _pObjectQueue(THROW_HR_IF_NULL(E_INVALIDARG, pObjectQueue)),
    _WaitReplyMessage(*pWaitReplyMessage),
    _pWaiter(THROW_HR_IF_NULL(E_INVALIDARG, pWaiter))
{
    // MSFT-33127449, GH#9692
    // Until there's a ""Wait"", there's only one API message inflight at a time. In our
    // quest for performance, we put that single API message in charge of its own
    // buffer management- instead of allocating buffers on the heap and deleting them
    // later (storing pointers to them at the far corners of the earth), it would
    // instead allocate them from small internal pools (if possible) and only heap
    /...",1,<empty>,,25,1,CPPASTProblemDeclaration,,<empty>
539110,UNKNOWN,3,,"[[nodiscard]] HRESULT ConsoleWaitBlock::s_CreateWait(_Inout_ CONSOLE_API_MSG* const pWaitReplyMessage,
                                                     _In_ IWaitRoutine* const pWaiter)
{
    const auto ProcessData = pWaitReplyMessage->GetProcessHandle();
    FAIL_FAST_IF_NULL(ProcessData);

    const auto pProcessQueue = ProcessData->pWaitBlockQueue.get();

    const auto pHandleData = pWaitReplyMessage->GetObjectHandle();
    FAIL_FAST_IF_NULL(pHandleData);

    ConsoleWaitQueue* pObjectQueue = nullptr;
    LOG_IF_FAILED(pHandleData->GetWaitQueue(&pObjectQueue));
    FAIL_FAST_IF_NULL(pObjectQueue);

    ConsoleWaitBlock* pWaitBlock;
    try
    {
        pWaitBlock = new ConsoleWaitBlock(pProcessQueue,
                                          pObjectQueue,
                                          pWaitReplyMessage,
                                          pWaiter);

        // Set the iterators on the wait block so that it can remove itself later.
        pWaitBlock->_itPr...",1,<empty>,,86,3,CPPASTProblemDeclaration,,<empty>
539283,UNKNOWN,1,,INPUT_RECORD* const,52,<empty>,,194,1,CPPASTTypeId,,<empty>
539290,UNKNOWN,1,,ULONG,41,<empty>,,195,1,CPPASTTypeId,,<empty>
539367,UNKNOWN,1,,PUCHAR,19,<empty>,,211,1,CPPASTTypeId,,<empty>
539488,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_CreateWait(_Inout_ CONSOLE_API_MSG* const pWaitReplymessage,
                                              _In_ IWaitRoutine* const pWaiter);",5,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
539489,UNKNOWN,-1,,"ConsoleWaitBlock(_In_ ConsoleWaitQueue* const pProcessQueue,
                     _In_ ConsoleWaitQueue* const pObjectQueue,
                     const CONSOLE_API_MSG* const pWaitReplyMessage,
                     _In_ IWaitRoutine* const pWaiter);",5,<empty>,,39,4,CPPASTProblemDeclaration,,<empty>
539524,UNKNOWN,3,,"[[nodiscard]] HRESULT ConsoleWaitQueue::s_CreateWait(_Inout_ CONSOLE_API_MSG* const pWaitReplyMessage,
                                                     _In_ IWaitRoutine* const pWaiter)
{
    // Normally we'd have the Wait Queue handle the insertion of the block into the queue, but
    // the console does queues in a somewhat special way.
    //
    // Each block belongs in two queues:
    // 1. The process queue of the client that dispatched the request
    // 2. The object queue that the request will be serviced by
    // As such, when a wait occurs, it gets added to both queues.
    //
    // It will end up being serviced by one or the other queue, but when it is serviced, it must be
    // removed from both so it is not double processed.
    //
    // Therefore, I've inverted the queue management responsibility into the WaitBlock itself
    // and made it a friend to this WaitQueue class.

    return ConsoleWaitBlock::s_CreateWait(pWaitReplyMessage,
                         ...",1,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
539604,UNKNOWN,6,,"bool ConsoleWaitQueue::_NotifyBlock(_In_ ConsoleWaitBlock* pWaitBlock,
                                    _In_ WaitTerminationReason TerminationReason)
{
    // Attempt to notify block with the given reason.
    const auto fResult = pWaitBlock->Notify(TerminationReason);

    if (fResult)
    {
        // If it was successful, delete it. (It will remove itself from appropriate queues.)
        delete pWaitBlock;
    }

    return fResult;
}",1,<empty>,,113,6,CPPASTProblemDeclaration,,<empty>
539640,UNKNOWN,-1,,"[[nodiscard]] static HRESULT s_CreateWait(_Inout_ CONSOLE_API_MSG* const pWaitReplyMessage,
                                              _In_ IWaitRoutine* const pWaiter);",5,<empty>,,40,5,CPPASTProblemDeclaration,,<empty>
539641,UNKNOWN,-1,,"bool _NotifyBlock(_In_ ConsoleWaitBlock* pWaitBlock,
                      const WaitTerminationReason TerminationReason);",5,<empty>,,44,6,CPPASTProblemDeclaration,,<empty>
539695,UNKNOWN,3,,"[[nodiscard]] NTSTATUS WinNTControl::NtOpenFile(_Out_ PHANDLE FileHandle,
                                                _In_ ACCESS_MASK DesiredAccess,
                                                _In_ POBJECT_ATTRIBUTES ObjectAttributes,
                                                _Out_ PIO_STATUS_BLOCK IoStatusBlock,
                                                _In_ ULONG ShareAccess,
                                                _In_ ULONG OpenOptions)
{
    try
    {
        return GetInstance()._NtOpenFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);
    }
    CATCH_RETURN();
}",1,<empty>,,39,3,CPPASTProblemDeclaration,,<empty>
539702,UNKNOWN,-1,,"[[nodiscard]] static NTSTATUS NtOpenFile(_Out_ PHANDLE FileHandle,
                                             _In_ ACCESS_MASK DesiredAccess,
                                             _In_ POBJECT_ATTRIBUTES ObjectAttributes,
                                             _Out_ PIO_STATUS_BLOCK IoStatusBlock,
                                             _In_ ULONG ShareAccess,
                                             _In_ ULONG OpenOptions);",5,<empty>,,22,1,CPPASTProblemDeclaration,,<empty>
539722,UNKNOWN,-1,,"typedef NTSTATUS(NTAPI* PfnNtOpenFile)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);",5,<empty>,,39,7,CPPASTProblemDeclaration,,<empty>
539936,UNKNOWN,1,,uint64_t,48,<empty>,,92,1,CPPASTTypeId,,<empty>
539952,UNKNOWN,1,,uint64_t,50,<empty>,,99,1,CPPASTTypeId,,<empty>
540009,UNKNOWN,1,,T,32,<empty>,,141,1,CPPASTTypeId,,<empty>
540362,UNKNOWN,1,,T,32,<empty>,,342,1,CPPASTTypeId,,<empty>
541623,UNKNOWN,1,,VTInt,42,<empty>,,133,1,CPPASTTypeId,,<empty>
545627,UNKNOWN,1,,Field,43,<empty>,,4587,1,CPPASTTypeId,,<empty>
545927,UNKNOWN,1,,Field,43,<empty>,,4646,1,CPPASTTypeId,,<empty>
546019,UNKNOWN,1,,Field,43,<empty>,,4668,1,CPPASTTypeId,,<empty>
546091,UNKNOWN,1,,size_t,54,<empty>,,4737,1,CPPASTTypeId,,<empty>
546400,UNKNOWN,-1,,e,17,<empty>,,95,18,CPPASTProblemStatement,,<empty>
549594,UNKNOWN,1,,CharacterAttributes,63,<empty>,,1193,1,CPPASTTypeId,,<empty>
555433,UNKNOWN,1,,DispatchTypes::TaskbarState,45,<empty>,,3611,1,CPPASTTypeId,,<empty>
556557,UNKNOWN,1,,DispatchTypes::ColorItem,25,<empty>,,4370,1,CPPASTTypeId,,<empty>
563931,UNKNOWN,1,,std::wstring_view,47,<empty>,,291,1,CPPASTTypeId,,<empty>
563934,UNKNOWN,1,,std::wstring_view,74,<empty>,,291,1,CPPASTTypeId,,<empty>
563971,UNKNOWN,-1,,"class TerminalOutput sealed
    {
    public:
        TerminalOutput() noexcept;

        wchar_t TranslateKey(const wchar_t wch) const noexcept;
        bool Designate94Charset(const size_t gsetNumber, const VTID charset);
        bool Designate96Charset(const size_t gsetNumber, const VTID charset);
        void SetDrcs94Designation(const VTID charset);
        void SetDrcs96Designation(const VTID charset);
        VTID GetCharsetId(const size_t gsetNumber) const;
        size_t GetCharsetSize(const size_t gsetNumber) const;
        bool LockingShift(const size_t gsetNumber);
        bool LockingShiftRight(const size_t gsetNumber);
        bool SingleShift(const size_t gsetNumber) noexcept;
        size_t GetLeftSetNumber() const noexcept;
        size_t GetRightSetNumber() const noexcept;
        bool IsSingleShiftPending(const size_t gsetNumber) const noexcept;
        bool NeedToTranslate() const noexcept;
        void EnableGrTranslation(boolean enabled);

    private:
        ...",5,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
564087,UNKNOWN,-1,,),38,<empty>,,316,2,CPPASTProblemStatement,,<empty>
564091,UNKNOWN,-1,,),103,<empty>,,318,4,CPPASTProblemStatement,,<empty>
564095,UNKNOWN,-1,,),105,<empty>,,320,6,CPPASTProblemStatement,,<empty>
564097,UNKNOWN,-1,,),36,<empty>,,321,8,CPPASTProblemStatement,,<empty>
564119,UNKNOWN,1,,SHORT,35,<empty>,,329,1,CPPASTTypeId,,<empty>
564386,UNKNOWN,11,,"TEST_METHOD(SgrModeTests)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            // TEST_METHOD_PROPERTY(L""Data:uiButton"", L""{WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MBUTTONDOWN, WM_MBUTTONUP, WM_RBUTTONDOWN, WM_RBUTTONUP, WM_MOUSEMOVE}"")
            TEST_METHOD_PROPERTY(L""Data:uiButton"", L""{0x0201, 0x0202, 0x0207, 0x0208, 0x0204, 0x0205, 0x0200}"")
            // None, SHIFT, LEFT_CONTROL, RIGHT_ALT, RIGHT_ALT | LEFT_CONTROL
            TEST_METHOD_PROPERTY(L""Data:uiModifierKeystate"", L""{0x0000, 0x0010, 0x0008, 0x0001, 0x0009}"")
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,405,11,CPPASTProblemDeclaration,,<empty>
564392,UNKNOWN,15,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiModifierKeystate"", uiModifierKeystate));",9,<empty>,,418,15,CPPASTProblemDeclaration,,<empty>
564397,UNKNOWN,1,,SHORT,35,<empty>,,419,1,CPPASTTypeId,,<empty>
564404,UNKNOWN,21,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiButton"", uiButton));",9,<empty>,,423,21,CPPASTProblemDeclaration,,<empty>
564405,UNKNOWN,22,,"VERIFY_ARE_EQUAL(TerminalInput::MakeUnhandled(), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,425,22,CPPASTProblemDeclaration,,<empty>
564406,UNKNOWN,23,,", uiButton, sModifierKeystate, sScrollDelta, {}",89,<empty>,,425,23,CPPASTProblemDeclaration,,<empty>
564407,UNKNOWN,24,,));,136,<empty>,,425,24,CPPASTProblemDeclaration,,<empty>
564408,UNKNOWN,25,,"mouseInput.SetInputMode(TerminalInput::Mode::SgrMouseEncoding, true);",9,<empty>,,427,25,CPPASTProblemDeclaration,,<empty>
564409,UNKNOWN,26,,"mouseInput.SetInputMode(TerminalInput::Mode::DefaultMouseTracking, true);",9,<empty>,,429,26,CPPASTProblemDeclaration,,<empty>
564410,UNKNOWN,27,,for (auto i = 0;,9,<empty>,,430,27,CPPASTProblemDeclaration,,<empty>
564411,UNKNOWN,28,,i < s_iTestCoordsLength;,26,<empty>,,430,28,CPPASTProblemDeclaration,,<empty>
564412,UNKNOWN,29,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];

            // SGR Mode should be able to handle any arbitrary coords.
            // However, mouse moves are only handled in Any Event mode
            TerminalInput::OutputType expected;
            if (uiButton != WM_MOUSEMOVE)
            {
                expected = BuildSGRTestOutput(s_rgSgrTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);
            }

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord, uiButton, sModifierKeystate, sScrollDelta, {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,430,29,CPPASTProblemDeclaration,,<empty>
564413,UNKNOWN,30,,"mouseInput.SetInputMode(TerminalInput::Mode::ButtonEventMouseTracking, true);",9,<empty>,,448,30,CPPASTProblemDeclaration,,<empty>
564414,UNKNOWN,31,,for (auto i = 0;,9,<empty>,,449,31,CPPASTProblemDeclaration,,<empty>
564415,UNKNOWN,32,,i < s_iTestCoordsLength;,26,<empty>,,449,32,CPPASTProblemDeclaration,,<empty>
564416,UNKNOWN,33,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];

            // SGR Mode should be able to handle any arbitrary coords.
            // However, mouse moves are only handled in Any Event mode
            TerminalInput::OutputType expected;
            if (uiButton != WM_MOUSEMOVE)
            {
                expected = BuildSGRTestOutput(s_rgSgrTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);
            }

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord,
                                                    uiButton,
                                                    sModifierKeystate,
                                                    sScrollDelta,
                                                    {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,449,33,CPPASTProblemDeclaration,,<empty>
564417,UNKNOWN,34,,"mouseInput.SetInputMode(TerminalInput::Mode::AnyEventMouseTracking, true);",9,<empty>,,471,34,CPPASTProblemDeclaration,,<empty>
564418,UNKNOWN,35,,for (auto i = 0;,9,<empty>,,472,35,CPPASTProblemDeclaration,,<empty>
564419,UNKNOWN,36,,i < s_iTestCoordsLength;,26,<empty>,,472,36,CPPASTProblemDeclaration,,<empty>
564420,UNKNOWN,37,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];
            const auto expected = BuildSGRTestOutput(s_rgSgrTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord,
                                                    uiButton,
                                                    sModifierKeystate,
                                                    sScrollDelta,
                                                    {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,472,37,CPPASTProblemDeclaration,,<empty>
564421,UNKNOWN,38,,},5,<empty>,,486,38,CPPASTProblemDeclaration,,<empty>
564422,UNKNOWN,39,,"TEST_METHOD(ScrollWheelTests)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:sScrollDelta"", L""{-120, 120, -10000, 32736}"")
            // None, SHIFT, LEFT_CONTROL, RIGHT_ALT, RIGHT_ALT | LEFT_CONTROL
            TEST_METHOD_PROPERTY(L""Data:uiModifierKeystate"", L""{0x0000, 0x0010, 0x0008, 0x0001, 0x0009}"")
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,488,39,CPPASTProblemDeclaration,,<empty>
564428,UNKNOWN,43,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiModifierKeystate"", uiModifierKeystate));",9,<empty>,,500,43,CPPASTProblemDeclaration,,<empty>
564433,UNKNOWN,1,,SHORT,35,<empty>,,501,1,CPPASTTypeId,,<empty>
564443,UNKNOWN,50,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""sScrollDelta"", iScrollDelta));",9,<empty>,,505,50,CPPASTProblemDeclaration,,<empty>
564448,UNKNOWN,1,,short,30,<empty>,,506,1,CPPASTTypeId,,<empty>
564450,UNKNOWN,53,,"VERIFY_ARE_EQUAL(TerminalInput::MakeUnhandled(), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,508,53,CPPASTProblemDeclaration,,<empty>
564451,UNKNOWN,54,,", uiButton, sModifierKeystate, sScrollDelta, {}",89,<empty>,,508,54,CPPASTProblemDeclaration,,<empty>
564452,UNKNOWN,55,,));,136,<empty>,,508,55,CPPASTProblemDeclaration,,<empty>
564453,UNKNOWN,56,,"mouseInput.SetInputMode(TerminalInput::Mode::DefaultMouseTracking, true);",9,<empty>,,511,56,CPPASTProblemDeclaration,,<empty>
564454,UNKNOWN,57,,for (auto i = 0;,9,<empty>,,513,57,CPPASTProblemDeclaration,,<empty>
564455,UNKNOWN,58,,i < s_iTestCoordsLength;,26,<empty>,,513,58,CPPASTProblemDeclaration,,<empty>
564456,UNKNOWN,59,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];

            TerminalInput::OutputType expected;
            if (Coord.x <= 94 && Coord.y <= 94)
            {
                expected = BuildDefaultTestOutput(s_rgDefaultTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);
            }

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord,
                                                    uiButton,
                                                    sModifierKeystate,
                                                    sScrollDelta,
                                                    {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,513,59,CPPASTProblemDeclaration,,<empty>
564457,UNKNOWN,60,,"mouseInput.SetInputMode(TerminalInput::Mode::Utf8MouseEncoding, true);",9,<empty>,,534,60,CPPASTProblemDeclaration,,<empty>
564464,UNKNOWN,63,,for (auto i = 0;,9,<empty>,,536,63,CPPASTProblemDeclaration,,<empty>
564465,UNKNOWN,64,,i < s_iTestCoordsLength;,26,<empty>,,536,64,CPPASTProblemDeclaration,,<empty>
564466,UNKNOWN,65,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];

            TerminalInput::OutputType expected;
            if (Coord.x <= MaxCoord && Coord.y <= MaxCoord)
            {
                expected = BuildDefaultTestOutput(s_rgDefaultTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);
            }

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord,
                                                    uiButton,
                                                    sModifierKeystate,
                                                    sScrollDelta,
                                                    {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,536,65,CPPASTProblemDeclaration,,<empty>
564467,UNKNOWN,66,,"mouseInput.SetInputMode(TerminalInput::Mode::SgrMouseEncoding, true);",9,<empty>,,557,66,CPPASTProblemDeclaration,,<empty>
564468,UNKNOWN,67,,for (auto i = 0;,9,<empty>,,558,67,CPPASTProblemDeclaration,,<empty>
564469,UNKNOWN,68,,i < s_iTestCoordsLength;,26,<empty>,,558,68,CPPASTProblemDeclaration,,<empty>
564470,UNKNOWN,69,,"i++)
        {
            const auto Coord = s_rgTestCoords[i];
            const auto expected = BuildSGRTestOutput(s_rgSgrTestOutput[i], uiButton, sModifierKeystate, sScrollDelta);

            // validate translation
            VERIFY_ARE_EQUAL(expected,
                             mouseInput.HandleMouse(Coord,
                                                    uiButton,
                                                    sModifierKeystate,
                                                    sScrollDelta,
                                                    {}),
                             NoThrowString().Format(L""(x,y)=(%d,%d)"", Coord.x, Coord.y));
        }",51,<empty>,,558,69,CPPASTProblemDeclaration,,<empty>
564471,UNKNOWN,70,,},5,<empty>,,572,70,CPPASTProblemDeclaration,,<empty>
564472,UNKNOWN,71,,"TEST_METHOD(AlternateScrollModeTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,574,71,CPPASTProblemDeclaration,,<empty>
564478,UNKNOWN,75,,"Log::Comment(L""Enable alternate scroll mode in the alt screen buffer"");",9,<empty>,,580,75,CPPASTProblemDeclaration,,<empty>
564479,UNKNOWN,76,,mouseInput.UseAlternateScreenBuffer();,9,<empty>,,581,76,CPPASTProblemDeclaration,,<empty>
564480,UNKNOWN,77,,"mouseInput.SetInputMode(TerminalInput::Mode::AlternateScroll, true);",9,<empty>,,582,77,CPPASTProblemDeclaration,,<empty>
564481,UNKNOWN,78,,"Log::Comment(L""Test mouse wheel scrolling up"");",9,<empty>,,584,78,CPPASTProblemDeclaration,,<empty>
564482,UNKNOWN,79,,"VERIFY_ARE_EQUAL(TerminalInput::MakeOutput(L""\x1B[A""), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,585,79,CPPASTProblemDeclaration,,<empty>
564483,UNKNOWN,80,,", WM_MOUSEWHEEL, noModifierKeys, WHEEL_DELTA, {}",95,<empty>,,585,80,CPPASTProblemDeclaration,,<empty>
564484,UNKNOWN,81,,));,143,<empty>,,585,81,CPPASTProblemDeclaration,,<empty>
564485,UNKNOWN,82,,"Log::Comment(L""Test mouse wheel scrolling down"");",9,<empty>,,587,82,CPPASTProblemDeclaration,,<empty>
564486,UNKNOWN,83,,"VERIFY_ARE_EQUAL(TerminalInput::MakeOutput(L""\x1B[B""), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,588,83,CPPASTProblemDeclaration,,<empty>
564487,UNKNOWN,84,,", WM_MOUSEWHEEL, noModifierKeys, -WHEEL_DELTA, {}",95,<empty>,,588,84,CPPASTProblemDeclaration,,<empty>
564488,UNKNOWN,85,,));,144,<empty>,,588,85,CPPASTProblemDeclaration,,<empty>
564489,UNKNOWN,86,,"Log::Comment(L""Enable cursor keys mode"");",9,<empty>,,590,86,CPPASTProblemDeclaration,,<empty>
564490,UNKNOWN,87,,"mouseInput.SetInputMode(TerminalInput::Mode::CursorKey, true);",9,<empty>,,591,87,CPPASTProblemDeclaration,,<empty>
564491,UNKNOWN,88,,"Log::Comment(L""Test mouse wheel scrolling up"");",9,<empty>,,593,88,CPPASTProblemDeclaration,,<empty>
564492,UNKNOWN,89,,"VERIFY_ARE_EQUAL(TerminalInput::MakeOutput(L""\x1BOA""), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,594,89,CPPASTProblemDeclaration,,<empty>
564493,UNKNOWN,90,,", WM_MOUSEWHEEL, noModifierKeys, WHEEL_DELTA, {}",95,<empty>,,594,90,CPPASTProblemDeclaration,,<empty>
564494,UNKNOWN,91,,));,143,<empty>,,594,91,CPPASTProblemDeclaration,,<empty>
564495,UNKNOWN,92,,"Log::Comment(L""Test mouse wheel scrolling down"");",9,<empty>,,596,92,CPPASTProblemDeclaration,,<empty>
564496,UNKNOWN,93,,"VERIFY_ARE_EQUAL(TerminalInput::MakeOutput(L""\x1BOB""), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,597,93,CPPASTProblemDeclaration,,<empty>
564497,UNKNOWN,94,,", WM_MOUSEWHEEL, noModifierKeys, -WHEEL_DELTA, {}",95,<empty>,,597,94,CPPASTProblemDeclaration,,<empty>
564498,UNKNOWN,95,,));,144,<empty>,,597,95,CPPASTProblemDeclaration,,<empty>
564499,UNKNOWN,96,,"Log::Comment(L""Confirm no effect when scroll mode is disabled"");",9,<empty>,,599,96,CPPASTProblemDeclaration,,<empty>
564500,UNKNOWN,97,,mouseInput.UseAlternateScreenBuffer();,9,<empty>,,600,97,CPPASTProblemDeclaration,,<empty>
564501,UNKNOWN,98,,"mouseInput.SetInputMode(TerminalInput::Mode::AlternateScroll, false);",9,<empty>,,601,98,CPPASTProblemDeclaration,,<empty>
564502,UNKNOWN,99,,"VERIFY_ARE_EQUAL(TerminalInput::MakeUnhandled(), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,602,99,CPPASTProblemDeclaration,,<empty>
564503,UNKNOWN,100,,", WM_MOUSEWHEEL, noModifierKeys, WHEEL_DELTA, {}",89,<empty>,,602,100,CPPASTProblemDeclaration,,<empty>
564504,UNKNOWN,101,,));,137,<empty>,,602,101,CPPASTProblemDeclaration,,<empty>
564505,UNKNOWN,102,,"Log::Comment(L""Confirm no effect when using the main buffer"");",9,<empty>,,604,102,CPPASTProblemDeclaration,,<empty>
564506,UNKNOWN,103,,mouseInput.UseMainScreenBuffer();,9,<empty>,,605,103,CPPASTProblemDeclaration,,<empty>
564507,UNKNOWN,104,,"mouseInput.SetInputMode(TerminalInput::Mode::AlternateScroll, true);",9,<empty>,,606,104,CPPASTProblemDeclaration,,<empty>
564508,UNKNOWN,105,,"VERIFY_ARE_EQUAL(TerminalInput::MakeUnhandled(), mouseInput.HandleMouse({ 0, 0 }",9,<empty>,,607,105,CPPASTProblemDeclaration,,<empty>
564509,UNKNOWN,106,,", WM_MOUSEWHEEL, noModifierKeys, WHEEL_DELTA, {}",89,<empty>,,607,106,CPPASTProblemDeclaration,,<empty>
564510,UNKNOWN,107,,));,137,<empty>,,607,107,CPPASTProblemDeclaration,,<empty>
564511,UNKNOWN,108,,},5,<empty>,,608,108,CPPASTProblemDeclaration,,<empty>
564512,UNKNOWN,109,,};,1,<empty>,,609,109,CPPASTProblemDeclaration,,<empty>
566279,UNKNOWN,1,,DispatchTypes::DrcsCellMatrix,49,<empty>,,2794,1,CPPASTTypeId,,<empty>
567297,UNKNOWN,-1,,"static void MakeSubParamsAndRanges(std::initializer_list<std::initializer_list<const VTParameter>> subParamList, _Out_ std::vector<VTParameter>& subParams, _Out_ std::vector<std::pair<BYTE, BYTE>>& subParamRanges)
    {
        // Args are a list of lists of VTParameters:
        //    { {P1S1, P1S2, P1S3, ... }, { P2S1, P2S2, P2S3, ... } ... }
        //
        // P1 and P2 denotes the parameters, while S1, S2, S3 denotes the
        // subparameters of the corresponding parameter.
        size_t totalSubParams = 0;
        subParams.clear();
        subParamRanges.clear();
        for (const auto& it : subParamList)
        {
            subParams.insert(subParams.end(), it.begin(), it.end());
            subParamRanges.push_back({ gsl::narrow_cast<BYTE>(totalSubParams), gsl::narrow_cast<BYTE>(it.size() + totalSubParams) });
            totalSubParams += it.size();
        }
    }",5,<empty>,,335,35,CPPASTProblemDeclaration,,<empty>
567311,UNKNOWN,-1,,"void ValidateInputEvent(_In_ PCWSTR pwszExpectedResponse)
    {
        VERIFY_ARE_EQUAL(pwszExpectedResponse, _response);
    }",5,<empty>,,358,37,CPPASTProblemDeclaration,,<empty>
567364,UNKNOWN,1,,WCHAR,38,<empty>,,365,1,CPPASTTypeId,,<empty>
567453,UNKNOWN,8,,"TEST_METHOD(CursorMovementTest)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiDirection"", L""{0, 1, 2, 3, 4, 5}"") // These values align with the CursorDirection enum class to try all the directions.
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,451,8,CPPASTProblemDeclaration,,<empty>
567465,UNKNOWN,14,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiDirection"", dir));",9,<empty>,,466,14,CPPASTProblemDeclaration,,<empty>
567466,UNKNOWN,15,,direction = (CursorDirection)dir;,9,<empty>,,467,15,CPPASTProblemDeclaration,,<empty>
567467,UNKNOWN,16,,"switch (direction)
        {
        case CursorDirection::UP:
            Log::Comment(L""Testing up direction."");
            moveFunc = &AdaptDispatch::CursorUp;
            break;
        case CursorDirection::DOWN:
            Log::Comment(L""Testing down direction."");
            moveFunc = &AdaptDispatch::CursorDown;
            break;
        case CursorDirection::RIGHT:
            Log::Comment(L""Testing right direction."");
            moveFunc = &AdaptDispatch::CursorForward;
            break;
        case CursorDirection::LEFT:
            Log::Comment(L""Testing left direction."");
            moveFunc = &AdaptDispatch::CursorBackward;
            break;
        case CursorDirection::NEXTLINE:
            Log::Comment(L""Testing next line direction."");
            moveFunc = &AdaptDispatch::CursorNextLine;
            break;
        case CursorDirection::PREVLINE:
            Log::Comment(L""Testing prev line direction."");
            moveFunc = &AdaptDispatch::CursorPrevLine...",9,<empty>,,469,16,CPPASTProblemDeclaration,,<empty>
567468,UNKNOWN,17,,"if (moveFunc == nullptr)
        {
            VERIFY_FAIL();
            return;
        }",9,<empty>,,497,17,CPPASTProblemDeclaration,,<empty>
567469,UNKNOWN,18,,"Log::Comment(L""Test 1: Cursor doesn't move when placed in corner of viewport."");",9,<empty>,,505,18,CPPASTProblemDeclaration,,<empty>
567470,UNKNOWN,19,,_testGetSet->PrepData(direction);,9,<empty>,,506,19,CPPASTProblemDeclaration,,<empty>
567471,UNKNOWN,20,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(1));,9,<empty>,,508,20,CPPASTProblemDeclaration,,<empty>
567472,UNKNOWN,21,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,509,21,CPPASTProblemDeclaration,,<empty>
567473,UNKNOWN,22,,"Log::Comment(L""Test 1b: Cursor moves to left of line with next/prev line command when cursor can't move higher/lower."");",9,<empty>,,511,22,CPPASTProblemDeclaration,,<empty>
567478,UNKNOWN,25,,"switch (direction)
        {
        case CursorDirection::NEXTLINE:
            _testGetSet->PrepData(CursorX::RIGHT, CursorY::BOTTOM);
            fDoTest1b = true;
            break;
        case CursorDirection::PREVLINE:
            _testGetSet->PrepData(CursorX::RIGHT, CursorY::TOP);
            fDoTest1b = true;
            break;
        }",9,<empty>,,515,25,CPPASTProblemDeclaration,,<empty>
567479,UNKNOWN,26,,"if (fDoTest1b)
        {
            _testGetSet->_expectedCursorPos.x = 0;
            VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(1));
            _testGetSet->ValidateExpectedCursorPos();
        }",9,<empty>,,527,26,CPPASTProblemDeclaration,,<empty>
567480,UNKNOWN,27,,"else
        {
            Log::Comment(L""Test not applicable to direction selected. Skipping."");
        }",9,<empty>,,533,27,CPPASTProblemDeclaration,,<empty>
567481,UNKNOWN,28,,"Log::Comment(L""Test 2: Cursor moves 1 in the correct direction from viewport."");",9,<empty>,,539,28,CPPASTProblemDeclaration,,<empty>
567482,UNKNOWN,29,,"_testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);",9,<empty>,,540,29,CPPASTProblemDeclaration,,<empty>
567483,UNKNOWN,30,,"switch (direction)
        {
        case CursorDirection::UP:
            _testGetSet->_expectedCursorPos.y--;
            break;
        case CursorDirection::DOWN:
            _testGetSet->_expectedCursorPos.y++;
            break;
        case CursorDirection::RIGHT:
            _testGetSet->_expectedCursorPos.x++;
            break;
        case CursorDirection::LEFT:
            _testGetSet->_expectedCursorPos.x--;
            break;
        case CursorDirection::NEXTLINE:
            _testGetSet->_expectedCursorPos.y++;
            _testGetSet->_expectedCursorPos.x = 0;
            break;
        case CursorDirection::PREVLINE:
            _testGetSet->_expectedCursorPos.y--;
            _testGetSet->_expectedCursorPos.x = 0;
            break;
        }",9,<empty>,,542,30,CPPASTProblemDeclaration,,<empty>
567484,UNKNOWN,31,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(1));,9,<empty>,,566,31,CPPASTProblemDeclaration,,<empty>
567485,UNKNOWN,32,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,567,32,CPPASTProblemDeclaration,,<empty>
567486,UNKNOWN,33,,"Log::Comment(L""Test 3: Cursor moves and gets stuck at viewport when started away from edges and moved beyond edges."");",9,<empty>,,570,33,CPPASTProblemDeclaration,,<empty>
567487,UNKNOWN,34,,"_testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);",9,<empty>,,571,34,CPPASTProblemDeclaration,,<empty>
567488,UNKNOWN,35,,"switch (direction)
        {
        case CursorDirection::UP:
            _testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.top;
            break;
        case CursorDirection::DOWN:
            _testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.bottom - 1;
            break;
        case CursorDirection::RIGHT:
            _testGetSet->_expectedCursorPos.x = _testGetSet->_textBuffer->GetSize().Dimensions().width - 1;
            break;
        case CursorDirection::LEFT:
            _testGetSet->_expectedCursorPos.x = 0;
            break;
        case CursorDirection::NEXTLINE:
            _testGetSet->_expectedCursorPos.x = 0;
            _testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.bottom - 1;
            break;
        case CursorDirection::PREVLINE:
            _testGetSet->_expectedCursorPos.x = 0;
            _testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.top;
            break;
        }",9,<empty>,,575,35,CPPASTProblemDeclaration,,<empty>
567489,UNKNOWN,36,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(100));,9,<empty>,,599,36,CPPASTProblemDeclaration,,<empty>
567490,UNKNOWN,37,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,600,37,CPPASTProblemDeclaration,,<empty>
567491,UNKNOWN,38,,},5,<empty>,,601,38,CPPASTProblemDeclaration,,<empty>
567492,UNKNOWN,39,,"TEST_METHOD(CursorPositionTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,603,39,CPPASTProblemDeclaration,,<empty>
567493,UNKNOWN,40,,"Log::Comment(L""Test 1: Place cursor within the viewport. Start from top left, move to middle."");",9,<empty>,,607,40,CPPASTProblemDeclaration,,<empty>
567494,UNKNOWN,41,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::TOP);",9,<empty>,,608,41,CPPASTProblemDeclaration,,<empty>
567527,UNKNOWN,46,,_testGetSet->_expectedCursorPos.x = sCol - 1;,9,<empty>,,614,46,CPPASTProblemDeclaration,,<empty>
567528,UNKNOWN,47,,_testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.top + (sRow - 1);,9,<empty>,,615,47,CPPASTProblemDeclaration,,<empty>
567529,UNKNOWN,48,,"VERIFY_IS_TRUE(_pDispatch->CursorPosition(sRow, sCol));",9,<empty>,,617,48,CPPASTProblemDeclaration,,<empty>
567530,UNKNOWN,49,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,618,49,CPPASTProblemDeclaration,,<empty>
567531,UNKNOWN,50,,"Log::Comment(L""Test 2: Move to 0, 0 (which is 1,1 in VT speak)"");",9,<empty>,,620,50,CPPASTProblemDeclaration,,<empty>
567532,UNKNOWN,51,,"_testGetSet->PrepData(CursorX::RIGHT, CursorY::BOTTOM);",9,<empty>,,621,51,CPPASTProblemDeclaration,,<empty>
567533,UNKNOWN,52,,_testGetSet->_expectedCursorPos.x = 0;,9,<empty>,,624,52,CPPASTProblemDeclaration,,<empty>
567534,UNKNOWN,53,,_testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.top;,9,<empty>,,625,53,CPPASTProblemDeclaration,,<empty>
567535,UNKNOWN,54,,"VERIFY_IS_TRUE(_pDispatch->CursorPosition(1, 1));",9,<empty>,,627,54,CPPASTProblemDeclaration,,<empty>
567536,UNKNOWN,55,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,628,55,CPPASTProblemDeclaration,,<empty>
567537,UNKNOWN,56,,"Log::Comment(L""Test 3: Move beyond rectangle (down/right too far). Should be bounded back in."");",9,<empty>,,630,56,CPPASTProblemDeclaration,,<empty>
567538,UNKNOWN,57,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::TOP);",9,<empty>,,631,57,CPPASTProblemDeclaration,,<empty>
567539,UNKNOWN,58,,sCol = (_testGetSet->_textBuffer->GetSize().Dimensions().width) * 2;,9,<empty>,,633,58,CPPASTProblemDeclaration,,<empty>
567540,UNKNOWN,59,,sRow = (_testGetSet->_viewport.bottom - _testGetSet->_viewport.top) * 2;,9,<empty>,,634,59,CPPASTProblemDeclaration,,<empty>
567541,UNKNOWN,60,,_testGetSet->_expectedCursorPos.x = _testGetSet->_textBuffer->GetSize().Dimensions().width - 1;,9,<empty>,,636,60,CPPASTProblemDeclaration,,<empty>
567542,UNKNOWN,61,,_testGetSet->_expectedCursorPos.y = _testGetSet->_viewport.bottom - 1;,9,<empty>,,637,61,CPPASTProblemDeclaration,,<empty>
567543,UNKNOWN,62,,"VERIFY_IS_TRUE(_pDispatch->CursorPosition(sRow, sCol));",9,<empty>,,639,62,CPPASTProblemDeclaration,,<empty>
567544,UNKNOWN,63,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,640,63,CPPASTProblemDeclaration,,<empty>
567545,UNKNOWN,64,,},5,<empty>,,641,64,CPPASTProblemDeclaration,,<empty>
567546,UNKNOWN,65,,"TEST_METHOD(CursorSingleDimensionMoveTest)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiDirection"", L""{0, 1}"") // These values align with the CursorDirection enum class to try all the directions.
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,643,65,CPPASTProblemDeclaration,,<empty>
567565,UNKNOWN,76,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiDirection"", dir));",9,<empty>,,661,76,CPPASTProblemDeclaration,,<empty>
567566,UNKNOWN,77,,direction = (AbsolutePosition)dir;,9,<empty>,,662,77,CPPASTProblemDeclaration,,<empty>
567567,UNKNOWN,78,,_testGetSet->PrepData();,9,<empty>,,663,78,CPPASTProblemDeclaration,,<empty>
567568,UNKNOWN,79,,"switch (direction)
        {
        case AbsolutePosition::CursorHorizontal:
            Log::Comment(L""Testing cursor horizontal movement."");
            sRangeEnd = _testGetSet->_textBuffer->GetSize().Dimensions().width;
            sRangeStart = 0;
            psCursorExpected = &_testGetSet->_expectedCursorPos.x;
            moveFunc = &AdaptDispatch::CursorHorizontalPositionAbsolute;
            break;
        case AbsolutePosition::VerticalLine:
            Log::Comment(L""Testing vertical line movement."");
            sRangeEnd = _testGetSet->_viewport.bottom;
            sRangeStart = _testGetSet->_viewport.top;
            psCursorExpected = &_testGetSet->_expectedCursorPos.y;
            moveFunc = &AdaptDispatch::VerticalLinePositionAbsolute;
            break;
        }",9,<empty>,,665,79,CPPASTProblemDeclaration,,<empty>
567569,UNKNOWN,80,,"if (moveFunc == nullptr || psCursorExpected == nullptr)
        {
            VERIFY_FAIL();
            return;
        }",9,<empty>,,683,80,CPPASTProblemDeclaration,,<empty>
567570,UNKNOWN,81,,"Log::Comment(L""Test 1: Place cursor within the viewport. Start from top left, move to middle."");",9,<empty>,,689,81,CPPASTProblemDeclaration,,<empty>
567571,UNKNOWN,82,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::TOP);",9,<empty>,,690,82,CPPASTProblemDeclaration,,<empty>
567580,UNKNOWN,85,,*psCursorExpected = sRangeStart + (sVal - 1);,9,<empty>,,694,85,CPPASTProblemDeclaration,,<empty>
567581,UNKNOWN,86,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(sVal));,9,<empty>,,696,86,CPPASTProblemDeclaration,,<empty>
567582,UNKNOWN,87,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,697,87,CPPASTProblemDeclaration,,<empty>
567583,UNKNOWN,88,,"Log::Comment(L""Test 2: Move to 0 (which is 1 in VT speak)"");",9,<empty>,,699,88,CPPASTProblemDeclaration,,<empty>
567584,UNKNOWN,89,,"_testGetSet->PrepData(CursorX::RIGHT, CursorY::BOTTOM);",9,<empty>,,700,89,CPPASTProblemDeclaration,,<empty>
567585,UNKNOWN,90,,*psCursorExpected = sRangeStart;,9,<empty>,,702,90,CPPASTProblemDeclaration,,<empty>
567586,UNKNOWN,91,,sVal = 1;,9,<empty>,,703,91,CPPASTProblemDeclaration,,<empty>
567587,UNKNOWN,92,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(sVal));,9,<empty>,,705,92,CPPASTProblemDeclaration,,<empty>
567588,UNKNOWN,93,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,706,93,CPPASTProblemDeclaration,,<empty>
567589,UNKNOWN,94,,"Log::Comment(L""Test 3: Move beyond rectangle (down/right too far). Should be bounded back in."");",9,<empty>,,708,94,CPPASTProblemDeclaration,,<empty>
567590,UNKNOWN,95,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::TOP);",9,<empty>,,709,95,CPPASTProblemDeclaration,,<empty>
567591,UNKNOWN,96,,sVal = (sRangeEnd - sRangeStart) * 2;,9,<empty>,,711,96,CPPASTProblemDeclaration,,<empty>
567592,UNKNOWN,97,,*psCursorExpected = sRangeEnd - 1;,9,<empty>,,713,97,CPPASTProblemDeclaration,,<empty>
567593,UNKNOWN,98,,VERIFY_IS_TRUE((_pDispatch->*(moveFunc))(sVal));,9,<empty>,,715,98,CPPASTProblemDeclaration,,<empty>
567594,UNKNOWN,99,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,716,99,CPPASTProblemDeclaration,,<empty>
567595,UNKNOWN,100,,},5,<empty>,,717,100,CPPASTProblemDeclaration,,<empty>
567596,UNKNOWN,101,,"TEST_METHOD(CursorSaveRestoreTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,719,101,CPPASTProblemDeclaration,,<empty>
567598,UNKNOWN,103,,"Log::Comment(L""Test 1: Restore with no saved data should move to top-left corner, the null/default position."");",9,<empty>,,725,103,CPPASTProblemDeclaration,,<empty>
567599,UNKNOWN,104,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::TOP);",9,<empty>,,728,104,CPPASTProblemDeclaration,,<empty>
567600,UNKNOWN,105,,coordExpected = _testGetSet->_expectedCursorPos;,9,<empty>,,729,105,CPPASTProblemDeclaration,,<empty>
567601,UNKNOWN,106,,"_testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);",9,<empty>,,732,106,CPPASTProblemDeclaration,,<empty>
567602,UNKNOWN,107,,_testGetSet->_expectedCursorPos = coordExpected;,9,<empty>,,733,107,CPPASTProblemDeclaration,,<empty>
567603,UNKNOWN,108,,_testGetSet->_expectedAttribute = {};,9,<empty>,,736,108,CPPASTProblemDeclaration,,<empty>
567604,UNKNOWN,109,,"VERIFY_IS_TRUE(_pDispatch->CursorRestoreState(), L""By default, restore to top left corner (0,0 offset from viewport)."");",9,<empty>,,738,109,CPPASTProblemDeclaration,,<empty>
567605,UNKNOWN,110,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,739,110,CPPASTProblemDeclaration,,<empty>
567606,UNKNOWN,111,,"Log::Comment(L""Test 2: Place cursor in center. Save. Move cursor to corner. Restore. Should come back to center."");",9,<empty>,,741,111,CPPASTProblemDeclaration,,<empty>
567607,UNKNOWN,112,,"_testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);",9,<empty>,,742,112,CPPASTProblemDeclaration,,<empty>
567608,UNKNOWN,113,,"VERIFY_IS_TRUE(_pDispatch->CursorSaveState(), L""Succeed at saving position."");",9,<empty>,,743,113,CPPASTProblemDeclaration,,<empty>
567609,UNKNOWN,114,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,744,114,CPPASTProblemDeclaration,,<empty>
567610,UNKNOWN,115,,"Log::Comment(L""Backup expected cursor (in the middle). Move cursor to corner. Then re-set expected cursor to middle."");",9,<empty>,,746,115,CPPASTProblemDeclaration,,<empty>
567611,UNKNOWN,116,,coordExpected = _testGetSet->_expectedCursorPos;,9,<empty>,,748,116,CPPASTProblemDeclaration,,<empty>
567612,UNKNOWN,117,,"_testGetSet->PrepData(CursorX::LEFT, CursorY::BOTTOM);",9,<empty>,,751,117,CPPASTProblemDeclaration,,<empty>
567613,UNKNOWN,118,,_testGetSet->_expectedCursorPos = coordExpected;,9,<empty>,,754,118,CPPASTProblemDeclaration,,<empty>
567614,UNKNOWN,119,,"VERIFY_IS_TRUE(_pDispatch->CursorRestoreState(), L""Restoring to corner should succeed. API call inside will test that cursor matched expected position."");",9,<empty>,,756,119,CPPASTProblemDeclaration,,<empty>
567615,UNKNOWN,120,,_testGetSet->ValidateExpectedCursorPos();,9,<empty>,,757,120,CPPASTProblemDeclaration,,<empty>
567616,UNKNOWN,121,,},5,<empty>,,758,121,CPPASTProblemDeclaration,,<empty>
567617,UNKNOWN,122,,"TEST_METHOD(CursorHideShowTest)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:fStartingVis"", L""{TRUE, FALSE}"")
            TEST_METHOD_PROPERTY(L""Data:fEndingVis"", L""{TRUE, FALSE}"")
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,760,122,CPPASTProblemDeclaration,,<empty>
567620,UNKNOWN,125,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""fStartingVis"", fStart));",9,<empty>,,772,125,CPPASTProblemDeclaration,,<empty>
567621,UNKNOWN,126,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""fEndingVis"", fEnd));",9,<empty>,,773,126,CPPASTProblemDeclaration,,<empty>
567622,UNKNOWN,127,,"Log::Comment(L""Verify successful API call modifies visibility state."");",9,<empty>,,775,127,CPPASTProblemDeclaration,,<empty>
567623,UNKNOWN,128,,_testGetSet->PrepData();,9,<empty>,,776,128,CPPASTProblemDeclaration,,<empty>
567624,UNKNOWN,129,,_testGetSet->_textBuffer->GetCursor().SetIsVisible(fStart);,9,<empty>,,777,129,CPPASTProblemDeclaration,,<empty>
567625,UNKNOWN,130,,"if (fEnd)
        {
            VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::DECTCEM_TextCursorEnableMode));
        }",9,<empty>,,778,130,CPPASTProblemDeclaration,,<empty>
567626,UNKNOWN,131,,"else
        {
            VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::DECTCEM_TextCursorEnableMode));
        }",9,<empty>,,782,131,CPPASTProblemDeclaration,,<empty>
567627,UNKNOWN,132,,"VERIFY_ARE_EQUAL(fEnd, _testGetSet->_textBuffer->GetCursor().IsVisible());",9,<empty>,,786,132,CPPASTProblemDeclaration,,<empty>
567628,UNKNOWN,133,,},5,<empty>,,787,133,CPPASTProblemDeclaration,,<empty>
567629,UNKNOWN,134,,"TEST_METHOD(GraphicsBaseTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,789,134,CPPASTProblemDeclaration,,<empty>
567630,UNKNOWN,135,,"Log::Comment(L""Test 1: Send no options."");",9,<empty>,,793,135,CPPASTProblemDeclaration,,<empty>
567631,UNKNOWN,136,,_testGetSet->PrepData();,9,<empty>,,795,136,CPPASTProblemDeclaration,,<empty>
567639,UNKNOWN,141,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,800,141,CPPASTProblemDeclaration,,<empty>
567640,UNKNOWN,142,,));,80,<empty>,,800,142,CPPASTProblemDeclaration,,<empty>
567641,UNKNOWN,143,,"Log::Comment(L""Test 2: Gracefully fail when setting attribute data fails."");",9,<empty>,,802,143,CPPASTProblemDeclaration,,<empty>
567642,UNKNOWN,144,,_testGetSet->PrepData();,9,<empty>,,804,144,CPPASTProblemDeclaration,,<empty>
567643,UNKNOWN,145,,_testGetSet->_setTextAttributesResult = FALSE;,9,<empty>,,805,145,CPPASTProblemDeclaration,,<empty>
567644,UNKNOWN,146,,rgOptions[0] = (DispatchTypes::GraphicsOptions)0;,9,<empty>,,807,146,CPPASTProblemDeclaration,,<empty>
567645,UNKNOWN,147,,cOptions = 1;,9,<empty>,,808,147,CPPASTProblemDeclaration,,<empty>
567646,UNKNOWN,148,,"VERIFY_THROWS(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,809,148,CPPASTProblemDeclaration,,<empty>
567647,UNKNOWN,149,,"), std::exception);",79,<empty>,,809,149,CPPASTProblemDeclaration,,<empty>
567648,UNKNOWN,150,,},5,<empty>,,810,150,CPPASTProblemDeclaration,,<empty>
567649,UNKNOWN,151,,"TEST_METHOD(GraphicsSingleTests)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiGraphicsOptions"", L""{0, 1, 2, 4, 7, 8, 9, 21, 22, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 53, 55, 90, 91, 92, 93, 94, 95, 96, 97, 100, 101, 102, 103, 104, 105, 106, 107}"") // corresponds to options in DispatchTypes::GraphicsOptions
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,812,151,CPPASTProblemDeclaration,,<empty>
567650,UNKNOWN,152,,_testGetSet->PrepData();,9,<empty>,,819,152,CPPASTProblemDeclaration,,<empty>
567653,UNKNOWN,155,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiGraphicsOptions"", uiGraphicsOption));",9,<empty>,,824,155,CPPASTProblemDeclaration,,<empty>
567654,UNKNOWN,156,,graphicsOption = (DispatchTypes::GraphicsOptions)uiGraphicsOption;,9,<empty>,,825,156,CPPASTProblemDeclaration,,<empty>
567662,UNKNOWN,161,,rgOptions[0] = graphicsOption;,9,<empty>,,829,161,CPPASTProblemDeclaration,,<empty>
567664,UNKNOWN,163,,"switch (graphicsOption)
        {
        case DispatchTypes::GraphicsOptions::Off:
            Log::Comment(L""Testing graphics 'Off/Reset'"");
            startingAttribute = TextAttribute{ (WORD)~_testGetSet->s_defaultFill };
            _testGetSet->_expectedAttribute = TextAttribute{};
            break;
        case DispatchTypes::GraphicsOptions::Intense:
            Log::Comment(L""Testing graphics 'Intense'"");
            startingAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute.SetIntense(true);
            break;
        case DispatchTypes::GraphicsOptions::RGBColorOrFaint:
            Log::Comment(L""Testing graphics 'Faint'"");
            startingAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute.SetFaint(true);
            break;
        case DispatchTypes::GraphicsOptions::Underline:
        ...",9,<empty>,,832,163,CPPASTProblemDeclaration,,<empty>
567665,UNKNOWN,164,,_testGetSet->_textBuffer->SetCurrentAttributes(startingAttribute);,9,<empty>,,1131,164,CPPASTProblemDeclaration,,<empty>
567666,UNKNOWN,165,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1132,165,CPPASTProblemDeclaration,,<empty>
567667,UNKNOWN,166,,));,80,<empty>,,1132,166,CPPASTProblemDeclaration,,<empty>
567668,UNKNOWN,167,,},5,<empty>,,1133,167,CPPASTProblemDeclaration,,<empty>
567669,UNKNOWN,168,,"TEST_METHOD(GraphicsSingleWithSubParamTests)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiGraphicsOptions"", L""{4, 38, 48, 58}"") // corresponds to options in DispatchTypes::GraphicsOptions
        END_TEST_METHOD_PROPERTIES()

        Log::Comment(L""Starting test..."");",5,<empty>,,1135,168,CPPASTProblemDeclaration,,<empty>
567670,UNKNOWN,169,,_testGetSet->PrepData();,9,<empty>,,1142,169,CPPASTProblemDeclaration,,<empty>
567675,UNKNOWN,174,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiGraphicsOptions"", uiGraphicsOption));",9,<empty>,,1149,174,CPPASTProblemDeclaration,,<empty>
567676,UNKNOWN,175,,graphicsOption = (DispatchTypes::GraphicsOptions)uiGraphicsOption;,9,<empty>,,1150,175,CPPASTProblemDeclaration,,<empty>
567684,UNKNOWN,180,,rgOptions[0] = graphicsOption;,9,<empty>,,1154,180,CPPASTProblemDeclaration,,<empty>
567686,UNKNOWN,182,,"switch (graphicsOption)
        {
        case DispatchTypes::GraphicsOptions::Underline:
            Log::Comment(L""Testing graphics 'Underline'"");
            _testGetSet->MakeSubParamsAndRanges({ { 3 } }, subParams, subParamRanges);
            startingAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::CurlyUnderlined);
            break;
        case DispatchTypes::GraphicsOptions::ForegroundExtended:
            Log::Comment(L""Testing graphics 'ForegroundExtended'"");
            _testGetSet->MakeSubParamsAndRanges({ { DispatchTypes::GraphicsOptions::BlinkOrXterm256Index, TextColor::DARK_RED } }, subParams, subParamRanges);
            startingAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute = TextAttribute{ 0 };
            _testGetSet->_expectedAttribute.SetIndexedForeground256(TextColor::DARK_RED);
            break;
        c...",9,<empty>,,1157,182,CPPASTProblemDeclaration,,<empty>
567687,UNKNOWN,183,,_testGetSet->_textBuffer->SetCurrentAttributes(startingAttribute);,9,<empty>,,1191,183,CPPASTProblemDeclaration,,<empty>
567688,UNKNOWN,184,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ std::span{ rgOptions, cOptions }, subParams, subParamRanges }",9,<empty>,,1192,184,CPPASTProblemDeclaration,,<empty>
567689,UNKNOWN,185,,));,120,<empty>,,1192,185,CPPASTProblemDeclaration,,<empty>
567690,UNKNOWN,186,,},5,<empty>,,1193,186,CPPASTProblemDeclaration,,<empty>
567691,UNKNOWN,187,,"TEST_METHOD(GraphicsPushPopTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1195,187,CPPASTProblemDeclaration,,<empty>
567692,UNKNOWN,188,,_testGetSet->PrepData();,9,<empty>,,1199,188,CPPASTProblemDeclaration,,<empty>
567705,UNKNOWN,197,,"Log::Comment(L""Test 1: Basic push and pop"");",9,<empty>,,1207,197,CPPASTProblemDeclaration,,<empty>
567706,UNKNOWN,198,,rgOptions[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,1209,198,CPPASTProblemDeclaration,,<empty>
567707,UNKNOWN,199,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1210,199,CPPASTProblemDeclaration,,<empty>
567708,UNKNOWN,200,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1211,200,CPPASTProblemDeclaration,,<empty>
567709,UNKNOWN,201,,));,80,<empty>,,1211,201,CPPASTProblemDeclaration,,<empty>
567710,UNKNOWN,202,,cOptions = 0;,9,<empty>,,1213,202,CPPASTProblemDeclaration,,<empty>
567711,UNKNOWN,203,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1214,203,CPPASTProblemDeclaration,,<empty>
567712,UNKNOWN,204,,));,86,<empty>,,1214,204,CPPASTProblemDeclaration,,<empty>
567713,UNKNOWN,205,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1216,205,CPPASTProblemDeclaration,,<empty>
567714,UNKNOWN,206,,"Log::Comment(L""Test 2: Push, change color, pop"");",9,<empty>,,1218,206,CPPASTProblemDeclaration,,<empty>
567715,UNKNOWN,207,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1220,207,CPPASTProblemDeclaration,,<empty>
567716,UNKNOWN,208,,));,86,<empty>,,1220,208,CPPASTProblemDeclaration,,<empty>
567717,UNKNOWN,209,,cOptions = 1;,9,<empty>,,1222,209,CPPASTProblemDeclaration,,<empty>
567718,UNKNOWN,210,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundCyan;,9,<empty>,,1223,210,CPPASTProblemDeclaration,,<empty>
567719,UNKNOWN,211,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1224,211,CPPASTProblemDeclaration,,<empty>
567720,UNKNOWN,212,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_CYAN);,9,<empty>,,1225,212,CPPASTProblemDeclaration,,<empty>
567721,UNKNOWN,213,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1226,213,CPPASTProblemDeclaration,,<empty>
567722,UNKNOWN,214,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1227,214,CPPASTProblemDeclaration,,<empty>
567723,UNKNOWN,215,,));,80,<empty>,,1227,215,CPPASTProblemDeclaration,,<empty>
567724,UNKNOWN,216,,cOptions = 0;,9,<empty>,,1229,216,CPPASTProblemDeclaration,,<empty>
567725,UNKNOWN,217,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1230,217,CPPASTProblemDeclaration,,<empty>
567726,UNKNOWN,218,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1231,218,CPPASTProblemDeclaration,,<empty>
567727,UNKNOWN,219,,"Log::Comment(L""Test 3: two pushes (nested) and pops"");",9,<empty>,,1233,219,CPPASTProblemDeclaration,,<empty>
567728,UNKNOWN,220,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1236,220,CPPASTProblemDeclaration,,<empty>
567729,UNKNOWN,221,,));,86,<empty>,,1236,221,CPPASTProblemDeclaration,,<empty>
567730,UNKNOWN,222,,cOptions = 1;,9,<empty>,,1238,222,CPPASTProblemDeclaration,,<empty>
567731,UNKNOWN,223,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundRed;,9,<empty>,,1239,223,CPPASTProblemDeclaration,,<empty>
567732,UNKNOWN,224,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1240,224,CPPASTProblemDeclaration,,<empty>
567733,UNKNOWN,225,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_RED);,9,<empty>,,1241,225,CPPASTProblemDeclaration,,<empty>
567734,UNKNOWN,226,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1242,226,CPPASTProblemDeclaration,,<empty>
567735,UNKNOWN,227,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1243,227,CPPASTProblemDeclaration,,<empty>
567736,UNKNOWN,228,,));,80,<empty>,,1243,228,CPPASTProblemDeclaration,,<empty>
567737,UNKNOWN,229,,cOptions = 0;,9,<empty>,,1246,229,CPPASTProblemDeclaration,,<empty>
567738,UNKNOWN,230,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1247,230,CPPASTProblemDeclaration,,<empty>
567739,UNKNOWN,231,,));,86,<empty>,,1247,231,CPPASTProblemDeclaration,,<empty>
567740,UNKNOWN,232,,cOptions = 1;,9,<empty>,,1249,232,CPPASTProblemDeclaration,,<empty>
567741,UNKNOWN,233,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundGreen;,9,<empty>,,1250,233,CPPASTProblemDeclaration,,<empty>
567742,UNKNOWN,234,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1251,234,CPPASTProblemDeclaration,,<empty>
567743,UNKNOWN,235,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1252,235,CPPASTProblemDeclaration,,<empty>
567744,UNKNOWN,236,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1253,236,CPPASTProblemDeclaration,,<empty>
567745,UNKNOWN,237,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1254,237,CPPASTProblemDeclaration,,<empty>
567746,UNKNOWN,238,,));,80,<empty>,,1254,238,CPPASTProblemDeclaration,,<empty>
567747,UNKNOWN,239,,cOptions = 0;,9,<empty>,,1257,239,CPPASTProblemDeclaration,,<empty>
567748,UNKNOWN,240,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1258,240,CPPASTProblemDeclaration,,<empty>
567749,UNKNOWN,241,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_RED);,9,<empty>,,1259,241,CPPASTProblemDeclaration,,<empty>
567750,UNKNOWN,242,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1260,242,CPPASTProblemDeclaration,,<empty>
567751,UNKNOWN,243,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1261,243,CPPASTProblemDeclaration,,<empty>
567752,UNKNOWN,244,,cOptions = 0;,9,<empty>,,1264,244,CPPASTProblemDeclaration,,<empty>
567753,UNKNOWN,245,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1265,245,CPPASTProblemDeclaration,,<empty>
567754,UNKNOWN,246,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1266,246,CPPASTProblemDeclaration,,<empty>
567755,UNKNOWN,247,,"Log::Comment(L""Test 4: Save and restore partial attributes"");",9,<empty>,,1268,247,CPPASTProblemDeclaration,,<empty>
567756,UNKNOWN,248,,cOptions = 1;,9,<empty>,,1270,248,CPPASTProblemDeclaration,,<empty>
567757,UNKNOWN,249,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundGreen;,9,<empty>,,1271,249,CPPASTProblemDeclaration,,<empty>
567758,UNKNOWN,250,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1272,250,CPPASTProblemDeclaration,,<empty>
567759,UNKNOWN,251,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1273,251,CPPASTProblemDeclaration,,<empty>
567760,UNKNOWN,252,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1274,252,CPPASTProblemDeclaration,,<empty>
567761,UNKNOWN,253,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1275,253,CPPASTProblemDeclaration,,<empty>
567762,UNKNOWN,254,,));,80,<empty>,,1275,254,CPPASTProblemDeclaration,,<empty>
567763,UNKNOWN,255,,cOptions = 1;,9,<empty>,,1277,255,CPPASTProblemDeclaration,,<empty>
567764,UNKNOWN,256,,rgOptions[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,1278,256,CPPASTProblemDeclaration,,<empty>
567765,UNKNOWN,257,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1279,257,CPPASTProblemDeclaration,,<empty>
567766,UNKNOWN,258,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1280,258,CPPASTProblemDeclaration,,<empty>
567767,UNKNOWN,259,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1281,259,CPPASTProblemDeclaration,,<empty>
567768,UNKNOWN,260,,_testGetSet->_expectedAttribute.SetDefaultBackground();,9,<empty>,,1282,260,CPPASTProblemDeclaration,,<empty>
567769,UNKNOWN,261,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1283,261,CPPASTProblemDeclaration,,<empty>
567770,UNKNOWN,262,,));,80,<empty>,,1283,262,CPPASTProblemDeclaration,,<empty>
567771,UNKNOWN,263,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundBlue;,9,<empty>,,1285,263,CPPASTProblemDeclaration,,<empty>
567772,UNKNOWN,264,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1286,264,CPPASTProblemDeclaration,,<empty>
567773,UNKNOWN,265,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1287,265,CPPASTProblemDeclaration,,<empty>
567774,UNKNOWN,266,,_testGetSet->_expectedAttribute.SetIndexedBackground(TextColor::DARK_BLUE);,9,<empty>,,1288,266,CPPASTProblemDeclaration,,<empty>
567775,UNKNOWN,267,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1289,267,CPPASTProblemDeclaration,,<empty>
567776,UNKNOWN,268,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1290,268,CPPASTProblemDeclaration,,<empty>
567777,UNKNOWN,269,,));,80,<empty>,,1290,269,CPPASTProblemDeclaration,,<empty>
567778,UNKNOWN,270,,cOptions = 3;,9,<empty>,,1293,270,CPPASTProblemDeclaration,,<empty>
567779,UNKNOWN,271,,rgStackOptions[0] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::Intense;,9,<empty>,,1294,271,CPPASTProblemDeclaration,,<empty>
567780,UNKNOWN,272,,rgStackOptions[1] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::SaveBackgroundColor;,9,<empty>,,1295,272,CPPASTProblemDeclaration,,<empty>
567781,UNKNOWN,273,,rgStackOptions[2] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::DoublyUnderlined;,9,<empty>,,1296,273,CPPASTProblemDeclaration,,<empty>
567782,UNKNOWN,274,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1297,274,CPPASTProblemDeclaration,,<empty>
567783,UNKNOWN,275,,));,86,<empty>,,1297,275,CPPASTProblemDeclaration,,<empty>
567784,UNKNOWN,276,,cOptions = 2;,9,<empty>,,1300,276,CPPASTProblemDeclaration,,<empty>
567785,UNKNOWN,277,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundGreen;,9,<empty>,,1301,277,CPPASTProblemDeclaration,,<empty>
567786,UNKNOWN,278,,rgOptions[1] = DispatchTypes::GraphicsOptions::DoublyUnderlined;,9,<empty>,,1302,278,CPPASTProblemDeclaration,,<empty>
567787,UNKNOWN,279,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1303,279,CPPASTProblemDeclaration,,<empty>
567788,UNKNOWN,280,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1304,280,CPPASTProblemDeclaration,,<empty>
567789,UNKNOWN,281,,_testGetSet->_expectedAttribute.SetIndexedBackground(TextColor::DARK_GREEN);,9,<empty>,,1305,281,CPPASTProblemDeclaration,,<empty>
567790,UNKNOWN,282,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1306,282,CPPASTProblemDeclaration,,<empty>
567791,UNKNOWN,283,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1307,283,CPPASTProblemDeclaration,,<empty>
567792,UNKNOWN,284,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1308,284,CPPASTProblemDeclaration,,<empty>
567793,UNKNOWN,285,,));,80,<empty>,,1308,285,CPPASTProblemDeclaration,,<empty>
567794,UNKNOWN,286,,cOptions = 1;,9,<empty>,,1310,286,CPPASTProblemDeclaration,,<empty>
567795,UNKNOWN,287,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundRed;,9,<empty>,,1311,287,CPPASTProblemDeclaration,,<empty>
567796,UNKNOWN,288,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1312,288,CPPASTProblemDeclaration,,<empty>
567797,UNKNOWN,289,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_RED);,9,<empty>,,1313,289,CPPASTProblemDeclaration,,<empty>
567798,UNKNOWN,290,,_testGetSet->_expectedAttribute.SetIndexedBackground(TextColor::DARK_GREEN);,9,<empty>,,1314,290,CPPASTProblemDeclaration,,<empty>
567799,UNKNOWN,291,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1315,291,CPPASTProblemDeclaration,,<empty>
567800,UNKNOWN,292,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1316,292,CPPASTProblemDeclaration,,<empty>
567801,UNKNOWN,293,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1317,293,CPPASTProblemDeclaration,,<empty>
567802,UNKNOWN,294,,));,80,<empty>,,1317,294,CPPASTProblemDeclaration,,<empty>
567803,UNKNOWN,295,,rgOptions[0] = DispatchTypes::GraphicsOptions::NotIntenseOrFaint;,9,<empty>,,1319,295,CPPASTProblemDeclaration,,<empty>
567804,UNKNOWN,296,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1320,296,CPPASTProblemDeclaration,,<empty>
567805,UNKNOWN,297,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_RED);,9,<empty>,,1321,297,CPPASTProblemDeclaration,,<empty>
567806,UNKNOWN,298,,_testGetSet->_expectedAttribute.SetIndexedBackground(TextColor::DARK_GREEN);,9,<empty>,,1322,298,CPPASTProblemDeclaration,,<empty>
567807,UNKNOWN,299,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1323,299,CPPASTProblemDeclaration,,<empty>
567808,UNKNOWN,300,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1324,300,CPPASTProblemDeclaration,,<empty>
567809,UNKNOWN,301,,));,80,<empty>,,1324,301,CPPASTProblemDeclaration,,<empty>
567810,UNKNOWN,302,,cOptions = 0;,9,<empty>,,1327,302,CPPASTProblemDeclaration,,<empty>
567811,UNKNOWN,303,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1328,303,CPPASTProblemDeclaration,,<empty>
567812,UNKNOWN,304,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_RED);,9,<empty>,,1329,304,CPPASTProblemDeclaration,,<empty>
567813,UNKNOWN,305,,_testGetSet->_expectedAttribute.SetIndexedBackground(TextColor::DARK_BLUE);,9,<empty>,,1330,305,CPPASTProblemDeclaration,,<empty>
567814,UNKNOWN,306,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1331,306,CPPASTProblemDeclaration,,<empty>
567815,UNKNOWN,307,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1332,307,CPPASTProblemDeclaration,,<empty>
567816,UNKNOWN,308,,"Log::Comment(L""Test 5: Save 'no singly underline' state, set singly underlined, and pop. ""
                     L""Singly underlined is off after the pop."");",9,<empty>,,1334,308,CPPASTProblemDeclaration,,<empty>
567817,UNKNOWN,309,,cOptions = 1;,9,<empty>,,1337,309,CPPASTProblemDeclaration,,<empty>
567818,UNKNOWN,310,,rgOptions[0] = DispatchTypes::GraphicsOptions::NoUnderline;,9,<empty>,,1338,310,CPPASTProblemDeclaration,,<empty>
567819,UNKNOWN,311,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::NoUnderline);,9,<empty>,,1339,311,CPPASTProblemDeclaration,,<empty>
567820,UNKNOWN,312,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1340,312,CPPASTProblemDeclaration,,<empty>
567821,UNKNOWN,313,,));,80,<empty>,,1340,313,CPPASTProblemDeclaration,,<empty>
567822,UNKNOWN,314,,cOptions = 1;,9,<empty>,,1343,314,CPPASTProblemDeclaration,,<empty>
567823,UNKNOWN,315,,rgStackOptions[0] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::Underline;,9,<empty>,,1344,315,CPPASTProblemDeclaration,,<empty>
567824,UNKNOWN,316,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1345,316,CPPASTProblemDeclaration,,<empty>
567825,UNKNOWN,317,,));,86,<empty>,,1345,317,CPPASTProblemDeclaration,,<empty>
567826,UNKNOWN,318,,cOptions = 1;,9,<empty>,,1348,318,CPPASTProblemDeclaration,,<empty>
567827,UNKNOWN,319,,rgOptions[0] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,1349,319,CPPASTProblemDeclaration,,<empty>
567828,UNKNOWN,320,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);,9,<empty>,,1350,320,CPPASTProblemDeclaration,,<empty>
567829,UNKNOWN,321,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1351,321,CPPASTProblemDeclaration,,<empty>
567830,UNKNOWN,322,,));,80,<empty>,,1351,322,CPPASTProblemDeclaration,,<empty>
567831,UNKNOWN,323,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::NoUnderline);,9,<empty>,,1354,323,CPPASTProblemDeclaration,,<empty>
567832,UNKNOWN,324,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1355,324,CPPASTProblemDeclaration,,<empty>
567833,UNKNOWN,325,,"Log::Comment(L""Test 6: Save 'no singly underlined' state, set doubly underlined, and pop. ""
                     L""Doubly underlined is retained after the pop."");",9,<empty>,,1357,325,CPPASTProblemDeclaration,,<empty>
567834,UNKNOWN,326,,cOptions = 1;,9,<empty>,,1360,326,CPPASTProblemDeclaration,,<empty>
567835,UNKNOWN,327,,rgOptions[0] = DispatchTypes::GraphicsOptions::NoUnderline;,9,<empty>,,1361,327,CPPASTProblemDeclaration,,<empty>
567836,UNKNOWN,328,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::NoUnderline);,9,<empty>,,1362,328,CPPASTProblemDeclaration,,<empty>
567837,UNKNOWN,329,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1363,329,CPPASTProblemDeclaration,,<empty>
567838,UNKNOWN,330,,));,80,<empty>,,1363,330,CPPASTProblemDeclaration,,<empty>
567839,UNKNOWN,331,,cOptions = 1;,9,<empty>,,1366,331,CPPASTProblemDeclaration,,<empty>
567840,UNKNOWN,332,,rgStackOptions[0] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::Underline;,9,<empty>,,1367,332,CPPASTProblemDeclaration,,<empty>
567841,UNKNOWN,333,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1368,333,CPPASTProblemDeclaration,,<empty>
567842,UNKNOWN,334,,));,86,<empty>,,1368,334,CPPASTProblemDeclaration,,<empty>
567843,UNKNOWN,335,,cOptions = 1;,9,<empty>,,1371,335,CPPASTProblemDeclaration,,<empty>
567844,UNKNOWN,336,,rgOptions[0] = DispatchTypes::GraphicsOptions::DoublyUnderlined;,9,<empty>,,1372,336,CPPASTProblemDeclaration,,<empty>
567845,UNKNOWN,337,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1373,337,CPPASTProblemDeclaration,,<empty>
567846,UNKNOWN,338,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1374,338,CPPASTProblemDeclaration,,<empty>
567847,UNKNOWN,339,,));,80,<empty>,,1374,339,CPPASTProblemDeclaration,,<empty>
567848,UNKNOWN,340,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1377,340,CPPASTProblemDeclaration,,<empty>
567849,UNKNOWN,341,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1378,341,CPPASTProblemDeclaration,,<empty>
567850,UNKNOWN,342,,"Log::Comment(L""Test 7: Save 'curly underlined' state, set doubly underlined, and pop. ""
                     L""Curly underlined is restored after the pop."");",9,<empty>,,1380,342,CPPASTProblemDeclaration,,<empty>
567851,UNKNOWN,343,,cOptions = 1;,9,<empty>,,1383,343,CPPASTProblemDeclaration,,<empty>
567852,UNKNOWN,344,,rgOptions[0] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,1384,344,CPPASTProblemDeclaration,,<empty>
567853,UNKNOWN,345,,_testGetSet->MakeSubParamsAndRanges({ { 3 } },9,<empty>,,1385,345,CPPASTProblemDeclaration,,<empty>
567854,UNKNOWN,346,,", subParams, subParamRanges);",54,<empty>,,1385,346,CPPASTProblemDeclaration,,<empty>
567855,UNKNOWN,347,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::CurlyUnderlined);,9,<empty>,,1386,347,CPPASTProblemDeclaration,,<empty>
567856,UNKNOWN,348,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ std::span{ rgOptions, cOptions }, subParams, subParamRanges }",9,<empty>,,1387,348,CPPASTProblemDeclaration,,<empty>
567857,UNKNOWN,349,,));,120,<empty>,,1387,349,CPPASTProblemDeclaration,,<empty>
567858,UNKNOWN,350,,cOptions = 1;,9,<empty>,,1390,350,CPPASTProblemDeclaration,,<empty>
567859,UNKNOWN,351,,rgStackOptions[0] = (size_t)DispatchTypes::SgrSaveRestoreStackOptions::Underline;,9,<empty>,,1391,351,CPPASTProblemDeclaration,,<empty>
567860,UNKNOWN,352,,"VERIFY_IS_TRUE(_pDispatch->PushGraphicsRendition({ rgStackOptions, cOptions }",9,<empty>,,1392,352,CPPASTProblemDeclaration,,<empty>
567861,UNKNOWN,353,,));,86,<empty>,,1392,353,CPPASTProblemDeclaration,,<empty>
567862,UNKNOWN,354,,cOptions = 1;,9,<empty>,,1395,354,CPPASTProblemDeclaration,,<empty>
567863,UNKNOWN,355,,rgOptions[0] = DispatchTypes::GraphicsOptions::DoublyUnderlined;,9,<empty>,,1396,355,CPPASTProblemDeclaration,,<empty>
567864,UNKNOWN,356,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1397,356,CPPASTProblemDeclaration,,<empty>
567865,UNKNOWN,357,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1398,357,CPPASTProblemDeclaration,,<empty>
567866,UNKNOWN,358,,));,80,<empty>,,1398,358,CPPASTProblemDeclaration,,<empty>
567867,UNKNOWN,359,,_testGetSet->_expectedAttribute.SetUnderlineStyle(UnderlineStyle::CurlyUnderlined);,9,<empty>,,1401,359,CPPASTProblemDeclaration,,<empty>
567868,UNKNOWN,360,,VERIFY_IS_TRUE(_pDispatch->PopGraphicsRendition());,9,<empty>,,1402,360,CPPASTProblemDeclaration,,<empty>
567869,UNKNOWN,361,,},5,<empty>,,1403,361,CPPASTProblemDeclaration,,<empty>
567870,UNKNOWN,362,,"TEST_METHOD(GraphicsPersistBrightnessTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1405,362,CPPASTProblemDeclaration,,<empty>
567871,UNKNOWN,363,,_testGetSet->PrepData();,9,<empty>,,1409,363,CPPASTProblemDeclaration,,<empty>
567879,UNKNOWN,368,,"Log::Comment(L""Test 1: Basic brightness test"");",9,<empty>,,1414,368,CPPASTProblemDeclaration,,<empty>
567880,UNKNOWN,369,,"Log::Comment(L""Resetting graphics options"");",9,<empty>,,1415,369,CPPASTProblemDeclaration,,<empty>
567881,UNKNOWN,370,,rgOptions[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,1416,370,CPPASTProblemDeclaration,,<empty>
567882,UNKNOWN,371,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1417,371,CPPASTProblemDeclaration,,<empty>
567883,UNKNOWN,372,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1418,372,CPPASTProblemDeclaration,,<empty>
567884,UNKNOWN,373,,));,80,<empty>,,1418,373,CPPASTProblemDeclaration,,<empty>
567885,UNKNOWN,374,,"Log::Comment(L""Testing graphics 'Foreground Color Blue'"");",9,<empty>,,1420,374,CPPASTProblemDeclaration,,<empty>
567886,UNKNOWN,375,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundBlue;,9,<empty>,,1421,375,CPPASTProblemDeclaration,,<empty>
567887,UNKNOWN,376,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_BLUE);,9,<empty>,,1422,376,CPPASTProblemDeclaration,,<empty>
567888,UNKNOWN,377,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1423,377,CPPASTProblemDeclaration,,<empty>
567889,UNKNOWN,378,,));,80,<empty>,,1423,378,CPPASTProblemDeclaration,,<empty>
567890,UNKNOWN,379,,"Log::Comment(L""Enabling brightness"");",9,<empty>,,1425,379,CPPASTProblemDeclaration,,<empty>
567891,UNKNOWN,380,,rgOptions[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,1426,380,CPPASTProblemDeclaration,,<empty>
567892,UNKNOWN,381,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1427,381,CPPASTProblemDeclaration,,<empty>
567893,UNKNOWN,382,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1428,382,CPPASTProblemDeclaration,,<empty>
567894,UNKNOWN,383,,));,80,<empty>,,1428,383,CPPASTProblemDeclaration,,<empty>
567895,UNKNOWN,384,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1429,384,CPPASTProblemDeclaration,,<empty>
567896,UNKNOWN,385,,"Log::Comment(L""Testing graphics 'Foreground Color Green, with brightness'"");",9,<empty>,,1431,385,CPPASTProblemDeclaration,,<empty>
567897,UNKNOWN,386,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundGreen;,9,<empty>,,1432,386,CPPASTProblemDeclaration,,<empty>
567898,UNKNOWN,387,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1433,387,CPPASTProblemDeclaration,,<empty>
567899,UNKNOWN,388,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1434,388,CPPASTProblemDeclaration,,<empty>
567900,UNKNOWN,389,,));,80,<empty>,,1434,389,CPPASTProblemDeclaration,,<empty>
567901,UNKNOWN,390,,"VERIFY_IS_TRUE(WI_IsFlagSet(_testGetSet->_textBuffer->GetCurrentAttributes().GetLegacyAttributes(), FOREGROUND_GREEN));",9,<empty>,,1435,390,CPPASTProblemDeclaration,,<empty>
567902,UNKNOWN,391,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1436,391,CPPASTProblemDeclaration,,<empty>
567903,UNKNOWN,392,,"Log::Comment(L""Test 2: Disable brightness, use a bright color, next normal call remains not bright"");",9,<empty>,,1438,392,CPPASTProblemDeclaration,,<empty>
567904,UNKNOWN,393,,"Log::Comment(L""Resetting graphics options"");",9,<empty>,,1439,393,CPPASTProblemDeclaration,,<empty>
567905,UNKNOWN,394,,rgOptions[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,1440,394,CPPASTProblemDeclaration,,<empty>
567906,UNKNOWN,395,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1441,395,CPPASTProblemDeclaration,,<empty>
567907,UNKNOWN,396,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1442,396,CPPASTProblemDeclaration,,<empty>
567908,UNKNOWN,397,,));,80,<empty>,,1442,397,CPPASTProblemDeclaration,,<empty>
567909,UNKNOWN,398,,"VERIFY_IS_TRUE(WI_IsFlagClear(_testGetSet->_textBuffer->GetCurrentAttributes().GetLegacyAttributes(), FOREGROUND_INTENSITY));",9,<empty>,,1443,398,CPPASTProblemDeclaration,,<empty>
567910,UNKNOWN,399,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1444,399,CPPASTProblemDeclaration,,<empty>
567911,UNKNOWN,400,,"Log::Comment(L""Testing graphics 'Foreground Color Bright Blue'"");",9,<empty>,,1446,400,CPPASTProblemDeclaration,,<empty>
567912,UNKNOWN,401,,rgOptions[0] = DispatchTypes::GraphicsOptions::BrightForegroundBlue;,9,<empty>,,1447,401,CPPASTProblemDeclaration,,<empty>
567913,UNKNOWN,402,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::BRIGHT_BLUE);,9,<empty>,,1448,402,CPPASTProblemDeclaration,,<empty>
567914,UNKNOWN,403,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1449,403,CPPASTProblemDeclaration,,<empty>
567915,UNKNOWN,404,,));,80,<empty>,,1449,404,CPPASTProblemDeclaration,,<empty>
567916,UNKNOWN,405,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1450,405,CPPASTProblemDeclaration,,<empty>
567917,UNKNOWN,406,,"Log::Comment(L""Testing graphics 'Foreground Color Blue', brightness of 9x series doesn't persist"");",9,<empty>,,1452,406,CPPASTProblemDeclaration,,<empty>
567918,UNKNOWN,407,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundBlue;,9,<empty>,,1453,407,CPPASTProblemDeclaration,,<empty>
567919,UNKNOWN,408,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_BLUE);,9,<empty>,,1454,408,CPPASTProblemDeclaration,,<empty>
567920,UNKNOWN,409,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1455,409,CPPASTProblemDeclaration,,<empty>
567921,UNKNOWN,410,,));,80,<empty>,,1455,410,CPPASTProblemDeclaration,,<empty>
567922,UNKNOWN,411,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1456,411,CPPASTProblemDeclaration,,<empty>
567923,UNKNOWN,412,,"Log::Comment(L""Test 3: Enable brightness, use a bright color, brightness persists to next normal call"");",9,<empty>,,1458,412,CPPASTProblemDeclaration,,<empty>
567924,UNKNOWN,413,,"Log::Comment(L""Resetting graphics options"");",9,<empty>,,1459,413,CPPASTProblemDeclaration,,<empty>
567925,UNKNOWN,414,,rgOptions[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,1460,414,CPPASTProblemDeclaration,,<empty>
567926,UNKNOWN,415,,_testGetSet->_expectedAttribute = {};,9,<empty>,,1461,415,CPPASTProblemDeclaration,,<empty>
567927,UNKNOWN,416,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1462,416,CPPASTProblemDeclaration,,<empty>
567928,UNKNOWN,417,,));,80,<empty>,,1462,417,CPPASTProblemDeclaration,,<empty>
567929,UNKNOWN,418,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1463,418,CPPASTProblemDeclaration,,<empty>
567930,UNKNOWN,419,,"Log::Comment(L""Testing graphics 'Foreground Color Blue'"");",9,<empty>,,1465,419,CPPASTProblemDeclaration,,<empty>
567931,UNKNOWN,420,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundBlue;,9,<empty>,,1466,420,CPPASTProblemDeclaration,,<empty>
567932,UNKNOWN,421,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_BLUE);,9,<empty>,,1467,421,CPPASTProblemDeclaration,,<empty>
567933,UNKNOWN,422,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1468,422,CPPASTProblemDeclaration,,<empty>
567934,UNKNOWN,423,,));,80,<empty>,,1468,423,CPPASTProblemDeclaration,,<empty>
567935,UNKNOWN,424,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1469,424,CPPASTProblemDeclaration,,<empty>
567936,UNKNOWN,425,,"Log::Comment(L""Enabling brightness"");",9,<empty>,,1471,425,CPPASTProblemDeclaration,,<empty>
567937,UNKNOWN,426,,rgOptions[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,1472,426,CPPASTProblemDeclaration,,<empty>
567938,UNKNOWN,427,,_testGetSet->_expectedAttribute.SetIntense(true);,9,<empty>,,1473,427,CPPASTProblemDeclaration,,<empty>
567939,UNKNOWN,428,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1474,428,CPPASTProblemDeclaration,,<empty>
567940,UNKNOWN,429,,));,80,<empty>,,1474,429,CPPASTProblemDeclaration,,<empty>
567941,UNKNOWN,430,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1475,430,CPPASTProblemDeclaration,,<empty>
567942,UNKNOWN,431,,"Log::Comment(L""Testing graphics 'Foreground Color Bright Blue'"");",9,<empty>,,1477,431,CPPASTProblemDeclaration,,<empty>
567943,UNKNOWN,432,,rgOptions[0] = DispatchTypes::GraphicsOptions::BrightForegroundBlue;,9,<empty>,,1478,432,CPPASTProblemDeclaration,,<empty>
567944,UNKNOWN,433,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::BRIGHT_BLUE);,9,<empty>,,1479,433,CPPASTProblemDeclaration,,<empty>
567945,UNKNOWN,434,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1480,434,CPPASTProblemDeclaration,,<empty>
567946,UNKNOWN,435,,));,80,<empty>,,1480,435,CPPASTProblemDeclaration,,<empty>
567947,UNKNOWN,436,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1481,436,CPPASTProblemDeclaration,,<empty>
567948,UNKNOWN,437,,"Log::Comment(L""Testing graphics 'Foreground Color Blue, with brightness', brightness of 9x series doesn't affect brightness"");",9,<empty>,,1483,437,CPPASTProblemDeclaration,,<empty>
567949,UNKNOWN,438,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundBlue;,9,<empty>,,1484,438,CPPASTProblemDeclaration,,<empty>
567950,UNKNOWN,439,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_BLUE);,9,<empty>,,1485,439,CPPASTProblemDeclaration,,<empty>
567951,UNKNOWN,440,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1486,440,CPPASTProblemDeclaration,,<empty>
567952,UNKNOWN,441,,));,80,<empty>,,1486,441,CPPASTProblemDeclaration,,<empty>
567953,UNKNOWN,442,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1487,442,CPPASTProblemDeclaration,,<empty>
567954,UNKNOWN,443,,"Log::Comment(L""Testing graphics 'Foreground Color Green, with brightness'"");",9,<empty>,,1489,443,CPPASTProblemDeclaration,,<empty>
567955,UNKNOWN,444,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundGreen;,9,<empty>,,1490,444,CPPASTProblemDeclaration,,<empty>
567956,UNKNOWN,445,,_testGetSet->_expectedAttribute.SetIndexedForeground(TextColor::DARK_GREEN);,9,<empty>,,1491,445,CPPASTProblemDeclaration,,<empty>
567957,UNKNOWN,446,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,1492,446,CPPASTProblemDeclaration,,<empty>
567958,UNKNOWN,447,,));,80,<empty>,,1492,447,CPPASTProblemDeclaration,,<empty>
567959,UNKNOWN,448,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCurrentAttributes().IsIntense());,9,<empty>,,1493,448,CPPASTProblemDeclaration,,<empty>
567960,UNKNOWN,449,,},5,<empty>,,1494,449,CPPASTProblemDeclaration,,<empty>
567961,UNKNOWN,450,,"TEST_METHOD(DeviceStatusReportTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1496,450,CPPASTProblemDeclaration,,<empty>
567962,UNKNOWN,451,,"Log::Comment(L""Test 1: Verify failure when using bad status."");",9,<empty>,,1500,451,CPPASTProblemDeclaration,,<empty>
567963,UNKNOWN,452,,_testGetSet->PrepData();,9,<empty>,,1501,452,CPPASTProblemDeclaration,,<empty>
567964,UNKNOWN,453,,"VERIFY_IS_FALSE(_pDispatch->DeviceStatusReport((DispatchTypes::StatusType)-1, {}",9,<empty>,,1502,453,CPPASTProblemDeclaration,,<empty>
567965,UNKNOWN,454,,));,89,<empty>,,1502,454,CPPASTProblemDeclaration,,<empty>
567966,UNKNOWN,455,,},5,<empty>,,1503,455,CPPASTProblemDeclaration,,<empty>
567967,UNKNOWN,456,,"TEST_METHOD(DeviceStatus_OperatingStatusTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1505,456,CPPASTProblemDeclaration,,<empty>
567968,UNKNOWN,457,,"Log::Comment(L""Test 1: Verify good operating condition."");",9,<empty>,,1509,457,CPPASTProblemDeclaration,,<empty>
567969,UNKNOWN,458,,_testGetSet->PrepData();,9,<empty>,,1510,458,CPPASTProblemDeclaration,,<empty>
567970,UNKNOWN,459,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::OperatingStatus, {}",9,<empty>,,1511,459,CPPASTProblemDeclaration,,<empty>
567971,UNKNOWN,460,,));,101,<empty>,,1511,460,CPPASTProblemDeclaration,,<empty>
567972,UNKNOWN,461,,"_testGetSet->ValidateInputEvent(L""\x1b[0n"");",9,<empty>,,1513,461,CPPASTProblemDeclaration,,<empty>
567973,UNKNOWN,462,,},5,<empty>,,1514,462,CPPASTProblemDeclaration,,<empty>
567974,UNKNOWN,463,,"TEST_METHOD(DeviceStatus_CursorPositionReportTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1516,463,CPPASTProblemDeclaration,,<empty>
567975,UNKNOWN,464,,"{
            Log::Comment(L""Test 1: Verify normal cursor response position."");
            _testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);

            // start with the cursor position in the buffer.
            til::point coordCursorExpected{ _testGetSet->_textBuffer->GetCursor().GetPosition() };

            // to get to VT, we have to adjust it to its position relative to the viewport top.
            coordCursorExpected.y -= _testGetSet->_viewport.top;

            // Then note that VT is 1,1 based for the top left, so add 1. (The rest of the console uses 0,0 for array index bases.)
            coordCursorExpected.x++;
            coordCursorExpected.y++;

            VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::CursorPositionReport, {}));

            wchar_t pwszBuffer[50];

            swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\x1b[%d;%dR"", coordCursorExpected.y, coordCursorExpected.x);
            _testGetSet->ValidateInputEvent...",9,<empty>,,1520,464,CPPASTProblemDeclaration,,<empty>
567976,UNKNOWN,465,,"{
            Log::Comment(L""Test 2: Verify multiple CPRs with a cursor move between them"");
            _testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);

            // enable retention so that the two DSR responses don't delete each other
            auto retentionScope{ _testGetSet->EnableInputRetentionInScope() };

            // start with the cursor position in the buffer.
            til::point coordCursorExpectedFirst{ _testGetSet->_textBuffer->GetCursor().GetPosition() };

            // to get to VT, we have to adjust it to its position relative to the viewport top.
            coordCursorExpectedFirst -= til::point{ 0, _testGetSet->_viewport.top };

            // Then note that VT is 1,1 based for the top left, so add 1. (The rest of the console uses 0,0 for array index bases.)
            coordCursorExpectedFirst += til::point{ 1, 1 };

            VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::CursorPositionReport, {}));

           ...",9,<empty>,,1542,465,CPPASTProblemDeclaration,,<empty>
567977,UNKNOWN,466,,},5,<empty>,,1575,466,CPPASTProblemDeclaration,,<empty>
567978,UNKNOWN,467,,"TEST_METHOD(DeviceStatus_ExtendedCursorPositionReportTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1577,467,CPPASTProblemDeclaration,,<empty>
567979,UNKNOWN,468,,"Log::Comment(L""Test 1: Verify extended cursor position report."");",9,<empty>,,1581,468,CPPASTProblemDeclaration,,<empty>
567980,UNKNOWN,469,,"_testGetSet->PrepData(CursorX::XCENTER, CursorY::YCENTER);",9,<empty>,,1582,469,CPPASTProblemDeclaration,,<empty>
567994,UNKNOWN,472,,coordCursorExpected.y -= _testGetSet->_viewport.top;,9,<empty>,,1588,472,CPPASTProblemDeclaration,,<empty>
567995,UNKNOWN,473,,coordCursorExpected.x++;,9,<empty>,,1591,473,CPPASTProblemDeclaration,,<empty>
567996,UNKNOWN,474,,coordCursorExpected.y++;,9,<empty>,,1592,474,CPPASTProblemDeclaration,,<empty>
568001,UNKNOWN,477,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::ExtendedCursorPositionReport, {}",9,<empty>,,1597,477,CPPASTProblemDeclaration,,<empty>
568002,UNKNOWN,478,,));,114,<empty>,,1597,478,CPPASTProblemDeclaration,,<empty>
568006,UNKNOWN,481,,"swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\x1b[?%d;%d;%dR"", coordCursorExpected.y, coordCursorExpected.x, pageExpected);",9,<empty>,,1600,481,CPPASTProblemDeclaration,,<empty>
568007,UNKNOWN,482,,_testGetSet->ValidateInputEvent(pwszBuffer);,9,<empty>,,1601,482,CPPASTProblemDeclaration,,<empty>
568008,UNKNOWN,483,,},5,<empty>,,1602,483,CPPASTProblemDeclaration,,<empty>
568009,UNKNOWN,484,,"TEST_METHOD(DeviceStatus_MacroSpaceReportTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1604,484,CPPASTProblemDeclaration,,<empty>
568018,UNKNOWN,487,,"Log::Comment(L""Test 1: Verify maximum space available"");",9,<empty>,,1611,487,CPPASTProblemDeclaration,,<empty>
568019,UNKNOWN,488,,_testGetSet->PrepData();,9,<empty>,,1612,488,CPPASTProblemDeclaration,,<empty>
568020,UNKNOWN,489,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MacroSpaceReport, {}",9,<empty>,,1613,489,CPPASTProblemDeclaration,,<empty>
568021,UNKNOWN,490,,));,102,<empty>,,1613,490,CPPASTProblemDeclaration,,<empty>
568025,UNKNOWN,493,,"swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\x1b[%zu*{"", availableSpace);",9,<empty>,,1616,493,CPPASTProblemDeclaration,,<empty>
568026,UNKNOWN,494,,_testGetSet->ValidateInputEvent(pwszBuffer);,9,<empty>,,1617,494,CPPASTProblemDeclaration,,<empty>
568027,UNKNOWN,495,,"Log::Comment(L""Test 2: Verify space decrease"");",9,<empty>,,1619,495,CPPASTProblemDeclaration,,<empty>
568028,UNKNOWN,496,,_testGetSet->PrepData();,9,<empty>,,1620,496,CPPASTProblemDeclaration,,<empty>
568029,UNKNOWN,497,,"_stateMachine->ProcessString(L""\033P1;0;0!z12345678\033\\"");",9,<empty>,,1622,497,CPPASTProblemDeclaration,,<empty>
568030,UNKNOWN,498,,"_stateMachine->ProcessString(L""\033P2;0;0!z12345678\033\\"");",9,<empty>,,1623,498,CPPASTProblemDeclaration,,<empty>
568031,UNKNOWN,499,,"_stateMachine->ProcessString(L""\033P3;0;0!z12345678\033\\"");",9,<empty>,,1624,499,CPPASTProblemDeclaration,,<empty>
568032,UNKNOWN,500,,"_stateMachine->ProcessString(L""\033P4;0;0!z12345678\033\\"");",9,<empty>,,1625,500,CPPASTProblemDeclaration,,<empty>
568033,UNKNOWN,501,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MacroSpaceReport, {}",9,<empty>,,1626,501,CPPASTProblemDeclaration,,<empty>
568034,UNKNOWN,502,,));,102,<empty>,,1626,502,CPPASTProblemDeclaration,,<empty>
568035,UNKNOWN,503,,"swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\x1b[%zu*{"", availableSpace - 2);",9,<empty>,,1628,503,CPPASTProblemDeclaration,,<empty>
568036,UNKNOWN,504,,_testGetSet->ValidateInputEvent(pwszBuffer);,9,<empty>,,1629,504,CPPASTProblemDeclaration,,<empty>
568037,UNKNOWN,505,,"Log::Comment(L""Test 3: Verify space reset"");",9,<empty>,,1631,505,CPPASTProblemDeclaration,,<empty>
568038,UNKNOWN,506,,_testGetSet->PrepData();,9,<empty>,,1632,506,CPPASTProblemDeclaration,,<empty>
568039,UNKNOWN,507,,VERIFY_IS_TRUE(_pDispatch->HardReset());,9,<empty>,,1633,507,CPPASTProblemDeclaration,,<empty>
568040,UNKNOWN,508,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MacroSpaceReport, {}",9,<empty>,,1634,508,CPPASTProblemDeclaration,,<empty>
568041,UNKNOWN,509,,));,102,<empty>,,1634,509,CPPASTProblemDeclaration,,<empty>
568042,UNKNOWN,510,,"swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\x1b[%zu*{"", availableSpace);",9,<empty>,,1636,510,CPPASTProblemDeclaration,,<empty>
568043,UNKNOWN,511,,_testGetSet->ValidateInputEvent(pwszBuffer);,9,<empty>,,1637,511,CPPASTProblemDeclaration,,<empty>
568044,UNKNOWN,512,,},5,<empty>,,1638,512,CPPASTProblemDeclaration,,<empty>
568045,UNKNOWN,513,,"TEST_METHOD(DeviceStatus_MemoryChecksumReportTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1640,513,CPPASTProblemDeclaration,,<empty>
568046,UNKNOWN,514,,"Log::Comment(L""Test 1: Verify initial checksum is 0"");",9,<empty>,,1644,514,CPPASTProblemDeclaration,,<empty>
568047,UNKNOWN,515,,_testGetSet->PrepData();,9,<empty>,,1645,515,CPPASTProblemDeclaration,,<empty>
568048,UNKNOWN,516,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MemoryChecksum, 12));",9,<empty>,,1646,516,CPPASTProblemDeclaration,,<empty>
568049,UNKNOWN,517,,"_testGetSet->ValidateInputEvent(L""\033P12!~0000\033\\"");",9,<empty>,,1648,517,CPPASTProblemDeclaration,,<empty>
568050,UNKNOWN,518,,"Log::Comment(L""Test 2: Verify checksum after macros defined"");",9,<empty>,,1650,518,CPPASTProblemDeclaration,,<empty>
568051,UNKNOWN,519,,_testGetSet->PrepData();,9,<empty>,,1651,519,CPPASTProblemDeclaration,,<empty>
568052,UNKNOWN,520,,"_stateMachine->ProcessString(L""\033P1;0;0!zABCD\033\\"");",9,<empty>,,1653,520,CPPASTProblemDeclaration,,<empty>
568053,UNKNOWN,521,,"_stateMachine->ProcessString(L""\033P2;0;0!zabcd\033\\"");",9,<empty>,,1654,521,CPPASTProblemDeclaration,,<empty>
568054,UNKNOWN,522,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MemoryChecksum, 34));",9,<empty>,,1655,522,CPPASTProblemDeclaration,,<empty>
568082,UNKNOWN,527,,"swprintf_s(pwszBuffer, ARRAYSIZE(pwszBuffer), L""\033P34!~%04X\033\\"", checksum);",9,<empty>,,1660,527,CPPASTProblemDeclaration,,<empty>
568083,UNKNOWN,528,,_testGetSet->ValidateInputEvent(pwszBuffer);,9,<empty>,,1661,528,CPPASTProblemDeclaration,,<empty>
568084,UNKNOWN,529,,"Log::Comment(L""Test 3: Verify checksum resets to 0"");",9,<empty>,,1663,529,CPPASTProblemDeclaration,,<empty>
568085,UNKNOWN,530,,_testGetSet->PrepData();,9,<empty>,,1664,530,CPPASTProblemDeclaration,,<empty>
568086,UNKNOWN,531,,VERIFY_IS_TRUE(_pDispatch->HardReset());,9,<empty>,,1665,531,CPPASTProblemDeclaration,,<empty>
568087,UNKNOWN,532,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MemoryChecksum, 56));",9,<empty>,,1666,532,CPPASTProblemDeclaration,,<empty>
568088,UNKNOWN,533,,"_testGetSet->ValidateInputEvent(L""\033P56!~0000\033\\"");",9,<empty>,,1668,533,CPPASTProblemDeclaration,,<empty>
568089,UNKNOWN,534,,},5,<empty>,,1669,534,CPPASTProblemDeclaration,,<empty>
568090,UNKNOWN,535,,"TEST_METHOD(DeviceStatus_PrivateStatusTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1671,535,CPPASTProblemDeclaration,,<empty>
568091,UNKNOWN,536,,"Log::Comment(L""Test 1: Verify printer is not connected."");",9,<empty>,,1675,536,CPPASTProblemDeclaration,,<empty>
568092,UNKNOWN,537,,_testGetSet->PrepData();,9,<empty>,,1676,537,CPPASTProblemDeclaration,,<empty>
568093,UNKNOWN,538,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::PrinterStatus, {}",9,<empty>,,1677,538,CPPASTProblemDeclaration,,<empty>
568094,UNKNOWN,539,,));,99,<empty>,,1677,539,CPPASTProblemDeclaration,,<empty>
568095,UNKNOWN,540,,"_testGetSet->ValidateInputEvent(L""\x1b[?13n"");",9,<empty>,,1678,540,CPPASTProblemDeclaration,,<empty>
568096,UNKNOWN,541,,"Log::Comment(L""Test 2: Verify UDKs are not supported."");",9,<empty>,,1680,541,CPPASTProblemDeclaration,,<empty>
568097,UNKNOWN,542,,_testGetSet->PrepData();,9,<empty>,,1681,542,CPPASTProblemDeclaration,,<empty>
568098,UNKNOWN,543,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::UserDefinedKeys, {}",9,<empty>,,1682,543,CPPASTProblemDeclaration,,<empty>
568099,UNKNOWN,544,,));,101,<empty>,,1682,544,CPPASTProblemDeclaration,,<empty>
568100,UNKNOWN,545,,"_testGetSet->ValidateInputEvent(L""\x1b[?23n"");",9,<empty>,,1683,545,CPPASTProblemDeclaration,,<empty>
568101,UNKNOWN,546,,"Log::Comment(L""Test 3: Verify PC keyboard with unknown dialect."");",9,<empty>,,1685,546,CPPASTProblemDeclaration,,<empty>
568102,UNKNOWN,547,,_testGetSet->PrepData();,9,<empty>,,1686,547,CPPASTProblemDeclaration,,<empty>
568103,UNKNOWN,548,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::KeyboardStatus, {}",9,<empty>,,1687,548,CPPASTProblemDeclaration,,<empty>
568104,UNKNOWN,549,,));,100,<empty>,,1687,549,CPPASTProblemDeclaration,,<empty>
568105,UNKNOWN,550,,"_testGetSet->ValidateInputEvent(L""\x1b[?27;0;0;5n"");",9,<empty>,,1688,550,CPPASTProblemDeclaration,,<empty>
568106,UNKNOWN,551,,"Log::Comment(L""Test 4: Verify locator is not connected."");",9,<empty>,,1690,551,CPPASTProblemDeclaration,,<empty>
568107,UNKNOWN,552,,_testGetSet->PrepData();,9,<empty>,,1691,552,CPPASTProblemDeclaration,,<empty>
568108,UNKNOWN,553,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::LocatorStatus, {}",9,<empty>,,1692,553,CPPASTProblemDeclaration,,<empty>
568109,UNKNOWN,554,,));,99,<empty>,,1692,554,CPPASTProblemDeclaration,,<empty>
568110,UNKNOWN,555,,"_testGetSet->ValidateInputEvent(L""\x1b[?53n"");",9,<empty>,,1693,555,CPPASTProblemDeclaration,,<empty>
568111,UNKNOWN,556,,"Log::Comment(L""Test 5: Verify locator type is unknown."");",9,<empty>,,1695,556,CPPASTProblemDeclaration,,<empty>
568112,UNKNOWN,557,,_testGetSet->PrepData();,9,<empty>,,1696,557,CPPASTProblemDeclaration,,<empty>
568113,UNKNOWN,558,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::LocatorIdentity, {}",9,<empty>,,1697,558,CPPASTProblemDeclaration,,<empty>
568114,UNKNOWN,559,,));,101,<empty>,,1697,559,CPPASTProblemDeclaration,,<empty>
568115,UNKNOWN,560,,"_testGetSet->ValidateInputEvent(L""\x1b[?57;0n"");",9,<empty>,,1698,560,CPPASTProblemDeclaration,,<empty>
568116,UNKNOWN,561,,"Log::Comment(L""Test 6: Verify terminal is ready."");",9,<empty>,,1700,561,CPPASTProblemDeclaration,,<empty>
568117,UNKNOWN,562,,_testGetSet->PrepData();,9,<empty>,,1701,562,CPPASTProblemDeclaration,,<empty>
568118,UNKNOWN,563,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::DataIntegrity, {}",9,<empty>,,1702,563,CPPASTProblemDeclaration,,<empty>
568119,UNKNOWN,564,,));,99,<empty>,,1702,564,CPPASTProblemDeclaration,,<empty>
568120,UNKNOWN,565,,"_testGetSet->ValidateInputEvent(L""\x1b[?70n"");",9,<empty>,,1703,565,CPPASTProblemDeclaration,,<empty>
568121,UNKNOWN,566,,"Log::Comment(L""Test 7: Verify multiple sessions are not supported."");",9,<empty>,,1705,566,CPPASTProblemDeclaration,,<empty>
568122,UNKNOWN,567,,_testGetSet->PrepData();,9,<empty>,,1706,567,CPPASTProblemDeclaration,,<empty>
568123,UNKNOWN,568,,"VERIFY_IS_TRUE(_pDispatch->DeviceStatusReport(DispatchTypes::StatusType::MultipleSessionStatus, {}",9,<empty>,,1707,568,CPPASTProblemDeclaration,,<empty>
568124,UNKNOWN,569,,));,107,<empty>,,1707,569,CPPASTProblemDeclaration,,<empty>
568125,UNKNOWN,570,,"_testGetSet->ValidateInputEvent(L""\x1b[?83n"");",9,<empty>,,1708,570,CPPASTProblemDeclaration,,<empty>
568126,UNKNOWN,571,,},5,<empty>,,1709,571,CPPASTProblemDeclaration,,<empty>
568127,UNKNOWN,572,,"TEST_METHOD(DeviceAttributesTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1711,572,CPPASTProblemDeclaration,,<empty>
568128,UNKNOWN,573,,"Log::Comment(L""Test 1: Verify normal response."");",9,<empty>,,1715,573,CPPASTProblemDeclaration,,<empty>
568129,UNKNOWN,574,,_testGetSet->PrepData();,9,<empty>,,1716,574,CPPASTProblemDeclaration,,<empty>
568130,UNKNOWN,575,,VERIFY_IS_TRUE(_pDispatch->DeviceAttributes());,9,<empty>,,1717,575,CPPASTProblemDeclaration,,<empty>
568135,UNKNOWN,578,,_testGetSet->ValidateInputEvent(pwszExpectedResponse);,9,<empty>,,1720,578,CPPASTProblemDeclaration,,<empty>
568136,UNKNOWN,579,,"Log::Comment(L""Test 2: Verify failure when ReturnResponse doesn't work."");",9,<empty>,,1722,579,CPPASTProblemDeclaration,,<empty>
568137,UNKNOWN,580,,_testGetSet->PrepData();,9,<empty>,,1723,580,CPPASTProblemDeclaration,,<empty>
568138,UNKNOWN,581,,_testGetSet->_returnResponseResult = FALSE;,9,<empty>,,1724,581,CPPASTProblemDeclaration,,<empty>
568139,UNKNOWN,582,,"VERIFY_THROWS(_pDispatch->DeviceAttributes(), std::exception);",9,<empty>,,1726,582,CPPASTProblemDeclaration,,<empty>
568140,UNKNOWN,583,,},5,<empty>,,1727,583,CPPASTProblemDeclaration,,<empty>
568141,UNKNOWN,584,,"TEST_METHOD(SecondaryDeviceAttributesTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1729,584,CPPASTProblemDeclaration,,<empty>
568142,UNKNOWN,585,,"Log::Comment(L""Test 1: Verify normal response."");",9,<empty>,,1733,585,CPPASTProblemDeclaration,,<empty>
568143,UNKNOWN,586,,_testGetSet->PrepData();,9,<empty>,,1734,586,CPPASTProblemDeclaration,,<empty>
568144,UNKNOWN,587,,VERIFY_IS_TRUE(_pDispatch->SecondaryDeviceAttributes());,9,<empty>,,1735,587,CPPASTProblemDeclaration,,<empty>
568149,UNKNOWN,590,,_testGetSet->ValidateInputEvent(pwszExpectedResponse);,9,<empty>,,1738,590,CPPASTProblemDeclaration,,<empty>
568150,UNKNOWN,591,,"Log::Comment(L""Test 2: Verify failure when ReturnResponse doesn't work."");",9,<empty>,,1740,591,CPPASTProblemDeclaration,,<empty>
568151,UNKNOWN,592,,_testGetSet->PrepData();,9,<empty>,,1741,592,CPPASTProblemDeclaration,,<empty>
568152,UNKNOWN,593,,_testGetSet->_returnResponseResult = FALSE;,9,<empty>,,1742,593,CPPASTProblemDeclaration,,<empty>
568153,UNKNOWN,594,,"VERIFY_THROWS(_pDispatch->SecondaryDeviceAttributes(), std::exception);",9,<empty>,,1744,594,CPPASTProblemDeclaration,,<empty>
568154,UNKNOWN,595,,},5,<empty>,,1745,595,CPPASTProblemDeclaration,,<empty>
568155,UNKNOWN,596,,"TEST_METHOD(TertiaryDeviceAttributesTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1747,596,CPPASTProblemDeclaration,,<empty>
568156,UNKNOWN,597,,"Log::Comment(L""Test 1: Verify normal response."");",9,<empty>,,1751,597,CPPASTProblemDeclaration,,<empty>
568157,UNKNOWN,598,,_testGetSet->PrepData();,9,<empty>,,1752,598,CPPASTProblemDeclaration,,<empty>
568158,UNKNOWN,599,,VERIFY_IS_TRUE(_pDispatch->TertiaryDeviceAttributes());,9,<empty>,,1753,599,CPPASTProblemDeclaration,,<empty>
568163,UNKNOWN,602,,_testGetSet->ValidateInputEvent(pwszExpectedResponse);,9,<empty>,,1756,602,CPPASTProblemDeclaration,,<empty>
568164,UNKNOWN,603,,"Log::Comment(L""Test 2: Verify failure when ReturnResponse doesn't work."");",9,<empty>,,1758,603,CPPASTProblemDeclaration,,<empty>
568165,UNKNOWN,604,,_testGetSet->PrepData();,9,<empty>,,1759,604,CPPASTProblemDeclaration,,<empty>
568166,UNKNOWN,605,,_testGetSet->_returnResponseResult = FALSE;,9,<empty>,,1760,605,CPPASTProblemDeclaration,,<empty>
568167,UNKNOWN,606,,"VERIFY_THROWS(_pDispatch->TertiaryDeviceAttributes(), std::exception);",9,<empty>,,1762,606,CPPASTProblemDeclaration,,<empty>
568168,UNKNOWN,607,,},5,<empty>,,1763,607,CPPASTProblemDeclaration,,<empty>
568169,UNKNOWN,608,,"TEST_METHOD(RequestTerminalParametersTests)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,1765,608,CPPASTProblemDeclaration,,<empty>
568170,UNKNOWN,609,,"Log::Comment(L""Test 1: Verify response for unsolicited permission."");",9,<empty>,,1769,609,CPPASTProblemDeclaration,,<empty>
568171,UNKNOWN,610,,_testGetSet->PrepData();,9,<empty>,,1770,610,CPPASTProblemDeclaration,,<empty>
568172,UNKNOWN,611,,VERIFY_IS_TRUE(_pDispatch->RequestTerminalParameters(DispatchTypes::ReportingPermission::Unsolicited));,9,<empty>,,1771,611,CPPASTProblemDeclaration,,<empty>
568173,UNKNOWN,612,,"_testGetSet->ValidateInputEvent(L""\x1b[2;1;1;128;128;1;0x"");",9,<empty>,,1772,612,CPPASTProblemDeclaration,,<empty>
568174,UNKNOWN,613,,"Log::Comment(L""Test 2: Verify response for solicited permission."");",9,<empty>,,1774,613,CPPASTProblemDeclaration,,<empty>
568175,UNKNOWN,614,,_testGetSet->PrepData();,9,<empty>,,1775,614,CPPASTProblemDeclaration,,<empty>
568176,UNKNOWN,615,,VERIFY_IS_TRUE(_pDispatch->RequestTerminalParameters(DispatchTypes::ReportingPermission::Solicited));,9,<empty>,,1776,615,CPPASTProblemDeclaration,,<empty>
568177,UNKNOWN,616,,"_testGetSet->ValidateInputEvent(L""\x1b[3;1;1;128;128;1;0x"");",9,<empty>,,1777,616,CPPASTProblemDeclaration,,<empty>
568178,UNKNOWN,617,,"Log::Comment(L""Test 3: Verify failure with invalid parameter."");",9,<empty>,,1779,617,CPPASTProblemDeclaration,,<empty>
568179,UNKNOWN,618,,_testGetSet->PrepData();,9,<empty>,,1780,618,CPPASTProblemDeclaration,,<empty>
568180,UNKNOWN,619,,VERIFY_IS_FALSE(_pDispatch->RequestTerminalParameters((DispatchTypes::ReportingPermission)2));,9,<empty>,,1781,619,CPPASTProblemDeclaration,,<empty>
568181,UNKNOWN,620,,"Log::Comment(L""Test 4: Verify failure when ReturnResponse doesn't work."");",9,<empty>,,1783,620,CPPASTProblemDeclaration,,<empty>
568182,UNKNOWN,621,,_testGetSet->PrepData();,9,<empty>,,1784,621,CPPASTProblemDeclaration,,<empty>
568183,UNKNOWN,622,,_testGetSet->_returnResponseResult = FALSE;,9,<empty>,,1785,622,CPPASTProblemDeclaration,,<empty>
568184,UNKNOWN,623,,"VERIFY_THROWS(_pDispatch->RequestTerminalParameters(DispatchTypes::ReportingPermission::Unsolicited), std::exception);",9,<empty>,,1786,623,CPPASTProblemDeclaration,,<empty>
568185,UNKNOWN,624,,},5,<empty>,,1787,624,CPPASTProblemDeclaration,,<empty>
568186,UNKNOWN,625,,"TEST_METHOD(RequestSettingsTests)
    {
        const auto requestSetting = [=](const std::wstring_view settingId = {}",5,<empty>,,1789,625,CPPASTProblemDeclaration,,<empty>
568187,UNKNOWN,626,,") {
            const auto stringHandler = _pDispatch->RequestSetting();
            for (auto ch : settingId)
            {
                stringHandler(ch);
            }
            stringHandler(L'\033'); // String terminator
        };",79,<empty>,,1791,626,CPPASTProblemDeclaration,,<empty>
568188,UNKNOWN,627,,"Log::Comment(L""Requesting DECSTBM margins (5 to 10)."");",9,<empty>,,1800,627,CPPASTProblemDeclaration,,<empty>
568189,UNKNOWN,628,,_testGetSet->PrepData();,9,<empty>,,1801,628,CPPASTProblemDeclaration,,<empty>
568190,UNKNOWN,629,,"_pDispatch->SetTopBottomScrollingMargins(5, 10);",9,<empty>,,1802,629,CPPASTProblemDeclaration,,<empty>
568191,UNKNOWN,630,,"requestSetting(L""r"");",9,<empty>,,1803,630,CPPASTProblemDeclaration,,<empty>
568192,UNKNOWN,631,,"_testGetSet->ValidateInputEvent(L""\033P1$r5;10r\033\\"");",9,<empty>,,1804,631,CPPASTProblemDeclaration,,<empty>
568193,UNKNOWN,632,,"Log::Comment(L""Requesting DECSTBM margins (full screen)."");",9,<empty>,,1806,632,CPPASTProblemDeclaration,,<empty>
568194,UNKNOWN,633,,_testGetSet->PrepData();,9,<empty>,,1807,633,CPPASTProblemDeclaration,,<empty>
568195,UNKNOWN,634,,_testGetSet->_viewport.bottom = _testGetSet->_viewport.top + 25;,9,<empty>,,1809,634,CPPASTProblemDeclaration,,<empty>
568196,UNKNOWN,635,,"_pDispatch->SetTopBottomScrollingMargins(0, 0);",9,<empty>,,1810,635,CPPASTProblemDeclaration,,<empty>
568197,UNKNOWN,636,,"requestSetting(L""r"");",9,<empty>,,1811,636,CPPASTProblemDeclaration,,<empty>
568198,UNKNOWN,637,,"_testGetSet->ValidateInputEvent(L""\033P1$r1;25r\033\\"");",9,<empty>,,1812,637,CPPASTProblemDeclaration,,<empty>
568199,UNKNOWN,638,,"Log::Comment(L""Requesting DECSLRM margins (5 to 10)."");",9,<empty>,,1814,638,CPPASTProblemDeclaration,,<empty>
568200,UNKNOWN,639,,_testGetSet->PrepData();,9,<empty>,,1815,639,CPPASTProblemDeclaration,,<empty>
568201,UNKNOWN,640,,_pDispatch->SetMode(DispatchTypes::DECLRMM_LeftRightMarginMode);,9,<empty>,,1817,640,CPPASTProblemDeclaration,,<empty>
568202,UNKNOWN,641,,"_pDispatch->SetLeftRightScrollingMargins(5, 10);",9,<empty>,,1818,641,CPPASTProblemDeclaration,,<empty>
568203,UNKNOWN,642,,"requestSetting(L""s"");",9,<empty>,,1819,642,CPPASTProblemDeclaration,,<empty>
568204,UNKNOWN,643,,"_testGetSet->ValidateInputEvent(L""\033P1$r5;10s\033\\"");",9,<empty>,,1820,643,CPPASTProblemDeclaration,,<empty>
568205,UNKNOWN,644,,"Log::Comment(L""Requesting DECSLRM margins (full width)."");",9,<empty>,,1822,644,CPPASTProblemDeclaration,,<empty>
568206,UNKNOWN,645,,_testGetSet->PrepData();,9,<empty>,,1823,645,CPPASTProblemDeclaration,,<empty>
568207,UNKNOWN,646,,"_pDispatch->SetLeftRightScrollingMargins(0, 0);",9,<empty>,,1824,646,CPPASTProblemDeclaration,,<empty>
568208,UNKNOWN,647,,"requestSetting(L""s"");",9,<empty>,,1825,647,CPPASTProblemDeclaration,,<empty>
568209,UNKNOWN,648,,"_testGetSet->ValidateInputEvent(L""\033P1$r1;100s\033\\"");",9,<empty>,,1826,648,CPPASTProblemDeclaration,,<empty>
568210,UNKNOWN,649,,_pDispatch->ResetMode(DispatchTypes::DECLRMM_LeftRightMarginMode);,9,<empty>,,1828,649,CPPASTProblemDeclaration,,<empty>
568211,UNKNOWN,650,,"Log::Comment(L""Requesting SGR attributes (default)."");",9,<empty>,,1830,650,CPPASTProblemDeclaration,,<empty>
568212,UNKNOWN,651,,_testGetSet->PrepData();,9,<empty>,,1831,651,CPPASTProblemDeclaration,,<empty>
568217,UNKNOWN,654,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1833,654,CPPASTProblemDeclaration,,<empty>
568218,UNKNOWN,655,,"requestSetting(L""m"");",9,<empty>,,1834,655,CPPASTProblemDeclaration,,<empty>
568219,UNKNOWN,656,,"_testGetSet->ValidateInputEvent(L""\033P1$r0m\033\\"");",9,<empty>,,1835,656,CPPASTProblemDeclaration,,<empty>
568220,UNKNOWN,657,,"Log::Comment(L""Requesting SGR attributes (intense, underlined, reversed)."");",9,<empty>,,1837,657,CPPASTProblemDeclaration,,<empty>
568221,UNKNOWN,658,,_testGetSet->PrepData();,9,<empty>,,1838,658,CPPASTProblemDeclaration,,<empty>
568226,UNKNOWN,661,,attribute.SetIntense(true);,9,<empty>,,1840,661,CPPASTProblemDeclaration,,<empty>
568227,UNKNOWN,662,,attribute.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);,9,<empty>,,1841,662,CPPASTProblemDeclaration,,<empty>
568228,UNKNOWN,663,,attribute.SetReverseVideo(true);,9,<empty>,,1842,663,CPPASTProblemDeclaration,,<empty>
568229,UNKNOWN,664,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1843,664,CPPASTProblemDeclaration,,<empty>
568230,UNKNOWN,665,,"requestSetting(L""m"");",9,<empty>,,1844,665,CPPASTProblemDeclaration,,<empty>
568231,UNKNOWN,666,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;1;4;7m\033\\"");",9,<empty>,,1845,666,CPPASTProblemDeclaration,,<empty>
568232,UNKNOWN,667,,"Log::Comment(L""Requesting SGR attributes (extended underline style)."");",9,<empty>,,1847,667,CPPASTProblemDeclaration,,<empty>
568233,UNKNOWN,668,,_testGetSet->PrepData();,9,<empty>,,1848,668,CPPASTProblemDeclaration,,<empty>
568238,UNKNOWN,671,,attribute.SetUnderlineStyle(UnderlineStyle::CurlyUnderlined);,9,<empty>,,1850,671,CPPASTProblemDeclaration,,<empty>
568239,UNKNOWN,672,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1851,672,CPPASTProblemDeclaration,,<empty>
568240,UNKNOWN,673,,"requestSetting(L""m"");",9,<empty>,,1852,673,CPPASTProblemDeclaration,,<empty>
568241,UNKNOWN,674,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;4:3m\033\\"");",9,<empty>,,1853,674,CPPASTProblemDeclaration,,<empty>
568242,UNKNOWN,675,,"Log::Comment(L""Requesting SGR attributes (faint, blinking, invisible)."");",9,<empty>,,1855,675,CPPASTProblemDeclaration,,<empty>
568243,UNKNOWN,676,,_testGetSet->PrepData();,9,<empty>,,1856,676,CPPASTProblemDeclaration,,<empty>
568248,UNKNOWN,679,,attribute.SetFaint(true);,9,<empty>,,1858,679,CPPASTProblemDeclaration,,<empty>
568249,UNKNOWN,680,,attribute.SetBlinking(true);,9,<empty>,,1859,680,CPPASTProblemDeclaration,,<empty>
568250,UNKNOWN,681,,attribute.SetInvisible(true);,9,<empty>,,1860,681,CPPASTProblemDeclaration,,<empty>
568251,UNKNOWN,682,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1861,682,CPPASTProblemDeclaration,,<empty>
568252,UNKNOWN,683,,"requestSetting(L""m"");",9,<empty>,,1862,683,CPPASTProblemDeclaration,,<empty>
568253,UNKNOWN,684,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;2;5;8m\033\\"");",9,<empty>,,1863,684,CPPASTProblemDeclaration,,<empty>
568254,UNKNOWN,685,,"Log::Comment(L""Requesting SGR attributes (italic, crossed-out)."");",9,<empty>,,1865,685,CPPASTProblemDeclaration,,<empty>
568255,UNKNOWN,686,,_testGetSet->PrepData();,9,<empty>,,1866,686,CPPASTProblemDeclaration,,<empty>
568260,UNKNOWN,689,,attribute.SetItalic(true);,9,<empty>,,1868,689,CPPASTProblemDeclaration,,<empty>
568261,UNKNOWN,690,,attribute.SetCrossedOut(true);,9,<empty>,,1869,690,CPPASTProblemDeclaration,,<empty>
568262,UNKNOWN,691,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1870,691,CPPASTProblemDeclaration,,<empty>
568263,UNKNOWN,692,,"requestSetting(L""m"");",9,<empty>,,1871,692,CPPASTProblemDeclaration,,<empty>
568264,UNKNOWN,693,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;3;9m\033\\"");",9,<empty>,,1872,693,CPPASTProblemDeclaration,,<empty>
568265,UNKNOWN,694,,"Log::Comment(L""Requesting SGR attributes (doubly underlined, overlined)."");",9,<empty>,,1874,694,CPPASTProblemDeclaration,,<empty>
568266,UNKNOWN,695,,_testGetSet->PrepData();,9,<empty>,,1875,695,CPPASTProblemDeclaration,,<empty>
568271,UNKNOWN,698,,attribute.SetUnderlineStyle(UnderlineStyle::DoublyUnderlined);,9,<empty>,,1877,698,CPPASTProblemDeclaration,,<empty>
568272,UNKNOWN,699,,attribute.SetOverlined(true);,9,<empty>,,1878,699,CPPASTProblemDeclaration,,<empty>
568273,UNKNOWN,700,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1879,700,CPPASTProblemDeclaration,,<empty>
568274,UNKNOWN,701,,"requestSetting(L""m"");",9,<empty>,,1880,701,CPPASTProblemDeclaration,,<empty>
568275,UNKNOWN,702,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;21;53m\033\\"");",9,<empty>,,1881,702,CPPASTProblemDeclaration,,<empty>
568276,UNKNOWN,703,,"Log::Comment(L""Requesting SGR attributes (standard colors)."");",9,<empty>,,1883,703,CPPASTProblemDeclaration,,<empty>
568277,UNKNOWN,704,,_testGetSet->PrepData();,9,<empty>,,1884,704,CPPASTProblemDeclaration,,<empty>
568282,UNKNOWN,707,,attribute.SetIndexedForeground(TextColor::DARK_YELLOW);,9,<empty>,,1886,707,CPPASTProblemDeclaration,,<empty>
568283,UNKNOWN,708,,attribute.SetIndexedBackground(TextColor::DARK_CYAN);,9,<empty>,,1887,708,CPPASTProblemDeclaration,,<empty>
568284,UNKNOWN,709,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1888,709,CPPASTProblemDeclaration,,<empty>
568285,UNKNOWN,710,,"requestSetting(L""m"");",9,<empty>,,1889,710,CPPASTProblemDeclaration,,<empty>
568286,UNKNOWN,711,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;33;46m\033\\"");",9,<empty>,,1890,711,CPPASTProblemDeclaration,,<empty>
568287,UNKNOWN,712,,"Log::Comment(L""Requesting SGR attributes (AIX colors)."");",9,<empty>,,1892,712,CPPASTProblemDeclaration,,<empty>
568288,UNKNOWN,713,,_testGetSet->PrepData();,9,<empty>,,1893,713,CPPASTProblemDeclaration,,<empty>
568293,UNKNOWN,716,,attribute.SetIndexedForeground(TextColor::BRIGHT_CYAN);,9,<empty>,,1895,716,CPPASTProblemDeclaration,,<empty>
568294,UNKNOWN,717,,attribute.SetIndexedBackground(TextColor::BRIGHT_YELLOW);,9,<empty>,,1896,717,CPPASTProblemDeclaration,,<empty>
568295,UNKNOWN,718,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1897,718,CPPASTProblemDeclaration,,<empty>
568296,UNKNOWN,719,,"requestSetting(L""m"");",9,<empty>,,1898,719,CPPASTProblemDeclaration,,<empty>
568297,UNKNOWN,720,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;96;103m\033\\"");",9,<empty>,,1899,720,CPPASTProblemDeclaration,,<empty>
568298,UNKNOWN,721,,"Log::Comment(L""Requesting SGR attributes (ITU indexed colors)."");",9,<empty>,,1901,721,CPPASTProblemDeclaration,,<empty>
568299,UNKNOWN,722,,_testGetSet->PrepData();,9,<empty>,,1902,722,CPPASTProblemDeclaration,,<empty>
568304,UNKNOWN,725,,attribute.SetIndexedForeground256(123);,9,<empty>,,1904,725,CPPASTProblemDeclaration,,<empty>
568305,UNKNOWN,726,,attribute.SetIndexedBackground256(45);,9,<empty>,,1905,726,CPPASTProblemDeclaration,,<empty>
568306,UNKNOWN,727,,"attribute.SetUnderlineColor(TextColor{ 128, true }",9,<empty>,,1906,727,CPPASTProblemDeclaration,,<empty>
568307,UNKNOWN,728,,);,59,<empty>,,1906,728,CPPASTProblemDeclaration,,<empty>
568308,UNKNOWN,729,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1907,729,CPPASTProblemDeclaration,,<empty>
568309,UNKNOWN,730,,"requestSetting(L""m"");",9,<empty>,,1908,730,CPPASTProblemDeclaration,,<empty>
568310,UNKNOWN,731,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;38:5:123;48:5:45;58:5:128m\033\\"");",9,<empty>,,1909,731,CPPASTProblemDeclaration,,<empty>
568311,UNKNOWN,732,,"Log::Comment(L""Requesting SGR attributes (ITU RGB colors)."");",9,<empty>,,1911,732,CPPASTProblemDeclaration,,<empty>
568312,UNKNOWN,733,,_testGetSet->PrepData();,9,<empty>,,1912,733,CPPASTProblemDeclaration,,<empty>
568317,UNKNOWN,736,,"attribute.SetForeground(RGB(12, 34, 56));",9,<empty>,,1914,736,CPPASTProblemDeclaration,,<empty>
568318,UNKNOWN,737,,"attribute.SetBackground(RGB(65, 43, 21));",9,<empty>,,1915,737,CPPASTProblemDeclaration,,<empty>
568319,UNKNOWN,738,,"attribute.SetUnderlineColor(RGB(128, 222, 45));",9,<empty>,,1916,738,CPPASTProblemDeclaration,,<empty>
568320,UNKNOWN,739,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1917,739,CPPASTProblemDeclaration,,<empty>
568321,UNKNOWN,740,,"requestSetting(L""m"");",9,<empty>,,1918,740,CPPASTProblemDeclaration,,<empty>
568322,UNKNOWN,741,,"_testGetSet->ValidateInputEvent(L""\033P1$r0;38:2::12:34:56;48:2::65:43:21;58:2::128:222:45m\033\\"");",9,<empty>,,1919,741,CPPASTProblemDeclaration,,<empty>
568323,UNKNOWN,742,,"Log::Comment(L""Requesting DECSCA attributes (unprotected)."");",9,<empty>,,1921,742,CPPASTProblemDeclaration,,<empty>
568324,UNKNOWN,743,,_testGetSet->PrepData();,9,<empty>,,1922,743,CPPASTProblemDeclaration,,<empty>
568329,UNKNOWN,746,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1924,746,CPPASTProblemDeclaration,,<empty>
568330,UNKNOWN,747,,"requestSetting(L""\""q"");",9,<empty>,,1925,747,CPPASTProblemDeclaration,,<empty>
568331,UNKNOWN,748,,"_testGetSet->ValidateInputEvent(L""\033P1$r0\""q\033\\"");",9,<empty>,,1926,748,CPPASTProblemDeclaration,,<empty>
568332,UNKNOWN,749,,"Log::Comment(L""Requesting DECSCA attributes (protected)."");",9,<empty>,,1928,749,CPPASTProblemDeclaration,,<empty>
568333,UNKNOWN,750,,_testGetSet->PrepData();,9,<empty>,,1929,750,CPPASTProblemDeclaration,,<empty>
568338,UNKNOWN,753,,attribute.SetProtected(true);,9,<empty>,,1931,753,CPPASTProblemDeclaration,,<empty>
568339,UNKNOWN,754,,_testGetSet->_textBuffer->SetCurrentAttributes(attribute);,9,<empty>,,1932,754,CPPASTProblemDeclaration,,<empty>
568340,UNKNOWN,755,,"requestSetting(L""\""q"");",9,<empty>,,1933,755,CPPASTProblemDeclaration,,<empty>
568341,UNKNOWN,756,,"_testGetSet->ValidateInputEvent(L""\033P1$r1\""q\033\\"");",9,<empty>,,1934,756,CPPASTProblemDeclaration,,<empty>
568342,UNKNOWN,757,,_testGetSet->PrepData();,9,<empty>,,1937,757,CPPASTProblemDeclaration,,<empty>
568351,UNKNOWN,760,,"renderSettings.SetColorAliasIndex(ColorAlias::DefaultForeground, 3);",9,<empty>,,1939,760,CPPASTProblemDeclaration,,<empty>
568352,UNKNOWN,761,,"renderSettings.SetColorAliasIndex(ColorAlias::DefaultBackground, 5);",9,<empty>,,1940,761,CPPASTProblemDeclaration,,<empty>
568353,UNKNOWN,762,,"renderSettings.SetColorAliasIndex(ColorAlias::FrameForeground, 4);",9,<empty>,,1941,762,CPPASTProblemDeclaration,,<empty>
568354,UNKNOWN,763,,"renderSettings.SetColorAliasIndex(ColorAlias::FrameBackground, 6);",9,<empty>,,1942,763,CPPASTProblemDeclaration,,<empty>
568355,UNKNOWN,764,,"Log::Comment(L""Requesting DECAC colors (default)."");",9,<empty>,,1944,764,CPPASTProblemDeclaration,,<empty>
568356,UNKNOWN,765,,"requestSetting(L"",|"");",9,<empty>,,1945,765,CPPASTProblemDeclaration,,<empty>
568357,UNKNOWN,766,,"_testGetSet->ValidateInputEvent(L""\033P1$r1;3;5,|\033\\"");",9,<empty>,,1946,766,CPPASTProblemDeclaration,,<empty>
568358,UNKNOWN,767,,"Log::Comment(L""Requesting DECAC colors (normal text)."");",9,<empty>,,1948,767,CPPASTProblemDeclaration,,<empty>
568359,UNKNOWN,768,,"requestSetting(L""1,|"");",9,<empty>,,1949,768,CPPASTProblemDeclaration,,<empty>
568360,UNKNOWN,769,,"_testGetSet->ValidateInputEvent(L""\033P1$r1;3;5,|\033\\"");",9,<empty>,,1950,769,CPPASTProblemDeclaration,,<empty>
568361,UNKNOWN,770,,"Log::Comment(L""Requesting DECAC colors (window frame)."");",9,<empty>,,1952,770,CPPASTProblemDeclaration,,<empty>
568362,UNKNOWN,771,,"requestSetting(L""2,|"");",9,<empty>,,1953,771,CPPASTProblemDeclaration,,<empty>
568363,UNKNOWN,772,,"_testGetSet->ValidateInputEvent(L""\033P1$r2;4;6,|\033\\"");",9,<empty>,,1954,772,CPPASTProblemDeclaration,,<empty>
568364,UNKNOWN,773,,"Log::Comment(L""Requesting DECAC colors (invalid item)."");",9,<empty>,,1956,773,CPPASTProblemDeclaration,,<empty>
568365,UNKNOWN,774,,"requestSetting(L""3,|"");",9,<empty>,,1957,774,CPPASTProblemDeclaration,,<empty>
568366,UNKNOWN,775,,"_testGetSet->ValidateInputEvent(L""\033P0$r\033\\"");",9,<empty>,,1958,775,CPPASTProblemDeclaration,,<empty>
568367,UNKNOWN,776,,"Log::Comment(L""Requesting an unsupported setting."");",9,<empty>,,1960,776,CPPASTProblemDeclaration,,<empty>
568368,UNKNOWN,777,,_testGetSet->PrepData();,9,<empty>,,1961,777,CPPASTProblemDeclaration,,<empty>
568369,UNKNOWN,778,,"requestSetting(L""x"");",9,<empty>,,1962,778,CPPASTProblemDeclaration,,<empty>
568370,UNKNOWN,779,,"_testGetSet->ValidateInputEvent(L""\033P0$r\033\\"");",9,<empty>,,1963,779,CPPASTProblemDeclaration,,<empty>
568371,UNKNOWN,780,,},5,<empty>,,1964,780,CPPASTProblemDeclaration,,<empty>
568372,UNKNOWN,781,,"TEST_METHOD(RequestStandardModeTests)
    {
        // The mode numbers below correspond to the ANSIStandardMode values
        // in the ModeParams enum in DispatchTypes.hpp.

        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:modeNumber"", L""{4, 20}"")
        END_TEST_METHOD_PROPERTIES()

        VTInt modeNumber;",5,<empty>,,1966,781,CPPASTProblemDeclaration,,<empty>
568373,UNKNOWN,782,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""modeNumber"", modeNumber));",9,<empty>,,1976,782,CPPASTProblemDeclaration,,<empty>
568382,UNKNOWN,785,,"Log::Comment(NoThrowString().Format(L""Setting standard mode %d"", modeNumber));",9,<empty>,,1980,785,CPPASTProblemDeclaration,,<empty>
568383,UNKNOWN,786,,_testGetSet->PrepData();,9,<empty>,,1981,786,CPPASTProblemDeclaration,,<empty>
568384,UNKNOWN,787,,VERIFY_IS_TRUE(_pDispatch->SetMode(mode));,9,<empty>,,1982,787,CPPASTProblemDeclaration,,<empty>
568385,UNKNOWN,788,,VERIFY_IS_TRUE(_pDispatch->RequestMode(mode));,9,<empty>,,1983,788,CPPASTProblemDeclaration,,<empty>
568389,UNKNOWN,791,,"swprintf_s(expectedResponse, ARRAYSIZE(expectedResponse), L""\x1b[%d;1$y"", modeNumber);",9,<empty>,,1986,791,CPPASTProblemDeclaration,,<empty>
568390,UNKNOWN,792,,_testGetSet->ValidateInputEvent(expectedResponse);,9,<empty>,,1987,792,CPPASTProblemDeclaration,,<empty>
568391,UNKNOWN,793,,"Log::Comment(NoThrowString().Format(L""Resetting standard mode %d"", modeNumber));",9,<empty>,,1989,793,CPPASTProblemDeclaration,,<empty>
568392,UNKNOWN,794,,_testGetSet->PrepData();,9,<empty>,,1990,794,CPPASTProblemDeclaration,,<empty>
568393,UNKNOWN,795,,VERIFY_IS_TRUE(_pDispatch->ResetMode(mode));,9,<empty>,,1991,795,CPPASTProblemDeclaration,,<empty>
568394,UNKNOWN,796,,VERIFY_IS_TRUE(_pDispatch->RequestMode(mode));,9,<empty>,,1992,796,CPPASTProblemDeclaration,,<empty>
568395,UNKNOWN,797,,"swprintf_s(expectedResponse, ARRAYSIZE(expectedResponse), L""\x1b[%d;2$y"", modeNumber);",9,<empty>,,1994,797,CPPASTProblemDeclaration,,<empty>
568396,UNKNOWN,798,,_testGetSet->ValidateInputEvent(expectedResponse);,9,<empty>,,1995,798,CPPASTProblemDeclaration,,<empty>
568397,UNKNOWN,799,,},5,<empty>,,1996,799,CPPASTProblemDeclaration,,<empty>
568398,UNKNOWN,800,,"TEST_METHOD(RequestPrivateModeTests)
    {
        // The mode numbers below correspond to the DECPrivateMode values
        // in the ModeParams enum in DispatchTypes.hpp. We don't include
        // AnsiMode (2), because once that's disabled we'd be in VT52 mode,
        // and DECRQM would not then be applicable.

        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:modeNumber"", L""{1, 3, 5, 6, 7, 8, 12, 25, 40, 66, 67, 69, 117, 1000, 1002, 1003, 1004, 1005, 1006, 1007, 1049, 2004, 9001}"")
        END_TEST_METHOD_PROPERTIES()

        VTInt modeNumber;",5,<empty>,,1998,800,CPPASTProblemDeclaration,,<empty>
568399,UNKNOWN,801,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""modeNumber"", modeNumber));",9,<empty>,,2010,801,CPPASTProblemDeclaration,,<empty>
568408,UNKNOWN,804,,"if (mode == DispatchTypes::DECCOLM_SetNumberOfColumns)
        {
            Log::Comment(L""Make sure DECCOLM is allowed"");
            VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::XTERM_EnableDECCOLMSupport));
        }",9,<empty>,,2013,804,CPPASTProblemDeclaration,,<empty>
568409,UNKNOWN,805,,"Log::Comment(NoThrowString().Format(L""Setting private mode %d"", modeNumber));",9,<empty>,,2019,805,CPPASTProblemDeclaration,,<empty>
568410,UNKNOWN,806,,_testGetSet->PrepData();,9,<empty>,,2020,806,CPPASTProblemDeclaration,,<empty>
568411,UNKNOWN,807,,VERIFY_IS_TRUE(_pDispatch->SetMode(mode));,9,<empty>,,2021,807,CPPASTProblemDeclaration,,<empty>
568412,UNKNOWN,808,,VERIFY_IS_TRUE(_pDispatch->RequestMode(mode));,9,<empty>,,2022,808,CPPASTProblemDeclaration,,<empty>
568416,UNKNOWN,811,,"swprintf_s(expectedResponse, ARRAYSIZE(expectedResponse), L""\x1b[?%d;1$y"", modeNumber);",9,<empty>,,2025,811,CPPASTProblemDeclaration,,<empty>
568417,UNKNOWN,812,,_testGetSet->ValidateInputEvent(expectedResponse);,9,<empty>,,2026,812,CPPASTProblemDeclaration,,<empty>
568418,UNKNOWN,813,,"Log::Comment(NoThrowString().Format(L""Resetting private mode %d"", modeNumber));",9,<empty>,,2028,813,CPPASTProblemDeclaration,,<empty>
568419,UNKNOWN,814,,_testGetSet->PrepData();,9,<empty>,,2029,814,CPPASTProblemDeclaration,,<empty>
568420,UNKNOWN,815,,VERIFY_IS_TRUE(_pDispatch->ResetMode(mode));,9,<empty>,,2030,815,CPPASTProblemDeclaration,,<empty>
568421,UNKNOWN,816,,VERIFY_IS_TRUE(_pDispatch->RequestMode(mode));,9,<empty>,,2031,816,CPPASTProblemDeclaration,,<empty>
568422,UNKNOWN,817,,"swprintf_s(expectedResponse, ARRAYSIZE(expectedResponse), L""\x1b[?%d;2$y"", modeNumber);",9,<empty>,,2033,817,CPPASTProblemDeclaration,,<empty>
568423,UNKNOWN,818,,_testGetSet->ValidateInputEvent(expectedResponse);,9,<empty>,,2034,818,CPPASTProblemDeclaration,,<empty>
568424,UNKNOWN,819,,},5,<empty>,,2035,819,CPPASTProblemDeclaration,,<empty>
568425,UNKNOWN,820,,"TEST_METHOD(RequestChecksumReportTests)
    {
        const auto requestChecksumReport = [this](const auto length) {
            wchar_t checksumQuery[30];
            swprintf_s(checksumQuery, ARRAYSIZE(checksumQuery), L""\033[99;1;1;1;1;%zu*y"", length);
            _stateMachine->ProcessString(checksumQuery);
        };",5,<empty>,,2037,820,CPPASTProblemDeclaration,,<empty>
568438,UNKNOWN,827,,"Log::Comment(L""Test 1: ASCII characters"");",9,<empty>,,2068,827,CPPASTProblemDeclaration,,<empty>
568439,UNKNOWN,828,,"outputText(L""A""sv);",9,<empty>,,2069,828,CPPASTProblemDeclaration,,<empty>
568440,UNKNOWN,829,,"verifyChecksumReport(L""FF4F"");",9,<empty>,,2070,829,CPPASTProblemDeclaration,,<empty>
568441,UNKNOWN,830,,"outputText(L"" ""sv);",9,<empty>,,2071,830,CPPASTProblemDeclaration,,<empty>
568442,UNKNOWN,831,,"verifyChecksumReport(L""FF70"");",9,<empty>,,2072,831,CPPASTProblemDeclaration,,<empty>
568443,UNKNOWN,832,,"outputText(L""~""sv);",9,<empty>,,2073,832,CPPASTProblemDeclaration,,<empty>
568444,UNKNOWN,833,,"verifyChecksumReport(L""FF12"");",9,<empty>,,2074,833,CPPASTProblemDeclaration,,<empty>
568445,UNKNOWN,834,,"outputText(L""ABC""sv);",9,<empty>,,2075,834,CPPASTProblemDeclaration,,<empty>
568446,UNKNOWN,835,,"verifyChecksumReport(L""FDEA"");",9,<empty>,,2076,835,CPPASTProblemDeclaration,,<empty>
568447,UNKNOWN,836,,"Log::Comment(L""Test 2: Latin-1 characters"");",9,<empty>,,2078,836,CPPASTProblemDeclaration,,<empty>
568448,UNKNOWN,837,,"outputText(L""""sv);",9,<empty>,,2079,837,CPPASTProblemDeclaration,,<empty>
568449,UNKNOWN,838,,"verifyChecksumReport(L""FECF"");",9,<empty>,,2080,838,CPPASTProblemDeclaration,,<empty>
568450,UNKNOWN,839,,"outputText(L""""sv);",9,<empty>,,2081,839,CPPASTProblemDeclaration,,<empty>
568451,UNKNOWN,840,,"verifyChecksumReport(L""FEEF"");",9,<empty>,,2082,840,CPPASTProblemDeclaration,,<empty>
568452,UNKNOWN,841,,"outputText(L""""sv);",9,<empty>,,2083,841,CPPASTProblemDeclaration,,<empty>
568453,UNKNOWN,842,,"verifyChecksumReport(L""FE91"");",9,<empty>,,2084,842,CPPASTProblemDeclaration,,<empty>
568454,UNKNOWN,843,,"outputText(L""""sv);",9,<empty>,,2085,843,CPPASTProblemDeclaration,,<empty>
568455,UNKNOWN,844,,"verifyChecksumReport(L""FC6A"");",9,<empty>,,2086,844,CPPASTProblemDeclaration,,<empty>
568456,UNKNOWN,845,,"Log::Comment(L""Test 3: Rendition attributes"");",9,<empty>,,2088,845,CPPASTProblemDeclaration,,<empty>
568457,UNKNOWN,846,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetIntense(true);
        }",9,<empty>,,2089,846,CPPASTProblemDeclaration,,<empty>
568458,UNKNOWN,847,,);,10,<empty>,,2091,847,CPPASTProblemDeclaration,,<empty>
568459,UNKNOWN,848,,"verifyChecksumReport(L""FECF"");",9,<empty>,,2092,848,CPPASTProblemDeclaration,,<empty>
568460,UNKNOWN,849,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);
        }",9,<empty>,,2093,849,CPPASTProblemDeclaration,,<empty>
568461,UNKNOWN,850,,);,10,<empty>,,2095,850,CPPASTProblemDeclaration,,<empty>
568462,UNKNOWN,851,,"verifyChecksumReport(L""FF3F"");",9,<empty>,,2096,851,CPPASTProblemDeclaration,,<empty>
568463,UNKNOWN,852,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetBlinking(true);
        }",9,<empty>,,2097,852,CPPASTProblemDeclaration,,<empty>
568464,UNKNOWN,853,,);,10,<empty>,,2099,853,CPPASTProblemDeclaration,,<empty>
568465,UNKNOWN,854,,"verifyChecksumReport(L""FF0F"");",9,<empty>,,2100,854,CPPASTProblemDeclaration,,<empty>
568466,UNKNOWN,855,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetReverseVideo(true);
        }",9,<empty>,,2101,855,CPPASTProblemDeclaration,,<empty>
568467,UNKNOWN,856,,);,10,<empty>,,2103,856,CPPASTProblemDeclaration,,<empty>
568468,UNKNOWN,857,,"verifyChecksumReport(L""FF2F"");",9,<empty>,,2104,857,CPPASTProblemDeclaration,,<empty>
568469,UNKNOWN,858,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetInvisible(true);
        }",9,<empty>,,2105,858,CPPASTProblemDeclaration,,<empty>
568470,UNKNOWN,859,,);,10,<empty>,,2107,859,CPPASTProblemDeclaration,,<empty>
568471,UNKNOWN,860,,"verifyChecksumReport(L""FF47"");",9,<empty>,,2108,860,CPPASTProblemDeclaration,,<empty>
568472,UNKNOWN,861,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetIntense(true);
            attr.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);
            attr.SetReverseVideo(true);
        }",9,<empty>,,2109,861,CPPASTProblemDeclaration,,<empty>
568473,UNKNOWN,862,,);,10,<empty>,,2113,862,CPPASTProblemDeclaration,,<empty>
568474,UNKNOWN,863,,"verifyChecksumReport(L""FE9F"");",9,<empty>,,2114,863,CPPASTProblemDeclaration,,<empty>
568475,UNKNOWN,864,,"Log::Comment(L""Test 4: Selective erase"");",9,<empty>,,2116,864,CPPASTProblemDeclaration,,<empty>
568476,UNKNOWN,865,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetProtected(true);
        }",9,<empty>,,2117,865,CPPASTProblemDeclaration,,<empty>
568477,UNKNOWN,866,,);,10,<empty>,,2119,866,CPPASTProblemDeclaration,,<empty>
568478,UNKNOWN,867,,"verifyChecksumReport(L""FF4B"");",9,<empty>,,2120,867,CPPASTProblemDeclaration,,<empty>
568479,UNKNOWN,868,,"outputTextWithAttributes(L""B""sv, [](auto& attr) {
            attr.SetProtected(true);
        }",9,<empty>,,2121,868,CPPASTProblemDeclaration,,<empty>
568480,UNKNOWN,869,,);,10,<empty>,,2123,869,CPPASTProblemDeclaration,,<empty>
568481,UNKNOWN,870,,"verifyChecksumReport(L""FF4A"");",9,<empty>,,2124,870,CPPASTProblemDeclaration,,<empty>
568482,UNKNOWN,871,,"Log::Comment(L""Test 5: Color attributes"");",9,<empty>,,2126,871,CPPASTProblemDeclaration,,<empty>
568483,UNKNOWN,872,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetIndexedForeground(TextColor::DARK_RED);
        }",9,<empty>,,2127,872,CPPASTProblemDeclaration,,<empty>
568484,UNKNOWN,873,,);,10,<empty>,,2129,873,CPPASTProblemDeclaration,,<empty>
568485,UNKNOWN,874,,"verifyChecksumReport(L""FFAF"");",9,<empty>,,2130,874,CPPASTProblemDeclaration,,<empty>
568486,UNKNOWN,875,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetIndexedBackground(TextColor::DARK_GREEN);
        }",9,<empty>,,2131,875,CPPASTProblemDeclaration,,<empty>
568487,UNKNOWN,876,,);,10,<empty>,,2133,876,CPPASTProblemDeclaration,,<empty>
568488,UNKNOWN,877,,"verifyChecksumReport(L""FF4D"");",9,<empty>,,2134,877,CPPASTProblemDeclaration,,<empty>
568489,UNKNOWN,878,,"outputTextWithAttributes(L""A""sv, [](auto& attr) {
            attr.SetIndexedForeground(TextColor::DARK_YELLOW);
            attr.SetIndexedBackground(TextColor::DARK_BLUE);
        }",9,<empty>,,2135,878,CPPASTProblemDeclaration,,<empty>
568490,UNKNOWN,879,,);,10,<empty>,,2138,879,CPPASTProblemDeclaration,,<empty>
568491,UNKNOWN,880,,"verifyChecksumReport(L""FF8B"");",9,<empty>,,2139,880,CPPASTProblemDeclaration,,<empty>
568492,UNKNOWN,881,,},5,<empty>,,2140,881,CPPASTProblemDeclaration,,<empty>
568493,UNKNOWN,882,,"TEST_METHOD(TabulationStopReportTests)
    {
        _testGetSet->PrepData();",5,<empty>,,2142,882,CPPASTProblemDeclaration,,<empty>
568508,UNKNOWN,887,,"Log::Comment(L""Default tabs stops in 80-column mode"");",9,<empty>,,2148,887,CPPASTProblemDeclaration,,<empty>
568509,UNKNOWN,888,,"textBuffer.ResizeTraditional({ 80, 600 }",9,<empty>,,2149,888,CPPASTProblemDeclaration,,<empty>
568510,UNKNOWN,889,,);,49,<empty>,,2149,889,CPPASTProblemDeclaration,,<empty>
568511,UNKNOWN,890,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2150,890,CPPASTProblemDeclaration,,<empty>
568512,UNKNOWN,891,,"_testGetSet->ValidateInputEvent(L""\033P2$u9/17/25/33/41/49/57/65/73\033\\"");",9,<empty>,,2151,891,CPPASTProblemDeclaration,,<empty>
568513,UNKNOWN,892,,"Log::Comment(L""Default tabs stops in 132-column mode"");",9,<empty>,,2153,892,CPPASTProblemDeclaration,,<empty>
568514,UNKNOWN,893,,"textBuffer.ResizeTraditional({ 132, 600 }",9,<empty>,,2154,893,CPPASTProblemDeclaration,,<empty>
568515,UNKNOWN,894,,);,50,<empty>,,2154,894,CPPASTProblemDeclaration,,<empty>
568516,UNKNOWN,895,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2155,895,CPPASTProblemDeclaration,,<empty>
568517,UNKNOWN,896,,"_testGetSet->ValidateInputEvent(L""\033P2$u9/17/25/33/41/49/57/65/73/81/89/97/105/113/121/129\033\\"");",9,<empty>,,2156,896,CPPASTProblemDeclaration,,<empty>
568518,UNKNOWN,897,,"Log::Comment(L""Custom tab stops in 80 columns"");",9,<empty>,,2158,897,CPPASTProblemDeclaration,,<empty>
568519,UNKNOWN,898,,"textBuffer.ResizeTraditional({ 80, 600 }",9,<empty>,,2159,898,CPPASTProblemDeclaration,,<empty>
568520,UNKNOWN,899,,);,49,<empty>,,2159,899,CPPASTProblemDeclaration,,<empty>
568521,UNKNOWN,900,,"_testGetSet->_stateMachine->ProcessString(L""\033P2$t30/60/120/240\033\\"");",9,<empty>,,2160,900,CPPASTProblemDeclaration,,<empty>
568522,UNKNOWN,901,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2161,901,CPPASTProblemDeclaration,,<empty>
568523,UNKNOWN,902,,"_testGetSet->ValidateInputEvent(L""\033P2$u30/60\033\\"");",9,<empty>,,2162,902,CPPASTProblemDeclaration,,<empty>
568524,UNKNOWN,903,,"Log::Comment(L""After expanding width to 132 columns"");",9,<empty>,,2164,903,CPPASTProblemDeclaration,,<empty>
568525,UNKNOWN,904,,"textBuffer.ResizeTraditional({ 132, 600 }",9,<empty>,,2165,904,CPPASTProblemDeclaration,,<empty>
568526,UNKNOWN,905,,);,50,<empty>,,2165,905,CPPASTProblemDeclaration,,<empty>
568527,UNKNOWN,906,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2166,906,CPPASTProblemDeclaration,,<empty>
568528,UNKNOWN,907,,"_testGetSet->ValidateInputEvent(L""\033P2$u30/60/120\033\\"");",9,<empty>,,2167,907,CPPASTProblemDeclaration,,<empty>
568529,UNKNOWN,908,,"textBuffer.ResizeTraditional({ 80, 600 }",9,<empty>,,2168,908,CPPASTProblemDeclaration,,<empty>
568530,UNKNOWN,909,,);,49,<empty>,,2168,909,CPPASTProblemDeclaration,,<empty>
568531,UNKNOWN,910,,"Log::Comment(L""Out of order tab stops"");",9,<empty>,,2170,910,CPPASTProblemDeclaration,,<empty>
568532,UNKNOWN,911,,"stateMachine.ProcessString(L""\033P2$t44/22/66\033\\"");",9,<empty>,,2171,911,CPPASTProblemDeclaration,,<empty>
568533,UNKNOWN,912,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2172,912,CPPASTProblemDeclaration,,<empty>
568534,UNKNOWN,913,,"_testGetSet->ValidateInputEvent(L""\033P2$u22/44/66\033\\"");",9,<empty>,,2173,913,CPPASTProblemDeclaration,,<empty>
568535,UNKNOWN,914,,"Log::Comment(L""Empty tab stop are ignored"");",9,<empty>,,2175,914,CPPASTProblemDeclaration,,<empty>
568536,UNKNOWN,915,,"stateMachine.ProcessString(L""\033P2$t3//7\033\\"");",9,<empty>,,2176,915,CPPASTProblemDeclaration,,<empty>
568537,UNKNOWN,916,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2177,916,CPPASTProblemDeclaration,,<empty>
568538,UNKNOWN,917,,"_testGetSet->ValidateInputEvent(L""\033P2$u3/7\033\\"");",9,<empty>,,2178,917,CPPASTProblemDeclaration,,<empty>
568539,UNKNOWN,918,,"Log::Comment(L""'0' tab stops are ignored"");",9,<empty>,,2180,918,CPPASTProblemDeclaration,,<empty>
568540,UNKNOWN,919,,"stateMachine.ProcessString(L""\033P2$t0/5/10\033\\"");",9,<empty>,,2181,919,CPPASTProblemDeclaration,,<empty>
568541,UNKNOWN,920,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2182,920,CPPASTProblemDeclaration,,<empty>
568542,UNKNOWN,921,,"_testGetSet->ValidateInputEvent(L""\033P2$u5/10\033\\"");",9,<empty>,,2183,921,CPPASTProblemDeclaration,,<empty>
568543,UNKNOWN,922,,"Log::Comment(L""'1' tab stops are ignored"");",9,<empty>,,2185,922,CPPASTProblemDeclaration,,<empty>
568544,UNKNOWN,923,,"stateMachine.ProcessString(L""\033P2$t1/8/18\033\\"");",9,<empty>,,2186,923,CPPASTProblemDeclaration,,<empty>
568545,UNKNOWN,924,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2187,924,CPPASTProblemDeclaration,,<empty>
568546,UNKNOWN,925,,"_testGetSet->ValidateInputEvent(L""\033P2$u8/18\033\\"");",9,<empty>,,2188,925,CPPASTProblemDeclaration,,<empty>
568547,UNKNOWN,926,,"Log::Comment(L""Clear tab stops"");",9,<empty>,,2190,926,CPPASTProblemDeclaration,,<empty>
568548,UNKNOWN,927,,_pDispatch->TabClear(DispatchTypes::TabClearType::ClearAllColumns);,9,<empty>,,2191,927,CPPASTProblemDeclaration,,<empty>
568549,UNKNOWN,928,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::TabulationStopReport);,9,<empty>,,2192,928,CPPASTProblemDeclaration,,<empty>
568550,UNKNOWN,929,,"_testGetSet->ValidateInputEvent(L""\033P2$u\033\\"");",9,<empty>,,2193,929,CPPASTProblemDeclaration,,<empty>
568551,UNKNOWN,930,,},5,<empty>,,2194,930,CPPASTProblemDeclaration,,<empty>
568552,UNKNOWN,931,,"TEST_METHOD(CursorInformationReportTests)
    {
        _testGetSet->PrepData();",5,<empty>,,2196,931,CPPASTProblemDeclaration,,<empty>
568586,UNKNOWN,942,,"Log::Comment(L""Initial state"");",9,<empty>,,2205,942,CPPASTProblemDeclaration,,<empty>
568587,UNKNOWN,943,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2206,943,CPPASTProblemDeclaration,,<empty>
568588,UNKNOWN,944,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;1;1;@;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2207,944,CPPASTProblemDeclaration,,<empty>
568589,UNKNOWN,945,,"Log::Comment(L""Cursor position"");",9,<empty>,,2209,945,CPPASTProblemDeclaration,,<empty>
568590,UNKNOWN,946,,"textBuffer.GetCursor().SetPosition({ 3, viewportTop + 2 }",9,<empty>,,2210,946,CPPASTProblemDeclaration,,<empty>
568591,UNKNOWN,947,,);,66,<empty>,,2210,947,CPPASTProblemDeclaration,,<empty>
568592,UNKNOWN,948,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2211,948,CPPASTProblemDeclaration,,<empty>
568593,UNKNOWN,949,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;@;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2212,949,CPPASTProblemDeclaration,,<empty>
568594,UNKNOWN,950,,"Log::Comment(L""Intense rendition"");",9,<empty>,,2214,950,CPPASTProblemDeclaration,,<empty>
568595,UNKNOWN,951,,attributes.SetIntense(true);,9,<empty>,,2215,951,CPPASTProblemDeclaration,,<empty>
568596,UNKNOWN,952,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2216,952,CPPASTProblemDeclaration,,<empty>
568597,UNKNOWN,953,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2217,953,CPPASTProblemDeclaration,,<empty>
568598,UNKNOWN,954,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;A;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2218,954,CPPASTProblemDeclaration,,<empty>
568599,UNKNOWN,955,,"Log::Comment(L""Underlined rendition"");",9,<empty>,,2220,955,CPPASTProblemDeclaration,,<empty>
568600,UNKNOWN,956,,attributes.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);,9,<empty>,,2221,956,CPPASTProblemDeclaration,,<empty>
568601,UNKNOWN,957,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2222,957,CPPASTProblemDeclaration,,<empty>
568602,UNKNOWN,958,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2223,958,CPPASTProblemDeclaration,,<empty>
568603,UNKNOWN,959,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;C;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2224,959,CPPASTProblemDeclaration,,<empty>
568604,UNKNOWN,960,,"Log::Comment(L""Blinking rendition"");",9,<empty>,,2226,960,CPPASTProblemDeclaration,,<empty>
568605,UNKNOWN,961,,attributes.SetBlinking(true);,9,<empty>,,2227,961,CPPASTProblemDeclaration,,<empty>
568606,UNKNOWN,962,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2228,962,CPPASTProblemDeclaration,,<empty>
568607,UNKNOWN,963,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2229,963,CPPASTProblemDeclaration,,<empty>
568608,UNKNOWN,964,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;G;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2230,964,CPPASTProblemDeclaration,,<empty>
568609,UNKNOWN,965,,"Log::Comment(L""Reverse video rendition"");",9,<empty>,,2232,965,CPPASTProblemDeclaration,,<empty>
568610,UNKNOWN,966,,attributes.SetReverseVideo(true);,9,<empty>,,2233,966,CPPASTProblemDeclaration,,<empty>
568611,UNKNOWN,967,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2234,967,CPPASTProblemDeclaration,,<empty>
568612,UNKNOWN,968,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2235,968,CPPASTProblemDeclaration,,<empty>
568613,UNKNOWN,969,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;O;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2236,969,CPPASTProblemDeclaration,,<empty>
568614,UNKNOWN,970,,"Log::Comment(L""Invisible rendition"");",9,<empty>,,2238,970,CPPASTProblemDeclaration,,<empty>
568615,UNKNOWN,971,,attributes.SetInvisible(true);,9,<empty>,,2239,971,CPPASTProblemDeclaration,,<empty>
568616,UNKNOWN,972,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2240,972,CPPASTProblemDeclaration,,<empty>
568617,UNKNOWN,973,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2241,973,CPPASTProblemDeclaration,,<empty>
568618,UNKNOWN,974,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;_;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2242,974,CPPASTProblemDeclaration,,<empty>
568619,UNKNOWN,975,,"Log::Comment(L""Protected attribute"");",9,<empty>,,2244,975,CPPASTProblemDeclaration,,<empty>
568620,UNKNOWN,976,,attributes.SetProtected(true);,9,<empty>,,2245,976,CPPASTProblemDeclaration,,<empty>
568621,UNKNOWN,977,,textBuffer.SetCurrentAttributes(attributes);,9,<empty>,,2246,977,CPPASTProblemDeclaration,,<empty>
568622,UNKNOWN,978,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2247,978,CPPASTProblemDeclaration,,<empty>
568623,UNKNOWN,979,,"_testGetSet->ValidateInputEvent(L""\033P1$u3;4;1;_;A;@;0;2;@;BBBB\033\\"");",9,<empty>,,2248,979,CPPASTProblemDeclaration,,<empty>
568624,UNKNOWN,980,,"Log::Comment(L""Origin mode"");",9,<empty>,,2250,980,CPPASTProblemDeclaration,,<empty>
568625,UNKNOWN,981,,_pDispatch->SetMode(DispatchTypes::DECOM_OriginMode);,9,<empty>,,2251,981,CPPASTProblemDeclaration,,<empty>
568626,UNKNOWN,982,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2252,982,CPPASTProblemDeclaration,,<empty>
568627,UNKNOWN,983,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;1;1;_;A;A;0;2;@;BBBB\033\\"");",9,<empty>,,2253,983,CPPASTProblemDeclaration,,<empty>
568628,UNKNOWN,984,,"Log::Comment(L""Single shift 2"");",9,<empty>,,2255,984,CPPASTProblemDeclaration,,<empty>
568629,UNKNOWN,985,,_pDispatch->SingleShift(2);,9,<empty>,,2256,985,CPPASTProblemDeclaration,,<empty>
568630,UNKNOWN,986,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2257,986,CPPASTProblemDeclaration,,<empty>
568631,UNKNOWN,987,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;1;1;_;A;C;0;2;@;BBBB\033\\"");",9,<empty>,,2258,987,CPPASTProblemDeclaration,,<empty>
568632,UNKNOWN,988,,"Log::Comment(L""Single shift 3"");",9,<empty>,,2260,988,CPPASTProblemDeclaration,,<empty>
568633,UNKNOWN,989,,_pDispatch->SingleShift(3);,9,<empty>,,2261,989,CPPASTProblemDeclaration,,<empty>
568634,UNKNOWN,990,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2262,990,CPPASTProblemDeclaration,,<empty>
568635,UNKNOWN,991,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;1;1;_;A;E;0;2;@;BBBB\033\\"");",9,<empty>,,2263,991,CPPASTProblemDeclaration,,<empty>
568636,UNKNOWN,992,,"Log::Comment(L""Delayed EOL wrap"");",9,<empty>,,2265,992,CPPASTProblemDeclaration,,<empty>
568637,UNKNOWN,993,,_pDispatch->CursorForward(999);,9,<empty>,,2266,993,CPPASTProblemDeclaration,,<empty>
568638,UNKNOWN,994,,_pDispatch->Print(L'*');,9,<empty>,,2267,994,CPPASTProblemDeclaration,,<empty>
568639,UNKNOWN,995,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2268,995,CPPASTProblemDeclaration,,<empty>
568640,UNKNOWN,996,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;0;2;@;BBBB\033\\"");",9,<empty>,,2269,996,CPPASTProblemDeclaration,,<empty>
568641,UNKNOWN,997,,"Log::Comment(L""Locking shifts"");",9,<empty>,,2271,997,CPPASTProblemDeclaration,,<empty>
568642,UNKNOWN,998,,_pDispatch->LockingShift(1);,9,<empty>,,2272,998,CPPASTProblemDeclaration,,<empty>
568643,UNKNOWN,999,,_pDispatch->LockingShiftRight(3);,9,<empty>,,2273,999,CPPASTProblemDeclaration,,<empty>
568644,UNKNOWN,1000,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2274,1000,CPPASTProblemDeclaration,,<empty>
568645,UNKNOWN,1001,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;1;3;@;BBBB\033\\"");",9,<empty>,,2275,1001,CPPASTProblemDeclaration,,<empty>
568646,UNKNOWN,1002,,"Log::Comment(L""94 charset designations"");",9,<empty>,,2277,1002,CPPASTProblemDeclaration,,<empty>
568647,UNKNOWN,1003,,"_pDispatch->Designate94Charset(0, ""%5"");",9,<empty>,,2278,1003,CPPASTProblemDeclaration,,<empty>
568648,UNKNOWN,1004,,"_pDispatch->Designate94Charset(1, ""<"");",9,<empty>,,2279,1004,CPPASTProblemDeclaration,,<empty>
568649,UNKNOWN,1005,,"_pDispatch->Designate94Charset(2, ""0"");",9,<empty>,,2280,1005,CPPASTProblemDeclaration,,<empty>
568650,UNKNOWN,1006,,"_pDispatch->Designate94Charset(3, ""K"");",9,<empty>,,2281,1006,CPPASTProblemDeclaration,,<empty>
568651,UNKNOWN,1007,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2282,1007,CPPASTProblemDeclaration,,<empty>
568652,UNKNOWN,1008,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;1;3;@;%5<0K\033\\"");",9,<empty>,,2283,1008,CPPASTProblemDeclaration,,<empty>
568653,UNKNOWN,1009,,"Log::Comment(L""96 charset designation (G1)"");",9,<empty>,,2285,1009,CPPASTProblemDeclaration,,<empty>
568654,UNKNOWN,1010,,"_pDispatch->Designate96Charset(1, ""H"");",9,<empty>,,2286,1010,CPPASTProblemDeclaration,,<empty>
568655,UNKNOWN,1011,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2287,1011,CPPASTProblemDeclaration,,<empty>
568656,UNKNOWN,1012,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;1;3;B;%5H0K\033\\"");",9,<empty>,,2288,1012,CPPASTProblemDeclaration,,<empty>
568657,UNKNOWN,1013,,"Log::Comment(L""96 charset designation (G2)"");",9,<empty>,,2290,1013,CPPASTProblemDeclaration,,<empty>
568658,UNKNOWN,1014,,"_pDispatch->Designate96Charset(2, ""M"");",9,<empty>,,2291,1014,CPPASTProblemDeclaration,,<empty>
568659,UNKNOWN,1015,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2292,1015,CPPASTProblemDeclaration,,<empty>
568660,UNKNOWN,1016,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;1;3;F;%5HMK\033\\"");",9,<empty>,,2293,1016,CPPASTProblemDeclaration,,<empty>
568661,UNKNOWN,1017,,"Log::Comment(L""96 charset designation (G3)"");",9,<empty>,,2295,1017,CPPASTProblemDeclaration,,<empty>
568662,UNKNOWN,1018,,"_pDispatch->Designate96Charset(3, ""B"");",9,<empty>,,2296,1018,CPPASTProblemDeclaration,,<empty>
568663,UNKNOWN,1019,,_pDispatch->RequestPresentationStateReport(DispatchTypes::PresentationReportFormat::CursorInformationReport);,9,<empty>,,2297,1019,CPPASTProblemDeclaration,,<empty>
568664,UNKNOWN,1020,,"_testGetSet->ValidateInputEvent(L""\033P1$u1;100;1;_;A;I;1;3;N;%5HMB\033\\"");",9,<empty>,,2298,1020,CPPASTProblemDeclaration,,<empty>
568665,UNKNOWN,1021,,"Log::Comment(L""Restore cursor position"");",9,<empty>,,2300,1021,CPPASTProblemDeclaration,,<empty>
568666,UNKNOWN,1022,,"stateMachine.ProcessString(L""\033P1$t3;4;1;@;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2301,1022,CPPASTProblemDeclaration,,<empty>
568676,UNKNOWN,1025,,"VERIFY_ARE_EQUAL(expectedPosition, textBuffer.GetCursor().GetPosition());",9,<empty>,,2303,1025,CPPASTProblemDeclaration,,<empty>
568677,UNKNOWN,1026,,"Log::Comment(L""Restore rendition attributes"");",9,<empty>,,2305,1026,CPPASTProblemDeclaration,,<empty>
568678,UNKNOWN,1027,,"stateMachine.ProcessString(L""\033P1$t1;1;1;U;@;@;0;2;@;BBBB\033\\"");",9,<empty>,,2308,1027,CPPASTProblemDeclaration,,<empty>
568683,UNKNOWN,1030,,attributes.SetIntense(true);,9,<empty>,,2310,1030,CPPASTProblemDeclaration,,<empty>
568684,UNKNOWN,1031,,attributes.SetBlinking(true);,9,<empty>,,2311,1031,CPPASTProblemDeclaration,,<empty>
568685,UNKNOWN,1032,,attributes.SetInvisible(true);,9,<empty>,,2312,1032,CPPASTProblemDeclaration,,<empty>
568686,UNKNOWN,1033,,"VERIFY_ARE_EQUAL(attributes, textBuffer.GetCurrentAttributes());",9,<empty>,,2313,1033,CPPASTProblemDeclaration,,<empty>
568687,UNKNOWN,1034,,"stateMachine.ProcessString(L""\033P1$t1;1;1;J;A;@;0;2;@;BBBB\033\\"");",9,<empty>,,2316,1034,CPPASTProblemDeclaration,,<empty>
568692,UNKNOWN,1037,,attributes.SetUnderlineStyle(UnderlineStyle::SinglyUnderlined);,9,<empty>,,2318,1037,CPPASTProblemDeclaration,,<empty>
568693,UNKNOWN,1038,,attributes.SetReverseVideo(true);,9,<empty>,,2319,1038,CPPASTProblemDeclaration,,<empty>
568694,UNKNOWN,1039,,attributes.SetProtected(true);,9,<empty>,,2320,1039,CPPASTProblemDeclaration,,<empty>
568695,UNKNOWN,1040,,"VERIFY_ARE_EQUAL(attributes, textBuffer.GetCurrentAttributes());",9,<empty>,,2321,1040,CPPASTProblemDeclaration,,<empty>
568696,UNKNOWN,1041,,"Log::Comment(L""Restore flags"");",9,<empty>,,2323,1041,CPPASTProblemDeclaration,,<empty>
568697,UNKNOWN,1042,,"stateMachine.ProcessString(L""\033P1$t1;1;1;@;@;E;0;2;@;BBBB\033\\"");",9,<empty>,,2324,1042,CPPASTProblemDeclaration,,<empty>
568698,UNKNOWN,1043,,VERIFY_IS_TRUE(_pDispatch->_modes.test(AdaptDispatch::Mode::Origin));,9,<empty>,,2325,1043,CPPASTProblemDeclaration,,<empty>
568699,UNKNOWN,1044,,VERIFY_IS_FALSE(termOutput.IsSingleShiftPending(2));,9,<empty>,,2326,1044,CPPASTProblemDeclaration,,<empty>
568700,UNKNOWN,1045,,VERIFY_IS_TRUE(termOutput.IsSingleShiftPending(3));,9,<empty>,,2327,1045,CPPASTProblemDeclaration,,<empty>
568701,UNKNOWN,1046,,VERIFY_IS_FALSE(textBuffer.GetCursor().IsDelayedEOLWrap());,9,<empty>,,2328,1046,CPPASTProblemDeclaration,,<empty>
568702,UNKNOWN,1047,,"stateMachine.ProcessString(L""\033P1$t1;1;1;@;@;J;0;2;@;BBBB\033\\"");",9,<empty>,,2329,1047,CPPASTProblemDeclaration,,<empty>
568703,UNKNOWN,1048,,VERIFY_IS_FALSE(_pDispatch->_modes.test(AdaptDispatch::Mode::Origin));,9,<empty>,,2330,1048,CPPASTProblemDeclaration,,<empty>
568704,UNKNOWN,1049,,VERIFY_IS_TRUE(termOutput.IsSingleShiftPending(2));,9,<empty>,,2331,1049,CPPASTProblemDeclaration,,<empty>
568705,UNKNOWN,1050,,VERIFY_IS_FALSE(termOutput.IsSingleShiftPending(3));,9,<empty>,,2332,1050,CPPASTProblemDeclaration,,<empty>
568706,UNKNOWN,1051,,VERIFY_IS_TRUE(textBuffer.GetCursor().IsDelayedEOLWrap());,9,<empty>,,2333,1051,CPPASTProblemDeclaration,,<empty>
568707,UNKNOWN,1052,,"Log::Comment(L""Restore charset configuration"");",9,<empty>,,2335,1052,CPPASTProblemDeclaration,,<empty>
568708,UNKNOWN,1053,,"stateMachine.ProcessString(L""\033P1$t1;1;1;@;@;@;3;1;H;ABCF\033\\"");",9,<empty>,,2336,1053,CPPASTProblemDeclaration,,<empty>
568709,UNKNOWN,1054,,"VERIFY_ARE_EQUAL(3u, termOutput.GetLeftSetNumber());",9,<empty>,,2337,1054,CPPASTProblemDeclaration,,<empty>
568710,UNKNOWN,1055,,"VERIFY_ARE_EQUAL(1u, termOutput.GetRightSetNumber());",9,<empty>,,2338,1055,CPPASTProblemDeclaration,,<empty>
568711,UNKNOWN,1056,,"VERIFY_ARE_EQUAL(94u, termOutput.GetCharsetSize(0));",9,<empty>,,2339,1056,CPPASTProblemDeclaration,,<empty>
568712,UNKNOWN,1057,,"VERIFY_ARE_EQUAL(94u, termOutput.GetCharsetSize(1));",9,<empty>,,2340,1057,CPPASTProblemDeclaration,,<empty>
568713,UNKNOWN,1058,,"VERIFY_ARE_EQUAL(94u, termOutput.GetCharsetSize(2));",9,<empty>,,2341,1058,CPPASTProblemDeclaration,,<empty>
568714,UNKNOWN,1059,,"VERIFY_ARE_EQUAL(96u, termOutput.GetCharsetSize(3));",9,<empty>,,2342,1059,CPPASTProblemDeclaration,,<empty>
568715,UNKNOWN,1060,,"VERIFY_ARE_EQUAL(VTID(""A""), termOutput.GetCharsetId(0));",9,<empty>,,2343,1060,CPPASTProblemDeclaration,,<empty>
568716,UNKNOWN,1061,,"VERIFY_ARE_EQUAL(VTID(""B""), termOutput.GetCharsetId(1));",9,<empty>,,2344,1061,CPPASTProblemDeclaration,,<empty>
568717,UNKNOWN,1062,,"VERIFY_ARE_EQUAL(VTID(""C""), termOutput.GetCharsetId(2));",9,<empty>,,2345,1062,CPPASTProblemDeclaration,,<empty>
568718,UNKNOWN,1063,,"VERIFY_ARE_EQUAL(VTID(""F""), termOutput.GetCharsetId(3));",9,<empty>,,2346,1063,CPPASTProblemDeclaration,,<empty>
568719,UNKNOWN,1064,,},5,<empty>,,2347,1064,CPPASTProblemDeclaration,,<empty>
568720,UNKNOWN,1065,,"TEST_METHOD(CursorKeysModeTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2349,1065,CPPASTProblemDeclaration,,<empty>
568721,UNKNOWN,1066,,"_terminalInput.SetInputMode(TerminalInput::Mode::CursorKey, true);",9,<empty>,,2352,1066,CPPASTProblemDeclaration,,<empty>
568722,UNKNOWN,1067,,"Log::Comment(L""Test 1: application mode = false"");",9,<empty>,,2356,1067,CPPASTProblemDeclaration,,<empty>
568723,UNKNOWN,1068,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::DECCKM_CursorKeysMode));,9,<empty>,,2357,1068,CPPASTProblemDeclaration,,<empty>
568724,UNKNOWN,1069,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::CursorKey));,9,<empty>,,2358,1069,CPPASTProblemDeclaration,,<empty>
568725,UNKNOWN,1070,,"Log::Comment(L""Test 2: application mode = true"");",9,<empty>,,2361,1070,CPPASTProblemDeclaration,,<empty>
568726,UNKNOWN,1071,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::DECCKM_CursorKeysMode));,9,<empty>,,2362,1071,CPPASTProblemDeclaration,,<empty>
568727,UNKNOWN,1072,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::CursorKey));,9,<empty>,,2363,1072,CPPASTProblemDeclaration,,<empty>
568728,UNKNOWN,1073,,},5,<empty>,,2364,1073,CPPASTProblemDeclaration,,<empty>
568729,UNKNOWN,1074,,"TEST_METHOD(KeypadModeTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2366,1074,CPPASTProblemDeclaration,,<empty>
568730,UNKNOWN,1075,,"_terminalInput.SetInputMode(TerminalInput::Mode::Keypad, true);",9,<empty>,,2369,1075,CPPASTProblemDeclaration,,<empty>
568731,UNKNOWN,1076,,"Log::Comment(L""Test 1: application mode = false"");",9,<empty>,,2373,1076,CPPASTProblemDeclaration,,<empty>
568732,UNKNOWN,1077,,VERIFY_IS_TRUE(_pDispatch->SetKeypadMode(false));,9,<empty>,,2374,1077,CPPASTProblemDeclaration,,<empty>
568733,UNKNOWN,1078,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::Keypad));,9,<empty>,,2375,1078,CPPASTProblemDeclaration,,<empty>
568734,UNKNOWN,1079,,"Log::Comment(L""Test 2: application mode = true"");",9,<empty>,,2378,1079,CPPASTProblemDeclaration,,<empty>
568735,UNKNOWN,1080,,VERIFY_IS_TRUE(_pDispatch->SetKeypadMode(true));,9,<empty>,,2379,1080,CPPASTProblemDeclaration,,<empty>
568736,UNKNOWN,1081,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::Keypad));,9,<empty>,,2380,1081,CPPASTProblemDeclaration,,<empty>
568737,UNKNOWN,1082,,},5,<empty>,,2381,1082,CPPASTProblemDeclaration,,<empty>
568738,UNKNOWN,1083,,"TEST_METHOD(AnsiModeTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2383,1083,CPPASTProblemDeclaration,,<empty>
568739,UNKNOWN,1084,,"_stateMachine->SetParserMode(StateMachine::Mode::Ansi, false);",9,<empty>,,2386,1084,CPPASTProblemDeclaration,,<empty>
568740,UNKNOWN,1085,,"Log::Comment(L""Test 1: ansi mode = true"");",9,<empty>,,2390,1085,CPPASTProblemDeclaration,,<empty>
568741,UNKNOWN,1086,,VERIFY_IS_TRUE(_pDispatch->SetAnsiMode(true));,9,<empty>,,2391,1086,CPPASTProblemDeclaration,,<empty>
568742,UNKNOWN,1087,,VERIFY_IS_TRUE(_stateMachine->GetParserMode(StateMachine::Mode::Ansi));,9,<empty>,,2392,1087,CPPASTProblemDeclaration,,<empty>
568743,UNKNOWN,1088,,"Log::Comment(L""Test 2: ansi mode = false."");",9,<empty>,,2395,1088,CPPASTProblemDeclaration,,<empty>
568744,UNKNOWN,1089,,VERIFY_IS_TRUE(_pDispatch->SetAnsiMode(false));,9,<empty>,,2396,1089,CPPASTProblemDeclaration,,<empty>
568745,UNKNOWN,1090,,VERIFY_IS_FALSE(_stateMachine->GetParserMode(StateMachine::Mode::Ansi));,9,<empty>,,2397,1090,CPPASTProblemDeclaration,,<empty>
568746,UNKNOWN,1091,,},5,<empty>,,2398,1091,CPPASTProblemDeclaration,,<empty>
568747,UNKNOWN,1092,,"TEST_METHOD(AllowBlinkingTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2400,1092,CPPASTProblemDeclaration,,<empty>
568748,UNKNOWN,1093,,_testGetSet->PrepData();,9,<empty>,,2404,1093,CPPASTProblemDeclaration,,<empty>
568749,UNKNOWN,1094,,"Log::Comment(L""Test 1: enable blinking = true"");",9,<empty>,,2408,1094,CPPASTProblemDeclaration,,<empty>
568750,UNKNOWN,1095,,_testGetSet->_textBuffer->GetCursor().SetBlinkingAllowed(false);,9,<empty>,,2409,1095,CPPASTProblemDeclaration,,<empty>
568751,UNKNOWN,1096,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::ATT610_StartCursorBlink));,9,<empty>,,2410,1096,CPPASTProblemDeclaration,,<empty>
568752,UNKNOWN,1097,,VERIFY_IS_TRUE(_testGetSet->_textBuffer->GetCursor().IsBlinkingAllowed());,9,<empty>,,2411,1097,CPPASTProblemDeclaration,,<empty>
568753,UNKNOWN,1098,,"Log::Comment(L""Test 2: enable blinking = false"");",9,<empty>,,2414,1098,CPPASTProblemDeclaration,,<empty>
568754,UNKNOWN,1099,,_testGetSet->_textBuffer->GetCursor().SetBlinkingAllowed(true);,9,<empty>,,2415,1099,CPPASTProblemDeclaration,,<empty>
568755,UNKNOWN,1100,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::ATT610_StartCursorBlink));,9,<empty>,,2416,1100,CPPASTProblemDeclaration,,<empty>
568756,UNKNOWN,1101,,VERIFY_IS_FALSE(_testGetSet->_textBuffer->GetCursor().IsBlinkingAllowed());,9,<empty>,,2417,1101,CPPASTProblemDeclaration,,<empty>
568757,UNKNOWN,1102,,},5,<empty>,,2418,1102,CPPASTProblemDeclaration,,<empty>
568758,UNKNOWN,1103,,"TEST_METHOD(ScrollMarginsTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2420,1103,CPPASTProblemDeclaration,,<empty>
568760,UNKNOWN,1105,,"_testGetSet->_textBuffer = std::make_unique<TextBuffer>(til::size{ 100, 600 }",9,<empty>,,2425,1105,CPPASTProblemDeclaration,,<empty>
568761,UNKNOWN,1106,,", TextAttribute{}",86,<empty>,,2425,1106,CPPASTProblemDeclaration,,<empty>
568762,UNKNOWN,1107,,", 0, false, _testGetSet->_renderer);",103,<empty>,,2425,1107,CPPASTProblemDeclaration,,<empty>
568763,UNKNOWN,1108,,_testGetSet->_viewport.right = 8;,9,<empty>,,2426,1108,CPPASTProblemDeclaration,,<empty>
568764,UNKNOWN,1109,,_testGetSet->_viewport.bottom = 8;,9,<empty>,,2427,1109,CPPASTProblemDeclaration,,<empty>
568779,UNKNOWN,1112,,"Log::Comment(L""Test 1: Verify having both values is valid."");",9,<empty>,,2430,1112,CPPASTProblemDeclaration,,<empty>
568780,UNKNOWN,1113,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(2, 6));",9,<empty>,,2431,1113,CPPASTProblemDeclaration,,<empty>
568781,UNKNOWN,1114,,"VERIFY_ARE_EQUAL(2, _pDispatch->_scrollMargins.top + 1);",9,<empty>,,2432,1114,CPPASTProblemDeclaration,,<empty>
568782,UNKNOWN,1115,,"VERIFY_ARE_EQUAL(6, _pDispatch->_scrollMargins.bottom + 1);",9,<empty>,,2433,1115,CPPASTProblemDeclaration,,<empty>
568783,UNKNOWN,1116,,"Log::Comment(L""Test 2: Verify having only top is valid."");",9,<empty>,,2435,1116,CPPASTProblemDeclaration,,<empty>
568784,UNKNOWN,1117,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(7, 0));",9,<empty>,,2436,1117,CPPASTProblemDeclaration,,<empty>
568785,UNKNOWN,1118,,"VERIFY_ARE_EQUAL(7, _pDispatch->_scrollMargins.top + 1);",9,<empty>,,2437,1118,CPPASTProblemDeclaration,,<empty>
568786,UNKNOWN,1119,,"VERIFY_ARE_EQUAL(sScreenHeight, _pDispatch->_scrollMargins.bottom + 1);",9,<empty>,,2438,1119,CPPASTProblemDeclaration,,<empty>
568787,UNKNOWN,1120,,"Log::Comment(L""Test 3: Verify having only bottom is valid."");",9,<empty>,,2440,1120,CPPASTProblemDeclaration,,<empty>
568788,UNKNOWN,1121,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(0, 7));",9,<empty>,,2441,1121,CPPASTProblemDeclaration,,<empty>
568789,UNKNOWN,1122,,"VERIFY_ARE_EQUAL(1, _pDispatch->_scrollMargins.top + 1);",9,<empty>,,2442,1122,CPPASTProblemDeclaration,,<empty>
568790,UNKNOWN,1123,,"VERIFY_ARE_EQUAL(7, _pDispatch->_scrollMargins.bottom + 1);",9,<empty>,,2443,1123,CPPASTProblemDeclaration,,<empty>
568791,UNKNOWN,1124,,"Log::Comment(L""Test 4: Verify having no values is valid."");",9,<empty>,,2445,1124,CPPASTProblemDeclaration,,<empty>
568792,UNKNOWN,1125,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(0, 0));",9,<empty>,,2446,1125,CPPASTProblemDeclaration,,<empty>
568793,UNKNOWN,1126,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2447,1126,CPPASTProblemDeclaration,,<empty>
568794,UNKNOWN,1127,,},46,<empty>,,2447,1127,CPPASTProblemDeclaration,,<empty>
568795,UNKNOWN,1128,,", _pDispatch->_scrollMargins);",47,<empty>,,2447,1128,CPPASTProblemDeclaration,,<empty>
568796,UNKNOWN,1129,,"Log::Comment(L""Test 5: Verify having both values, but bad bounds has no effect."");",9,<empty>,,2449,1129,CPPASTProblemDeclaration,,<empty>
568797,UNKNOWN,1130,,_pDispatch->_scrollMargins = {};,9,<empty>,,2450,1130,CPPASTProblemDeclaration,,<empty>
568798,UNKNOWN,1131,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(7, 3));",9,<empty>,,2451,1131,CPPASTProblemDeclaration,,<empty>
568799,UNKNOWN,1132,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2452,1132,CPPASTProblemDeclaration,,<empty>
568800,UNKNOWN,1133,,},46,<empty>,,2452,1133,CPPASTProblemDeclaration,,<empty>
568801,UNKNOWN,1134,,", _pDispatch->_scrollMargins);",47,<empty>,,2452,1134,CPPASTProblemDeclaration,,<empty>
568802,UNKNOWN,1135,,"Log::Comment(L""Test 6: Verify setting margins to (0, height) clears them"");",9,<empty>,,2454,1135,CPPASTProblemDeclaration,,<empty>
568803,UNKNOWN,1136,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(2, 6));",9,<empty>,,2456,1136,CPPASTProblemDeclaration,,<empty>
568804,UNKNOWN,1137,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(0, sScreenHeight));",9,<empty>,,2458,1137,CPPASTProblemDeclaration,,<empty>
568805,UNKNOWN,1138,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2459,1138,CPPASTProblemDeclaration,,<empty>
568806,UNKNOWN,1139,,},46,<empty>,,2459,1139,CPPASTProblemDeclaration,,<empty>
568807,UNKNOWN,1140,,", _pDispatch->_scrollMargins);",47,<empty>,,2459,1140,CPPASTProblemDeclaration,,<empty>
568808,UNKNOWN,1141,,"Log::Comment(L""Test 7: Verify setting margins to (1, height) clears them"");",9,<empty>,,2461,1141,CPPASTProblemDeclaration,,<empty>
568809,UNKNOWN,1142,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(2, 6));",9,<empty>,,2463,1142,CPPASTProblemDeclaration,,<empty>
568810,UNKNOWN,1143,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(1, sScreenHeight));",9,<empty>,,2465,1143,CPPASTProblemDeclaration,,<empty>
568811,UNKNOWN,1144,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2466,1144,CPPASTProblemDeclaration,,<empty>
568812,UNKNOWN,1145,,},46,<empty>,,2466,1145,CPPASTProblemDeclaration,,<empty>
568813,UNKNOWN,1146,,", _pDispatch->_scrollMargins);",47,<empty>,,2466,1146,CPPASTProblemDeclaration,,<empty>
568814,UNKNOWN,1147,,"Log::Comment(L""Test 8: Verify setting margins to (1, 0) clears them"");",9,<empty>,,2468,1147,CPPASTProblemDeclaration,,<empty>
568815,UNKNOWN,1148,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(2, 6));",9,<empty>,,2470,1148,CPPASTProblemDeclaration,,<empty>
568816,UNKNOWN,1149,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(1, 0));",9,<empty>,,2472,1149,CPPASTProblemDeclaration,,<empty>
568817,UNKNOWN,1150,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2473,1150,CPPASTProblemDeclaration,,<empty>
568818,UNKNOWN,1151,,},46,<empty>,,2473,1151,CPPASTProblemDeclaration,,<empty>
568819,UNKNOWN,1152,,", _pDispatch->_scrollMargins);",47,<empty>,,2473,1152,CPPASTProblemDeclaration,,<empty>
568820,UNKNOWN,1153,,"Log::Comment(L""Test 9: Verify having top and bottom margin the same has no effect."");",9,<empty>,,2475,1153,CPPASTProblemDeclaration,,<empty>
568821,UNKNOWN,1154,,_pDispatch->_scrollMargins = {};,9,<empty>,,2476,1154,CPPASTProblemDeclaration,,<empty>
568822,UNKNOWN,1155,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(4, 4));",9,<empty>,,2477,1155,CPPASTProblemDeclaration,,<empty>
568823,UNKNOWN,1156,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2478,1156,CPPASTProblemDeclaration,,<empty>
568824,UNKNOWN,1157,,},46,<empty>,,2478,1157,CPPASTProblemDeclaration,,<empty>
568825,UNKNOWN,1158,,", _pDispatch->_scrollMargins);",47,<empty>,,2478,1158,CPPASTProblemDeclaration,,<empty>
568826,UNKNOWN,1159,,"Log::Comment(L""Test 10: Verify having top margin out of bounds has no effect."");",9,<empty>,,2480,1159,CPPASTProblemDeclaration,,<empty>
568827,UNKNOWN,1160,,_pDispatch->_scrollMargins = {};,9,<empty>,,2481,1160,CPPASTProblemDeclaration,,<empty>
568828,UNKNOWN,1161,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(sScreenHeight + 1, sScreenHeight + 10));",9,<empty>,,2482,1161,CPPASTProblemDeclaration,,<empty>
568829,UNKNOWN,1162,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2483,1162,CPPASTProblemDeclaration,,<empty>
568830,UNKNOWN,1163,,},46,<empty>,,2483,1163,CPPASTProblemDeclaration,,<empty>
568831,UNKNOWN,1164,,", _pDispatch->_scrollMargins);",47,<empty>,,2483,1164,CPPASTProblemDeclaration,,<empty>
568832,UNKNOWN,1165,,"Log::Comment(L""Test 11: Verify having bottom margin out of bounds has no effect."");",9,<empty>,,2485,1165,CPPASTProblemDeclaration,,<empty>
568833,UNKNOWN,1166,,_pDispatch->_scrollMargins = {};,9,<empty>,,2486,1166,CPPASTProblemDeclaration,,<empty>
568834,UNKNOWN,1167,,"VERIFY_IS_TRUE(_pDispatch->SetTopBottomScrollingMargins(1, sScreenHeight + 1));",9,<empty>,,2487,1167,CPPASTProblemDeclaration,,<empty>
568835,UNKNOWN,1168,,VERIFY_ARE_EQUAL(til::inclusive_rect{,9,<empty>,,2488,1168,CPPASTProblemDeclaration,,<empty>
568836,UNKNOWN,1169,,},46,<empty>,,2488,1169,CPPASTProblemDeclaration,,<empty>
568837,UNKNOWN,1170,,", _pDispatch->_scrollMargins);",47,<empty>,,2488,1170,CPPASTProblemDeclaration,,<empty>
568838,UNKNOWN,1171,,},5,<empty>,,2489,1171,CPPASTProblemDeclaration,,<empty>
568839,UNKNOWN,1172,,"TEST_METHOD(LineFeedTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2491,1172,CPPASTProblemDeclaration,,<empty>
568840,UNKNOWN,1173,,_testGetSet->PrepData();,9,<empty>,,2495,1173,CPPASTProblemDeclaration,,<empty>
568850,UNKNOWN,1176,,"Log::Comment(L""Test 1: Line feed without carriage return."");",9,<empty>,,2498,1176,CPPASTProblemDeclaration,,<empty>
568851,UNKNOWN,1177,,"cursor.SetPosition({ 10, 0 }",9,<empty>,,2499,1177,CPPASTProblemDeclaration,,<empty>
568852,UNKNOWN,1178,,);,37,<empty>,,2499,1178,CPPASTProblemDeclaration,,<empty>
568853,UNKNOWN,1179,,VERIFY_IS_TRUE(_pDispatch->LineFeed(DispatchTypes::LineFeedType::WithoutReturn));,9,<empty>,,2500,1179,CPPASTProblemDeclaration,,<empty>
568854,UNKNOWN,1180,,"VERIFY_ARE_EQUAL(til::point(10, 1), cursor.GetPosition());",9,<empty>,,2501,1180,CPPASTProblemDeclaration,,<empty>
568855,UNKNOWN,1181,,"Log::Comment(L""Test 2: Line feed with carriage return."");",9,<empty>,,2503,1181,CPPASTProblemDeclaration,,<empty>
568856,UNKNOWN,1182,,"cursor.SetPosition({ 10, 0 }",9,<empty>,,2504,1182,CPPASTProblemDeclaration,,<empty>
568857,UNKNOWN,1183,,);,37,<empty>,,2504,1183,CPPASTProblemDeclaration,,<empty>
568858,UNKNOWN,1184,,VERIFY_IS_TRUE(_pDispatch->LineFeed(DispatchTypes::LineFeedType::WithReturn));,9,<empty>,,2505,1184,CPPASTProblemDeclaration,,<empty>
568859,UNKNOWN,1185,,"VERIFY_ARE_EQUAL(til::point(0, 1), cursor.GetPosition());",9,<empty>,,2506,1185,CPPASTProblemDeclaration,,<empty>
568860,UNKNOWN,1186,,"Log::Comment(L""Test 3: Line feed depends on mode, and mode reset."");",9,<empty>,,2508,1186,CPPASTProblemDeclaration,,<empty>
568861,UNKNOWN,1187,,_testGetSet->_systemMode.reset(ITerminalApi::Mode::LineFeed);,9,<empty>,,2509,1187,CPPASTProblemDeclaration,,<empty>
568862,UNKNOWN,1188,,"cursor.SetPosition({ 10, 0 }",9,<empty>,,2510,1188,CPPASTProblemDeclaration,,<empty>
568863,UNKNOWN,1189,,);,37,<empty>,,2510,1189,CPPASTProblemDeclaration,,<empty>
568864,UNKNOWN,1190,,VERIFY_IS_TRUE(_pDispatch->LineFeed(DispatchTypes::LineFeedType::DependsOnMode));,9,<empty>,,2511,1190,CPPASTProblemDeclaration,,<empty>
568865,UNKNOWN,1191,,"VERIFY_ARE_EQUAL(til::point(10, 1), cursor.GetPosition());",9,<empty>,,2512,1191,CPPASTProblemDeclaration,,<empty>
568866,UNKNOWN,1192,,"Log::Comment(L""Test 4: Line feed depends on mode, and mode set."");",9,<empty>,,2514,1192,CPPASTProblemDeclaration,,<empty>
568867,UNKNOWN,1193,,_testGetSet->_systemMode.set(ITerminalApi::Mode::LineFeed);,9,<empty>,,2515,1193,CPPASTProblemDeclaration,,<empty>
568868,UNKNOWN,1194,,"cursor.SetPosition({ 10, 0 }",9,<empty>,,2516,1194,CPPASTProblemDeclaration,,<empty>
568869,UNKNOWN,1195,,);,37,<empty>,,2516,1195,CPPASTProblemDeclaration,,<empty>
568870,UNKNOWN,1196,,VERIFY_IS_TRUE(_pDispatch->LineFeed(DispatchTypes::LineFeedType::DependsOnMode));,9,<empty>,,2517,1196,CPPASTProblemDeclaration,,<empty>
568871,UNKNOWN,1197,,"VERIFY_ARE_EQUAL(til::point(0, 1), cursor.GetPosition());",9,<empty>,,2518,1197,CPPASTProblemDeclaration,,<empty>
568872,UNKNOWN,1198,,},5,<empty>,,2519,1198,CPPASTProblemDeclaration,,<empty>
568873,UNKNOWN,1199,,"TEST_METHOD(SetConsoleTitleTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2521,1199,CPPASTProblemDeclaration,,<empty>
568874,UNKNOWN,1200,,"Log::Comment(L""Test 1: set title to be non-null"");",9,<empty>,,2525,1200,CPPASTProblemDeclaration,,<empty>
568875,UNKNOWN,1201,,_testGetSet->_setWindowTitleResult = TRUE;,9,<empty>,,2526,1201,CPPASTProblemDeclaration,,<empty>
568876,UNKNOWN,1202,,"_testGetSet->_expectedWindowTitle = L""Foo bar"";",9,<empty>,,2527,1202,CPPASTProblemDeclaration,,<empty>
568877,UNKNOWN,1203,,VERIFY_IS_TRUE(_pDispatch->SetWindowTitle(_testGetSet->_expectedWindowTitle));,9,<empty>,,2529,1203,CPPASTProblemDeclaration,,<empty>
568878,UNKNOWN,1204,,"Log::Comment(L""Test 2: set title to be null"");",9,<empty>,,2531,1204,CPPASTProblemDeclaration,,<empty>
568879,UNKNOWN,1205,,_testGetSet->_setWindowTitleResult = FALSE;,9,<empty>,,2532,1205,CPPASTProblemDeclaration,,<empty>
568880,UNKNOWN,1206,,_testGetSet->_expectedWindowTitle = {};,9,<empty>,,2533,1206,CPPASTProblemDeclaration,,<empty>
568881,UNKNOWN,1207,,VERIFY_IS_TRUE(_pDispatch->SetWindowTitle({},9,<empty>,,2535,1207,CPPASTProblemDeclaration,,<empty>
568882,UNKNOWN,1208,,));,53,<empty>,,2535,1208,CPPASTProblemDeclaration,,<empty>
568883,UNKNOWN,1209,,},5,<empty>,,2536,1209,CPPASTProblemDeclaration,,<empty>
568884,UNKNOWN,1210,,"TEST_METHOD(TestMouseModes)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2538,1210,CPPASTProblemDeclaration,,<empty>
568885,UNKNOWN,1211,,"Log::Comment(L""Test 1: Test Default Mouse Mode"");",9,<empty>,,2542,1211,CPPASTProblemDeclaration,,<empty>
568886,UNKNOWN,1212,,"_terminalInput.SetInputMode(TerminalInput::Mode::DefaultMouseTracking, false);",9,<empty>,,2543,1212,CPPASTProblemDeclaration,,<empty>
568887,UNKNOWN,1213,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::VT200_MOUSE_MODE));,9,<empty>,,2544,1213,CPPASTProblemDeclaration,,<empty>
568888,UNKNOWN,1214,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::DefaultMouseTracking));,9,<empty>,,2545,1214,CPPASTProblemDeclaration,,<empty>
568889,UNKNOWN,1215,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::VT200_MOUSE_MODE));,9,<empty>,,2546,1215,CPPASTProblemDeclaration,,<empty>
568890,UNKNOWN,1216,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::DefaultMouseTracking));,9,<empty>,,2547,1216,CPPASTProblemDeclaration,,<empty>
568891,UNKNOWN,1217,,"Log::Comment(L""Test 2: Test UTF-8 Extended Mouse Mode"");",9,<empty>,,2549,1217,CPPASTProblemDeclaration,,<empty>
568892,UNKNOWN,1218,,"_terminalInput.SetInputMode(TerminalInput::Mode::Utf8MouseEncoding, false);",9,<empty>,,2550,1218,CPPASTProblemDeclaration,,<empty>
568893,UNKNOWN,1219,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::UTF8_EXTENDED_MODE));,9,<empty>,,2551,1219,CPPASTProblemDeclaration,,<empty>
568894,UNKNOWN,1220,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::Utf8MouseEncoding));,9,<empty>,,2552,1220,CPPASTProblemDeclaration,,<empty>
568895,UNKNOWN,1221,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::UTF8_EXTENDED_MODE));,9,<empty>,,2553,1221,CPPASTProblemDeclaration,,<empty>
568896,UNKNOWN,1222,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::Utf8MouseEncoding));,9,<empty>,,2554,1222,CPPASTProblemDeclaration,,<empty>
568897,UNKNOWN,1223,,"Log::Comment(L""Test 3: Test SGR Extended Mouse Mode"");",9,<empty>,,2556,1223,CPPASTProblemDeclaration,,<empty>
568898,UNKNOWN,1224,,"_terminalInput.SetInputMode(TerminalInput::Mode::SgrMouseEncoding, false);",9,<empty>,,2557,1224,CPPASTProblemDeclaration,,<empty>
568899,UNKNOWN,1225,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::SGR_EXTENDED_MODE));,9,<empty>,,2558,1225,CPPASTProblemDeclaration,,<empty>
568900,UNKNOWN,1226,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::SgrMouseEncoding));,9,<empty>,,2559,1226,CPPASTProblemDeclaration,,<empty>
568901,UNKNOWN,1227,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::SGR_EXTENDED_MODE));,9,<empty>,,2560,1227,CPPASTProblemDeclaration,,<empty>
568902,UNKNOWN,1228,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::SgrMouseEncoding));,9,<empty>,,2561,1228,CPPASTProblemDeclaration,,<empty>
568903,UNKNOWN,1229,,"Log::Comment(L""Test 4: Test Button-Event Mouse Mode"");",9,<empty>,,2563,1229,CPPASTProblemDeclaration,,<empty>
568904,UNKNOWN,1230,,"_terminalInput.SetInputMode(TerminalInput::Mode::ButtonEventMouseTracking, false);",9,<empty>,,2564,1230,CPPASTProblemDeclaration,,<empty>
568905,UNKNOWN,1231,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::BUTTON_EVENT_MOUSE_MODE));,9,<empty>,,2565,1231,CPPASTProblemDeclaration,,<empty>
568906,UNKNOWN,1232,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::ButtonEventMouseTracking));,9,<empty>,,2566,1232,CPPASTProblemDeclaration,,<empty>
568907,UNKNOWN,1233,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::BUTTON_EVENT_MOUSE_MODE));,9,<empty>,,2567,1233,CPPASTProblemDeclaration,,<empty>
568908,UNKNOWN,1234,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::ButtonEventMouseTracking));,9,<empty>,,2568,1234,CPPASTProblemDeclaration,,<empty>
568909,UNKNOWN,1235,,"Log::Comment(L""Test 5: Test Any-Event Mouse Mode"");",9,<empty>,,2570,1235,CPPASTProblemDeclaration,,<empty>
568910,UNKNOWN,1236,,"_terminalInput.SetInputMode(TerminalInput::Mode::AnyEventMouseTracking, false);",9,<empty>,,2571,1236,CPPASTProblemDeclaration,,<empty>
568911,UNKNOWN,1237,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::ANY_EVENT_MOUSE_MODE));,9,<empty>,,2572,1237,CPPASTProblemDeclaration,,<empty>
568912,UNKNOWN,1238,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::AnyEventMouseTracking));,9,<empty>,,2573,1238,CPPASTProblemDeclaration,,<empty>
568913,UNKNOWN,1239,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::ANY_EVENT_MOUSE_MODE));,9,<empty>,,2574,1239,CPPASTProblemDeclaration,,<empty>
568914,UNKNOWN,1240,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::AnyEventMouseTracking));,9,<empty>,,2575,1240,CPPASTProblemDeclaration,,<empty>
568915,UNKNOWN,1241,,"Log::Comment(L""Test 6: Test Alt Scroll Mouse Mode"");",9,<empty>,,2577,1241,CPPASTProblemDeclaration,,<empty>
568916,UNKNOWN,1242,,"_terminalInput.SetInputMode(TerminalInput::Mode::AlternateScroll, false);",9,<empty>,,2578,1242,CPPASTProblemDeclaration,,<empty>
568917,UNKNOWN,1243,,VERIFY_IS_TRUE(_pDispatch->SetMode(DispatchTypes::ALTERNATE_SCROLL));,9,<empty>,,2579,1243,CPPASTProblemDeclaration,,<empty>
568918,UNKNOWN,1244,,VERIFY_IS_TRUE(_terminalInput.GetInputMode(TerminalInput::Mode::AlternateScroll));,9,<empty>,,2580,1244,CPPASTProblemDeclaration,,<empty>
568919,UNKNOWN,1245,,VERIFY_IS_TRUE(_pDispatch->ResetMode(DispatchTypes::ALTERNATE_SCROLL));,9,<empty>,,2581,1245,CPPASTProblemDeclaration,,<empty>
568920,UNKNOWN,1246,,VERIFY_IS_FALSE(_terminalInput.GetInputMode(TerminalInput::Mode::AlternateScroll));,9,<empty>,,2582,1246,CPPASTProblemDeclaration,,<empty>
568921,UNKNOWN,1247,,},5,<empty>,,2583,1247,CPPASTProblemDeclaration,,<empty>
568922,UNKNOWN,1248,,"TEST_METHOD(Xterm256ColorTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2585,1248,CPPASTProblemDeclaration,,<empty>
568923,UNKNOWN,1249,,_testGetSet->PrepData();,9,<empty>,,2589,1249,CPPASTProblemDeclaration,,<empty>
568931,UNKNOWN,1254,,_testGetSet->_expectedAttribute = _testGetSet->_textBuffer->GetCurrentAttributes();,9,<empty>,,2594,1254,CPPASTProblemDeclaration,,<empty>
568932,UNKNOWN,1255,,"Log::Comment(L""Test 1: Change Foreground"");",9,<empty>,,2596,1255,CPPASTProblemDeclaration,,<empty>
568933,UNKNOWN,1256,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2597,1256,CPPASTProblemDeclaration,,<empty>
568934,UNKNOWN,1257,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2598,1257,CPPASTProblemDeclaration,,<empty>
568935,UNKNOWN,1258,,rgOptions[2] = (DispatchTypes::GraphicsOptions)2;,9,<empty>,,2599,1258,CPPASTProblemDeclaration,,<empty>
568936,UNKNOWN,1259,,_testGetSet->_expectedAttribute.SetIndexedForeground256(TextColor::DARK_GREEN);,9,<empty>,,2600,1259,CPPASTProblemDeclaration,,<empty>
568937,UNKNOWN,1260,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,2601,1260,CPPASTProblemDeclaration,,<empty>
568938,UNKNOWN,1261,,));,80,<empty>,,2601,1261,CPPASTProblemDeclaration,,<empty>
568939,UNKNOWN,1262,,"Log::Comment(L""Test 2: Change Background"");",9,<empty>,,2603,1262,CPPASTProblemDeclaration,,<empty>
568940,UNKNOWN,1263,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2604,1263,CPPASTProblemDeclaration,,<empty>
568941,UNKNOWN,1264,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2605,1264,CPPASTProblemDeclaration,,<empty>
568942,UNKNOWN,1265,,rgOptions[2] = (DispatchTypes::GraphicsOptions)9;,9,<empty>,,2606,1265,CPPASTProblemDeclaration,,<empty>
568943,UNKNOWN,1266,,_testGetSet->_expectedAttribute.SetIndexedBackground256(TextColor::BRIGHT_RED);,9,<empty>,,2607,1266,CPPASTProblemDeclaration,,<empty>
568944,UNKNOWN,1267,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,2608,1267,CPPASTProblemDeclaration,,<empty>
568945,UNKNOWN,1268,,));,80,<empty>,,2608,1268,CPPASTProblemDeclaration,,<empty>
568946,UNKNOWN,1269,,"Log::Comment(L""Test 3: Change Foreground to RGB color"");",9,<empty>,,2610,1269,CPPASTProblemDeclaration,,<empty>
568947,UNKNOWN,1270,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2611,1270,CPPASTProblemDeclaration,,<empty>
568948,UNKNOWN,1271,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2612,1271,CPPASTProblemDeclaration,,<empty>
568949,UNKNOWN,1272,,rgOptions[2] = (DispatchTypes::GraphicsOptions)42;,9,<empty>,,2613,1272,CPPASTProblemDeclaration,,<empty>
568950,UNKNOWN,1273,,_testGetSet->_expectedAttribute.SetIndexedForeground256(42);,9,<empty>,,2614,1273,CPPASTProblemDeclaration,,<empty>
568951,UNKNOWN,1274,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,2615,1274,CPPASTProblemDeclaration,,<empty>
568952,UNKNOWN,1275,,));,80,<empty>,,2615,1275,CPPASTProblemDeclaration,,<empty>
568953,UNKNOWN,1276,,"Log::Comment(L""Test 4: Change Background to RGB color"");",9,<empty>,,2617,1276,CPPASTProblemDeclaration,,<empty>
568954,UNKNOWN,1277,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2618,1277,CPPASTProblemDeclaration,,<empty>
568955,UNKNOWN,1278,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2619,1278,CPPASTProblemDeclaration,,<empty>
568956,UNKNOWN,1279,,rgOptions[2] = (DispatchTypes::GraphicsOptions)142;,9,<empty>,,2620,1279,CPPASTProblemDeclaration,,<empty>
568957,UNKNOWN,1280,,_testGetSet->_expectedAttribute.SetIndexedBackground256(142);,9,<empty>,,2621,1280,CPPASTProblemDeclaration,,<empty>
568958,UNKNOWN,1281,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,2622,1281,CPPASTProblemDeclaration,,<empty>
568959,UNKNOWN,1282,,));,80,<empty>,,2622,1282,CPPASTProblemDeclaration,,<empty>
568960,UNKNOWN,1283,,"Log::Comment(L""Test 5: Change Foreground to Legacy Attr while BG is RGB color"");",9,<empty>,,2624,1283,CPPASTProblemDeclaration,,<empty>
568961,UNKNOWN,1284,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2628,1284,CPPASTProblemDeclaration,,<empty>
568962,UNKNOWN,1285,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2629,1285,CPPASTProblemDeclaration,,<empty>
568963,UNKNOWN,1286,,rgOptions[2] = (DispatchTypes::GraphicsOptions)9;,9,<empty>,,2630,1286,CPPASTProblemDeclaration,,<empty>
568964,UNKNOWN,1287,,_testGetSet->_expectedAttribute.SetIndexedForeground256(TextColor::BRIGHT_RED);,9,<empty>,,2631,1287,CPPASTProblemDeclaration,,<empty>
568965,UNKNOWN,1288,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, cOptions }",9,<empty>,,2632,1288,CPPASTProblemDeclaration,,<empty>
568966,UNKNOWN,1289,,));,80,<empty>,,2632,1289,CPPASTProblemDeclaration,,<empty>
568967,UNKNOWN,1290,,},5,<empty>,,2633,1290,CPPASTProblemDeclaration,,<empty>
568968,UNKNOWN,1291,,"TEST_METHOD(XtermExtendedColorDefaultParameterTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2635,1291,CPPASTProblemDeclaration,,<empty>
568969,UNKNOWN,1292,,_testGetSet->PrepData();,9,<empty>,,2639,1292,CPPASTProblemDeclaration,,<empty>
568973,UNKNOWN,1295,,_testGetSet->_expectedAttribute = _testGetSet->_textBuffer->GetCurrentAttributes();,9,<empty>,,2643,1295,CPPASTProblemDeclaration,,<empty>
568974,UNKNOWN,1296,,"Log::Comment(L""Test 1: Change Indexed Foreground with missing index parameter"");",9,<empty>,,2645,1296,CPPASTProblemDeclaration,,<empty>
568975,UNKNOWN,1297,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2646,1297,CPPASTProblemDeclaration,,<empty>
568976,UNKNOWN,1298,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2647,1298,CPPASTProblemDeclaration,,<empty>
568977,UNKNOWN,1299,,_testGetSet->_expectedAttribute.SetIndexedForeground256(TextColor::DARK_BLACK);,9,<empty>,,2648,1299,CPPASTProblemDeclaration,,<empty>
568978,UNKNOWN,1300,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 2 }",9,<empty>,,2649,1300,CPPASTProblemDeclaration,,<empty>
568979,UNKNOWN,1301,,));,73,<empty>,,2649,1301,CPPASTProblemDeclaration,,<empty>
568980,UNKNOWN,1302,,"Log::Comment(L""Test 2: Change Indexed Background with default index parameter"");",9,<empty>,,2651,1302,CPPASTProblemDeclaration,,<empty>
568981,UNKNOWN,1303,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2652,1303,CPPASTProblemDeclaration,,<empty>
568982,UNKNOWN,1304,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2653,1304,CPPASTProblemDeclaration,,<empty>
568987,UNKNOWN,1307,,_testGetSet->_expectedAttribute.SetIndexedBackground256(TextColor::DARK_BLACK);,9,<empty>,,2655,1307,CPPASTProblemDeclaration,,<empty>
568988,UNKNOWN,1308,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 3 }",9,<empty>,,2656,1308,CPPASTProblemDeclaration,,<empty>
568989,UNKNOWN,1309,,));,73,<empty>,,2656,1309,CPPASTProblemDeclaration,,<empty>
568990,UNKNOWN,1310,,"Log::Comment(L""Test 3: Change RGB Foreground with all RGB parameters missing"");",9,<empty>,,2658,1310,CPPASTProblemDeclaration,,<empty>
568991,UNKNOWN,1311,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2659,1311,CPPASTProblemDeclaration,,<empty>
568992,UNKNOWN,1312,,rgOptions[1] = DispatchTypes::GraphicsOptions::RGBColorOrFaint;,9,<empty>,,2660,1312,CPPASTProblemDeclaration,,<empty>
568993,UNKNOWN,1313,,"_testGetSet->_expectedAttribute.SetForeground(RGB(0, 0, 0));",9,<empty>,,2661,1313,CPPASTProblemDeclaration,,<empty>
568994,UNKNOWN,1314,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 2 }",9,<empty>,,2662,1314,CPPASTProblemDeclaration,,<empty>
568995,UNKNOWN,1315,,));,73,<empty>,,2662,1315,CPPASTProblemDeclaration,,<empty>
568996,UNKNOWN,1316,,"Log::Comment(L""Test 4: Change RGB Background with some missing RGB parameters"");",9,<empty>,,2664,1316,CPPASTProblemDeclaration,,<empty>
568997,UNKNOWN,1317,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2665,1317,CPPASTProblemDeclaration,,<empty>
568998,UNKNOWN,1318,,rgOptions[1] = DispatchTypes::GraphicsOptions::RGBColorOrFaint;,9,<empty>,,2666,1318,CPPASTProblemDeclaration,,<empty>
568999,UNKNOWN,1319,,rgOptions[2] = 123;,9,<empty>,,2667,1319,CPPASTProblemDeclaration,,<empty>
569000,UNKNOWN,1320,,"_testGetSet->_expectedAttribute.SetBackground(RGB(123, 0, 0));",9,<empty>,,2668,1320,CPPASTProblemDeclaration,,<empty>
569001,UNKNOWN,1321,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 3 }",9,<empty>,,2669,1321,CPPASTProblemDeclaration,,<empty>
569002,UNKNOWN,1322,,));,73,<empty>,,2669,1322,CPPASTProblemDeclaration,,<empty>
569003,UNKNOWN,1323,,"Log::Comment(L""Test 5: Change RGB Foreground with some default RGB parameters"");",9,<empty>,,2671,1323,CPPASTProblemDeclaration,,<empty>
569004,UNKNOWN,1324,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2672,1324,CPPASTProblemDeclaration,,<empty>
569005,UNKNOWN,1325,,rgOptions[1] = DispatchTypes::GraphicsOptions::RGBColorOrFaint;,9,<empty>,,2673,1325,CPPASTProblemDeclaration,,<empty>
569014,UNKNOWN,1330,,rgOptions[4] = 123;,9,<empty>,,2676,1330,CPPASTProblemDeclaration,,<empty>
569015,UNKNOWN,1331,,"_testGetSet->_expectedAttribute.SetForeground(RGB(0, 0, 123));",9,<empty>,,2677,1331,CPPASTProblemDeclaration,,<empty>
569016,UNKNOWN,1332,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 5 }",9,<empty>,,2678,1332,CPPASTProblemDeclaration,,<empty>
569017,UNKNOWN,1333,,));,73,<empty>,,2678,1333,CPPASTProblemDeclaration,,<empty>
569018,UNKNOWN,1334,,"Log::Comment(L""Test 6: Ignore Rgb color when R, G or B is out of range (>255)"");",9,<empty>,,2680,1334,CPPASTProblemDeclaration,,<empty>
569019,UNKNOWN,1335,,_testGetSet->PrepData();,9,<empty>,,2681,1335,CPPASTProblemDeclaration,,<empty>
569020,UNKNOWN,1336,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2682,1336,CPPASTProblemDeclaration,,<empty>
569021,UNKNOWN,1337,,rgOptions[1] = DispatchTypes::GraphicsOptions::RGBColorOrFaint;,9,<empty>,,2683,1337,CPPASTProblemDeclaration,,<empty>
569022,UNKNOWN,1338,,rgOptions[2] = 283;,9,<empty>,,2684,1338,CPPASTProblemDeclaration,,<empty>
569023,UNKNOWN,1339,,rgOptions[3] = 182;,9,<empty>,,2685,1339,CPPASTProblemDeclaration,,<empty>
569024,UNKNOWN,1340,,rgOptions[4] = 123;,9,<empty>,,2686,1340,CPPASTProblemDeclaration,,<empty>
569025,UNKNOWN,1341,,_testGetSet->_expectedAttribute = TextAttribute{ FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED };,9,<empty>,,2688,1341,CPPASTProblemDeclaration,,<empty>
569026,UNKNOWN,1342,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 5 }",9,<empty>,,2689,1342,CPPASTProblemDeclaration,,<empty>
569027,UNKNOWN,1343,,));,73,<empty>,,2689,1343,CPPASTProblemDeclaration,,<empty>
569028,UNKNOWN,1344,,"Log::Comment(L""Test 7: Ignore indexed color when index is out of range (>255)"");",9,<empty>,,2691,1344,CPPASTProblemDeclaration,,<empty>
569029,UNKNOWN,1345,,_testGetSet->PrepData();,9,<empty>,,2692,1345,CPPASTProblemDeclaration,,<empty>
569030,UNKNOWN,1346,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2693,1346,CPPASTProblemDeclaration,,<empty>
569031,UNKNOWN,1347,,rgOptions[1] = DispatchTypes::GraphicsOptions::BlinkOrXterm256Index;,9,<empty>,,2694,1347,CPPASTProblemDeclaration,,<empty>
569032,UNKNOWN,1348,,rgOptions[2] = 283;,9,<empty>,,2695,1348,CPPASTProblemDeclaration,,<empty>
569033,UNKNOWN,1349,,_testGetSet->_expectedAttribute = TextAttribute{ FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED };,9,<empty>,,2697,1349,CPPASTProblemDeclaration,,<empty>
569034,UNKNOWN,1350,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, 3 }",9,<empty>,,2698,1350,CPPASTProblemDeclaration,,<empty>
569035,UNKNOWN,1351,,));,73,<empty>,,2698,1351,CPPASTProblemDeclaration,,<empty>
569036,UNKNOWN,1352,,},5,<empty>,,2699,1352,CPPASTProblemDeclaration,,<empty>
569037,UNKNOWN,1353,,"TEST_METHOD(XtermExtendedSubParameterColorTest)
    {
        Log::Comment(L""Starting test..."");",5,<empty>,,2701,1353,CPPASTProblemDeclaration,,<empty>
569038,UNKNOWN,1354,,_testGetSet->PrepData();,9,<empty>,,2705,1354,CPPASTProblemDeclaration,,<empty>
569044,UNKNOWN,1359,,_testGetSet->_expectedAttribute = _testGetSet->_textBuffer->GetCurrentAttributes();,9,<empty>,,2711,1359,CPPASTProblemDeclaration,,<empty>
569045,UNKNOWN,1360,,"Log::Comment(L""Test 1: Change Indexed Foreground with missing index sub parameter"");",9,<empty>,,2713,1360,CPPASTProblemDeclaration,,<empty>
569046,UNKNOWN,1361,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2714,1361,CPPASTProblemDeclaration,,<empty>
569047,UNKNOWN,1362,,_testGetSet->MakeSubParamsAndRanges({ { 5 } },9,<empty>,,2715,1362,CPPASTProblemDeclaration,,<empty>
569048,UNKNOWN,1363,,", rgSubParamOpts, subParamRanges);",54,<empty>,,2715,1363,CPPASTProblemDeclaration,,<empty>
569049,UNKNOWN,1364,,_testGetSet->_expectedAttribute.SetIndexedForeground256(TextColor::DARK_BLACK);,9,<empty>,,2716,1364,CPPASTProblemDeclaration,,<empty>
569050,UNKNOWN,1365,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2717,1365,CPPASTProblemDeclaration,,<empty>
569051,UNKNOWN,1366,,));,102,<empty>,,2717,1366,CPPASTProblemDeclaration,,<empty>
569052,UNKNOWN,1367,,"Log::Comment(L""Test 2: Change Indexed Background with default index sub parameter"");",9,<empty>,,2719,1367,CPPASTProblemDeclaration,,<empty>
569053,UNKNOWN,1368,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2720,1368,CPPASTProblemDeclaration,,<empty>
569054,UNKNOWN,1369,,"_testGetSet->MakeSubParamsAndRanges({ { 5, {} } }",9,<empty>,,2721,1369,CPPASTProblemDeclaration,,<empty>
569055,UNKNOWN,1370,,", rgSubParamOpts, subParamRanges);",58,<empty>,,2721,1370,CPPASTProblemDeclaration,,<empty>
569056,UNKNOWN,1371,,_testGetSet->_expectedAttribute.SetIndexedBackground256(TextColor::DARK_BLACK);,9,<empty>,,2722,1371,CPPASTProblemDeclaration,,<empty>
569057,UNKNOWN,1372,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2723,1372,CPPASTProblemDeclaration,,<empty>
569058,UNKNOWN,1373,,));,102,<empty>,,2723,1373,CPPASTProblemDeclaration,,<empty>
569059,UNKNOWN,1374,,"Log::Comment(L""Test 3: Change RGB Foreground with all RGB sub parameters missing"");",9,<empty>,,2725,1374,CPPASTProblemDeclaration,,<empty>
569060,UNKNOWN,1375,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2726,1375,CPPASTProblemDeclaration,,<empty>
569061,UNKNOWN,1376,,_testGetSet->MakeSubParamsAndRanges({ { 2 } },9,<empty>,,2727,1376,CPPASTProblemDeclaration,,<empty>
569062,UNKNOWN,1377,,", rgSubParamOpts, subParamRanges);",54,<empty>,,2727,1377,CPPASTProblemDeclaration,,<empty>
569063,UNKNOWN,1378,,"_testGetSet->_expectedAttribute.SetForeground(RGB(0, 0, 0));",9,<empty>,,2728,1378,CPPASTProblemDeclaration,,<empty>
569064,UNKNOWN,1379,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2729,1379,CPPASTProblemDeclaration,,<empty>
569065,UNKNOWN,1380,,));,102,<empty>,,2729,1380,CPPASTProblemDeclaration,,<empty>
569066,UNKNOWN,1381,,"Log::Comment(L""Test 4: Change RGB Background with some missing RGB sub parameters"");",9,<empty>,,2731,1381,CPPASTProblemDeclaration,,<empty>
569067,UNKNOWN,1382,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2732,1382,CPPASTProblemDeclaration,,<empty>
569068,UNKNOWN,1383,,"_testGetSet->MakeSubParamsAndRanges({ { 2, {}, 123 } }",9,<empty>,,2733,1383,CPPASTProblemDeclaration,,<empty>
569069,UNKNOWN,1384,,", rgSubParamOpts, subParamRanges);",63,<empty>,,2733,1384,CPPASTProblemDeclaration,,<empty>
569070,UNKNOWN,1385,,"_testGetSet->_expectedAttribute.SetBackground(RGB(123, 0, 0));",9,<empty>,,2734,1385,CPPASTProblemDeclaration,,<empty>
569071,UNKNOWN,1386,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2735,1386,CPPASTProblemDeclaration,,<empty>
569072,UNKNOWN,1387,,));,102,<empty>,,2735,1387,CPPASTProblemDeclaration,,<empty>
569073,UNKNOWN,1388,,"Log::Comment(L""Test 5: Change RGB Foreground with some default RGB sub parameters"");",9,<empty>,,2737,1388,CPPASTProblemDeclaration,,<empty>
569074,UNKNOWN,1389,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2738,1389,CPPASTProblemDeclaration,,<empty>
569075,UNKNOWN,1390,,"_testGetSet->MakeSubParamsAndRanges({ { 2, {}, {}, {}, 123 } }",9,<empty>,,2739,1390,CPPASTProblemDeclaration,,<empty>
569076,UNKNOWN,1391,,", rgSubParamOpts, subParamRanges);",71,<empty>,,2739,1391,CPPASTProblemDeclaration,,<empty>
569077,UNKNOWN,1392,,"_testGetSet->_expectedAttribute.SetForeground(RGB(0, 0, 123));",9,<empty>,,2740,1392,CPPASTProblemDeclaration,,<empty>
569078,UNKNOWN,1393,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2741,1393,CPPASTProblemDeclaration,,<empty>
569079,UNKNOWN,1394,,));,102,<empty>,,2741,1394,CPPASTProblemDeclaration,,<empty>
569080,UNKNOWN,1395,,"Log::Comment(L""Test 6: Ignore color when ColorSpaceID is not empty"");",9,<empty>,,2743,1395,CPPASTProblemDeclaration,,<empty>
569081,UNKNOWN,1396,,_testGetSet->PrepData();,9,<empty>,,2744,1396,CPPASTProblemDeclaration,,<empty>
569082,UNKNOWN,1397,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2745,1397,CPPASTProblemDeclaration,,<empty>
569083,UNKNOWN,1398,,"_testGetSet->MakeSubParamsAndRanges({ { 2, 7, 182, 182, 123 } }",9,<empty>,,2746,1398,CPPASTProblemDeclaration,,<empty>
569084,UNKNOWN,1399,,", rgSubParamOpts, subParamRanges);",72,<empty>,,2746,1399,CPPASTProblemDeclaration,,<empty>
569085,UNKNOWN,1400,,_testGetSet->_expectedAttribute = TextAttribute{ FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED };,9,<empty>,,2748,1400,CPPASTProblemDeclaration,,<empty>
569086,UNKNOWN,1401,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2749,1401,CPPASTProblemDeclaration,,<empty>
569087,UNKNOWN,1402,,));,102,<empty>,,2749,1402,CPPASTProblemDeclaration,,<empty>
569088,UNKNOWN,1403,,"Log::Comment(L""Test 7: Ignore Rgb color when R, G or B is out of range (>255)"");",9,<empty>,,2751,1403,CPPASTProblemDeclaration,,<empty>
569089,UNKNOWN,1404,,_testGetSet->PrepData();,9,<empty>,,2752,1404,CPPASTProblemDeclaration,,<empty>
569090,UNKNOWN,1405,,rgOptions[0] = DispatchTypes::GraphicsOptions::BackgroundExtended;,9,<empty>,,2753,1405,CPPASTProblemDeclaration,,<empty>
569091,UNKNOWN,1406,,"_testGetSet->MakeSubParamsAndRanges({ { 2, {}, 128, 283, 155 } }",9,<empty>,,2756,1406,CPPASTProblemDeclaration,,<empty>
569092,UNKNOWN,1407,,", rgSubParamOpts, subParamRanges);",73,<empty>,,2756,1407,CPPASTProblemDeclaration,,<empty>
569093,UNKNOWN,1408,,_testGetSet->_expectedAttribute = TextAttribute{ FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED };,9,<empty>,,2758,1408,CPPASTProblemDeclaration,,<empty>
569094,UNKNOWN,1409,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2759,1409,CPPASTProblemDeclaration,,<empty>
569095,UNKNOWN,1410,,));,102,<empty>,,2759,1410,CPPASTProblemDeclaration,,<empty>
569096,UNKNOWN,1411,,"Log::Comment(L""Test 8: Ignore indexed color when index is out of range (>255)"");",9,<empty>,,2761,1411,CPPASTProblemDeclaration,,<empty>
569097,UNKNOWN,1412,,_testGetSet->PrepData();,9,<empty>,,2762,1412,CPPASTProblemDeclaration,,<empty>
569098,UNKNOWN,1413,,rgOptions[0] = DispatchTypes::GraphicsOptions::ForegroundExtended;,9,<empty>,,2763,1413,CPPASTProblemDeclaration,,<empty>
569099,UNKNOWN,1414,,"_testGetSet->MakeSubParamsAndRanges({ { 5, 283 } }",9,<empty>,,2764,1414,CPPASTProblemDeclaration,,<empty>
569100,UNKNOWN,1415,,", rgSubParamOpts, subParamRanges);",59,<empty>,,2764,1415,CPPASTProblemDeclaration,,<empty>
569101,UNKNOWN,1416,,_testGetSet->_expectedAttribute = TextAttribute{ FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED };,9,<empty>,,2766,1416,CPPASTProblemDeclaration,,<empty>
569102,UNKNOWN,1417,,"VERIFY_IS_TRUE(_pDispatch->SetGraphicsRendition({ rgOptions, rgSubParamOpts, subParamRanges }",9,<empty>,,2767,1417,CPPASTProblemDeclaration,,<empty>
569103,UNKNOWN,1418,,));,102,<empty>,,2767,1418,CPPASTProblemDeclaration,,<empty>
569104,UNKNOWN,1419,,},5,<empty>,,2768,1419,CPPASTProblemDeclaration,,<empty>
569105,UNKNOWN,1420,,"TEST_METHOD(SetColorTableValue)
    {
        _testGetSet->PrepData();",5,<empty>,,2770,1420,CPPASTProblemDeclaration,,<empty>
569121,UNKNOWN,1425,,for (size_t i = 0;,9,<empty>,,2777,1425,CPPASTProblemDeclaration,,<empty>
569122,UNKNOWN,1426,,i < 256;,28,<empty>,,2777,1426,CPPASTProblemDeclaration,,<empty>
569123,UNKNOWN,1427,,"i++)
        {
            VERIFY_IS_TRUE(_pDispatch->SetColorTableEntry(i, testColor));
            VERIFY_ARE_EQUAL(testColor, renderSettings.GetColorTableEntry(i));
        }",37,<empty>,,2777,1427,CPPASTProblemDeclaration,,<empty>
569124,UNKNOWN,1428,,},5,<empty>,,2782,1428,CPPASTProblemDeclaration,,<empty>
569125,UNKNOWN,1429,,"TEST_METHOD(SoftFontSizeDetection)
    {
        using CellMatrix = DispatchTypes::DrcsCellMatrix;",5,<empty>,,2784,1429,CPPASTProblemDeclaration,,<empty>
569132,UNKNOWN,1436,,"Log::Comment(L""Matrix 5x10 for 80x24 font set with text usage"");",9,<empty>,,2814,1436,CPPASTProblemDeclaration,,<empty>
569139,UNKNOWN,1439,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size5x10, 0, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2816,1439,CPPASTProblemDeclaration,,<empty>
569140,UNKNOWN,1440,,"Log::Comment(L""Matrix 6x10 for 80x24 font set with text usage"");",9,<empty>,,2817,1440,CPPASTProblemDeclaration,,<empty>
569147,UNKNOWN,1443,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size6x10, 0, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2819,1443,CPPASTProblemDeclaration,,<empty>
569148,UNKNOWN,1444,,"Log::Comment(L""Matrix 7x10 for 80x24 font set with text usage"");",9,<empty>,,2820,1444,CPPASTProblemDeclaration,,<empty>
569155,UNKNOWN,1447,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size7x10, 0, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2822,1447,CPPASTProblemDeclaration,,<empty>
569156,UNKNOWN,1448,,"Log::Comment(L""Matrix 5x10 for 132x24 font set with text usage"");",9,<empty>,,2825,1448,CPPASTProblemDeclaration,,<empty>
569163,UNKNOWN,1451,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size5x10, 0, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2827,1451,CPPASTProblemDeclaration,,<empty>
569164,UNKNOWN,1452,,"Log::Comment(L""Matrix 6x10 for 132x24 font set with text usage"");",9,<empty>,,2828,1452,CPPASTProblemDeclaration,,<empty>
569171,UNKNOWN,1455,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size6x10, 0, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2830,1455,CPPASTProblemDeclaration,,<empty>
569172,UNKNOWN,1456,,"Log::Comment(L""Matrix 7x10 for 132x24 font set with text usage (VT220 only)"");",9,<empty>,,2831,1456,CPPASTProblemDeclaration,,<empty>
569179,UNKNOWN,1459,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size7x10, 0, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2833,1459,CPPASTProblemDeclaration,,<empty>
569180,UNKNOWN,1460,,"Log::Comment(L""Matrix 5x10 for 80x24 font set with full cell usage (invalid)"");",9,<empty>,,2836,1460,CPPASTProblemDeclaration,,<empty>
569181,UNKNOWN,1461,,"VERIFY_IS_FALSE(decdld(CellMatrix::Size5x10, 0, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2837,1461,CPPASTProblemDeclaration,,<empty>
569182,UNKNOWN,1462,,"Log::Comment(L""Matrix 6x10 for 80x24 font set with full cell usage (invalid)"");",9,<empty>,,2838,1462,CPPASTProblemDeclaration,,<empty>
569183,UNKNOWN,1463,,"VERIFY_IS_FALSE(decdld(CellMatrix::Size6x10, 0, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2839,1463,CPPASTProblemDeclaration,,<empty>
569184,UNKNOWN,1464,,"Log::Comment(L""Matrix 7x10 for 80x24 font set with full cell usage (invalid)"");",9,<empty>,,2840,1464,CPPASTProblemDeclaration,,<empty>
569185,UNKNOWN,1465,,"VERIFY_IS_FALSE(decdld(CellMatrix::Size7x10, 0, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2841,1465,CPPASTProblemDeclaration,,<empty>
569186,UNKNOWN,1466,,"Log::Comment(L""Matrix 5x10 for 132x24 font set with full cell usage (invalid)"");",9,<empty>,,2842,1466,CPPASTProblemDeclaration,,<empty>
569187,UNKNOWN,1467,,"VERIFY_IS_FALSE(decdld(CellMatrix::Size5x10, 0, FontSet::Size132x24, FontUsage::FullCell));",9,<empty>,,2843,1467,CPPASTProblemDeclaration,,<empty>
569188,UNKNOWN,1468,,"Log::Comment(L""Matrix 6x10 for 132x24 font set with full cell usage"");",9,<empty>,,2844,1468,CPPASTProblemDeclaration,,<empty>
569195,UNKNOWN,1471,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size6x10, 0, FontSet::Size132x24, FontUsage::FullCell));",9,<empty>,,2846,1471,CPPASTProblemDeclaration,,<empty>
569196,UNKNOWN,1472,,"Log::Comment(L""Matrix 7x10 for 132x24 font set with full cell usage (invalid)"");",9,<empty>,,2847,1472,CPPASTProblemDeclaration,,<empty>
569197,UNKNOWN,1473,,"VERIFY_IS_FALSE(decdld(CellMatrix::Size7x10, 0, FontSet::Size132x24, FontUsage::FullCell));",9,<empty>,,2848,1473,CPPASTProblemDeclaration,,<empty>
569198,UNKNOWN,1474,,"Log::Comment(L""Matrix 1 for 80x24 font set with text usage (invalid)"");",9,<empty>,,2851,1474,CPPASTProblemDeclaration,,<empty>
569199,UNKNOWN,1475,,"VERIFY_IS_FALSE(decdld(CellMatrix::Invalid, 0, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2852,1475,CPPASTProblemDeclaration,,<empty>
569200,UNKNOWN,1476,,"Log::Comment(L""Matrix 1 for 132x24 font set with text usage (invalid)"");",9,<empty>,,2853,1476,CPPASTProblemDeclaration,,<empty>
569201,UNKNOWN,1477,,"VERIFY_IS_FALSE(decdld(CellMatrix::Invalid, 0, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2854,1477,CPPASTProblemDeclaration,,<empty>
569202,UNKNOWN,1478,,"Log::Comment(L""Matrix 1 for 80x24 font set with full cell usage (invalid)"");",9,<empty>,,2855,1478,CPPASTProblemDeclaration,,<empty>
569203,UNKNOWN,1479,,"VERIFY_IS_FALSE(decdld(CellMatrix::Invalid, 0, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2856,1479,CPPASTProblemDeclaration,,<empty>
569204,UNKNOWN,1480,,"Log::Comment(L""Matrix 1 for 132x24 font set with full cell usage (invalid)"");",9,<empty>,,2857,1480,CPPASTProblemDeclaration,,<empty>
569205,UNKNOWN,1481,,"VERIFY_IS_FALSE(decdld(CellMatrix::Invalid, 0, FontSet::Size132x24, FontUsage::FullCell));",9,<empty>,,2858,1481,CPPASTProblemDeclaration,,<empty>
569206,UNKNOWN,1482,,"Log::Comment(L""Matrix 7x10 with unused height parameter"");",9,<empty>,,2861,1482,CPPASTProblemDeclaration,,<empty>
569213,UNKNOWN,1485,,"VERIFY_IS_TRUE(decdld(CellMatrix::Size7x10, 20, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2863,1485,CPPASTProblemDeclaration,,<empty>
569214,UNKNOWN,1486,,"Log::Comment(L""Explicit 13x17 for 80x24 font set with full cell usage"");",9,<empty>,,2866,1486,CPPASTProblemDeclaration,,<empty>
569221,UNKNOWN,1489,,"VERIFY_IS_TRUE(decdld(13, 17, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2868,1489,CPPASTProblemDeclaration,,<empty>
569222,UNKNOWN,1490,,"Log::Comment(L""Explicit 9x25 for 132x24 font set with full cell usage"");",9,<empty>,,2869,1490,CPPASTProblemDeclaration,,<empty>
569229,UNKNOWN,1493,,"VERIFY_IS_TRUE(decdld(9, 25, FontSet::Size132x24, FontUsage::FullCell));",9,<empty>,,2871,1493,CPPASTProblemDeclaration,,<empty>
569230,UNKNOWN,1494,,"Log::Comment(L""Explicit 18x38 for 80x24 font set with full cell usage (invalid)"");",9,<empty>,,2874,1494,CPPASTProblemDeclaration,,<empty>
569231,UNKNOWN,1495,,"VERIFY_IS_FALSE(decdld(18, 38, FontSet::Size80x24, FontUsage::FullCell));",9,<empty>,,2875,1495,CPPASTProblemDeclaration,,<empty>
569232,UNKNOWN,1496,,"Log::Comment(L""Explicit 12x12 for 80x24 font set with text usage (VT320)"");",9,<empty>,,2878,1496,CPPASTProblemDeclaration,,<empty>
569239,UNKNOWN,1499,,"VERIFY_IS_TRUE(decdld(12, 12, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2880,1499,CPPASTProblemDeclaration,,<empty>
569240,UNKNOWN,1500,,"Log::Comment(L""Explicit 9x20 for 80x24 font set with text usage (VT340)"");",9,<empty>,,2881,1500,CPPASTProblemDeclaration,,<empty>
569247,UNKNOWN,1503,,"VERIFY_IS_TRUE(decdld(9, 20, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2883,1503,CPPASTProblemDeclaration,,<empty>
569248,UNKNOWN,1504,,"Log::Comment(L""Explicit 10x30 for 80x24 font set with text usage (VT382)"");",9,<empty>,,2884,1504,CPPASTProblemDeclaration,,<empty>
569255,UNKNOWN,1507,,"VERIFY_IS_TRUE(decdld(10, 30, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2886,1507,CPPASTProblemDeclaration,,<empty>
569256,UNKNOWN,1508,,"Log::Comment(L""Explicit 8x16 for 80x24 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2887,1508,CPPASTProblemDeclaration,,<empty>
569263,UNKNOWN,1511,,"VERIFY_IS_TRUE(decdld(8, 16, FontSet::Size80x24, FontUsage::Text));",9,<empty>,,2889,1511,CPPASTProblemDeclaration,,<empty>
569264,UNKNOWN,1512,,"Log::Comment(L""Explicit 7x12 for 132x24 font set with text usage (VT320)"");",9,<empty>,,2890,1512,CPPASTProblemDeclaration,,<empty>
569271,UNKNOWN,1515,,"VERIFY_IS_TRUE(decdld(7, 12, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2892,1515,CPPASTProblemDeclaration,,<empty>
569272,UNKNOWN,1516,,"Log::Comment(L""Explicit 5x20 for 132x24 font set with text usage (VT340)"");",9,<empty>,,2893,1516,CPPASTProblemDeclaration,,<empty>
569279,UNKNOWN,1519,,"VERIFY_IS_TRUE(decdld(5, 20, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2895,1519,CPPASTProblemDeclaration,,<empty>
569280,UNKNOWN,1520,,"Log::Comment(L""Explicit 6x30 for 132x24 font set with text usage (VT382)"");",9,<empty>,,2896,1520,CPPASTProblemDeclaration,,<empty>
569287,UNKNOWN,1523,,"VERIFY_IS_TRUE(decdld(6, 30, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2898,1523,CPPASTProblemDeclaration,,<empty>
569288,UNKNOWN,1524,,"Log::Comment(L""Explicit 5x16 for 132x24 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2899,1524,CPPASTProblemDeclaration,,<empty>
569295,UNKNOWN,1527,,"VERIFY_IS_TRUE(decdld(5, 16, FontSet::Size132x24, FontUsage::Text));",9,<empty>,,2901,1527,CPPASTProblemDeclaration,,<empty>
569296,UNKNOWN,1528,,"Log::Comment(L""80x36 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2904,1528,CPPASTProblemDeclaration,,<empty>
569303,UNKNOWN,1531,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x36, FontUsage::Text));",9,<empty>,,2906,1531,CPPASTProblemDeclaration,,<empty>
569304,UNKNOWN,1532,,"Log::Comment(L""80x48 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2907,1532,CPPASTProblemDeclaration,,<empty>
569311,UNKNOWN,1535,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x48, FontUsage::Text));",9,<empty>,,2909,1535,CPPASTProblemDeclaration,,<empty>
569312,UNKNOWN,1536,,"Log::Comment(L""132x36 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2910,1536,CPPASTProblemDeclaration,,<empty>
569319,UNKNOWN,1539,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x36, FontUsage::Text));",9,<empty>,,2912,1539,CPPASTProblemDeclaration,,<empty>
569320,UNKNOWN,1540,,"Log::Comment(L""132x48 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2913,1540,CPPASTProblemDeclaration,,<empty>
569327,UNKNOWN,1543,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x48, FontUsage::Text));",9,<empty>,,2915,1543,CPPASTProblemDeclaration,,<empty>
569328,UNKNOWN,1544,,"Log::Comment(L""80x36 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,2916,1544,CPPASTProblemDeclaration,,<empty>
569335,UNKNOWN,1547,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x36, FontUsage::FullCell));",9,<empty>,,2918,1547,CPPASTProblemDeclaration,,<empty>
569336,UNKNOWN,1548,,"Log::Comment(L""80x48 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,2919,1548,CPPASTProblemDeclaration,,<empty>
569343,UNKNOWN,1551,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x48, FontUsage::FullCell));",9,<empty>,,2921,1551,CPPASTProblemDeclaration,,<empty>
569344,UNKNOWN,1552,,"Log::Comment(L""132x36 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,2922,1552,CPPASTProblemDeclaration,,<empty>
569351,UNKNOWN,1555,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x36, FontUsage::FullCell));",9,<empty>,,2924,1555,CPPASTProblemDeclaration,,<empty>
569352,UNKNOWN,1556,,"Log::Comment(L""132x48 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,2925,1556,CPPASTProblemDeclaration,,<empty>
569359,UNKNOWN,1559,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x48, FontUsage::FullCell));",9,<empty>,,2927,1559,CPPASTProblemDeclaration,,<empty>
569360,UNKNOWN,1560,,"Log::Comment(L""8x12 bitmap for 80x24 font set with text usage (VT2xx)"");",9,<empty>,,2932,1560,CPPASTProblemDeclaration,,<empty>
569371,UNKNOWN,1565,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::Text, bitmapOf8x12));",9,<empty>,,2935,1565,CPPASTProblemDeclaration,,<empty>
569372,UNKNOWN,1566,,"Log::Comment(L""12x12 bitmap for 80x24 font set with text usage (VT320)"");",9,<empty>,,2936,1566,CPPASTProblemDeclaration,,<empty>
569383,UNKNOWN,1571,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::Text, bitmapOf12x12));",9,<empty>,,2939,1571,CPPASTProblemDeclaration,,<empty>
569384,UNKNOWN,1572,,"Log::Comment(L""9x24 bitmap for 80x24 font set with text usage (VT340)"");",9,<empty>,,2940,1572,CPPASTProblemDeclaration,,<empty>
569395,UNKNOWN,1577,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::Text, bitmapOf9x24));",9,<empty>,,2943,1577,CPPASTProblemDeclaration,,<empty>
569396,UNKNOWN,1578,,"Log::Comment(L""10x30 bitmap for 80x24 font set with text usage (VT382)"");",9,<empty>,,2944,1578,CPPASTProblemDeclaration,,<empty>
569407,UNKNOWN,1583,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::Text, bitmapOf10x30));",9,<empty>,,2947,1583,CPPASTProblemDeclaration,,<empty>
569408,UNKNOWN,1584,,"Log::Comment(L""8x18 bitmap for 80x24 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2948,1584,CPPASTProblemDeclaration,,<empty>
569419,UNKNOWN,1589,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::Text, bitmapOf8x18));",9,<empty>,,2951,1589,CPPASTProblemDeclaration,,<empty>
569420,UNKNOWN,1590,,"Log::Comment(L""5x12 bitmap for 132x24 font set with text usage (VT240)"");",9,<empty>,,2953,1590,CPPASTProblemDeclaration,,<empty>
569431,UNKNOWN,1595,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::Text, bitmapOf5x12));",9,<empty>,,2956,1595,CPPASTProblemDeclaration,,<empty>
569432,UNKNOWN,1596,,"Log::Comment(L""7x12 bitmap for 132x24 font set with text usage (VT320)"");",9,<empty>,,2957,1596,CPPASTProblemDeclaration,,<empty>
569443,UNKNOWN,1601,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::Text, bitmapOf7x12));",9,<empty>,,2960,1601,CPPASTProblemDeclaration,,<empty>
569444,UNKNOWN,1602,,"Log::Comment(L""5x24 bitmap for 132x24 font set with text usage (VT340)"");",9,<empty>,,2961,1602,CPPASTProblemDeclaration,,<empty>
569455,UNKNOWN,1607,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::Text, bitmapOf5x24));",9,<empty>,,2964,1607,CPPASTProblemDeclaration,,<empty>
569456,UNKNOWN,1608,,"Log::Comment(L""6x30 bitmap for 132x24 font set with text usage (VT382)"");",9,<empty>,,2965,1608,CPPASTProblemDeclaration,,<empty>
569467,UNKNOWN,1613,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::Text, bitmapOf6x30));",9,<empty>,,2968,1613,CPPASTProblemDeclaration,,<empty>
569468,UNKNOWN,1614,,"Log::Comment(L""5x18 bitmap for 132x24 font set with text usage (VT420/VT5xx)"");",9,<empty>,,2969,1614,CPPASTProblemDeclaration,,<empty>
569479,UNKNOWN,1619,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::Text, bitmapOf5x18));",9,<empty>,,2972,1619,CPPASTProblemDeclaration,,<empty>
569480,UNKNOWN,1620,,"Log::Comment(L""15x12 bitmap for 80x24 font set with full cell usage (VT320)"");",9,<empty>,,2974,1620,CPPASTProblemDeclaration,,<empty>
569491,UNKNOWN,1625,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::FullCell, bitmapOf15x12));",9,<empty>,,2977,1625,CPPASTProblemDeclaration,,<empty>
569492,UNKNOWN,1626,,"Log::Comment(L""10x24 bitmap for 80x24 font set with full cell usage (VT340)"");",9,<empty>,,2978,1626,CPPASTProblemDeclaration,,<empty>
569503,UNKNOWN,1631,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::FullCell, bitmapOf10x24));",9,<empty>,,2981,1631,CPPASTProblemDeclaration,,<empty>
569504,UNKNOWN,1632,,"Log::Comment(L""12x30 bitmap for 80x24 font set with full cell usage (VT382)"");",9,<empty>,,2982,1632,CPPASTProblemDeclaration,,<empty>
569515,UNKNOWN,1637,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::FullCell, bitmapOf12x30));",9,<empty>,,2985,1637,CPPASTProblemDeclaration,,<empty>
569516,UNKNOWN,1638,,"Log::Comment(L""10x18 bitmap for 80x24 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,2986,1638,CPPASTProblemDeclaration,,<empty>
569527,UNKNOWN,1643,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size80x24, FontUsage::FullCell, bitmapOf10x18));",9,<empty>,,2989,1643,CPPASTProblemDeclaration,,<empty>
569528,UNKNOWN,1644,,"Log::Comment(L""6x12 bitmap for 132x24 font set with full cell usage (VT240)"");",9,<empty>,,2991,1644,CPPASTProblemDeclaration,,<empty>
569539,UNKNOWN,1649,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::FullCell, bitmapOf6x12));",9,<empty>,,2994,1649,CPPASTProblemDeclaration,,<empty>
569540,UNKNOWN,1650,,"Log::Comment(L""9x12 bitmap for 132x24 font set with full cell usage (VT320)"");",9,<empty>,,2995,1650,CPPASTProblemDeclaration,,<empty>
569551,UNKNOWN,1655,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::FullCell, bitmapOf9x12));",9,<empty>,,2998,1655,CPPASTProblemDeclaration,,<empty>
569552,UNKNOWN,1656,,"Log::Comment(L""6x24 bitmap for 132x24 font set with full cell usage (VT340)"");",9,<empty>,,2999,1656,CPPASTProblemDeclaration,,<empty>
569563,UNKNOWN,1661,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::FullCell, bitmapOf6x24));",9,<empty>,,3002,1661,CPPASTProblemDeclaration,,<empty>
569564,UNKNOWN,1662,,"Log::Comment(L""7x30 bitmap for 132x24 font set with full cell usage (VT382)"");",9,<empty>,,3003,1662,CPPASTProblemDeclaration,,<empty>
569575,UNKNOWN,1667,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::FullCell, bitmapOf7x30));",9,<empty>,,3006,1667,CPPASTProblemDeclaration,,<empty>
569576,UNKNOWN,1668,,"Log::Comment(L""6x18 bitmap for 132x24 font set with full cell usage (VT420/VT5xx)"");",9,<empty>,,3007,1668,CPPASTProblemDeclaration,,<empty>
569587,UNKNOWN,1673,,"VERIFY_IS_TRUE(decdld(CellMatrix::Default, 0, FontSet::Size132x24, FontUsage::FullCell, bitmapOf6x18));",9,<empty>,,3010,1673,CPPASTProblemDeclaration,,<empty>
569588,UNKNOWN,1674,,},5,<empty>,,3011,1674,CPPASTProblemDeclaration,,<empty>
569589,UNKNOWN,1675,,"TEST_METHOD(TogglingC1ParserMode)
    {
        _stateMachine->SetParserMode(StateMachine::Mode::AcceptC1, false);",5,<empty>,,3013,1675,CPPASTProblemDeclaration,,<empty>
569590,UNKNOWN,1676,,"Log::Comment(L""1. Accept C1 controls"");",9,<empty>,,3017,1676,CPPASTProblemDeclaration,,<empty>
569591,UNKNOWN,1677,,VERIFY_IS_TRUE(_pDispatch->AcceptC1Controls(true));,9,<empty>,,3018,1677,CPPASTProblemDeclaration,,<empty>
569592,UNKNOWN,1678,,VERIFY_IS_TRUE(_stateMachine->GetParserMode(StateMachine::Mode::AcceptC1));,9,<empty>,,3019,1678,CPPASTProblemDeclaration,,<empty>
569593,UNKNOWN,1679,,"Log::Comment(L""2. Don't accept C1 controls"");",9,<empty>,,3021,1679,CPPASTProblemDeclaration,,<empty>
569594,UNKNOWN,1680,,VERIFY_IS_TRUE(_pDispatch->AcceptC1Controls(false));,9,<empty>,,3022,1680,CPPASTProblemDeclaration,,<empty>
569595,UNKNOWN,1681,,VERIFY_IS_FALSE(_stateMachine->GetParserMode(StateMachine::Mode::AcceptC1));,9,<empty>,,3023,1681,CPPASTProblemDeclaration,,<empty>
569596,UNKNOWN,1682,,"Log::Comment(L""3. Designate ISO-2022 coding system"");",9,<empty>,,3025,1682,CPPASTProblemDeclaration,,<empty>
569597,UNKNOWN,1683,,_testGetSet->_setConsoleOutputCPResult = true;,9,<empty>,,3027,1683,CPPASTProblemDeclaration,,<empty>
569598,UNKNOWN,1684,,_testGetSet->_expectedOutputCP = 28591;,9,<empty>,,3028,1684,CPPASTProblemDeclaration,,<empty>
569599,UNKNOWN,1685,,VERIFY_IS_TRUE(_pDispatch->DesignateCodingSystem(DispatchTypes::CodingSystem::ISO2022));,9,<empty>,,3029,1685,CPPASTProblemDeclaration,,<empty>
569600,UNKNOWN,1686,,VERIFY_IS_TRUE(_stateMachine->GetParserMode(StateMachine::Mode::AcceptC1));,9,<empty>,,3030,1686,CPPASTProblemDeclaration,,<empty>
569601,UNKNOWN,1687,,"Log::Comment(L""4. Designate UTF-8 coding system"");",9,<empty>,,3032,1687,CPPASTProblemDeclaration,,<empty>
569602,UNKNOWN,1688,,_testGetSet->_setConsoleOutputCPResult = true;,9,<empty>,,3034,1688,CPPASTProblemDeclaration,,<empty>
569603,UNKNOWN,1689,,_testGetSet->_expectedOutputCP = CP_UTF8;,9,<empty>,,3035,1689,CPPASTProblemDeclaration,,<empty>
569604,UNKNOWN,1690,,VERIFY_IS_TRUE(_pDispatch->DesignateCodingSystem(DispatchTypes::CodingSystem::UTF8));,9,<empty>,,3036,1690,CPPASTProblemDeclaration,,<empty>
569605,UNKNOWN,1691,,VERIFY_IS_FALSE(_stateMachine->GetParserMode(StateMachine::Mode::AcceptC1));,9,<empty>,,3037,1691,CPPASTProblemDeclaration,,<empty>
569606,UNKNOWN,1692,,},5,<empty>,,3038,1692,CPPASTProblemDeclaration,,<empty>
569607,UNKNOWN,1693,,"TEST_METHOD(MacroDefinitions)
    {
        const auto getMacroText = [&](const auto id) {
            return _pDispatch->_macroBuffer->_macros.at(id);
        };",5,<empty>,,3040,1693,CPPASTProblemDeclaration,,<empty>
569608,UNKNOWN,1694,,"Log::Comment(L""Text encoding"");",9,<empty>,,3046,1694,CPPASTProblemDeclaration,,<empty>
569609,UNKNOWN,1695,,"_stateMachine->ProcessString(L""\033P1;0;0!zText Encoding\033\\"");",9,<empty>,,3047,1695,CPPASTProblemDeclaration,,<empty>
569610,UNKNOWN,1696,,"VERIFY_ARE_EQUAL(L""Text Encoding"", getMacroText(1));",9,<empty>,,3048,1696,CPPASTProblemDeclaration,,<empty>
569611,UNKNOWN,1697,,"Log::Comment(L""Hex encoding (uppercase)"");",9,<empty>,,3050,1697,CPPASTProblemDeclaration,,<empty>
569612,UNKNOWN,1698,,"_stateMachine->ProcessString(L""\033P2;0;1!z486578204A4B4C4D4E4F\033\\"");",9,<empty>,,3051,1698,CPPASTProblemDeclaration,,<empty>
569613,UNKNOWN,1699,,"VERIFY_ARE_EQUAL(L""Hex JKLMNO"", getMacroText(2));",9,<empty>,,3052,1699,CPPASTProblemDeclaration,,<empty>
569614,UNKNOWN,1700,,"Log::Comment(L""Hex encoding (lowercase)"");",9,<empty>,,3054,1700,CPPASTProblemDeclaration,,<empty>
569615,UNKNOWN,1701,,"_stateMachine->ProcessString(L""\033P3;0;1!z486578206a6b6c6d6e6f\033\\"");",9,<empty>,,3055,1701,CPPASTProblemDeclaration,,<empty>
569616,UNKNOWN,1702,,"VERIFY_ARE_EQUAL(L""Hex jklmno"", getMacroText(3));",9,<empty>,,3056,1702,CPPASTProblemDeclaration,,<empty>
569617,UNKNOWN,1703,,"Log::Comment(L""Default encoding is text"");",9,<empty>,,3058,1703,CPPASTProblemDeclaration,,<empty>
569618,UNKNOWN,1704,,"_stateMachine->ProcessString(L""\033P4;0;!zDefault Encoding\033\\"");",9,<empty>,,3059,1704,CPPASTProblemDeclaration,,<empty>
569619,UNKNOWN,1705,,"VERIFY_ARE_EQUAL(L""Default Encoding"", getMacroText(4));",9,<empty>,,3060,1705,CPPASTProblemDeclaration,,<empty>
569620,UNKNOWN,1706,,"Log::Comment(L""Default ID is 0"");",9,<empty>,,3062,1706,CPPASTProblemDeclaration,,<empty>
569621,UNKNOWN,1707,,"_stateMachine->ProcessString(L""\033P;0;0!zDefault ID\033\\"");",9,<empty>,,3063,1707,CPPASTProblemDeclaration,,<empty>
569622,UNKNOWN,1708,,"VERIFY_ARE_EQUAL(L""Default ID"", getMacroText(0));",9,<empty>,,3064,1708,CPPASTProblemDeclaration,,<empty>
569623,UNKNOWN,1709,,"Log::Comment(L""Replacing a single macro"");",9,<empty>,,3066,1709,CPPASTProblemDeclaration,,<empty>
569624,UNKNOWN,1710,,"_stateMachine->ProcessString(L""\033P1;0;0!zRetained\033\\"");",9,<empty>,,3067,1710,CPPASTProblemDeclaration,,<empty>
569625,UNKNOWN,1711,,"_stateMachine->ProcessString(L""\033P2;0;0!zReplaced\033\\"");",9,<empty>,,3068,1711,CPPASTProblemDeclaration,,<empty>
569626,UNKNOWN,1712,,"_stateMachine->ProcessString(L""\033P2;0;0!zNew\033\\"");",9,<empty>,,3069,1712,CPPASTProblemDeclaration,,<empty>
569627,UNKNOWN,1713,,"VERIFY_ARE_EQUAL(L""Retained"", getMacroText(1));",9,<empty>,,3070,1713,CPPASTProblemDeclaration,,<empty>
569628,UNKNOWN,1714,,"VERIFY_ARE_EQUAL(L""New"", getMacroText(2));",9,<empty>,,3071,1714,CPPASTProblemDeclaration,,<empty>
569629,UNKNOWN,1715,,"Log::Comment(L""Replacing all macros"");",9,<empty>,,3073,1715,CPPASTProblemDeclaration,,<empty>
569630,UNKNOWN,1716,,"_stateMachine->ProcessString(L""\033P1;0;0!zErased\033\\"");",9,<empty>,,3074,1716,CPPASTProblemDeclaration,,<empty>
569631,UNKNOWN,1717,,"_stateMachine->ProcessString(L""\033P2;0;0!zReplaced\033\\"");",9,<empty>,,3075,1717,CPPASTProblemDeclaration,,<empty>
569632,UNKNOWN,1718,,"_stateMachine->ProcessString(L""\033P2;1;0!zNew\033\\"");",9,<empty>,,3076,1718,CPPASTProblemDeclaration,,<empty>
569633,UNKNOWN,1719,,"VERIFY_ARE_EQUAL(L"""", getMacroText(1));",9,<empty>,,3077,1719,CPPASTProblemDeclaration,,<empty>
569634,UNKNOWN,1720,,"VERIFY_ARE_EQUAL(L""New"", getMacroText(2));",9,<empty>,,3078,1720,CPPASTProblemDeclaration,,<empty>
569635,UNKNOWN,1721,,"Log::Comment(L""Default replacement is a single macro"");",9,<empty>,,3080,1721,CPPASTProblemDeclaration,,<empty>
569636,UNKNOWN,1722,,"_stateMachine->ProcessString(L""\033P1;0;0!zRetained\033\\"");",9,<empty>,,3081,1722,CPPASTProblemDeclaration,,<empty>
569637,UNKNOWN,1723,,"_stateMachine->ProcessString(L""\033P2;0;0!zReplaced\033\\"");",9,<empty>,,3082,1723,CPPASTProblemDeclaration,,<empty>
569638,UNKNOWN,1724,,"_stateMachine->ProcessString(L""\033P2;;0!zNew\033\\"");",9,<empty>,,3083,1724,CPPASTProblemDeclaration,,<empty>
569639,UNKNOWN,1725,,"VERIFY_ARE_EQUAL(L""Retained"", getMacroText(1));",9,<empty>,,3084,1725,CPPASTProblemDeclaration,,<empty>
569640,UNKNOWN,1726,,"VERIFY_ARE_EQUAL(L""New"", getMacroText(2));",9,<empty>,,3085,1726,CPPASTProblemDeclaration,,<empty>
569641,UNKNOWN,1727,,"Log::Comment(L""Repeating three times"");",9,<empty>,,3087,1727,CPPASTProblemDeclaration,,<empty>
569642,UNKNOWN,1728,,"_stateMachine->ProcessString(L""\033P5;0;1!z526570656174!3;206563686F;207468726565\033\\"");",9,<empty>,,3088,1728,CPPASTProblemDeclaration,,<empty>
569643,UNKNOWN,1729,,"VERIFY_ARE_EQUAL(L""Repeat echo echo echo three"", getMacroText(5));",9,<empty>,,3089,1729,CPPASTProblemDeclaration,,<empty>
569644,UNKNOWN,1730,,"Log::Comment(L""Zero repeats once"");",9,<empty>,,3091,1730,CPPASTProblemDeclaration,,<empty>
569645,UNKNOWN,1731,,"_stateMachine->ProcessString(L""\033P6;0;1!z526570656174!0;206563686F;207A65726F\033\\"");",9,<empty>,,3092,1731,CPPASTProblemDeclaration,,<empty>
569646,UNKNOWN,1732,,"VERIFY_ARE_EQUAL(L""Repeat echo zero"", getMacroText(6));",9,<empty>,,3093,1732,CPPASTProblemDeclaration,,<empty>
569647,UNKNOWN,1733,,"Log::Comment(L""Default repeats once"");",9,<empty>,,3095,1733,CPPASTProblemDeclaration,,<empty>
569648,UNKNOWN,1734,,"_stateMachine->ProcessString(L""\033P7;0;1!z526570656174!;206563686F;2064656661756C74\033\\"");",9,<empty>,,3096,1734,CPPASTProblemDeclaration,,<empty>
569649,UNKNOWN,1735,,"VERIFY_ARE_EQUAL(L""Repeat echo default"", getMacroText(7));",9,<empty>,,3097,1735,CPPASTProblemDeclaration,,<empty>
569650,UNKNOWN,1736,,"Log::Comment(L""Unterminated repeat sequence"");",9,<empty>,,3099,1736,CPPASTProblemDeclaration,,<empty>
569651,UNKNOWN,1737,,"_stateMachine->ProcessString(L""\033P8;0;1!z556E7465726D696E61746564!3;206563686F\033\\"");",9,<empty>,,3100,1737,CPPASTProblemDeclaration,,<empty>
569652,UNKNOWN,1738,,"VERIFY_ARE_EQUAL(L""Unterminated echo echo echo"", getMacroText(8));",9,<empty>,,3101,1738,CPPASTProblemDeclaration,,<empty>
569653,UNKNOWN,1739,,"Log::Comment(L""Unexpected semicolon cancels definition"");",9,<empty>,,3103,1739,CPPASTProblemDeclaration,,<empty>
569654,UNKNOWN,1740,,"_stateMachine->ProcessString(L""\033P9;0;0!zReplaced\033\\"");",9,<empty>,,3104,1740,CPPASTProblemDeclaration,,<empty>
569655,UNKNOWN,1741,,"_stateMachine->ProcessString(L""\033P9;0;1!z526570656174!3;206563;686F;207468726565\033\\"");",9,<empty>,,3105,1741,CPPASTProblemDeclaration,,<empty>
569656,UNKNOWN,1742,,"VERIFY_ARE_EQUAL(L"""", getMacroText(9));",9,<empty>,,3106,1742,CPPASTProblemDeclaration,,<empty>
569657,UNKNOWN,1743,,"Log::Comment(L""Control characters in a text encoding"");",9,<empty>,,3108,1743,CPPASTProblemDeclaration,,<empty>
569658,UNKNOWN,1744,,"_stateMachine->ProcessString(L""\033P10;0;0!zA\aB\bC\tD\nE\vF\fG\rH\033\\"");",9,<empty>,,3109,1744,CPPASTProblemDeclaration,,<empty>
569659,UNKNOWN,1745,,"VERIFY_ARE_EQUAL(L""ABCDEFGH"", getMacroText(10));",9,<empty>,,3110,1745,CPPASTProblemDeclaration,,<empty>
569660,UNKNOWN,1746,,"Log::Comment(L""Control characters in a hex encoding"");",9,<empty>,,3112,1746,CPPASTProblemDeclaration,,<empty>
569661,UNKNOWN,1747,,"_stateMachine->ProcessString(L""\033P11;0;1!z41\a42\b43\t44\n45\v46\f47\r48\033\\"");",9,<empty>,,3113,1747,CPPASTProblemDeclaration,,<empty>
569662,UNKNOWN,1748,,"VERIFY_ARE_EQUAL(L""ABCDEFGH"", getMacroText(11));",9,<empty>,,3114,1748,CPPASTProblemDeclaration,,<empty>
569663,UNKNOWN,1749,,"Log::Comment(L""Control characters in a repeat"");",9,<empty>,,3116,1749,CPPASTProblemDeclaration,,<empty>
569664,UNKNOWN,1750,,"_stateMachine->ProcessString(L""\033P12;0;1!z!\a3\b;\t4\n1\v4\f2\r4\a3\b;\033\\"");",9,<empty>,,3117,1750,CPPASTProblemDeclaration,,<empty>
569665,UNKNOWN,1751,,"VERIFY_ARE_EQUAL(L""ABCABCABC"", getMacroText(12));",9,<empty>,,3118,1751,CPPASTProblemDeclaration,,<empty>
569666,UNKNOWN,1752,,"Log::Comment(L""Encoded control characters"");",9,<empty>,,3120,1752,CPPASTProblemDeclaration,,<empty>
569667,UNKNOWN,1753,,"_stateMachine->ProcessString(L""\033P13;0;1!z410742084309440A450B460C470D481B49\033\\"");",9,<empty>,,3121,1753,CPPASTProblemDeclaration,,<empty>
569668,UNKNOWN,1754,,"VERIFY_ARE_EQUAL(L""A\aB\bC\tD\nE\vF\fG\rH\033I"", getMacroText(13));",9,<empty>,,3122,1754,CPPASTProblemDeclaration,,<empty>
569669,UNKNOWN,1755,,_pDispatch->_macroBuffer = nullptr;,9,<empty>,,3124,1755,CPPASTProblemDeclaration,,<empty>
569670,UNKNOWN,1756,,},5,<empty>,,3125,1756,CPPASTProblemDeclaration,,<empty>
569671,UNKNOWN,1757,,"TEST_METHOD(MacroInvokes)
    {
        _pDispatch->_macroBuffer = std::make_shared<MacroBuffer>();",5,<empty>,,3127,1757,CPPASTProblemDeclaration,,<empty>
569676,UNKNOWN,1760,,"setMacroText(0, L""Macro 0"");",9,<empty>,,3135,1760,CPPASTProblemDeclaration,,<empty>
569677,UNKNOWN,1761,,"setMacroText(1, L""Macro 1"");",9,<empty>,,3136,1761,CPPASTProblemDeclaration,,<empty>
569678,UNKNOWN,1762,,"setMacroText(2, L""Macro 2"");",9,<empty>,,3137,1762,CPPASTProblemDeclaration,,<empty>
569679,UNKNOWN,1763,,"setMacroText(63, L""Macro 63"");",9,<empty>,,3138,1763,CPPASTProblemDeclaration,,<empty>
569684,UNKNOWN,1766,,"Log::Comment(L""Simple macro invoke"");",9,<empty>,,3146,1766,CPPASTProblemDeclaration,,<empty>
569685,UNKNOWN,1767,,_testGetSet->PrepData();,9,<empty>,,3147,1767,CPPASTProblemDeclaration,,<empty>
569686,UNKNOWN,1768,,"_stateMachine->ProcessString(L""\033[2*z"");",9,<empty>,,3148,1768,CPPASTProblemDeclaration,,<empty>
569687,UNKNOWN,1769,,"VERIFY_ARE_EQUAL(L""Macro 2"", getBufferOutput());",9,<empty>,,3149,1769,CPPASTProblemDeclaration,,<empty>
569688,UNKNOWN,1770,,"Log::Comment(L""Default macro invoke"");",9,<empty>,,3151,1770,CPPASTProblemDeclaration,,<empty>
569689,UNKNOWN,1771,,_testGetSet->PrepData();,9,<empty>,,3152,1771,CPPASTProblemDeclaration,,<empty>
569690,UNKNOWN,1772,,"_stateMachine->ProcessString(L""\033[*z"");",9,<empty>,,3153,1772,CPPASTProblemDeclaration,,<empty>
569691,UNKNOWN,1773,,"VERIFY_ARE_EQUAL(L""Macro 0"", getBufferOutput());",9,<empty>,,3154,1773,CPPASTProblemDeclaration,,<empty>
569692,UNKNOWN,1774,,"Log::Comment(L""Maximum ID number"");",9,<empty>,,3156,1774,CPPASTProblemDeclaration,,<empty>
569693,UNKNOWN,1775,,_testGetSet->PrepData();,9,<empty>,,3157,1775,CPPASTProblemDeclaration,,<empty>
569694,UNKNOWN,1776,,"_stateMachine->ProcessString(L""\033[63*z"");",9,<empty>,,3158,1776,CPPASTProblemDeclaration,,<empty>
569695,UNKNOWN,1777,,"VERIFY_ARE_EQUAL(L""Macro 63"", getBufferOutput());",9,<empty>,,3159,1777,CPPASTProblemDeclaration,,<empty>
569696,UNKNOWN,1778,,"Log::Comment(L""Out of range ID number"");",9,<empty>,,3161,1778,CPPASTProblemDeclaration,,<empty>
569697,UNKNOWN,1779,,_testGetSet->PrepData();,9,<empty>,,3162,1779,CPPASTProblemDeclaration,,<empty>
569698,UNKNOWN,1780,,"_stateMachine->ProcessString(L""\033[64*z"");",9,<empty>,,3163,1780,CPPASTProblemDeclaration,,<empty>
569699,UNKNOWN,1781,,"VERIFY_ARE_EQUAL(L"""", getBufferOutput());",9,<empty>,,3164,1781,CPPASTProblemDeclaration,,<empty>
569700,UNKNOWN,1782,,"Log::Comment(L""Only one ID parameter allowed"");",9,<empty>,,3166,1782,CPPASTProblemDeclaration,,<empty>
569701,UNKNOWN,1783,,_testGetSet->PrepData();,9,<empty>,,3167,1783,CPPASTProblemDeclaration,,<empty>
569702,UNKNOWN,1784,,"_stateMachine->ProcessString(L""\033[2;0;1*z"");",9,<empty>,,3168,1784,CPPASTProblemDeclaration,,<empty>
569703,UNKNOWN,1785,,"VERIFY_ARE_EQUAL(L""Macro 2"", getBufferOutput());",9,<empty>,,3169,1785,CPPASTProblemDeclaration,,<empty>
569704,UNKNOWN,1786,,"Log::Comment(L""DECDMAC ignored when inside a macro"");",9,<empty>,,3171,1786,CPPASTProblemDeclaration,,<empty>
569705,UNKNOWN,1787,,"setMacroText(10, L""[\033P1;0;0!zReplace Macro 1\033\\]"");",9,<empty>,,3172,1787,CPPASTProblemDeclaration,,<empty>
569706,UNKNOWN,1788,,_testGetSet->PrepData();,9,<empty>,,3173,1788,CPPASTProblemDeclaration,,<empty>
569707,UNKNOWN,1789,,"_stateMachine->ProcessString(L""\033[10*z"");",9,<empty>,,3174,1789,CPPASTProblemDeclaration,,<empty>
569708,UNKNOWN,1790,,"_stateMachine->ProcessString(L""\033[1*z"");",9,<empty>,,3175,1790,CPPASTProblemDeclaration,,<empty>
569709,UNKNOWN,1791,,"VERIFY_ARE_EQUAL(L""[]Macro 1"", getBufferOutput());",9,<empty>,,3176,1791,CPPASTProblemDeclaration,,<empty>
569710,UNKNOWN,1792,,"Log::Comment(L""Maximum recursive depth is 16"");",9,<empty>,,3178,1792,CPPASTProblemDeclaration,,<empty>
569711,UNKNOWN,1793,,"setMacroText(0, L""<\033[1*z>"");",9,<empty>,,3179,1793,CPPASTProblemDeclaration,,<empty>
569712,UNKNOWN,1794,,"setMacroText(1, L""[\033[0*z]"");",9,<empty>,,3180,1794,CPPASTProblemDeclaration,,<empty>
569713,UNKNOWN,1795,,_testGetSet->PrepData();,9,<empty>,,3181,1795,CPPASTProblemDeclaration,,<empty>
569714,UNKNOWN,1796,,"_stateMachine->ProcessString(L""\033[0*z"");",9,<empty>,,3182,1796,CPPASTProblemDeclaration,,<empty>
569715,UNKNOWN,1797,,"VERIFY_ARE_EQUAL(L""<[<[<[<[<[<[<[<[]>]>]>]>]>]>]>]>"", getBufferOutput());",9,<empty>,,3183,1797,CPPASTProblemDeclaration,,<empty>
569716,UNKNOWN,1798,,_pDispatch->_macroBuffer = nullptr;,9,<empty>,,3185,1798,CPPASTProblemDeclaration,,<empty>
569717,UNKNOWN,1799,,},5,<empty>,,3186,1799,CPPASTProblemDeclaration,,<empty>
569718,UNKNOWN,1800,,"TEST_METHOD(WindowManipulationTypeTests)
    {
        _testGetSet->PrepData();",5,<empty>,,3188,1800,CPPASTProblemDeclaration,,<empty>
569719,UNKNOWN,1801,,"_pDispatch->WindowManipulation(DispatchTypes::WindowManipulationType::ReportTextSizeInCharacters, NULL, NULL);",9,<empty>,,3191,1801,CPPASTProblemDeclaration,,<empty>
569745,UNKNOWN,1804,,_testGetSet->ValidateInputEvent(expectedResponse.c_str());,9,<empty>,,3193,1804,CPPASTProblemDeclaration,,<empty>
569746,UNKNOWN,1805,,},5,<empty>,,3194,1805,CPPASTProblemDeclaration,,<empty>
569747,UNKNOWN,1806,,"TEST_METHOD(MenuCompletionsTests)
    {
        _testGetSet->PrepData();",5,<empty>,,3196,1806,CPPASTProblemDeclaration,,<empty>
569748,UNKNOWN,1807,,"Log::Comment(L""Not enough parameters"");",9,<empty>,,3200,1807,CPPASTProblemDeclaration,,<empty>
569749,UNKNOWN,1808,,"VERIFY_IS_FALSE(_pDispatch->DoVsCodeAction(LR""(garbage)""));",9,<empty>,,3201,1808,CPPASTProblemDeclaration,,<empty>
569750,UNKNOWN,1809,,"Log::Comment(L""Not enough parameters"");",9,<empty>,,3203,1809,CPPASTProblemDeclaration,,<empty>
569751,UNKNOWN,1810,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions)""));",9,<empty>,,3204,1810,CPPASTProblemDeclaration,,<empty>
569752,UNKNOWN,1811,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;)""));",9,<empty>,,3205,1811,CPPASTProblemDeclaration,,<empty>
569753,UNKNOWN,1812,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;10;)""));",9,<empty>,,3206,1812,CPPASTProblemDeclaration,,<empty>
569754,UNKNOWN,1813,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;10;20)""));",9,<empty>,,3207,1813,CPPASTProblemDeclaration,,<empty>
569755,UNKNOWN,1814,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;10;20;)""));",9,<empty>,,3208,1814,CPPASTProblemDeclaration,,<empty>
569756,UNKNOWN,1815,,"Log::Comment(L""No trailing semicolon"");",9,<empty>,,3209,1815,CPPASTProblemDeclaration,,<empty>
569757,UNKNOWN,1816,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;10;20;3)""));",9,<empty>,,3210,1816,CPPASTProblemDeclaration,,<empty>
569758,UNKNOWN,1817,,"Log::Comment(L""Normal, good case"");",9,<empty>,,3212,1817,CPPASTProblemDeclaration,,<empty>
569759,UNKNOWN,1818,,"_testGetSet->_expectedMenuJson = LR""({ ""foo"": 1, ""bar"": 2 })"";",9,<empty>,,3213,1818,CPPASTProblemDeclaration,,<empty>
569760,UNKNOWN,1819,,_testGetSet->_expectedReplaceLength = 2;,9,<empty>,,3214,1819,CPPASTProblemDeclaration,,<empty>
569761,UNKNOWN,1820,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;1;2;3;{ ""foo"": 1, ""bar"": 2 })""));",9,<empty>,,3215,1820,CPPASTProblemDeclaration,,<empty>
569762,UNKNOWN,1821,,"Log::Comment(L""JSON has a semicolon in it"");",9,<empty>,,3217,1821,CPPASTProblemDeclaration,,<empty>
569763,UNKNOWN,1822,,"_testGetSet->_expectedMenuJson = LR""({ ""foo"": ""what;ever"", ""bar"": 2 })"";",9,<empty>,,3218,1822,CPPASTProblemDeclaration,,<empty>
569764,UNKNOWN,1823,,_testGetSet->_expectedReplaceLength = 20;,9,<empty>,,3219,1823,CPPASTProblemDeclaration,,<empty>
569765,UNKNOWN,1824,,"VERIFY_IS_TRUE(_pDispatch->DoVsCodeAction(LR""(Completions;10;20;30;{ ""foo"": ""what;ever"", ""bar"": 2 })""));",9,<empty>,,3220,1824,CPPASTProblemDeclaration,,<empty>
569766,UNKNOWN,1825,,},5,<empty>,,3221,1825,CPPASTProblemDeclaration,,<empty>
569767,UNKNOWN,1826,,"private:
    TerminalInput _terminalInput;",1,<empty>,,3223,1826,CPPASTProblemDeclaration,,<empty>
569771,UNKNOWN,1830,,};,1,<empty>,,3228,1830,CPPASTProblemDeclaration,,<empty>
570502,UNKNOWN,-1,,),34,<empty>,,244,3,CPPASTProblemStatement,,<empty>
570506,UNKNOWN,-1,,),181,<empty>,,245,5,CPPASTProblemStatement,,<empty>
570508,UNKNOWN,-1,,),32,<empty>,,246,7,CPPASTProblemStatement,,<empty>
571904,UNKNOWN,1,,WORD,29,<empty>,,606,1,CPPASTTypeId,,<empty>
571927,UNKNOWN,1,,WORD,24,<empty>,,613,1,CPPASTTypeId,,<empty>
571941,UNKNOWN,1,,WORD,24,<empty>,,616,1,CPPASTTypeId,,<empty>
571955,UNKNOWN,1,,WORD,24,<empty>,,619,1,CPPASTTypeId,,<empty>
571969,UNKNOWN,1,,WORD,24,<empty>,,622,1,CPPASTTypeId,,<empty>
571983,UNKNOWN,1,,WORD,24,<empty>,,625,1,CPPASTTypeId,,<empty>
571997,UNKNOWN,1,,WORD,24,<empty>,,628,1,CPPASTTypeId,,<empty>
572011,UNKNOWN,1,,WORD,24,<empty>,,631,1,CPPASTTypeId,,<empty>
573850,UNKNOWN,1,,WORD,29,<empty>,,214,1,CPPASTTypeId,,<empty>
573861,UNKNOWN,1,,WORD,29,<empty>,,216,1,CPPASTTypeId,,<empty>
573872,UNKNOWN,1,,WORD,29,<empty>,,217,1,CPPASTTypeId,,<empty>
573883,UNKNOWN,1,,WORD,29,<empty>,,218,1,CPPASTTypeId,,<empty>
573894,UNKNOWN,1,,WORD,29,<empty>,,219,1,CPPASTTypeId,,<empty>
573905,UNKNOWN,1,,WORD,29,<empty>,,220,1,CPPASTTypeId,,<empty>
573916,UNKNOWN,1,,WORD,29,<empty>,,221,1,CPPASTTypeId,,<empty>
573927,UNKNOWN,1,,WORD,29,<empty>,,222,1,CPPASTTypeId,,<empty>
577459,UNKNOWN,1,,Ss3ActionCodes,73,<empty>,,992,1,CPPASTTypeId,,<empty>
583252,UNKNOWN,1,,BYTE,30,<empty>,,48,1,CPPASTTypeId,,<empty>
584509,UNKNOWN,1,,CHAR,34,<empty>,,20,1,CPPASTTypeId,,<empty>
584511,UNKNOWN,1,,unsigned char,52,<empty>,,20,1,CPPASTTypeId,,<empty>
584662,UNKNOWN,1,,std::string,13,<empty>,,80,1,CPPASTTypeId,,<empty>
584699,UNKNOWN,1,,std::string,13,<empty>,,93,1,CPPASTTypeId,,<empty>
584734,UNKNOWN,1,,DWORD,28,<empty>,,105,1,CPPASTTypeId,,<empty>
584806,UNKNOWN,37,,"std::string GenerateFuzzedToken(
    __in_ecount(cmap) const _fuzz_type_entry<std::string>* map,
    __in DWORD cmap,
    __in_ecount(ctokens) const LPCSTR* tokens,
    __in DWORD ctokens)
{
    std::string csis[] = { CSI, C1CSI };
    auto s = CFuzzChance::SelectOne(csis);

    auto manipulations = (BYTE)CFuzzType<BYTE>(FUZZ_MAP(g_repeatMap), 1);
    for (BYTE i = 0; i < manipulations; i++)
    {
        CFuzzType<std::string> ft(map, cmap, std::string(""""));
        s += GenerateTokenLowProbability();
        s += (std::string)ft;
        s += GenerateTokenLowProbability();
        s += (i + 1 == manipulations) ? """" : "";"";
        s += GenerateTokenLowProbability();
    }

    s.append(CFuzzChance::SelectOne(tokens, ctokens));
    return s;
}",1,<empty>,,141,37,CPPASTProblemDeclaration,,<empty>
584807,UNKNOWN,38,,"std::string GenerateFuzzedOscToken(
    __in_ecount(cmap) const _fuzz_type_entry<std::string>* map,
    __in DWORD cmap,
    __in_ecount(ctokens) const LPCSTR* tokens,
    __in DWORD ctokens)
{
    std::string s(OSC);
    auto manipulations = (BYTE)CFuzzType<BYTE>(FUZZ_MAP(g_repeatMap), 1);
    for (BYTE i = 0; i < manipulations; i++)
    {
        CFuzzType<std::string> ft(map, cmap, std::string(""""));
        s += GenerateTokenLowProbability();
        s += (std::string)ft;
        s += GenerateTokenLowProbability();
        s += (i + 1 == manipulations) ? """" : "";"";
        s += GenerateTokenLowProbability();
    }

    s.append(CFuzzChance::SelectOne(tokens, ctokens));
    return s;
}",1,<empty>,,165,38,CPPASTProblemDeclaration,,<empty>
585649,UNKNOWN,1,,ULONG,68,<empty>,,645,1,CPPASTTypeId,,<empty>
585704,UNKNOWN,1,,LPSTR,60,<empty>,,991,1,CPPASTTypeId,,<empty>
585713,UNKNOWN,1,,LPWSTR,60,<empty>,,992,1,CPPASTTypeId,,<empty>
585721,UNKNOWN,1,,_Type*,52,<empty>,,993,1,CPPASTTypeId,,<empty>
585738,UNKNOWN,1,,LPSTR,60,<empty>,,997,1,CPPASTTypeId,,<empty>
585742,UNKNOWN,1,,LPCSTR,102,<empty>,,997,1,CPPASTTypeId,,<empty>
585746,UNKNOWN,1,,LPWSTR,60,<empty>,,998,1,CPPASTTypeId,,<empty>
585750,UNKNOWN,1,,LPCWSTR,103,<empty>,,998,1,CPPASTTypeId,,<empty>
585864,UNKNOWN,-1,,"template<class _Type>
        static _Type GetRandom(__in _Type tCap) throw()
        {
            return GetRandom<_Type>(std::numeric_limits<_Type>::min(), --tCap);
        }",9,<empty>,,247,2,CPPASTProblemDeclaration,,<empty>
585865,UNKNOWN,-1,,"template<class _Type>
        static _Type GetRandom(__in _Type tMin, __in _Type tMax)
        {
            if constexpr (std::is_same_v<_Type, BYTE>)
            {
                // uniform_int_distribution only works with _Is_IntType types, which do not
                // currently include char or unsigned char, so here is a specialization
                // specifically for BYTE (unsigned char).
                std::mt19937 engine(m_rd()); // Mersenne twister MT19937
                // BYTE is unsigned, so we want to also use an unsigned type to avoid sign
                // extension of tMin and tMax.
                std::uniform_int_distribution<unsigned short> distribution(tMin, tMax);
                auto generator = std::bind(distribution, engine);
                return static_cast<BYTE>(generator());
            }
            else
            {
                std::mt19937 engine(m_rd()); // Mersenne twister MT19937
                std::uniform_int_distribution<_Type> di...",9,<empty>,,253,3,CPPASTProblemDeclaration,,<empty>
585866,UNKNOWN,-1,,"template<typename _Type>
        static _Type SelectOne(__in_ecount(cElems) const _Type* rg, __in size_t cElems) throw()
        {
            return rg[GetRandom<size_t>(cElems)];
        }",9,<empty>,,289,4,CPPASTProblemDeclaration,,<empty>
585896,UNKNOWN,-1,,"void ConvertPercentageToRange(__in unsigned int iPercentage,
                                      __inout int& riTotal,
                                      __deref_out _range* pr) const
        {
            pr->iHigh = riTotal;
            pr->iLow = riTotal - iPercentage;
            riTotal -= iPercentage;
        }",9,<empty>,,325,3,CPPASTProblemDeclaration,,<empty>
585911,UNKNOWN,-1,,"CFuzzArray(
            __in_ecount(cfae) const _fuzz_array_entry<_Type1, _Type2, _Args...>* rgfae,
            __in ULONG cfae,
            __in_ecount_opt(cElems) _Type1* rg,
            __inout _Type2& cElems,
            __in _Args&&... args) :
            m_rgCaller(rg),
            m_pcElems(&cElems),
            m_pfas(nullptr),
            m_tArgs(std::forward<_Args>(args)...)
        {
            Init(rgfae, cfae);
        }",9,<empty>,,377,2,CPPASTProblemDeclaration,,<empty>
585912,UNKNOWN,-1,,"CFuzzArray(
            __in_ecount(cfae) const _fuzz_array_entry<_Type1, _Type2, _Args...>* rgfae,
            __in ULONG cfae,
            __in_opt _Type1* rg,
            __in CFuzzArraySize<_Type1, _Type2, _Args...>& size,
            __in _Args&&... args) :
            m_rgCaller(rg),
            m_pcElems(size.m_pcElems),
            m_pfas(nullptr),
            m_tArgs(std::forward<_Args>(args)...)
        {
            if (SUCCEEDED(Init(rgfae, cfae)))
            {
                size.Pair(*this);
                m_pfas = size.Reference();
            }
        }",9,<empty>,,393,3,CPPASTProblemDeclaration,,<empty>
585965,UNKNOWN,-1,,"[[nodiscard]] __inline HRESULT SetFuzzArrayMap(
            __in_ecount(cfae) const _fuzz_array_entry<_Type1, _Type2, _Args...>* rgfae,
            __in ULONG cfae) throw()
        {
            ClearFuzzArrayEntries();
            for (ULONG i = 0; i < cfae; i++)
            {
                AddFuzzArrayEntry(rgfae[i].uiPercentage, rgfae[i].pfnFuzz, rgfae[i].pfnDealloc);
            }

            return (m_iPercentageTotal >= 0) ? S_OK : E_INVALIDARG;
        }",9,<empty>,,461,9,CPPASTProblemDeclaration,,<empty>
585966,UNKNOWN,-1,,"[[nodiscard]] HRESULT AddFuzzArrayEntry(
            __in unsigned int uiPercentage,
            __in std::function<_Type1*(_Type1*, _Type2&, _Args...)> pfnFuzz,
            __in std::function<void(_Type1*)> pfnDealloc = nullptr) throw()
        {
            _range_fuzz_array_entry<_Type1, _Type2, _Args...> r = { 0 };
            r.fae.uiPercentage = uiPercentage;
            r.fae.pfnFuzz = pfnFuzz;
            r.fae.pfnDealloc = pfnDealloc;
            ConvertPercentageToRange(uiPercentage, m_iPercentageTotal, &r.range);
            m_map.push_back(r);
            return (m_iPercentageTotal >= 0) ? S_OK : E_INVALIDARG;
        }",9,<empty>,,477,10,CPPASTProblemDeclaration,,<empty>
586053,UNKNOWN,1,,_Type1*,60,<empty>,,520,1,CPPASTTypeId,,<empty>
586138,UNKNOWN,-1,,"[[nodiscard]] HRESULT Init(
            __in_ecount(cfae) const _fuzz_array_entry<_Type1, _Type2, _Args...>* rgfae,
            __in ULONG cfae)
        {
            m_rgRealloc = nullptr;
            m_ftEffectiveTraits = m_traits;

            // Since constructors cannot return error values, the
            // TRAIT_THROW_ON_INIT_FAILURE trait allows for an exception
            // to be thrown in the event that this class was not initialized
            // correctly.  The intended purpose is to catch users of this
            // codebase who have incorrectly specified fuzz maps that add up
            // to more than 100%.
            HRESULT hr = SetFuzzArrayMap(rgfae, cfae);
            if (FAILED(hr) && (m_traits & TRAIT_THROW_ON_INIT_FAILURE))
            {
                throw CFuzzRangeException();
            }

            if (m_rgCaller == nullptr)
            {
                m_ftEffectiveTraits |= TRAIT_TRANSFER_ALLOCATION;
            }

            return hr;
   ...",9,<empty>,,574,23,CPPASTProblemDeclaration,,<empty>
586171,UNKNOWN,-1,,"CFuzzArraySize(__inout _Type2& cElems) :
            m_pcElems(&cElems),
            m_pfa(nullptr)
        {
        }",9,<empty>,,650,2,CPPASTProblemDeclaration,,<empty>
586202,UNKNOWN,-1,,"__inline void Pair(__in CFuzzArray<__FUZZING_ALLOCATOR, _Type1, _Type2, _Args...>& rfa)
        {
            m_pfa = rfa.Reference();
        }",9,<empty>,,678,7,CPPASTProblemDeclaration,,<empty>
586212,UNKNOWN,-1,,"CFuzzType(
            __in_ecount(cfte) const _fuzz_type_entry<_Type, _Args...>* rgfte,
            __in ULONG cfte,
            __in _Type t,
            __in _Args&&... args) :
            m_t(t),
            m_tInit(t),
            m_tArgs(std::forward<_Args>(args)...)
        {
            m_pfnOnFuzzedValueFromMap = [](_Type t, std::function<void(_Type)>) { return t; };
            HRESULT hr = SetFuzzTypeMap(rgfte, cfte);

            // Since constructors cannot return error values, the
            // TRAIT_THROW_ON_INIT_FAILURE trait allows for an exception
            // to be thrown in the event that this class was not initialized
            // correctly.  The intended purpose is to catch users of this
            // codebase who have incorrectly specified fuzz maps that add up
            // to more than 100%.
            if (FAILED(hr) && (m_traits & TRAIT_THROW_ON_INIT_FAILURE))
            {
                throw CFuzzRangeException();
            }
        }",9,<empty>,,706,1,CPPASTProblemDeclaration,,<empty>
586217,UNKNOWN,-1,,"__inline _Type operator()(__in _Type t) throw()
        {
            m_t = m_tInit = t;
            return GetValueFromMap();
        }",9,<empty>,,743,3,CPPASTProblemDeclaration,,<empty>
586218,UNKNOWN,-1,,"__inline void operator=(__in _Type t) throw()
        {
            m_t = m_tInit = t;
        }",9,<empty>,,753,4,CPPASTProblemDeclaration,,<empty>
586247,UNKNOWN,-1,,"[[nodiscard]] __inline HRESULT SetFuzzTypeMap(
            __in_ecount(cfte) const _fuzz_type_entry<_Type, _Args...>* rgfte,
            __in ULONG cfte) throw()
        {
            ClearFuzzTypeEntries();

            bool fInvalidEntry{};
            for (ULONG i{}; i < cfte; ++i)
            {
                // Process all entries; failure will be returned at the end.
                fInvalidEntry |= FAILED(AddFuzzTypeEntry(rgfte[i].uiPercentage, rgfte[i].pfnFuzz, rgfte[i].pfnDealloc));
            }

            return (fInvalidEntry || (m_iPercentageTotal >= 0)) ? S_OK : E_INVALIDARG;
        }",9,<empty>,,785,8,CPPASTProblemDeclaration,,<empty>
586248,UNKNOWN,-1,,"[[nodiscard]] HRESULT AddFuzzTypeEntry(
            __in unsigned int uiPercentage,
            __in std::function<_Type(_Type, _Args...)> pfnFuzz,
            __in std::function<void(_Type)> pfnDealloc = nullptr) throw()
        {
            _range_fuzz_type_entry<_Type, _Args...> r = { 0 };
            r.fte.uiPercentage = uiPercentage;
            r.fte.pfnFuzz = pfnFuzz;
            r.fte.pfnDealloc = pfnDealloc;
            ConvertPercentageToRange(uiPercentage, m_iPercentageTotal, &r.range);
            m_map.push_back(r);
            return (m_iPercentageTotal >= 0) ? S_OK : E_INVALIDARG;
        }",9,<empty>,,804,9,CPPASTProblemDeclaration,,<empty>
586362,UNKNOWN,-1,,"CFuzzTypePtr(
            __in_ecount(cfte) const _fuzz_type_entry<_Type>* rgfte,
            __in ULONG cfte,
            __in _Type pt,
            __in _Args&&... args) :
            CFuzzType<_Type, _Args...>(rgfte, cfte, pt, std::forward<_Args>(args)...)
        {
        }",9,<empty>,,891,1,CPPASTProblemDeclaration,,<empty>
586390,UNKNOWN,-1,,"CFuzzString(
            __in_ecount(cfte) const _fuzz_type_entry<_Type*, _Args...>* rgfte,
            __in ULONG cfte,
            __in _Type* psz,
            __in _Args... args) :
            CFuzzType<_Type, _Args...>(rgfte, cfte, psz, std::forward<_Args>(args)...)
        {
            OnFuzzedValueFromMap();
        }",9,<empty>,,932,1,CPPASTProblemDeclaration,,<empty>
586470,UNKNOWN,-1,,"CFuzzFlags(
            __in_ecount(cfte) const _fuzz_type_entry<_Type>* rgfte,
            __in ULONG cfte,
            __in _Type flags,
            __in _Args&&... args) :
            CFuzzType<_Type, _Args...>(rgfte, cfte, flags, std::forward<_Args>(args)...)
        {
        }",9,<empty>,,1060,1,CPPASTProblemDeclaration,,<empty>
586558,UNKNOWN,3,,"template<typename _Type, typename... _Args>
static __forceinline _Type __untrusted_init(
    __in_opt void*,
    __in ULONG,
    __in _Type t,
    __in _Args&&...)
{
    return t;
}",1,<empty>,,1215,3,CPPASTProblemDeclaration,,<empty>
586559,UNKNOWN,4,,"template<typename... _Args>
static __forceinline LPWSTR __untrusted_lpwstr_init(
    __in_opt void*,
    __in ULONG,
    __in LPWSTR pwsz,
    __in _Args&&...)
{
    return pwsz;
}",1,<empty>,,1225,4,CPPASTProblemDeclaration,,<empty>
586560,UNKNOWN,5,,"template<typename... _Args>
static __forceinline LPSTR __untrusted_lpstr_init(
    __in_opt void*,
    __in ULONG,
    __in LPSTR psz,
    __in _Args&&...)
{
    return psz;
}",1,<empty>,,1235,5,CPPASTProblemDeclaration,,<empty>
586561,UNKNOWN,6,,"template<typename _Type1, typename _Type2, typename... _Args>
static __forceinline _Type1* __untrusted_array_init(
    __in_opt void*,
    __in ULONG,
    __in _Type1* pt,
    __in _Type2,
    __in _Args&&...)
{
    return pt;
}",1,<empty>,,1245,6,CPPASTProblemDeclaration,,<empty>
586569,UNKNOWN,8,,"template<typename _Type, typename... _Args>
static __forceinline void __make_untrusted_ptr(__in _Type&)
{
    return;
}",1,<empty>,,1262,8,CPPASTProblemDeclaration,,<empty>
586593,UNKNOWN,-1,,),57,<empty>,,13,2,CPPASTProblemDeclaration,,<empty>
586594,UNKNOWN,-1,,"static void* Reallocate(
            _In_ void* p,
            _In_ size_t nBytes) throw()
        {
            return realloc(p, nBytes);
        }",59,<empty>,,13,3,CPPASTProblemDeclaration,,<empty>
586595,UNKNOWN,-1,,),57,<empty>,,20,4,CPPASTProblemDeclaration,,<empty>
586596,UNKNOWN,-1,,"static void* Allocate(_In_ size_t nBytes) throw()
        {
            return malloc(nBytes);
        }",59,<empty>,,20,5,CPPASTProblemDeclaration,,<empty>
586597,UNKNOWN,-1,,"static void Free(_In_ void* p) throw()
        {
            free(p);
        }",9,<empty>,,25,6,CPPASTProblemDeclaration,,<empty>
586623,UNKNOWN,1,,"void AppendFormat(
    _In_ std::string& to,
    _In_z_ _Printf_format_string_ const char* format,
    ...)
{
    THROW_HR_IF_NULL(E_INVALIDARG, format);

    va_list args;
    va_start(args, format);

    const auto currentLength = to.length();
    const auto appendLength = _vscprintf(format, args); // _vscprintf The value returned does not include the terminating null character.

    THROW_HR_IF(E_FAIL, appendLength < 0);

    // sprintf_s guarantees that the buffer will be null-terminated. So allocate one more byte for null character and then remove it.
    to.resize(currentLength + appendLength + 1);

    const auto len = vsprintf_s(to.data() + currentLength, appendLength + 1, format, args);
    THROW_HR_IF(E_FAIL, len < 0);

    to.resize(currentLength + appendLength);

    va_end(args);
}",1,<empty>,,9,1,CPPASTProblemDeclaration,,<empty>
586624,UNKNOWN,2,,"template<typename T>
void TrimLeft(_In_ T& str, _In_ const typename T::value_type ch)
{
    const auto pos = str.find_first_not_of(ch);
    if (pos != T::npos)
    {
        str.erase(0, pos);
    }
    else
    {
        // find_first_not_of returns npos when:
        // 1. str is empty.
        // 2. str contains only ch. (For example : str = ""AAA"", ch = 'A')
        // So here we should clear the string.
        str.clear();
    }
}",1,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
586625,UNKNOWN,3,,"template<typename T>
void TrimRight(_In_ T& str, _In_ const typename T::value_type ch)
{
    const auto pos = str.find_last_not_of(ch);
    if (pos != T::npos)
    {
        str.resize(pos + 1);
    }
    else
    {
        str.clear();
    }
}",1,<empty>,,53,3,CPPASTProblemDeclaration,,<empty>
586758,UNKNOWN,1,,wchar_t,18,<empty>,,34,1,CPPASTTypeId,,<empty>
586775,UNKNOWN,1,,char*,45,<empty>,,40,1,CPPASTTypeId,,<empty>
586809,UNKNOWN,1,,UINT,23,<empty>,,56,1,CPPASTTypeId,,<empty>
589454,UNKNOWN,1,,wchar_t,41,<empty>,,1972,1,CPPASTTypeId,,<empty>
590270,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(g_hConsoleVirtTermParserEventTraceProvider,
                             ""Microsoft.Windows.Console.VirtualTerminal.Parser"",
                             // {c9ba2a84-d3ca-5e19-2bd6-776a0910cb9d}
                             (0xc9ba2a84, 0xd3ca, 0x5e19, 0x2b, 0xd6, 0x77, 0x6a, 0x09, 0x10, 0xcb, 0x9d));",1,<empty>,,14,1,CPPASTProblemDeclaration,,<empty>
590276,UNKNOWN,4,,"void ParserTracing::TraceStateChange(_In_z_ const wchar_t* name) const noexcept
{
    TraceLoggingWrite(g_hConsoleVirtTermParserEventTraceProvider,
                      ""StateMachine_EnterState"",
                      TraceLoggingWideString(name),
                      TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                      TraceLoggingKeyword(TIL_KEYWORD_TRACE));
}",1,<empty>,,26,4,CPPASTProblemDeclaration,,<empty>
590277,UNKNOWN,5,,"void ParserTracing::TraceOnAction(_In_z_ const wchar_t* name) const noexcept
{
    TraceLoggingWrite(g_hConsoleVirtTermParserEventTraceProvider,
                      ""StateMachine_Action"",
                      TraceLoggingWideString(name),
                      TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                      TraceLoggingKeyword(TIL_KEYWORD_TRACE));
}",1,<empty>,,35,5,CPPASTProblemDeclaration,,<empty>
590334,UNKNOWN,8,,"void ParserTracing::TraceOnEvent(_In_z_ const wchar_t* name) const noexcept
{
    TraceLoggingWrite(g_hConsoleVirtTermParserEventTraceProvider,
                      ""StateMachine_Event"",
                      TraceLoggingWideString(name),
                      TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
                      TraceLoggingKeyword(TIL_KEYWORD_TRACE));
}",1,<empty>,,66,8,CPPASTProblemDeclaration,,<empty>
590516,UNKNOWN,-1,,"class ParserTracing sealed
    {
    public:
        // NOTE: This code uses
        //   (_In_z_ const wchar_t* name)
        // as arguments instead of the more modern std::wstring_view
        // for performance reasons.
        //
        // Passing structures larger than the register size is very expensive
        // due to Microsoft's x64 calling convention. We could reduce the
        // overhead by passing the string-view by reference, but this forces us
        // to allocate the parameters as static string-views on the data
        // segment of our binary. I've found that passing them as classic
        // C-strings is more ergonomic instead and fits the need for
        // high performance in this particular code.

        void TraceStateChange(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnAction(_In_z_ const wchar_t* name) const noexcept;
        void TraceOnExecute(const wchar_t wch) const noexcept;
        void TraceOnExecuteFromEscape(const wchar_t ...",5,<empty>,,25,1,CPPASTProblemDeclaration,,<empty>
590560,UNKNOWN,3,,};,1,<empty>,,119,3,CPPASTProblemDeclaration,,<empty>
590714,UNKNOWN,-1,,"void RoundtripTerminalInputCallback(_In_ const std::span<const INPUT_RECORD>& inputRecords)
    {
        // Take all the characters out of the input records here, and put them into
        //  the input state machine.
        std::wstring vtseq = L"""";
        for (auto& inRec : inputRecords)
        {
            VERIFY_ARE_EQUAL(KEY_EVENT, inRec.EventType);
            if (inRec.Event.KeyEvent.bKeyDown)
            {
                vtseq += &inRec.Event.KeyEvent.uChar.UnicodeChar;
            }
        }
        Log::Comment(
            NoThrowString().Format(L""\tvtseq: \""%s\""(%zu)"", vtseq.c_str(), vtseq.length()));

        _stateMachine->ProcessString(vtseq);
        Log::Comment(L""String processed"");
    }",5,<empty>,,78,2,CPPASTProblemDeclaration,,<empty>
591085,UNKNOWN,1,,size_t,38,<empty>,,189,1,CPPASTTypeId,,<empty>
591120,UNKNOWN,8,,"TEST_METHOD_SETUP(MethodSetup)
    {
        return true;",5,<empty>,,245,8,CPPASTProblemDeclaration,,<empty>
591121,UNKNOWN,9,,},5,<empty>,,248,9,CPPASTProblemDeclaration,,<empty>
591149,UNKNOWN,37,,};,1,<empty>,,279,37,CPPASTProblemDeclaration,,<empty>
591230,UNKNOWN,-1,,"TestInteractDispatch(_In_ std::function<void(const std::span<const INPUT_RECORD>&)> pfn,
                         _In_ TestState* testState);",5,<empty>,,317,1,CPPASTProblemDeclaration,,<empty>
591231,UNKNOWN,-1,,virtual bool WriteInput(_In_ const std::span<const INPUT_RECORD>& inputEvents) override;,5,<empty>,,319,2,CPPASTProblemDeclaration,,<empty>
591266,UNKNOWN,40,,"TestInteractDispatch::TestInteractDispatch(_In_ std::function<void(const std::span<const INPUT_RECORD>&)> pfn,
                                           _In_ TestState* testState) :
    _pfnWriteInputCallback(pfn),
    _testState(testState)
{
}",1,<empty>,,339,40,CPPASTProblemDeclaration,,<empty>
591267,UNKNOWN,41,,"bool TestInteractDispatch::WriteInput(_In_ const std::span<const INPUT_RECORD>& inputEvents)
{
    _pfnWriteInputCallback(inputEvents);
    return true;
}",1,<empty>,,346,41,CPPASTProblemDeclaration,,<empty>
591545,UNKNOWN,1,,WORD,26,<empty>,,442,1,CPPASTTypeId,,<empty>
591849,UNKNOWN,1,,wchar_t,26,<empty>,,519,1,CPPASTTypeId,,<empty>
592111,UNKNOWN,1,,unsigned int,46,<empty>,,634,1,CPPASTTypeId,,<empty>
592164,UNKNOWN,1,,DispatchTypes::WindowManipulationType,65,<empty>,,649,1,CPPASTTypeId,,<empty>
592192,UNKNOWN,1,,DispatchTypes::WindowManipulationType,65,<empty>,,658,1,CPPASTTypeId,,<empty>
592700,UNKNOWN,1,,WORD,60,<empty>,,757,1,CPPASTTypeId,,<empty>
592866,UNKNOWN,1,,WORD,60,<empty>,,783,1,CPPASTTypeId,,<empty>
593030,UNKNOWN,1,,wchar_t,27,<empty>,,825,1,CPPASTTypeId,,<empty>
593038,UNKNOWN,1,,WORD,32,<empty>,,826,1,CPPASTTypeId,,<empty>
593083,UNKNOWN,1,,WORD,63,<empty>,,832,1,CPPASTTypeId,,<empty>
593238,UNKNOWN,1,,wchar_t,27,<empty>,,869,1,CPPASTTypeId,,<empty>
593246,UNKNOWN,1,,WORD,32,<empty>,,870,1,CPPASTTypeId,,<empty>
593291,UNKNOWN,1,,WORD,63,<empty>,,876,1,CPPASTTypeId,,<empty>
593464,UNKNOWN,1,,WORD,60,<empty>,,905,1,CPPASTTypeId,,<empty>
593632,UNKNOWN,1,,WORD,60,<empty>,,933,1,CPPASTTypeId,,<empty>
593908,UNKNOWN,1,,WORD,60,<empty>,,1014,1,CPPASTTypeId,,<empty>
593984,UNKNOWN,1,,WORD,60,<empty>,,1029,1,CPPASTTypeId,,<empty>
594143,UNKNOWN,1,,int,97,<empty>,,1087,1,CPPASTTypeId,,<empty>
595435,UNKNOWN,1,,WORD,26,<empty>,,1347,1,CPPASTTypeId,,<empty>
595541,UNKNOWN,1,,WORD,26,<empty>,,1369,1,CPPASTTypeId,,<empty>
596663,UNKNOWN,-1,,),34,<empty>,,1555,2,CPPASTProblemStatement,,<empty>
596667,UNKNOWN,-1,,),77,<empty>,,1556,4,CPPASTProblemStatement,,<empty>
596671,UNKNOWN,-1,,),78,<empty>,,1557,6,CPPASTProblemStatement,,<empty>
596675,UNKNOWN,-1,,),71,<empty>,,1558,8,CPPASTProblemStatement,,<empty>
596679,UNKNOWN,-1,,),70,<empty>,,1559,10,CPPASTProblemStatement,,<empty>
596683,UNKNOWN,-1,,),81,<empty>,,1560,12,CPPASTProblemStatement,,<empty>
596687,UNKNOWN,-1,,),74,<empty>,,1561,14,CPPASTProblemStatement,,<empty>
596691,UNKNOWN,-1,,),73,<empty>,,1562,16,CPPASTProblemStatement,,<empty>
596696,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideVirtualKeyCode, L""If true, pass the VirtualKeyCode param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1565,1,CPPASTProblemStatement,,<empty>
596700,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideVirtualScanCode, L""If true, pass the VirtualScanCode param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1566,1,CPPASTProblemStatement,,<empty>
596704,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideCharData, L""If true, pass the CharData param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1567,1,CPPASTProblemStatement,,<empty>
596708,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideKeyDown, L""If true, pass the KeyDown param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1568,1,CPPASTProblemStatement,,<empty>
596712,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideActiveModifierKeys, L""If true, pass the ActiveModifierKeys param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1569,1,CPPASTProblemStatement,,<empty>
596716,UNKNOWN,1,,"INIT_TEST_PROPERTY(bool, provideRepeatCount, L""If true, pass the RepeatCount param in the list of params. Otherwise, leave it as the default param value (0)"")",5,<empty>,,1570,1,CPPASTProblemStatement,,<empty>
596720,UNKNOWN,1,,"INIT_TEST_PROPERTY(size_t, numParams, L""Control how many of the params we send"")",5,<empty>,,1571,1,CPPASTProblemStatement,,<empty>
597064,UNKNOWN,4,,"TEST_METHOD(TestEscapeThenC0Path)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,212,4,CPPASTProblemDeclaration,,<empty>
597084,UNKNOWN,8,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,218,8,CPPASTProblemDeclaration,,<empty>
597085,UNKNOWN,9,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,219,9,CPPASTProblemDeclaration,,<empty>
597086,UNKNOWN,10,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,220,10,CPPASTProblemDeclaration,,<empty>
597087,UNKNOWN,11,,mach.ProcessCharacter(L'\x03');,9,<empty>,,224,11,CPPASTProblemDeclaration,,<empty>
597088,UNKNOWN,12,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,225,12,CPPASTProblemDeclaration,,<empty>
597089,UNKNOWN,13,,mach.ProcessCharacter(L'[');,9,<empty>,,226,13,CPPASTProblemDeclaration,,<empty>
597090,UNKNOWN,14,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,227,14,CPPASTProblemDeclaration,,<empty>
597091,UNKNOWN,15,,mach.ProcessCharacter(L'3');,9,<empty>,,228,15,CPPASTProblemDeclaration,,<empty>
597092,UNKNOWN,16,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,229,16,CPPASTProblemDeclaration,,<empty>
597093,UNKNOWN,17,,mach.ProcessCharacter(L'1');,9,<empty>,,230,17,CPPASTProblemDeclaration,,<empty>
597094,UNKNOWN,18,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,231,18,CPPASTProblemDeclaration,,<empty>
597095,UNKNOWN,19,,mach.ProcessCharacter(L'm');,9,<empty>,,232,19,CPPASTProblemDeclaration,,<empty>
597096,UNKNOWN,20,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,233,20,CPPASTProblemDeclaration,,<empty>
597097,UNKNOWN,21,,},5,<empty>,,234,21,CPPASTProblemDeclaration,,<empty>
597098,UNKNOWN,22,,"TEST_METHOD(TestGroundPrint)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,236,22,CPPASTProblemDeclaration,,<empty>
597113,UNKNOWN,25,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,242,25,CPPASTProblemDeclaration,,<empty>
597114,UNKNOWN,26,,mach.ProcessCharacter(L'a');,9,<empty>,,243,26,CPPASTProblemDeclaration,,<empty>
597115,UNKNOWN,27,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,244,27,CPPASTProblemDeclaration,,<empty>
597116,UNKNOWN,28,,},5,<empty>,,245,28,CPPASTProblemDeclaration,,<empty>
597117,UNKNOWN,29,,"TEST_METHOD(TestCsiEntry)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,247,29,CPPASTProblemDeclaration,,<empty>
597132,UNKNOWN,32,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,253,32,CPPASTProblemDeclaration,,<empty>
597133,UNKNOWN,33,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,254,33,CPPASTProblemDeclaration,,<empty>
597134,UNKNOWN,34,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,255,34,CPPASTProblemDeclaration,,<empty>
597135,UNKNOWN,35,,mach.ProcessCharacter(L'[');,9,<empty>,,256,35,CPPASTProblemDeclaration,,<empty>
597136,UNKNOWN,36,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,257,36,CPPASTProblemDeclaration,,<empty>
597137,UNKNOWN,37,,mach.ProcessCharacter(L'm');,9,<empty>,,258,37,CPPASTProblemDeclaration,,<empty>
597138,UNKNOWN,38,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,259,38,CPPASTProblemDeclaration,,<empty>
597139,UNKNOWN,39,,},5,<empty>,,260,39,CPPASTProblemDeclaration,,<empty>
597140,UNKNOWN,40,,"TEST_METHOD(TestC1CsiEntry)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,262,40,CPPASTProblemDeclaration,,<empty>
597155,UNKNOWN,43,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,269,43,CPPASTProblemDeclaration,,<empty>
597156,UNKNOWN,44,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,271,44,CPPASTProblemDeclaration,,<empty>
597157,UNKNOWN,45,,mach.ProcessCharacter(L'\x9b');,9,<empty>,,272,45,CPPASTProblemDeclaration,,<empty>
597158,UNKNOWN,46,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,273,46,CPPASTProblemDeclaration,,<empty>
597159,UNKNOWN,47,,mach.ProcessCharacter(L'm');,9,<empty>,,274,47,CPPASTProblemDeclaration,,<empty>
597160,UNKNOWN,48,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,275,48,CPPASTProblemDeclaration,,<empty>
597161,UNKNOWN,49,,},5,<empty>,,276,49,CPPASTProblemDeclaration,,<empty>
597162,UNKNOWN,50,,"TEST_METHOD(TestCsiImmediate)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,278,50,CPPASTProblemDeclaration,,<empty>
597177,UNKNOWN,53,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,284,53,CPPASTProblemDeclaration,,<empty>
597178,UNKNOWN,54,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,285,54,CPPASTProblemDeclaration,,<empty>
597179,UNKNOWN,55,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,286,55,CPPASTProblemDeclaration,,<empty>
597180,UNKNOWN,56,,mach.ProcessCharacter(L'[');,9,<empty>,,287,56,CPPASTProblemDeclaration,,<empty>
597181,UNKNOWN,57,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,288,57,CPPASTProblemDeclaration,,<empty>
597182,UNKNOWN,58,,mach.ProcessCharacter(L'$');,9,<empty>,,289,58,CPPASTProblemDeclaration,,<empty>
597183,UNKNOWN,59,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIntermediate);",9,<empty>,,290,59,CPPASTProblemDeclaration,,<empty>
597184,UNKNOWN,60,,mach.ProcessCharacter(L'#');,9,<empty>,,291,60,CPPASTProblemDeclaration,,<empty>
597185,UNKNOWN,61,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIntermediate);",9,<empty>,,292,61,CPPASTProblemDeclaration,,<empty>
597186,UNKNOWN,62,,mach.ProcessCharacter(L'%');,9,<empty>,,293,62,CPPASTProblemDeclaration,,<empty>
597187,UNKNOWN,63,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIntermediate);",9,<empty>,,294,63,CPPASTProblemDeclaration,,<empty>
597188,UNKNOWN,64,,mach.ProcessCharacter(L'v');,9,<empty>,,295,64,CPPASTProblemDeclaration,,<empty>
597189,UNKNOWN,65,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,296,65,CPPASTProblemDeclaration,,<empty>
597190,UNKNOWN,66,,},5,<empty>,,297,66,CPPASTProblemDeclaration,,<empty>
597191,UNKNOWN,67,,"TEST_METHOD(TestCsiParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,299,67,CPPASTProblemDeclaration,,<empty>
597206,UNKNOWN,70,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,305,70,CPPASTProblemDeclaration,,<empty>
597207,UNKNOWN,71,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,306,71,CPPASTProblemDeclaration,,<empty>
597208,UNKNOWN,72,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,307,72,CPPASTProblemDeclaration,,<empty>
597209,UNKNOWN,73,,mach.ProcessCharacter(L'[');,9,<empty>,,308,73,CPPASTProblemDeclaration,,<empty>
597210,UNKNOWN,74,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,309,74,CPPASTProblemDeclaration,,<empty>
597211,UNKNOWN,75,,mach.ProcessCharacter(L';');,9,<empty>,,310,75,CPPASTProblemDeclaration,,<empty>
597212,UNKNOWN,76,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,311,76,CPPASTProblemDeclaration,,<empty>
597213,UNKNOWN,77,,mach.ProcessCharacter(L'3');,9,<empty>,,312,77,CPPASTProblemDeclaration,,<empty>
597214,UNKNOWN,78,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,313,78,CPPASTProblemDeclaration,,<empty>
597215,UNKNOWN,79,,mach.ProcessCharacter(L'2');,9,<empty>,,314,79,CPPASTProblemDeclaration,,<empty>
597216,UNKNOWN,80,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,315,80,CPPASTProblemDeclaration,,<empty>
597217,UNKNOWN,81,,mach.ProcessCharacter(L'4');,9,<empty>,,316,81,CPPASTProblemDeclaration,,<empty>
597218,UNKNOWN,82,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,317,82,CPPASTProblemDeclaration,,<empty>
597219,UNKNOWN,83,,mach.ProcessCharacter(L';');,9,<empty>,,318,83,CPPASTProblemDeclaration,,<empty>
597220,UNKNOWN,84,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,319,84,CPPASTProblemDeclaration,,<empty>
597221,UNKNOWN,85,,mach.ProcessCharacter(L';');,9,<empty>,,320,85,CPPASTProblemDeclaration,,<empty>
597222,UNKNOWN,86,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,321,86,CPPASTProblemDeclaration,,<empty>
597223,UNKNOWN,87,,mach.ProcessCharacter(L'8');,9,<empty>,,322,87,CPPASTProblemDeclaration,,<empty>
597224,UNKNOWN,88,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,323,88,CPPASTProblemDeclaration,,<empty>
597225,UNKNOWN,89,,mach.ProcessCharacter(L'J');,9,<empty>,,324,89,CPPASTProblemDeclaration,,<empty>
597226,UNKNOWN,90,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,325,90,CPPASTProblemDeclaration,,<empty>
597227,UNKNOWN,91,,"VERIFY_ARE_EQUAL(mach._parameters.size(), 4u);",9,<empty>,,327,91,CPPASTProblemDeclaration,,<empty>
597228,UNKNOWN,92,,VERIFY_IS_FALSE(mach._parameters.at(0).has_value());,9,<empty>,,328,92,CPPASTProblemDeclaration,,<empty>
597229,UNKNOWN,93,,"VERIFY_ARE_EQUAL(mach._parameters.at(1), 324);",9,<empty>,,329,93,CPPASTProblemDeclaration,,<empty>
597230,UNKNOWN,94,,VERIFY_IS_FALSE(mach._parameters.at(2).has_value());,9,<empty>,,330,94,CPPASTProblemDeclaration,,<empty>
597231,UNKNOWN,95,,"VERIFY_ARE_EQUAL(mach._parameters.at(3), 8);",9,<empty>,,331,95,CPPASTProblemDeclaration,,<empty>
597232,UNKNOWN,96,,},5,<empty>,,332,96,CPPASTProblemDeclaration,,<empty>
597233,UNKNOWN,97,,"TEST_METHOD(TestCsiMaxParamCount)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,334,97,CPPASTProblemDeclaration,,<empty>
597248,UNKNOWN,100,,"Log::Comment(L""Output a sequence with 100 parameters"");",9,<empty>,,340,100,CPPASTProblemDeclaration,,<empty>
597249,UNKNOWN,101,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,341,101,CPPASTProblemDeclaration,,<empty>
597250,UNKNOWN,102,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,342,102,CPPASTProblemDeclaration,,<empty>
597251,UNKNOWN,103,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,343,103,CPPASTProblemDeclaration,,<empty>
597252,UNKNOWN,104,,mach.ProcessCharacter(L'[');,9,<empty>,,344,104,CPPASTProblemDeclaration,,<empty>
597253,UNKNOWN,105,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,345,105,CPPASTProblemDeclaration,,<empty>
597254,UNKNOWN,106,,for (size_t i = 0;,9,<empty>,,346,106,CPPASTProblemDeclaration,,<empty>
597255,UNKNOWN,107,,i < 100;,28,<empty>,,346,107,CPPASTProblemDeclaration,,<empty>
597256,UNKNOWN,108,,"i++)
        {
            if (i > 0)
            {
                mach.ProcessCharacter(L';');
                VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
            }
            mach.ProcessCharacter(L'0' + i % 10);
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
        }",37,<empty>,,346,108,CPPASTProblemDeclaration,,<empty>
597257,UNKNOWN,109,,mach.ProcessCharacter(L'J');,9,<empty>,,356,109,CPPASTProblemDeclaration,,<empty>
597258,UNKNOWN,110,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,357,110,CPPASTProblemDeclaration,,<empty>
597259,UNKNOWN,111,,"Log::Comment(L""Only MAX_PARAMETER_COUNT (32) parameters should be stored"");",9,<empty>,,359,111,CPPASTProblemDeclaration,,<empty>
597260,UNKNOWN,112,,"VERIFY_ARE_EQUAL(mach._parameters.size(), MAX_PARAMETER_COUNT);",9,<empty>,,360,112,CPPASTProblemDeclaration,,<empty>
597261,UNKNOWN,113,,for (size_t i = 0;,9,<empty>,,361,113,CPPASTProblemDeclaration,,<empty>
597262,UNKNOWN,114,,i < MAX_PARAMETER_COUNT;,28,<empty>,,361,114,CPPASTProblemDeclaration,,<empty>
597263,UNKNOWN,115,,"i++)
        {
            VERIFY_IS_TRUE(mach._parameters.at(i).has_value());
            VERIFY_ARE_EQUAL(mach._parameters.at(i).value(), gsl::narrow_cast<VTInt>(i % 10));
        }",53,<empty>,,361,115,CPPASTProblemDeclaration,,<empty>
597264,UNKNOWN,116,,},5,<empty>,,366,116,CPPASTProblemDeclaration,,<empty>
597265,UNKNOWN,117,,"TEST_METHOD(TestLeadingZeroCsiParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,368,117,CPPASTProblemDeclaration,,<empty>
597280,UNKNOWN,120,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,374,120,CPPASTProblemDeclaration,,<empty>
597281,UNKNOWN,121,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,375,121,CPPASTProblemDeclaration,,<empty>
597282,UNKNOWN,122,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,376,122,CPPASTProblemDeclaration,,<empty>
597283,UNKNOWN,123,,mach.ProcessCharacter(L'[');,9,<empty>,,377,123,CPPASTProblemDeclaration,,<empty>
597284,UNKNOWN,124,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,378,124,CPPASTProblemDeclaration,,<empty>
597285,UNKNOWN,125,,for (auto i = 0;,9,<empty>,,379,125,CPPASTProblemDeclaration,,<empty>
597286,UNKNOWN,126,,i < 50;,26,<empty>,,379,126,CPPASTProblemDeclaration,,<empty>
597287,UNKNOWN,127,,"i++) // Any number of leading zeros should be supported
        {
            mach.ProcessCharacter(L'0');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
        }",34,<empty>,,379,127,CPPASTProblemDeclaration,,<empty>
597288,UNKNOWN,128,,for (auto i = 0;,9,<empty>,,384,128,CPPASTProblemDeclaration,,<empty>
597289,UNKNOWN,129,,i < 5;,26,<empty>,,384,129,CPPASTProblemDeclaration,,<empty>
597290,UNKNOWN,130,,"i++) // We're only expecting to be able to keep 5 digits max
        {
            mach.ProcessCharacter((wchar_t)(L'1' + i));
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
        }",33,<empty>,,384,130,CPPASTProblemDeclaration,,<empty>
597291,UNKNOWN,131,,"VERIFY_ARE_EQUAL(mach._parameters.back(), 12345);",9,<empty>,,389,131,CPPASTProblemDeclaration,,<empty>
597292,UNKNOWN,132,,mach.ProcessCharacter(L'J');,9,<empty>,,390,132,CPPASTProblemDeclaration,,<empty>
597293,UNKNOWN,133,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,391,133,CPPASTProblemDeclaration,,<empty>
597294,UNKNOWN,134,,},5,<empty>,,392,134,CPPASTProblemDeclaration,,<empty>
597295,UNKNOWN,135,,"TEST_METHOD(TestCsiSubParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,394,135,CPPASTProblemDeclaration,,<empty>
597310,UNKNOWN,138,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,401,138,CPPASTProblemDeclaration,,<empty>
597311,UNKNOWN,139,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,402,139,CPPASTProblemDeclaration,,<empty>
597312,UNKNOWN,140,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,403,140,CPPASTProblemDeclaration,,<empty>
597313,UNKNOWN,141,,mach.ProcessCharacter(L'[');,9,<empty>,,404,141,CPPASTProblemDeclaration,,<empty>
597314,UNKNOWN,142,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,405,142,CPPASTProblemDeclaration,,<empty>
597315,UNKNOWN,143,,mach.ProcessCharacter(L':');,9,<empty>,,406,143,CPPASTProblemDeclaration,,<empty>
597316,UNKNOWN,144,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,407,144,CPPASTProblemDeclaration,,<empty>
597317,UNKNOWN,145,,mach.ProcessCharacter(L'3');,9,<empty>,,408,145,CPPASTProblemDeclaration,,<empty>
597318,UNKNOWN,146,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,409,146,CPPASTProblemDeclaration,,<empty>
597319,UNKNOWN,147,,mach.ProcessCharacter(L';');,9,<empty>,,410,147,CPPASTProblemDeclaration,,<empty>
597320,UNKNOWN,148,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,411,148,CPPASTProblemDeclaration,,<empty>
597321,UNKNOWN,149,,mach.ProcessCharacter(L'9');,9,<empty>,,412,149,CPPASTProblemDeclaration,,<empty>
597322,UNKNOWN,150,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,413,150,CPPASTProblemDeclaration,,<empty>
597323,UNKNOWN,151,,mach.ProcessCharacter(L':');,9,<empty>,,414,151,CPPASTProblemDeclaration,,<empty>
597324,UNKNOWN,152,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,415,152,CPPASTProblemDeclaration,,<empty>
597325,UNKNOWN,153,,mach.ProcessCharacter(L'5');,9,<empty>,,416,153,CPPASTProblemDeclaration,,<empty>
597326,UNKNOWN,154,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,417,154,CPPASTProblemDeclaration,,<empty>
597327,UNKNOWN,155,,mach.ProcessCharacter(L':');,9,<empty>,,418,155,CPPASTProblemDeclaration,,<empty>
597328,UNKNOWN,156,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,419,156,CPPASTProblemDeclaration,,<empty>
597329,UNKNOWN,157,,mach.ProcessCharacter(L':');,9,<empty>,,420,157,CPPASTProblemDeclaration,,<empty>
597330,UNKNOWN,158,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,421,158,CPPASTProblemDeclaration,,<empty>
597331,UNKNOWN,159,,mach.ProcessCharacter(L'8');,9,<empty>,,422,159,CPPASTProblemDeclaration,,<empty>
597332,UNKNOWN,160,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,423,160,CPPASTProblemDeclaration,,<empty>
597333,UNKNOWN,161,,mach.ProcessCharacter(L'J');,9,<empty>,,424,161,CPPASTProblemDeclaration,,<empty>
597334,UNKNOWN,162,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,425,162,CPPASTProblemDeclaration,,<empty>
597335,UNKNOWN,163,,"VERIFY_ARE_EQUAL(mach._parameters.size(), 2u);",9,<empty>,,427,163,CPPASTProblemDeclaration,,<empty>
597336,UNKNOWN,164,,VERIFY_IS_FALSE(mach._parameters.at(0).has_value());,9,<empty>,,428,164,CPPASTProblemDeclaration,,<empty>
597337,UNKNOWN,165,,"VERIFY_ARE_EQUAL(mach._parameters.at(1), 9);",9,<empty>,,429,165,CPPASTProblemDeclaration,,<empty>
597338,UNKNOWN,166,,"VERIFY_ARE_EQUAL(mach._subParameters.size(), 4u);",9,<empty>,,431,166,CPPASTProblemDeclaration,,<empty>
597339,UNKNOWN,167,,"VERIFY_ARE_EQUAL(mach._subParameters.at(0), 3);",9,<empty>,,432,167,CPPASTProblemDeclaration,,<empty>
597340,UNKNOWN,168,,"VERIFY_ARE_EQUAL(mach._subParameters.at(1), 5);",9,<empty>,,433,168,CPPASTProblemDeclaration,,<empty>
597341,UNKNOWN,169,,VERIFY_IS_FALSE(mach._subParameters.at(2).has_value());,9,<empty>,,434,169,CPPASTProblemDeclaration,,<empty>
597342,UNKNOWN,170,,"VERIFY_ARE_EQUAL(mach._subParameters.at(3), 8);",9,<empty>,,435,170,CPPASTProblemDeclaration,,<empty>
597343,UNKNOWN,171,,"VERIFY_ARE_EQUAL(mach._subParameterRanges.at(0).first, 0);",9,<empty>,,437,171,CPPASTProblemDeclaration,,<empty>
597344,UNKNOWN,172,,"VERIFY_ARE_EQUAL(mach._subParameterRanges.at(0).second, 1);",9,<empty>,,438,172,CPPASTProblemDeclaration,,<empty>
597345,UNKNOWN,173,,"VERIFY_ARE_EQUAL(mach._subParameterRanges.at(1).first, 1);",9,<empty>,,439,173,CPPASTProblemDeclaration,,<empty>
597346,UNKNOWN,174,,"VERIFY_ARE_EQUAL(mach._subParameterRanges.at(1).second, 4);",9,<empty>,,440,174,CPPASTProblemDeclaration,,<empty>
597347,UNKNOWN,175,,"VERIFY_ARE_EQUAL(mach._subParameterRanges.size(), mach._parameters.size());",9,<empty>,,442,175,CPPASTProblemDeclaration,,<empty>
597348,UNKNOWN,176,,"VERIFY_IS_TRUE(
            (mach._subParameterRanges.back().second == mach._subParameters.size() - 1) // lastIndex
            || (mach._subParameterRanges.back().second == mach._subParameters.size()) // or lastIndex + 1
        );",9,<empty>,,443,176,CPPASTProblemDeclaration,,<empty>
597349,UNKNOWN,177,,},5,<empty>,,447,177,CPPASTProblemDeclaration,,<empty>
597350,UNKNOWN,178,,"TEST_METHOD(TestCsiMaxSubParamCount)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,449,178,CPPASTProblemDeclaration,,<empty>
597365,UNKNOWN,181,,"Log::Comment(L""Output two parameters with 100 sub parameters each"");",9,<empty>,,455,181,CPPASTProblemDeclaration,,<empty>
597366,UNKNOWN,182,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,456,182,CPPASTProblemDeclaration,,<empty>
597367,UNKNOWN,183,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,457,183,CPPASTProblemDeclaration,,<empty>
597368,UNKNOWN,184,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,458,184,CPPASTProblemDeclaration,,<empty>
597369,UNKNOWN,185,,mach.ProcessCharacter(L'[');,9,<empty>,,459,185,CPPASTProblemDeclaration,,<empty>
597370,UNKNOWN,186,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,460,186,CPPASTProblemDeclaration,,<empty>
597371,UNKNOWN,187,,for (size_t nParam = 0;,9,<empty>,,461,187,CPPASTProblemDeclaration,,<empty>
597372,UNKNOWN,188,,nParam < 2;,33,<empty>,,461,188,CPPASTProblemDeclaration,,<empty>
597373,UNKNOWN,189,,"nParam++)
        {
            mach.ProcessCharacter(L'3');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
            for (size_t i = 0; i < 100; i++)
            {
                mach.ProcessCharacter(L':');
                VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);
                mach.ProcessCharacter(L'0' + i % 10);
                VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);
            }
            Log::Comment(L""Receiving 100 sub parameters should set the overflow flag"");
            VERIFY_IS_TRUE(mach._subParameterLimitOverflowed);
            mach.ProcessCharacter(L';');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);
            VERIFY_IS_FALSE(mach._subParameterLimitOverflowed);
        }",45,<empty>,,461,189,CPPASTProblemDeclaration,,<empty>
597374,UNKNOWN,190,,mach.ProcessCharacter(L'J');,9,<empty>,,478,190,CPPASTProblemDeclaration,,<empty>
597375,UNKNOWN,191,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,479,191,CPPASTProblemDeclaration,,<empty>
597376,UNKNOWN,192,,"Log::Comment(L""Only MAX_SUBPARAMETER_COUNT (6) sub parameters should be stored for each parameter"");",9,<empty>,,481,192,CPPASTProblemDeclaration,,<empty>
597377,UNKNOWN,193,,"VERIFY_ARE_EQUAL(mach._subParameters.size(), 12u);",9,<empty>,,482,193,CPPASTProblemDeclaration,,<empty>
597378,UNKNOWN,194,,for (size_t i = 0;,9,<empty>,,486,194,CPPASTProblemDeclaration,,<empty>
597379,UNKNOWN,195,,i < 12;,28,<empty>,,486,195,CPPASTProblemDeclaration,,<empty>
597380,UNKNOWN,196,,"i++)
        {
            VERIFY_IS_TRUE(mach._subParameters.at(i).has_value());
            VERIFY_ARE_EQUAL(mach._subParameters.at(i).value(), gsl::narrow_cast<VTInt>(i % 6));
        }",36,<empty>,,486,196,CPPASTProblemDeclaration,,<empty>
597401,UNKNOWN,201,,"VERIFY_ARE_EQUAL(firstRange.first, 0);",9,<empty>,,494,201,CPPASTProblemDeclaration,,<empty>
597402,UNKNOWN,202,,"VERIFY_ARE_EQUAL(firstRange.second, 6);",9,<empty>,,495,202,CPPASTProblemDeclaration,,<empty>
597403,UNKNOWN,203,,"VERIFY_ARE_EQUAL(secondRange.first, 6);",9,<empty>,,496,203,CPPASTProblemDeclaration,,<empty>
597404,UNKNOWN,204,,"VERIFY_ARE_EQUAL(secondRange.second, 12);",9,<empty>,,497,204,CPPASTProblemDeclaration,,<empty>
597405,UNKNOWN,205,,},5,<empty>,,498,205,CPPASTProblemDeclaration,,<empty>
597406,UNKNOWN,206,,"TEST_METHOD(TestLeadingZeroCsiSubParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,500,206,CPPASTProblemDeclaration,,<empty>
597421,UNKNOWN,209,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,506,209,CPPASTProblemDeclaration,,<empty>
597422,UNKNOWN,210,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,507,210,CPPASTProblemDeclaration,,<empty>
597423,UNKNOWN,211,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,508,211,CPPASTProblemDeclaration,,<empty>
597424,UNKNOWN,212,,mach.ProcessCharacter(L'[');,9,<empty>,,509,212,CPPASTProblemDeclaration,,<empty>
597425,UNKNOWN,213,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,510,213,CPPASTProblemDeclaration,,<empty>
597426,UNKNOWN,214,,mach.ProcessCharacter(L'3');,9,<empty>,,511,214,CPPASTProblemDeclaration,,<empty>
597427,UNKNOWN,215,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,512,215,CPPASTProblemDeclaration,,<empty>
597428,UNKNOWN,216,,mach.ProcessCharacter(L':');,9,<empty>,,513,216,CPPASTProblemDeclaration,,<empty>
597429,UNKNOWN,217,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);",9,<empty>,,514,217,CPPASTProblemDeclaration,,<empty>
597430,UNKNOWN,218,,for (auto i = 0;,9,<empty>,,515,218,CPPASTProblemDeclaration,,<empty>
597431,UNKNOWN,219,,i < 50;,26,<empty>,,515,219,CPPASTProblemDeclaration,,<empty>
597432,UNKNOWN,220,,"i++) // Any number of leading zeros should be supported
        {
            mach.ProcessCharacter(L'0');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);
        }",34,<empty>,,515,220,CPPASTProblemDeclaration,,<empty>
597433,UNKNOWN,221,,for (auto i = 0;,9,<empty>,,520,221,CPPASTProblemDeclaration,,<empty>
597434,UNKNOWN,222,,i < 5;,26,<empty>,,520,222,CPPASTProblemDeclaration,,<empty>
597435,UNKNOWN,223,,"i++) // We're only expecting to be able to keep 5 digits max
        {
            mach.ProcessCharacter((wchar_t)(L'1' + i));
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiSubParam);
        }",33,<empty>,,520,223,CPPASTProblemDeclaration,,<empty>
597436,UNKNOWN,224,,"VERIFY_ARE_EQUAL(mach._subParameters.back(), 12345);",9,<empty>,,525,224,CPPASTProblemDeclaration,,<empty>
597437,UNKNOWN,225,,mach.ProcessCharacter(L'J');,9,<empty>,,526,225,CPPASTProblemDeclaration,,<empty>
597438,UNKNOWN,226,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,527,226,CPPASTProblemDeclaration,,<empty>
597439,UNKNOWN,227,,},5,<empty>,,528,227,CPPASTProblemDeclaration,,<empty>
597440,UNKNOWN,228,,"TEST_METHOD(TestCsiIgnore)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,530,228,CPPASTProblemDeclaration,,<empty>
597455,UNKNOWN,231,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,536,231,CPPASTProblemDeclaration,,<empty>
597456,UNKNOWN,232,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,537,232,CPPASTProblemDeclaration,,<empty>
597457,UNKNOWN,233,,mach.ProcessCharacter(L'[');,9,<empty>,,538,233,CPPASTProblemDeclaration,,<empty>
597458,UNKNOWN,234,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,539,234,CPPASTProblemDeclaration,,<empty>
597459,UNKNOWN,235,,mach.ProcessCharacter(L'4');,9,<empty>,,540,235,CPPASTProblemDeclaration,,<empty>
597460,UNKNOWN,236,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,541,236,CPPASTProblemDeclaration,,<empty>
597461,UNKNOWN,237,,mach.ProcessCharacter(L';');,9,<empty>,,542,237,CPPASTProblemDeclaration,,<empty>
597462,UNKNOWN,238,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,543,238,CPPASTProblemDeclaration,,<empty>
597463,UNKNOWN,239,,mach.ProcessCharacter(L'=');,9,<empty>,,544,239,CPPASTProblemDeclaration,,<empty>
597464,UNKNOWN,240,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIgnore);",9,<empty>,,545,240,CPPASTProblemDeclaration,,<empty>
597465,UNKNOWN,241,,mach.ProcessCharacter(L'8');,9,<empty>,,546,241,CPPASTProblemDeclaration,,<empty>
597466,UNKNOWN,242,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIgnore);",9,<empty>,,547,242,CPPASTProblemDeclaration,,<empty>
597467,UNKNOWN,243,,mach.ProcessCharacter(L'J');,9,<empty>,,548,243,CPPASTProblemDeclaration,,<empty>
597468,UNKNOWN,244,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,549,244,CPPASTProblemDeclaration,,<empty>
597469,UNKNOWN,245,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,551,245,CPPASTProblemDeclaration,,<empty>
597470,UNKNOWN,246,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,552,246,CPPASTProblemDeclaration,,<empty>
597471,UNKNOWN,247,,mach.ProcessCharacter(L'[');,9,<empty>,,553,247,CPPASTProblemDeclaration,,<empty>
597472,UNKNOWN,248,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,554,248,CPPASTProblemDeclaration,,<empty>
597473,UNKNOWN,249,,mach.ProcessCharacter(L'4');,9,<empty>,,555,249,CPPASTProblemDeclaration,,<empty>
597474,UNKNOWN,250,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,556,250,CPPASTProblemDeclaration,,<empty>
597475,UNKNOWN,251,,mach.ProcessCharacter(L'#');,9,<empty>,,557,251,CPPASTProblemDeclaration,,<empty>
597476,UNKNOWN,252,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIntermediate);",9,<empty>,,558,252,CPPASTProblemDeclaration,,<empty>
597477,UNKNOWN,253,,mach.ProcessCharacter(L':');,9,<empty>,,559,253,CPPASTProblemDeclaration,,<empty>
597478,UNKNOWN,254,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIgnore);",9,<empty>,,560,254,CPPASTProblemDeclaration,,<empty>
597479,UNKNOWN,255,,mach.ProcessCharacter(L'8');,9,<empty>,,561,255,CPPASTProblemDeclaration,,<empty>
597480,UNKNOWN,256,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiIgnore);",9,<empty>,,562,256,CPPASTProblemDeclaration,,<empty>
597481,UNKNOWN,257,,mach.ProcessCharacter(L'J');,9,<empty>,,563,257,CPPASTProblemDeclaration,,<empty>
597482,UNKNOWN,258,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,564,258,CPPASTProblemDeclaration,,<empty>
597483,UNKNOWN,259,,},5,<empty>,,565,259,CPPASTProblemDeclaration,,<empty>
597484,UNKNOWN,260,,"TEST_METHOD(TestC1Osc)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,567,260,CPPASTProblemDeclaration,,<empty>
597499,UNKNOWN,263,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,574,263,CPPASTProblemDeclaration,,<empty>
597500,UNKNOWN,264,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,576,264,CPPASTProblemDeclaration,,<empty>
597501,UNKNOWN,265,,mach.ProcessCharacter(L'\x9d');,9,<empty>,,577,265,CPPASTProblemDeclaration,,<empty>
597502,UNKNOWN,266,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,578,266,CPPASTProblemDeclaration,,<empty>
597503,UNKNOWN,267,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,579,267,CPPASTProblemDeclaration,,<empty>
597504,UNKNOWN,268,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,580,268,CPPASTProblemDeclaration,,<empty>
597505,UNKNOWN,269,,},5,<empty>,,581,269,CPPASTProblemDeclaration,,<empty>
597506,UNKNOWN,270,,"TEST_METHOD(TestOscStringSimple)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,583,270,CPPASTProblemDeclaration,,<empty>
597521,UNKNOWN,273,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,589,273,CPPASTProblemDeclaration,,<empty>
597522,UNKNOWN,274,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,590,274,CPPASTProblemDeclaration,,<empty>
597523,UNKNOWN,275,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,591,275,CPPASTProblemDeclaration,,<empty>
597524,UNKNOWN,276,,mach.ProcessCharacter(L']');,9,<empty>,,592,276,CPPASTProblemDeclaration,,<empty>
597525,UNKNOWN,277,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,593,277,CPPASTProblemDeclaration,,<empty>
597526,UNKNOWN,278,,mach.ProcessCharacter(L'0');,9,<empty>,,594,278,CPPASTProblemDeclaration,,<empty>
597527,UNKNOWN,279,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,595,279,CPPASTProblemDeclaration,,<empty>
597528,UNKNOWN,280,,mach.ProcessCharacter(L';');,9,<empty>,,596,280,CPPASTProblemDeclaration,,<empty>
597529,UNKNOWN,281,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,597,281,CPPASTProblemDeclaration,,<empty>
597530,UNKNOWN,282,,mach.ProcessCharacter(L's');,9,<empty>,,598,282,CPPASTProblemDeclaration,,<empty>
597531,UNKNOWN,283,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,599,283,CPPASTProblemDeclaration,,<empty>
597532,UNKNOWN,284,,mach.ProcessCharacter(L'o');,9,<empty>,,600,284,CPPASTProblemDeclaration,,<empty>
597533,UNKNOWN,285,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,601,285,CPPASTProblemDeclaration,,<empty>
597534,UNKNOWN,286,,mach.ProcessCharacter(L'm');,9,<empty>,,602,286,CPPASTProblemDeclaration,,<empty>
597535,UNKNOWN,287,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,603,287,CPPASTProblemDeclaration,,<empty>
597536,UNKNOWN,288,,mach.ProcessCharacter(L'e');,9,<empty>,,604,288,CPPASTProblemDeclaration,,<empty>
597537,UNKNOWN,289,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,605,289,CPPASTProblemDeclaration,,<empty>
597538,UNKNOWN,290,,mach.ProcessCharacter(L' ');,9,<empty>,,606,290,CPPASTProblemDeclaration,,<empty>
597539,UNKNOWN,291,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,607,291,CPPASTProblemDeclaration,,<empty>
597540,UNKNOWN,292,,mach.ProcessCharacter(L't');,9,<empty>,,608,292,CPPASTProblemDeclaration,,<empty>
597541,UNKNOWN,293,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,609,293,CPPASTProblemDeclaration,,<empty>
597542,UNKNOWN,294,,mach.ProcessCharacter(L'e');,9,<empty>,,610,294,CPPASTProblemDeclaration,,<empty>
597543,UNKNOWN,295,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,611,295,CPPASTProblemDeclaration,,<empty>
597544,UNKNOWN,296,,mach.ProcessCharacter(L'x');,9,<empty>,,612,296,CPPASTProblemDeclaration,,<empty>
597545,UNKNOWN,297,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,613,297,CPPASTProblemDeclaration,,<empty>
597546,UNKNOWN,298,,mach.ProcessCharacter(L't');,9,<empty>,,614,298,CPPASTProblemDeclaration,,<empty>
597547,UNKNOWN,299,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,615,299,CPPASTProblemDeclaration,,<empty>
597548,UNKNOWN,300,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,616,300,CPPASTProblemDeclaration,,<empty>
597549,UNKNOWN,301,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,617,301,CPPASTProblemDeclaration,,<empty>
597550,UNKNOWN,302,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,619,302,CPPASTProblemDeclaration,,<empty>
597551,UNKNOWN,303,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,620,303,CPPASTProblemDeclaration,,<empty>
597552,UNKNOWN,304,,mach.ProcessCharacter(L']');,9,<empty>,,621,304,CPPASTProblemDeclaration,,<empty>
597553,UNKNOWN,305,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,622,305,CPPASTProblemDeclaration,,<empty>
597554,UNKNOWN,306,,mach.ProcessCharacter(L'0');,9,<empty>,,623,306,CPPASTProblemDeclaration,,<empty>
597555,UNKNOWN,307,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,624,307,CPPASTProblemDeclaration,,<empty>
597556,UNKNOWN,308,,mach.ProcessCharacter(L';');,9,<empty>,,625,308,CPPASTProblemDeclaration,,<empty>
597557,UNKNOWN,309,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,626,309,CPPASTProblemDeclaration,,<empty>
597558,UNKNOWN,310,,mach.ProcessCharacter(L's');,9,<empty>,,627,310,CPPASTProblemDeclaration,,<empty>
597559,UNKNOWN,311,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,628,311,CPPASTProblemDeclaration,,<empty>
597560,UNKNOWN,312,,mach.ProcessCharacter(L'o');,9,<empty>,,629,312,CPPASTProblemDeclaration,,<empty>
597561,UNKNOWN,313,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,630,313,CPPASTProblemDeclaration,,<empty>
597562,UNKNOWN,314,,mach.ProcessCharacter(L'm');,9,<empty>,,631,314,CPPASTProblemDeclaration,,<empty>
597563,UNKNOWN,315,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,632,315,CPPASTProblemDeclaration,,<empty>
597564,UNKNOWN,316,,mach.ProcessCharacter(L'e');,9,<empty>,,633,316,CPPASTProblemDeclaration,,<empty>
597565,UNKNOWN,317,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,634,317,CPPASTProblemDeclaration,,<empty>
597566,UNKNOWN,318,,mach.ProcessCharacter(L' ');,9,<empty>,,635,318,CPPASTProblemDeclaration,,<empty>
597567,UNKNOWN,319,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,636,319,CPPASTProblemDeclaration,,<empty>
597568,UNKNOWN,320,,mach.ProcessCharacter(L't');,9,<empty>,,637,320,CPPASTProblemDeclaration,,<empty>
597569,UNKNOWN,321,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,638,321,CPPASTProblemDeclaration,,<empty>
597570,UNKNOWN,322,,mach.ProcessCharacter(L'e');,9,<empty>,,639,322,CPPASTProblemDeclaration,,<empty>
597571,UNKNOWN,323,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,640,323,CPPASTProblemDeclaration,,<empty>
597572,UNKNOWN,324,,mach.ProcessCharacter(L'x');,9,<empty>,,641,324,CPPASTProblemDeclaration,,<empty>
597573,UNKNOWN,325,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,642,325,CPPASTProblemDeclaration,,<empty>
597574,UNKNOWN,326,,mach.ProcessCharacter(L't');,9,<empty>,,643,326,CPPASTProblemDeclaration,,<empty>
597575,UNKNOWN,327,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,644,327,CPPASTProblemDeclaration,,<empty>
597576,UNKNOWN,328,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,645,328,CPPASTProblemDeclaration,,<empty>
597577,UNKNOWN,329,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscTermination);",9,<empty>,,646,329,CPPASTProblemDeclaration,,<empty>
597578,UNKNOWN,330,,mach.ProcessCharacter(L'\\');,9,<empty>,,647,330,CPPASTProblemDeclaration,,<empty>
597579,UNKNOWN,331,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,648,331,CPPASTProblemDeclaration,,<empty>
597580,UNKNOWN,332,,},5,<empty>,,649,332,CPPASTProblemDeclaration,,<empty>
597581,UNKNOWN,333,,"TEST_METHOD(TestLongOscString)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,651,333,CPPASTProblemDeclaration,,<empty>
597596,UNKNOWN,336,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,657,336,CPPASTProblemDeclaration,,<empty>
597597,UNKNOWN,337,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,658,337,CPPASTProblemDeclaration,,<empty>
597598,UNKNOWN,338,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,659,338,CPPASTProblemDeclaration,,<empty>
597599,UNKNOWN,339,,mach.ProcessCharacter(L']');,9,<empty>,,660,339,CPPASTProblemDeclaration,,<empty>
597600,UNKNOWN,340,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,661,340,CPPASTProblemDeclaration,,<empty>
597601,UNKNOWN,341,,mach.ProcessCharacter(L'0');,9,<empty>,,662,341,CPPASTProblemDeclaration,,<empty>
597602,UNKNOWN,342,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,663,342,CPPASTProblemDeclaration,,<empty>
597603,UNKNOWN,343,,mach.ProcessCharacter(L';');,9,<empty>,,664,343,CPPASTProblemDeclaration,,<empty>
597604,UNKNOWN,344,,for (auto i = 0;,9,<empty>,,665,344,CPPASTProblemDeclaration,,<empty>
597605,UNKNOWN,345,,i < 260u;,26,<empty>,,665,345,CPPASTProblemDeclaration,,<empty>
597606,UNKNOWN,346,,"i++) // The buffer is only 256 long, so any longer value should work :P
        {
            mach.ProcessCharacter(L's');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);
        }",36,<empty>,,665,346,CPPASTProblemDeclaration,,<empty>
597607,UNKNOWN,347,,"VERIFY_ARE_EQUAL(mach._oscString.size(), 260u);",9,<empty>,,670,347,CPPASTProblemDeclaration,,<empty>
597608,UNKNOWN,348,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,671,348,CPPASTProblemDeclaration,,<empty>
597609,UNKNOWN,349,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,672,349,CPPASTProblemDeclaration,,<empty>
597610,UNKNOWN,350,,},5,<empty>,,673,350,CPPASTProblemDeclaration,,<empty>
597611,UNKNOWN,351,,"TEST_METHOD(NormalTestOscParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,675,351,CPPASTProblemDeclaration,,<empty>
597626,UNKNOWN,354,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,681,354,CPPASTProblemDeclaration,,<empty>
597627,UNKNOWN,355,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,682,355,CPPASTProblemDeclaration,,<empty>
597628,UNKNOWN,356,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,683,356,CPPASTProblemDeclaration,,<empty>
597629,UNKNOWN,357,,mach.ProcessCharacter(L']');,9,<empty>,,684,357,CPPASTProblemDeclaration,,<empty>
597630,UNKNOWN,358,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,685,358,CPPASTProblemDeclaration,,<empty>
597631,UNKNOWN,359,,for (auto i = 0;,9,<empty>,,686,359,CPPASTProblemDeclaration,,<empty>
597632,UNKNOWN,360,,i < 5;,26,<empty>,,686,360,CPPASTProblemDeclaration,,<empty>
597633,UNKNOWN,361,,"i++) // We're only expecting to be able to keep 5 digits max
        {
            mach.ProcessCharacter((wchar_t)(L'1' + i));
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);
        }",33,<empty>,,686,361,CPPASTProblemDeclaration,,<empty>
597634,UNKNOWN,362,,"VERIFY_ARE_EQUAL(mach._oscParameter, 12345);",9,<empty>,,691,362,CPPASTProblemDeclaration,,<empty>
597635,UNKNOWN,363,,mach.ProcessCharacter(L';');,9,<empty>,,692,363,CPPASTProblemDeclaration,,<empty>
597636,UNKNOWN,364,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,693,364,CPPASTProblemDeclaration,,<empty>
597637,UNKNOWN,365,,mach.ProcessCharacter(L's');,9,<empty>,,694,365,CPPASTProblemDeclaration,,<empty>
597638,UNKNOWN,366,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,695,366,CPPASTProblemDeclaration,,<empty>
597639,UNKNOWN,367,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,696,367,CPPASTProblemDeclaration,,<empty>
597640,UNKNOWN,368,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,697,368,CPPASTProblemDeclaration,,<empty>
597641,UNKNOWN,369,,},5,<empty>,,698,369,CPPASTProblemDeclaration,,<empty>
597642,UNKNOWN,370,,"TEST_METHOD(TestLeadingZeroOscParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,700,370,CPPASTProblemDeclaration,,<empty>
597657,UNKNOWN,373,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,706,373,CPPASTProblemDeclaration,,<empty>
597658,UNKNOWN,374,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,707,374,CPPASTProblemDeclaration,,<empty>
597659,UNKNOWN,375,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,708,375,CPPASTProblemDeclaration,,<empty>
597660,UNKNOWN,376,,mach.ProcessCharacter(L']');,9,<empty>,,709,376,CPPASTProblemDeclaration,,<empty>
597661,UNKNOWN,377,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,710,377,CPPASTProblemDeclaration,,<empty>
597662,UNKNOWN,378,,for (auto i = 0;,9,<empty>,,711,378,CPPASTProblemDeclaration,,<empty>
597663,UNKNOWN,379,,i < 50;,26,<empty>,,711,379,CPPASTProblemDeclaration,,<empty>
597664,UNKNOWN,380,,"i++) // Any number of leading zeros should be supported
        {
            mach.ProcessCharacter(L'0');
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);
        }",34,<empty>,,711,380,CPPASTProblemDeclaration,,<empty>
597665,UNKNOWN,381,,for (auto i = 0;,9,<empty>,,716,381,CPPASTProblemDeclaration,,<empty>
597666,UNKNOWN,382,,i < 5;,26,<empty>,,716,382,CPPASTProblemDeclaration,,<empty>
597667,UNKNOWN,383,,"i++) // We're only expecting to be able to keep 5 digits max
        {
            mach.ProcessCharacter((wchar_t)(L'1' + i));
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);
        }",33,<empty>,,716,383,CPPASTProblemDeclaration,,<empty>
597668,UNKNOWN,384,,"VERIFY_ARE_EQUAL(mach._oscParameter, 12345);",9,<empty>,,721,384,CPPASTProblemDeclaration,,<empty>
597669,UNKNOWN,385,,mach.ProcessCharacter(L';');,9,<empty>,,722,385,CPPASTProblemDeclaration,,<empty>
597670,UNKNOWN,386,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,723,386,CPPASTProblemDeclaration,,<empty>
597671,UNKNOWN,387,,mach.ProcessCharacter(L's');,9,<empty>,,724,387,CPPASTProblemDeclaration,,<empty>
597672,UNKNOWN,388,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,725,388,CPPASTProblemDeclaration,,<empty>
597673,UNKNOWN,389,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,726,389,CPPASTProblemDeclaration,,<empty>
597674,UNKNOWN,390,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,727,390,CPPASTProblemDeclaration,,<empty>
597675,UNKNOWN,391,,},5,<empty>,,728,391,CPPASTProblemDeclaration,,<empty>
597676,UNKNOWN,392,,"TEST_METHOD(TestLongOscParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,730,392,CPPASTProblemDeclaration,,<empty>
597691,UNKNOWN,395,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,736,395,CPPASTProblemDeclaration,,<empty>
597692,UNKNOWN,396,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,737,396,CPPASTProblemDeclaration,,<empty>
597693,UNKNOWN,397,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,738,397,CPPASTProblemDeclaration,,<empty>
597694,UNKNOWN,398,,mach.ProcessCharacter(L']');,9,<empty>,,739,398,CPPASTProblemDeclaration,,<empty>
597695,UNKNOWN,399,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,740,399,CPPASTProblemDeclaration,,<empty>
597724,UNKNOWN,404,,"for (auto& wch : sizeMaxStr)
        {
            mach.ProcessCharacter(wch);
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);
        }",9,<empty>,,743,404,CPPASTProblemDeclaration,,<empty>
597725,UNKNOWN,405,,"VERIFY_ARE_EQUAL(mach._oscParameter, MAX_PARAMETER_VALUE);",9,<empty>,,748,405,CPPASTProblemDeclaration,,<empty>
597726,UNKNOWN,406,,mach.ProcessCharacter(L';');,9,<empty>,,749,406,CPPASTProblemDeclaration,,<empty>
597727,UNKNOWN,407,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,750,407,CPPASTProblemDeclaration,,<empty>
597728,UNKNOWN,408,,mach.ProcessCharacter(L's');,9,<empty>,,751,408,CPPASTProblemDeclaration,,<empty>
597729,UNKNOWN,409,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,752,409,CPPASTProblemDeclaration,,<empty>
597730,UNKNOWN,410,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,753,410,CPPASTProblemDeclaration,,<empty>
597731,UNKNOWN,411,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,754,411,CPPASTProblemDeclaration,,<empty>
597732,UNKNOWN,412,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,756,412,CPPASTProblemDeclaration,,<empty>
597733,UNKNOWN,413,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,757,413,CPPASTProblemDeclaration,,<empty>
597734,UNKNOWN,414,,mach.ProcessCharacter(L']');,9,<empty>,,758,414,CPPASTProblemDeclaration,,<empty>
597735,UNKNOWN,415,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,759,415,CPPASTProblemDeclaration,,<empty>
597736,UNKNOWN,416,,"for (const auto& wch : sizeMaxStr)
        {
            mach.ProcessCharacter(wch);
            VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);
        }",9,<empty>,,760,416,CPPASTProblemDeclaration,,<empty>
597737,UNKNOWN,417,,"VERIFY_ARE_EQUAL(mach._oscParameter, MAX_PARAMETER_VALUE);",9,<empty>,,765,417,CPPASTProblemDeclaration,,<empty>
597738,UNKNOWN,418,,mach.ProcessCharacter(L';');,9,<empty>,,766,418,CPPASTProblemDeclaration,,<empty>
597739,UNKNOWN,419,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,767,419,CPPASTProblemDeclaration,,<empty>
597740,UNKNOWN,420,,mach.ProcessCharacter(L's');,9,<empty>,,768,420,CPPASTProblemDeclaration,,<empty>
597741,UNKNOWN,421,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,769,421,CPPASTProblemDeclaration,,<empty>
597742,UNKNOWN,422,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,770,422,CPPASTProblemDeclaration,,<empty>
597743,UNKNOWN,423,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,771,423,CPPASTProblemDeclaration,,<empty>
597744,UNKNOWN,424,,},5,<empty>,,772,424,CPPASTProblemDeclaration,,<empty>
597745,UNKNOWN,425,,"TEST_METHOD(TestOscStringInvalidTermination)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,774,425,CPPASTProblemDeclaration,,<empty>
597760,UNKNOWN,428,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,780,428,CPPASTProblemDeclaration,,<empty>
597761,UNKNOWN,429,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,781,429,CPPASTProblemDeclaration,,<empty>
597762,UNKNOWN,430,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,782,430,CPPASTProblemDeclaration,,<empty>
597763,UNKNOWN,431,,mach.ProcessCharacter(L']');,9,<empty>,,783,431,CPPASTProblemDeclaration,,<empty>
597764,UNKNOWN,432,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,784,432,CPPASTProblemDeclaration,,<empty>
597765,UNKNOWN,433,,mach.ProcessCharacter(L'1');,9,<empty>,,785,433,CPPASTProblemDeclaration,,<empty>
597766,UNKNOWN,434,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,786,434,CPPASTProblemDeclaration,,<empty>
597767,UNKNOWN,435,,mach.ProcessCharacter(L';');,9,<empty>,,787,435,CPPASTProblemDeclaration,,<empty>
597768,UNKNOWN,436,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,788,436,CPPASTProblemDeclaration,,<empty>
597769,UNKNOWN,437,,mach.ProcessCharacter(L's');,9,<empty>,,789,437,CPPASTProblemDeclaration,,<empty>
597770,UNKNOWN,438,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,790,438,CPPASTProblemDeclaration,,<empty>
597771,UNKNOWN,439,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,791,439,CPPASTProblemDeclaration,,<empty>
597772,UNKNOWN,440,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscTermination);",9,<empty>,,792,440,CPPASTProblemDeclaration,,<empty>
597773,UNKNOWN,441,,mach.ProcessCharacter(L'[');,9,<empty>,,793,441,CPPASTProblemDeclaration,,<empty>
597774,UNKNOWN,442,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,794,442,CPPASTProblemDeclaration,,<empty>
597775,UNKNOWN,443,,mach.ProcessCharacter(L'4');,9,<empty>,,795,443,CPPASTProblemDeclaration,,<empty>
597776,UNKNOWN,444,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,796,444,CPPASTProblemDeclaration,,<empty>
597777,UNKNOWN,445,,mach.ProcessCharacter(L';');,9,<empty>,,797,445,CPPASTProblemDeclaration,,<empty>
597778,UNKNOWN,446,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,798,446,CPPASTProblemDeclaration,,<empty>
597779,UNKNOWN,447,,mach.ProcessCharacter(L'm');,9,<empty>,,799,447,CPPASTProblemDeclaration,,<empty>
597780,UNKNOWN,448,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,800,448,CPPASTProblemDeclaration,,<empty>
597781,UNKNOWN,449,,},5,<empty>,,801,449,CPPASTProblemDeclaration,,<empty>
597782,UNKNOWN,450,,"TEST_METHOD(TestDcsEntry)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,803,450,CPPASTProblemDeclaration,,<empty>
597797,UNKNOWN,453,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,809,453,CPPASTProblemDeclaration,,<empty>
597798,UNKNOWN,454,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,810,454,CPPASTProblemDeclaration,,<empty>
597799,UNKNOWN,455,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,811,455,CPPASTProblemDeclaration,,<empty>
597800,UNKNOWN,456,,mach.ProcessCharacter(L'P');,9,<empty>,,812,456,CPPASTProblemDeclaration,,<empty>
597801,UNKNOWN,457,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,813,457,CPPASTProblemDeclaration,,<empty>
597802,UNKNOWN,458,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,814,458,CPPASTProblemDeclaration,,<empty>
597803,UNKNOWN,459,,mach.ProcessCharacter(L'\\');,9,<empty>,,815,459,CPPASTProblemDeclaration,,<empty>
597804,UNKNOWN,460,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,816,460,CPPASTProblemDeclaration,,<empty>
597805,UNKNOWN,461,,},5,<empty>,,817,461,CPPASTProblemDeclaration,,<empty>
597806,UNKNOWN,462,,"TEST_METHOD(TestC1DcsEntry)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,819,462,CPPASTProblemDeclaration,,<empty>
597821,UNKNOWN,465,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,826,465,CPPASTProblemDeclaration,,<empty>
597822,UNKNOWN,466,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,828,466,CPPASTProblemDeclaration,,<empty>
597823,UNKNOWN,467,,mach.ProcessCharacter(L'\x90');,9,<empty>,,829,467,CPPASTProblemDeclaration,,<empty>
597824,UNKNOWN,468,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,830,468,CPPASTProblemDeclaration,,<empty>
597825,UNKNOWN,469,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,831,469,CPPASTProblemDeclaration,,<empty>
597826,UNKNOWN,470,,mach.ProcessCharacter(L'\\');,9,<empty>,,832,470,CPPASTProblemDeclaration,,<empty>
597827,UNKNOWN,471,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,833,471,CPPASTProblemDeclaration,,<empty>
597828,UNKNOWN,472,,},5,<empty>,,834,472,CPPASTProblemDeclaration,,<empty>
597829,UNKNOWN,473,,"TEST_METHOD(TestDcsImmediate)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,836,473,CPPASTProblemDeclaration,,<empty>
597844,UNKNOWN,476,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,842,476,CPPASTProblemDeclaration,,<empty>
597845,UNKNOWN,477,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,843,477,CPPASTProblemDeclaration,,<empty>
597846,UNKNOWN,478,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,844,478,CPPASTProblemDeclaration,,<empty>
597847,UNKNOWN,479,,mach.ProcessCharacter(L'P');,9,<empty>,,845,479,CPPASTProblemDeclaration,,<empty>
597848,UNKNOWN,480,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,846,480,CPPASTProblemDeclaration,,<empty>
597849,UNKNOWN,481,,mach.ProcessCharacter(L' ');,9,<empty>,,847,481,CPPASTProblemDeclaration,,<empty>
597850,UNKNOWN,482,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIntermediate);",9,<empty>,,848,482,CPPASTProblemDeclaration,,<empty>
597851,UNKNOWN,483,,mach.ProcessCharacter(L'#');,9,<empty>,,849,483,CPPASTProblemDeclaration,,<empty>
597852,UNKNOWN,484,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIntermediate);",9,<empty>,,850,484,CPPASTProblemDeclaration,,<empty>
597853,UNKNOWN,485,,mach.ProcessCharacter(L'%');,9,<empty>,,851,485,CPPASTProblemDeclaration,,<empty>
597854,UNKNOWN,486,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIntermediate);",9,<empty>,,852,486,CPPASTProblemDeclaration,,<empty>
597855,UNKNOWN,487,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,853,487,CPPASTProblemDeclaration,,<empty>
597856,UNKNOWN,488,,mach.ProcessCharacter(L'\\');,9,<empty>,,854,488,CPPASTProblemDeclaration,,<empty>
597857,UNKNOWN,489,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,855,489,CPPASTProblemDeclaration,,<empty>
597858,UNKNOWN,490,,},5,<empty>,,856,490,CPPASTProblemDeclaration,,<empty>
597859,UNKNOWN,491,,"TEST_METHOD(TestDcsIgnore)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,858,491,CPPASTProblemDeclaration,,<empty>
597874,UNKNOWN,494,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,864,494,CPPASTProblemDeclaration,,<empty>
597875,UNKNOWN,495,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,865,495,CPPASTProblemDeclaration,,<empty>
597876,UNKNOWN,496,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,866,496,CPPASTProblemDeclaration,,<empty>
597877,UNKNOWN,497,,mach.ProcessCharacter(L'P');,9,<empty>,,867,497,CPPASTProblemDeclaration,,<empty>
597878,UNKNOWN,498,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,868,498,CPPASTProblemDeclaration,,<empty>
597879,UNKNOWN,499,,mach.ProcessCharacter(L':');,9,<empty>,,869,499,CPPASTProblemDeclaration,,<empty>
597880,UNKNOWN,500,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,870,500,CPPASTProblemDeclaration,,<empty>
597881,UNKNOWN,501,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,871,501,CPPASTProblemDeclaration,,<empty>
597882,UNKNOWN,502,,mach.ProcessCharacter(L'\\');,9,<empty>,,872,502,CPPASTProblemDeclaration,,<empty>
597883,UNKNOWN,503,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,873,503,CPPASTProblemDeclaration,,<empty>
597884,UNKNOWN,504,,},5,<empty>,,874,504,CPPASTProblemDeclaration,,<empty>
597885,UNKNOWN,505,,"TEST_METHOD(TestDcsParam)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,876,505,CPPASTProblemDeclaration,,<empty>
597900,UNKNOWN,508,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,882,508,CPPASTProblemDeclaration,,<empty>
597901,UNKNOWN,509,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,883,509,CPPASTProblemDeclaration,,<empty>
597902,UNKNOWN,510,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,884,510,CPPASTProblemDeclaration,,<empty>
597903,UNKNOWN,511,,mach.ProcessCharacter(L'P');,9,<empty>,,885,511,CPPASTProblemDeclaration,,<empty>
597904,UNKNOWN,512,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,886,512,CPPASTProblemDeclaration,,<empty>
597905,UNKNOWN,513,,mach.ProcessCharacter(L';');,9,<empty>,,887,513,CPPASTProblemDeclaration,,<empty>
597906,UNKNOWN,514,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,888,514,CPPASTProblemDeclaration,,<empty>
597907,UNKNOWN,515,,mach.ProcessCharacter(L'3');,9,<empty>,,889,515,CPPASTProblemDeclaration,,<empty>
597908,UNKNOWN,516,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,890,516,CPPASTProblemDeclaration,,<empty>
597909,UNKNOWN,517,,mach.ProcessCharacter(L'2');,9,<empty>,,891,517,CPPASTProblemDeclaration,,<empty>
597910,UNKNOWN,518,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,892,518,CPPASTProblemDeclaration,,<empty>
597911,UNKNOWN,519,,mach.ProcessCharacter(L'4');,9,<empty>,,893,519,CPPASTProblemDeclaration,,<empty>
597912,UNKNOWN,520,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,894,520,CPPASTProblemDeclaration,,<empty>
597913,UNKNOWN,521,,mach.ProcessCharacter(L';');,9,<empty>,,895,521,CPPASTProblemDeclaration,,<empty>
597914,UNKNOWN,522,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,896,522,CPPASTProblemDeclaration,,<empty>
597915,UNKNOWN,523,,mach.ProcessCharacter(L';');,9,<empty>,,897,523,CPPASTProblemDeclaration,,<empty>
597916,UNKNOWN,524,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,898,524,CPPASTProblemDeclaration,,<empty>
597917,UNKNOWN,525,,mach.ProcessCharacter(L'8');,9,<empty>,,899,525,CPPASTProblemDeclaration,,<empty>
597918,UNKNOWN,526,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsParam);",9,<empty>,,900,526,CPPASTProblemDeclaration,,<empty>
597919,UNKNOWN,527,,"VERIFY_ARE_EQUAL(mach._parameters.size(), 4u);",9,<empty>,,902,527,CPPASTProblemDeclaration,,<empty>
597920,UNKNOWN,528,,VERIFY_IS_FALSE(mach._parameters.at(0).has_value());,9,<empty>,,903,528,CPPASTProblemDeclaration,,<empty>
597921,UNKNOWN,529,,"VERIFY_ARE_EQUAL(mach._parameters.at(1), 324);",9,<empty>,,904,529,CPPASTProblemDeclaration,,<empty>
597922,UNKNOWN,530,,VERIFY_IS_FALSE(mach._parameters.at(2).has_value());,9,<empty>,,905,530,CPPASTProblemDeclaration,,<empty>
597923,UNKNOWN,531,,"VERIFY_ARE_EQUAL(mach._parameters.at(3), 8);",9,<empty>,,906,531,CPPASTProblemDeclaration,,<empty>
597924,UNKNOWN,532,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,908,532,CPPASTProblemDeclaration,,<empty>
597925,UNKNOWN,533,,mach.ProcessCharacter(L'\\');,9,<empty>,,909,533,CPPASTProblemDeclaration,,<empty>
597926,UNKNOWN,534,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,910,534,CPPASTProblemDeclaration,,<empty>
597927,UNKNOWN,535,,},5,<empty>,,911,535,CPPASTProblemDeclaration,,<empty>
597928,UNKNOWN,536,,"TEST_METHOD(TestDcsIntermediateAndPassThrough)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,913,536,CPPASTProblemDeclaration,,<empty>
597943,UNKNOWN,539,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,919,539,CPPASTProblemDeclaration,,<empty>
597944,UNKNOWN,540,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,920,540,CPPASTProblemDeclaration,,<empty>
597945,UNKNOWN,541,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,921,541,CPPASTProblemDeclaration,,<empty>
597946,UNKNOWN,542,,mach.ProcessCharacter(L'P');,9,<empty>,,922,542,CPPASTProblemDeclaration,,<empty>
597947,UNKNOWN,543,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,923,543,CPPASTProblemDeclaration,,<empty>
597948,UNKNOWN,544,,mach.ProcessCharacter(L' ');,9,<empty>,,924,544,CPPASTProblemDeclaration,,<empty>
597949,UNKNOWN,545,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIntermediate);",9,<empty>,,925,545,CPPASTProblemDeclaration,,<empty>
597950,UNKNOWN,546,,mach.ProcessCharacter(L'x');,9,<empty>,,926,546,CPPASTProblemDeclaration,,<empty>
597951,UNKNOWN,547,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,928,547,CPPASTProblemDeclaration,,<empty>
597952,UNKNOWN,548,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,929,548,CPPASTProblemDeclaration,,<empty>
597953,UNKNOWN,549,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,930,549,CPPASTProblemDeclaration,,<empty>
597954,UNKNOWN,550,,mach.ProcessCharacter(L'\\');,9,<empty>,,931,550,CPPASTProblemDeclaration,,<empty>
597955,UNKNOWN,551,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,932,551,CPPASTProblemDeclaration,,<empty>
597956,UNKNOWN,552,,},5,<empty>,,933,552,CPPASTProblemDeclaration,,<empty>
597957,UNKNOWN,553,,"TEST_METHOD(TestDcsLongStringPassThrough)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,935,553,CPPASTProblemDeclaration,,<empty>
597972,UNKNOWN,556,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,941,556,CPPASTProblemDeclaration,,<empty>
597973,UNKNOWN,557,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,942,557,CPPASTProblemDeclaration,,<empty>
597974,UNKNOWN,558,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,943,558,CPPASTProblemDeclaration,,<empty>
597975,UNKNOWN,559,,mach.ProcessCharacter(L'P');,9,<empty>,,944,559,CPPASTProblemDeclaration,,<empty>
597976,UNKNOWN,560,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,945,560,CPPASTProblemDeclaration,,<empty>
597977,UNKNOWN,561,,mach.ProcessCharacter(L'q');,9,<empty>,,946,561,CPPASTProblemDeclaration,,<empty>
597978,UNKNOWN,562,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,948,562,CPPASTProblemDeclaration,,<empty>
597979,UNKNOWN,563,,mach.ProcessCharacter(L'#');,9,<empty>,,949,563,CPPASTProblemDeclaration,,<empty>
597980,UNKNOWN,564,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,950,564,CPPASTProblemDeclaration,,<empty>
597981,UNKNOWN,565,,mach.ProcessCharacter(L'1');,9,<empty>,,951,565,CPPASTProblemDeclaration,,<empty>
597982,UNKNOWN,566,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,952,566,CPPASTProblemDeclaration,,<empty>
597983,UNKNOWN,567,,mach.ProcessCharacter(L'N');,9,<empty>,,953,567,CPPASTProblemDeclaration,,<empty>
597984,UNKNOWN,568,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,954,568,CPPASTProblemDeclaration,,<empty>
597985,UNKNOWN,569,,mach.ProcessCharacter(L'N');,9,<empty>,,955,569,CPPASTProblemDeclaration,,<empty>
597986,UNKNOWN,570,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,956,570,CPPASTProblemDeclaration,,<empty>
597987,UNKNOWN,571,,mach.ProcessCharacter(L'N');,9,<empty>,,957,571,CPPASTProblemDeclaration,,<empty>
597988,UNKNOWN,572,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,958,572,CPPASTProblemDeclaration,,<empty>
597989,UNKNOWN,573,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,959,573,CPPASTProblemDeclaration,,<empty>
597990,UNKNOWN,574,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,960,574,CPPASTProblemDeclaration,,<empty>
597991,UNKNOWN,575,,mach.ProcessCharacter(L'\\');,9,<empty>,,961,575,CPPASTProblemDeclaration,,<empty>
597992,UNKNOWN,576,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,962,576,CPPASTProblemDeclaration,,<empty>
597993,UNKNOWN,577,,},5,<empty>,,963,577,CPPASTProblemDeclaration,,<empty>
597994,UNKNOWN,578,,"TEST_METHOD(TestDcsInvalidTermination)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,965,578,CPPASTProblemDeclaration,,<empty>
598009,UNKNOWN,581,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,971,581,CPPASTProblemDeclaration,,<empty>
598010,UNKNOWN,582,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,972,582,CPPASTProblemDeclaration,,<empty>
598011,UNKNOWN,583,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,973,583,CPPASTProblemDeclaration,,<empty>
598012,UNKNOWN,584,,mach.ProcessCharacter(L'P');,9,<empty>,,974,584,CPPASTProblemDeclaration,,<empty>
598013,UNKNOWN,585,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,975,585,CPPASTProblemDeclaration,,<empty>
598014,UNKNOWN,586,,mach.ProcessCharacter(L'q');,9,<empty>,,976,586,CPPASTProblemDeclaration,,<empty>
598015,UNKNOWN,587,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,977,587,CPPASTProblemDeclaration,,<empty>
598016,UNKNOWN,588,,mach.ProcessCharacter(L'#');,9,<empty>,,978,588,CPPASTProblemDeclaration,,<empty>
598017,UNKNOWN,589,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,979,589,CPPASTProblemDeclaration,,<empty>
598018,UNKNOWN,590,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,980,590,CPPASTProblemDeclaration,,<empty>
598019,UNKNOWN,591,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,981,591,CPPASTProblemDeclaration,,<empty>
598020,UNKNOWN,592,,mach.ProcessCharacter(L'[');,9,<empty>,,982,592,CPPASTProblemDeclaration,,<empty>
598021,UNKNOWN,593,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiEntry);",9,<empty>,,983,593,CPPASTProblemDeclaration,,<empty>
598022,UNKNOWN,594,,mach.ProcessCharacter(L'4');,9,<empty>,,984,594,CPPASTProblemDeclaration,,<empty>
598023,UNKNOWN,595,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,985,595,CPPASTProblemDeclaration,,<empty>
598024,UNKNOWN,596,,mach.ProcessCharacter(L';');,9,<empty>,,986,596,CPPASTProblemDeclaration,,<empty>
598025,UNKNOWN,597,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::CsiParam);",9,<empty>,,987,597,CPPASTProblemDeclaration,,<empty>
598026,UNKNOWN,598,,mach.ProcessCharacter(L'm');,9,<empty>,,988,598,CPPASTProblemDeclaration,,<empty>
598027,UNKNOWN,599,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,989,599,CPPASTProblemDeclaration,,<empty>
598028,UNKNOWN,600,,},5,<empty>,,990,600,CPPASTProblemDeclaration,,<empty>
598029,UNKNOWN,601,,"TEST_METHOD(TestSosPmApcString)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,992,601,CPPASTProblemDeclaration,,<empty>
598044,UNKNOWN,604,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,998,604,CPPASTProblemDeclaration,,<empty>
598045,UNKNOWN,605,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,999,605,CPPASTProblemDeclaration,,<empty>
598046,UNKNOWN,606,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1000,606,CPPASTProblemDeclaration,,<empty>
598047,UNKNOWN,607,,mach.ProcessCharacter(L'X');,9,<empty>,,1001,607,CPPASTProblemDeclaration,,<empty>
598048,UNKNOWN,608,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1002,608,CPPASTProblemDeclaration,,<empty>
598049,UNKNOWN,609,,mach.ProcessCharacter(L'1');,9,<empty>,,1003,609,CPPASTProblemDeclaration,,<empty>
598050,UNKNOWN,610,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1004,610,CPPASTProblemDeclaration,,<empty>
598051,UNKNOWN,611,,mach.ProcessCharacter(L'2');,9,<empty>,,1005,611,CPPASTProblemDeclaration,,<empty>
598052,UNKNOWN,612,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1006,612,CPPASTProblemDeclaration,,<empty>
598053,UNKNOWN,613,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1007,613,CPPASTProblemDeclaration,,<empty>
598054,UNKNOWN,614,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1008,614,CPPASTProblemDeclaration,,<empty>
598055,UNKNOWN,615,,mach.ProcessCharacter(L'\\');,9,<empty>,,1009,615,CPPASTProblemDeclaration,,<empty>
598056,UNKNOWN,616,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1010,616,CPPASTProblemDeclaration,,<empty>
598057,UNKNOWN,617,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1012,617,CPPASTProblemDeclaration,,<empty>
598058,UNKNOWN,618,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1013,618,CPPASTProblemDeclaration,,<empty>
598059,UNKNOWN,619,,mach.ProcessCharacter(L'^');,9,<empty>,,1014,619,CPPASTProblemDeclaration,,<empty>
598060,UNKNOWN,620,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1015,620,CPPASTProblemDeclaration,,<empty>
598061,UNKNOWN,621,,mach.ProcessCharacter(L'3');,9,<empty>,,1016,621,CPPASTProblemDeclaration,,<empty>
598062,UNKNOWN,622,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1017,622,CPPASTProblemDeclaration,,<empty>
598063,UNKNOWN,623,,mach.ProcessCharacter(L'4');,9,<empty>,,1018,623,CPPASTProblemDeclaration,,<empty>
598064,UNKNOWN,624,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1019,624,CPPASTProblemDeclaration,,<empty>
598065,UNKNOWN,625,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1020,625,CPPASTProblemDeclaration,,<empty>
598066,UNKNOWN,626,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1021,626,CPPASTProblemDeclaration,,<empty>
598067,UNKNOWN,627,,mach.ProcessCharacter(L'\\');,9,<empty>,,1022,627,CPPASTProblemDeclaration,,<empty>
598068,UNKNOWN,628,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1023,628,CPPASTProblemDeclaration,,<empty>
598069,UNKNOWN,629,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1025,629,CPPASTProblemDeclaration,,<empty>
598070,UNKNOWN,630,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1026,630,CPPASTProblemDeclaration,,<empty>
598071,UNKNOWN,631,,mach.ProcessCharacter(L'_');,9,<empty>,,1027,631,CPPASTProblemDeclaration,,<empty>
598072,UNKNOWN,632,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1028,632,CPPASTProblemDeclaration,,<empty>
598073,UNKNOWN,633,,mach.ProcessCharacter(L'5');,9,<empty>,,1029,633,CPPASTProblemDeclaration,,<empty>
598074,UNKNOWN,634,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1030,634,CPPASTProblemDeclaration,,<empty>
598075,UNKNOWN,635,,mach.ProcessCharacter(L'6');,9,<empty>,,1031,635,CPPASTProblemDeclaration,,<empty>
598076,UNKNOWN,636,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1032,636,CPPASTProblemDeclaration,,<empty>
598077,UNKNOWN,637,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1033,637,CPPASTProblemDeclaration,,<empty>
598078,UNKNOWN,638,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1034,638,CPPASTProblemDeclaration,,<empty>
598079,UNKNOWN,639,,mach.ProcessCharacter(L'\\');,9,<empty>,,1035,639,CPPASTProblemDeclaration,,<empty>
598080,UNKNOWN,640,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1036,640,CPPASTProblemDeclaration,,<empty>
598081,UNKNOWN,641,,},5,<empty>,,1037,641,CPPASTProblemDeclaration,,<empty>
598082,UNKNOWN,642,,"TEST_METHOD(TestC1StringTerminator)
    {
        auto dispatch = std::make_unique<DummyDispatch>();",5,<empty>,,1039,642,CPPASTProblemDeclaration,,<empty>
598097,UNKNOWN,645,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,1046,645,CPPASTProblemDeclaration,,<empty>
598098,UNKNOWN,646,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1049,646,CPPASTProblemDeclaration,,<empty>
598099,UNKNOWN,647,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1050,647,CPPASTProblemDeclaration,,<empty>
598100,UNKNOWN,648,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1051,648,CPPASTProblemDeclaration,,<empty>
598101,UNKNOWN,649,,mach.ProcessCharacter(L']');,9,<empty>,,1052,649,CPPASTProblemDeclaration,,<empty>
598102,UNKNOWN,650,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,1053,650,CPPASTProblemDeclaration,,<empty>
598103,UNKNOWN,651,,mach.ProcessCharacter(L'1');,9,<empty>,,1054,651,CPPASTProblemDeclaration,,<empty>
598104,UNKNOWN,652,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscParam);",9,<empty>,,1055,652,CPPASTProblemDeclaration,,<empty>
598105,UNKNOWN,653,,mach.ProcessCharacter(L';');,9,<empty>,,1056,653,CPPASTProblemDeclaration,,<empty>
598106,UNKNOWN,654,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,1057,654,CPPASTProblemDeclaration,,<empty>
598107,UNKNOWN,655,,mach.ProcessCharacter(L's');,9,<empty>,,1058,655,CPPASTProblemDeclaration,,<empty>
598108,UNKNOWN,656,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::OscString);",9,<empty>,,1059,656,CPPASTProblemDeclaration,,<empty>
598109,UNKNOWN,657,,mach.ProcessCharacter(L'\x9c');,9,<empty>,,1060,657,CPPASTProblemDeclaration,,<empty>
598110,UNKNOWN,658,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1061,658,CPPASTProblemDeclaration,,<empty>
598111,UNKNOWN,659,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1064,659,CPPASTProblemDeclaration,,<empty>
598112,UNKNOWN,660,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1065,660,CPPASTProblemDeclaration,,<empty>
598113,UNKNOWN,661,,mach.ProcessCharacter(L'P');,9,<empty>,,1066,661,CPPASTProblemDeclaration,,<empty>
598114,UNKNOWN,662,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsEntry);",9,<empty>,,1067,662,CPPASTProblemDeclaration,,<empty>
598115,UNKNOWN,663,,mach.ProcessCharacter(L'q');,9,<empty>,,1068,663,CPPASTProblemDeclaration,,<empty>
598116,UNKNOWN,664,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,1069,664,CPPASTProblemDeclaration,,<empty>
598117,UNKNOWN,665,,mach.ProcessCharacter(L'#');,9,<empty>,,1070,665,CPPASTProblemDeclaration,,<empty>
598118,UNKNOWN,666,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::DcsIgnore);",9,<empty>,,1071,666,CPPASTProblemDeclaration,,<empty>
598119,UNKNOWN,667,,mach.ProcessCharacter(L'1');,9,<empty>,,1072,667,CPPASTProblemDeclaration,,<empty>
598120,UNKNOWN,668,,mach.ProcessCharacter(L'\x9c');,9,<empty>,,1073,668,CPPASTProblemDeclaration,,<empty>
598121,UNKNOWN,669,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1074,669,CPPASTProblemDeclaration,,<empty>
598122,UNKNOWN,670,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1077,670,CPPASTProblemDeclaration,,<empty>
598123,UNKNOWN,671,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1078,671,CPPASTProblemDeclaration,,<empty>
598124,UNKNOWN,672,,mach.ProcessCharacter(L'X');,9,<empty>,,1079,672,CPPASTProblemDeclaration,,<empty>
598125,UNKNOWN,673,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1080,673,CPPASTProblemDeclaration,,<empty>
598126,UNKNOWN,674,,mach.ProcessCharacter(L'1');,9,<empty>,,1081,674,CPPASTProblemDeclaration,,<empty>
598127,UNKNOWN,675,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1082,675,CPPASTProblemDeclaration,,<empty>
598128,UNKNOWN,676,,mach.ProcessCharacter(L'\x9c');,9,<empty>,,1083,676,CPPASTProblemDeclaration,,<empty>
598129,UNKNOWN,677,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1084,677,CPPASTProblemDeclaration,,<empty>
598130,UNKNOWN,678,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1086,678,CPPASTProblemDeclaration,,<empty>
598131,UNKNOWN,679,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1087,679,CPPASTProblemDeclaration,,<empty>
598132,UNKNOWN,680,,mach.ProcessCharacter(L'^');,9,<empty>,,1088,680,CPPASTProblemDeclaration,,<empty>
598133,UNKNOWN,681,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1089,681,CPPASTProblemDeclaration,,<empty>
598134,UNKNOWN,682,,mach.ProcessCharacter(L'2');,9,<empty>,,1090,682,CPPASTProblemDeclaration,,<empty>
598135,UNKNOWN,683,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1091,683,CPPASTProblemDeclaration,,<empty>
598136,UNKNOWN,684,,mach.ProcessCharacter(L'\x9c');,9,<empty>,,1092,684,CPPASTProblemDeclaration,,<empty>
598137,UNKNOWN,685,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1093,685,CPPASTProblemDeclaration,,<empty>
598138,UNKNOWN,686,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1095,686,CPPASTProblemDeclaration,,<empty>
598139,UNKNOWN,687,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Escape);",9,<empty>,,1096,687,CPPASTProblemDeclaration,,<empty>
598140,UNKNOWN,688,,mach.ProcessCharacter(L'_');,9,<empty>,,1097,688,CPPASTProblemDeclaration,,<empty>
598141,UNKNOWN,689,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1098,689,CPPASTProblemDeclaration,,<empty>
598142,UNKNOWN,690,,mach.ProcessCharacter(L'3');,9,<empty>,,1099,690,CPPASTProblemDeclaration,,<empty>
598143,UNKNOWN,691,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::SosPmApcString);",9,<empty>,,1100,691,CPPASTProblemDeclaration,,<empty>
598144,UNKNOWN,692,,mach.ProcessCharacter(L'\x9c');,9,<empty>,,1101,692,CPPASTProblemDeclaration,,<empty>
598145,UNKNOWN,693,,"VERIFY_ARE_EQUAL(mach._state, StateMachine::VTStates::Ground);",9,<empty>,,1102,693,CPPASTProblemDeclaration,,<empty>
598146,UNKNOWN,694,,},5,<empty>,,1103,694,CPPASTProblemDeclaration,,<empty>
598147,UNKNOWN,695,,};,1,<empty>,,1104,695,CPPASTProblemDeclaration,,<empty>
598506,UNKNOWN,-1,,"bool _ModeParamsHelper(_In_ DispatchTypes::ModeParams const param, const bool fEnable)
    {
        _modeType = param;
        _modeTypes.push_back(param);
        _modeEnabled = fEnable;

        return true;
    }",5,<empty>,,1359,29,CPPASTProblemDeclaration,,<empty>
598794,UNKNOWN,-1,,"TEST_METHOD_SETUP(SetupState)
    {
        return true;",5,<empty>,,1547,2,CPPASTProblemDeclaration,,<empty>
598795,UNKNOWN,698,,},5,<empty>,,1550,698,CPPASTProblemDeclaration,,<empty>
598951,UNKNOWN,702,,"TEST_METHOD(TestCsiCursorMovementWithValues)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiDistance"", PARAM_VALUES)
            TEST_METHOD_PROPERTY(L""Data:fExtraParam"", L""{false,true}"")
        END_TEST_METHOD_PROPERTIES()

        size_t uiDistance;",5,<empty>,,1624,702,CPPASTProblemDeclaration,,<empty>
598952,UNKNOWN,703,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiDistance"", uiDistance));",9,<empty>,,1632,703,CPPASTProblemDeclaration,,<empty>
598954,UNKNOWN,705,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""fExtraParam"", fExtra));",9,<empty>,,1634,705,CPPASTProblemDeclaration,,<empty>
598983,UNKNOWN,712,,"TestCsiCursorMovement(L'A', uiDistance, true, fExtra, &pDispatch->_cursorUp, mach, *pDispatch);",9,<empty>,,1641,712,CPPASTProblemDeclaration,,<empty>
598984,UNKNOWN,713,,pDispatch->ClearState();,9,<empty>,,1642,713,CPPASTProblemDeclaration,,<empty>
598985,UNKNOWN,714,,"TestCsiCursorMovement(L'B', uiDistance, true, fExtra, &pDispatch->_cursorDown, mach, *pDispatch);",9,<empty>,,1643,714,CPPASTProblemDeclaration,,<empty>
598986,UNKNOWN,715,,pDispatch->ClearState();,9,<empty>,,1644,715,CPPASTProblemDeclaration,,<empty>
598987,UNKNOWN,716,,"TestCsiCursorMovement(L'C', uiDistance, true, fExtra, &pDispatch->_cursorForward, mach, *pDispatch);",9,<empty>,,1645,716,CPPASTProblemDeclaration,,<empty>
598988,UNKNOWN,717,,pDispatch->ClearState();,9,<empty>,,1646,717,CPPASTProblemDeclaration,,<empty>
598989,UNKNOWN,718,,"TestCsiCursorMovement(L'D', uiDistance, true, fExtra, &pDispatch->_cursorBackward, mach, *pDispatch);",9,<empty>,,1647,718,CPPASTProblemDeclaration,,<empty>
598990,UNKNOWN,719,,pDispatch->ClearState();,9,<empty>,,1648,719,CPPASTProblemDeclaration,,<empty>
598991,UNKNOWN,720,,"TestCsiCursorMovement(L'E', uiDistance, true, fExtra, &pDispatch->_cursorNextLine, mach, *pDispatch);",9,<empty>,,1649,720,CPPASTProblemDeclaration,,<empty>
598992,UNKNOWN,721,,pDispatch->ClearState();,9,<empty>,,1650,721,CPPASTProblemDeclaration,,<empty>
598993,UNKNOWN,722,,"TestCsiCursorMovement(L'F', uiDistance, true, fExtra, &pDispatch->_cursorPreviousLine, mach, *pDispatch);",9,<empty>,,1651,722,CPPASTProblemDeclaration,,<empty>
598994,UNKNOWN,723,,pDispatch->ClearState();,9,<empty>,,1652,723,CPPASTProblemDeclaration,,<empty>
598995,UNKNOWN,724,,"TestCsiCursorMovement(L'G', uiDistance, true, fExtra, &pDispatch->_cursorHorizontalPositionAbsolute, mach, *pDispatch);",9,<empty>,,1653,724,CPPASTProblemDeclaration,,<empty>
598996,UNKNOWN,725,,pDispatch->ClearState();,9,<empty>,,1654,725,CPPASTProblemDeclaration,,<empty>
598997,UNKNOWN,726,,"TestCsiCursorMovement(L'`', uiDistance, true, fExtra, &pDispatch->_cursorHorizontalPositionAbsolute, mach, *pDispatch);",9,<empty>,,1655,726,CPPASTProblemDeclaration,,<empty>
598998,UNKNOWN,727,,pDispatch->ClearState();,9,<empty>,,1656,727,CPPASTProblemDeclaration,,<empty>
598999,UNKNOWN,728,,"TestCsiCursorMovement(L'd', uiDistance, true, fExtra, &pDispatch->_verticalLinePositionAbsolute, mach, *pDispatch);",9,<empty>,,1657,728,CPPASTProblemDeclaration,,<empty>
599000,UNKNOWN,729,,pDispatch->ClearState();,9,<empty>,,1658,729,CPPASTProblemDeclaration,,<empty>
599001,UNKNOWN,730,,"TestCsiCursorMovement(L'a', uiDistance, true, fExtra, &pDispatch->_horizontalPositionRelative, mach, *pDispatch);",9,<empty>,,1659,730,CPPASTProblemDeclaration,,<empty>
599002,UNKNOWN,731,,pDispatch->ClearState();,9,<empty>,,1660,731,CPPASTProblemDeclaration,,<empty>
599003,UNKNOWN,732,,"TestCsiCursorMovement(L'e', uiDistance, true, fExtra, &pDispatch->_verticalPositionRelative, mach, *pDispatch);",9,<empty>,,1661,732,CPPASTProblemDeclaration,,<empty>
599004,UNKNOWN,733,,pDispatch->ClearState();,9,<empty>,,1662,733,CPPASTProblemDeclaration,,<empty>
599005,UNKNOWN,734,,"TestCsiCursorMovement(L'@', uiDistance, true, fExtra, &pDispatch->_insertCharacter, mach, *pDispatch);",9,<empty>,,1663,734,CPPASTProblemDeclaration,,<empty>
599006,UNKNOWN,735,,pDispatch->ClearState();,9,<empty>,,1664,735,CPPASTProblemDeclaration,,<empty>
599007,UNKNOWN,736,,"TestCsiCursorMovement(L'P', uiDistance, true, fExtra, &pDispatch->_deleteCharacter, mach, *pDispatch);",9,<empty>,,1665,736,CPPASTProblemDeclaration,,<empty>
599008,UNKNOWN,737,,},5,<empty>,,1666,737,CPPASTProblemDeclaration,,<empty>
599009,UNKNOWN,738,,"TEST_METHOD(TestCsiCursorMovementWithoutValues)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1668,738,CPPASTProblemDeclaration,,<empty>
599035,UNKNOWN,745,,"TestCsiCursorMovement(L'A', uiDistance, false, false, &pDispatch->_cursorUp, mach, *pDispatch);",9,<empty>,,1676,745,CPPASTProblemDeclaration,,<empty>
599036,UNKNOWN,746,,pDispatch->ClearState();,9,<empty>,,1677,746,CPPASTProblemDeclaration,,<empty>
599037,UNKNOWN,747,,"TestCsiCursorMovement(L'B', uiDistance, false, false, &pDispatch->_cursorDown, mach, *pDispatch);",9,<empty>,,1678,747,CPPASTProblemDeclaration,,<empty>
599038,UNKNOWN,748,,pDispatch->ClearState();,9,<empty>,,1679,748,CPPASTProblemDeclaration,,<empty>
599039,UNKNOWN,749,,"TestCsiCursorMovement(L'C', uiDistance, false, false, &pDispatch->_cursorForward, mach, *pDispatch);",9,<empty>,,1680,749,CPPASTProblemDeclaration,,<empty>
599040,UNKNOWN,750,,pDispatch->ClearState();,9,<empty>,,1681,750,CPPASTProblemDeclaration,,<empty>
599041,UNKNOWN,751,,"TestCsiCursorMovement(L'D', uiDistance, false, false, &pDispatch->_cursorBackward, mach, *pDispatch);",9,<empty>,,1682,751,CPPASTProblemDeclaration,,<empty>
599042,UNKNOWN,752,,pDispatch->ClearState();,9,<empty>,,1683,752,CPPASTProblemDeclaration,,<empty>
599043,UNKNOWN,753,,"TestCsiCursorMovement(L'E', uiDistance, false, false, &pDispatch->_cursorNextLine, mach, *pDispatch);",9,<empty>,,1684,753,CPPASTProblemDeclaration,,<empty>
599044,UNKNOWN,754,,pDispatch->ClearState();,9,<empty>,,1685,754,CPPASTProblemDeclaration,,<empty>
599045,UNKNOWN,755,,"TestCsiCursorMovement(L'F', uiDistance, false, false, &pDispatch->_cursorPreviousLine, mach, *pDispatch);",9,<empty>,,1686,755,CPPASTProblemDeclaration,,<empty>
599046,UNKNOWN,756,,pDispatch->ClearState();,9,<empty>,,1687,756,CPPASTProblemDeclaration,,<empty>
599047,UNKNOWN,757,,"TestCsiCursorMovement(L'G', uiDistance, false, false, &pDispatch->_cursorHorizontalPositionAbsolute, mach, *pDispatch);",9,<empty>,,1688,757,CPPASTProblemDeclaration,,<empty>
599048,UNKNOWN,758,,pDispatch->ClearState();,9,<empty>,,1689,758,CPPASTProblemDeclaration,,<empty>
599049,UNKNOWN,759,,"TestCsiCursorMovement(L'`', uiDistance, false, false, &pDispatch->_cursorHorizontalPositionAbsolute, mach, *pDispatch);",9,<empty>,,1690,759,CPPASTProblemDeclaration,,<empty>
599050,UNKNOWN,760,,pDispatch->ClearState();,9,<empty>,,1691,760,CPPASTProblemDeclaration,,<empty>
599051,UNKNOWN,761,,"TestCsiCursorMovement(L'd', uiDistance, false, false, &pDispatch->_verticalLinePositionAbsolute, mach, *pDispatch);",9,<empty>,,1692,761,CPPASTProblemDeclaration,,<empty>
599052,UNKNOWN,762,,pDispatch->ClearState();,9,<empty>,,1693,762,CPPASTProblemDeclaration,,<empty>
599053,UNKNOWN,763,,"TestCsiCursorMovement(L'a', uiDistance, false, false, &pDispatch->_horizontalPositionRelative, mach, *pDispatch);",9,<empty>,,1694,763,CPPASTProblemDeclaration,,<empty>
599054,UNKNOWN,764,,pDispatch->ClearState();,9,<empty>,,1695,764,CPPASTProblemDeclaration,,<empty>
599055,UNKNOWN,765,,"TestCsiCursorMovement(L'e', uiDistance, false, false, &pDispatch->_verticalPositionRelative, mach, *pDispatch);",9,<empty>,,1696,765,CPPASTProblemDeclaration,,<empty>
599056,UNKNOWN,766,,pDispatch->ClearState();,9,<empty>,,1697,766,CPPASTProblemDeclaration,,<empty>
599057,UNKNOWN,767,,"TestCsiCursorMovement(L'@', uiDistance, false, false, &pDispatch->_insertCharacter, mach, *pDispatch);",9,<empty>,,1698,767,CPPASTProblemDeclaration,,<empty>
599058,UNKNOWN,768,,pDispatch->ClearState();,9,<empty>,,1699,768,CPPASTProblemDeclaration,,<empty>
599059,UNKNOWN,769,,"TestCsiCursorMovement(L'P', uiDistance, false, false, &pDispatch->_deleteCharacter, mach, *pDispatch);",9,<empty>,,1700,769,CPPASTProblemDeclaration,,<empty>
599060,UNKNOWN,770,,},5,<empty>,,1701,770,CPPASTProblemDeclaration,,<empty>
599061,UNKNOWN,771,,"TEST_METHOD(TestCsiCursorPosition)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiRow"", PARAM_VALUES)
            TEST_METHOD_PROPERTY(L""Data:uiCol"", PARAM_VALUES)
        END_TEST_METHOD_PROPERTIES()

        size_t uiRow;",5,<empty>,,1703,771,CPPASTProblemDeclaration,,<empty>
599062,UNKNOWN,772,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiRow"", uiRow));",9,<empty>,,1711,772,CPPASTProblemDeclaration,,<empty>
599064,UNKNOWN,774,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiCol"", uiCol));",9,<empty>,,1713,774,CPPASTProblemDeclaration,,<empty>
599093,UNKNOWN,781,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1720,781,CPPASTProblemDeclaration,,<empty>
599094,UNKNOWN,782,,mach.ProcessCharacter(L'[');,9,<empty>,,1721,782,CPPASTProblemDeclaration,,<empty>
599095,UNKNOWN,783,,"InsertNumberToMachine(&mach, uiRow);",9,<empty>,,1723,783,CPPASTProblemDeclaration,,<empty>
599096,UNKNOWN,784,,mach.ProcessCharacter(L';');,9,<empty>,,1724,784,CPPASTProblemDeclaration,,<empty>
599097,UNKNOWN,785,,"InsertNumberToMachine(&mach, uiCol);",9,<empty>,,1725,785,CPPASTProblemDeclaration,,<empty>
599098,UNKNOWN,786,,mach.ProcessCharacter(L'H');,9,<empty>,,1726,786,CPPASTProblemDeclaration,,<empty>
599099,UNKNOWN,787,,"ApplyParameterBoundary(&uiRow, uiRow);",9,<empty>,,1729,787,CPPASTProblemDeclaration,,<empty>
599100,UNKNOWN,788,,"ApplyParameterBoundary(&uiCol, uiCol);",9,<empty>,,1730,788,CPPASTProblemDeclaration,,<empty>
599101,UNKNOWN,789,,VERIFY_IS_TRUE(pDispatch->_cursorPosition);,9,<empty>,,1732,789,CPPASTProblemDeclaration,,<empty>
599102,UNKNOWN,790,,"VERIFY_ARE_EQUAL(pDispatch->_line, uiRow);",9,<empty>,,1733,790,CPPASTProblemDeclaration,,<empty>
599103,UNKNOWN,791,,"VERIFY_ARE_EQUAL(pDispatch->_column, uiCol);",9,<empty>,,1734,791,CPPASTProblemDeclaration,,<empty>
599104,UNKNOWN,792,,},5,<empty>,,1735,792,CPPASTProblemDeclaration,,<empty>
599105,UNKNOWN,793,,"TEST_METHOD(TestCsiCursorPositionWithOnlyRow)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiRow"", PARAM_VALUES)
        END_TEST_METHOD_PROPERTIES()

        size_t uiRow;",5,<empty>,,1737,793,CPPASTProblemDeclaration,,<empty>
599106,UNKNOWN,794,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiRow"", uiRow));",9,<empty>,,1744,794,CPPASTProblemDeclaration,,<empty>
599135,UNKNOWN,801,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1751,801,CPPASTProblemDeclaration,,<empty>
599136,UNKNOWN,802,,mach.ProcessCharacter(L'[');,9,<empty>,,1752,802,CPPASTProblemDeclaration,,<empty>
599137,UNKNOWN,803,,"InsertNumberToMachine(&mach, uiRow);",9,<empty>,,1754,803,CPPASTProblemDeclaration,,<empty>
599138,UNKNOWN,804,,mach.ProcessCharacter(L'H');,9,<empty>,,1755,804,CPPASTProblemDeclaration,,<empty>
599139,UNKNOWN,805,,"ApplyParameterBoundary(&uiRow, uiRow);",9,<empty>,,1758,805,CPPASTProblemDeclaration,,<empty>
599140,UNKNOWN,806,,VERIFY_IS_TRUE(pDispatch->_cursorPosition);,9,<empty>,,1760,806,CPPASTProblemDeclaration,,<empty>
599141,UNKNOWN,807,,"VERIFY_ARE_EQUAL(pDispatch->_line, uiRow);",9,<empty>,,1761,807,CPPASTProblemDeclaration,,<empty>
599142,UNKNOWN,808,,"VERIFY_ARE_EQUAL(pDispatch->_column, (size_t)1);",9,<empty>,,1762,808,CPPASTProblemDeclaration,,<empty>
599143,UNKNOWN,809,,},5,<empty>,,1763,809,CPPASTProblemDeclaration,,<empty>
599144,UNKNOWN,810,,"TEST_METHOD(TestCursorSaveLoad)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1765,810,CPPASTProblemDeclaration,,<empty>
599166,UNKNOWN,815,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1772,815,CPPASTProblemDeclaration,,<empty>
599167,UNKNOWN,816,,mach.ProcessCharacter(L'7');,9,<empty>,,1773,816,CPPASTProblemDeclaration,,<empty>
599168,UNKNOWN,817,,VERIFY_IS_TRUE(pDispatch->_cursorSave);,9,<empty>,,1774,817,CPPASTProblemDeclaration,,<empty>
599169,UNKNOWN,818,,pDispatch->ClearState();,9,<empty>,,1776,818,CPPASTProblemDeclaration,,<empty>
599170,UNKNOWN,819,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1778,819,CPPASTProblemDeclaration,,<empty>
599171,UNKNOWN,820,,mach.ProcessCharacter(L'8');,9,<empty>,,1779,820,CPPASTProblemDeclaration,,<empty>
599172,UNKNOWN,821,,VERIFY_IS_TRUE(pDispatch->_cursorLoad);,9,<empty>,,1780,821,CPPASTProblemDeclaration,,<empty>
599173,UNKNOWN,822,,pDispatch->ClearState();,9,<empty>,,1782,822,CPPASTProblemDeclaration,,<empty>
599174,UNKNOWN,823,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1789,823,CPPASTProblemDeclaration,,<empty>
599175,UNKNOWN,824,,mach.ProcessCharacter(L'[');,9,<empty>,,1790,824,CPPASTProblemDeclaration,,<empty>
599176,UNKNOWN,825,,mach.ProcessCharacter(L'u');,9,<empty>,,1791,825,CPPASTProblemDeclaration,,<empty>
599177,UNKNOWN,826,,VERIFY_IS_TRUE(pDispatch->_cursorLoad);,9,<empty>,,1792,826,CPPASTProblemDeclaration,,<empty>
599178,UNKNOWN,827,,pDispatch->ClearState();,9,<empty>,,1794,827,CPPASTProblemDeclaration,,<empty>
599179,UNKNOWN,828,,},5,<empty>,,1795,828,CPPASTProblemDeclaration,,<empty>
599180,UNKNOWN,829,,"TEST_METHOD(TestAnsiMode)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1797,829,CPPASTProblemDeclaration,,<empty>
599202,UNKNOWN,834,,pDispatch->_modeEnabled = true;,9,<empty>,,1804,834,CPPASTProblemDeclaration,,<empty>
599203,UNKNOWN,835,,"mach.ProcessString(L""\x1b[?2l"");",9,<empty>,,1805,835,CPPASTProblemDeclaration,,<empty>
599204,UNKNOWN,836,,"VERIFY_ARE_EQUAL(DispatchTypes::DECANM_AnsiMode, pDispatch->_modeType);",9,<empty>,,1806,836,CPPASTProblemDeclaration,,<empty>
599205,UNKNOWN,837,,VERIFY_IS_FALSE(pDispatch->_modeEnabled);,9,<empty>,,1807,837,CPPASTProblemDeclaration,,<empty>
599206,UNKNOWN,838,,pDispatch->ClearState();,9,<empty>,,1809,838,CPPASTProblemDeclaration,,<empty>
599207,UNKNOWN,839,,"mach.SetParserMode(StateMachine::Mode::Ansi, false);",9,<empty>,,1810,839,CPPASTProblemDeclaration,,<empty>
599208,UNKNOWN,840,,"mach.ProcessString(L""\x1b<"");",9,<empty>,,1812,840,CPPASTProblemDeclaration,,<empty>
599209,UNKNOWN,841,,"VERIFY_ARE_EQUAL(DispatchTypes::DECANM_AnsiMode, pDispatch->_modeType);",9,<empty>,,1813,841,CPPASTProblemDeclaration,,<empty>
599210,UNKNOWN,842,,VERIFY_IS_TRUE(pDispatch->_modeEnabled);,9,<empty>,,1814,842,CPPASTProblemDeclaration,,<empty>
599211,UNKNOWN,843,,pDispatch->ClearState();,9,<empty>,,1816,843,CPPASTProblemDeclaration,,<empty>
599212,UNKNOWN,844,,},5,<empty>,,1817,844,CPPASTProblemDeclaration,,<empty>
599213,UNKNOWN,845,,"TEST_METHOD(TestPrivateModes)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:modeNumber"", L""{1, 3, 5, 6, 7, 12, 25, 40, 1049}"")
        END_TEST_METHOD_PROPERTIES()

        VTInt modeNumber;",5,<empty>,,1819,845,CPPASTProblemDeclaration,,<empty>
599214,UNKNOWN,846,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""modeNumber"", modeNumber));",9,<empty>,,1826,846,CPPASTProblemDeclaration,,<empty>
599281,UNKNOWN,859,,mach.ProcessString(setModeSequence);,9,<empty>,,1837,859,CPPASTProblemDeclaration,,<empty>
599282,UNKNOWN,860,,"VERIFY_ARE_EQUAL(modeType, pDispatch->_modeType);",9,<empty>,,1838,860,CPPASTProblemDeclaration,,<empty>
599283,UNKNOWN,861,,VERIFY_IS_TRUE(pDispatch->_modeEnabled);,9,<empty>,,1839,861,CPPASTProblemDeclaration,,<empty>
599284,UNKNOWN,862,,pDispatch->ClearState();,9,<empty>,,1841,862,CPPASTProblemDeclaration,,<empty>
599285,UNKNOWN,863,,pDispatch->_modeEnabled = true;,9,<empty>,,1842,863,CPPASTProblemDeclaration,,<empty>
599286,UNKNOWN,864,,mach.ProcessString(resetModeSequence);,9,<empty>,,1844,864,CPPASTProblemDeclaration,,<empty>
599287,UNKNOWN,865,,"VERIFY_ARE_EQUAL(modeType, pDispatch->_modeType);",9,<empty>,,1845,865,CPPASTProblemDeclaration,,<empty>
599288,UNKNOWN,866,,VERIFY_IS_FALSE(pDispatch->_modeEnabled);,9,<empty>,,1846,866,CPPASTProblemDeclaration,,<empty>
599289,UNKNOWN,867,,pDispatch->ClearState();,9,<empty>,,1848,867,CPPASTProblemDeclaration,,<empty>
599290,UNKNOWN,868,,},5,<empty>,,1849,868,CPPASTProblemDeclaration,,<empty>
599291,UNKNOWN,869,,"TEST_METHOD(TestMultipleModes)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1851,869,CPPASTProblemDeclaration,,<empty>
599327,UNKNOWN,876,,"mach.ProcessString(L""\x1b[?5;1;6h"");",9,<empty>,,1860,876,CPPASTProblemDeclaration,,<empty>
599328,UNKNOWN,877,,VERIFY_IS_TRUE(pDispatch->_modeEnabled);,9,<empty>,,1861,877,CPPASTProblemDeclaration,,<empty>
599329,UNKNOWN,878,,"VERIFY_ARE_EQUAL(expectedModes, pDispatch->_modeTypes);",9,<empty>,,1862,878,CPPASTProblemDeclaration,,<empty>
599330,UNKNOWN,879,,pDispatch->ClearState();,9,<empty>,,1864,879,CPPASTProblemDeclaration,,<empty>
599331,UNKNOWN,880,,pDispatch->_modeEnabled = true;,9,<empty>,,1865,880,CPPASTProblemDeclaration,,<empty>
599332,UNKNOWN,881,,"mach.ProcessString(L""\x1b[?5;1;6l"");",9,<empty>,,1867,881,CPPASTProblemDeclaration,,<empty>
599333,UNKNOWN,882,,VERIFY_IS_FALSE(pDispatch->_modeEnabled);,9,<empty>,,1868,882,CPPASTProblemDeclaration,,<empty>
599334,UNKNOWN,883,,"VERIFY_ARE_EQUAL(expectedModes, pDispatch->_modeTypes);",9,<empty>,,1869,883,CPPASTProblemDeclaration,,<empty>
599335,UNKNOWN,884,,pDispatch->ClearState();,9,<empty>,,1871,884,CPPASTProblemDeclaration,,<empty>
599336,UNKNOWN,885,,},5,<empty>,,1872,885,CPPASTProblemDeclaration,,<empty>
599337,UNKNOWN,886,,"TEST_METHOD(TestErase)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:uiEraseOperation"", L""{0, 1}"") // for ""display"" and ""line"" type erase operations
            TEST_METHOD_PROPERTY(L""Data:uiDispatchTypes::EraseType"", L""{0, 1, 2, 10}"") // maps to DispatchTypes::EraseType enum class options.
        END_TEST_METHOD_PROPERTIES()

        size_t uiEraseOperation;",5,<empty>,,1874,886,CPPASTProblemDeclaration,,<empty>
599338,UNKNOWN,887,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiEraseOperation"", uiEraseOperation));",9,<empty>,,1882,887,CPPASTProblemDeclaration,,<empty>
599340,UNKNOWN,889,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""uiDispatchTypes::EraseType"", uiDispatchTypes));",9,<empty>,,1884,889,CPPASTProblemDeclaration,,<empty>
599377,UNKNOWN,900,,"switch (uiEraseOperation)
        {
        case 0:
            wchOp = L'J';
            pfOperationCallback = &pDispatch->_eraseDisplay;
            break;
        case 1:
            wchOp = L'K';
            pfOperationCallback = &pDispatch->_eraseLine;
            break;
        default:
            VERIFY_FAIL(L""Unknown erase operation permutation."");
        }",9,<empty>,,1894,900,CPPASTProblemDeclaration,,<empty>
599380,UNKNOWN,903,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,1911,903,CPPASTProblemDeclaration,,<empty>
599381,UNKNOWN,904,,mach.ProcessCharacter(L'[');,9,<empty>,,1912,904,CPPASTProblemDeclaration,,<empty>
599383,UNKNOWN,906,,"switch (uiDispatchTypes)
        {
        case 0:
            expectedDispatchTypes = DispatchTypes::EraseType::ToEnd;
            InsertNumberToMachine(&mach, uiDispatchTypes);
            break;
        case 1:
            expectedDispatchTypes = DispatchTypes::EraseType::FromBeginning;
            InsertNumberToMachine(&mach, uiDispatchTypes);
            break;
        case 2:
            expectedDispatchTypes = DispatchTypes::EraseType::All;
            InsertNumberToMachine(&mach, uiDispatchTypes);
            break;
        case 10:
            // Do nothing. Default case of 10 should be like a 0 to the end.
            expectedDispatchTypes = DispatchTypes::EraseType::ToEnd;
            break;
        }",9,<empty>,,1916,906,CPPASTProblemDeclaration,,<empty>
599384,UNKNOWN,907,,mach.ProcessCharacter(wchOp);,9,<empty>,,1936,907,CPPASTProblemDeclaration,,<empty>
599386,UNKNOWN,909,,"VERIFY_ARE_EQUAL(expectedDispatchTypes, pDispatch->_eraseType);",9,<empty>,,1939,909,CPPASTProblemDeclaration,,<empty>
599387,UNKNOWN,910,,},5,<empty>,,1940,910,CPPASTProblemDeclaration,,<empty>
599388,UNKNOWN,911,,"TEST_METHOD(TestMultipleErase)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1942,911,CPPASTProblemDeclaration,,<empty>
599410,UNKNOWN,916,,"mach.ProcessString(L""\x1b[3;2J"");",9,<empty>,,1949,916,CPPASTProblemDeclaration,,<empty>
599426,UNKNOWN,919,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,1951,919,CPPASTProblemDeclaration,,<empty>
599427,UNKNOWN,920,,"VERIFY_ARE_EQUAL(expectedEraseTypes, pDispatch->_eraseTypes);",9,<empty>,,1952,920,CPPASTProblemDeclaration,,<empty>
599428,UNKNOWN,921,,pDispatch->ClearState();,9,<empty>,,1954,921,CPPASTProblemDeclaration,,<empty>
599429,UNKNOWN,922,,"mach.ProcessString(L""\x1b[0;1K"");",9,<empty>,,1956,922,CPPASTProblemDeclaration,,<empty>
599430,UNKNOWN,923,,"expectedEraseTypes = std::vector{ DispatchTypes::EraseType::ToEnd, DispatchTypes::EraseType::FromBeginning };",9,<empty>,,1957,923,CPPASTProblemDeclaration,,<empty>
599431,UNKNOWN,924,,VERIFY_IS_TRUE(pDispatch->_eraseLine);,9,<empty>,,1958,924,CPPASTProblemDeclaration,,<empty>
599432,UNKNOWN,925,,"VERIFY_ARE_EQUAL(expectedEraseTypes, pDispatch->_eraseTypes);",9,<empty>,,1959,925,CPPASTProblemDeclaration,,<empty>
599433,UNKNOWN,926,,pDispatch->ClearState();,9,<empty>,,1961,926,CPPASTProblemDeclaration,,<empty>
599434,UNKNOWN,927,,},5,<empty>,,1962,927,CPPASTProblemDeclaration,,<empty>
599475,UNKNOWN,1,,DispatchTypes::GraphicsOptions,36,<empty>,,1972,1,CPPASTTypeId,,<empty>
599535,UNKNOWN,929,,"TEST_METHOD(TestSetGraphicsRendition)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,1991,929,CPPASTProblemDeclaration,,<empty>
599560,UNKNOWN,936,,"Log::Comment(L""Test 1: Check default case."");",9,<empty>,,2000,936,CPPASTProblemDeclaration,,<empty>
599561,UNKNOWN,937,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2001,937,CPPASTProblemDeclaration,,<empty>
599562,UNKNOWN,938,,mach.ProcessCharacter(L'[');,9,<empty>,,2002,938,CPPASTProblemDeclaration,,<empty>
599563,UNKNOWN,939,,mach.ProcessCharacter(L'm');,9,<empty>,,2003,939,CPPASTProblemDeclaration,,<empty>
599564,UNKNOWN,940,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2004,940,CPPASTProblemDeclaration,,<empty>
599565,UNKNOWN,941,,rgExpected[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,2006,941,CPPASTProblemDeclaration,,<empty>
599566,UNKNOWN,942,,"VerifyDispatchTypes({ rgExpected, 1 }",9,<empty>,,2007,942,CPPASTProblemDeclaration,,<empty>
599567,UNKNOWN,943,,", *pDispatch);",46,<empty>,,2007,943,CPPASTProblemDeclaration,,<empty>
599568,UNKNOWN,944,,pDispatch->ClearState();,9,<empty>,,2009,944,CPPASTProblemDeclaration,,<empty>
599569,UNKNOWN,945,,"Log::Comment(L""Test 2: Check clear/0 case."");",9,<empty>,,2011,945,CPPASTProblemDeclaration,,<empty>
599570,UNKNOWN,946,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2013,946,CPPASTProblemDeclaration,,<empty>
599571,UNKNOWN,947,,mach.ProcessCharacter(L'[');,9,<empty>,,2014,947,CPPASTProblemDeclaration,,<empty>
599572,UNKNOWN,948,,mach.ProcessCharacter(L'0');,9,<empty>,,2015,948,CPPASTProblemDeclaration,,<empty>
599573,UNKNOWN,949,,mach.ProcessCharacter(L'm');,9,<empty>,,2016,949,CPPASTProblemDeclaration,,<empty>
599574,UNKNOWN,950,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2017,950,CPPASTProblemDeclaration,,<empty>
599575,UNKNOWN,951,,rgExpected[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,2019,951,CPPASTProblemDeclaration,,<empty>
599576,UNKNOWN,952,,"VerifyDispatchTypes({ rgExpected, 1 }",9,<empty>,,2020,952,CPPASTProblemDeclaration,,<empty>
599577,UNKNOWN,953,,", *pDispatch);",46,<empty>,,2020,953,CPPASTProblemDeclaration,,<empty>
599578,UNKNOWN,954,,pDispatch->ClearState();,9,<empty>,,2022,954,CPPASTProblemDeclaration,,<empty>
599579,UNKNOWN,955,,"Log::Comment(L""Test 3: Check 'handful of options' case."");",9,<empty>,,2024,955,CPPASTProblemDeclaration,,<empty>
599580,UNKNOWN,956,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2026,956,CPPASTProblemDeclaration,,<empty>
599581,UNKNOWN,957,,mach.ProcessCharacter(L'[');,9,<empty>,,2027,957,CPPASTProblemDeclaration,,<empty>
599582,UNKNOWN,958,,mach.ProcessCharacter(L'1');,9,<empty>,,2028,958,CPPASTProblemDeclaration,,<empty>
599583,UNKNOWN,959,,mach.ProcessCharacter(L';');,9,<empty>,,2029,959,CPPASTProblemDeclaration,,<empty>
599584,UNKNOWN,960,,mach.ProcessCharacter(L'4');,9,<empty>,,2030,960,CPPASTProblemDeclaration,,<empty>
599585,UNKNOWN,961,,mach.ProcessCharacter(L';');,9,<empty>,,2031,961,CPPASTProblemDeclaration,,<empty>
599586,UNKNOWN,962,,mach.ProcessCharacter(L'7');,9,<empty>,,2032,962,CPPASTProblemDeclaration,,<empty>
599587,UNKNOWN,963,,mach.ProcessCharacter(L';');,9,<empty>,,2033,963,CPPASTProblemDeclaration,,<empty>
599588,UNKNOWN,964,,mach.ProcessCharacter(L'3');,9,<empty>,,2034,964,CPPASTProblemDeclaration,,<empty>
599589,UNKNOWN,965,,mach.ProcessCharacter(L'0');,9,<empty>,,2035,965,CPPASTProblemDeclaration,,<empty>
599590,UNKNOWN,966,,mach.ProcessCharacter(L';');,9,<empty>,,2036,966,CPPASTProblemDeclaration,,<empty>
599591,UNKNOWN,967,,mach.ProcessCharacter(L'4');,9,<empty>,,2037,967,CPPASTProblemDeclaration,,<empty>
599592,UNKNOWN,968,,mach.ProcessCharacter(L'5');,9,<empty>,,2038,968,CPPASTProblemDeclaration,,<empty>
599593,UNKNOWN,969,,mach.ProcessCharacter(L';');,9,<empty>,,2039,969,CPPASTProblemDeclaration,,<empty>
599594,UNKNOWN,970,,mach.ProcessCharacter(L'5');,9,<empty>,,2040,970,CPPASTProblemDeclaration,,<empty>
599595,UNKNOWN,971,,mach.ProcessCharacter(L'3');,9,<empty>,,2041,971,CPPASTProblemDeclaration,,<empty>
599596,UNKNOWN,972,,mach.ProcessCharacter(L'm');,9,<empty>,,2042,972,CPPASTProblemDeclaration,,<empty>
599597,UNKNOWN,973,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2043,973,CPPASTProblemDeclaration,,<empty>
599598,UNKNOWN,974,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2045,974,CPPASTProblemDeclaration,,<empty>
599599,UNKNOWN,975,,rgExpected[1] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2046,975,CPPASTProblemDeclaration,,<empty>
599600,UNKNOWN,976,,rgExpected[2] = DispatchTypes::GraphicsOptions::Negative;,9,<empty>,,2047,976,CPPASTProblemDeclaration,,<empty>
599601,UNKNOWN,977,,rgExpected[3] = DispatchTypes::GraphicsOptions::ForegroundBlack;,9,<empty>,,2048,977,CPPASTProblemDeclaration,,<empty>
599602,UNKNOWN,978,,rgExpected[4] = DispatchTypes::GraphicsOptions::BackgroundMagenta;,9,<empty>,,2049,978,CPPASTProblemDeclaration,,<empty>
599603,UNKNOWN,979,,rgExpected[5] = DispatchTypes::GraphicsOptions::Overline;,9,<empty>,,2050,979,CPPASTProblemDeclaration,,<empty>
599604,UNKNOWN,980,,"VerifyDispatchTypes({ rgExpected, 6 }",9,<empty>,,2051,980,CPPASTProblemDeclaration,,<empty>
599605,UNKNOWN,981,,", *pDispatch);",46,<empty>,,2051,981,CPPASTProblemDeclaration,,<empty>
599606,UNKNOWN,982,,pDispatch->ClearState();,9,<empty>,,2053,982,CPPASTProblemDeclaration,,<empty>
599607,UNKNOWN,983,,"Log::Comment(L""Test 4: Check 'many options' (>16) case."");",9,<empty>,,2055,983,CPPASTProblemDeclaration,,<empty>
599608,UNKNOWN,984,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2057,984,CPPASTProblemDeclaration,,<empty>
599609,UNKNOWN,985,,mach.ProcessCharacter(L'[');,9,<empty>,,2058,985,CPPASTProblemDeclaration,,<empty>
599610,UNKNOWN,986,,mach.ProcessCharacter(L'1');,9,<empty>,,2059,986,CPPASTProblemDeclaration,,<empty>
599611,UNKNOWN,987,,mach.ProcessCharacter(L';');,9,<empty>,,2060,987,CPPASTProblemDeclaration,,<empty>
599612,UNKNOWN,988,,mach.ProcessCharacter(L'4');,9,<empty>,,2061,988,CPPASTProblemDeclaration,,<empty>
599613,UNKNOWN,989,,mach.ProcessCharacter(L';');,9,<empty>,,2062,989,CPPASTProblemDeclaration,,<empty>
599614,UNKNOWN,990,,mach.ProcessCharacter(L'1');,9,<empty>,,2063,990,CPPASTProblemDeclaration,,<empty>
599615,UNKNOWN,991,,mach.ProcessCharacter(L';');,9,<empty>,,2064,991,CPPASTProblemDeclaration,,<empty>
599616,UNKNOWN,992,,mach.ProcessCharacter(L'4');,9,<empty>,,2065,992,CPPASTProblemDeclaration,,<empty>
599617,UNKNOWN,993,,mach.ProcessCharacter(L';');,9,<empty>,,2066,993,CPPASTProblemDeclaration,,<empty>
599618,UNKNOWN,994,,mach.ProcessCharacter(L'1');,9,<empty>,,2067,994,CPPASTProblemDeclaration,,<empty>
599619,UNKNOWN,995,,mach.ProcessCharacter(L';');,9,<empty>,,2068,995,CPPASTProblemDeclaration,,<empty>
599620,UNKNOWN,996,,mach.ProcessCharacter(L'4');,9,<empty>,,2069,996,CPPASTProblemDeclaration,,<empty>
599621,UNKNOWN,997,,mach.ProcessCharacter(L';');,9,<empty>,,2070,997,CPPASTProblemDeclaration,,<empty>
599622,UNKNOWN,998,,mach.ProcessCharacter(L'1');,9,<empty>,,2071,998,CPPASTProblemDeclaration,,<empty>
599623,UNKNOWN,999,,mach.ProcessCharacter(L';');,9,<empty>,,2072,999,CPPASTProblemDeclaration,,<empty>
599624,UNKNOWN,1000,,mach.ProcessCharacter(L'4');,9,<empty>,,2073,1000,CPPASTProblemDeclaration,,<empty>
599625,UNKNOWN,1001,,mach.ProcessCharacter(L';');,9,<empty>,,2074,1001,CPPASTProblemDeclaration,,<empty>
599626,UNKNOWN,1002,,mach.ProcessCharacter(L'1');,9,<empty>,,2075,1002,CPPASTProblemDeclaration,,<empty>
599627,UNKNOWN,1003,,mach.ProcessCharacter(L';');,9,<empty>,,2076,1003,CPPASTProblemDeclaration,,<empty>
599628,UNKNOWN,1004,,mach.ProcessCharacter(L'4');,9,<empty>,,2077,1004,CPPASTProblemDeclaration,,<empty>
599629,UNKNOWN,1005,,mach.ProcessCharacter(L';');,9,<empty>,,2078,1005,CPPASTProblemDeclaration,,<empty>
599630,UNKNOWN,1006,,mach.ProcessCharacter(L'1');,9,<empty>,,2079,1006,CPPASTProblemDeclaration,,<empty>
599631,UNKNOWN,1007,,mach.ProcessCharacter(L';');,9,<empty>,,2080,1007,CPPASTProblemDeclaration,,<empty>
599632,UNKNOWN,1008,,mach.ProcessCharacter(L'4');,9,<empty>,,2081,1008,CPPASTProblemDeclaration,,<empty>
599633,UNKNOWN,1009,,mach.ProcessCharacter(L';');,9,<empty>,,2082,1009,CPPASTProblemDeclaration,,<empty>
599634,UNKNOWN,1010,,mach.ProcessCharacter(L'1');,9,<empty>,,2083,1010,CPPASTProblemDeclaration,,<empty>
599635,UNKNOWN,1011,,mach.ProcessCharacter(L';');,9,<empty>,,2084,1011,CPPASTProblemDeclaration,,<empty>
599636,UNKNOWN,1012,,mach.ProcessCharacter(L'4');,9,<empty>,,2085,1012,CPPASTProblemDeclaration,,<empty>
599637,UNKNOWN,1013,,mach.ProcessCharacter(L';');,9,<empty>,,2086,1013,CPPASTProblemDeclaration,,<empty>
599638,UNKNOWN,1014,,mach.ProcessCharacter(L'1');,9,<empty>,,2087,1014,CPPASTProblemDeclaration,,<empty>
599639,UNKNOWN,1015,,mach.ProcessCharacter(L';');,9,<empty>,,2088,1015,CPPASTProblemDeclaration,,<empty>
599640,UNKNOWN,1016,,mach.ProcessCharacter(L'4');,9,<empty>,,2089,1016,CPPASTProblemDeclaration,,<empty>
599641,UNKNOWN,1017,,mach.ProcessCharacter(L';');,9,<empty>,,2090,1017,CPPASTProblemDeclaration,,<empty>
599642,UNKNOWN,1018,,mach.ProcessCharacter(L'1');,9,<empty>,,2091,1018,CPPASTProblemDeclaration,,<empty>
599643,UNKNOWN,1019,,mach.ProcessCharacter(L'm');,9,<empty>,,2092,1019,CPPASTProblemDeclaration,,<empty>
599644,UNKNOWN,1020,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2093,1020,CPPASTProblemDeclaration,,<empty>
599645,UNKNOWN,1021,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2095,1021,CPPASTProblemDeclaration,,<empty>
599646,UNKNOWN,1022,,rgExpected[1] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2096,1022,CPPASTProblemDeclaration,,<empty>
599647,UNKNOWN,1023,,rgExpected[2] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2097,1023,CPPASTProblemDeclaration,,<empty>
599648,UNKNOWN,1024,,rgExpected[3] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2098,1024,CPPASTProblemDeclaration,,<empty>
599649,UNKNOWN,1025,,rgExpected[4] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2099,1025,CPPASTProblemDeclaration,,<empty>
599650,UNKNOWN,1026,,rgExpected[5] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2100,1026,CPPASTProblemDeclaration,,<empty>
599651,UNKNOWN,1027,,rgExpected[6] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2101,1027,CPPASTProblemDeclaration,,<empty>
599652,UNKNOWN,1028,,rgExpected[7] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2102,1028,CPPASTProblemDeclaration,,<empty>
599653,UNKNOWN,1029,,rgExpected[8] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2103,1029,CPPASTProblemDeclaration,,<empty>
599654,UNKNOWN,1030,,rgExpected[9] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2104,1030,CPPASTProblemDeclaration,,<empty>
599655,UNKNOWN,1031,,rgExpected[10] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2105,1031,CPPASTProblemDeclaration,,<empty>
599656,UNKNOWN,1032,,rgExpected[11] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2106,1032,CPPASTProblemDeclaration,,<empty>
599657,UNKNOWN,1033,,rgExpected[12] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2107,1033,CPPASTProblemDeclaration,,<empty>
599658,UNKNOWN,1034,,rgExpected[13] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2108,1034,CPPASTProblemDeclaration,,<empty>
599659,UNKNOWN,1035,,rgExpected[14] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2109,1035,CPPASTProblemDeclaration,,<empty>
599660,UNKNOWN,1036,,rgExpected[15] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2110,1036,CPPASTProblemDeclaration,,<empty>
599661,UNKNOWN,1037,,rgExpected[16] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2111,1037,CPPASTProblemDeclaration,,<empty>
599662,UNKNOWN,1038,,"VerifyDispatchTypes({ rgExpected, 17 }",9,<empty>,,2112,1038,CPPASTProblemDeclaration,,<empty>
599663,UNKNOWN,1039,,", *pDispatch);",47,<empty>,,2112,1039,CPPASTProblemDeclaration,,<empty>
599664,UNKNOWN,1040,,pDispatch->ClearState();,9,<empty>,,2114,1040,CPPASTProblemDeclaration,,<empty>
599665,UNKNOWN,1041,,"Log::Comment(L""Test 5.a: Test an empty param at the end of a sequence"");",9,<empty>,,2116,1041,CPPASTProblemDeclaration,,<empty>
599670,UNKNOWN,1044,,mach.ProcessString(sequence);,9,<empty>,,2119,1044,CPPASTProblemDeclaration,,<empty>
599671,UNKNOWN,1045,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2120,1045,CPPASTProblemDeclaration,,<empty>
599672,UNKNOWN,1046,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2122,1046,CPPASTProblemDeclaration,,<empty>
599673,UNKNOWN,1047,,rgExpected[1] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,2123,1047,CPPASTProblemDeclaration,,<empty>
599674,UNKNOWN,1048,,"VerifyDispatchTypes({ rgExpected, 2 }",9,<empty>,,2124,1048,CPPASTProblemDeclaration,,<empty>
599675,UNKNOWN,1049,,", *pDispatch);",46,<empty>,,2124,1049,CPPASTProblemDeclaration,,<empty>
599676,UNKNOWN,1050,,pDispatch->ClearState();,9,<empty>,,2126,1050,CPPASTProblemDeclaration,,<empty>
599677,UNKNOWN,1051,,"Log::Comment(L""Test 5.b: Test an empty param in the middle of a sequence"");",9,<empty>,,2128,1051,CPPASTProblemDeclaration,,<empty>
599678,UNKNOWN,1052,,"sequence = L""\x1b[1;;1m"";",9,<empty>,,2130,1052,CPPASTProblemDeclaration,,<empty>
599679,UNKNOWN,1053,,mach.ProcessString(sequence);,9,<empty>,,2131,1053,CPPASTProblemDeclaration,,<empty>
599680,UNKNOWN,1054,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2132,1054,CPPASTProblemDeclaration,,<empty>
599681,UNKNOWN,1055,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2134,1055,CPPASTProblemDeclaration,,<empty>
599682,UNKNOWN,1056,,rgExpected[1] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,2135,1056,CPPASTProblemDeclaration,,<empty>
599683,UNKNOWN,1057,,rgExpected[2] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2136,1057,CPPASTProblemDeclaration,,<empty>
599684,UNKNOWN,1058,,"VerifyDispatchTypes({ rgExpected, 3 }",9,<empty>,,2137,1058,CPPASTProblemDeclaration,,<empty>
599685,UNKNOWN,1059,,", *pDispatch);",46,<empty>,,2137,1059,CPPASTProblemDeclaration,,<empty>
599686,UNKNOWN,1060,,pDispatch->ClearState();,9,<empty>,,2139,1060,CPPASTProblemDeclaration,,<empty>
599687,UNKNOWN,1061,,"Log::Comment(L""Test 5.c: Test an empty param at the start of a sequence"");",9,<empty>,,2141,1061,CPPASTProblemDeclaration,,<empty>
599688,UNKNOWN,1062,,"sequence = L""\x1b[;31;1m"";",9,<empty>,,2143,1062,CPPASTProblemDeclaration,,<empty>
599689,UNKNOWN,1063,,mach.ProcessString(sequence);,9,<empty>,,2144,1063,CPPASTProblemDeclaration,,<empty>
599690,UNKNOWN,1064,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2145,1064,CPPASTProblemDeclaration,,<empty>
599691,UNKNOWN,1065,,rgExpected[0] = DispatchTypes::GraphicsOptions::Off;,9,<empty>,,2147,1065,CPPASTProblemDeclaration,,<empty>
599692,UNKNOWN,1066,,rgExpected[1] = DispatchTypes::GraphicsOptions::ForegroundRed;,9,<empty>,,2148,1066,CPPASTProblemDeclaration,,<empty>
599693,UNKNOWN,1067,,rgExpected[2] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2149,1067,CPPASTProblemDeclaration,,<empty>
599694,UNKNOWN,1068,,"VerifyDispatchTypes({ rgExpected, 3 }",9,<empty>,,2150,1068,CPPASTProblemDeclaration,,<empty>
599695,UNKNOWN,1069,,", *pDispatch);",46,<empty>,,2150,1069,CPPASTProblemDeclaration,,<empty>
599696,UNKNOWN,1070,,pDispatch->ClearState();,9,<empty>,,2152,1070,CPPASTProblemDeclaration,,<empty>
599697,UNKNOWN,1071,,},5,<empty>,,2153,1071,CPPASTProblemDeclaration,,<empty>
599698,UNKNOWN,1072,,"TEST_METHOD(TestDeviceStatusReport)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2155,1072,CPPASTProblemDeclaration,,<empty>
599720,UNKNOWN,1077,,"Log::Comment(L""Test 1: Check operating status (case 5). Should succeed."");",9,<empty>,,2162,1077,CPPASTProblemDeclaration,,<empty>
599721,UNKNOWN,1078,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2163,1078,CPPASTProblemDeclaration,,<empty>
599722,UNKNOWN,1079,,mach.ProcessCharacter(L'[');,9,<empty>,,2164,1079,CPPASTProblemDeclaration,,<empty>
599723,UNKNOWN,1080,,mach.ProcessCharacter(L'5');,9,<empty>,,2165,1080,CPPASTProblemDeclaration,,<empty>
599724,UNKNOWN,1081,,mach.ProcessCharacter(L'n');,9,<empty>,,2166,1081,CPPASTProblemDeclaration,,<empty>
599725,UNKNOWN,1082,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2168,1082,CPPASTProblemDeclaration,,<empty>
599726,UNKNOWN,1083,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::OperatingStatus, pDispatch->_statusReportType);",9,<empty>,,2169,1083,CPPASTProblemDeclaration,,<empty>
599727,UNKNOWN,1084,,pDispatch->ClearState();,9,<empty>,,2171,1084,CPPASTProblemDeclaration,,<empty>
599728,UNKNOWN,1085,,"Log::Comment(L""Test 2: Check cursor position report (case 6). Should succeed."");",9,<empty>,,2173,1085,CPPASTProblemDeclaration,,<empty>
599729,UNKNOWN,1086,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2174,1086,CPPASTProblemDeclaration,,<empty>
599730,UNKNOWN,1087,,mach.ProcessCharacter(L'[');,9,<empty>,,2175,1087,CPPASTProblemDeclaration,,<empty>
599731,UNKNOWN,1088,,mach.ProcessCharacter(L'6');,9,<empty>,,2176,1088,CPPASTProblemDeclaration,,<empty>
599732,UNKNOWN,1089,,mach.ProcessCharacter(L'n');,9,<empty>,,2177,1089,CPPASTProblemDeclaration,,<empty>
599733,UNKNOWN,1090,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2179,1090,CPPASTProblemDeclaration,,<empty>
599734,UNKNOWN,1091,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::CursorPositionReport, pDispatch->_statusReportType);",9,<empty>,,2180,1091,CPPASTProblemDeclaration,,<empty>
599735,UNKNOWN,1092,,pDispatch->ClearState();,9,<empty>,,2182,1092,CPPASTProblemDeclaration,,<empty>
599736,UNKNOWN,1093,,"Log::Comment(L""Test 3: Check extended cursor position report (case ?6). Should succeed."");",9,<empty>,,2184,1093,CPPASTProblemDeclaration,,<empty>
599737,UNKNOWN,1094,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2185,1094,CPPASTProblemDeclaration,,<empty>
599738,UNKNOWN,1095,,mach.ProcessCharacter(L'[');,9,<empty>,,2186,1095,CPPASTProblemDeclaration,,<empty>
599739,UNKNOWN,1096,,mach.ProcessCharacter(L'?');,9,<empty>,,2187,1096,CPPASTProblemDeclaration,,<empty>
599740,UNKNOWN,1097,,mach.ProcessCharacter(L'6');,9,<empty>,,2188,1097,CPPASTProblemDeclaration,,<empty>
599741,UNKNOWN,1098,,mach.ProcessCharacter(L'n');,9,<empty>,,2189,1098,CPPASTProblemDeclaration,,<empty>
599742,UNKNOWN,1099,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2191,1099,CPPASTProblemDeclaration,,<empty>
599743,UNKNOWN,1100,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::ExtendedCursorPositionReport, pDispatch->_statusReportType);",9,<empty>,,2192,1100,CPPASTProblemDeclaration,,<empty>
599744,UNKNOWN,1101,,pDispatch->ClearState();,9,<empty>,,2194,1101,CPPASTProblemDeclaration,,<empty>
599745,UNKNOWN,1102,,"Log::Comment(L""Test 4: Check printer status (case ?15). Should succeed."");",9,<empty>,,2196,1102,CPPASTProblemDeclaration,,<empty>
599746,UNKNOWN,1103,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2197,1103,CPPASTProblemDeclaration,,<empty>
599747,UNKNOWN,1104,,mach.ProcessCharacter(L'[');,9,<empty>,,2198,1104,CPPASTProblemDeclaration,,<empty>
599748,UNKNOWN,1105,,mach.ProcessCharacter(L'?');,9,<empty>,,2199,1105,CPPASTProblemDeclaration,,<empty>
599749,UNKNOWN,1106,,mach.ProcessCharacter(L'1');,9,<empty>,,2200,1106,CPPASTProblemDeclaration,,<empty>
599750,UNKNOWN,1107,,mach.ProcessCharacter(L'5');,9,<empty>,,2201,1107,CPPASTProblemDeclaration,,<empty>
599751,UNKNOWN,1108,,mach.ProcessCharacter(L'n');,9,<empty>,,2202,1108,CPPASTProblemDeclaration,,<empty>
599752,UNKNOWN,1109,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2204,1109,CPPASTProblemDeclaration,,<empty>
599753,UNKNOWN,1110,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::PrinterStatus, pDispatch->_statusReportType);",9,<empty>,,2205,1110,CPPASTProblemDeclaration,,<empty>
599754,UNKNOWN,1111,,pDispatch->ClearState();,9,<empty>,,2207,1111,CPPASTProblemDeclaration,,<empty>
599755,UNKNOWN,1112,,"Log::Comment(L""Test 5: Check user-defined keys (case ?25). Should succeed."");",9,<empty>,,2209,1112,CPPASTProblemDeclaration,,<empty>
599756,UNKNOWN,1113,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2210,1113,CPPASTProblemDeclaration,,<empty>
599757,UNKNOWN,1114,,mach.ProcessCharacter(L'[');,9,<empty>,,2211,1114,CPPASTProblemDeclaration,,<empty>
599758,UNKNOWN,1115,,mach.ProcessCharacter(L'?');,9,<empty>,,2212,1115,CPPASTProblemDeclaration,,<empty>
599759,UNKNOWN,1116,,mach.ProcessCharacter(L'2');,9,<empty>,,2213,1116,CPPASTProblemDeclaration,,<empty>
599760,UNKNOWN,1117,,mach.ProcessCharacter(L'5');,9,<empty>,,2214,1117,CPPASTProblemDeclaration,,<empty>
599761,UNKNOWN,1118,,mach.ProcessCharacter(L'n');,9,<empty>,,2215,1118,CPPASTProblemDeclaration,,<empty>
599762,UNKNOWN,1119,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2217,1119,CPPASTProblemDeclaration,,<empty>
599763,UNKNOWN,1120,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::UserDefinedKeys, pDispatch->_statusReportType);",9,<empty>,,2218,1120,CPPASTProblemDeclaration,,<empty>
599764,UNKNOWN,1121,,pDispatch->ClearState();,9,<empty>,,2220,1121,CPPASTProblemDeclaration,,<empty>
599765,UNKNOWN,1122,,"Log::Comment(L""Test 6: Check keyboard status / dialect (case ?26). Should succeed."");",9,<empty>,,2222,1122,CPPASTProblemDeclaration,,<empty>
599766,UNKNOWN,1123,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2223,1123,CPPASTProblemDeclaration,,<empty>
599767,UNKNOWN,1124,,mach.ProcessCharacter(L'[');,9,<empty>,,2224,1124,CPPASTProblemDeclaration,,<empty>
599768,UNKNOWN,1125,,mach.ProcessCharacter(L'?');,9,<empty>,,2225,1125,CPPASTProblemDeclaration,,<empty>
599769,UNKNOWN,1126,,mach.ProcessCharacter(L'2');,9,<empty>,,2226,1126,CPPASTProblemDeclaration,,<empty>
599770,UNKNOWN,1127,,mach.ProcessCharacter(L'6');,9,<empty>,,2227,1127,CPPASTProblemDeclaration,,<empty>
599771,UNKNOWN,1128,,mach.ProcessCharacter(L'n');,9,<empty>,,2228,1128,CPPASTProblemDeclaration,,<empty>
599772,UNKNOWN,1129,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2230,1129,CPPASTProblemDeclaration,,<empty>
599773,UNKNOWN,1130,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::KeyboardStatus, pDispatch->_statusReportType);",9,<empty>,,2231,1130,CPPASTProblemDeclaration,,<empty>
599774,UNKNOWN,1131,,pDispatch->ClearState();,9,<empty>,,2233,1131,CPPASTProblemDeclaration,,<empty>
599775,UNKNOWN,1132,,"Log::Comment(L""Test 7: Check locator status (case ?55). Should succeed."");",9,<empty>,,2235,1132,CPPASTProblemDeclaration,,<empty>
599776,UNKNOWN,1133,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2236,1133,CPPASTProblemDeclaration,,<empty>
599777,UNKNOWN,1134,,mach.ProcessCharacter(L'[');,9,<empty>,,2237,1134,CPPASTProblemDeclaration,,<empty>
599778,UNKNOWN,1135,,mach.ProcessCharacter(L'?');,9,<empty>,,2238,1135,CPPASTProblemDeclaration,,<empty>
599779,UNKNOWN,1136,,mach.ProcessCharacter(L'5');,9,<empty>,,2239,1136,CPPASTProblemDeclaration,,<empty>
599780,UNKNOWN,1137,,mach.ProcessCharacter(L'5');,9,<empty>,,2240,1137,CPPASTProblemDeclaration,,<empty>
599781,UNKNOWN,1138,,mach.ProcessCharacter(L'n');,9,<empty>,,2241,1138,CPPASTProblemDeclaration,,<empty>
599782,UNKNOWN,1139,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2243,1139,CPPASTProblemDeclaration,,<empty>
599783,UNKNOWN,1140,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::LocatorStatus, pDispatch->_statusReportType);",9,<empty>,,2244,1140,CPPASTProblemDeclaration,,<empty>
599784,UNKNOWN,1141,,pDispatch->ClearState();,9,<empty>,,2246,1141,CPPASTProblemDeclaration,,<empty>
599785,UNKNOWN,1142,,"Log::Comment(L""Test 8: Check locator identity (case ?56). Should succeed."");",9,<empty>,,2248,1142,CPPASTProblemDeclaration,,<empty>
599786,UNKNOWN,1143,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2249,1143,CPPASTProblemDeclaration,,<empty>
599787,UNKNOWN,1144,,mach.ProcessCharacter(L'[');,9,<empty>,,2250,1144,CPPASTProblemDeclaration,,<empty>
599788,UNKNOWN,1145,,mach.ProcessCharacter(L'?');,9,<empty>,,2251,1145,CPPASTProblemDeclaration,,<empty>
599789,UNKNOWN,1146,,mach.ProcessCharacter(L'5');,9,<empty>,,2252,1146,CPPASTProblemDeclaration,,<empty>
599790,UNKNOWN,1147,,mach.ProcessCharacter(L'6');,9,<empty>,,2253,1147,CPPASTProblemDeclaration,,<empty>
599791,UNKNOWN,1148,,mach.ProcessCharacter(L'n');,9,<empty>,,2254,1148,CPPASTProblemDeclaration,,<empty>
599792,UNKNOWN,1149,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2256,1149,CPPASTProblemDeclaration,,<empty>
599793,UNKNOWN,1150,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::LocatorIdentity, pDispatch->_statusReportType);",9,<empty>,,2257,1150,CPPASTProblemDeclaration,,<empty>
599794,UNKNOWN,1151,,pDispatch->ClearState();,9,<empty>,,2259,1151,CPPASTProblemDeclaration,,<empty>
599795,UNKNOWN,1152,,"Log::Comment(L""Test 9: Check macro space report (case ?62). Should succeed."");",9,<empty>,,2261,1152,CPPASTProblemDeclaration,,<empty>
599796,UNKNOWN,1153,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2262,1153,CPPASTProblemDeclaration,,<empty>
599797,UNKNOWN,1154,,mach.ProcessCharacter(L'[');,9,<empty>,,2263,1154,CPPASTProblemDeclaration,,<empty>
599798,UNKNOWN,1155,,mach.ProcessCharacter(L'?');,9,<empty>,,2264,1155,CPPASTProblemDeclaration,,<empty>
599799,UNKNOWN,1156,,mach.ProcessCharacter(L'6');,9,<empty>,,2265,1156,CPPASTProblemDeclaration,,<empty>
599800,UNKNOWN,1157,,mach.ProcessCharacter(L'2');,9,<empty>,,2266,1157,CPPASTProblemDeclaration,,<empty>
599801,UNKNOWN,1158,,mach.ProcessCharacter(L'n');,9,<empty>,,2267,1158,CPPASTProblemDeclaration,,<empty>
599802,UNKNOWN,1159,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2269,1159,CPPASTProblemDeclaration,,<empty>
599803,UNKNOWN,1160,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::MacroSpaceReport, pDispatch->_statusReportType);",9,<empty>,,2270,1160,CPPASTProblemDeclaration,,<empty>
599804,UNKNOWN,1161,,pDispatch->ClearState();,9,<empty>,,2272,1161,CPPASTProblemDeclaration,,<empty>
599805,UNKNOWN,1162,,"Log::Comment(L""Test 10: Check memory checksum (case ?63). Should succeed."");",9,<empty>,,2274,1162,CPPASTProblemDeclaration,,<empty>
599806,UNKNOWN,1163,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2275,1163,CPPASTProblemDeclaration,,<empty>
599807,UNKNOWN,1164,,mach.ProcessCharacter(L'[');,9,<empty>,,2276,1164,CPPASTProblemDeclaration,,<empty>
599808,UNKNOWN,1165,,mach.ProcessCharacter(L'?');,9,<empty>,,2277,1165,CPPASTProblemDeclaration,,<empty>
599809,UNKNOWN,1166,,mach.ProcessCharacter(L'6');,9,<empty>,,2278,1166,CPPASTProblemDeclaration,,<empty>
599810,UNKNOWN,1167,,mach.ProcessCharacter(L'3');,9,<empty>,,2279,1167,CPPASTProblemDeclaration,,<empty>
599811,UNKNOWN,1168,,mach.ProcessCharacter(L'n');,9,<empty>,,2280,1168,CPPASTProblemDeclaration,,<empty>
599812,UNKNOWN,1169,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2282,1169,CPPASTProblemDeclaration,,<empty>
599813,UNKNOWN,1170,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::MemoryChecksum, pDispatch->_statusReportType);",9,<empty>,,2283,1170,CPPASTProblemDeclaration,,<empty>
599814,UNKNOWN,1171,,pDispatch->ClearState();,9,<empty>,,2285,1171,CPPASTProblemDeclaration,,<empty>
599815,UNKNOWN,1172,,"Log::Comment(L""Test 11: Check data integrity report (case ?75). Should succeed."");",9,<empty>,,2287,1172,CPPASTProblemDeclaration,,<empty>
599816,UNKNOWN,1173,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2288,1173,CPPASTProblemDeclaration,,<empty>
599817,UNKNOWN,1174,,mach.ProcessCharacter(L'[');,9,<empty>,,2289,1174,CPPASTProblemDeclaration,,<empty>
599818,UNKNOWN,1175,,mach.ProcessCharacter(L'?');,9,<empty>,,2290,1175,CPPASTProblemDeclaration,,<empty>
599819,UNKNOWN,1176,,mach.ProcessCharacter(L'7');,9,<empty>,,2291,1176,CPPASTProblemDeclaration,,<empty>
599820,UNKNOWN,1177,,mach.ProcessCharacter(L'5');,9,<empty>,,2292,1177,CPPASTProblemDeclaration,,<empty>
599821,UNKNOWN,1178,,mach.ProcessCharacter(L'n');,9,<empty>,,2293,1178,CPPASTProblemDeclaration,,<empty>
599822,UNKNOWN,1179,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2295,1179,CPPASTProblemDeclaration,,<empty>
599823,UNKNOWN,1180,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::DataIntegrity, pDispatch->_statusReportType);",9,<empty>,,2296,1180,CPPASTProblemDeclaration,,<empty>
599824,UNKNOWN,1181,,pDispatch->ClearState();,9,<empty>,,2298,1181,CPPASTProblemDeclaration,,<empty>
599825,UNKNOWN,1182,,"Log::Comment(L""Test 12: Check multiple session status (case ?85). Should succeed."");",9,<empty>,,2300,1182,CPPASTProblemDeclaration,,<empty>
599826,UNKNOWN,1183,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2301,1183,CPPASTProblemDeclaration,,<empty>
599827,UNKNOWN,1184,,mach.ProcessCharacter(L'[');,9,<empty>,,2302,1184,CPPASTProblemDeclaration,,<empty>
599828,UNKNOWN,1185,,mach.ProcessCharacter(L'?');,9,<empty>,,2303,1185,CPPASTProblemDeclaration,,<empty>
599829,UNKNOWN,1186,,mach.ProcessCharacter(L'8');,9,<empty>,,2304,1186,CPPASTProblemDeclaration,,<empty>
599830,UNKNOWN,1187,,mach.ProcessCharacter(L'5');,9,<empty>,,2305,1187,CPPASTProblemDeclaration,,<empty>
599831,UNKNOWN,1188,,mach.ProcessCharacter(L'n');,9,<empty>,,2306,1188,CPPASTProblemDeclaration,,<empty>
599832,UNKNOWN,1189,,VERIFY_IS_TRUE(pDispatch->_deviceStatusReport);,9,<empty>,,2308,1189,CPPASTProblemDeclaration,,<empty>
599833,UNKNOWN,1190,,"VERIFY_ARE_EQUAL(DispatchTypes::StatusType::MultipleSessionStatus, pDispatch->_statusReportType);",9,<empty>,,2309,1190,CPPASTProblemDeclaration,,<empty>
599834,UNKNOWN,1191,,pDispatch->ClearState();,9,<empty>,,2311,1191,CPPASTProblemDeclaration,,<empty>
599835,UNKNOWN,1192,,},5,<empty>,,2312,1192,CPPASTProblemDeclaration,,<empty>
599836,UNKNOWN,1193,,"TEST_METHOD(TestDeviceAttributes)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2314,1193,CPPASTProblemDeclaration,,<empty>
599858,UNKNOWN,1198,,"Log::Comment(L""Test 1: Check default case, no params."");",9,<empty>,,2321,1198,CPPASTProblemDeclaration,,<empty>
599859,UNKNOWN,1199,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2322,1199,CPPASTProblemDeclaration,,<empty>
599860,UNKNOWN,1200,,mach.ProcessCharacter(L'[');,9,<empty>,,2323,1200,CPPASTProblemDeclaration,,<empty>
599861,UNKNOWN,1201,,mach.ProcessCharacter(L'c');,9,<empty>,,2324,1201,CPPASTProblemDeclaration,,<empty>
599862,UNKNOWN,1202,,VERIFY_IS_TRUE(pDispatch->_deviceAttributes);,9,<empty>,,2326,1202,CPPASTProblemDeclaration,,<empty>
599863,UNKNOWN,1203,,pDispatch->ClearState();,9,<empty>,,2328,1203,CPPASTProblemDeclaration,,<empty>
599864,UNKNOWN,1204,,"Log::Comment(L""Test 2: Check default case, 0 param."");",9,<empty>,,2330,1204,CPPASTProblemDeclaration,,<empty>
599865,UNKNOWN,1205,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2331,1205,CPPASTProblemDeclaration,,<empty>
599866,UNKNOWN,1206,,mach.ProcessCharacter(L'[');,9,<empty>,,2332,1206,CPPASTProblemDeclaration,,<empty>
599867,UNKNOWN,1207,,mach.ProcessCharacter(L'0');,9,<empty>,,2333,1207,CPPASTProblemDeclaration,,<empty>
599868,UNKNOWN,1208,,mach.ProcessCharacter(L'c');,9,<empty>,,2334,1208,CPPASTProblemDeclaration,,<empty>
599869,UNKNOWN,1209,,VERIFY_IS_TRUE(pDispatch->_deviceAttributes);,9,<empty>,,2336,1209,CPPASTProblemDeclaration,,<empty>
599870,UNKNOWN,1210,,pDispatch->ClearState();,9,<empty>,,2338,1210,CPPASTProblemDeclaration,,<empty>
599871,UNKNOWN,1211,,"Log::Comment(L""Test 3: Check fail case, 1 (or any other) param."");",9,<empty>,,2340,1211,CPPASTProblemDeclaration,,<empty>
599872,UNKNOWN,1212,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2341,1212,CPPASTProblemDeclaration,,<empty>
599873,UNKNOWN,1213,,mach.ProcessCharacter(L'[');,9,<empty>,,2342,1213,CPPASTProblemDeclaration,,<empty>
599874,UNKNOWN,1214,,mach.ProcessCharacter(L'1');,9,<empty>,,2343,1214,CPPASTProblemDeclaration,,<empty>
599875,UNKNOWN,1215,,mach.ProcessCharacter(L'c');,9,<empty>,,2344,1215,CPPASTProblemDeclaration,,<empty>
599876,UNKNOWN,1216,,VERIFY_IS_FALSE(pDispatch->_deviceAttributes);,9,<empty>,,2346,1216,CPPASTProblemDeclaration,,<empty>
599877,UNKNOWN,1217,,pDispatch->ClearState();,9,<empty>,,2348,1217,CPPASTProblemDeclaration,,<empty>
599878,UNKNOWN,1218,,},5,<empty>,,2349,1218,CPPASTProblemDeclaration,,<empty>
599879,UNKNOWN,1219,,"TEST_METHOD(TestSecondaryDeviceAttributes)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2351,1219,CPPASTProblemDeclaration,,<empty>
599901,UNKNOWN,1224,,"Log::Comment(L""Test 1: Check default case, no params."");",9,<empty>,,2358,1224,CPPASTProblemDeclaration,,<empty>
599902,UNKNOWN,1225,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2359,1225,CPPASTProblemDeclaration,,<empty>
599903,UNKNOWN,1226,,mach.ProcessCharacter(L'[');,9,<empty>,,2360,1226,CPPASTProblemDeclaration,,<empty>
599904,UNKNOWN,1227,,mach.ProcessCharacter(L'>');,9,<empty>,,2361,1227,CPPASTProblemDeclaration,,<empty>
599905,UNKNOWN,1228,,mach.ProcessCharacter(L'c');,9,<empty>,,2362,1228,CPPASTProblemDeclaration,,<empty>
599906,UNKNOWN,1229,,VERIFY_IS_TRUE(pDispatch->_secondaryDeviceAttributes);,9,<empty>,,2364,1229,CPPASTProblemDeclaration,,<empty>
599907,UNKNOWN,1230,,pDispatch->ClearState();,9,<empty>,,2366,1230,CPPASTProblemDeclaration,,<empty>
599908,UNKNOWN,1231,,"Log::Comment(L""Test 2: Check default case, 0 param."");",9,<empty>,,2368,1231,CPPASTProblemDeclaration,,<empty>
599909,UNKNOWN,1232,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2369,1232,CPPASTProblemDeclaration,,<empty>
599910,UNKNOWN,1233,,mach.ProcessCharacter(L'[');,9,<empty>,,2370,1233,CPPASTProblemDeclaration,,<empty>
599911,UNKNOWN,1234,,mach.ProcessCharacter(L'>');,9,<empty>,,2371,1234,CPPASTProblemDeclaration,,<empty>
599912,UNKNOWN,1235,,mach.ProcessCharacter(L'0');,9,<empty>,,2372,1235,CPPASTProblemDeclaration,,<empty>
599913,UNKNOWN,1236,,mach.ProcessCharacter(L'c');,9,<empty>,,2373,1236,CPPASTProblemDeclaration,,<empty>
599914,UNKNOWN,1237,,VERIFY_IS_TRUE(pDispatch->_secondaryDeviceAttributes);,9,<empty>,,2375,1237,CPPASTProblemDeclaration,,<empty>
599915,UNKNOWN,1238,,pDispatch->ClearState();,9,<empty>,,2377,1238,CPPASTProblemDeclaration,,<empty>
599916,UNKNOWN,1239,,"Log::Comment(L""Test 3: Check fail case, 1 (or any other) param."");",9,<empty>,,2379,1239,CPPASTProblemDeclaration,,<empty>
599917,UNKNOWN,1240,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2380,1240,CPPASTProblemDeclaration,,<empty>
599918,UNKNOWN,1241,,mach.ProcessCharacter(L'[');,9,<empty>,,2381,1241,CPPASTProblemDeclaration,,<empty>
599919,UNKNOWN,1242,,mach.ProcessCharacter(L'>');,9,<empty>,,2382,1242,CPPASTProblemDeclaration,,<empty>
599920,UNKNOWN,1243,,mach.ProcessCharacter(L'1');,9,<empty>,,2383,1243,CPPASTProblemDeclaration,,<empty>
599921,UNKNOWN,1244,,mach.ProcessCharacter(L'c');,9,<empty>,,2384,1244,CPPASTProblemDeclaration,,<empty>
599922,UNKNOWN,1245,,VERIFY_IS_FALSE(pDispatch->_secondaryDeviceAttributes);,9,<empty>,,2386,1245,CPPASTProblemDeclaration,,<empty>
599923,UNKNOWN,1246,,pDispatch->ClearState();,9,<empty>,,2388,1246,CPPASTProblemDeclaration,,<empty>
599924,UNKNOWN,1247,,},5,<empty>,,2389,1247,CPPASTProblemDeclaration,,<empty>
599925,UNKNOWN,1248,,"TEST_METHOD(TestTertiaryDeviceAttributes)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2391,1248,CPPASTProblemDeclaration,,<empty>
599947,UNKNOWN,1253,,"Log::Comment(L""Test 1: Check default case, no params."");",9,<empty>,,2398,1253,CPPASTProblemDeclaration,,<empty>
599948,UNKNOWN,1254,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2399,1254,CPPASTProblemDeclaration,,<empty>
599949,UNKNOWN,1255,,mach.ProcessCharacter(L'[');,9,<empty>,,2400,1255,CPPASTProblemDeclaration,,<empty>
599950,UNKNOWN,1256,,mach.ProcessCharacter(L'=');,9,<empty>,,2401,1256,CPPASTProblemDeclaration,,<empty>
599951,UNKNOWN,1257,,mach.ProcessCharacter(L'c');,9,<empty>,,2402,1257,CPPASTProblemDeclaration,,<empty>
599952,UNKNOWN,1258,,VERIFY_IS_TRUE(pDispatch->_tertiaryDeviceAttributes);,9,<empty>,,2404,1258,CPPASTProblemDeclaration,,<empty>
599953,UNKNOWN,1259,,pDispatch->ClearState();,9,<empty>,,2406,1259,CPPASTProblemDeclaration,,<empty>
599954,UNKNOWN,1260,,"Log::Comment(L""Test 2: Check default case, 0 param."");",9,<empty>,,2408,1260,CPPASTProblemDeclaration,,<empty>
599955,UNKNOWN,1261,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2409,1261,CPPASTProblemDeclaration,,<empty>
599956,UNKNOWN,1262,,mach.ProcessCharacter(L'[');,9,<empty>,,2410,1262,CPPASTProblemDeclaration,,<empty>
599957,UNKNOWN,1263,,mach.ProcessCharacter(L'=');,9,<empty>,,2411,1263,CPPASTProblemDeclaration,,<empty>
599958,UNKNOWN,1264,,mach.ProcessCharacter(L'0');,9,<empty>,,2412,1264,CPPASTProblemDeclaration,,<empty>
599959,UNKNOWN,1265,,mach.ProcessCharacter(L'c');,9,<empty>,,2413,1265,CPPASTProblemDeclaration,,<empty>
599960,UNKNOWN,1266,,VERIFY_IS_TRUE(pDispatch->_tertiaryDeviceAttributes);,9,<empty>,,2415,1266,CPPASTProblemDeclaration,,<empty>
599961,UNKNOWN,1267,,pDispatch->ClearState();,9,<empty>,,2417,1267,CPPASTProblemDeclaration,,<empty>
599962,UNKNOWN,1268,,"Log::Comment(L""Test 3: Check fail case, 1 (or any other) param."");",9,<empty>,,2419,1268,CPPASTProblemDeclaration,,<empty>
599963,UNKNOWN,1269,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2420,1269,CPPASTProblemDeclaration,,<empty>
599964,UNKNOWN,1270,,mach.ProcessCharacter(L'[');,9,<empty>,,2421,1270,CPPASTProblemDeclaration,,<empty>
599965,UNKNOWN,1271,,mach.ProcessCharacter(L'=');,9,<empty>,,2422,1271,CPPASTProblemDeclaration,,<empty>
599966,UNKNOWN,1272,,mach.ProcessCharacter(L'1');,9,<empty>,,2423,1272,CPPASTProblemDeclaration,,<empty>
599967,UNKNOWN,1273,,mach.ProcessCharacter(L'c');,9,<empty>,,2424,1273,CPPASTProblemDeclaration,,<empty>
599968,UNKNOWN,1274,,VERIFY_IS_FALSE(pDispatch->_tertiaryDeviceAttributes);,9,<empty>,,2426,1274,CPPASTProblemDeclaration,,<empty>
599969,UNKNOWN,1275,,pDispatch->ClearState();,9,<empty>,,2428,1275,CPPASTProblemDeclaration,,<empty>
599970,UNKNOWN,1276,,},5,<empty>,,2429,1276,CPPASTProblemDeclaration,,<empty>
599971,UNKNOWN,1277,,"TEST_METHOD(TestRequestTerminalParameters)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2431,1277,CPPASTProblemDeclaration,,<empty>
599993,UNKNOWN,1282,,"Log::Comment(L""Test 1: Check default case, no params."");",9,<empty>,,2438,1282,CPPASTProblemDeclaration,,<empty>
599994,UNKNOWN,1283,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2439,1283,CPPASTProblemDeclaration,,<empty>
599995,UNKNOWN,1284,,mach.ProcessCharacter(L'[');,9,<empty>,,2440,1284,CPPASTProblemDeclaration,,<empty>
599996,UNKNOWN,1285,,mach.ProcessCharacter(L'x');,9,<empty>,,2441,1285,CPPASTProblemDeclaration,,<empty>
599997,UNKNOWN,1286,,VERIFY_IS_TRUE(pDispatch->_requestTerminalParameters);,9,<empty>,,2443,1286,CPPASTProblemDeclaration,,<empty>
599998,UNKNOWN,1287,,"VERIFY_ARE_EQUAL(DispatchTypes::ReportingPermission::Unsolicited, pDispatch->_reportingPermission);",9,<empty>,,2444,1287,CPPASTProblemDeclaration,,<empty>
599999,UNKNOWN,1288,,pDispatch->ClearState();,9,<empty>,,2446,1288,CPPASTProblemDeclaration,,<empty>
600000,UNKNOWN,1289,,"Log::Comment(L""Test 2: Check unsolicited permission, 0 param."");",9,<empty>,,2448,1289,CPPASTProblemDeclaration,,<empty>
600001,UNKNOWN,1290,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2449,1290,CPPASTProblemDeclaration,,<empty>
600002,UNKNOWN,1291,,mach.ProcessCharacter(L'[');,9,<empty>,,2450,1291,CPPASTProblemDeclaration,,<empty>
600003,UNKNOWN,1292,,mach.ProcessCharacter(L'0');,9,<empty>,,2451,1292,CPPASTProblemDeclaration,,<empty>
600004,UNKNOWN,1293,,mach.ProcessCharacter(L'x');,9,<empty>,,2452,1293,CPPASTProblemDeclaration,,<empty>
600005,UNKNOWN,1294,,VERIFY_IS_TRUE(pDispatch->_requestTerminalParameters);,9,<empty>,,2454,1294,CPPASTProblemDeclaration,,<empty>
600006,UNKNOWN,1295,,"VERIFY_ARE_EQUAL(DispatchTypes::ReportingPermission::Unsolicited, pDispatch->_reportingPermission);",9,<empty>,,2455,1295,CPPASTProblemDeclaration,,<empty>
600007,UNKNOWN,1296,,"Log::Comment(L""Test 3: Check solicited permission, 1 param."");",9,<empty>,,2457,1296,CPPASTProblemDeclaration,,<empty>
600008,UNKNOWN,1297,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2458,1297,CPPASTProblemDeclaration,,<empty>
600009,UNKNOWN,1298,,mach.ProcessCharacter(L'[');,9,<empty>,,2459,1298,CPPASTProblemDeclaration,,<empty>
600010,UNKNOWN,1299,,mach.ProcessCharacter(L'1');,9,<empty>,,2460,1299,CPPASTProblemDeclaration,,<empty>
600011,UNKNOWN,1300,,mach.ProcessCharacter(L'x');,9,<empty>,,2461,1300,CPPASTProblemDeclaration,,<empty>
600012,UNKNOWN,1301,,VERIFY_IS_TRUE(pDispatch->_requestTerminalParameters);,9,<empty>,,2463,1301,CPPASTProblemDeclaration,,<empty>
600013,UNKNOWN,1302,,"VERIFY_ARE_EQUAL(DispatchTypes::ReportingPermission::Solicited, pDispatch->_reportingPermission);",9,<empty>,,2464,1302,CPPASTProblemDeclaration,,<empty>
600014,UNKNOWN,1303,,pDispatch->ClearState();,9,<empty>,,2466,1303,CPPASTProblemDeclaration,,<empty>
600015,UNKNOWN,1304,,},5,<empty>,,2467,1304,CPPASTProblemDeclaration,,<empty>
600016,UNKNOWN,1305,,"TEST_METHOD(TestStrings)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2469,1305,CPPASTProblemDeclaration,,<empty>
600042,UNKNOWN,1313,,"Log::Comment(L""Test 1: Basic String processing. One sequence in a string."");",9,<empty>,,2480,1313,CPPASTProblemDeclaration,,<empty>
600043,UNKNOWN,1314,,"mach.ProcessString(L""\x1b[0m"");",9,<empty>,,2481,1314,CPPASTProblemDeclaration,,<empty>
600044,UNKNOWN,1315,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2483,1315,CPPASTProblemDeclaration,,<empty>
600045,UNKNOWN,1316,,pDispatch->ClearState();,9,<empty>,,2485,1316,CPPASTProblemDeclaration,,<empty>
600046,UNKNOWN,1317,,"Log::Comment(L""Test 2: A couple of sequences all in one string"");",9,<empty>,,2489,1317,CPPASTProblemDeclaration,,<empty>
600047,UNKNOWN,1318,,"mach.ProcessString(L""\x1b[1;4;7;30;45;53m\x1b[2J"");",9,<empty>,,2491,1318,CPPASTProblemDeclaration,,<empty>
600048,UNKNOWN,1319,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2492,1319,CPPASTProblemDeclaration,,<empty>
600049,UNKNOWN,1320,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,2493,1320,CPPASTProblemDeclaration,,<empty>
600050,UNKNOWN,1321,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2495,1321,CPPASTProblemDeclaration,,<empty>
600051,UNKNOWN,1322,,rgExpected[1] = DispatchTypes::GraphicsOptions::Underline;,9,<empty>,,2496,1322,CPPASTProblemDeclaration,,<empty>
600052,UNKNOWN,1323,,rgExpected[2] = DispatchTypes::GraphicsOptions::Negative;,9,<empty>,,2497,1323,CPPASTProblemDeclaration,,<empty>
600053,UNKNOWN,1324,,rgExpected[3] = DispatchTypes::GraphicsOptions::ForegroundBlack;,9,<empty>,,2498,1324,CPPASTProblemDeclaration,,<empty>
600054,UNKNOWN,1325,,rgExpected[4] = DispatchTypes::GraphicsOptions::BackgroundMagenta;,9,<empty>,,2499,1325,CPPASTProblemDeclaration,,<empty>
600055,UNKNOWN,1326,,rgExpected[5] = DispatchTypes::GraphicsOptions::Overline;,9,<empty>,,2500,1326,CPPASTProblemDeclaration,,<empty>
600056,UNKNOWN,1327,,expectedDispatchTypes = DispatchTypes::EraseType::All;,9,<empty>,,2501,1327,CPPASTProblemDeclaration,,<empty>
600057,UNKNOWN,1328,,"VerifyDispatchTypes({ rgExpected, 6 }",9,<empty>,,2502,1328,CPPASTProblemDeclaration,,<empty>
600058,UNKNOWN,1329,,", *pDispatch);",46,<empty>,,2502,1329,CPPASTProblemDeclaration,,<empty>
600059,UNKNOWN,1330,,"VERIFY_ARE_EQUAL(expectedDispatchTypes, pDispatch->_eraseType);",9,<empty>,,2503,1330,CPPASTProblemDeclaration,,<empty>
600060,UNKNOWN,1331,,pDispatch->ClearState();,9,<empty>,,2505,1331,CPPASTProblemDeclaration,,<empty>
600061,UNKNOWN,1332,,"Log::Comment(L""Test 3: Two sequences separated by a non-sequence of characters"");",9,<empty>,,2508,1332,CPPASTProblemDeclaration,,<empty>
600062,UNKNOWN,1333,,"mach.ProcessString(L""\x1b[1;30mHello World\x1b[2J"");",9,<empty>,,2510,1333,CPPASTProblemDeclaration,,<empty>
600063,UNKNOWN,1334,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2512,1334,CPPASTProblemDeclaration,,<empty>
600064,UNKNOWN,1335,,rgExpected[1] = DispatchTypes::GraphicsOptions::ForegroundBlack;,9,<empty>,,2513,1335,CPPASTProblemDeclaration,,<empty>
600065,UNKNOWN,1336,,expectedDispatchTypes = DispatchTypes::EraseType::All;,9,<empty>,,2514,1336,CPPASTProblemDeclaration,,<empty>
600066,UNKNOWN,1337,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2516,1337,CPPASTProblemDeclaration,,<empty>
600067,UNKNOWN,1338,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,2517,1338,CPPASTProblemDeclaration,,<empty>
600068,UNKNOWN,1339,,"VerifyDispatchTypes({ rgExpected, 2 }",9,<empty>,,2519,1339,CPPASTProblemDeclaration,,<empty>
600069,UNKNOWN,1340,,", *pDispatch);",46,<empty>,,2519,1340,CPPASTProblemDeclaration,,<empty>
600070,UNKNOWN,1341,,"VERIFY_ARE_EQUAL(expectedDispatchTypes, pDispatch->_eraseType);",9,<empty>,,2520,1341,CPPASTProblemDeclaration,,<empty>
600071,UNKNOWN,1342,,pDispatch->ClearState();,9,<empty>,,2522,1342,CPPASTProblemDeclaration,,<empty>
600072,UNKNOWN,1343,,"Log::Comment(L""Test 4: An entire sequence broke into multiple strings"");",9,<empty>,,2525,1343,CPPASTProblemDeclaration,,<empty>
600073,UNKNOWN,1344,,"mach.ProcessString(L""\x1b[1;"");",9,<empty>,,2526,1344,CPPASTProblemDeclaration,,<empty>
600074,UNKNOWN,1345,,VERIFY_IS_FALSE(pDispatch->_setGraphics);,9,<empty>,,2527,1345,CPPASTProblemDeclaration,,<empty>
600075,UNKNOWN,1346,,VERIFY_IS_FALSE(pDispatch->_eraseDisplay);,9,<empty>,,2528,1346,CPPASTProblemDeclaration,,<empty>
600076,UNKNOWN,1347,,"mach.ProcessString(L""30mHello World\x1b[2J"");",9,<empty>,,2530,1347,CPPASTProblemDeclaration,,<empty>
600077,UNKNOWN,1348,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2532,1348,CPPASTProblemDeclaration,,<empty>
600078,UNKNOWN,1349,,rgExpected[1] = DispatchTypes::GraphicsOptions::ForegroundBlack;,9,<empty>,,2533,1349,CPPASTProblemDeclaration,,<empty>
600079,UNKNOWN,1350,,expectedDispatchTypes = DispatchTypes::EraseType::All;,9,<empty>,,2534,1350,CPPASTProblemDeclaration,,<empty>
600080,UNKNOWN,1351,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2536,1351,CPPASTProblemDeclaration,,<empty>
600081,UNKNOWN,1352,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,2537,1352,CPPASTProblemDeclaration,,<empty>
600082,UNKNOWN,1353,,"VerifyDispatchTypes({ rgExpected, 2 }",9,<empty>,,2539,1353,CPPASTProblemDeclaration,,<empty>
600083,UNKNOWN,1354,,", *pDispatch);",46,<empty>,,2539,1354,CPPASTProblemDeclaration,,<empty>
600084,UNKNOWN,1355,,"VERIFY_ARE_EQUAL(expectedDispatchTypes, pDispatch->_eraseType);",9,<empty>,,2540,1355,CPPASTProblemDeclaration,,<empty>
600085,UNKNOWN,1356,,pDispatch->ClearState();,9,<empty>,,2542,1356,CPPASTProblemDeclaration,,<empty>
600086,UNKNOWN,1357,,"Log::Comment(L""Test 5: A sequence with mixed ProcessCharacter and ProcessString calls"");",9,<empty>,,2545,1357,CPPASTProblemDeclaration,,<empty>
600087,UNKNOWN,1358,,rgExpected[0] = DispatchTypes::GraphicsOptions::Intense;,9,<empty>,,2547,1358,CPPASTProblemDeclaration,,<empty>
600088,UNKNOWN,1359,,rgExpected[1] = DispatchTypes::GraphicsOptions::ForegroundBlack;,9,<empty>,,2548,1359,CPPASTProblemDeclaration,,<empty>
600089,UNKNOWN,1360,,"mach.ProcessString(L""\x1b[1;"");",9,<empty>,,2550,1360,CPPASTProblemDeclaration,,<empty>
600090,UNKNOWN,1361,,VERIFY_IS_FALSE(pDispatch->_setGraphics);,9,<empty>,,2551,1361,CPPASTProblemDeclaration,,<empty>
600091,UNKNOWN,1362,,VERIFY_IS_FALSE(pDispatch->_eraseDisplay);,9,<empty>,,2552,1362,CPPASTProblemDeclaration,,<empty>
600092,UNKNOWN,1363,,mach.ProcessCharacter(L'3');,9,<empty>,,2554,1363,CPPASTProblemDeclaration,,<empty>
600093,UNKNOWN,1364,,VERIFY_IS_FALSE(pDispatch->_setGraphics);,9,<empty>,,2555,1364,CPPASTProblemDeclaration,,<empty>
600094,UNKNOWN,1365,,VERIFY_IS_FALSE(pDispatch->_eraseDisplay);,9,<empty>,,2556,1365,CPPASTProblemDeclaration,,<empty>
600095,UNKNOWN,1366,,mach.ProcessCharacter(L'0');,9,<empty>,,2558,1366,CPPASTProblemDeclaration,,<empty>
600096,UNKNOWN,1367,,VERIFY_IS_FALSE(pDispatch->_setGraphics);,9,<empty>,,2559,1367,CPPASTProblemDeclaration,,<empty>
600097,UNKNOWN,1368,,VERIFY_IS_FALSE(pDispatch->_eraseDisplay);,9,<empty>,,2560,1368,CPPASTProblemDeclaration,,<empty>
600098,UNKNOWN,1369,,mach.ProcessCharacter(L'm');,9,<empty>,,2562,1369,CPPASTProblemDeclaration,,<empty>
600099,UNKNOWN,1370,,VERIFY_IS_TRUE(pDispatch->_setGraphics);,9,<empty>,,2564,1370,CPPASTProblemDeclaration,,<empty>
600100,UNKNOWN,1371,,VERIFY_IS_FALSE(pDispatch->_eraseDisplay);,9,<empty>,,2565,1371,CPPASTProblemDeclaration,,<empty>
600101,UNKNOWN,1372,,"VerifyDispatchTypes({ rgExpected, 2 }",9,<empty>,,2566,1372,CPPASTProblemDeclaration,,<empty>
600102,UNKNOWN,1373,,", *pDispatch);",46,<empty>,,2566,1373,CPPASTProblemDeclaration,,<empty>
600103,UNKNOWN,1374,,"mach.ProcessString(L""Hello World\x1b[2J"");",9,<empty>,,2568,1374,CPPASTProblemDeclaration,,<empty>
600104,UNKNOWN,1375,,expectedDispatchTypes = DispatchTypes::EraseType::All;,9,<empty>,,2570,1375,CPPASTProblemDeclaration,,<empty>
600105,UNKNOWN,1376,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,2572,1376,CPPASTProblemDeclaration,,<empty>
600106,UNKNOWN,1377,,"VERIFY_ARE_EQUAL(expectedDispatchTypes, pDispatch->_eraseType);",9,<empty>,,2574,1377,CPPASTProblemDeclaration,,<empty>
600107,UNKNOWN,1378,,pDispatch->ClearState();,9,<empty>,,2576,1378,CPPASTProblemDeclaration,,<empty>
600108,UNKNOWN,1379,,},5,<empty>,,2577,1379,CPPASTProblemDeclaration,,<empty>
600109,UNKNOWN,1380,,"TEST_METHOD(TestLineFeed)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2579,1380,CPPASTProblemDeclaration,,<empty>
600131,UNKNOWN,1385,,"Log::Comment(L""IND (Index) escape sequence"");",9,<empty>,,2586,1385,CPPASTProblemDeclaration,,<empty>
600132,UNKNOWN,1386,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2587,1386,CPPASTProblemDeclaration,,<empty>
600133,UNKNOWN,1387,,mach.ProcessCharacter(L'D');,9,<empty>,,2588,1387,CPPASTProblemDeclaration,,<empty>
600134,UNKNOWN,1388,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,2590,1388,CPPASTProblemDeclaration,,<empty>
600135,UNKNOWN,1389,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::WithoutReturn, pDispatch->_lineFeedType);",9,<empty>,,2591,1389,CPPASTProblemDeclaration,,<empty>
600136,UNKNOWN,1390,,pDispatch->ClearState();,9,<empty>,,2593,1390,CPPASTProblemDeclaration,,<empty>
600137,UNKNOWN,1391,,"Log::Comment(L""NEL (Next Line) escape sequence"");",9,<empty>,,2595,1391,CPPASTProblemDeclaration,,<empty>
600138,UNKNOWN,1392,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2596,1392,CPPASTProblemDeclaration,,<empty>
600139,UNKNOWN,1393,,mach.ProcessCharacter(L'E');,9,<empty>,,2597,1393,CPPASTProblemDeclaration,,<empty>
600140,UNKNOWN,1394,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,2599,1394,CPPASTProblemDeclaration,,<empty>
600141,UNKNOWN,1395,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::WithReturn, pDispatch->_lineFeedType);",9,<empty>,,2600,1395,CPPASTProblemDeclaration,,<empty>
600142,UNKNOWN,1396,,pDispatch->ClearState();,9,<empty>,,2602,1396,CPPASTProblemDeclaration,,<empty>
600143,UNKNOWN,1397,,"Log::Comment(L""LF (Line Feed) control code"");",9,<empty>,,2604,1397,CPPASTProblemDeclaration,,<empty>
600144,UNKNOWN,1398,,mach.ProcessCharacter(AsciiChars::LF);,9,<empty>,,2605,1398,CPPASTProblemDeclaration,,<empty>
600145,UNKNOWN,1399,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,2607,1399,CPPASTProblemDeclaration,,<empty>
600146,UNKNOWN,1400,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::DependsOnMode, pDispatch->_lineFeedType);",9,<empty>,,2608,1400,CPPASTProblemDeclaration,,<empty>
600147,UNKNOWN,1401,,pDispatch->ClearState();,9,<empty>,,2610,1401,CPPASTProblemDeclaration,,<empty>
600148,UNKNOWN,1402,,"Log::Comment(L""FF (Form Feed) control code"");",9,<empty>,,2612,1402,CPPASTProblemDeclaration,,<empty>
600149,UNKNOWN,1403,,mach.ProcessCharacter(AsciiChars::FF);,9,<empty>,,2613,1403,CPPASTProblemDeclaration,,<empty>
600150,UNKNOWN,1404,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,2615,1404,CPPASTProblemDeclaration,,<empty>
600151,UNKNOWN,1405,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::DependsOnMode, pDispatch->_lineFeedType);",9,<empty>,,2616,1405,CPPASTProblemDeclaration,,<empty>
600152,UNKNOWN,1406,,pDispatch->ClearState();,9,<empty>,,2618,1406,CPPASTProblemDeclaration,,<empty>
600153,UNKNOWN,1407,,"Log::Comment(L""VT (Vertical Tab) control code"");",9,<empty>,,2620,1407,CPPASTProblemDeclaration,,<empty>
600154,UNKNOWN,1408,,mach.ProcessCharacter(AsciiChars::VT);,9,<empty>,,2621,1408,CPPASTProblemDeclaration,,<empty>
600155,UNKNOWN,1409,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,2623,1409,CPPASTProblemDeclaration,,<empty>
600156,UNKNOWN,1410,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::DependsOnMode, pDispatch->_lineFeedType);",9,<empty>,,2624,1410,CPPASTProblemDeclaration,,<empty>
600157,UNKNOWN,1411,,pDispatch->ClearState();,9,<empty>,,2626,1411,CPPASTProblemDeclaration,,<empty>
600158,UNKNOWN,1412,,},5,<empty>,,2627,1412,CPPASTProblemDeclaration,,<empty>
600159,UNKNOWN,1413,,"TEST_METHOD(TestControlCharacters)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2629,1413,CPPASTProblemDeclaration,,<empty>
600181,UNKNOWN,1418,,"Log::Comment(L""BEL (Warning Bell) control character"");",9,<empty>,,2636,1418,CPPASTProblemDeclaration,,<empty>
600182,UNKNOWN,1419,,mach.ProcessCharacter(AsciiChars::BEL);,9,<empty>,,2637,1419,CPPASTProblemDeclaration,,<empty>
600183,UNKNOWN,1420,,VERIFY_IS_TRUE(pDispatch->_warningBell);,9,<empty>,,2639,1420,CPPASTProblemDeclaration,,<empty>
600184,UNKNOWN,1421,,pDispatch->ClearState();,9,<empty>,,2641,1421,CPPASTProblemDeclaration,,<empty>
600185,UNKNOWN,1422,,"Log::Comment(L""BS (Back Space) control character"");",9,<empty>,,2643,1422,CPPASTProblemDeclaration,,<empty>
600186,UNKNOWN,1423,,mach.ProcessCharacter(AsciiChars::BS);,9,<empty>,,2644,1423,CPPASTProblemDeclaration,,<empty>
600187,UNKNOWN,1424,,VERIFY_IS_TRUE(pDispatch->_cursorBackward);,9,<empty>,,2646,1424,CPPASTProblemDeclaration,,<empty>
600188,UNKNOWN,1425,,"VERIFY_ARE_EQUAL(1u, pDispatch->_cursorDistance);",9,<empty>,,2647,1425,CPPASTProblemDeclaration,,<empty>
600189,UNKNOWN,1426,,pDispatch->ClearState();,9,<empty>,,2649,1426,CPPASTProblemDeclaration,,<empty>
600190,UNKNOWN,1427,,"Log::Comment(L""CR (Carriage Return) control character"");",9,<empty>,,2651,1427,CPPASTProblemDeclaration,,<empty>
600191,UNKNOWN,1428,,mach.ProcessCharacter(AsciiChars::CR);,9,<empty>,,2652,1428,CPPASTProblemDeclaration,,<empty>
600192,UNKNOWN,1429,,VERIFY_IS_TRUE(pDispatch->_carriageReturn);,9,<empty>,,2654,1429,CPPASTProblemDeclaration,,<empty>
600193,UNKNOWN,1430,,pDispatch->ClearState();,9,<empty>,,2656,1430,CPPASTProblemDeclaration,,<empty>
600194,UNKNOWN,1431,,"Log::Comment(L""HT (Horizontal Tab) control character"");",9,<empty>,,2658,1431,CPPASTProblemDeclaration,,<empty>
600195,UNKNOWN,1432,,mach.ProcessCharacter(AsciiChars::TAB);,9,<empty>,,2659,1432,CPPASTProblemDeclaration,,<empty>
600196,UNKNOWN,1433,,VERIFY_IS_TRUE(pDispatch->_forwardTab);,9,<empty>,,2661,1433,CPPASTProblemDeclaration,,<empty>
600197,UNKNOWN,1434,,"VERIFY_ARE_EQUAL(1u, pDispatch->_numTabs);",9,<empty>,,2662,1434,CPPASTProblemDeclaration,,<empty>
600198,UNKNOWN,1435,,pDispatch->ClearState();,9,<empty>,,2664,1435,CPPASTProblemDeclaration,,<empty>
600199,UNKNOWN,1436,,},5,<empty>,,2665,1436,CPPASTProblemDeclaration,,<empty>
600200,UNKNOWN,1437,,"TEST_METHOD(TestTabClear)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2667,1437,CPPASTProblemDeclaration,,<empty>
600222,UNKNOWN,1442,,"mach.ProcessString(L""\x1b[g"");",9,<empty>,,2674,1442,CPPASTProblemDeclaration,,<empty>
600233,UNKNOWN,1445,,VERIFY_IS_TRUE(pDispatch->_tabClear);,9,<empty>,,2676,1445,CPPASTProblemDeclaration,,<empty>
600234,UNKNOWN,1446,,"VERIFY_ARE_EQUAL(expectedClearTypes, pDispatch->_tabClearTypes);",9,<empty>,,2677,1446,CPPASTProblemDeclaration,,<empty>
600235,UNKNOWN,1447,,pDispatch->ClearState();,9,<empty>,,2679,1447,CPPASTProblemDeclaration,,<empty>
600236,UNKNOWN,1448,,"mach.ProcessString(L""\x1b[3g"");",9,<empty>,,2681,1448,CPPASTProblemDeclaration,,<empty>
600237,UNKNOWN,1449,,expectedClearTypes = std::vector{ DispatchTypes::TabClearType::ClearAllColumns };,9,<empty>,,2682,1449,CPPASTProblemDeclaration,,<empty>
600238,UNKNOWN,1450,,VERIFY_IS_TRUE(pDispatch->_tabClear);,9,<empty>,,2683,1450,CPPASTProblemDeclaration,,<empty>
600239,UNKNOWN,1451,,"VERIFY_ARE_EQUAL(expectedClearTypes, pDispatch->_tabClearTypes);",9,<empty>,,2684,1451,CPPASTProblemDeclaration,,<empty>
600240,UNKNOWN,1452,,pDispatch->ClearState();,9,<empty>,,2686,1452,CPPASTProblemDeclaration,,<empty>
600241,UNKNOWN,1453,,"mach.ProcessString(L""\x1b[0;3g"");",9,<empty>,,2688,1453,CPPASTProblemDeclaration,,<empty>
600242,UNKNOWN,1454,,"expectedClearTypes = std::vector{ DispatchTypes::TabClearType::ClearCurrentColumn, DispatchTypes::TabClearType::ClearAllColumns };",9,<empty>,,2689,1454,CPPASTProblemDeclaration,,<empty>
600243,UNKNOWN,1455,,VERIFY_IS_TRUE(pDispatch->_tabClear);,9,<empty>,,2690,1455,CPPASTProblemDeclaration,,<empty>
600244,UNKNOWN,1456,,"VERIFY_ARE_EQUAL(expectedClearTypes, pDispatch->_tabClearTypes);",9,<empty>,,2691,1456,CPPASTProblemDeclaration,,<empty>
600245,UNKNOWN,1457,,pDispatch->ClearState();,9,<empty>,,2693,1457,CPPASTProblemDeclaration,,<empty>
600246,UNKNOWN,1458,,},5,<empty>,,2694,1458,CPPASTProblemDeclaration,,<empty>
600247,UNKNOWN,1459,,"TEST_METHOD(TestVt52Sequences)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2696,1459,CPPASTProblemDeclaration,,<empty>
600269,UNKNOWN,1464,,"mach.SetParserMode(StateMachine::Mode::Ansi, false);",9,<empty>,,2704,1464,CPPASTProblemDeclaration,,<empty>
600270,UNKNOWN,1465,,"Log::Comment(L""Cursor Up"");",9,<empty>,,2706,1465,CPPASTProblemDeclaration,,<empty>
600271,UNKNOWN,1466,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2707,1466,CPPASTProblemDeclaration,,<empty>
600272,UNKNOWN,1467,,mach.ProcessCharacter(L'A');,9,<empty>,,2708,1467,CPPASTProblemDeclaration,,<empty>
600273,UNKNOWN,1468,,VERIFY_IS_TRUE(pDispatch->_cursorUp);,9,<empty>,,2709,1468,CPPASTProblemDeclaration,,<empty>
600274,UNKNOWN,1469,,"VERIFY_ARE_EQUAL(1u, pDispatch->_cursorDistance);",9,<empty>,,2710,1469,CPPASTProblemDeclaration,,<empty>
600275,UNKNOWN,1470,,pDispatch->ClearState();,9,<empty>,,2712,1470,CPPASTProblemDeclaration,,<empty>
600276,UNKNOWN,1471,,"Log::Comment(L""Cursor Down"");",9,<empty>,,2714,1471,CPPASTProblemDeclaration,,<empty>
600277,UNKNOWN,1472,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2715,1472,CPPASTProblemDeclaration,,<empty>
600278,UNKNOWN,1473,,mach.ProcessCharacter(L'B');,9,<empty>,,2716,1473,CPPASTProblemDeclaration,,<empty>
600279,UNKNOWN,1474,,VERIFY_IS_TRUE(pDispatch->_cursorDown);,9,<empty>,,2717,1474,CPPASTProblemDeclaration,,<empty>
600280,UNKNOWN,1475,,"VERIFY_ARE_EQUAL(1u, pDispatch->_cursorDistance);",9,<empty>,,2718,1475,CPPASTProblemDeclaration,,<empty>
600281,UNKNOWN,1476,,pDispatch->ClearState();,9,<empty>,,2720,1476,CPPASTProblemDeclaration,,<empty>
600282,UNKNOWN,1477,,"Log::Comment(L""Cursor Right"");",9,<empty>,,2722,1477,CPPASTProblemDeclaration,,<empty>
600283,UNKNOWN,1478,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2723,1478,CPPASTProblemDeclaration,,<empty>
600284,UNKNOWN,1479,,mach.ProcessCharacter(L'C');,9,<empty>,,2724,1479,CPPASTProblemDeclaration,,<empty>
600285,UNKNOWN,1480,,VERIFY_IS_TRUE(pDispatch->_cursorForward);,9,<empty>,,2725,1480,CPPASTProblemDeclaration,,<empty>
600286,UNKNOWN,1481,,"VERIFY_ARE_EQUAL(1u, pDispatch->_cursorDistance);",9,<empty>,,2726,1481,CPPASTProblemDeclaration,,<empty>
600287,UNKNOWN,1482,,pDispatch->ClearState();,9,<empty>,,2728,1482,CPPASTProblemDeclaration,,<empty>
600288,UNKNOWN,1483,,"Log::Comment(L""Cursor Left"");",9,<empty>,,2730,1483,CPPASTProblemDeclaration,,<empty>
600289,UNKNOWN,1484,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2731,1484,CPPASTProblemDeclaration,,<empty>
600290,UNKNOWN,1485,,mach.ProcessCharacter(L'D');,9,<empty>,,2732,1485,CPPASTProblemDeclaration,,<empty>
600291,UNKNOWN,1486,,VERIFY_IS_TRUE(pDispatch->_cursorBackward);,9,<empty>,,2733,1486,CPPASTProblemDeclaration,,<empty>
600292,UNKNOWN,1487,,"VERIFY_ARE_EQUAL(1u, pDispatch->_cursorDistance);",9,<empty>,,2734,1487,CPPASTProblemDeclaration,,<empty>
600293,UNKNOWN,1488,,pDispatch->ClearState();,9,<empty>,,2736,1488,CPPASTProblemDeclaration,,<empty>
600294,UNKNOWN,1489,,"Log::Comment(L""Cursor to Home"");",9,<empty>,,2738,1489,CPPASTProblemDeclaration,,<empty>
600295,UNKNOWN,1490,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2739,1490,CPPASTProblemDeclaration,,<empty>
600296,UNKNOWN,1491,,mach.ProcessCharacter(L'H');,9,<empty>,,2740,1491,CPPASTProblemDeclaration,,<empty>
600297,UNKNOWN,1492,,VERIFY_IS_TRUE(pDispatch->_cursorPosition);,9,<empty>,,2741,1492,CPPASTProblemDeclaration,,<empty>
600298,UNKNOWN,1493,,"VERIFY_ARE_EQUAL(1u, pDispatch->_line);",9,<empty>,,2742,1493,CPPASTProblemDeclaration,,<empty>
600299,UNKNOWN,1494,,"VERIFY_ARE_EQUAL(1u, pDispatch->_column);",9,<empty>,,2743,1494,CPPASTProblemDeclaration,,<empty>
600300,UNKNOWN,1495,,pDispatch->ClearState();,9,<empty>,,2745,1495,CPPASTProblemDeclaration,,<empty>
600301,UNKNOWN,1496,,"Log::Comment(L""Reverse Line Feed"");",9,<empty>,,2747,1496,CPPASTProblemDeclaration,,<empty>
600302,UNKNOWN,1497,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2748,1497,CPPASTProblemDeclaration,,<empty>
600303,UNKNOWN,1498,,mach.ProcessCharacter(L'I');,9,<empty>,,2749,1498,CPPASTProblemDeclaration,,<empty>
600304,UNKNOWN,1499,,VERIFY_IS_TRUE(pDispatch->_reverseLineFeed);,9,<empty>,,2750,1499,CPPASTProblemDeclaration,,<empty>
600305,UNKNOWN,1500,,pDispatch->ClearState();,9,<empty>,,2752,1500,CPPASTProblemDeclaration,,<empty>
600306,UNKNOWN,1501,,"Log::Comment(L""Erase to End of Screen"");",9,<empty>,,2754,1501,CPPASTProblemDeclaration,,<empty>
600307,UNKNOWN,1502,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2755,1502,CPPASTProblemDeclaration,,<empty>
600308,UNKNOWN,1503,,mach.ProcessCharacter(L'J');,9,<empty>,,2756,1503,CPPASTProblemDeclaration,,<empty>
600309,UNKNOWN,1504,,VERIFY_IS_TRUE(pDispatch->_eraseDisplay);,9,<empty>,,2757,1504,CPPASTProblemDeclaration,,<empty>
600310,UNKNOWN,1505,,"VERIFY_ARE_EQUAL(DispatchTypes::EraseType::ToEnd, pDispatch->_eraseType);",9,<empty>,,2758,1505,CPPASTProblemDeclaration,,<empty>
600311,UNKNOWN,1506,,pDispatch->ClearState();,9,<empty>,,2760,1506,CPPASTProblemDeclaration,,<empty>
600312,UNKNOWN,1507,,"Log::Comment(L""Erase to End of Line"");",9,<empty>,,2762,1507,CPPASTProblemDeclaration,,<empty>
600313,UNKNOWN,1508,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2763,1508,CPPASTProblemDeclaration,,<empty>
600314,UNKNOWN,1509,,mach.ProcessCharacter(L'K');,9,<empty>,,2764,1509,CPPASTProblemDeclaration,,<empty>
600315,UNKNOWN,1510,,VERIFY_IS_TRUE(pDispatch->_eraseLine);,9,<empty>,,2765,1510,CPPASTProblemDeclaration,,<empty>
600316,UNKNOWN,1511,,"VERIFY_ARE_EQUAL(DispatchTypes::EraseType::ToEnd, pDispatch->_eraseType);",9,<empty>,,2766,1511,CPPASTProblemDeclaration,,<empty>
600317,UNKNOWN,1512,,pDispatch->ClearState();,9,<empty>,,2768,1512,CPPASTProblemDeclaration,,<empty>
600318,UNKNOWN,1513,,"Log::Comment(L""Direct Cursor Address"");",9,<empty>,,2770,1513,CPPASTProblemDeclaration,,<empty>
600319,UNKNOWN,1514,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2771,1514,CPPASTProblemDeclaration,,<empty>
600320,UNKNOWN,1515,,mach.ProcessCharacter(L'Y');,9,<empty>,,2772,1515,CPPASTProblemDeclaration,,<empty>
600321,UNKNOWN,1516,,mach.ProcessCharacter(L' ' + 3);,9,<empty>,,2773,1516,CPPASTProblemDeclaration,,<empty>
600322,UNKNOWN,1517,,mach.ProcessCharacter(L' ' + 5);,9,<empty>,,2774,1517,CPPASTProblemDeclaration,,<empty>
600323,UNKNOWN,1518,,VERIFY_IS_TRUE(pDispatch->_cursorPosition);,9,<empty>,,2775,1518,CPPASTProblemDeclaration,,<empty>
600324,UNKNOWN,1519,,"VERIFY_ARE_EQUAL(3u, pDispatch->_line - 1);",9,<empty>,,2776,1519,CPPASTProblemDeclaration,,<empty>
600325,UNKNOWN,1520,,"VERIFY_ARE_EQUAL(5u, pDispatch->_column - 1);",9,<empty>,,2777,1520,CPPASTProblemDeclaration,,<empty>
600326,UNKNOWN,1521,,pDispatch->ClearState();,9,<empty>,,2779,1521,CPPASTProblemDeclaration,,<empty>
600327,UNKNOWN,1522,,},5,<empty>,,2780,1522,CPPASTProblemDeclaration,,<empty>
600328,UNKNOWN,1523,,"TEST_METHOD(TestIdentifyDeviceReport)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2782,1523,CPPASTProblemDeclaration,,<empty>
600350,UNKNOWN,1528,,"Log::Comment(L""Identify Device in VT52 mode."");",9,<empty>,,2789,1528,CPPASTProblemDeclaration,,<empty>
600351,UNKNOWN,1529,,"mach.SetParserMode(StateMachine::Mode::Ansi, false);",9,<empty>,,2790,1529,CPPASTProblemDeclaration,,<empty>
600352,UNKNOWN,1530,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2791,1530,CPPASTProblemDeclaration,,<empty>
600353,UNKNOWN,1531,,mach.ProcessCharacter(L'Z');,9,<empty>,,2792,1531,CPPASTProblemDeclaration,,<empty>
600354,UNKNOWN,1532,,VERIFY_IS_TRUE(pDispatch->_vt52DeviceAttributes);,9,<empty>,,2793,1532,CPPASTProblemDeclaration,,<empty>
600355,UNKNOWN,1533,,VERIFY_IS_FALSE(pDispatch->_deviceAttributes);,9,<empty>,,2794,1533,CPPASTProblemDeclaration,,<empty>
600356,UNKNOWN,1534,,pDispatch->ClearState();,9,<empty>,,2796,1534,CPPASTProblemDeclaration,,<empty>
600357,UNKNOWN,1535,,"Log::Comment(L""Identify Device in ANSI mode."");",9,<empty>,,2798,1535,CPPASTProblemDeclaration,,<empty>
600358,UNKNOWN,1536,,"mach.SetParserMode(StateMachine::Mode::Ansi, true);",9,<empty>,,2799,1536,CPPASTProblemDeclaration,,<empty>
600359,UNKNOWN,1537,,mach.ProcessCharacter(AsciiChars::ESC);,9,<empty>,,2800,1537,CPPASTProblemDeclaration,,<empty>
600360,UNKNOWN,1538,,mach.ProcessCharacter(L'Z');,9,<empty>,,2801,1538,CPPASTProblemDeclaration,,<empty>
600361,UNKNOWN,1539,,VERIFY_IS_TRUE(pDispatch->_deviceAttributes);,9,<empty>,,2802,1539,CPPASTProblemDeclaration,,<empty>
600362,UNKNOWN,1540,,VERIFY_IS_FALSE(pDispatch->_vt52DeviceAttributes);,9,<empty>,,2803,1540,CPPASTProblemDeclaration,,<empty>
600363,UNKNOWN,1541,,pDispatch->ClearState();,9,<empty>,,2805,1541,CPPASTProblemDeclaration,,<empty>
600364,UNKNOWN,1542,,},5,<empty>,,2806,1542,CPPASTProblemDeclaration,,<empty>
600365,UNKNOWN,1543,,"TEST_METHOD(TestOscSetDefaultForeground)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2808,1543,CPPASTProblemDeclaration,,<empty>
600387,UNKNOWN,1548,,"mach.ProcessString(L""\033]10;rgb:1/1/1\033\\"");",9,<empty>,,2816,1548,CPPASTProblemDeclaration,,<empty>
600388,UNKNOWN,1549,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2817,1549,CPPASTProblemDeclaration,,<empty>
600389,UNKNOWN,1550,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultForegroundColor);",9,<empty>,,2818,1550,CPPASTProblemDeclaration,,<empty>
600390,UNKNOWN,1551,,pDispatch->ClearState();,9,<empty>,,2820,1551,CPPASTProblemDeclaration,,<empty>
600391,UNKNOWN,1552,,"mach.ProcessString(L""\033]10;rgb:12/34/56\033\\"");",9,<empty>,,2822,1552,CPPASTProblemDeclaration,,<empty>
600392,UNKNOWN,1553,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2823,1553,CPPASTProblemDeclaration,,<empty>
600393,UNKNOWN,1554,,"VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultForegroundColor);",9,<empty>,,2824,1554,CPPASTProblemDeclaration,,<empty>
600394,UNKNOWN,1555,,pDispatch->ClearState();,9,<empty>,,2826,1555,CPPASTProblemDeclaration,,<empty>
600395,UNKNOWN,1556,,"mach.ProcessString(L""\033]10;#111\033\\"");",9,<empty>,,2828,1556,CPPASTProblemDeclaration,,<empty>
600396,UNKNOWN,1557,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2829,1557,CPPASTProblemDeclaration,,<empty>
600397,UNKNOWN,1558,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2830,1558,CPPASTProblemDeclaration,,<empty>
600398,UNKNOWN,1559,,pDispatch->ClearState();,9,<empty>,,2832,1559,CPPASTProblemDeclaration,,<empty>
600399,UNKNOWN,1560,,"mach.ProcessString(L""\033]10;#123456\033\\"");",9,<empty>,,2834,1560,CPPASTProblemDeclaration,,<empty>
600400,UNKNOWN,1561,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2835,1561,CPPASTProblemDeclaration,,<empty>
600401,UNKNOWN,1562,,"VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultForegroundColor);",9,<empty>,,2836,1562,CPPASTProblemDeclaration,,<empty>
600402,UNKNOWN,1563,,pDispatch->ClearState();,9,<empty>,,2838,1563,CPPASTProblemDeclaration,,<empty>
600403,UNKNOWN,1564,,"mach.ProcessString(L""\033]10;DarkOrange\033\\"");",9,<empty>,,2840,1564,CPPASTProblemDeclaration,,<empty>
600404,UNKNOWN,1565,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2841,1565,CPPASTProblemDeclaration,,<empty>
600405,UNKNOWN,1566,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultForegroundColor);",9,<empty>,,2842,1566,CPPASTProblemDeclaration,,<empty>
600406,UNKNOWN,1567,,pDispatch->ClearState();,9,<empty>,,2844,1567,CPPASTProblemDeclaration,,<empty>
600407,UNKNOWN,1568,,"mach.ProcessString(L""\033]10;#111;rgb:2/2/2\033\\"");",9,<empty>,,2847,1568,CPPASTProblemDeclaration,,<empty>
600408,UNKNOWN,1569,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2848,1569,CPPASTProblemDeclaration,,<empty>
600409,UNKNOWN,1570,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2849,1570,CPPASTProblemDeclaration,,<empty>
600410,UNKNOWN,1571,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2850,1571,CPPASTProblemDeclaration,,<empty>
600411,UNKNOWN,1572,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultBackgroundColor);",9,<empty>,,2851,1572,CPPASTProblemDeclaration,,<empty>
600412,UNKNOWN,1573,,pDispatch->ClearState();,9,<empty>,,2853,1573,CPPASTProblemDeclaration,,<empty>
600413,UNKNOWN,1574,,"mach.ProcessString(L""\033]10;#111;DarkOrange\033\\"");",9,<empty>,,2855,1574,CPPASTProblemDeclaration,,<empty>
600414,UNKNOWN,1575,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2856,1575,CPPASTProblemDeclaration,,<empty>
600415,UNKNOWN,1576,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2857,1576,CPPASTProblemDeclaration,,<empty>
600416,UNKNOWN,1577,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2858,1577,CPPASTProblemDeclaration,,<empty>
600417,UNKNOWN,1578,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);",9,<empty>,,2859,1578,CPPASTProblemDeclaration,,<empty>
600418,UNKNOWN,1579,,pDispatch->ClearState();,9,<empty>,,2861,1579,CPPASTProblemDeclaration,,<empty>
600419,UNKNOWN,1580,,"mach.ProcessString(L""\033]10;#111;DarkOrange;rgb:2/2/2\033\\"");",9,<empty>,,2863,1580,CPPASTProblemDeclaration,,<empty>
600420,UNKNOWN,1581,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2864,1581,CPPASTProblemDeclaration,,<empty>
600421,UNKNOWN,1582,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2865,1582,CPPASTProblemDeclaration,,<empty>
600422,UNKNOWN,1583,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2866,1583,CPPASTProblemDeclaration,,<empty>
600423,UNKNOWN,1584,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);",9,<empty>,,2867,1584,CPPASTProblemDeclaration,,<empty>
600424,UNKNOWN,1585,,VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);,9,<empty>,,2868,1585,CPPASTProblemDeclaration,,<empty>
600425,UNKNOWN,1586,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultCursorColor);",9,<empty>,,2869,1586,CPPASTProblemDeclaration,,<empty>
600426,UNKNOWN,1587,,pDispatch->ClearState();,9,<empty>,,2871,1587,CPPASTProblemDeclaration,,<empty>
600427,UNKNOWN,1588,,"mach.ProcessString(L""\033]10;#111;\033\\"");",9,<empty>,,2874,1588,CPPASTProblemDeclaration,,<empty>
600428,UNKNOWN,1589,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2875,1589,CPPASTProblemDeclaration,,<empty>
600429,UNKNOWN,1590,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2876,1590,CPPASTProblemDeclaration,,<empty>
600430,UNKNOWN,1591,,pDispatch->ClearState();,9,<empty>,,2878,1591,CPPASTProblemDeclaration,,<empty>
600431,UNKNOWN,1592,,"mach.ProcessString(L""\033]10;#111;rgb:\033\\"");",9,<empty>,,2880,1592,CPPASTProblemDeclaration,,<empty>
600432,UNKNOWN,1593,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2881,1593,CPPASTProblemDeclaration,,<empty>
600433,UNKNOWN,1594,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2882,1594,CPPASTProblemDeclaration,,<empty>
600434,UNKNOWN,1595,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,2883,1595,CPPASTProblemDeclaration,,<empty>
600435,UNKNOWN,1596,,pDispatch->ClearState();,9,<empty>,,2885,1596,CPPASTProblemDeclaration,,<empty>
600436,UNKNOWN,1597,,"mach.ProcessString(L""\033]10;#111;#2\033\\"");",9,<empty>,,2887,1597,CPPASTProblemDeclaration,,<empty>
600437,UNKNOWN,1598,,VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);,9,<empty>,,2888,1598,CPPASTProblemDeclaration,,<empty>
600438,UNKNOWN,1599,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);",9,<empty>,,2889,1599,CPPASTProblemDeclaration,,<empty>
600439,UNKNOWN,1600,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,2890,1600,CPPASTProblemDeclaration,,<empty>
600440,UNKNOWN,1601,,pDispatch->ClearState();,9,<empty>,,2892,1601,CPPASTProblemDeclaration,,<empty>
600441,UNKNOWN,1602,,"mach.ProcessString(L""\033]10;;rgb:1/1/1\033\\"");",9,<empty>,,2894,1602,CPPASTProblemDeclaration,,<empty>
600442,UNKNOWN,1603,,VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);,9,<empty>,,2895,1603,CPPASTProblemDeclaration,,<empty>
600443,UNKNOWN,1604,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2896,1604,CPPASTProblemDeclaration,,<empty>
600444,UNKNOWN,1605,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);",9,<empty>,,2897,1605,CPPASTProblemDeclaration,,<empty>
600445,UNKNOWN,1606,,pDispatch->ClearState();,9,<empty>,,2899,1606,CPPASTProblemDeclaration,,<empty>
600446,UNKNOWN,1607,,"mach.ProcessString(L""\033]10;#1;rgb:1/1/1\033\\"");",9,<empty>,,2901,1607,CPPASTProblemDeclaration,,<empty>
600447,UNKNOWN,1608,,VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);,9,<empty>,,2902,1608,CPPASTProblemDeclaration,,<empty>
600448,UNKNOWN,1609,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2903,1609,CPPASTProblemDeclaration,,<empty>
600449,UNKNOWN,1610,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);",9,<empty>,,2904,1610,CPPASTProblemDeclaration,,<empty>
600450,UNKNOWN,1611,,pDispatch->ClearState();,9,<empty>,,2906,1611,CPPASTProblemDeclaration,,<empty>
600451,UNKNOWN,1612,,"mach.ProcessString(L""\033]10;rgb:1/1/\033\\"");",9,<empty>,,2909,1612,CPPASTProblemDeclaration,,<empty>
600452,UNKNOWN,1613,,VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);,9,<empty>,,2910,1613,CPPASTProblemDeclaration,,<empty>
600453,UNKNOWN,1614,,pDispatch->ClearState();,9,<empty>,,2912,1614,CPPASTProblemDeclaration,,<empty>
600454,UNKNOWN,1615,,"mach.ProcessString(L""\033]10;#1\033\\"");",9,<empty>,,2914,1615,CPPASTProblemDeclaration,,<empty>
600455,UNKNOWN,1616,,VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);,9,<empty>,,2915,1616,CPPASTProblemDeclaration,,<empty>
600456,UNKNOWN,1617,,pDispatch->ClearState();,9,<empty>,,2917,1617,CPPASTProblemDeclaration,,<empty>
600457,UNKNOWN,1618,,},5,<empty>,,2918,1618,CPPASTProblemDeclaration,,<empty>
600458,UNKNOWN,1619,,"TEST_METHOD(TestOscSetDefaultBackground)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,2920,1619,CPPASTProblemDeclaration,,<empty>
600480,UNKNOWN,1624,,"mach.ProcessString(L""\033]11;rgb:1/1/1\033\\"");",9,<empty>,,2927,1624,CPPASTProblemDeclaration,,<empty>
600481,UNKNOWN,1625,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2928,1625,CPPASTProblemDeclaration,,<empty>
600482,UNKNOWN,1626,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);",9,<empty>,,2929,1626,CPPASTProblemDeclaration,,<empty>
600483,UNKNOWN,1627,,pDispatch->ClearState();,9,<empty>,,2931,1627,CPPASTProblemDeclaration,,<empty>
600484,UNKNOWN,1628,,"mach.ProcessString(L""\033]11;rgb:12/34/56\033\\"");",9,<empty>,,2934,1628,CPPASTProblemDeclaration,,<empty>
600485,UNKNOWN,1629,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2935,1629,CPPASTProblemDeclaration,,<empty>
600486,UNKNOWN,1630,,"VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultBackgroundColor);",9,<empty>,,2936,1630,CPPASTProblemDeclaration,,<empty>
600487,UNKNOWN,1631,,pDispatch->ClearState();,9,<empty>,,2938,1631,CPPASTProblemDeclaration,,<empty>
600488,UNKNOWN,1632,,"mach.ProcessString(L""\033]11;#111\033\\"");",9,<empty>,,2940,1632,CPPASTProblemDeclaration,,<empty>
600489,UNKNOWN,1633,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2941,1633,CPPASTProblemDeclaration,,<empty>
600490,UNKNOWN,1634,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2942,1634,CPPASTProblemDeclaration,,<empty>
600491,UNKNOWN,1635,,pDispatch->ClearState();,9,<empty>,,2944,1635,CPPASTProblemDeclaration,,<empty>
600492,UNKNOWN,1636,,"mach.ProcessString(L""\033]11;#123456\033\\"");",9,<empty>,,2946,1636,CPPASTProblemDeclaration,,<empty>
600493,UNKNOWN,1637,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2947,1637,CPPASTProblemDeclaration,,<empty>
600494,UNKNOWN,1638,,"VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultBackgroundColor);",9,<empty>,,2948,1638,CPPASTProblemDeclaration,,<empty>
600495,UNKNOWN,1639,,pDispatch->ClearState();,9,<empty>,,2950,1639,CPPASTProblemDeclaration,,<empty>
600496,UNKNOWN,1640,,"mach.ProcessString(L""\033]11;DarkOrange\033\\"");",9,<empty>,,2952,1640,CPPASTProblemDeclaration,,<empty>
600497,UNKNOWN,1641,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2953,1641,CPPASTProblemDeclaration,,<empty>
600498,UNKNOWN,1642,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);",9,<empty>,,2954,1642,CPPASTProblemDeclaration,,<empty>
600499,UNKNOWN,1643,,pDispatch->ClearState();,9,<empty>,,2956,1643,CPPASTProblemDeclaration,,<empty>
600500,UNKNOWN,1644,,"mach.ProcessString(L""\033]11;#111;rgb:2/2/2\033\\"");",9,<empty>,,2959,1644,CPPASTProblemDeclaration,,<empty>
600501,UNKNOWN,1645,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2960,1645,CPPASTProblemDeclaration,,<empty>
600502,UNKNOWN,1646,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2961,1646,CPPASTProblemDeclaration,,<empty>
600503,UNKNOWN,1647,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultCursorColor);",9,<empty>,,2962,1647,CPPASTProblemDeclaration,,<empty>
600504,UNKNOWN,1648,,pDispatch->ClearState();,9,<empty>,,2964,1648,CPPASTProblemDeclaration,,<empty>
600505,UNKNOWN,1649,,"mach.ProcessString(L""\033]11;#111;DarkOrange\033\\"");",9,<empty>,,2966,1649,CPPASTProblemDeclaration,,<empty>
600506,UNKNOWN,1650,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2967,1650,CPPASTProblemDeclaration,,<empty>
600507,UNKNOWN,1651,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2968,1651,CPPASTProblemDeclaration,,<empty>
600508,UNKNOWN,1652,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultCursorColor);",9,<empty>,,2969,1652,CPPASTProblemDeclaration,,<empty>
600509,UNKNOWN,1653,,pDispatch->ClearState();,9,<empty>,,2971,1653,CPPASTProblemDeclaration,,<empty>
600510,UNKNOWN,1654,,"mach.ProcessString(L""\033]11;#111;DarkOrange;rgb:2/2/2\033\\"");",9,<empty>,,2973,1654,CPPASTProblemDeclaration,,<empty>
600511,UNKNOWN,1655,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2974,1655,CPPASTProblemDeclaration,,<empty>
600512,UNKNOWN,1656,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2975,1656,CPPASTProblemDeclaration,,<empty>
600513,UNKNOWN,1657,,"VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultCursorColor);",9,<empty>,,2976,1657,CPPASTProblemDeclaration,,<empty>
600514,UNKNOWN,1658,,pDispatch->ClearState();,9,<empty>,,2979,1658,CPPASTProblemDeclaration,,<empty>
600515,UNKNOWN,1659,,"mach.ProcessString(L""\033]11;#111;\033\\"");",9,<empty>,,2982,1659,CPPASTProblemDeclaration,,<empty>
600516,UNKNOWN,1660,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2983,1660,CPPASTProblemDeclaration,,<empty>
600517,UNKNOWN,1661,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2984,1661,CPPASTProblemDeclaration,,<empty>
600518,UNKNOWN,1662,,pDispatch->ClearState();,9,<empty>,,2986,1662,CPPASTProblemDeclaration,,<empty>
600519,UNKNOWN,1663,,"mach.ProcessString(L""\033]11;#111;rgb:\033\\"");",9,<empty>,,2988,1663,CPPASTProblemDeclaration,,<empty>
600520,UNKNOWN,1664,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2989,1664,CPPASTProblemDeclaration,,<empty>
600521,UNKNOWN,1665,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2990,1665,CPPASTProblemDeclaration,,<empty>
600522,UNKNOWN,1666,,pDispatch->ClearState();,9,<empty>,,2992,1666,CPPASTProblemDeclaration,,<empty>
600523,UNKNOWN,1667,,"mach.ProcessString(L""\033]11;#111;#2\033\\"");",9,<empty>,,2994,1667,CPPASTProblemDeclaration,,<empty>
600524,UNKNOWN,1668,,VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);,9,<empty>,,2995,1668,CPPASTProblemDeclaration,,<empty>
600525,UNKNOWN,1669,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);",9,<empty>,,2996,1669,CPPASTProblemDeclaration,,<empty>
600526,UNKNOWN,1670,,pDispatch->ClearState();,9,<empty>,,2998,1670,CPPASTProblemDeclaration,,<empty>
600527,UNKNOWN,1671,,"mach.ProcessString(L""\033]11;;rgb:1/1/1\033\\"");",9,<empty>,,3000,1671,CPPASTProblemDeclaration,,<empty>
600528,UNKNOWN,1672,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,3001,1672,CPPASTProblemDeclaration,,<empty>
600529,UNKNOWN,1673,,VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);,9,<empty>,,3002,1673,CPPASTProblemDeclaration,,<empty>
600530,UNKNOWN,1674,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultCursorColor);",9,<empty>,,3003,1674,CPPASTProblemDeclaration,,<empty>
600531,UNKNOWN,1675,,pDispatch->ClearState();,9,<empty>,,3005,1675,CPPASTProblemDeclaration,,<empty>
600532,UNKNOWN,1676,,"mach.ProcessString(L""\033]11;#1;rgb:1/1/1\033\\"");",9,<empty>,,3007,1676,CPPASTProblemDeclaration,,<empty>
600533,UNKNOWN,1677,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,3008,1677,CPPASTProblemDeclaration,,<empty>
600534,UNKNOWN,1678,,VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);,9,<empty>,,3009,1678,CPPASTProblemDeclaration,,<empty>
600535,UNKNOWN,1679,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultCursorColor);",9,<empty>,,3010,1679,CPPASTProblemDeclaration,,<empty>
600536,UNKNOWN,1680,,pDispatch->ClearState();,9,<empty>,,3012,1680,CPPASTProblemDeclaration,,<empty>
600537,UNKNOWN,1681,,"mach.ProcessString(L""\033]11;rgb:1/1/\033\\"");",9,<empty>,,3015,1681,CPPASTProblemDeclaration,,<empty>
600538,UNKNOWN,1682,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,3016,1682,CPPASTProblemDeclaration,,<empty>
600539,UNKNOWN,1683,,pDispatch->ClearState();,9,<empty>,,3018,1683,CPPASTProblemDeclaration,,<empty>
600540,UNKNOWN,1684,,"mach.ProcessString(L""\033]11;#1\033\\"");",9,<empty>,,3020,1684,CPPASTProblemDeclaration,,<empty>
600541,UNKNOWN,1685,,VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);,9,<empty>,,3021,1685,CPPASTProblemDeclaration,,<empty>
600542,UNKNOWN,1686,,pDispatch->ClearState();,9,<empty>,,3023,1686,CPPASTProblemDeclaration,,<empty>
600543,UNKNOWN,1687,,},5,<empty>,,3024,1687,CPPASTProblemDeclaration,,<empty>
600544,UNKNOWN,1688,,"TEST_METHOD(TestOscSetColorTableEntry)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,3026,1688,CPPASTProblemDeclaration,,<empty>
600566,UNKNOWN,1693,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1\033\\"");",9,<empty>,,3033,1693,CPPASTProblemDeclaration,,<empty>
600567,UNKNOWN,1694,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3034,1694,CPPASTProblemDeclaration,,<empty>
600568,UNKNOWN,1695,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3035,1695,CPPASTProblemDeclaration,,<empty>
600569,UNKNOWN,1696,,pDispatch->ClearState();,9,<empty>,,3037,1696,CPPASTProblemDeclaration,,<empty>
600570,UNKNOWN,1697,,"mach.ProcessString(L""\033]4;16;rgb:11/11/11\033\\"");",9,<empty>,,3039,1697,CPPASTProblemDeclaration,,<empty>
600571,UNKNOWN,1698,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3040,1698,CPPASTProblemDeclaration,,<empty>
600572,UNKNOWN,1699,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(16));",9,<empty>,,3041,1699,CPPASTProblemDeclaration,,<empty>
600573,UNKNOWN,1700,,pDispatch->ClearState();,9,<empty>,,3043,1700,CPPASTProblemDeclaration,,<empty>
600574,UNKNOWN,1701,,"mach.ProcessString(L""\033]4;64;#111\033\\"");",9,<empty>,,3045,1701,CPPASTProblemDeclaration,,<empty>
600575,UNKNOWN,1702,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3046,1702,CPPASTProblemDeclaration,,<empty>
600576,UNKNOWN,1703,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(64));",9,<empty>,,3047,1703,CPPASTProblemDeclaration,,<empty>
600577,UNKNOWN,1704,,pDispatch->ClearState();,9,<empty>,,3049,1704,CPPASTProblemDeclaration,,<empty>
600578,UNKNOWN,1705,,"mach.ProcessString(L""\033]4;128;orange\033\\"");",9,<empty>,,3051,1705,CPPASTProblemDeclaration,,<empty>
600579,UNKNOWN,1706,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3052,1706,CPPASTProblemDeclaration,,<empty>
600580,UNKNOWN,1707,,"VERIFY_ARE_EQUAL(RGB(255, 165, 0), pDispatch->_colorTable.at(128));",9,<empty>,,3053,1707,CPPASTProblemDeclaration,,<empty>
600581,UNKNOWN,1708,,pDispatch->ClearState();,9,<empty>,,3055,1708,CPPASTProblemDeclaration,,<empty>
600582,UNKNOWN,1709,,"mach.ProcessString(L""\033]4;\033\\"");",9,<empty>,,3058,1709,CPPASTProblemDeclaration,,<empty>
600583,UNKNOWN,1710,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3059,1710,CPPASTProblemDeclaration,,<empty>
600584,UNKNOWN,1711,,pDispatch->ClearState();,9,<empty>,,3061,1711,CPPASTProblemDeclaration,,<empty>
600585,UNKNOWN,1712,,"mach.ProcessString(L""\033]4;;\033\\"");",9,<empty>,,3063,1712,CPPASTProblemDeclaration,,<empty>
600586,UNKNOWN,1713,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3064,1713,CPPASTProblemDeclaration,,<empty>
600587,UNKNOWN,1714,,pDispatch->ClearState();,9,<empty>,,3066,1714,CPPASTProblemDeclaration,,<empty>
600588,UNKNOWN,1715,,"mach.ProcessString(L""\033]4;0\033\\"");",9,<empty>,,3068,1715,CPPASTProblemDeclaration,,<empty>
600589,UNKNOWN,1716,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3069,1716,CPPASTProblemDeclaration,,<empty>
600590,UNKNOWN,1717,,pDispatch->ClearState();,9,<empty>,,3071,1717,CPPASTProblemDeclaration,,<empty>
600591,UNKNOWN,1718,,"mach.ProcessString(L""\033]4;111\033\\"");",9,<empty>,,3073,1718,CPPASTProblemDeclaration,,<empty>
600592,UNKNOWN,1719,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3074,1719,CPPASTProblemDeclaration,,<empty>
600593,UNKNOWN,1720,,pDispatch->ClearState();,9,<empty>,,3076,1720,CPPASTProblemDeclaration,,<empty>
600594,UNKNOWN,1721,,"mach.ProcessString(L""\033]4;#111\033\\"");",9,<empty>,,3078,1721,CPPASTProblemDeclaration,,<empty>
600595,UNKNOWN,1722,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3079,1722,CPPASTProblemDeclaration,,<empty>
600596,UNKNOWN,1723,,pDispatch->ClearState();,9,<empty>,,3081,1723,CPPASTProblemDeclaration,,<empty>
600597,UNKNOWN,1724,,"mach.ProcessString(L""\033]4;1;111\033\\"");",9,<empty>,,3083,1724,CPPASTProblemDeclaration,,<empty>
600598,UNKNOWN,1725,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3084,1725,CPPASTProblemDeclaration,,<empty>
600599,UNKNOWN,1726,,pDispatch->ClearState();,9,<empty>,,3086,1726,CPPASTProblemDeclaration,,<empty>
600600,UNKNOWN,1727,,"mach.ProcessString(L""\033]4;1;rgb:\033\\"");",9,<empty>,,3088,1727,CPPASTProblemDeclaration,,<empty>
600601,UNKNOWN,1728,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3089,1728,CPPASTProblemDeclaration,,<empty>
600602,UNKNOWN,1729,,pDispatch->ClearState();,9,<empty>,,3091,1729,CPPASTProblemDeclaration,,<empty>
600603,UNKNOWN,1730,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1;16;rgb:2/2/2\033\\"");",9,<empty>,,3094,1730,CPPASTProblemDeclaration,,<empty>
600604,UNKNOWN,1731,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3095,1731,CPPASTProblemDeclaration,,<empty>
600605,UNKNOWN,1732,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3096,1732,CPPASTProblemDeclaration,,<empty>
600606,UNKNOWN,1733,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_colorTable.at(16));",9,<empty>,,3097,1733,CPPASTProblemDeclaration,,<empty>
600607,UNKNOWN,1734,,pDispatch->ClearState();,9,<empty>,,3099,1734,CPPASTProblemDeclaration,,<empty>
600608,UNKNOWN,1735,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1;16;rgb:2/2/2;64;#111\033\\"");",9,<empty>,,3101,1735,CPPASTProblemDeclaration,,<empty>
600609,UNKNOWN,1736,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3102,1736,CPPASTProblemDeclaration,,<empty>
600610,UNKNOWN,1737,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3103,1737,CPPASTProblemDeclaration,,<empty>
600611,UNKNOWN,1738,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_colorTable.at(16));",9,<empty>,,3104,1738,CPPASTProblemDeclaration,,<empty>
600612,UNKNOWN,1739,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(64));",9,<empty>,,3105,1739,CPPASTProblemDeclaration,,<empty>
600613,UNKNOWN,1740,,pDispatch->ClearState();,9,<empty>,,3107,1740,CPPASTProblemDeclaration,,<empty>
600614,UNKNOWN,1741,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1;16;rgb:2/2/2;64;#111;128;orange\033\\"");",9,<empty>,,3109,1741,CPPASTProblemDeclaration,,<empty>
600615,UNKNOWN,1742,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3110,1742,CPPASTProblemDeclaration,,<empty>
600616,UNKNOWN,1743,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3111,1743,CPPASTProblemDeclaration,,<empty>
600617,UNKNOWN,1744,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_colorTable.at(16));",9,<empty>,,3112,1744,CPPASTProblemDeclaration,,<empty>
600618,UNKNOWN,1745,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(64));",9,<empty>,,3113,1745,CPPASTProblemDeclaration,,<empty>
600619,UNKNOWN,1746,,"VERIFY_ARE_EQUAL(RGB(255, 165, 0), pDispatch->_colorTable.at(128));",9,<empty>,,3114,1746,CPPASTProblemDeclaration,,<empty>
600620,UNKNOWN,1747,,pDispatch->ClearState();,9,<empty>,,3116,1747,CPPASTProblemDeclaration,,<empty>
600621,UNKNOWN,1748,,"mach.ProcessString(L""\033]4;0;rgb:11;1;rgb:2/2/2;2;#111;3;orange;4;#111\033\\"");",9,<empty>,,3119,1748,CPPASTProblemDeclaration,,<empty>
600622,UNKNOWN,1749,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3120,1749,CPPASTProblemDeclaration,,<empty>
600623,UNKNOWN,1750,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(0));",9,<empty>,,3121,1750,CPPASTProblemDeclaration,,<empty>
600624,UNKNOWN,1751,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_colorTable.at(1));",9,<empty>,,3122,1751,CPPASTProblemDeclaration,,<empty>
600625,UNKNOWN,1752,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(2));",9,<empty>,,3123,1752,CPPASTProblemDeclaration,,<empty>
600626,UNKNOWN,1753,,"VERIFY_ARE_EQUAL(RGB(255, 165, 0), pDispatch->_colorTable.at(3));",9,<empty>,,3124,1753,CPPASTProblemDeclaration,,<empty>
600627,UNKNOWN,1754,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(4));",9,<empty>,,3125,1754,CPPASTProblemDeclaration,,<empty>
600628,UNKNOWN,1755,,pDispatch->ClearState();,9,<empty>,,3127,1755,CPPASTProblemDeclaration,,<empty>
600629,UNKNOWN,1756,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1;1;rgb:2/2/2;2;#111;3;orange;4;111\033\\"");",9,<empty>,,3129,1756,CPPASTProblemDeclaration,,<empty>
600630,UNKNOWN,1757,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3130,1757,CPPASTProblemDeclaration,,<empty>
600631,UNKNOWN,1758,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3131,1758,CPPASTProblemDeclaration,,<empty>
600632,UNKNOWN,1759,,"VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_colorTable.at(1));",9,<empty>,,3132,1759,CPPASTProblemDeclaration,,<empty>
600633,UNKNOWN,1760,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(2));",9,<empty>,,3133,1760,CPPASTProblemDeclaration,,<empty>
600634,UNKNOWN,1761,,"VERIFY_ARE_EQUAL(RGB(255, 165, 0), pDispatch->_colorTable.at(3));",9,<empty>,,3134,1761,CPPASTProblemDeclaration,,<empty>
600635,UNKNOWN,1762,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(4));",9,<empty>,,3135,1762,CPPASTProblemDeclaration,,<empty>
600636,UNKNOWN,1763,,pDispatch->ClearState();,9,<empty>,,3137,1763,CPPASTProblemDeclaration,,<empty>
600637,UNKNOWN,1764,,"mach.ProcessString(L""\033]4;0;rgb:1/1/1;1;rgb:2;2;#111;3;orange;4;#222\033\\"");",9,<empty>,,3139,1764,CPPASTProblemDeclaration,,<empty>
600638,UNKNOWN,1765,,VERIFY_IS_TRUE(pDispatch->_setColorTableEntry);,9,<empty>,,3140,1765,CPPASTProblemDeclaration,,<empty>
600639,UNKNOWN,1766,,"VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_colorTable.at(0));",9,<empty>,,3141,1766,CPPASTProblemDeclaration,,<empty>
600640,UNKNOWN,1767,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(1));",9,<empty>,,3142,1767,CPPASTProblemDeclaration,,<empty>
600641,UNKNOWN,1768,,"VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_colorTable.at(2));",9,<empty>,,3143,1768,CPPASTProblemDeclaration,,<empty>
600642,UNKNOWN,1769,,"VERIFY_ARE_EQUAL(RGB(255, 165, 0), pDispatch->_colorTable.at(3));",9,<empty>,,3144,1769,CPPASTProblemDeclaration,,<empty>
600643,UNKNOWN,1770,,"VERIFY_ARE_EQUAL(RGB(0x20, 0x20, 0x20), pDispatch->_colorTable.at(4));",9,<empty>,,3145,1770,CPPASTProblemDeclaration,,<empty>
600644,UNKNOWN,1771,,pDispatch->ClearState();,9,<empty>,,3147,1771,CPPASTProblemDeclaration,,<empty>
600645,UNKNOWN,1772,,"mach.ProcessString(L""\033]4;0;;1;;\033\\"");",9,<empty>,,3150,1772,CPPASTProblemDeclaration,,<empty>
600646,UNKNOWN,1773,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3151,1773,CPPASTProblemDeclaration,,<empty>
600647,UNKNOWN,1774,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(0));",9,<empty>,,3152,1774,CPPASTProblemDeclaration,,<empty>
600648,UNKNOWN,1775,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(1));",9,<empty>,,3153,1775,CPPASTProblemDeclaration,,<empty>
600649,UNKNOWN,1776,,pDispatch->ClearState();,9,<empty>,,3155,1776,CPPASTProblemDeclaration,,<empty>
600650,UNKNOWN,1777,,"mach.ProcessString(L""\033]4;0;;;;;1;;;;;\033\\"");",9,<empty>,,3157,1777,CPPASTProblemDeclaration,,<empty>
600651,UNKNOWN,1778,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3158,1778,CPPASTProblemDeclaration,,<empty>
600652,UNKNOWN,1779,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(0));",9,<empty>,,3159,1779,CPPASTProblemDeclaration,,<empty>
600653,UNKNOWN,1780,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(1));",9,<empty>,,3160,1780,CPPASTProblemDeclaration,,<empty>
600654,UNKNOWN,1781,,pDispatch->ClearState();,9,<empty>,,3162,1781,CPPASTProblemDeclaration,,<empty>
600655,UNKNOWN,1782,,"mach.ProcessString(L""\033]4;0;rgb:1/1/;16;rgb:2/2/;64;#11\033\\"");",9,<empty>,,3164,1782,CPPASTProblemDeclaration,,<empty>
600656,UNKNOWN,1783,,VERIFY_IS_FALSE(pDispatch->_setColorTableEntry);,9,<empty>,,3165,1783,CPPASTProblemDeclaration,,<empty>
600657,UNKNOWN,1784,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(0));",9,<empty>,,3166,1784,CPPASTProblemDeclaration,,<empty>
600658,UNKNOWN,1785,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(16));",9,<empty>,,3167,1785,CPPASTProblemDeclaration,,<empty>
600659,UNKNOWN,1786,,"VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(64));",9,<empty>,,3168,1786,CPPASTProblemDeclaration,,<empty>
600660,UNKNOWN,1787,,pDispatch->ClearState();,9,<empty>,,3170,1787,CPPASTProblemDeclaration,,<empty>
600661,UNKNOWN,1788,,},5,<empty>,,3171,1788,CPPASTProblemDeclaration,,<empty>
600662,UNKNOWN,1789,,"TEST_METHOD(TestSetClipboard)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,3173,1789,CPPASTProblemDeclaration,,<empty>
600684,UNKNOWN,1794,,"mach.ProcessString(L""\x1b]52;;Zm9v\x07"");",9,<empty>,,3181,1794,CPPASTProblemDeclaration,,<empty>
600685,UNKNOWN,1795,,"VERIFY_ARE_EQUAL(L""foo"", pDispatch->_copyContent);",9,<empty>,,3182,1795,CPPASTProblemDeclaration,,<empty>
600686,UNKNOWN,1796,,pDispatch->ClearState();,9,<empty>,,3184,1796,CPPASTProblemDeclaration,,<empty>
600687,UNKNOWN,1797,,"mach.ProcessString(L""\x1b]52;;Zm9vDQpiYXI=\x07"");",9,<empty>,,3187,1797,CPPASTProblemDeclaration,,<empty>
600688,UNKNOWN,1798,,"VERIFY_ARE_EQUAL(L""foo\r\nbar"", pDispatch->_copyContent);",9,<empty>,,3188,1798,CPPASTProblemDeclaration,,<empty>
600689,UNKNOWN,1799,,pDispatch->ClearState();,9,<empty>,,3190,1799,CPPASTProblemDeclaration,,<empty>
600690,UNKNOWN,1800,,"mach.ProcessString(L""\x1b]52;;44Gr44G744KT44GU5rGJ6K+t7ZWc6rWt\x07"");",9,<empty>,,3194,1800,CPPASTProblemDeclaration,,<empty>
600691,UNKNOWN,1801,,"VERIFY_ARE_EQUAL(L"""", pDispatch->_copyContent);",9,<empty>,,3195,1801,CPPASTProblemDeclaration,,<empty>
600692,UNKNOWN,1802,,pDispatch->ClearState();,9,<empty>,,3197,1802,CPPASTProblemDeclaration,,<empty>
600693,UNKNOWN,1803,,"mach.ProcessString(L""\x1b]52;;8J+RjfCfkY3wn4+78J+RjfCfj7zwn5GN8J+PvfCfkY3wn4++8J+RjfCfj78=\x07"");",9,<empty>,,3202,1803,CPPASTProblemDeclaration,,<empty>
600694,UNKNOWN,1804,,"VERIFY_ARE_EQUAL(L""??????????????????????"", pDispatch->_copyContent);",9,<empty>,,3203,1804,CPPASTProblemDeclaration,,<empty>
600695,UNKNOWN,1805,,pDispatch->ClearState();,9,<empty>,,3205,1805,CPPASTProblemDeclaration,,<empty>
600696,UNKNOWN,1806,,"mach.ProcessString(L""\x1b]52;s0;Zm9v\x07"");",9,<empty>,,3208,1806,CPPASTProblemDeclaration,,<empty>
600697,UNKNOWN,1807,,"VERIFY_ARE_EQUAL(L""foo"", pDispatch->_copyContent);",9,<empty>,,3209,1807,CPPASTProblemDeclaration,,<empty>
600698,UNKNOWN,1808,,pDispatch->ClearState();,9,<empty>,,3211,1808,CPPASTProblemDeclaration,,<empty>
600699,UNKNOWN,1809,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3213,1809,CPPASTProblemDeclaration,,<empty>
600700,UNKNOWN,1810,,"mach.ProcessString(L""\x1b]52;Zm9v\x07"");",9,<empty>,,3215,1810,CPPASTProblemDeclaration,,<empty>
600701,UNKNOWN,1811,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3216,1811,CPPASTProblemDeclaration,,<empty>
600702,UNKNOWN,1812,,pDispatch->ClearState();,9,<empty>,,3218,1812,CPPASTProblemDeclaration,,<empty>
600703,UNKNOWN,1813,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3220,1813,CPPASTProblemDeclaration,,<empty>
600704,UNKNOWN,1814,,"mach.ProcessString(L""\x1b]52;;???\x07"");",9,<empty>,,3222,1814,CPPASTProblemDeclaration,,<empty>
600705,UNKNOWN,1815,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3223,1815,CPPASTProblemDeclaration,,<empty>
600706,UNKNOWN,1816,,pDispatch->ClearState();,9,<empty>,,3225,1816,CPPASTProblemDeclaration,,<empty>
600707,UNKNOWN,1817,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3227,1817,CPPASTProblemDeclaration,,<empty>
600708,UNKNOWN,1818,,"mach.ProcessString(L""\x1b]52;;;Zm9v\x07"");",9,<empty>,,3229,1818,CPPASTProblemDeclaration,,<empty>
600709,UNKNOWN,1819,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3230,1819,CPPASTProblemDeclaration,,<empty>
600710,UNKNOWN,1820,,pDispatch->ClearState();,9,<empty>,,3232,1820,CPPASTProblemDeclaration,,<empty>
600711,UNKNOWN,1821,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3234,1821,CPPASTProblemDeclaration,,<empty>
600712,UNKNOWN,1822,,"mach.ProcessString(L""\x1b]52;;?\x07"");",9,<empty>,,3236,1822,CPPASTProblemDeclaration,,<empty>
600713,UNKNOWN,1823,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3237,1823,CPPASTProblemDeclaration,,<empty>
600714,UNKNOWN,1824,,pDispatch->ClearState();,9,<empty>,,3239,1824,CPPASTProblemDeclaration,,<empty>
600715,UNKNOWN,1825,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3241,1825,CPPASTProblemDeclaration,,<empty>
600716,UNKNOWN,1826,,"mach.ProcessString(L""\x1b]52;?\x07"");",9,<empty>,,3243,1826,CPPASTProblemDeclaration,,<empty>
600717,UNKNOWN,1827,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3244,1827,CPPASTProblemDeclaration,,<empty>
600718,UNKNOWN,1828,,pDispatch->ClearState();,9,<empty>,,3246,1828,CPPASTProblemDeclaration,,<empty>
600719,UNKNOWN,1829,,"pDispatch->_copyContent = L""UNCHANGED"";",9,<empty>,,3248,1829,CPPASTProblemDeclaration,,<empty>
600720,UNKNOWN,1830,,"mach.ProcessString(L""\x1b]52;;;?\x07"");",9,<empty>,,3250,1830,CPPASTProblemDeclaration,,<empty>
600721,UNKNOWN,1831,,"VERIFY_ARE_EQUAL(L""UNCHANGED"", pDispatch->_copyContent);",9,<empty>,,3251,1831,CPPASTProblemDeclaration,,<empty>
600722,UNKNOWN,1832,,pDispatch->ClearState();,9,<empty>,,3253,1832,CPPASTProblemDeclaration,,<empty>
600723,UNKNOWN,1833,,},5,<empty>,,3254,1833,CPPASTProblemDeclaration,,<empty>
600724,UNKNOWN,1834,,"TEST_METHOD(TestAddHyperlink)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,3256,1834,CPPASTProblemDeclaration,,<empty>
600746,UNKNOWN,1839,,"mach.ProcessString(L""\x1b]8;;test.url\x1b\\"");",9,<empty>,,3265,1839,CPPASTProblemDeclaration,,<empty>
600747,UNKNOWN,1840,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3266,1840,CPPASTProblemDeclaration,,<empty>
600748,UNKNOWN,1841,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""test.url"");",9,<empty>,,3267,1841,CPPASTProblemDeclaration,,<empty>
600749,UNKNOWN,1842,,VERIFY_IS_TRUE(pDispatch->_customId.empty());,9,<empty>,,3268,1842,CPPASTProblemDeclaration,,<empty>
600750,UNKNOWN,1843,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3271,1843,CPPASTProblemDeclaration,,<empty>
600751,UNKNOWN,1844,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3272,1844,CPPASTProblemDeclaration,,<empty>
600752,UNKNOWN,1845,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3273,1845,CPPASTProblemDeclaration,,<empty>
600753,UNKNOWN,1846,,"mach.ProcessString(L""\x1b]8;id=testId;test2.url\x1b\\"");",9,<empty>,,3277,1846,CPPASTProblemDeclaration,,<empty>
600754,UNKNOWN,1847,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3278,1847,CPPASTProblemDeclaration,,<empty>
600755,UNKNOWN,1848,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""test2.url"");",9,<empty>,,3279,1848,CPPASTProblemDeclaration,,<empty>
600756,UNKNOWN,1849,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3280,1849,CPPASTProblemDeclaration,,<empty>
600757,UNKNOWN,1850,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3283,1850,CPPASTProblemDeclaration,,<empty>
600758,UNKNOWN,1851,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3284,1851,CPPASTProblemDeclaration,,<empty>
600759,UNKNOWN,1852,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3285,1852,CPPASTProblemDeclaration,,<empty>
600760,UNKNOWN,1853,,"mach.ProcessString(L""\x1b]8;id=testId;https://example.com\x1b\\"");",9,<empty>,,3288,1853,CPPASTProblemDeclaration,,<empty>
600761,UNKNOWN,1854,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3289,1854,CPPASTProblemDeclaration,,<empty>
600762,UNKNOWN,1855,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""https://example.com"");",9,<empty>,,3290,1855,CPPASTProblemDeclaration,,<empty>
600763,UNKNOWN,1856,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3291,1856,CPPASTProblemDeclaration,,<empty>
600764,UNKNOWN,1857,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3293,1857,CPPASTProblemDeclaration,,<empty>
600765,UNKNOWN,1858,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3294,1858,CPPASTProblemDeclaration,,<empty>
600766,UNKNOWN,1859,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3295,1859,CPPASTProblemDeclaration,,<empty>
600767,UNKNOWN,1860,,"mach.ProcessString(L""\x1b]8;id=testId:foo=bar;https://example.com\x1b\\"");",9,<empty>,,3298,1860,CPPASTProblemDeclaration,,<empty>
600768,UNKNOWN,1861,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3299,1861,CPPASTProblemDeclaration,,<empty>
600769,UNKNOWN,1862,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""https://example.com"");",9,<empty>,,3300,1862,CPPASTProblemDeclaration,,<empty>
600770,UNKNOWN,1863,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3301,1863,CPPASTProblemDeclaration,,<empty>
600771,UNKNOWN,1864,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3303,1864,CPPASTProblemDeclaration,,<empty>
600772,UNKNOWN,1865,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3304,1865,CPPASTProblemDeclaration,,<empty>
600773,UNKNOWN,1866,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3305,1866,CPPASTProblemDeclaration,,<empty>
600774,UNKNOWN,1867,,"mach.ProcessString(L""\x1b]8;foo=bar:id=testId;https://example.com\x1b\\"");",9,<empty>,,3307,1867,CPPASTProblemDeclaration,,<empty>
600775,UNKNOWN,1868,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3308,1868,CPPASTProblemDeclaration,,<empty>
600776,UNKNOWN,1869,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""https://example.com"");",9,<empty>,,3309,1869,CPPASTProblemDeclaration,,<empty>
600777,UNKNOWN,1870,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3310,1870,CPPASTProblemDeclaration,,<empty>
600778,UNKNOWN,1871,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3312,1871,CPPASTProblemDeclaration,,<empty>
600779,UNKNOWN,1872,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3313,1872,CPPASTProblemDeclaration,,<empty>
600780,UNKNOWN,1873,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3314,1873,CPPASTProblemDeclaration,,<empty>
600781,UNKNOWN,1874,,"mach.ProcessString(L""\x1b]8;id=testId;https://example.com?query1=value1\x1b\\"");",9,<empty>,,3317,1874,CPPASTProblemDeclaration,,<empty>
600782,UNKNOWN,1875,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3318,1875,CPPASTProblemDeclaration,,<empty>
600783,UNKNOWN,1876,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""https://example.com?query1=value1"");",9,<empty>,,3319,1876,CPPASTProblemDeclaration,,<empty>
600784,UNKNOWN,1877,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3320,1877,CPPASTProblemDeclaration,,<empty>
600785,UNKNOWN,1878,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3322,1878,CPPASTProblemDeclaration,,<empty>
600786,UNKNOWN,1879,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3323,1879,CPPASTProblemDeclaration,,<empty>
600787,UNKNOWN,1880,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3324,1880,CPPASTProblemDeclaration,,<empty>
600788,UNKNOWN,1881,,"mach.ProcessString(L""\x1b]8;id=testId;https://example.com?query1=value1;value2;value3\x1b\\"");",9,<empty>,,3326,1881,CPPASTProblemDeclaration,,<empty>
600789,UNKNOWN,1882,,VERIFY_IS_TRUE(pDispatch->_hyperlinkMode);,9,<empty>,,3327,1882,CPPASTProblemDeclaration,,<empty>
600790,UNKNOWN,1883,,"VERIFY_ARE_EQUAL(pDispatch->_uri, L""https://example.com?query1=value1;value2;value3"");",9,<empty>,,3328,1883,CPPASTProblemDeclaration,,<empty>
600791,UNKNOWN,1884,,"VERIFY_ARE_EQUAL(pDispatch->_customId, L""testId"");",9,<empty>,,3329,1884,CPPASTProblemDeclaration,,<empty>
600792,UNKNOWN,1885,,"mach.ProcessString(L""\x1b]8;;\x1b\\"");",9,<empty>,,3331,1885,CPPASTProblemDeclaration,,<empty>
600793,UNKNOWN,1886,,VERIFY_IS_FALSE(pDispatch->_hyperlinkMode);,9,<empty>,,3332,1886,CPPASTProblemDeclaration,,<empty>
600794,UNKNOWN,1887,,VERIFY_IS_TRUE(pDispatch->_uri.empty());,9,<empty>,,3333,1887,CPPASTProblemDeclaration,,<empty>
600795,UNKNOWN,1888,,pDispatch->ClearState();,9,<empty>,,3335,1888,CPPASTProblemDeclaration,,<empty>
600796,UNKNOWN,1889,,},5,<empty>,,3336,1889,CPPASTProblemDeclaration,,<empty>
600797,UNKNOWN,1890,,"TEST_METHOD(TestC1ParserMode)
    {
        auto dispatch = std::make_unique<StatefulDispatch>();",5,<empty>,,3338,1890,CPPASTProblemDeclaration,,<empty>
600819,UNKNOWN,1895,,"Log::Comment(L""C1 parsing disabled: CSI control ignored and rest of sequence printed"");",9,<empty>,,3345,1895,CPPASTProblemDeclaration,,<empty>
600820,UNKNOWN,1896,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, false);",9,<empty>,,3346,1896,CPPASTProblemDeclaration,,<empty>
600821,UNKNOWN,1897,,"mach.ProcessString(L""\u009b""
                           L""123A"");",9,<empty>,,3347,1897,CPPASTProblemDeclaration,,<empty>
600822,UNKNOWN,1898,,VERIFY_IS_FALSE(pDispatch->_cursorUp);,9,<empty>,,3349,1898,CPPASTProblemDeclaration,,<empty>
600823,UNKNOWN,1899,,"VERIFY_ARE_EQUAL(pDispatch->_printString, L""123A"");",9,<empty>,,3350,1899,CPPASTProblemDeclaration,,<empty>
600824,UNKNOWN,1900,,pDispatch->ClearState();,9,<empty>,,3352,1900,CPPASTProblemDeclaration,,<empty>
600825,UNKNOWN,1901,,"Log::Comment(L""C1 parsing enabled: CSI interpreted and CUP sequence executed"");",9,<empty>,,3354,1901,CPPASTProblemDeclaration,,<empty>
600826,UNKNOWN,1902,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,3355,1902,CPPASTProblemDeclaration,,<empty>
600827,UNKNOWN,1903,,"mach.ProcessString(L""\u009b""
                           L""123A"");",9,<empty>,,3356,1903,CPPASTProblemDeclaration,,<empty>
600828,UNKNOWN,1904,,VERIFY_IS_TRUE(pDispatch->_cursorUp);,9,<empty>,,3358,1904,CPPASTProblemDeclaration,,<empty>
600829,UNKNOWN,1905,,"VERIFY_ARE_EQUAL(pDispatch->_cursorDistance, 123u);",9,<empty>,,3359,1905,CPPASTProblemDeclaration,,<empty>
600830,UNKNOWN,1906,,pDispatch->ClearState();,9,<empty>,,3361,1906,CPPASTProblemDeclaration,,<empty>
600831,UNKNOWN,1907,,"Log::Comment(L""C1 parsing disabled: NEL has no effect within a sequence"");",9,<empty>,,3363,1907,CPPASTProblemDeclaration,,<empty>
600832,UNKNOWN,1908,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, false);",9,<empty>,,3364,1908,CPPASTProblemDeclaration,,<empty>
600833,UNKNOWN,1909,,"mach.ProcessString(L""\x1b[12""
                           L""\u0085""
                           L"";34H"");",9,<empty>,,3365,1909,CPPASTProblemDeclaration,,<empty>
600834,UNKNOWN,1910,,VERIFY_IS_FALSE(pDispatch->_lineFeed);,9,<empty>,,3368,1910,CPPASTProblemDeclaration,,<empty>
600835,UNKNOWN,1911,,VERIFY_IS_TRUE(pDispatch->_cursorPosition);,9,<empty>,,3369,1911,CPPASTProblemDeclaration,,<empty>
600836,UNKNOWN,1912,,"VERIFY_ARE_EQUAL(pDispatch->_line, 12u);",9,<empty>,,3370,1912,CPPASTProblemDeclaration,,<empty>
600837,UNKNOWN,1913,,"VERIFY_ARE_EQUAL(pDispatch->_column, 34u);",9,<empty>,,3371,1913,CPPASTProblemDeclaration,,<empty>
600838,UNKNOWN,1914,,"VERIFY_ARE_EQUAL(pDispatch->_printString, L"""");",9,<empty>,,3372,1914,CPPASTProblemDeclaration,,<empty>
600839,UNKNOWN,1915,,pDispatch->ClearState();,9,<empty>,,3374,1915,CPPASTProblemDeclaration,,<empty>
600840,UNKNOWN,1916,,"Log::Comment(L""C1 parsing enabled: NEL aborts sequence and executes line feed"");",9,<empty>,,3376,1916,CPPASTProblemDeclaration,,<empty>
600841,UNKNOWN,1917,,"mach.SetParserMode(StateMachine::Mode::AcceptC1, true);",9,<empty>,,3377,1917,CPPASTProblemDeclaration,,<empty>
600842,UNKNOWN,1918,,"mach.ProcessString(L""\x1b[12""
                           L""\u0085""
                           L"";34H"");",9,<empty>,,3378,1918,CPPASTProblemDeclaration,,<empty>
600843,UNKNOWN,1919,,VERIFY_IS_TRUE(pDispatch->_lineFeed);,9,<empty>,,3381,1919,CPPASTProblemDeclaration,,<empty>
600844,UNKNOWN,1920,,"VERIFY_ARE_EQUAL(DispatchTypes::LineFeedType::WithReturn, pDispatch->_lineFeedType);",9,<empty>,,3382,1920,CPPASTProblemDeclaration,,<empty>
600845,UNKNOWN,1921,,VERIFY_IS_FALSE(pDispatch->_cursorPosition);,9,<empty>,,3383,1921,CPPASTProblemDeclaration,,<empty>
600846,UNKNOWN,1922,,"VERIFY_ARE_EQUAL(pDispatch->_printString, L"";34H"");",9,<empty>,,3384,1922,CPPASTProblemDeclaration,,<empty>
600847,UNKNOWN,1923,,pDispatch->ClearState();,9,<empty>,,3386,1923,CPPASTProblemDeclaration,,<empty>
600848,UNKNOWN,1924,,},5,<empty>,,3387,1924,CPPASTProblemDeclaration,,<empty>
600849,UNKNOWN,1925,,};,1,<empty>,,3388,1925,CPPASTProblemDeclaration,,<empty>
601137,UNKNOWN,11,,};,1,<empty>,,167,11,CPPASTProblemDeclaration,,<empty>
601581,UNKNOWN,-1,,),34,<empty>,,287,2,CPPASTProblemStatement,,<empty>
601585,UNKNOWN,-1,,),71,<empty>,,288,4,CPPASTProblemStatement,,<empty>
601587,UNKNOWN,-1,,),32,<empty>,,289,6,CPPASTProblemStatement,,<empty>
601721,UNKNOWN,-1,,3,50,<empty>,,333,2,CPPASTProblemStatement,,<empty>
601960,UNKNOWN,-1,,"TEST_METHOD(ManageVector)
    {
        constexpr auto shrinkThreshold = 0.5f;",5,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
601962,UNKNOWN,-1,,foo.reserve(20);,9,<empty>,,22,4,CPPASTProblemDeclaration,,<empty>
601963,UNKNOWN,-1,,"Log::Comment(L""Expand vector."");",9,<empty>,,24,5,CPPASTProblemDeclaration,,<empty>
601964,UNKNOWN,-1,,"til::manage_vector(foo, 30, shrinkThreshold);",9,<empty>,,25,6,CPPASTProblemDeclaration,,<empty>
601965,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(30u, foo.capacity());",9,<empty>,,26,7,CPPASTProblemDeclaration,,<empty>
601966,UNKNOWN,-1,,"Log::Comment(L""Try shrink but by not enough for threshold."");",9,<empty>,,28,8,CPPASTProblemDeclaration,,<empty>
601967,UNKNOWN,-1,,"til::manage_vector(foo, 18, shrinkThreshold);",9,<empty>,,29,9,CPPASTProblemDeclaration,,<empty>
601968,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(30u, foo.capacity());",9,<empty>,,30,10,CPPASTProblemDeclaration,,<empty>
601969,UNKNOWN,-1,,"Log::Comment(L""Shrink because it is meeting threshold."");",9,<empty>,,32,11,CPPASTProblemDeclaration,,<empty>
601970,UNKNOWN,-1,,"til::manage_vector(foo, 15, shrinkThreshold);",9,<empty>,,33,12,CPPASTProblemDeclaration,,<empty>
601971,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(15u, foo.capacity());",9,<empty>,,34,13,CPPASTProblemDeclaration,,<empty>
601972,UNKNOWN,2,,},5,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
601973,UNKNOWN,3,,};,1,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
602032,UNKNOWN,2,,"TEST_METHOD(SizeConstructWithFill)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:fill"", L""{true, false}"")
        END_TEST_METHOD_PROPERTIES()

        bool fill;",5,<empty>,,77,2,CPPASTProblemDeclaration,,<empty>
602033,UNKNOWN,3,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""fill"", fill));",9,<empty>,,84,3,CPPASTProblemDeclaration,,<empty>
602054,UNKNOWN,10,,"VERIFY_ARE_EQUAL(expectedSize, bitmap._sz);",9,<empty>,,89,10,CPPASTProblemDeclaration,,<empty>
602055,UNKNOWN,11,,"VERIFY_ARE_EQUAL(expectedRect, bitmap._rc);",9,<empty>,,90,11,CPPASTProblemDeclaration,,<empty>
602056,UNKNOWN,12,,"VERIFY_ARE_EQUAL(50u, bitmap._bits.size());",9,<empty>,,91,12,CPPASTProblemDeclaration,,<empty>
602057,UNKNOWN,13,,"if (!fill)
        {
            VERIFY_IS_TRUE(bitmap._bits.none());
        }",9,<empty>,,93,13,CPPASTProblemDeclaration,,<empty>
602058,UNKNOWN,14,,"else
        {
            VERIFY_IS_TRUE(bitmap._bits.all());
        }",9,<empty>,,97,14,CPPASTProblemDeclaration,,<empty>
602059,UNKNOWN,15,,},5,<empty>,,101,15,CPPASTProblemDeclaration,,<empty>
602060,UNKNOWN,16,,"TEST_METHOD(Equality)
    {
        Log::Comment(L""0.) Defaults are equal"");",5,<empty>,,103,16,CPPASTProblemDeclaration,,<empty>
602061,UNKNOWN,17,,"{
            const til::bitmap one;
            const til::bitmap two;
            VERIFY_IS_TRUE(one == two);
        }",9,<empty>,,106,17,CPPASTProblemDeclaration,,<empty>
602062,UNKNOWN,18,,"Log::Comment(L""1.) Different sizes are unequal"");",9,<empty>,,112,18,CPPASTProblemDeclaration,,<empty>
602063,UNKNOWN,19,,"{
            const til::bitmap one{ til::size{ 2, 2 } };
            const til::bitmap two{ til::size{ 3, 3 } };
            VERIFY_IS_FALSE(one == two);
        }",9,<empty>,,113,19,CPPASTProblemDeclaration,,<empty>
602064,UNKNOWN,20,,"Log::Comment(L""2.) Same bits set are equal"");",9,<empty>,,119,20,CPPASTProblemDeclaration,,<empty>
602065,UNKNOWN,21,,"{
            til::bitmap one{ til::size{ 2, 2 } };
            til::bitmap two{ til::size{ 2, 2 } };
            one.set(til::point{ 0, 1 });
            one.set(til::point{ 1, 0 });
            two.set(til::point{ 0, 1 });
            two.set(til::point{ 1, 0 });
            VERIFY_IS_TRUE(one == two);
        }",9,<empty>,,120,21,CPPASTProblemDeclaration,,<empty>
602066,UNKNOWN,22,,"Log::Comment(L""3.) Different bits set are not equal"");",9,<empty>,,130,22,CPPASTProblemDeclaration,,<empty>
602067,UNKNOWN,23,,"{
            til::bitmap one{ til::size{ 2, 2 } };
            til::bitmap two{ til::size{ 2, 2 } };
            one.set(til::point{ 0, 1 });
            two.set(til::point{ 1, 0 });
            VERIFY_IS_FALSE(one == two);
        }",9,<empty>,,131,23,CPPASTProblemDeclaration,,<empty>
602068,UNKNOWN,24,,},5,<empty>,,138,24,CPPASTProblemDeclaration,,<empty>
602069,UNKNOWN,25,,"TEST_METHOD(Inequality)
    {
        Log::Comment(L""0.) Defaults are equal"");",5,<empty>,,140,25,CPPASTProblemDeclaration,,<empty>
602070,UNKNOWN,26,,"{
            const til::bitmap one;
            const til::bitmap two;
            VERIFY_IS_FALSE(one != two);
        }",9,<empty>,,143,26,CPPASTProblemDeclaration,,<empty>
602071,UNKNOWN,27,,"Log::Comment(L""1.) Different sizes are unequal"");",9,<empty>,,149,27,CPPASTProblemDeclaration,,<empty>
602072,UNKNOWN,28,,"{
            const til::bitmap one{ til::size{ 2, 2 } };
            const til::bitmap two{ til::size{ 3, 3 } };
            VERIFY_IS_TRUE(one != two);
        }",9,<empty>,,150,28,CPPASTProblemDeclaration,,<empty>
602073,UNKNOWN,29,,"Log::Comment(L""2.) Same bits set are equal"");",9,<empty>,,156,29,CPPASTProblemDeclaration,,<empty>
602074,UNKNOWN,30,,"{
            til::bitmap one{ til::size{ 2, 2 } };
            til::bitmap two{ til::size{ 2, 2 } };
            one.set(til::point{ 0, 1 });
            one.set(til::point{ 1, 0 });
            two.set(til::point{ 0, 1 });
            two.set(til::point{ 1, 0 });
            VERIFY_IS_FALSE(one != two);
        }",9,<empty>,,157,30,CPPASTProblemDeclaration,,<empty>
602075,UNKNOWN,31,,"Log::Comment(L""3.) Different bits set are not equal"");",9,<empty>,,167,31,CPPASTProblemDeclaration,,<empty>
602076,UNKNOWN,32,,"{
            til::bitmap one{ til::size{ 2, 2 } };
            til::bitmap two{ til::size{ 2, 2 } };
            one.set(til::point{ 0, 1 });
            two.set(til::point{ 1, 0 });
            VERIFY_IS_TRUE(one != two);
        }",9,<empty>,,168,32,CPPASTProblemDeclaration,,<empty>
602077,UNKNOWN,33,,},5,<empty>,,175,33,CPPASTProblemDeclaration,,<empty>
602078,UNKNOWN,34,,"TEST_METHOD(Translate)
    {
        const til::size mapSize{ 4, 4 };",5,<empty>,,177,34,CPPASTProblemDeclaration,,<empty>
602084,UNKNOWN,37,,"map.set(til::rect{ til::point{ 1, 1 }, til::size{ 2, 2 } }",9,<empty>,,187,37,CPPASTProblemDeclaration,,<empty>
602085,UNKNOWN,38,,);,67,<empty>,,187,38,CPPASTProblemDeclaration,,<empty>
602086,UNKNOWN,39,,"Log::Comment(L""1.) Move down and right"");",9,<empty>,,189,39,CPPASTProblemDeclaration,,<empty>
602087,UNKNOWN,40,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v --> -->
            const til::point delta{ 2, 2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0         0 0 0 0          0 0 0 0
            // 0 1 1 0         0 0 0 0          0 0 0 0
            // 0 1 1 0 v  -->  0 0 0 0   -->    0 0 0 0
            // 0 0 0 0 v       0 1 1 0          0 0 0 1
            //                     ->->
            expected.set(til::point{ 3, 3 });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,190,40,CPPASTProblemDeclaration,,<empty>
602088,UNKNOWN,41,,"Log::Comment(L""2.) Move down"");",9,<empty>,,213,41,CPPASTProblemDeclaration,,<empty>
602089,UNKNOWN,42,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v
            const til::point delta{ 0, 2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0         0 0 0 0
            // 0 1 1 0         0 0 0 0
            // 0 1 1 0 v  -->  0 0 0 0
            // 0 0 0 0 v       0 1 1 0
            expected.set(til::rect{ til::point{ 1, 3 }, til::size{ 2, 1 } });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,214,42,CPPASTProblemDeclaration,,<empty>
602090,UNKNOWN,43,,"Log::Comment(L""3.) Move down and left"");",9,<empty>,,236,43,CPPASTProblemDeclaration,,<empty>
602091,UNKNOWN,44,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v <-- <--
            const til::point delta{ -2, 2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0         0 0 0 0          0 0 0 0
            // 0 1 1 0         0 0 0 0          0 0 0 0
            // 0 1 1 0 v  -->  0 0 0 0   -->    0 0 0 0
            // 0 0 0 0 v       0 1 1 0          1 0 0 0
            //                 <-<-
            expected.set(til::point{ 0, 3 });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,237,44,CPPASTProblemDeclaration,,<empty>
602092,UNKNOWN,45,,"Log::Comment(L""4.) Move left"");",9,<empty>,,260,45,CPPASTProblemDeclaration,,<empty>
602093,UNKNOWN,46,,"{
            auto actual = map;
            // Move all contents
            // <-- <--
            const til::point delta{ -2, 0 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0         0 0 0 0
            // 0 1 1 0         1 0 0 0
            // 0 1 1 0    -->  1 0 0 0
            // 0 0 0 0         0 0 0 0
            // <--<--
            expected.set(til::rect{ til::point{ 0, 1 }, til::size{ 1, 2 } });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,261,46,CPPASTProblemDeclaration,,<empty>
602094,UNKNOWN,47,,"Log::Comment(L""5.) Move up and left"");",9,<empty>,,281,47,CPPASTProblemDeclaration,,<empty>
602095,UNKNOWN,48,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // | <-- <--
            const til::point delta{ -2, -2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0 ^       0 1 1 0          1 0 0 0
            // 0 1 1 0 ^       0 0 0 0          0 0 0 0
            // 0 1 1 0    -->  0 0 0 0   -->    0 0 0 0
            // 0 0 0 0         0 0 0 0          0 0 0 0
            //                 <-<-
            expected.set(til::point{ 0, 0 });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,282,48,CPPASTProblemDeclaration,,<empty>
602096,UNKNOWN,49,,"Log::Comment(L""6.) Move up"");",9,<empty>,,305,49,CPPASTProblemDeclaration,,<empty>
602097,UNKNOWN,50,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // |
            const til::point delta{ 0, -2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0 ^       0 1 1 0
            // 0 1 1 0 ^       0 0 0 0
            // 0 1 1 0    -->  0 0 0 0
            // 0 0 0 0         0 0 0 0
            expected.set(til::rect{ til::point{ 1, 0 }, til::size{ 2, 1 } });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,306,50,CPPASTProblemDeclaration,,<empty>
602098,UNKNOWN,51,,"Log::Comment(L""7.) Move up and right"");",9,<empty>,,328,51,CPPASTProblemDeclaration,,<empty>
602099,UNKNOWN,52,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // | --> -->
            const til::point delta{ 2, -2 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0 ^       0 1 1 0          0 0 0 1
            // 0 1 1 0 ^       0 0 0 0          0 0 0 0
            // 0 1 1 0    -->  0 0 0 0   -->    0 0 0 0
            // 0 0 0 0         0 0 0 0          0 0 0 0
            //                     ->->
            expected.set(til::point{ 3, 0 });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,329,52,CPPASTProblemDeclaration,,<empty>
602100,UNKNOWN,53,,"Log::Comment(L""8.) Move right"");",9,<empty>,,352,53,CPPASTProblemDeclaration,,<empty>
602101,UNKNOWN,54,,"{
            auto actual = map;
            // Move all contents
            // --> -->
            const til::point delta{ 2, 0 };

            til::bitmap expected{ mapSize };
            // Expected:
            // 0 0 0 0         0 0 0 0
            // 0 1 1 0         0 0 0 1
            // 0 1 1 0    -->  0 0 0 1
            // 0 0 0 0         0 0 0 0
            //     ->->
            expected.set(til::rect{ til::point{ 3, 1 }, til::size{ 1, 2 } });

            actual.translate(delta);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,353,54,CPPASTProblemDeclaration,,<empty>
602102,UNKNOWN,55,,},5,<empty>,,372,55,CPPASTProblemDeclaration,,<empty>
602103,UNKNOWN,56,,"TEST_METHOD(TranslateWithFill)
    {
        const til::size mapSize{ 4, 4 };",5,<empty>,,374,56,CPPASTProblemDeclaration,,<empty>
602109,UNKNOWN,59,,"map.set(til::rect{ til::point{ 1, 1 }, til::size{ 2, 2 } }",9,<empty>,,384,59,CPPASTProblemDeclaration,,<empty>
602110,UNKNOWN,60,,);,67,<empty>,,384,60,CPPASTProblemDeclaration,,<empty>
602111,UNKNOWN,61,,"Log::Comment(L""1.) Move down and right"");",9,<empty>,,386,61,CPPASTProblemDeclaration,,<empty>
602112,UNKNOWN,62,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v --> -->
            const til::point delta{ 2, 2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0         F F F F          F F F F
            // 0 1 1 0         F F F F          F F F F
            // 0 1 1 0 v  -->  0 0 0 0   -->    F F 0 0
            // 0 0 0 0 v       0 1 1 0          F F 0 1
            //                     ->->
            expected.set(til::rect{ til::point{ 0, 0 }, til::size{ 4, 2 } });
            expected.set(til::rect{ til::point{ 0, 2 }, til::size{ 2, 2 } });
            expected.set(til::point{ 3, 3 });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,387,62,CPPASTProblemDeclaration,,<empty>
602113,UNKNOWN,63,,"Log::Comment(L""2.) Move down"");",9,<empty>,,412,63,CPPASTProblemDeclaration,,<empty>
602114,UNKNOWN,64,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v
            const til::point delta{ 0, 2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0         F F F F
            // 0 1 1 0         F F F F
            // 0 1 1 0 v  -->  0 0 0 0
            // 0 0 0 0 v       0 1 1 0
            expected.set(til::rect{ til::point{ 0, 0 }, til::size{ 4, 2 } });
            expected.set(til::rect{ til::point{ 1, 3 }, til::size{ 2, 1 } });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,413,64,CPPASTProblemDeclaration,,<empty>
602115,UNKNOWN,65,,"Log::Comment(L""3.) Move down and left"");",9,<empty>,,436,65,CPPASTProblemDeclaration,,<empty>
602116,UNKNOWN,66,,"{
            auto actual = map;
            // Move all contents
            // |
            // v
            // |
            // v <-- <--
            const til::point delta{ -2, 2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0         F F F F          F F F F
            // 0 1 1 0         F F F F          F F F F
            // 0 1 1 0 v  -->  0 0 0 0   -->    0 0 F F
            // 0 0 0 0 v       0 1 1 0          1 0 F F
            //                 <-<-
            expected.set(til::rect{ til::point{ 0, 0 }, til::size{ 4, 2 } });
            expected.set(til::rect{ til::point{ 2, 2 }, til::size{ 2, 2 } });
            expected.set(til::point{ 0, 3 });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,437,66,CPPASTProblemDeclaration,,<empty>
602117,UNKNOWN,67,,"Log::Comment(L""4.) Move left"");",9,<empty>,,462,67,CPPASTProblemDeclaration,,<empty>
602118,UNKNOWN,68,,"{
            auto actual = map;
            // Move all contents
            // <-- <--
            const til::point delta{ -2, 0 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0         0 0 F F
            // 0 1 1 0         1 0 F F
            // 0 1 1 0    -->  1 0 F F
            // 0 0 0 0         0 0 F F
            // <--<--
            expected.set(til::rect{ til::point{ 2, 0 }, til::size{ 2, 4 } });
            expected.set(til::rect{ til::point{ 0, 1 }, til::size{ 1, 2 } });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,463,68,CPPASTProblemDeclaration,,<empty>
602119,UNKNOWN,69,,"Log::Comment(L""5.) Move up and left"");",9,<empty>,,484,69,CPPASTProblemDeclaration,,<empty>
602120,UNKNOWN,70,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // | <-- <--
            const til::point delta{ -2, -2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0 ^       0 1 1 0          1 0 F F
            // 0 1 1 0 ^       0 0 0 0          0 0 F F
            // 0 1 1 0    -->  F F F F   -->    F F F F
            // 0 0 0 0         F F F F          F F F F
            //                 <-<-
            expected.set(til::rect{ til::point{ 2, 0 }, til::size{ 2, 2 } });
            expected.set(til::rect{ til::point{ 0, 2 }, til::size{ 4, 2 } });
            expected.set(til::point{ 0, 0 });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,485,70,CPPASTProblemDeclaration,,<empty>
602121,UNKNOWN,71,,"Log::Comment(L""6.) Move up"");",9,<empty>,,510,71,CPPASTProblemDeclaration,,<empty>
602122,UNKNOWN,72,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // |
            const til::point delta{ 0, -2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0 ^       0 1 1 0
            // 0 1 1 0 ^       0 0 0 0
            // 0 1 1 0    -->  F F F F
            // 0 0 0 0         F F F F
            expected.set(til::rect{ til::point{ 1, 0 }, til::size{ 2, 1 } });
            expected.set(til::rect{ til::point{ 0, 2 }, til::size{ 4, 2 } });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,511,72,CPPASTProblemDeclaration,,<empty>
602123,UNKNOWN,73,,"Log::Comment(L""7.) Move up and right"");",9,<empty>,,534,73,CPPASTProblemDeclaration,,<empty>
602124,UNKNOWN,74,,"{
            auto actual = map;
            // Move all contents
            // ^
            // |
            // ^
            // | --> -->
            const til::point delta{ 2, -2 };

            til::bitmap expected{ mapSize };
            // Expected: (F is filling uncovered value)
            // 0 0 0 0 ^       0 1 1 0          F F 0 1
            // 0 1 1 0 ^       0 0 0 0          F F 0 0
            // 0 1 1 0    -->  F F F F   -->    F F F F
            // 0 0 0 0         F F F F          F F F F
            //                     ->->
            expected.set(til::point{ 3, 0 });
            expected.set(til::rect{ til::point{ 0, 2 }, til::size{ 4, 2 } });
            expected.set(til::rect{ til::point{ 0, 0 }, til::size{ 2, 2 } });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,535,74,CPPASTProblemDeclaration,,<empty>
602125,UNKNOWN,75,,"Log::Comment(L""8.) Move right"");",9,<empty>,,560,75,CPPASTProblemDeclaration,,<empty>
602126,UNKNOWN,76,,"{
            auto actual = map;
            // Move all contents
            // --> -->
            const til::point delta{ 2, 0 };

            til::bitmap expected{ mapSize };
            // Expected:  (F is filling uncovered value)
            // 0 0 0 0         F F 0 0
            // 0 1 1 0         F F 0 1
            // 0 1 1 0    -->  F F 0 1
            // 0 0 0 0         F F 0 0
            //     ->->
            expected.set(til::rect{ til::point{ 3, 1 }, til::size{ 1, 2 } });
            expected.set(til::rect{ til::point{ 0, 0 }, til::size{ 2, 4 } });

            actual.translate(delta, true);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,561,76,CPPASTProblemDeclaration,,<empty>
602127,UNKNOWN,77,,},5,<empty>,,581,77,CPPASTProblemDeclaration,,<empty>
602128,UNKNOWN,78,,"TEST_METHOD(SetReset)
    {
        const til::size sz{ 4, 4 };",5,<empty>,,583,78,CPPASTProblemDeclaration,,<empty>
602134,UNKNOWN,81,,"Log::Comment(L""All bits false on creation."");",9,<empty>,,589,81,CPPASTProblemDeclaration,,<empty>
602135,UNKNOWN,82,,VERIFY_IS_TRUE(bitmap._bits.none());,9,<empty>,,590,82,CPPASTProblemDeclaration,,<empty>
602142,UNKNOWN,85,,bitmap.set(point);,9,<empty>,,593,85,CPPASTProblemDeclaration,,<empty>
602144,UNKNOWN,87,,"expectedSet.emplace_back(til::rect{ 2, 2, 3, 3 }",9,<empty>,,596,87,CPPASTProblemDeclaration,,<empty>
602145,UNKNOWN,88,,);,57,<empty>,,596,88,CPPASTProblemDeclaration,,<empty>
602146,UNKNOWN,89,,"Log::Comment(L""Only the bit we set should be true."");",9,<empty>,,599,89,CPPASTProblemDeclaration,,<empty>
602147,UNKNOWN,90,,"_checkBits(expectedSet, bitmap);",9,<empty>,,600,90,CPPASTProblemDeclaration,,<empty>
602148,UNKNOWN,91,,"Log::Comment(L""Setting all should mean they're all true."");",9,<empty>,,602,91,CPPASTProblemDeclaration,,<empty>
602149,UNKNOWN,92,,bitmap.set_all();,9,<empty>,,603,92,CPPASTProblemDeclaration,,<empty>
602150,UNKNOWN,93,,expectedSet.clear();,9,<empty>,,605,93,CPPASTProblemDeclaration,,<empty>
602151,UNKNOWN,94,,expectedSet.emplace_back(til::rect{ bitmap._rc },9,<empty>,,606,94,CPPASTProblemDeclaration,,<empty>
602152,UNKNOWN,95,,);,57,<empty>,,606,95,CPPASTProblemDeclaration,,<empty>
602153,UNKNOWN,96,,"_checkBits(expectedSet, bitmap);",9,<empty>,,607,96,CPPASTProblemDeclaration,,<empty>
602154,UNKNOWN,97,,"Log::Comment(L""Now reset them all."");",9,<empty>,,609,97,CPPASTProblemDeclaration,,<empty>
602155,UNKNOWN,98,,bitmap.reset_all();,9,<empty>,,610,98,CPPASTProblemDeclaration,,<empty>
602156,UNKNOWN,99,,expectedSet.clear();,9,<empty>,,612,99,CPPASTProblemDeclaration,,<empty>
602157,UNKNOWN,100,,"_checkBits(expectedSet, bitmap);",9,<empty>,,613,100,CPPASTProblemDeclaration,,<empty>
602163,UNKNOWN,103,,"Log::Comment(L""Set a rectangle of bits and test they went on."");",9,<empty>,,616,103,CPPASTProblemDeclaration,,<empty>
602176,UNKNOWN,106,,bitmap.set(setZone);,9,<empty>,,622,106,CPPASTProblemDeclaration,,<empty>
602177,UNKNOWN,107,,expectedSet.clear();,9,<empty>,,624,107,CPPASTProblemDeclaration,,<empty>
602178,UNKNOWN,108,,expectedSet.emplace_back(setZone);,9,<empty>,,625,108,CPPASTProblemDeclaration,,<empty>
602179,UNKNOWN,109,,"_checkBits(expectedSet, bitmap);",9,<empty>,,626,109,CPPASTProblemDeclaration,,<empty>
602180,UNKNOWN,110,,"Log::Comment(L""Reset all."");",9,<empty>,,628,110,CPPASTProblemDeclaration,,<empty>
602181,UNKNOWN,111,,bitmap.reset_all();,9,<empty>,,629,111,CPPASTProblemDeclaration,,<empty>
602182,UNKNOWN,112,,expectedSet.clear();,9,<empty>,,631,112,CPPASTProblemDeclaration,,<empty>
602183,UNKNOWN,113,,"_checkBits(expectedSet, bitmap);",9,<empty>,,632,113,CPPASTProblemDeclaration,,<empty>
602184,UNKNOWN,114,,},5,<empty>,,633,114,CPPASTProblemDeclaration,,<empty>
602185,UNKNOWN,115,,"TEST_METHOD(SetResetOutOfBounds)
    {
        til::bitmap map{ til::size{ 4, 4 } };",5,<empty>,,635,115,CPPASTProblemDeclaration,,<empty>
602186,UNKNOWN,116,,"Log::Comment(L""1.) SetPoint out of bounds."");",9,<empty>,,638,116,CPPASTProblemDeclaration,,<empty>
602187,UNKNOWN,117,,"map.set(til::point{ 10, 10 }",9,<empty>,,639,117,CPPASTProblemDeclaration,,<empty>
602188,UNKNOWN,118,,);,37,<empty>,,639,118,CPPASTProblemDeclaration,,<empty>
602189,UNKNOWN,119,,"Log::Comment(L""2.) SetRectangle out of bounds."");",9,<empty>,,641,119,CPPASTProblemDeclaration,,<empty>
602190,UNKNOWN,120,,"map.set(til::rect{ til::point{ 2, 2 }, til::size{ 10, 10 } }",9,<empty>,,642,120,CPPASTProblemDeclaration,,<empty>
602191,UNKNOWN,121,,);,69,<empty>,,642,121,CPPASTProblemDeclaration,,<empty>
602199,UNKNOWN,124,,"VERIFY_ARE_EQUAL(2u, runs.size());",9,<empty>,,645,124,CPPASTProblemDeclaration,,<empty>
602200,UNKNOWN,125,,"VERIFY_ARE_EQUAL(til::rect(2, 2, 4, 3), runs[0]);",9,<empty>,,646,125,CPPASTProblemDeclaration,,<empty>
602201,UNKNOWN,126,,"VERIFY_ARE_EQUAL(til::rect(2, 3, 4, 4), runs[1]);",9,<empty>,,647,126,CPPASTProblemDeclaration,,<empty>
602202,UNKNOWN,127,,},5,<empty>,,648,127,CPPASTProblemDeclaration,,<empty>
602203,UNKNOWN,128,,"TEST_METHOD(Resize)
    {
        Log::Comment(L""Set up a bitmap with every location flagged."");",5,<empty>,,650,128,CPPASTProblemDeclaration,,<empty>
602217,UNKNOWN,134,,expectedFillRects.emplace_back(til::rect{ originalSize },9,<empty>,,660,134,CPPASTProblemDeclaration,,<empty>
602218,UNKNOWN,135,,);,65,<empty>,,660,135,CPPASTProblemDeclaration,,<empty>
602219,UNKNOWN,136,,"_checkBits(expectedFillRects, bitmap);",9,<empty>,,661,136,CPPASTProblemDeclaration,,<empty>
602220,UNKNOWN,137,,"Log::Comment(L""Attempt resize to the same size."");",9,<empty>,,663,137,CPPASTProblemDeclaration,,<empty>
602221,UNKNOWN,138,,VERIFY_IS_FALSE(bitmap.resize(originalSize));,9,<empty>,,664,138,CPPASTProblemDeclaration,,<empty>
602222,UNKNOWN,139,,"_checkBits(expectedFillRects, bitmap);",9,<empty>,,668,139,CPPASTProblemDeclaration,,<empty>
602223,UNKNOWN,140,,"Log::Comment(L""Attempt resize to a new size where both dimensions grow and we didn't ask for fill."");",9,<empty>,,670,140,CPPASTProblemDeclaration,,<empty>
602224,UNKNOWN,141,,"VERIFY_IS_TRUE(bitmap.resize(til::size{ 3, 3 }",9,<empty>,,671,141,CPPASTProblemDeclaration,,<empty>
602225,UNKNOWN,142,,));,55,<empty>,,671,142,CPPASTProblemDeclaration,,<empty>
602226,UNKNOWN,143,,"_checkBits(expectedFillRects, bitmap);",9,<empty>,,676,143,CPPASTProblemDeclaration,,<empty>
602227,UNKNOWN,144,,"Log::Comment(L""Set a bit out in the new space and check it."");",9,<empty>,,678,144,CPPASTProblemDeclaration,,<empty>
602234,UNKNOWN,147,,"expectedFillRects.emplace_back(til::rect{ 1, 2, 2, 3 }",9,<empty>,,680,147,CPPASTProblemDeclaration,,<empty>
602235,UNKNOWN,148,,);,63,<empty>,,680,148,CPPASTProblemDeclaration,,<empty>
602236,UNKNOWN,149,,bitmap.set(spaceBit);,9,<empty>,,681,149,CPPASTProblemDeclaration,,<empty>
602237,UNKNOWN,150,,"_checkBits(expectedFillRects, bitmap);",9,<empty>,,686,150,CPPASTProblemDeclaration,,<empty>
602238,UNKNOWN,151,,"Log::Comment(L""Grow vertically and shrink horizontally at the same time. Fill any new space."");",9,<empty>,,688,151,CPPASTProblemDeclaration,,<empty>
602239,UNKNOWN,152,,"expectedFillRects.emplace_back(til::rect{ til::point{ 0, 3 }, til::size{ 2, 1 } }",9,<empty>,,689,152,CPPASTProblemDeclaration,,<empty>
602240,UNKNOWN,153,,);,90,<empty>,,689,153,CPPASTProblemDeclaration,,<empty>
602241,UNKNOWN,154,,"bitmap.resize(til::size{ 2, 4 }",9,<empty>,,690,154,CPPASTProblemDeclaration,,<empty>
602242,UNKNOWN,155,,", true);",40,<empty>,,690,155,CPPASTProblemDeclaration,,<empty>
602243,UNKNOWN,156,,"_checkBits(expectedFillRects, bitmap);",9,<empty>,,696,156,CPPASTProblemDeclaration,,<empty>
602244,UNKNOWN,157,,},5,<empty>,,697,157,CPPASTProblemDeclaration,,<empty>
602245,UNKNOWN,158,,"TEST_METHOD(One)
    {
        Log::Comment(L""When created, it should be not be one."");",5,<empty>,,699,158,CPPASTProblemDeclaration,,<empty>
602254,UNKNOWN,161,,VERIFY_IS_FALSE(bitmap.one());,9,<empty>,,703,161,CPPASTProblemDeclaration,,<empty>
602255,UNKNOWN,162,,"Log::Comment(L""When a single point is set, it should be one."");",9,<empty>,,705,162,CPPASTProblemDeclaration,,<empty>
602256,UNKNOWN,163,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,706,163,CPPASTProblemDeclaration,,<empty>
602257,UNKNOWN,164,,);,38,<empty>,,706,164,CPPASTProblemDeclaration,,<empty>
602258,UNKNOWN,165,,VERIFY_IS_TRUE(bitmap.one());,9,<empty>,,707,165,CPPASTProblemDeclaration,,<empty>
602259,UNKNOWN,166,,"Log::Comment(L""Setting the same point again, should still be one."");",9,<empty>,,709,166,CPPASTProblemDeclaration,,<empty>
602260,UNKNOWN,167,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,710,167,CPPASTProblemDeclaration,,<empty>
602261,UNKNOWN,168,,);,38,<empty>,,710,168,CPPASTProblemDeclaration,,<empty>
602262,UNKNOWN,169,,VERIFY_IS_TRUE(bitmap.one());,9,<empty>,,711,169,CPPASTProblemDeclaration,,<empty>
602263,UNKNOWN,170,,"Log::Comment(L""Setting another point, it should no longer be one."");",9,<empty>,,713,170,CPPASTProblemDeclaration,,<empty>
602264,UNKNOWN,171,,"bitmap.set(til::point{ 0, 0 }",9,<empty>,,714,171,CPPASTProblemDeclaration,,<empty>
602265,UNKNOWN,172,,);,38,<empty>,,714,172,CPPASTProblemDeclaration,,<empty>
602266,UNKNOWN,173,,VERIFY_IS_FALSE(bitmap.one());,9,<empty>,,715,173,CPPASTProblemDeclaration,,<empty>
602267,UNKNOWN,174,,"Log::Comment(L""Clearing it, still not one."");",9,<empty>,,717,174,CPPASTProblemDeclaration,,<empty>
602268,UNKNOWN,175,,bitmap.reset_all();,9,<empty>,,718,175,CPPASTProblemDeclaration,,<empty>
602269,UNKNOWN,176,,VERIFY_IS_FALSE(bitmap.one());,9,<empty>,,719,176,CPPASTProblemDeclaration,,<empty>
602270,UNKNOWN,177,,"Log::Comment(L""Set one point, one again."");",9,<empty>,,721,177,CPPASTProblemDeclaration,,<empty>
602271,UNKNOWN,178,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,722,178,CPPASTProblemDeclaration,,<empty>
602272,UNKNOWN,179,,);,38,<empty>,,722,179,CPPASTProblemDeclaration,,<empty>
602273,UNKNOWN,180,,VERIFY_IS_TRUE(bitmap.one());,9,<empty>,,723,180,CPPASTProblemDeclaration,,<empty>
602274,UNKNOWN,181,,"Log::Comment(L""And setting all will no longer be one again."");",9,<empty>,,725,181,CPPASTProblemDeclaration,,<empty>
602275,UNKNOWN,182,,bitmap.set_all();,9,<empty>,,726,182,CPPASTProblemDeclaration,,<empty>
602276,UNKNOWN,183,,VERIFY_IS_FALSE(bitmap.one());,9,<empty>,,727,183,CPPASTProblemDeclaration,,<empty>
602277,UNKNOWN,184,,},5,<empty>,,728,184,CPPASTProblemDeclaration,,<empty>
602278,UNKNOWN,185,,"TEST_METHOD(Any)
    {
        Log::Comment(L""When created, it should be not be any."");",5,<empty>,,730,185,CPPASTProblemDeclaration,,<empty>
602287,UNKNOWN,188,,VERIFY_IS_FALSE(bitmap.any());,9,<empty>,,734,188,CPPASTProblemDeclaration,,<empty>
602288,UNKNOWN,189,,"Log::Comment(L""When a single point is set, it should be any."");",9,<empty>,,736,189,CPPASTProblemDeclaration,,<empty>
602289,UNKNOWN,190,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,737,190,CPPASTProblemDeclaration,,<empty>
602290,UNKNOWN,191,,);,38,<empty>,,737,191,CPPASTProblemDeclaration,,<empty>
602291,UNKNOWN,192,,VERIFY_IS_TRUE(bitmap.any());,9,<empty>,,738,192,CPPASTProblemDeclaration,,<empty>
602292,UNKNOWN,193,,"Log::Comment(L""Setting the same point again, should still be any."");",9,<empty>,,740,193,CPPASTProblemDeclaration,,<empty>
602293,UNKNOWN,194,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,741,194,CPPASTProblemDeclaration,,<empty>
602294,UNKNOWN,195,,);,38,<empty>,,741,195,CPPASTProblemDeclaration,,<empty>
602295,UNKNOWN,196,,VERIFY_IS_TRUE(bitmap.any());,9,<empty>,,742,196,CPPASTProblemDeclaration,,<empty>
602296,UNKNOWN,197,,"Log::Comment(L""Setting another point, it should still be any."");",9,<empty>,,744,197,CPPASTProblemDeclaration,,<empty>
602297,UNKNOWN,198,,"bitmap.set(til::point{ 0, 0 }",9,<empty>,,745,198,CPPASTProblemDeclaration,,<empty>
602298,UNKNOWN,199,,);,38,<empty>,,745,199,CPPASTProblemDeclaration,,<empty>
602299,UNKNOWN,200,,VERIFY_IS_TRUE(bitmap.any());,9,<empty>,,746,200,CPPASTProblemDeclaration,,<empty>
602300,UNKNOWN,201,,"Log::Comment(L""Clearing it, no longer any."");",9,<empty>,,748,201,CPPASTProblemDeclaration,,<empty>
602301,UNKNOWN,202,,bitmap.reset_all();,9,<empty>,,749,202,CPPASTProblemDeclaration,,<empty>
602302,UNKNOWN,203,,VERIFY_IS_FALSE(bitmap.any());,9,<empty>,,750,203,CPPASTProblemDeclaration,,<empty>
602303,UNKNOWN,204,,"Log::Comment(L""Set one point, one again, it's any."");",9,<empty>,,752,204,CPPASTProblemDeclaration,,<empty>
602304,UNKNOWN,205,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,753,205,CPPASTProblemDeclaration,,<empty>
602305,UNKNOWN,206,,);,38,<empty>,,753,206,CPPASTProblemDeclaration,,<empty>
602306,UNKNOWN,207,,VERIFY_IS_TRUE(bitmap.any());,9,<empty>,,754,207,CPPASTProblemDeclaration,,<empty>
602307,UNKNOWN,208,,"Log::Comment(L""And setting all will be any as well."");",9,<empty>,,756,208,CPPASTProblemDeclaration,,<empty>
602308,UNKNOWN,209,,bitmap.set_all();,9,<empty>,,757,209,CPPASTProblemDeclaration,,<empty>
602309,UNKNOWN,210,,VERIFY_IS_TRUE(bitmap.any());,9,<empty>,,758,210,CPPASTProblemDeclaration,,<empty>
602310,UNKNOWN,211,,},5,<empty>,,759,211,CPPASTProblemDeclaration,,<empty>
602311,UNKNOWN,212,,"TEST_METHOD(None)
    {
        Log::Comment(L""When created, it should be none."");",5,<empty>,,761,212,CPPASTProblemDeclaration,,<empty>
602320,UNKNOWN,215,,VERIFY_IS_TRUE(bitmap.none());,9,<empty>,,765,215,CPPASTProblemDeclaration,,<empty>
602321,UNKNOWN,216,,"Log::Comment(L""When it is modified with a set, it should no longer be none."");",9,<empty>,,767,216,CPPASTProblemDeclaration,,<empty>
602322,UNKNOWN,217,,"bitmap.set(til::point{ 0, 0 }",9,<empty>,,768,217,CPPASTProblemDeclaration,,<empty>
602323,UNKNOWN,218,,);,38,<empty>,,768,218,CPPASTProblemDeclaration,,<empty>
602324,UNKNOWN,219,,VERIFY_IS_FALSE(bitmap.none());,9,<empty>,,769,219,CPPASTProblemDeclaration,,<empty>
602325,UNKNOWN,220,,"Log::Comment(L""Resetting all, it will report none again."");",9,<empty>,,771,220,CPPASTProblemDeclaration,,<empty>
602326,UNKNOWN,221,,bitmap.reset_all();,9,<empty>,,772,221,CPPASTProblemDeclaration,,<empty>
602327,UNKNOWN,222,,VERIFY_IS_TRUE(bitmap.none());,9,<empty>,,773,222,CPPASTProblemDeclaration,,<empty>
602328,UNKNOWN,223,,"Log::Comment(L""And setting all will no longer be none again."");",9,<empty>,,775,223,CPPASTProblemDeclaration,,<empty>
602329,UNKNOWN,224,,bitmap.set_all();,9,<empty>,,776,224,CPPASTProblemDeclaration,,<empty>
602330,UNKNOWN,225,,VERIFY_IS_FALSE(bitmap.none());,9,<empty>,,777,225,CPPASTProblemDeclaration,,<empty>
602331,UNKNOWN,226,,},5,<empty>,,778,226,CPPASTProblemDeclaration,,<empty>
602332,UNKNOWN,227,,"TEST_METHOD(All)
    {
        Log::Comment(L""When created, it should be not be all."");",5,<empty>,,780,227,CPPASTProblemDeclaration,,<empty>
602341,UNKNOWN,230,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,784,230,CPPASTProblemDeclaration,,<empty>
602342,UNKNOWN,231,,"Log::Comment(L""When a single point is set, it should not be all."");",9,<empty>,,786,231,CPPASTProblemDeclaration,,<empty>
602343,UNKNOWN,232,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,787,232,CPPASTProblemDeclaration,,<empty>
602344,UNKNOWN,233,,);,38,<empty>,,787,233,CPPASTProblemDeclaration,,<empty>
602345,UNKNOWN,234,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,788,234,CPPASTProblemDeclaration,,<empty>
602346,UNKNOWN,235,,"Log::Comment(L""Setting the same point again, should still not be all."");",9,<empty>,,790,235,CPPASTProblemDeclaration,,<empty>
602347,UNKNOWN,236,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,791,236,CPPASTProblemDeclaration,,<empty>
602348,UNKNOWN,237,,);,38,<empty>,,791,237,CPPASTProblemDeclaration,,<empty>
602349,UNKNOWN,238,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,792,238,CPPASTProblemDeclaration,,<empty>
602350,UNKNOWN,239,,"Log::Comment(L""Setting another point, it should still not be all."");",9,<empty>,,794,239,CPPASTProblemDeclaration,,<empty>
602351,UNKNOWN,240,,"bitmap.set(til::point{ 0, 0 }",9,<empty>,,795,240,CPPASTProblemDeclaration,,<empty>
602352,UNKNOWN,241,,);,38,<empty>,,795,241,CPPASTProblemDeclaration,,<empty>
602353,UNKNOWN,242,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,796,242,CPPASTProblemDeclaration,,<empty>
602354,UNKNOWN,243,,"Log::Comment(L""Clearing it, still not all."");",9,<empty>,,798,243,CPPASTProblemDeclaration,,<empty>
602355,UNKNOWN,244,,bitmap.reset_all();,9,<empty>,,799,244,CPPASTProblemDeclaration,,<empty>
602356,UNKNOWN,245,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,800,245,CPPASTProblemDeclaration,,<empty>
602357,UNKNOWN,246,,"Log::Comment(L""Set one point, one again, not all."");",9,<empty>,,802,246,CPPASTProblemDeclaration,,<empty>
602358,UNKNOWN,247,,"bitmap.set(til::point{ 1, 0 }",9,<empty>,,803,247,CPPASTProblemDeclaration,,<empty>
602359,UNKNOWN,248,,);,38,<empty>,,803,248,CPPASTProblemDeclaration,,<empty>
602360,UNKNOWN,249,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,804,249,CPPASTProblemDeclaration,,<empty>
602361,UNKNOWN,250,,"Log::Comment(L""And setting all will finally be all."");",9,<empty>,,806,250,CPPASTProblemDeclaration,,<empty>
602362,UNKNOWN,251,,bitmap.set_all();,9,<empty>,,807,251,CPPASTProblemDeclaration,,<empty>
602363,UNKNOWN,252,,VERIFY_IS_TRUE(bitmap.all());,9,<empty>,,808,252,CPPASTProblemDeclaration,,<empty>
602364,UNKNOWN,253,,"Log::Comment(L""Clearing it, back to not all."");",9,<empty>,,810,253,CPPASTProblemDeclaration,,<empty>
602365,UNKNOWN,254,,bitmap.reset_all();,9,<empty>,,811,254,CPPASTProblemDeclaration,,<empty>
602366,UNKNOWN,255,,VERIFY_IS_FALSE(bitmap.all());,9,<empty>,,812,255,CPPASTProblemDeclaration,,<empty>
602367,UNKNOWN,256,,},5,<empty>,,813,256,CPPASTProblemDeclaration,,<empty>
602368,UNKNOWN,257,,"TEST_METHOD(Size)
    {
        til::size sz{ 5, 10 };",5,<empty>,,815,257,CPPASTProblemDeclaration,,<empty>
602374,UNKNOWN,260,,"VERIFY_ARE_EQUAL(sz, map.size());",9,<empty>,,820,260,CPPASTProblemDeclaration,,<empty>
602375,UNKNOWN,261,,},5,<empty>,,821,261,CPPASTProblemDeclaration,,<empty>
602376,UNKNOWN,262,,"TEST_METHOD(Runs)
    {
        // This map --> Those runs
        // 1 1 0 1      A A _ B
        // 1 0 1 1      C _ D D
        // 0 0 1 0      _ _ E _
        // 0 1 1 0      _ F F _
        Log::Comment(L""Set up a bitmap with some runs."");",5,<empty>,,823,262,CPPASTProblemDeclaration,,<empty>
602386,UNKNOWN,265,,"map.set(til::rect{ til::point{ 0, 0 }, til::size{ 2, 1 } }",9,<empty>,,838,265,CPPASTProblemDeclaration,,<empty>
602387,UNKNOWN,266,,);,67,<empty>,,838,266,CPPASTProblemDeclaration,,<empty>
602388,UNKNOWN,267,,"map.set(til::rect{ til::point{ 2, 1 }, til::size{ 1, 3 } }",9,<empty>,,844,267,CPPASTProblemDeclaration,,<empty>
602389,UNKNOWN,268,,);,67,<empty>,,844,268,CPPASTProblemDeclaration,,<empty>
602390,UNKNOWN,269,,"map.set(til::rect{ til::point{ 3, 0 }, til::size{ 1, 2 } }",9,<empty>,,850,269,CPPASTProblemDeclaration,,<empty>
602391,UNKNOWN,270,,);,67,<empty>,,850,270,CPPASTProblemDeclaration,,<empty>
602392,UNKNOWN,271,,"map.set(til::point{ 0, 1 }",9,<empty>,,856,271,CPPASTProblemDeclaration,,<empty>
602393,UNKNOWN,272,,);,35,<empty>,,856,272,CPPASTProblemDeclaration,,<empty>
602394,UNKNOWN,273,,"map.set(til::point{ 1, 3 }",9,<empty>,,862,273,CPPASTProblemDeclaration,,<empty>
602395,UNKNOWN,274,,);,35,<empty>,,862,274,CPPASTProblemDeclaration,,<empty>
602396,UNKNOWN,275,,"Log::Comment(L""Building the expected run rectangles."");",9,<empty>,,864,275,CPPASTProblemDeclaration,,<empty>
602398,UNKNOWN,277,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 2, 1 } }",9,<empty>,,872,277,CPPASTProblemDeclaration,,<empty>
602399,UNKNOWN,278,,);,78,<empty>,,872,278,CPPASTProblemDeclaration,,<empty>
602400,UNKNOWN,279,,"expected.push_back(til::rect{ til::point{ 3, 0 }, til::size{ 1, 1 } }",9,<empty>,,873,279,CPPASTProblemDeclaration,,<empty>
602401,UNKNOWN,280,,);,78,<empty>,,873,280,CPPASTProblemDeclaration,,<empty>
602402,UNKNOWN,281,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 1, 1 } }",9,<empty>,,874,281,CPPASTProblemDeclaration,,<empty>
602403,UNKNOWN,282,,);,78,<empty>,,874,282,CPPASTProblemDeclaration,,<empty>
602404,UNKNOWN,283,,"expected.push_back(til::rect{ til::point{ 2, 1 }, til::size{ 2, 1 } }",9,<empty>,,875,283,CPPASTProblemDeclaration,,<empty>
602405,UNKNOWN,284,,);,78,<empty>,,875,284,CPPASTProblemDeclaration,,<empty>
602406,UNKNOWN,285,,"expected.push_back(til::rect{ til::point{ 2, 2 }, til::size{ 1, 1 } }",9,<empty>,,876,285,CPPASTProblemDeclaration,,<empty>
602407,UNKNOWN,286,,);,78,<empty>,,876,286,CPPASTProblemDeclaration,,<empty>
602408,UNKNOWN,287,,"expected.push_back(til::rect{ til::point{ 1, 3 }, til::size{ 2, 1 } }",9,<empty>,,877,287,CPPASTProblemDeclaration,,<empty>
602409,UNKNOWN,288,,);,78,<empty>,,877,288,CPPASTProblemDeclaration,,<empty>
602410,UNKNOWN,289,,"Log::Comment(L""Run the iterator and collect the runs."");",9,<empty>,,879,289,CPPASTProblemDeclaration,,<empty>
602412,UNKNOWN,291,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,881,291,CPPASTProblemDeclaration,,<empty>
602413,UNKNOWN,292,,"Log::Comment(L""Verify they match what we expected."");",9,<empty>,,886,292,CPPASTProblemDeclaration,,<empty>
602414,UNKNOWN,293,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,887,293,CPPASTProblemDeclaration,,<empty>
602415,UNKNOWN,294,,"Log::Comment(L""Clear the map and iterate and make sure we get no results."");",9,<empty>,,889,294,CPPASTProblemDeclaration,,<empty>
602416,UNKNOWN,295,,map.reset_all();,9,<empty>,,890,295,CPPASTProblemDeclaration,,<empty>
602417,UNKNOWN,296,,expected.clear();,9,<empty>,,892,296,CPPASTProblemDeclaration,,<empty>
602418,UNKNOWN,297,,actual.clear();,9,<empty>,,893,297,CPPASTProblemDeclaration,,<empty>
602419,UNKNOWN,298,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,894,298,CPPASTProblemDeclaration,,<empty>
602420,UNKNOWN,299,,"Log::Comment(L""Verify they're empty."");",9,<empty>,,899,299,CPPASTProblemDeclaration,,<empty>
602421,UNKNOWN,300,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,900,300,CPPASTProblemDeclaration,,<empty>
602422,UNKNOWN,301,,"Log::Comment(L""Set point and validate runs updated."");",9,<empty>,,902,301,CPPASTProblemDeclaration,,<empty>
602429,UNKNOWN,304,,"expected.push_back(til::rect{ 2, 2, 3, 3 }",9,<empty>,,904,304,CPPASTProblemDeclaration,,<empty>
602430,UNKNOWN,305,,);,51,<empty>,,904,305,CPPASTProblemDeclaration,,<empty>
602431,UNKNOWN,306,,map.set(setPoint);,9,<empty>,,905,306,CPPASTProblemDeclaration,,<empty>
602432,UNKNOWN,307,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,907,307,CPPASTProblemDeclaration,,<empty>
602433,UNKNOWN,308,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,911,308,CPPASTProblemDeclaration,,<empty>
602434,UNKNOWN,309,,"Log::Comment(L""Set rectangle and validate runs updated."");",9,<empty>,,913,309,CPPASTProblemDeclaration,,<empty>
602444,UNKNOWN,312,,expected.clear();,9,<empty>,,915,312,CPPASTProblemDeclaration,,<empty>
602445,UNKNOWN,313,,"expected.push_back(til::rect{ til::point{ 2, 2 }, til::size{ 2, 1 } }",9,<empty>,,916,313,CPPASTProblemDeclaration,,<empty>
602446,UNKNOWN,314,,);,78,<empty>,,916,314,CPPASTProblemDeclaration,,<empty>
602447,UNKNOWN,315,,"expected.push_back(til::rect{ til::point{ 2, 3 }, til::size{ 2, 1 } }",9,<empty>,,917,315,CPPASTProblemDeclaration,,<empty>
602448,UNKNOWN,316,,);,78,<empty>,,917,316,CPPASTProblemDeclaration,,<empty>
602449,UNKNOWN,317,,map.set(setRect);,9,<empty>,,918,317,CPPASTProblemDeclaration,,<empty>
602450,UNKNOWN,318,,actual.clear();,9,<empty>,,920,318,CPPASTProblemDeclaration,,<empty>
602451,UNKNOWN,319,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,921,319,CPPASTProblemDeclaration,,<empty>
602452,UNKNOWN,320,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,925,320,CPPASTProblemDeclaration,,<empty>
602453,UNKNOWN,321,,"Log::Comment(L""Set all and validate runs updated."");",9,<empty>,,927,321,CPPASTProblemDeclaration,,<empty>
602454,UNKNOWN,322,,expected.clear();,9,<empty>,,928,322,CPPASTProblemDeclaration,,<empty>
602455,UNKNOWN,323,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 4, 1 } }",9,<empty>,,929,323,CPPASTProblemDeclaration,,<empty>
602456,UNKNOWN,324,,);,78,<empty>,,929,324,CPPASTProblemDeclaration,,<empty>
602457,UNKNOWN,325,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 4, 1 } }",9,<empty>,,930,325,CPPASTProblemDeclaration,,<empty>
602458,UNKNOWN,326,,);,78,<empty>,,930,326,CPPASTProblemDeclaration,,<empty>
602459,UNKNOWN,327,,"expected.push_back(til::rect{ til::point{ 0, 2 }, til::size{ 4, 1 } }",9,<empty>,,931,327,CPPASTProblemDeclaration,,<empty>
602460,UNKNOWN,328,,);,78,<empty>,,931,328,CPPASTProblemDeclaration,,<empty>
602461,UNKNOWN,329,,"expected.push_back(til::rect{ til::point{ 0, 3 }, til::size{ 4, 1 } }",9,<empty>,,932,329,CPPASTProblemDeclaration,,<empty>
602462,UNKNOWN,330,,);,78,<empty>,,932,330,CPPASTProblemDeclaration,,<empty>
602463,UNKNOWN,331,,map.set_all();,9,<empty>,,933,331,CPPASTProblemDeclaration,,<empty>
602464,UNKNOWN,332,,actual.clear();,9,<empty>,,935,332,CPPASTProblemDeclaration,,<empty>
602465,UNKNOWN,333,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,936,333,CPPASTProblemDeclaration,,<empty>
602466,UNKNOWN,334,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,940,334,CPPASTProblemDeclaration,,<empty>
602467,UNKNOWN,335,,"Log::Comment(L""Resize and validate runs updated."");",9,<empty>,,942,335,CPPASTProblemDeclaration,,<empty>
602474,UNKNOWN,338,,expected.clear();,9,<empty>,,944,338,CPPASTProblemDeclaration,,<empty>
602475,UNKNOWN,339,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 3, 1 } }",9,<empty>,,945,339,CPPASTProblemDeclaration,,<empty>
602476,UNKNOWN,340,,);,78,<empty>,,945,340,CPPASTProblemDeclaration,,<empty>
602477,UNKNOWN,341,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 3, 1 } }",9,<empty>,,946,341,CPPASTProblemDeclaration,,<empty>
602478,UNKNOWN,342,,);,78,<empty>,,946,342,CPPASTProblemDeclaration,,<empty>
602479,UNKNOWN,343,,"expected.push_back(til::rect{ til::point{ 0, 2 }, til::size{ 3, 1 } }",9,<empty>,,947,343,CPPASTProblemDeclaration,,<empty>
602480,UNKNOWN,344,,);,78,<empty>,,947,344,CPPASTProblemDeclaration,,<empty>
602481,UNKNOWN,345,,map.resize(newSize);,9,<empty>,,948,345,CPPASTProblemDeclaration,,<empty>
602482,UNKNOWN,346,,actual.clear();,9,<empty>,,950,346,CPPASTProblemDeclaration,,<empty>
602483,UNKNOWN,347,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,951,347,CPPASTProblemDeclaration,,<empty>
602484,UNKNOWN,348,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,955,348,CPPASTProblemDeclaration,,<empty>
602485,UNKNOWN,349,,},5,<empty>,,956,349,CPPASTProblemDeclaration,,<empty>
602486,UNKNOWN,350,,"TEST_METHOD(RunsWithPmr)
    {
        // This is a copy of the above test, but with a pmr::bitmap.
        std::pmr::unsynchronized_pool_resource pool{ til::pmr::get_default_resource() };",5,<empty>,,958,350,CPPASTProblemDeclaration,,<empty>
602487,UNKNOWN,351,,"Log::Comment(L""Set up a PMR bitmap with some runs."");",9,<empty>,,968,351,CPPASTProblemDeclaration,,<empty>
602499,UNKNOWN,354,,"map.set(til::rect{ til::point{ 0, 0 }, til::size{ 2, 1 } }",9,<empty>,,976,354,CPPASTProblemDeclaration,,<empty>
602500,UNKNOWN,355,,);,67,<empty>,,976,355,CPPASTProblemDeclaration,,<empty>
602501,UNKNOWN,356,,"map.set(til::rect{ til::point{ 2, 1 }, til::size{ 1, 3 } }",9,<empty>,,982,356,CPPASTProblemDeclaration,,<empty>
602502,UNKNOWN,357,,);,67,<empty>,,982,357,CPPASTProblemDeclaration,,<empty>
602503,UNKNOWN,358,,"map.set(til::rect{ til::point{ 3, 0 }, til::size{ 1, 2 } }",9,<empty>,,988,358,CPPASTProblemDeclaration,,<empty>
602504,UNKNOWN,359,,);,67,<empty>,,988,359,CPPASTProblemDeclaration,,<empty>
602505,UNKNOWN,360,,"map.set(til::point{ 0, 1 }",9,<empty>,,994,360,CPPASTProblemDeclaration,,<empty>
602506,UNKNOWN,361,,);,35,<empty>,,994,361,CPPASTProblemDeclaration,,<empty>
602507,UNKNOWN,362,,"map.set(til::point{ 1, 3 }",9,<empty>,,1000,362,CPPASTProblemDeclaration,,<empty>
602508,UNKNOWN,363,,);,35,<empty>,,1000,363,CPPASTProblemDeclaration,,<empty>
602509,UNKNOWN,364,,"Log::Comment(L""Building the expected run rectangles."");",9,<empty>,,1002,364,CPPASTProblemDeclaration,,<empty>
602511,UNKNOWN,366,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 2, 1 } }",9,<empty>,,1010,366,CPPASTProblemDeclaration,,<empty>
602512,UNKNOWN,367,,);,78,<empty>,,1010,367,CPPASTProblemDeclaration,,<empty>
602513,UNKNOWN,368,,"expected.push_back(til::rect{ til::point{ 3, 0 }, til::size{ 1, 1 } }",9,<empty>,,1011,368,CPPASTProblemDeclaration,,<empty>
602514,UNKNOWN,369,,);,78,<empty>,,1011,369,CPPASTProblemDeclaration,,<empty>
602515,UNKNOWN,370,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 1, 1 } }",9,<empty>,,1012,370,CPPASTProblemDeclaration,,<empty>
602516,UNKNOWN,371,,);,78,<empty>,,1012,371,CPPASTProblemDeclaration,,<empty>
602517,UNKNOWN,372,,"expected.push_back(til::rect{ til::point{ 2, 1 }, til::size{ 2, 1 } }",9,<empty>,,1013,372,CPPASTProblemDeclaration,,<empty>
602518,UNKNOWN,373,,);,78,<empty>,,1013,373,CPPASTProblemDeclaration,,<empty>
602519,UNKNOWN,374,,"expected.push_back(til::rect{ til::point{ 2, 2 }, til::size{ 1, 1 } }",9,<empty>,,1014,374,CPPASTProblemDeclaration,,<empty>
602520,UNKNOWN,375,,);,78,<empty>,,1014,375,CPPASTProblemDeclaration,,<empty>
602521,UNKNOWN,376,,"expected.push_back(til::rect{ til::point{ 1, 3 }, til::size{ 2, 1 } }",9,<empty>,,1015,376,CPPASTProblemDeclaration,,<empty>
602522,UNKNOWN,377,,);,78,<empty>,,1015,377,CPPASTProblemDeclaration,,<empty>
602523,UNKNOWN,378,,"Log::Comment(L""Run the iterator and collect the runs."");",9,<empty>,,1017,378,CPPASTProblemDeclaration,,<empty>
602525,UNKNOWN,380,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1019,380,CPPASTProblemDeclaration,,<empty>
602526,UNKNOWN,381,,"Log::Comment(L""Verify they match what we expected."");",9,<empty>,,1024,381,CPPASTProblemDeclaration,,<empty>
602527,UNKNOWN,382,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1025,382,CPPASTProblemDeclaration,,<empty>
602528,UNKNOWN,383,,"Log::Comment(L""Clear the map and iterate and make sure we get no results."");",9,<empty>,,1027,383,CPPASTProblemDeclaration,,<empty>
602529,UNKNOWN,384,,map.reset_all();,9,<empty>,,1028,384,CPPASTProblemDeclaration,,<empty>
602530,UNKNOWN,385,,expected.clear();,9,<empty>,,1030,385,CPPASTProblemDeclaration,,<empty>
602531,UNKNOWN,386,,actual.clear();,9,<empty>,,1031,386,CPPASTProblemDeclaration,,<empty>
602532,UNKNOWN,387,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1032,387,CPPASTProblemDeclaration,,<empty>
602533,UNKNOWN,388,,"Log::Comment(L""Verify they're empty."");",9,<empty>,,1037,388,CPPASTProblemDeclaration,,<empty>
602534,UNKNOWN,389,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1038,389,CPPASTProblemDeclaration,,<empty>
602535,UNKNOWN,390,,"Log::Comment(L""Set point and validate runs updated."");",9,<empty>,,1040,390,CPPASTProblemDeclaration,,<empty>
602542,UNKNOWN,393,,"expected.push_back(til::rect{ 2, 2, 3, 3 }",9,<empty>,,1042,393,CPPASTProblemDeclaration,,<empty>
602543,UNKNOWN,394,,);,51,<empty>,,1042,394,CPPASTProblemDeclaration,,<empty>
602544,UNKNOWN,395,,map.set(setPoint);,9,<empty>,,1043,395,CPPASTProblemDeclaration,,<empty>
602545,UNKNOWN,396,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1045,396,CPPASTProblemDeclaration,,<empty>
602546,UNKNOWN,397,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1049,397,CPPASTProblemDeclaration,,<empty>
602547,UNKNOWN,398,,"Log::Comment(L""Set rectangle and validate runs updated."");",9,<empty>,,1051,398,CPPASTProblemDeclaration,,<empty>
602557,UNKNOWN,401,,expected.clear();,9,<empty>,,1053,401,CPPASTProblemDeclaration,,<empty>
602558,UNKNOWN,402,,"expected.push_back(til::rect{ til::point{ 2, 2 }, til::size{ 2, 1 } }",9,<empty>,,1054,402,CPPASTProblemDeclaration,,<empty>
602559,UNKNOWN,403,,);,78,<empty>,,1054,403,CPPASTProblemDeclaration,,<empty>
602560,UNKNOWN,404,,"expected.push_back(til::rect{ til::point{ 2, 3 }, til::size{ 2, 1 } }",9,<empty>,,1055,404,CPPASTProblemDeclaration,,<empty>
602561,UNKNOWN,405,,);,78,<empty>,,1055,405,CPPASTProblemDeclaration,,<empty>
602562,UNKNOWN,406,,map.set(setRect);,9,<empty>,,1056,406,CPPASTProblemDeclaration,,<empty>
602563,UNKNOWN,407,,actual.clear();,9,<empty>,,1058,407,CPPASTProblemDeclaration,,<empty>
602564,UNKNOWN,408,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1059,408,CPPASTProblemDeclaration,,<empty>
602565,UNKNOWN,409,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1063,409,CPPASTProblemDeclaration,,<empty>
602566,UNKNOWN,410,,"Log::Comment(L""Set all and validate runs updated."");",9,<empty>,,1065,410,CPPASTProblemDeclaration,,<empty>
602567,UNKNOWN,411,,expected.clear();,9,<empty>,,1066,411,CPPASTProblemDeclaration,,<empty>
602568,UNKNOWN,412,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 4, 1 } }",9,<empty>,,1067,412,CPPASTProblemDeclaration,,<empty>
602569,UNKNOWN,413,,);,78,<empty>,,1067,413,CPPASTProblemDeclaration,,<empty>
602570,UNKNOWN,414,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 4, 1 } }",9,<empty>,,1068,414,CPPASTProblemDeclaration,,<empty>
602571,UNKNOWN,415,,);,78,<empty>,,1068,415,CPPASTProblemDeclaration,,<empty>
602572,UNKNOWN,416,,"expected.push_back(til::rect{ til::point{ 0, 2 }, til::size{ 4, 1 } }",9,<empty>,,1069,416,CPPASTProblemDeclaration,,<empty>
602573,UNKNOWN,417,,);,78,<empty>,,1069,417,CPPASTProblemDeclaration,,<empty>
602574,UNKNOWN,418,,"expected.push_back(til::rect{ til::point{ 0, 3 }, til::size{ 4, 1 } }",9,<empty>,,1070,418,CPPASTProblemDeclaration,,<empty>
602575,UNKNOWN,419,,);,78,<empty>,,1070,419,CPPASTProblemDeclaration,,<empty>
602576,UNKNOWN,420,,map.set_all();,9,<empty>,,1071,420,CPPASTProblemDeclaration,,<empty>
602577,UNKNOWN,421,,actual.clear();,9,<empty>,,1073,421,CPPASTProblemDeclaration,,<empty>
602578,UNKNOWN,422,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1074,422,CPPASTProblemDeclaration,,<empty>
602579,UNKNOWN,423,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1078,423,CPPASTProblemDeclaration,,<empty>
602580,UNKNOWN,424,,"Log::Comment(L""Resize and validate runs updated."");",9,<empty>,,1080,424,CPPASTProblemDeclaration,,<empty>
602587,UNKNOWN,427,,expected.clear();,9,<empty>,,1082,427,CPPASTProblemDeclaration,,<empty>
602588,UNKNOWN,428,,"expected.push_back(til::rect{ til::point{ 0, 0 }, til::size{ 3, 1 } }",9,<empty>,,1083,428,CPPASTProblemDeclaration,,<empty>
602589,UNKNOWN,429,,);,78,<empty>,,1083,429,CPPASTProblemDeclaration,,<empty>
602590,UNKNOWN,430,,"expected.push_back(til::rect{ til::point{ 0, 1 }, til::size{ 3, 1 } }",9,<empty>,,1084,430,CPPASTProblemDeclaration,,<empty>
602591,UNKNOWN,431,,);,78,<empty>,,1084,431,CPPASTProblemDeclaration,,<empty>
602592,UNKNOWN,432,,"expected.push_back(til::rect{ til::point{ 0, 2 }, til::size{ 3, 1 } }",9,<empty>,,1085,432,CPPASTProblemDeclaration,,<empty>
602593,UNKNOWN,433,,);,78,<empty>,,1085,433,CPPASTProblemDeclaration,,<empty>
602594,UNKNOWN,434,,map.resize(newSize);,9,<empty>,,1086,434,CPPASTProblemDeclaration,,<empty>
602595,UNKNOWN,435,,actual.clear();,9,<empty>,,1088,435,CPPASTProblemDeclaration,,<empty>
602596,UNKNOWN,436,,"for (auto run : map.runs())
        {
            actual.push_back(run);
        }",9,<empty>,,1089,436,CPPASTProblemDeclaration,,<empty>
602597,UNKNOWN,437,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,1093,437,CPPASTProblemDeclaration,,<empty>
602598,UNKNOWN,438,,},5,<empty>,,1094,438,CPPASTProblemDeclaration,,<empty>
602599,UNKNOWN,439,,};,1,<empty>,,1095,439,CPPASTProblemDeclaration,,<empty>
602937,UNKNOWN,2,,"TEST_METHOD(ConvertToColorRef)
    {
        til::color rgb{ 0xf0, 0x0d, 0xca, 0xfe };",5,<empty>,,47,2,CPPASTProblemDeclaration,,<empty>
602938,UNKNOWN,3,,"VERIFY_ARE_EQUAL(0x00CA0DF0u, static_cast<COLORREF>(rgb));",9,<empty>,,51,3,CPPASTProblemDeclaration,,<empty>
602939,UNKNOWN,4,,},5,<empty>,,52,4,CPPASTProblemDeclaration,,<empty>
602950,UNKNOWN,7,,"TEST_METHOD(ConvertFromIntColorStructs)
    {
        Quad_rgba<int> q1{ 0xca, 0xfe, 0xf0, 0x0d };",5,<empty>,,66,7,CPPASTProblemDeclaration,,<empty>
602959,UNKNOWN,10,,"VERIFY_ARE_EQUAL(t1, static_cast<til::color>(q1));",9,<empty>,,71,10,CPPASTProblemDeclaration,,<empty>
602976,UNKNOWN,15,,"VERIFY_ARE_EQUAL(t2, static_cast<til::color>(q2));",9,<empty>,,76,15,CPPASTProblemDeclaration,,<empty>
602977,UNKNOWN,16,,},5,<empty>,,77,16,CPPASTProblemDeclaration,,<empty>
602978,UNKNOWN,17,,"TEST_METHOD(ConvertFromFloatColorStructs)
    {
        Quad_rgba<float> q1{ 0.730f, 0.867f, 0.793f, 0.997f };",5,<empty>,,79,17,CPPASTProblemDeclaration,,<empty>
602987,UNKNOWN,20,,"VERIFY_ARE_EQUAL(t1, static_cast<til::color>(q1));",9,<empty>,,84,20,CPPASTProblemDeclaration,,<empty>
603004,UNKNOWN,25,,"VERIFY_ARE_EQUAL(t2, static_cast<til::color>(q2));",9,<empty>,,89,25,CPPASTProblemDeclaration,,<empty>
603005,UNKNOWN,26,,},5,<empty>,,90,26,CPPASTProblemDeclaration,,<empty>
603006,UNKNOWN,27,,"TEST_METHOD(WithAlpha)
    {
        const COLORREF c = 0x00FEEDFAu;",5,<empty>,,92,27,CPPASTProblemDeclaration,,<empty>
603012,UNKNOWN,30,,"VERIFY_ARE_EQUAL(0xfa, fromColorRef.r);",9,<empty>,,97,30,CPPASTProblemDeclaration,,<empty>
603013,UNKNOWN,31,,"VERIFY_ARE_EQUAL(0xed, fromColorRef.g);",9,<empty>,,98,31,CPPASTProblemDeclaration,,<empty>
603014,UNKNOWN,32,,"VERIFY_ARE_EQUAL(0xfe, fromColorRef.b);",9,<empty>,,99,32,CPPASTProblemDeclaration,,<empty>
603015,UNKNOWN,33,,"VERIFY_ARE_EQUAL(0xff, fromColorRef.a);",9,<empty>,,100,33,CPPASTProblemDeclaration,,<empty>
603025,UNKNOWN,36,,"VERIFY_ARE_NOT_EQUAL(colorWithAlpha, fromColorRef);",9,<empty>,,104,36,CPPASTProblemDeclaration,,<empty>
603026,UNKNOWN,37,,"VERIFY_ARE_EQUAL(0xfa, colorWithAlpha.r);",9,<empty>,,106,37,CPPASTProblemDeclaration,,<empty>
603027,UNKNOWN,38,,"VERIFY_ARE_EQUAL(0xed, colorWithAlpha.g);",9,<empty>,,107,38,CPPASTProblemDeclaration,,<empty>
603028,UNKNOWN,39,,"VERIFY_ARE_EQUAL(0xfe, colorWithAlpha.b);",9,<empty>,,108,39,CPPASTProblemDeclaration,,<empty>
603029,UNKNOWN,40,,"VERIFY_ARE_EQUAL(0x7f, colorWithAlpha.a);",9,<empty>,,109,40,CPPASTProblemDeclaration,,<empty>
603030,UNKNOWN,41,,},5,<empty>,,110,41,CPPASTProblemDeclaration,,<empty>
603031,UNKNOWN,42,,"TEST_METHOD(LayerOver)
    {
        static constexpr til::color orange{ 255, 165, 0, 255 };",5,<empty>,,112,42,CPPASTProblemDeclaration,,<empty>
603056,UNKNOWN,49,,"VERIFY_ARE_EQUAL(orange, orange.layer_over(blue));",9,<empty>,,119,49,CPPASTProblemDeclaration,,<empty>
603057,UNKNOWN,50,,"VERIFY_ARE_EQUAL(blue, blue.layer_over(orange));",9,<empty>,,120,50,CPPASTProblemDeclaration,,<empty>
603058,UNKNOWN,51,,"VERIFY_ARE_EQUAL(til::color(165, 179, 90, 255), orangeWithAlpha.layer_over(blue));",9,<empty>,,121,51,CPPASTProblemDeclaration,,<empty>
603059,UNKNOWN,52,,"VERIFY_ARE_EQUAL(til::color(177, 177, 78, 237), orangeWithAlpha.layer_over(blueWithAlpha));",9,<empty>,,122,52,CPPASTProblemDeclaration,,<empty>
603060,UNKNOWN,53,,"VERIFY_ARE_EQUAL(til::color(50, 197, 205, 255), blueWithAlpha.layer_over(orange));",9,<empty>,,123,53,CPPASTProblemDeclaration,,<empty>
603061,UNKNOWN,54,,"VERIFY_ARE_EQUAL(til::color(35, 200, 220, 237), blueWithAlpha.layer_over(orangeWithAlpha));",9,<empty>,,124,54,CPPASTProblemDeclaration,,<empty>
603062,UNKNOWN,55,,},5,<empty>,,125,55,CPPASTProblemDeclaration,,<empty>
603063,UNKNOWN,56,,};,1,<empty>,,126,56,CPPASTProblemDeclaration,,<empty>
603248,UNKNOWN,2,,"TEST_METHOD(TestMethods)
    {
        enum class Flags
        {
            Zero,
            One,
            Two,
            Three,
            Four
        };",5,<empty>,,91,2,CPPASTProblemDeclaration,,<empty>
603249,UNKNOWN,3,,"Log::Comment(L""Start with bits 0, 2, and 4 set"");",9,<empty>,,102,3,CPPASTProblemDeclaration,,<empty>
603263,UNKNOWN,6,,"VERIFY_ARE_EQUAL(0b10101u, flags.bits());",9,<empty>,,104,6,CPPASTProblemDeclaration,,<empty>
603264,UNKNOWN,7,,"Log::Comment(L""Test bits 1 through 4 with the test method"");",9,<empty>,,106,7,CPPASTProblemDeclaration,,<empty>
603265,UNKNOWN,8,,VERIFY_IS_FALSE(flags.test(Flags::One));,9,<empty>,,107,8,CPPASTProblemDeclaration,,<empty>
603266,UNKNOWN,9,,VERIFY_IS_TRUE(flags.test(Flags::Two));,9,<empty>,,108,9,CPPASTProblemDeclaration,,<empty>
603267,UNKNOWN,10,,VERIFY_IS_FALSE(flags.test(Flags::Three));,9,<empty>,,109,10,CPPASTProblemDeclaration,,<empty>
603268,UNKNOWN,11,,VERIFY_IS_TRUE(flags.test(Flags::Four));,9,<empty>,,110,11,CPPASTProblemDeclaration,,<empty>
603269,UNKNOWN,12,,"Log::Comment(L""Test if any bits are set"");",9,<empty>,,112,12,CPPASTProblemDeclaration,,<empty>
603270,UNKNOWN,13,,VERIFY_IS_TRUE(flags.any());,9,<empty>,,113,13,CPPASTProblemDeclaration,,<empty>
603271,UNKNOWN,14,,"Log::Comment(L""Test if either bit 1 or 3 are set"");",9,<empty>,,114,14,CPPASTProblemDeclaration,,<empty>
603272,UNKNOWN,15,,"VERIFY_IS_FALSE(flags.any(Flags::One, Flags::Three));",9,<empty>,,115,15,CPPASTProblemDeclaration,,<empty>
603273,UNKNOWN,16,,"Log::Comment(L""Test if either bit 1 or 4 are set"");",9,<empty>,,116,16,CPPASTProblemDeclaration,,<empty>
603274,UNKNOWN,17,,"VERIFY_IS_TRUE(flags.any(Flags::One, Flags::Four));",9,<empty>,,117,17,CPPASTProblemDeclaration,,<empty>
603275,UNKNOWN,18,,"Log::Comment(L""Test if all bits are set"");",9,<empty>,,119,18,CPPASTProblemDeclaration,,<empty>
603276,UNKNOWN,19,,VERIFY_IS_FALSE(flags.all());,9,<empty>,,120,19,CPPASTProblemDeclaration,,<empty>
603277,UNKNOWN,20,,"Log::Comment(L""Test if both bits 0 and 4 are set"");",9,<empty>,,121,20,CPPASTProblemDeclaration,,<empty>
603278,UNKNOWN,21,,"VERIFY_IS_TRUE(flags.all(Flags::Zero, Flags::Four));",9,<empty>,,122,21,CPPASTProblemDeclaration,,<empty>
603279,UNKNOWN,22,,"Log::Comment(L""Test if both bits 0 and 3 are set"");",9,<empty>,,123,22,CPPASTProblemDeclaration,,<empty>
603280,UNKNOWN,23,,"VERIFY_IS_FALSE(flags.all(Flags::Zero, Flags::Three));",9,<empty>,,124,23,CPPASTProblemDeclaration,,<empty>
603281,UNKNOWN,24,,},5,<empty>,,125,24,CPPASTProblemDeclaration,,<empty>
603282,UNKNOWN,25,,};,1,<empty>,,126,25,CPPASTProblemDeclaration,,<empty>
603292,UNKNOWN,1,,BOOL,1,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
603416,UNKNOWN,4,,"TEST_METHOD(ToString)
    {
        til::env environment;",5,<empty>,,55,4,CPPASTProblemDeclaration,,<empty>
603417,UNKNOWN,5,,"environment.as_map().insert_or_assign(L""A"", L""Apple"");",9,<empty>,,58,5,CPPASTProblemDeclaration,,<empty>
603418,UNKNOWN,6,,"environment.as_map().insert_or_assign(L""B"", L""Banana"");",9,<empty>,,59,6,CPPASTProblemDeclaration,,<empty>
603419,UNKNOWN,7,,"environment.as_map().insert_or_assign(L""C"", L""Cassowary"");",9,<empty>,,60,7,CPPASTProblemDeclaration,,<empty>
603441,UNKNOWN,14,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,65,14,CPPASTProblemDeclaration,,<empty>
603442,UNKNOWN,15,,},5,<empty>,,66,15,CPPASTProblemDeclaration,,<empty>
603443,UNKNOWN,16,,"TEST_METHOD(TestExpandEnvironmentStrings)
    {
        {
            til::env environment;",5,<empty>,,68,16,CPPASTProblemDeclaration,,<empty>
603444,UNKNOWN,17,,"environment.as_map().insert_or_assign(L""ENV"", L""Bar"");",13,<empty>,,72,17,CPPASTProblemDeclaration,,<empty>
603445,UNKNOWN,18,,"VERIFY_ARE_EQUAL(L""FooBarBaz"", environment.expand_environment_strings(L""Foo%ENV%Baz""));",13,<empty>,,74,18,CPPASTProblemDeclaration,,<empty>
603446,UNKNOWN,19,,},9,<empty>,,75,19,CPPASTProblemDeclaration,,<empty>
603447,UNKNOWN,20,,"{
            til::env environment;

            VERIFY_ARE_EQUAL(L""Foo%ENV%Baz"", environment.expand_environment_strings(L""Foo%ENV%Baz""));
        }",9,<empty>,,77,20,CPPASTProblemDeclaration,,<empty>
603448,UNKNOWN,21,,"{
            til::env environment;

            VERIFY_ARE_EQUAL(L""Foo%ENV"", environment.expand_environment_strings(L""Foo%ENV""));
        }",9,<empty>,,83,21,CPPASTProblemDeclaration,,<empty>
603449,UNKNOWN,22,,},5,<empty>,,88,22,CPPASTProblemDeclaration,,<empty>
603450,UNKNOWN,23,,};,1,<empty>,,89,23,CPPASTProblemDeclaration,,<empty>
603477,UNKNOWN,1,,size_t,37,<empty>,,23,1,CPPASTTypeId,,<empty>
603487,UNKNOWN,1,,size_t,29,<empty>,,28,1,CPPASTTypeId,,<empty>
603514,UNKNOWN,2,,"template<>
struct ::std::hash<Data>
{
    constexpr size_t operator()(int key) const noexcept
    {
        return til::flat_set_hash_integer(static_cast<size_t>(key));
    }

    constexpr size_t operator()(Data d) const noexcept
    {
        return til::flat_set_hash_integer(d.value);
    }
};",1,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
603517,UNKNOWN,-1,,"TEST_METHOD(Basic)
    {
        til::linear_flat_set<Data> set;",5,<empty>,,53,2,CPPASTProblemDeclaration,,<empty>
603526,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(&entry1, &entry2);",9,<empty>,,65,7,CPPASTProblemDeclaration,,<empty>
603527,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(123u, entry2.value);",9,<empty>,,66,8,CPPASTProblemDeclaration,,<empty>
603528,UNKNOWN,4,,},5,<empty>,,67,4,CPPASTProblemDeclaration,,<empty>
603529,UNKNOWN,5,,};,1,<empty>,,68,5,CPPASTProblemDeclaration,,<empty>
603550,UNKNOWN,-1,,"TEST_METHOD(Basic)
    {
        til::generational<Data> src;",5,<empty>,,21,2,CPPASTProblemDeclaration,,<empty>
603552,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(0, src->value);",9,<empty>,,27,4,CPPASTProblemDeclaration,,<empty>
603553,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(0, (*src).value);",9,<empty>,,28,5,CPPASTProblemDeclaration,,<empty>
603554,UNKNOWN,-1,,src.write()->value = 123;,9,<empty>,,31,6,CPPASTProblemDeclaration,,<empty>
603555,UNKNOWN,-1,,"VERIFY_ARE_NOT_EQUAL(dst, src);",9,<empty>,,33,7,CPPASTProblemDeclaration,,<empty>
603556,UNKNOWN,-1,,dst = src;,9,<empty>,,36,8,CPPASTProblemDeclaration,,<empty>
603557,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(dst, src);",9,<empty>,,38,9,CPPASTProblemDeclaration,,<empty>
603558,UNKNOWN,-1,,"VERIFY_ARE_EQUAL(123, dst->value);",9,<empty>,,40,10,CPPASTProblemDeclaration,,<empty>
603559,UNKNOWN,3,,},5,<empty>,,41,3,CPPASTProblemDeclaration,,<empty>
603560,UNKNOWN,4,,};,1,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
603572,UNKNOWN,-1,,"TEST_METHOD(TestVectors)
    {
        struct Test
        {
            std::string_view input;
            size_t seed;
            uint64_t expected64;
            uint32_t expected32;
        };",5,<empty>,,16,2,CPPASTProblemDeclaration,,<empty>
603574,UNKNOWN,-1,,"for (const auto& t : tests)
        {
            const auto actual = til::hasher{ t.seed }.write(t.input).finalize();
#if defined(TIL_HASH_32BIT)
            VERIFY_ARE_EQUAL(t.expected32, actual);
#else
            VERIFY_ARE_EQUAL(t.expected64, actual);
#endif
        }",9,<empty>,,36,4,CPPASTProblemDeclaration,,<empty>
603624,UNKNOWN,2,,},5,<empty>,,45,2,CPPASTProblemDeclaration,,<empty>
603625,UNKNOWN,3,,};,1,<empty>,,46,3,CPPASTProblemDeclaration,,<empty>
603698,UNKNOWN,2,,"TEST_METHOD(Rounding)
    {
        _RunCases<FloatType>(
            til::math::rounding,
            {
                { 1., 1 },
                { 1.9, 2 },
                { -7.1, -7 },
                { -8.5, -9 },
                { INT_MAX + 0.1, INT_MAX },
                { INT_MIN - 0.1, INT_MIN },
                { INT_MAX + 1.1, 0, true },
                { INT_MIN - 1.1, 0, true },
                { infinity, 0, true },
                { -infinity, 0, true },
                { nan, 0, true },
            });",5,<empty>,,85,2,CPPASTProblemDeclaration,,<empty>
603699,UNKNOWN,3,,},5,<empty>,,102,3,CPPASTProblemDeclaration,,<empty>
603700,UNKNOWN,4,,"TEST_METHOD(NormalIntegers)
    {
        _RunCases<IntegralType>(
            til::math::rounding,
            {
                { 1, 1 },
                { -1, -1 },
                { INT_MAX, INT_MAX },
                { INT_MIN, INT_MIN },
            });",5,<empty>,,104,4,CPPASTProblemDeclaration,,<empty>
603701,UNKNOWN,5,,},5,<empty>,,114,5,CPPASTProblemDeclaration,,<empty>
603702,UNKNOWN,6,,};,1,<empty>,,115,6,CPPASTProblemDeclaration,,<empty>
603748,UNKNOWN,2,,"TEST_METHOD(PointMulSize)
    {
        const til::point pt{ 5, 10 };",5,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
603771,UNKNOWN,9,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,40,9,CPPASTProblemDeclaration,,<empty>
603772,UNKNOWN,10,,},5,<empty>,,41,10,CPPASTProblemDeclaration,,<empty>
603773,UNKNOWN,11,,"TEST_METHOD(PointDivSize)
    {
        const til::point pt{ 5, 10 };",5,<empty>,,43,11,CPPASTProblemDeclaration,,<empty>
603796,UNKNOWN,18,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,49,18,CPPASTProblemDeclaration,,<empty>
603797,UNKNOWN,19,,},5,<empty>,,50,19,CPPASTProblemDeclaration,,<empty>
603798,UNKNOWN,20,,"TEST_METHOD(SizeAddPoint)
    {
        const til::size pt{ 5, 10 };",5,<empty>,,52,20,CPPASTProblemDeclaration,,<empty>
603821,UNKNOWN,27,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,58,27,CPPASTProblemDeclaration,,<empty>
603822,UNKNOWN,28,,},5,<empty>,,59,28,CPPASTProblemDeclaration,,<empty>
603823,UNKNOWN,29,,"TEST_METHOD(SizeSubPoint)
    {
        const til::size pt{ 5, 10 };",5,<empty>,,61,29,CPPASTProblemDeclaration,,<empty>
603846,UNKNOWN,36,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,67,36,CPPASTProblemDeclaration,,<empty>
603847,UNKNOWN,37,,},5,<empty>,,68,37,CPPASTProblemDeclaration,,<empty>
603848,UNKNOWN,38,,"TEST_METHOD(SizeMulPoint)
    {
        const til::size pt{ 5, 10 };",5,<empty>,,70,38,CPPASTProblemDeclaration,,<empty>
603871,UNKNOWN,45,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,76,45,CPPASTProblemDeclaration,,<empty>
603872,UNKNOWN,46,,},5,<empty>,,77,46,CPPASTProblemDeclaration,,<empty>
603873,UNKNOWN,47,,"TEST_METHOD(SizeDivPoint)
    {
        const til::size pt{ 5, 10 };",5,<empty>,,79,47,CPPASTProblemDeclaration,,<empty>
603896,UNKNOWN,54,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,85,54,CPPASTProblemDeclaration,,<empty>
603897,UNKNOWN,55,,},5,<empty>,,86,55,CPPASTProblemDeclaration,,<empty>
603898,UNKNOWN,56,,};,1,<empty>,,87,56,CPPASTProblemDeclaration,,<empty>
603961,UNKNOWN,3,,"TEST_METHOD(RawFloatingConstruct)
    {
        const til::point pt{ til::math::rounding, 3.2f, 7.6f };",5,<empty>,,37,3,CPPASTProblemDeclaration,,<empty>
603962,UNKNOWN,4,,"VERIFY_ARE_EQUAL(3, pt.x);",9,<empty>,,40,4,CPPASTProblemDeclaration,,<empty>
603963,UNKNOWN,5,,"VERIFY_ARE_EQUAL(8, pt.y);",9,<empty>,,41,5,CPPASTProblemDeclaration,,<empty>
603964,UNKNOWN,6,,},5,<empty>,,42,6,CPPASTProblemDeclaration,,<empty>
603965,UNKNOWN,7,,"TEST_METHOD(SignedConstruct)
    {
        const auto x = -5;",5,<empty>,,44,7,CPPASTProblemDeclaration,,<empty>
603977,UNKNOWN,12,,"VERIFY_ARE_EQUAL(x, pt.x);",9,<empty>,,50,12,CPPASTProblemDeclaration,,<empty>
603978,UNKNOWN,13,,"VERIFY_ARE_EQUAL(y, pt.y);",9,<empty>,,51,13,CPPASTProblemDeclaration,,<empty>
603979,UNKNOWN,14,,},5,<empty>,,52,14,CPPASTProblemDeclaration,,<empty>
603980,UNKNOWN,15,,"TEST_METHOD(CoordConstruct)
    {
        COORD coord{ -5, 10 };",5,<empty>,,54,15,CPPASTProblemDeclaration,,<empty>
603989,UNKNOWN,18,,"VERIFY_ARE_EQUAL(coord.X, pt.x);",9,<empty>,,59,18,CPPASTProblemDeclaration,,<empty>
603990,UNKNOWN,19,,"VERIFY_ARE_EQUAL(coord.Y, pt.y);",9,<empty>,,60,19,CPPASTProblemDeclaration,,<empty>
603991,UNKNOWN,20,,},5,<empty>,,61,20,CPPASTProblemDeclaration,,<empty>
603992,UNKNOWN,21,,"TEST_METHOD(PointConstruct)
    {
        POINT point{ 5, -10 };",5,<empty>,,63,21,CPPASTProblemDeclaration,,<empty>
603998,UNKNOWN,24,,"VERIFY_ARE_EQUAL(point.x, pt.x);",9,<empty>,,68,24,CPPASTProblemDeclaration,,<empty>
603999,UNKNOWN,25,,"VERIFY_ARE_EQUAL(point.y, pt.y);",9,<empty>,,69,25,CPPASTProblemDeclaration,,<empty>
604000,UNKNOWN,26,,},5,<empty>,,70,26,CPPASTProblemDeclaration,,<empty>
604001,UNKNOWN,27,,"TEST_METHOD(Equality)
    {
        Log::Comment(L""Equal."");",5,<empty>,,72,27,CPPASTProblemDeclaration,,<empty>
604002,UNKNOWN,28,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 == s2);
        }",9,<empty>,,75,28,CPPASTProblemDeclaration,,<empty>
604003,UNKNOWN,29,,"Log::Comment(L""Left Width changed."");",9,<empty>,,81,29,CPPASTProblemDeclaration,,<empty>
604004,UNKNOWN,30,,"{
            const til::point s1{ 4, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,82,30,CPPASTProblemDeclaration,,<empty>
604005,UNKNOWN,31,,"Log::Comment(L""Right Width changed."");",9,<empty>,,88,31,CPPASTProblemDeclaration,,<empty>
604006,UNKNOWN,32,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 6, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,89,32,CPPASTProblemDeclaration,,<empty>
604007,UNKNOWN,33,,"Log::Comment(L""Left Height changed."");",9,<empty>,,95,33,CPPASTProblemDeclaration,,<empty>
604008,UNKNOWN,34,,"{
            const til::point s1{ 5, 9 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,96,34,CPPASTProblemDeclaration,,<empty>
604009,UNKNOWN,35,,"Log::Comment(L""Right Height changed."");",9,<empty>,,102,35,CPPASTProblemDeclaration,,<empty>
604010,UNKNOWN,36,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 11 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,103,36,CPPASTProblemDeclaration,,<empty>
604011,UNKNOWN,37,,},5,<empty>,,108,37,CPPASTProblemDeclaration,,<empty>
604012,UNKNOWN,38,,"TEST_METHOD(Inequality)
    {
        Log::Comment(L""Equal."");",5,<empty>,,110,38,CPPASTProblemDeclaration,,<empty>
604013,UNKNOWN,39,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 != s2);
        }",9,<empty>,,113,39,CPPASTProblemDeclaration,,<empty>
604014,UNKNOWN,40,,"Log::Comment(L""Left Width changed."");",9,<empty>,,119,40,CPPASTProblemDeclaration,,<empty>
604015,UNKNOWN,41,,"{
            const til::point s1{ 4, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,120,41,CPPASTProblemDeclaration,,<empty>
604016,UNKNOWN,42,,"Log::Comment(L""Right Width changed."");",9,<empty>,,126,42,CPPASTProblemDeclaration,,<empty>
604017,UNKNOWN,43,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 6, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,127,43,CPPASTProblemDeclaration,,<empty>
604018,UNKNOWN,44,,"Log::Comment(L""Left Height changed."");",9,<empty>,,133,44,CPPASTProblemDeclaration,,<empty>
604019,UNKNOWN,45,,"{
            const til::point s1{ 5, 9 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,134,45,CPPASTProblemDeclaration,,<empty>
604020,UNKNOWN,46,,"Log::Comment(L""Right Height changed."");",9,<empty>,,140,46,CPPASTProblemDeclaration,,<empty>
604021,UNKNOWN,47,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 11 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,141,47,CPPASTProblemDeclaration,,<empty>
604022,UNKNOWN,48,,},5,<empty>,,146,48,CPPASTProblemDeclaration,,<empty>
604023,UNKNOWN,49,,"TEST_METHOD(LessThanOrEqual)
    {
        Log::Comment(L""Equal."");",5,<empty>,,148,49,CPPASTProblemDeclaration,,<empty>
604024,UNKNOWN,50,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 <= s2);
        }",9,<empty>,,151,50,CPPASTProblemDeclaration,,<empty>
604025,UNKNOWN,51,,"Log::Comment(L""Left Width changed."");",9,<empty>,,157,51,CPPASTProblemDeclaration,,<empty>
604026,UNKNOWN,52,,"{
            const til::point s1{ 4, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 <= s2);
        }",9,<empty>,,158,52,CPPASTProblemDeclaration,,<empty>
604027,UNKNOWN,53,,"Log::Comment(L""Right Width changed."");",9,<empty>,,164,53,CPPASTProblemDeclaration,,<empty>
604028,UNKNOWN,54,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 6, 10 };
            VERIFY_IS_TRUE(s1 <= s2);
        }",9,<empty>,,165,54,CPPASTProblemDeclaration,,<empty>
604029,UNKNOWN,55,,"Log::Comment(L""Left Height changed."");",9,<empty>,,171,55,CPPASTProblemDeclaration,,<empty>
604030,UNKNOWN,56,,"{
            const til::point s1{ 5, 9 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 <= s2);
        }",9,<empty>,,172,56,CPPASTProblemDeclaration,,<empty>
604031,UNKNOWN,57,,"Log::Comment(L""Right Height changed."");",9,<empty>,,178,57,CPPASTProblemDeclaration,,<empty>
604032,UNKNOWN,58,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 11 };
            VERIFY_IS_TRUE(s1 <= s2);
        }",9,<empty>,,179,58,CPPASTProblemDeclaration,,<empty>
604033,UNKNOWN,59,,},5,<empty>,,184,59,CPPASTProblemDeclaration,,<empty>
604034,UNKNOWN,60,,"TEST_METHOD(GreaterThanOrEqual)
    {
        Log::Comment(L""Equal."");",5,<empty>,,186,60,CPPASTProblemDeclaration,,<empty>
604035,UNKNOWN,61,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 >= s2);
        }",9,<empty>,,189,61,CPPASTProblemDeclaration,,<empty>
604036,UNKNOWN,62,,"Log::Comment(L""Left Width changed."");",9,<empty>,,195,62,CPPASTProblemDeclaration,,<empty>
604037,UNKNOWN,63,,"{
            const til::point s1{ 4, 10 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 >= s2);
        }",9,<empty>,,196,63,CPPASTProblemDeclaration,,<empty>
604038,UNKNOWN,64,,"Log::Comment(L""Right Width changed."");",9,<empty>,,202,64,CPPASTProblemDeclaration,,<empty>
604039,UNKNOWN,65,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 6, 10 };
            VERIFY_IS_FALSE(s1 >= s2);
        }",9,<empty>,,203,65,CPPASTProblemDeclaration,,<empty>
604040,UNKNOWN,66,,"Log::Comment(L""Left Height changed."");",9,<empty>,,209,66,CPPASTProblemDeclaration,,<empty>
604041,UNKNOWN,67,,"{
            const til::point s1{ 5, 9 };
            const til::point s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 >= s2);
        }",9,<empty>,,210,67,CPPASTProblemDeclaration,,<empty>
604042,UNKNOWN,68,,"Log::Comment(L""Right Height changed."");",9,<empty>,,216,68,CPPASTProblemDeclaration,,<empty>
604043,UNKNOWN,69,,"{
            const til::point s1{ 5, 10 };
            const til::point s2{ 5, 11 };
            VERIFY_IS_FALSE(s1 >= s2);
        }",9,<empty>,,217,69,CPPASTProblemDeclaration,,<empty>
604044,UNKNOWN,70,,},5,<empty>,,222,70,CPPASTProblemDeclaration,,<empty>
604045,UNKNOWN,71,,"TEST_METHOD(Addition)
    {
        Log::Comment(L""Addition of two things that should be in bounds."");",5,<empty>,,224,71,CPPASTProblemDeclaration,,<empty>
604046,UNKNOWN,72,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x + pt2.x, pt.y + pt2.y };

            VERIFY_ARE_EQUAL(expected, pt + pt2);
        }",9,<empty>,,227,72,CPPASTProblemDeclaration,,<empty>
604047,UNKNOWN,73,,"Log::Comment(L""Addition results in value that is too large (x)."");",9,<empty>,,236,73,CPPASTProblemDeclaration,,<empty>
604048,UNKNOWN,74,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                pt + pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,237,74,CPPASTProblemDeclaration,,<empty>
604049,UNKNOWN,75,,"Log::Comment(L""Addition results in value that is too large (y)."");",9,<empty>,,249,75,CPPASTProblemDeclaration,,<empty>
604050,UNKNOWN,76,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                pt + pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,250,76,CPPASTProblemDeclaration,,<empty>
604051,UNKNOWN,77,,},5,<empty>,,261,77,CPPASTProblemDeclaration,,<empty>
604052,UNKNOWN,78,,"TEST_METHOD(AdditionInplace)
    {
        Log::Comment(L""Addition of two things that should be in bounds."");",5,<empty>,,263,78,CPPASTProblemDeclaration,,<empty>
604053,UNKNOWN,79,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x + pt2.x, pt.y + pt2.y };

            auto actual = pt;
            actual += pt2;

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,266,79,CPPASTProblemDeclaration,,<empty>
604054,UNKNOWN,80,,"Log::Comment(L""Addition results in value that is too large (x)."");",9,<empty>,,278,80,CPPASTProblemDeclaration,,<empty>
604055,UNKNOWN,81,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                auto actual = pt;
                actual += pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,279,81,CPPASTProblemDeclaration,,<empty>
604056,UNKNOWN,82,,"Log::Comment(L""Addition results in value that is too large (y)."");",9,<empty>,,292,82,CPPASTProblemDeclaration,,<empty>
604057,UNKNOWN,83,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                auto actual = pt;
                actual += pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,293,83,CPPASTProblemDeclaration,,<empty>
604058,UNKNOWN,84,,},5,<empty>,,305,84,CPPASTProblemDeclaration,,<empty>
604059,UNKNOWN,85,,"TEST_METHOD(Subtraction)
    {
        Log::Comment(L""Subtraction of two things that should be in bounds."");",5,<empty>,,307,85,CPPASTProblemDeclaration,,<empty>
604060,UNKNOWN,86,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x - pt2.x, pt.y - pt2.y };

            VERIFY_ARE_EQUAL(expected, pt - pt2);
        }",9,<empty>,,310,86,CPPASTProblemDeclaration,,<empty>
604061,UNKNOWN,87,,"Log::Comment(L""Subtraction results in value that is too small (x)."");",9,<empty>,,319,87,CPPASTProblemDeclaration,,<empty>
604062,UNKNOWN,88,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ -2, -2 };

            auto fn = [&]() {
                pt2 - pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,320,88,CPPASTProblemDeclaration,,<empty>
604063,UNKNOWN,89,,"Log::Comment(L""Subtraction results in value that is too small (y)."");",9,<empty>,,332,89,CPPASTProblemDeclaration,,<empty>
604064,UNKNOWN,90,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ -2, -2 };

            auto fn = [&]() {
                pt2 - pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,333,90,CPPASTProblemDeclaration,,<empty>
604065,UNKNOWN,91,,},5,<empty>,,344,91,CPPASTProblemDeclaration,,<empty>
604066,UNKNOWN,92,,"TEST_METHOD(SubtractionInplace)
    {
        Log::Comment(L""Subtraction of two things that should be in bounds."");",5,<empty>,,346,92,CPPASTProblemDeclaration,,<empty>
604067,UNKNOWN,93,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x - pt2.x, pt.y - pt2.y };

            auto actual = pt;
            actual -= pt2;

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,349,93,CPPASTProblemDeclaration,,<empty>
604068,UNKNOWN,94,,"Log::Comment(L""Subtraction results in value that is too small (x)."");",9,<empty>,,361,94,CPPASTProblemDeclaration,,<empty>
604069,UNKNOWN,95,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ -2, -2 };

            auto fn = [&]() {
                auto actual = pt2;
                actual -= pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,362,95,CPPASTProblemDeclaration,,<empty>
604070,UNKNOWN,96,,"Log::Comment(L""Subtraction results in value that is too small (y)."");",9,<empty>,,375,96,CPPASTProblemDeclaration,,<empty>
604071,UNKNOWN,97,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ -2, -2 };

            auto fn = [&]() {
                auto actual = pt2;
                actual -= pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,376,97,CPPASTProblemDeclaration,,<empty>
604072,UNKNOWN,98,,},5,<empty>,,388,98,CPPASTProblemDeclaration,,<empty>
604073,UNKNOWN,99,,"TEST_METHOD(Multiplication)
    {
        Log::Comment(L""Multiplication of two things that should be in bounds."");",5,<empty>,,390,99,CPPASTProblemDeclaration,,<empty>
604074,UNKNOWN,100,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x * pt2.x, pt.y * pt2.y };

            VERIFY_ARE_EQUAL(expected, pt * pt2);
        }",9,<empty>,,393,100,CPPASTProblemDeclaration,,<empty>
604075,UNKNOWN,101,,"Log::Comment(L""Multiplication results in value that is too large (x)."");",9,<empty>,,402,101,CPPASTProblemDeclaration,,<empty>
604076,UNKNOWN,102,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 10, 10 };

            auto fn = [&]() {
                pt* pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,403,102,CPPASTProblemDeclaration,,<empty>
604077,UNKNOWN,103,,"Log::Comment(L""Multiplication results in value that is too large (y)."");",9,<empty>,,415,103,CPPASTProblemDeclaration,,<empty>
604078,UNKNOWN,104,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ 10, 10 };

            auto fn = [&]() {
                pt* pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,416,104,CPPASTProblemDeclaration,,<empty>
604079,UNKNOWN,105,,},5,<empty>,,427,105,CPPASTProblemDeclaration,,<empty>
604080,UNKNOWN,106,,"TEST_METHOD(MultiplicationInplace)
    {
        Log::Comment(L""Multiplication of two things that should be in bounds."");",5,<empty>,,429,106,CPPASTProblemDeclaration,,<empty>
604081,UNKNOWN,107,,"{
            const til::point pt{ 5, 10 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x * pt2.x, pt.y * pt2.y };

            auto actual = pt;
            actual *= pt2;

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,432,107,CPPASTProblemDeclaration,,<empty>
604082,UNKNOWN,108,,"Log::Comment(L""Multiplication results in value that is too large (x)."");",9,<empty>,,444,108,CPPASTProblemDeclaration,,<empty>
604083,UNKNOWN,109,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 10, 10 };

            auto fn = [&]() {
                auto actual = pt;
                actual *= pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,445,109,CPPASTProblemDeclaration,,<empty>
604084,UNKNOWN,110,,"Log::Comment(L""Multiplication results in value that is too large (y)."");",9,<empty>,,458,110,CPPASTProblemDeclaration,,<empty>
604085,UNKNOWN,111,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const til::point pt2{ 10, 10 };

            auto fn = [&]() {
                auto actual = pt;
                actual *= pt2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,459,111,CPPASTProblemDeclaration,,<empty>
604086,UNKNOWN,112,,},5,<empty>,,471,112,CPPASTProblemDeclaration,,<empty>
604087,UNKNOWN,113,,"TEST_METHOD(Division)
    {
        Log::Comment(L""Division of two things that should be in bounds."");",5,<empty>,,473,113,CPPASTProblemDeclaration,,<empty>
604088,UNKNOWN,114,,"{
            const til::point pt{ 555, 510 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x / pt2.x, pt.y / pt2.y };

            VERIFY_ARE_EQUAL(expected, pt / pt2);
        }",9,<empty>,,476,114,CPPASTProblemDeclaration,,<empty>
604089,UNKNOWN,115,,"Log::Comment(L""Division by zero"");",9,<empty>,,485,115,CPPASTProblemDeclaration,,<empty>
604090,UNKNOWN,116,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                pt2 / pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,486,116,CPPASTProblemDeclaration,,<empty>
604091,UNKNOWN,117,,},5,<empty>,,497,117,CPPASTProblemDeclaration,,<empty>
604092,UNKNOWN,118,,"TEST_METHOD(DivisionInplace)
    {
        Log::Comment(L""Division of two things that should be in bounds."");",5,<empty>,,499,118,CPPASTProblemDeclaration,,<empty>
604093,UNKNOWN,119,,"{
            const til::point pt{ 555, 510 };
            const til::point pt2{ 23, 47 };

            const til::point expected{ pt.x / pt2.x, pt.y / pt2.y };
            auto actual = pt;
            actual /= pt2;

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,502,119,CPPASTProblemDeclaration,,<empty>
604094,UNKNOWN,120,,"Log::Comment(L""Division by zero"");",9,<empty>,,513,120,CPPASTProblemDeclaration,,<empty>
604095,UNKNOWN,121,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const til::point pt2{ 1, 1 };

            auto fn = [&]() {
                auto actual = pt2;
                actual /= pt;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,514,121,CPPASTProblemDeclaration,,<empty>
604096,UNKNOWN,122,,},5,<empty>,,526,122,CPPASTProblemDeclaration,,<empty>
604097,UNKNOWN,123,,"TEST_METHOD(XCast)
    {
        const til::point pt{ 5, 10 };",5,<empty>,,528,123,CPPASTProblemDeclaration,,<empty>
604098,UNKNOWN,124,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(pt.x), pt.narrow_x<SHORT>());",9,<empty>,,531,124,CPPASTProblemDeclaration,,<empty>
604099,UNKNOWN,125,,},5,<empty>,,532,125,CPPASTProblemDeclaration,,<empty>
604100,UNKNOWN,126,,"TEST_METHOD(YCast)
    {
        const til::point pt{ 5, 10 };",5,<empty>,,534,126,CPPASTProblemDeclaration,,<empty>
604101,UNKNOWN,127,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(pt.x), pt.narrow_x<SHORT>());",9,<empty>,,537,127,CPPASTProblemDeclaration,,<empty>
604102,UNKNOWN,128,,},5,<empty>,,538,128,CPPASTProblemDeclaration,,<empty>
604103,UNKNOWN,129,,"TEST_METHOD(CastToPoint)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,540,129,CPPASTProblemDeclaration,,<empty>
604104,UNKNOWN,130,,"{
            const til::point pt{ 5, 10 };
            auto val = pt.to_win32_point();
            VERIFY_ARE_EQUAL(5, val.x);
            VERIFY_ARE_EQUAL(10, val.y);
        }",9,<empty>,,543,130,CPPASTProblemDeclaration,,<empty>
604105,UNKNOWN,131,,"Log::Comment(L""Fit max x into POINT (may overflow)."");",9,<empty>,,550,131,CPPASTProblemDeclaration,,<empty>
604106,UNKNOWN,132,,"{
            constexpr auto x = std::numeric_limits<til::CoordType>().max();
            const auto y = 10;
            const til::point pt{ x, y };

            // On some platforms, til::CoordType will fit inside x/y
            const auto overflowExpected = x > std::numeric_limits<decltype(POINT::x)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = pt.to_win32_point();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = pt.to_win32_point();
                VERIFY_ARE_EQUAL(x, val.x);
            }
        }",9,<empty>,,551,132,CPPASTProblemDeclaration,,<empty>
604107,UNKNOWN,133,,"Log::Comment(L""Fit max y into POINT (may overflow)."");",9,<empty>,,574,133,CPPASTProblemDeclaration,,<empty>
604108,UNKNOWN,134,,"{
            constexpr auto y = std::numeric_limits<til::CoordType>().max();
            const auto x = 10;
            const til::point pt{ x, y };

            // On some platforms, til::CoordType will fit inside x/y
            const auto overflowExpected = y > std::numeric_limits<decltype(POINT::y)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = pt.to_win32_point();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = pt.to_win32_point();
                VERIFY_ARE_EQUAL(y, val.y);
            }
        }",9,<empty>,,575,134,CPPASTProblemDeclaration,,<empty>
604109,UNKNOWN,135,,},5,<empty>,,597,135,CPPASTProblemDeclaration,,<empty>
604110,UNKNOWN,136,,"TEST_METHOD(CastToD2D1Point2F)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,599,136,CPPASTProblemDeclaration,,<empty>
604111,UNKNOWN,137,,"{
            const til::point pt{ 5, 10 };
            auto val = pt.to_d2d_point();
            VERIFY_ARE_EQUAL(5, val.x);
            VERIFY_ARE_EQUAL(10, val.y);
        }",9,<empty>,,602,137,CPPASTProblemDeclaration,,<empty>
604112,UNKNOWN,138,,},5,<empty>,,610,138,CPPASTProblemDeclaration,,<empty>
604113,UNKNOWN,139,,"TEST_METHOD(Scaling)
    {
        Log::Comment(L""Multiplication of two things that should be in bounds."");",5,<empty>,,612,139,CPPASTProblemDeclaration,,<empty>
604114,UNKNOWN,140,,"{
            const til::point pt{ 5, 10 };
            const auto scale = 23;

            const til::point expected{ pt.x * scale, pt.y * scale };

            VERIFY_ARE_EQUAL(expected, pt * scale);
        }",9,<empty>,,615,140,CPPASTProblemDeclaration,,<empty>
604115,UNKNOWN,141,,"Log::Comment(L""Multiplication results in value that is too large (x)."");",9,<empty>,,624,141,CPPASTProblemDeclaration,,<empty>
604116,UNKNOWN,142,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ bigSize, static_cast<til::CoordType>(0) };
            const auto scale = 10;

            auto fn = [&]() {
                pt* scale;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,625,142,CPPASTProblemDeclaration,,<empty>
604117,UNKNOWN,143,,"Log::Comment(L""Multiplication results in value that is too large (y)."");",9,<empty>,,637,143,CPPASTProblemDeclaration,,<empty>
604118,UNKNOWN,144,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::point pt{ static_cast<til::CoordType>(0), bigSize };
            const auto scale = 10;

            auto fn = [&]() {
                pt* scale;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,638,144,CPPASTProblemDeclaration,,<empty>
604119,UNKNOWN,145,,"Log::Comment(L""Division of two things that should be in bounds."");",9,<empty>,,650,145,CPPASTProblemDeclaration,,<empty>
604120,UNKNOWN,146,,"{
            const til::point pt{ 555, 510 };
            const auto scale = 23;

            const til::point expected{ pt.x / scale, pt.y / scale };

            VERIFY_ARE_EQUAL(expected, pt / scale);
        }",9,<empty>,,651,146,CPPASTProblemDeclaration,,<empty>
604121,UNKNOWN,147,,"Log::Comment(L""Division by zero"");",9,<empty>,,660,147,CPPASTProblemDeclaration,,<empty>
604122,UNKNOWN,148,,"{
            const til::point pt{ 1, 1 };
            const auto scale = 0;

            auto fn = [&]() {
                pt / scale;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,661,148,CPPASTProblemDeclaration,,<empty>
604123,UNKNOWN,149,,},5,<empty>,,671,149,CPPASTProblemDeclaration,,<empty>
604124,UNKNOWN,150,,"TEST_METHOD(CastFromFloatWithMathTypes)
    {
        Log::Comment(L""Ceiling"");",5,<empty>,,673,150,CPPASTProblemDeclaration,,<empty>
604125,UNKNOWN,151,,"{
            {
                til::point converted{ til::math::ceiling, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::point{ 1, 2 }), converted);
            }
            {
                til::point converted{ til::math::ceiling, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::point{ 2, 3 }), converted);
            }
            {
                til::point converted{ til::math::ceiling, 3., 4. };
                VERIFY_ARE_EQUAL((til::point{ 3, 4 }), converted);
            }
            {
                til::point converted{ til::math::ceiling, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::point{ 4, 5 }), converted);
            }
        }",9,<empty>,,676,151,CPPASTProblemDeclaration,,<empty>
604126,UNKNOWN,152,,"Log::Comment(L""Flooring"");",9,<empty>,,695,152,CPPASTProblemDeclaration,,<empty>
604127,UNKNOWN,153,,"{
            {
                til::point converted{ til::math::flooring, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::point{ 1, 2 }), converted);
            }
            {
                til::point converted{ til::math::flooring, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::point{ 1, 2 }), converted);
            }
            {
                til::point converted{ til::math::flooring, 3., 4. };
                VERIFY_ARE_EQUAL((til::point{ 3, 4 }), converted);
            }
            {
                til::point converted{ til::math::flooring, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::point{ 3, 4 }), converted);
            }
        }",9,<empty>,,696,153,CPPASTProblemDeclaration,,<empty>
604128,UNKNOWN,154,,"Log::Comment(L""Rounding"");",9,<empty>,,715,154,CPPASTProblemDeclaration,,<empty>
604129,UNKNOWN,155,,"{
            {
                til::point converted{ til::math::rounding, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::point{ 1, 2 }), converted);
            }
            {
                til::point converted{ til::math::rounding, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::point{ 2, 2 }), converted);
            }
            {
                til::point converted{ til::math::rounding, 3., 4. };
                VERIFY_ARE_EQUAL((til::point{ 3, 4 }), converted);
            }
            {
                til::point converted{ til::math::rounding, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::point{ 4, 4 }), converted);
            }
        }",9,<empty>,,716,155,CPPASTProblemDeclaration,,<empty>
604130,UNKNOWN,156,,},5,<empty>,,734,156,CPPASTProblemDeclaration,,<empty>
604131,UNKNOWN,157,,};,1,<empty>,,735,157,CPPASTProblemDeclaration,,<empty>
604284,UNKNOWN,4,,"TEST_METHOD(SignedConstruct)
    {
        const auto l = 5;",5,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
604305,UNKNOWN,13,,"VERIFY_ARE_EQUAL(5, rc.left);",9,<empty>,,57,13,CPPASTProblemDeclaration,,<empty>
604306,UNKNOWN,14,,"VERIFY_ARE_EQUAL(10, rc.top);",9,<empty>,,58,14,CPPASTProblemDeclaration,,<empty>
604307,UNKNOWN,15,,"VERIFY_ARE_EQUAL(15, rc.right);",9,<empty>,,59,15,CPPASTProblemDeclaration,,<empty>
604308,UNKNOWN,16,,"VERIFY_ARE_EQUAL(20, rc.bottom);",9,<empty>,,60,16,CPPASTProblemDeclaration,,<empty>
604309,UNKNOWN,17,,},5,<empty>,,61,17,CPPASTProblemDeclaration,,<empty>
604310,UNKNOWN,18,,"TEST_METHOD(TwoPointsConstruct)
    {
        const auto l = 5;",5,<empty>,,63,18,CPPASTProblemDeclaration,,<empty>
604335,UNKNOWN,27,,"VERIFY_ARE_EQUAL(5, rc.left);",9,<empty>,,71,27,CPPASTProblemDeclaration,,<empty>
604336,UNKNOWN,28,,"VERIFY_ARE_EQUAL(10, rc.top);",9,<empty>,,72,28,CPPASTProblemDeclaration,,<empty>
604337,UNKNOWN,29,,"VERIFY_ARE_EQUAL(15, rc.right);",9,<empty>,,73,29,CPPASTProblemDeclaration,,<empty>
604338,UNKNOWN,30,,"VERIFY_ARE_EQUAL(20, rc.bottom);",9,<empty>,,74,30,CPPASTProblemDeclaration,,<empty>
604339,UNKNOWN,31,,},5,<empty>,,75,31,CPPASTProblemDeclaration,,<empty>
604340,UNKNOWN,32,,"TEST_METHOD(SizeOnlyConstruct)
    {
        // Size will match bottom right point because
        // til::rect is exclusive.
        const auto sz = til::size{ 5, 10 };",5,<empty>,,77,32,CPPASTProblemDeclaration,,<empty>
604346,UNKNOWN,35,,"VERIFY_ARE_EQUAL(0, rc.left);",9,<empty>,,83,35,CPPASTProblemDeclaration,,<empty>
604347,UNKNOWN,36,,"VERIFY_ARE_EQUAL(0, rc.top);",9,<empty>,,84,36,CPPASTProblemDeclaration,,<empty>
604348,UNKNOWN,37,,"VERIFY_ARE_EQUAL(sz.width, rc.right);",9,<empty>,,85,37,CPPASTProblemDeclaration,,<empty>
604349,UNKNOWN,38,,"VERIFY_ARE_EQUAL(sz.height, rc.bottom);",9,<empty>,,86,38,CPPASTProblemDeclaration,,<empty>
604350,UNKNOWN,39,,},5,<empty>,,87,39,CPPASTProblemDeclaration,,<empty>
604351,UNKNOWN,40,,"TEST_METHOD(PointAndSizeConstruct)
    {
        const til::point pt{ 4, 8 };",5,<empty>,,89,40,CPPASTProblemDeclaration,,<empty>
604352,UNKNOWN,41,,"Log::Comment(L""Normal Case"");",9,<empty>,,93,41,CPPASTProblemDeclaration,,<empty>
604353,UNKNOWN,42,,"{
            const til::rect rc{ pt, til::size{ 2, 10 } };
            VERIFY_ARE_EQUAL(4, rc.left);
            VERIFY_ARE_EQUAL(8, rc.top);
            VERIFY_ARE_EQUAL(6, rc.right);
            VERIFY_ARE_EQUAL(18, rc.bottom);
        }",9,<empty>,,94,42,CPPASTProblemDeclaration,,<empty>
604354,UNKNOWN,43,,"Log::Comment(L""Overflow x-dimension case."");",9,<empty>,,102,43,CPPASTProblemDeclaration,,<empty>
604355,UNKNOWN,44,,"{
            auto fn = [&]() {
                constexpr auto x = std::numeric_limits<til::CoordType>().max();
                const auto y = 0;
                const til::rect rc{ pt, til::size{ x, y } };
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,103,44,CPPASTProblemDeclaration,,<empty>
604356,UNKNOWN,45,,"Log::Comment(L""Overflow y-dimension case."");",9,<empty>,,113,45,CPPASTProblemDeclaration,,<empty>
604357,UNKNOWN,46,,"{
            auto fn = [&]() {
                const auto x = 0;
                constexpr auto y = std::numeric_limits<til::CoordType>().max();
                const til::rect rc{ pt, til::size{ x, y } };
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,114,46,CPPASTProblemDeclaration,,<empty>
604358,UNKNOWN,47,,},5,<empty>,,123,47,CPPASTProblemDeclaration,,<empty>
604359,UNKNOWN,48,,"TEST_METHOD(SmallRectConstruct)
    {
        SMALL_RECT sr;",5,<empty>,,125,48,CPPASTProblemDeclaration,,<empty>
604360,UNKNOWN,49,,sr.Left = 5;,9,<empty>,,128,49,CPPASTProblemDeclaration,,<empty>
604361,UNKNOWN,50,,sr.Top = 10;,9,<empty>,,129,50,CPPASTProblemDeclaration,,<empty>
604362,UNKNOWN,51,,sr.Right = 14;,9,<empty>,,130,51,CPPASTProblemDeclaration,,<empty>
604363,UNKNOWN,52,,sr.Bottom = 19;,9,<empty>,,131,52,CPPASTProblemDeclaration,,<empty>
604373,UNKNOWN,55,,"VERIFY_ARE_EQUAL(5, rc.left);",9,<empty>,,134,55,CPPASTProblemDeclaration,,<empty>
604374,UNKNOWN,56,,"VERIFY_ARE_EQUAL(10, rc.top);",9,<empty>,,135,56,CPPASTProblemDeclaration,,<empty>
604375,UNKNOWN,57,,"VERIFY_ARE_EQUAL(15, rc.right);",9,<empty>,,136,57,CPPASTProblemDeclaration,,<empty>
604376,UNKNOWN,58,,"VERIFY_ARE_EQUAL(20, rc.bottom);",9,<empty>,,137,58,CPPASTProblemDeclaration,,<empty>
604377,UNKNOWN,59,,},5,<empty>,,138,59,CPPASTProblemDeclaration,,<empty>
604378,UNKNOWN,60,,"TEST_METHOD(Win32RectConstruct)
    {
        const RECT win32rc{ 5, 10, 15, 20 };",5,<empty>,,140,60,CPPASTProblemDeclaration,,<empty>
604384,UNKNOWN,63,,"VERIFY_ARE_EQUAL(5, rc.left);",9,<empty>,,145,63,CPPASTProblemDeclaration,,<empty>
604385,UNKNOWN,64,,"VERIFY_ARE_EQUAL(10, rc.top);",9,<empty>,,146,64,CPPASTProblemDeclaration,,<empty>
604386,UNKNOWN,65,,"VERIFY_ARE_EQUAL(15, rc.right);",9,<empty>,,147,65,CPPASTProblemDeclaration,,<empty>
604387,UNKNOWN,66,,"VERIFY_ARE_EQUAL(20, rc.bottom);",9,<empty>,,148,66,CPPASTProblemDeclaration,,<empty>
604388,UNKNOWN,67,,},5,<empty>,,149,67,CPPASTProblemDeclaration,,<empty>
604389,UNKNOWN,68,,"TEST_METHOD(Assignment)
    {
        til::rect a{ 1, 2, 3, 4 };",5,<empty>,,151,68,CPPASTProblemDeclaration,,<empty>
604398,UNKNOWN,71,,"VERIFY_ARE_EQUAL(1, a.left);",9,<empty>,,156,71,CPPASTProblemDeclaration,,<empty>
604399,UNKNOWN,72,,"VERIFY_ARE_EQUAL(2, a.top);",9,<empty>,,157,72,CPPASTProblemDeclaration,,<empty>
604400,UNKNOWN,73,,"VERIFY_ARE_EQUAL(3, a.right);",9,<empty>,,158,73,CPPASTProblemDeclaration,,<empty>
604401,UNKNOWN,74,,"VERIFY_ARE_EQUAL(4, a.bottom);",9,<empty>,,159,74,CPPASTProblemDeclaration,,<empty>
604402,UNKNOWN,75,,a = b;,9,<empty>,,161,75,CPPASTProblemDeclaration,,<empty>
604403,UNKNOWN,76,,"VERIFY_ARE_EQUAL(5, a.left);",9,<empty>,,163,76,CPPASTProblemDeclaration,,<empty>
604404,UNKNOWN,77,,"VERIFY_ARE_EQUAL(6, a.top);",9,<empty>,,164,77,CPPASTProblemDeclaration,,<empty>
604405,UNKNOWN,78,,"VERIFY_ARE_EQUAL(7, a.right);",9,<empty>,,165,78,CPPASTProblemDeclaration,,<empty>
604406,UNKNOWN,79,,"VERIFY_ARE_EQUAL(8, a.bottom);",9,<empty>,,166,79,CPPASTProblemDeclaration,,<empty>
604407,UNKNOWN,80,,},5,<empty>,,167,80,CPPASTProblemDeclaration,,<empty>
604408,UNKNOWN,81,,"TEST_METHOD(Equality)
    {
        Log::Comment(L""Equal."");",5,<empty>,,169,81,CPPASTProblemDeclaration,,<empty>
604409,UNKNOWN,82,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_TRUE(a == b);
        }",9,<empty>,,172,82,CPPASTProblemDeclaration,,<empty>
604410,UNKNOWN,83,,"Log::Comment(L""Left A changed."");",9,<empty>,,178,83,CPPASTProblemDeclaration,,<empty>
604411,UNKNOWN,84,,"{
            const til::rect a{ 9, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,179,84,CPPASTProblemDeclaration,,<empty>
604412,UNKNOWN,85,,"Log::Comment(L""Top A changed."");",9,<empty>,,185,85,CPPASTProblemDeclaration,,<empty>
604413,UNKNOWN,86,,"{
            const til::rect a{ 1, 9, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,186,86,CPPASTProblemDeclaration,,<empty>
604414,UNKNOWN,87,,"Log::Comment(L""Right A changed."");",9,<empty>,,192,87,CPPASTProblemDeclaration,,<empty>
604415,UNKNOWN,88,,"{
            const til::rect a{ 1, 2, 9, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,193,88,CPPASTProblemDeclaration,,<empty>
604416,UNKNOWN,89,,"Log::Comment(L""Bottom A changed."");",9,<empty>,,199,89,CPPASTProblemDeclaration,,<empty>
604417,UNKNOWN,90,,"{
            const til::rect a{ 1, 2, 3, 9 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,200,90,CPPASTProblemDeclaration,,<empty>
604418,UNKNOWN,91,,"Log::Comment(L""Left B changed."");",9,<empty>,,206,91,CPPASTProblemDeclaration,,<empty>
604419,UNKNOWN,92,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 9, 2, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,207,92,CPPASTProblemDeclaration,,<empty>
604420,UNKNOWN,93,,"Log::Comment(L""Top B changed."");",9,<empty>,,213,93,CPPASTProblemDeclaration,,<empty>
604421,UNKNOWN,94,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 9, 3, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,214,94,CPPASTProblemDeclaration,,<empty>
604422,UNKNOWN,95,,"Log::Comment(L""Right B changed."");",9,<empty>,,220,95,CPPASTProblemDeclaration,,<empty>
604423,UNKNOWN,96,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 9, 4 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,221,96,CPPASTProblemDeclaration,,<empty>
604424,UNKNOWN,97,,"Log::Comment(L""Bottom B changed."");",9,<empty>,,227,97,CPPASTProblemDeclaration,,<empty>
604425,UNKNOWN,98,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 9 };
            VERIFY_IS_FALSE(a == b);
        }",9,<empty>,,228,98,CPPASTProblemDeclaration,,<empty>
604426,UNKNOWN,99,,},5,<empty>,,233,99,CPPASTProblemDeclaration,,<empty>
604427,UNKNOWN,100,,"TEST_METHOD(Inequality)
    {
        Log::Comment(L""Equal."");",5,<empty>,,235,100,CPPASTProblemDeclaration,,<empty>
604428,UNKNOWN,101,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_FALSE(a != b);
        }",9,<empty>,,238,101,CPPASTProblemDeclaration,,<empty>
604429,UNKNOWN,102,,"Log::Comment(L""Left A changed."");",9,<empty>,,244,102,CPPASTProblemDeclaration,,<empty>
604430,UNKNOWN,103,,"{
            const til::rect a{ 9, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,245,103,CPPASTProblemDeclaration,,<empty>
604431,UNKNOWN,104,,"Log::Comment(L""Top A changed."");",9,<empty>,,251,104,CPPASTProblemDeclaration,,<empty>
604432,UNKNOWN,105,,"{
            const til::rect a{ 1, 9, 3, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,252,105,CPPASTProblemDeclaration,,<empty>
604433,UNKNOWN,106,,"Log::Comment(L""Right A changed."");",9,<empty>,,258,106,CPPASTProblemDeclaration,,<empty>
604434,UNKNOWN,107,,"{
            const til::rect a{ 1, 2, 9, 4 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,259,107,CPPASTProblemDeclaration,,<empty>
604435,UNKNOWN,108,,"Log::Comment(L""Bottom A changed."");",9,<empty>,,265,108,CPPASTProblemDeclaration,,<empty>
604436,UNKNOWN,109,,"{
            const til::rect a{ 1, 2, 3, 9 };
            const til::rect b{ 1, 2, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,266,109,CPPASTProblemDeclaration,,<empty>
604437,UNKNOWN,110,,"Log::Comment(L""Left B changed."");",9,<empty>,,272,110,CPPASTProblemDeclaration,,<empty>
604438,UNKNOWN,111,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 9, 2, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,273,111,CPPASTProblemDeclaration,,<empty>
604439,UNKNOWN,112,,"Log::Comment(L""Top B changed."");",9,<empty>,,279,112,CPPASTProblemDeclaration,,<empty>
604440,UNKNOWN,113,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 9, 3, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,280,113,CPPASTProblemDeclaration,,<empty>
604441,UNKNOWN,114,,"Log::Comment(L""Right B changed."");",9,<empty>,,286,114,CPPASTProblemDeclaration,,<empty>
604442,UNKNOWN,115,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 9, 4 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,287,115,CPPASTProblemDeclaration,,<empty>
604443,UNKNOWN,116,,"Log::Comment(L""Bottom B changed."");",9,<empty>,,293,116,CPPASTProblemDeclaration,,<empty>
604444,UNKNOWN,117,,"{
            const til::rect a{ 1, 2, 3, 4 };
            const til::rect b{ 1, 2, 3, 9 };
            VERIFY_IS_TRUE(a != b);
        }",9,<empty>,,294,117,CPPASTProblemDeclaration,,<empty>
604445,UNKNOWN,118,,},5,<empty>,,299,118,CPPASTProblemDeclaration,,<empty>
604446,UNKNOWN,119,,"TEST_METHOD(Boolean)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:left"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:top"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:right"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:bottom"", L""{0,10}"")
        END_TEST_METHOD_PROPERTIES()

        til::CoordType left, top, right, bottom;",5,<empty>,,301,119,CPPASTProblemDeclaration,,<empty>
604447,UNKNOWN,120,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""left"", left));",9,<empty>,,311,120,CPPASTProblemDeclaration,,<empty>
604448,UNKNOWN,121,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""top"", top));",9,<empty>,,312,121,CPPASTProblemDeclaration,,<empty>
604449,UNKNOWN,122,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""right"", right));",9,<empty>,,313,122,CPPASTProblemDeclaration,,<empty>
604450,UNKNOWN,123,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""bottom"", bottom));",9,<empty>,,314,123,CPPASTProblemDeclaration,,<empty>
604469,UNKNOWN,128,,"VERIFY_ARE_EQUAL(expected, (bool)actual);",9,<empty>,,318,128,CPPASTProblemDeclaration,,<empty>
604470,UNKNOWN,129,,},5,<empty>,,319,129,CPPASTProblemDeclaration,,<empty>
604471,UNKNOWN,130,,"TEST_METHOD(OrUnion)
    {
        const til::rect one{ 4, 6, 10, 14 };",5,<empty>,,321,130,CPPASTProblemDeclaration,,<empty>
604494,UNKNOWN,137,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,328,137,CPPASTProblemDeclaration,,<empty>
604495,UNKNOWN,138,,},5,<empty>,,329,138,CPPASTProblemDeclaration,,<empty>
604496,UNKNOWN,139,,"TEST_METHOD(OrUnionInplace)
    {
        til::rect one{ 4, 6, 10, 14 };",5,<empty>,,331,139,CPPASTProblemDeclaration,,<empty>
604513,UNKNOWN,144,,one |= two;,9,<empty>,,337,144,CPPASTProblemDeclaration,,<empty>
604514,UNKNOWN,145,,"VERIFY_ARE_EQUAL(expected, one);",9,<empty>,,338,145,CPPASTProblemDeclaration,,<empty>
604515,UNKNOWN,146,,},5,<empty>,,339,146,CPPASTProblemDeclaration,,<empty>
604516,UNKNOWN,147,,"TEST_METHOD(AndIntersect)
    {
        const til::rect one{ 4, 6, 10, 14 };",5,<empty>,,341,147,CPPASTProblemDeclaration,,<empty>
604539,UNKNOWN,154,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,348,154,CPPASTProblemDeclaration,,<empty>
604540,UNKNOWN,155,,},5,<empty>,,349,155,CPPASTProblemDeclaration,,<empty>
604541,UNKNOWN,156,,"TEST_METHOD(AndIntersectInplace)
    {
        til::rect one{ 4, 6, 10, 14 };",5,<empty>,,351,156,CPPASTProblemDeclaration,,<empty>
604558,UNKNOWN,161,,one &= two;,9,<empty>,,357,161,CPPASTProblemDeclaration,,<empty>
604559,UNKNOWN,162,,"VERIFY_ARE_EQUAL(expected, one);",9,<empty>,,358,162,CPPASTProblemDeclaration,,<empty>
604560,UNKNOWN,163,,},5,<empty>,,359,163,CPPASTProblemDeclaration,,<empty>
604561,UNKNOWN,164,,"TEST_METHOD(MinusSubtractSame)
    {
        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,361,164,CPPASTProblemDeclaration,,<empty>
604573,UNKNOWN,170,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,369,170,CPPASTProblemDeclaration,,<empty>
604574,UNKNOWN,171,,},5,<empty>,,370,171,CPPASTProblemDeclaration,,<empty>
604575,UNKNOWN,172,,"TEST_METHOD(MinusSubtractNoOverlap)
    {
        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,372,172,CPPASTProblemDeclaration,,<empty>
604595,UNKNOWN,179,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,380,179,CPPASTProblemDeclaration,,<empty>
604596,UNKNOWN,180,,},5,<empty>,,381,180,CPPASTProblemDeclaration,,<empty>
604597,UNKNOWN,181,,"TEST_METHOD(MinusSubtractOne)
    {
        //                +--------+
        //                | result |
        //                |        |
        //   +-------------------------------------+
        //   |            |        |               |
        //   |            |        |               |
        //   |            |original|               |
        //   |            |        |               |
        //   |            |        |               |
        //   |            +--------+               |
        //   |                                     |
        //   |                                     |
        //   |        removal                      |
        //   |                                     |
        //   +-------------------------------------+

        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,383,181,CPPASTProblemDeclaration,,<empty>
604631,UNKNOWN,188,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,408,188,CPPASTProblemDeclaration,,<empty>
604632,UNKNOWN,189,,},5,<empty>,,409,189,CPPASTProblemDeclaration,,<empty>
604633,UNKNOWN,190,,"TEST_METHOD(MinusSubtractTwo)
    {
        //    +--------+
        //    |result0 |
        //    |        |
        //    |~~~~+-----------------+
        //    |res1|   |             |
        //    |    |   |             |
        //    |original|             |
        //    |    |   |             |
        //    |    |   |             |
        //    +--------+             |
        //         |                 |
        //         |                 |
        //         |   removal       |
        //         +-----------------+

        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,411,190,CPPASTProblemDeclaration,,<empty>
604680,UNKNOWN,197,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,436,197,CPPASTProblemDeclaration,,<empty>
604681,UNKNOWN,198,,},5,<empty>,,437,198,CPPASTProblemDeclaration,,<empty>
604682,UNKNOWN,199,,"TEST_METHOD(MinusSubtractThree)
    {
        //    +--------+
        //    |result0 |
        //    |        |
        //    |~~~~+---------------------------+
        //    |res2|   |     removal           |
        //    |original|                       |
        //    |~~~~+---------------------------+
        //    |result1 |
        //    |        |
        //    +--------+

        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,439,199,CPPASTProblemDeclaration,,<empty>
604743,UNKNOWN,206,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,461,206,CPPASTProblemDeclaration,,<empty>
604744,UNKNOWN,207,,},5,<empty>,,462,207,CPPASTProblemDeclaration,,<empty>
604745,UNKNOWN,208,,"TEST_METHOD(MinusSubtractFour)
    {
        //     (original)---+
        //                  |
        //                  v
        //    + --------------------------+
        //    |         result0           |
        //    |   o         r         i   |
        //    |                           |
        //    |~~~~~~~+-----------+~~~~~~~|
        //    | res2  |           | res3  |
        //    |   g   |  removal  |   i   |
        //    |       |           |       |
        //    |~~~~~~~+-----------+~~~~~~~|
        //    |          result1          |
        //    |   n         a         l   |
        //    |                           |
        //    +---------------------------+

        const til::rect original{ 0, 0, 10, 10 };",5,<empty>,,464,208,CPPASTProblemDeclaration,,<empty>
604820,UNKNOWN,215,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,493,215,CPPASTProblemDeclaration,,<empty>
604821,UNKNOWN,216,,},5,<empty>,,494,216,CPPASTProblemDeclaration,,<empty>
604822,UNKNOWN,217,,"TEST_METHOD(AdditionPoint)
    {
        const til::rect start{ 10, 20, 30, 40 };",5,<empty>,,496,217,CPPASTProblemDeclaration,,<empty>
604851,UNKNOWN,224,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,502,224,CPPASTProblemDeclaration,,<empty>
604852,UNKNOWN,225,,},5,<empty>,,503,225,CPPASTProblemDeclaration,,<empty>
604853,UNKNOWN,226,,"TEST_METHOD(AdditionPointInplace)
    {
        til::rect start{ 10, 20, 30, 40 };",5,<empty>,,505,226,CPPASTProblemDeclaration,,<empty>
604876,UNKNOWN,231,,start += pt;,9,<empty>,,510,231,CPPASTProblemDeclaration,,<empty>
604877,UNKNOWN,232,,"VERIFY_ARE_EQUAL(expected, start);",9,<empty>,,511,232,CPPASTProblemDeclaration,,<empty>
604878,UNKNOWN,233,,},5,<empty>,,512,233,CPPASTProblemDeclaration,,<empty>
604879,UNKNOWN,234,,"TEST_METHOD(SubtractionPoint)
    {
        const til::rect start{ 10, 20, 30, 40 };",5,<empty>,,514,234,CPPASTProblemDeclaration,,<empty>
604908,UNKNOWN,241,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,520,241,CPPASTProblemDeclaration,,<empty>
604909,UNKNOWN,242,,},5,<empty>,,521,242,CPPASTProblemDeclaration,,<empty>
604910,UNKNOWN,243,,"TEST_METHOD(SubtractionPointInplace)
    {
        til::rect start{ 10, 20, 30, 40 };",5,<empty>,,523,243,CPPASTProblemDeclaration,,<empty>
604933,UNKNOWN,248,,start -= pt;,9,<empty>,,528,248,CPPASTProblemDeclaration,,<empty>
604934,UNKNOWN,249,,"VERIFY_ARE_EQUAL(expected, start);",9,<empty>,,529,249,CPPASTProblemDeclaration,,<empty>
604935,UNKNOWN,250,,},5,<empty>,,530,250,CPPASTProblemDeclaration,,<empty>
604936,UNKNOWN,251,,"TEST_METHOD(ScaleUpSize)
    {
        const til::rect start{ 10, 20, 30, 40 };",5,<empty>,,532,251,CPPASTProblemDeclaration,,<empty>
604937,UNKNOWN,252,,"Log::Comment(L""Multiply by size to scale from cells to pixels"");",9,<empty>,,536,252,CPPASTProblemDeclaration,,<empty>
604938,UNKNOWN,253,,"{
            const til::size scale{ 3, 7 };
            const til::rect expected{ 10 * 3, 20 * 7, 30 * 3, 40 * 7 };
            const auto actual = start.scale_up(scale);
            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,537,253,CPPASTProblemDeclaration,,<empty>
604939,UNKNOWN,254,,"Log::Comment(L""Multiply by size with width way too big."");",9,<empty>,,544,254,CPPASTProblemDeclaration,,<empty>
604940,UNKNOWN,255,,"{
            const til::size scale{ std::numeric_limits<til::CoordType>().max(), static_cast<til::CoordType>(7) };

            auto fn = [&]() {
                const auto actual = start.scale_up(scale);
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,545,255,CPPASTProblemDeclaration,,<empty>
604941,UNKNOWN,256,,"Log::Comment(L""Multiply by size with height way too big."");",9,<empty>,,555,256,CPPASTProblemDeclaration,,<empty>
604942,UNKNOWN,257,,"{
            const til::size scale{ static_cast<til::CoordType>(3), std::numeric_limits<til::CoordType>().max() };

            auto fn = [&]() {
                const auto actual = start.scale_up(scale);
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,556,257,CPPASTProblemDeclaration,,<empty>
604943,UNKNOWN,258,,},5,<empty>,,565,258,CPPASTProblemDeclaration,,<empty>
604944,UNKNOWN,259,,"TEST_METHOD(ScaleDownSize)
    {
        const til::rect start{ 10, 20, 29, 40 };",5,<empty>,,567,259,CPPASTProblemDeclaration,,<empty>
604945,UNKNOWN,260,,"Log::Comment(L""Division by size to scale from pixels to cells"");",9,<empty>,,571,260,CPPASTProblemDeclaration,,<empty>
604946,UNKNOWN,261,,"{
            const til::size scale{ 3, 7 };

            // Division is special. The top and left round down.
            // The bottom and right round up. This is to ensure that the cells
            // the smaller rectangle represents fully cover all the pixels
            // of the larger rectangle.
            // L: 10 / 3 = 3.333 --> round down --> 3
            // T: 20 / 7 = 2.857 --> round down --> 2
            // R: 29 / 3 = 9.667 --> round up ----> 10
            // B: 40 / 7 = 5.714 --> round up ----> 6
            const til::rect expected{ 3, 2, 10, 6 };
            const auto actual = start.scale_down(scale);
            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,572,261,CPPASTProblemDeclaration,,<empty>
604947,UNKNOWN,262,,},5,<empty>,,587,262,CPPASTProblemDeclaration,,<empty>
604948,UNKNOWN,263,,"TEST_METHOD(Top)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,589,263,CPPASTProblemDeclaration,,<empty>
604949,UNKNOWN,264,,"VERIFY_ARE_EQUAL(rc.top, rc.top);",9,<empty>,,592,264,CPPASTProblemDeclaration,,<empty>
604950,UNKNOWN,265,,},5,<empty>,,593,265,CPPASTProblemDeclaration,,<empty>
604951,UNKNOWN,266,,"TEST_METHOD(TopCast)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,595,266,CPPASTProblemDeclaration,,<empty>
604952,UNKNOWN,267,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(rc.top), rc.narrow_top<SHORT>());",9,<empty>,,598,267,CPPASTProblemDeclaration,,<empty>
604953,UNKNOWN,268,,},5,<empty>,,599,268,CPPASTProblemDeclaration,,<empty>
604954,UNKNOWN,269,,"TEST_METHOD(Bottom)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,601,269,CPPASTProblemDeclaration,,<empty>
604955,UNKNOWN,270,,"VERIFY_ARE_EQUAL(rc.bottom, rc.bottom);",9,<empty>,,604,270,CPPASTProblemDeclaration,,<empty>
604956,UNKNOWN,271,,},5,<empty>,,605,271,CPPASTProblemDeclaration,,<empty>
604957,UNKNOWN,272,,"TEST_METHOD(BottomCast)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,607,272,CPPASTProblemDeclaration,,<empty>
604958,UNKNOWN,273,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(rc.bottom), rc.narrow_bottom<SHORT>());",9,<empty>,,610,273,CPPASTProblemDeclaration,,<empty>
604959,UNKNOWN,274,,},5,<empty>,,611,274,CPPASTProblemDeclaration,,<empty>
604960,UNKNOWN,275,,"TEST_METHOD(Left)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,613,275,CPPASTProblemDeclaration,,<empty>
604961,UNKNOWN,276,,"VERIFY_ARE_EQUAL(rc.left, rc.left);",9,<empty>,,616,276,CPPASTProblemDeclaration,,<empty>
604962,UNKNOWN,277,,},5,<empty>,,617,277,CPPASTProblemDeclaration,,<empty>
604963,UNKNOWN,278,,"TEST_METHOD(LeftCast)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,619,278,CPPASTProblemDeclaration,,<empty>
604964,UNKNOWN,279,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(rc.left), rc.narrow_left<SHORT>());",9,<empty>,,622,279,CPPASTProblemDeclaration,,<empty>
604965,UNKNOWN,280,,},5,<empty>,,623,280,CPPASTProblemDeclaration,,<empty>
604966,UNKNOWN,281,,"TEST_METHOD(Right)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,625,281,CPPASTProblemDeclaration,,<empty>
604967,UNKNOWN,282,,"VERIFY_ARE_EQUAL(rc.right, rc.right);",9,<empty>,,628,282,CPPASTProblemDeclaration,,<empty>
604968,UNKNOWN,283,,},5,<empty>,,629,283,CPPASTProblemDeclaration,,<empty>
604969,UNKNOWN,284,,"TEST_METHOD(RightCast)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,631,284,CPPASTProblemDeclaration,,<empty>
604970,UNKNOWN,285,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(rc.right), rc.narrow_right<SHORT>());",9,<empty>,,634,285,CPPASTProblemDeclaration,,<empty>
604971,UNKNOWN,286,,},5,<empty>,,635,286,CPPASTProblemDeclaration,,<empty>
604972,UNKNOWN,287,,"TEST_METHOD(Width)
    {
        Log::Comment(L""Width that should be in bounds."");",5,<empty>,,637,287,CPPASTProblemDeclaration,,<empty>
604973,UNKNOWN,288,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            VERIFY_ARE_EQUAL(15 - 5, rc.width());
        }",9,<empty>,,640,288,CPPASTProblemDeclaration,,<empty>
604974,UNKNOWN,289,,"Log::Comment(L""Width that should go out of bounds on subtraction."");",9,<empty>,,645,289,CPPASTProblemDeclaration,,<empty>
604975,UNKNOWN,290,,"{
            constexpr auto bigVal = std::numeric_limits<til::CoordType>().min();
            const auto normalVal = 5;
            const til::rect rc{ normalVal, normalVal, bigVal, normalVal };

            auto fn = [&]() {
                rc.width();
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,646,290,CPPASTProblemDeclaration,,<empty>
604976,UNKNOWN,291,,},5,<empty>,,657,291,CPPASTProblemDeclaration,,<empty>
604977,UNKNOWN,292,,"TEST_METHOD(WidthCast)
    {
        const auto expected = 15 - 5;",5,<empty>,,659,292,CPPASTProblemDeclaration,,<empty>
604986,UNKNOWN,295,,"VERIFY_ARE_EQUAL(expected, rc.narrow_width<SHORT>());",9,<empty>,,663,295,CPPASTProblemDeclaration,,<empty>
604987,UNKNOWN,296,,},5,<empty>,,664,296,CPPASTProblemDeclaration,,<empty>
604988,UNKNOWN,297,,"TEST_METHOD(Height)
    {
        Log::Comment(L""Height that should be in bounds."");",5,<empty>,,666,297,CPPASTProblemDeclaration,,<empty>
604989,UNKNOWN,298,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            VERIFY_ARE_EQUAL(20 - 10, rc.height());
        }",9,<empty>,,669,298,CPPASTProblemDeclaration,,<empty>
604990,UNKNOWN,299,,"Log::Comment(L""Height that should go out of bounds on subtraction."");",9,<empty>,,674,299,CPPASTProblemDeclaration,,<empty>
604991,UNKNOWN,300,,"{
            constexpr auto bigVal = std::numeric_limits<til::CoordType>().min();
            const auto normalVal = 5;
            const til::rect rc{ normalVal, normalVal, normalVal, bigVal };

            auto fn = [&]() {
                rc.height();
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,675,300,CPPASTProblemDeclaration,,<empty>
604992,UNKNOWN,301,,},5,<empty>,,686,301,CPPASTProblemDeclaration,,<empty>
604993,UNKNOWN,302,,"TEST_METHOD(HeightCast)
    {
        const auto expected = 20 - 10;",5,<empty>,,688,302,CPPASTProblemDeclaration,,<empty>
605002,UNKNOWN,305,,"VERIFY_ARE_EQUAL(expected, rc.narrow_height<SHORT>());",9,<empty>,,692,305,CPPASTProblemDeclaration,,<empty>
605003,UNKNOWN,306,,},5,<empty>,,693,306,CPPASTProblemDeclaration,,<empty>
605004,UNKNOWN,307,,"TEST_METHOD(Origin)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,695,307,CPPASTProblemDeclaration,,<empty>
605011,UNKNOWN,310,,"VERIFY_ARE_EQUAL(expected, rc.origin());",9,<empty>,,699,310,CPPASTProblemDeclaration,,<empty>
605012,UNKNOWN,311,,},5,<empty>,,700,311,CPPASTProblemDeclaration,,<empty>
605013,UNKNOWN,312,,"TEST_METHOD(Size)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,702,312,CPPASTProblemDeclaration,,<empty>
605020,UNKNOWN,315,,"VERIFY_ARE_EQUAL(expected, rc.size());",9,<empty>,,706,315,CPPASTProblemDeclaration,,<empty>
605021,UNKNOWN,316,,},5,<empty>,,707,316,CPPASTProblemDeclaration,,<empty>
605022,UNKNOWN,317,,"TEST_METHOD(Empty)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:left"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:top"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:right"", L""{0,10}"")
            TEST_METHOD_PROPERTY(L""Data:bottom"", L""{0,10}"")
        END_TEST_METHOD_PROPERTIES()

        til::CoordType left, top, right, bottom;",5,<empty>,,709,317,CPPASTProblemDeclaration,,<empty>
605023,UNKNOWN,318,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""left"", left));",9,<empty>,,719,318,CPPASTProblemDeclaration,,<empty>
605024,UNKNOWN,319,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""top"", top));",9,<empty>,,720,319,CPPASTProblemDeclaration,,<empty>
605025,UNKNOWN,320,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""right"", right));",9,<empty>,,721,320,CPPASTProblemDeclaration,,<empty>
605026,UNKNOWN,321,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""bottom"", bottom));",9,<empty>,,722,321,CPPASTProblemDeclaration,,<empty>
605046,UNKNOWN,326,,"VERIFY_ARE_EQUAL(expected, actual.empty());",9,<empty>,,726,326,CPPASTProblemDeclaration,,<empty>
605047,UNKNOWN,327,,},5,<empty>,,727,327,CPPASTProblemDeclaration,,<empty>
605048,UNKNOWN,328,,"TEST_METHOD(ContainsPoint)
    {
        BEGIN_TEST_METHOD_PROPERTIES()
            TEST_METHOD_PROPERTY(L""Data:x"", L""{-1000,0,4,5,6,14,15,16,1000}"")
            TEST_METHOD_PROPERTY(L""Data:y"", L""{-1000,0,9,10,11,19,20,21,1000}"")
        END_TEST_METHOD_PROPERTIES()

        til::CoordType x, y;",5,<empty>,,729,328,CPPASTProblemDeclaration,,<empty>
605049,UNKNOWN,329,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""x"", x));",9,<empty>,,737,329,CPPASTProblemDeclaration,,<empty>
605050,UNKNOWN,330,,"VERIFY_SUCCEEDED_RETURN(TestData::TryGetValue(L""y"", y));",9,<empty>,,738,330,CPPASTProblemDeclaration,,<empty>
605091,UNKNOWN,341,,"if (expected)
        {
            Log::Comment(L""Expected in bounds."");
        }",9,<empty>,,746,341,CPPASTProblemDeclaration,,<empty>
605092,UNKNOWN,342,,"else
        {
            Log::Comment(L""Expected OUT of bounds."");
        }",9,<empty>,,750,342,CPPASTProblemDeclaration,,<empty>
605093,UNKNOWN,343,,"VERIFY_ARE_EQUAL(expected, rc.contains(pt));",9,<empty>,,755,343,CPPASTProblemDeclaration,,<empty>
605094,UNKNOWN,344,,},5,<empty>,,756,344,CPPASTProblemDeclaration,,<empty>
605095,UNKNOWN,345,,"TEST_METHOD(ContainsRectangle)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,758,345,CPPASTProblemDeclaration,,<empty>
605120,UNKNOWN,352,,"VERIFY_IS_TRUE(rc.contains(rc), L""We contain ourself."");",9,<empty>,,766,352,CPPASTProblemDeclaration,,<empty>
605121,UNKNOWN,353,,"VERIFY_IS_TRUE(rc.contains(fitsInside), L""We fully contain a smaller rectangle."");",9,<empty>,,767,353,CPPASTProblemDeclaration,,<empty>
605122,UNKNOWN,354,,"VERIFY_IS_FALSE(rc.contains(spillsOut), L""We do not fully contain rectangle larger than us."");",9,<empty>,,768,354,CPPASTProblemDeclaration,,<empty>
605123,UNKNOWN,355,,"VERIFY_IS_FALSE(rc.contains(sticksOut), L""We do not contain a rectangle that is smaller, but sticks out our edge."");",9,<empty>,,769,355,CPPASTProblemDeclaration,,<empty>
605124,UNKNOWN,356,,},5,<empty>,,770,356,CPPASTProblemDeclaration,,<empty>
605125,UNKNOWN,357,,"TEST_METHOD(IndexOfPoint)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,772,357,CPPASTProblemDeclaration,,<empty>
605126,UNKNOWN,358,,"Log::Comment(L""Normal in bounds."");",9,<empty>,,776,358,CPPASTProblemDeclaration,,<empty>
605127,UNKNOWN,359,,"{
            const til::point pt{ 7, 17 };
            const auto expected = 72;
            VERIFY_ARE_EQUAL(expected, rc.index_of(pt));
        }",9,<empty>,,777,359,CPPASTProblemDeclaration,,<empty>
605128,UNKNOWN,360,,"Log::Comment(L""Out of bounds."");",9,<empty>,,783,360,CPPASTProblemDeclaration,,<empty>
605129,UNKNOWN,361,,"{
            auto fn = [&]() {
                const til::point pt{ 1, 1 };
                rc.index_of(pt);
            };

            VERIFY_THROWS_SPECIFIC(fn(), wil::ResultException, [](wil::ResultException& e) { return e.GetErrorCode() == E_INVALIDARG; });
        }",9,<empty>,,784,361,CPPASTProblemDeclaration,,<empty>
605130,UNKNOWN,362,,"Log::Comment(L""Overflow."");",9,<empty>,,793,362,CPPASTProblemDeclaration,,<empty>
605131,UNKNOWN,363,,"{
            auto fn = [&]() {
                constexpr const auto min = static_cast<til::CoordType>(0);
                constexpr const auto max = std::numeric_limits<til::CoordType>().max();
                const til::rect bigRc{ min, min, max, max };
                const til::point pt{ max - 1, max - 1 };
                bigRc.index_of(pt);
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,794,363,CPPASTProblemDeclaration,,<empty>
605132,UNKNOWN,364,,},5,<empty>,,805,364,CPPASTProblemDeclaration,,<empty>
605133,UNKNOWN,365,,"TEST_METHOD(PointAtIndex)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,807,365,CPPASTProblemDeclaration,,<empty>
605134,UNKNOWN,366,,"Log::Comment(L""Normal in bounds."");",9,<empty>,,811,366,CPPASTProblemDeclaration,,<empty>
605135,UNKNOWN,367,,"{
            const til::point expected{ 7, 17 };
            VERIFY_ARE_EQUAL(expected, rc.point_at(72));
        }",9,<empty>,,812,367,CPPASTProblemDeclaration,,<empty>
605136,UNKNOWN,368,,"Log::Comment(L""Out of bounds too high."");",9,<empty>,,817,368,CPPASTProblemDeclaration,,<empty>
605137,UNKNOWN,369,,"{
            auto fn = [&]() {
                rc.point_at(1000);
            };

            VERIFY_THROWS_SPECIFIC(fn(), wil::ResultException, [](wil::ResultException& e) { return e.GetErrorCode() == E_INVALIDARG; });
        }",9,<empty>,,818,369,CPPASTProblemDeclaration,,<empty>
605138,UNKNOWN,370,,},5,<empty>,,825,370,CPPASTProblemDeclaration,,<empty>
605139,UNKNOWN,371,,"TEST_METHOD(CastToSmallRect)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,827,371,CPPASTProblemDeclaration,,<empty>
605140,UNKNOWN,372,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            const auto val = til::unwrap_small_rect(rc.to_inclusive_rect());
            VERIFY_ARE_EQUAL(5, val.Left);
            VERIFY_ARE_EQUAL(10, val.Top);
            VERIFY_ARE_EQUAL(14, val.Right);
            VERIFY_ARE_EQUAL(19, val.Bottom);
        }",9,<empty>,,830,372,CPPASTProblemDeclaration,,<empty>
605141,UNKNOWN,373,,"Log::Comment(L""Overflow on left."");",9,<empty>,,839,373,CPPASTProblemDeclaration,,<empty>
605142,UNKNOWN,374,,"{
            constexpr auto l = std::numeric_limits<til::CoordType>().max();
            const auto t = 10;
            const auto r = 15;
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            auto fn = [&]() {
                const auto val = til::unwrap_small_rect(rc.to_inclusive_rect());
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,840,374,CPPASTProblemDeclaration,,<empty>
605143,UNKNOWN,375,,"Log::Comment(L""Overflow on top."");",9,<empty>,,854,375,CPPASTProblemDeclaration,,<empty>
605144,UNKNOWN,376,,"{
            const auto l = 5;
            constexpr auto t = std::numeric_limits<til::CoordType>().max();
            const auto r = 15;
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            auto fn = [&]() {
                const auto val = til::unwrap_small_rect(rc.to_inclusive_rect());
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,855,376,CPPASTProblemDeclaration,,<empty>
605145,UNKNOWN,377,,"Log::Comment(L""Overflow on right."");",9,<empty>,,869,377,CPPASTProblemDeclaration,,<empty>
605146,UNKNOWN,378,,"{
            const auto l = 5;
            const auto t = 10;
            constexpr auto r = std::numeric_limits<til::CoordType>().max();
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            auto fn = [&]() {
                const auto val = til::unwrap_small_rect(rc.to_inclusive_rect());
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,870,378,CPPASTProblemDeclaration,,<empty>
605147,UNKNOWN,379,,"Log::Comment(L""Overflow on bottom."");",9,<empty>,,884,379,CPPASTProblemDeclaration,,<empty>
605148,UNKNOWN,380,,"{
            const auto l = 5;
            const auto t = 10;
            const auto r = 15;
            constexpr auto b = std::numeric_limits<til::CoordType>().max();
            const til::rect rc{ l, t, r, b };

            auto fn = [&]() {
                const auto val = til::unwrap_small_rect(rc.to_inclusive_rect());
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,885,380,CPPASTProblemDeclaration,,<empty>
605149,UNKNOWN,381,,},5,<empty>,,898,381,CPPASTProblemDeclaration,,<empty>
605150,UNKNOWN,382,,"TEST_METHOD(CastToRect)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,900,382,CPPASTProblemDeclaration,,<empty>
605151,UNKNOWN,383,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            auto val = rc.to_win32_rect();
            VERIFY_ARE_EQUAL(5, val.left);
            VERIFY_ARE_EQUAL(10, val.top);
            VERIFY_ARE_EQUAL(15, val.right);
            VERIFY_ARE_EQUAL(20, val.bottom);
        }",9,<empty>,,903,383,CPPASTProblemDeclaration,,<empty>
605152,UNKNOWN,384,,"Log::Comment(L""Fit max left into RECT (may overflow)."");",9,<empty>,,912,384,CPPASTProblemDeclaration,,<empty>
605153,UNKNOWN,385,,"{
            constexpr auto l = std::numeric_limits<til::CoordType>().max();
            const auto t = 10;
            const auto r = 15;
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            // On some platforms, til::CoordType will fit inside l/t/r/b
            const auto overflowExpected = l > std::numeric_limits<decltype(RECT::left)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = rc.to_win32_rect();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = rc.to_win32_rect();
                VERIFY_ARE_EQUAL(l, val.left);
            }
        }",9,<empty>,,913,385,CPPASTProblemDeclaration,,<empty>
605154,UNKNOWN,386,,"Log::Comment(L""Fit max top into RECT (may overflow)."");",9,<empty>,,938,386,CPPASTProblemDeclaration,,<empty>
605155,UNKNOWN,387,,"{
            const auto l = 5;
            constexpr auto t = std::numeric_limits<til::CoordType>().max();
            const auto r = 15;
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            // On some platforms, til::CoordType will fit inside l/t/r/b
            const auto overflowExpected = t > std::numeric_limits<decltype(RECT::top)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = rc.to_win32_rect();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = rc.to_win32_rect();
                VERIFY_ARE_EQUAL(t, val.top);
            }
        }",9,<empty>,,939,387,CPPASTProblemDeclaration,,<empty>
605156,UNKNOWN,388,,"Log::Comment(L""Fit max right into RECT (may overflow)."");",9,<empty>,,964,388,CPPASTProblemDeclaration,,<empty>
605157,UNKNOWN,389,,"{
            const auto l = 5;
            const auto t = 10;
            constexpr auto r = std::numeric_limits<til::CoordType>().max();
            const auto b = 20;
            const til::rect rc{ l, t, r, b };

            // On some platforms, til::CoordType will fit inside l/t/r/b
            const auto overflowExpected = r > std::numeric_limits<decltype(RECT::right)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = rc.to_win32_rect();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = rc.to_win32_rect();
                VERIFY_ARE_EQUAL(r, val.right);
            }
        }",9,<empty>,,965,389,CPPASTProblemDeclaration,,<empty>
605158,UNKNOWN,390,,"Log::Comment(L""Fit max bottom into RECT (may overflow)."");",9,<empty>,,990,390,CPPASTProblemDeclaration,,<empty>
605159,UNKNOWN,391,,"{
            const auto l = 5;
            const auto t = 10;
            const auto r = 15;
            constexpr auto b = std::numeric_limits<til::CoordType>().max();
            const til::rect rc{ l, t, r, b };

            // On some platforms, til::CoordType will fit inside l/t/r/b
            const auto overflowExpected = b > std::numeric_limits<decltype(RECT::bottom)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = rc.to_win32_rect();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = rc.to_win32_rect();
                VERIFY_ARE_EQUAL(b, val.bottom);
            }
        }",9,<empty>,,991,391,CPPASTProblemDeclaration,,<empty>
605160,UNKNOWN,392,,},5,<empty>,,1015,392,CPPASTProblemDeclaration,,<empty>
605161,UNKNOWN,393,,"TEST_METHOD(CastToD2D1RectF)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,1017,393,CPPASTProblemDeclaration,,<empty>
605162,UNKNOWN,394,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            auto val = rc.to_d2d_rect();
            VERIFY_ARE_EQUAL(5, val.left);
            VERIFY_ARE_EQUAL(10, val.top);
            VERIFY_ARE_EQUAL(15, val.right);
            VERIFY_ARE_EQUAL(20, val.bottom);
        }",9,<empty>,,1020,394,CPPASTProblemDeclaration,,<empty>
605163,UNKNOWN,395,,},5,<empty>,,1030,395,CPPASTProblemDeclaration,,<empty>
605164,UNKNOWN,396,,"TEST_METHOD(CastToWindowsFoundationRect)
    {
        Log::Comment(L""Typical situation."");",5,<empty>,,1032,396,CPPASTProblemDeclaration,,<empty>
605165,UNKNOWN,397,,"{
            const til::rect rc{ 5, 10, 15, 20 };
            auto val = rc.to_winrt_rect();
            VERIFY_ARE_EQUAL(5.f, val.X);
            VERIFY_ARE_EQUAL(10.f, val.Y);
            VERIFY_ARE_EQUAL(10.f, val.Width);
            VERIFY_ARE_EQUAL(10.f, val.Height);
        }",9,<empty>,,1035,397,CPPASTProblemDeclaration,,<empty>
605166,UNKNOWN,398,,},5,<empty>,,1047,398,CPPASTProblemDeclaration,,<empty>
605167,UNKNOWN,399,,"TEST_METHOD(Begin)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1050,399,CPPASTProblemDeclaration,,<empty>
605185,UNKNOWN,404,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1056,404,CPPASTProblemDeclaration,,<empty>
605186,UNKNOWN,405,,},5,<empty>,,1057,405,CPPASTProblemDeclaration,,<empty>
605187,UNKNOWN,406,,"TEST_METHOD(End)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1059,406,CPPASTProblemDeclaration,,<empty>
605205,UNKNOWN,411,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1065,411,CPPASTProblemDeclaration,,<empty>
605206,UNKNOWN,412,,},5,<empty>,,1066,412,CPPASTProblemDeclaration,,<empty>
605207,UNKNOWN,413,,"TEST_METHOD(ConstIteratorIncrement)
    {
        const til::rect rc{ til::size{ 2, 2 } };",5,<empty>,,1068,413,CPPASTProblemDeclaration,,<empty>
605222,UNKNOWN,418,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1074,418,CPPASTProblemDeclaration,,<empty>
605223,UNKNOWN,419,,++it;,9,<empty>,,1076,419,CPPASTProblemDeclaration,,<empty>
605224,UNKNOWN,420,,"expected = til::point{ 1, 0 };",9,<empty>,,1077,420,CPPASTProblemDeclaration,,<empty>
605225,UNKNOWN,421,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1078,421,CPPASTProblemDeclaration,,<empty>
605226,UNKNOWN,422,,++it;,9,<empty>,,1080,422,CPPASTProblemDeclaration,,<empty>
605227,UNKNOWN,423,,"expected = til::point{ 0, 1 };",9,<empty>,,1081,423,CPPASTProblemDeclaration,,<empty>
605228,UNKNOWN,424,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1082,424,CPPASTProblemDeclaration,,<empty>
605229,UNKNOWN,425,,++it;,9,<empty>,,1084,425,CPPASTProblemDeclaration,,<empty>
605230,UNKNOWN,426,,"expected = til::point{ 1, 1 };",9,<empty>,,1085,426,CPPASTProblemDeclaration,,<empty>
605231,UNKNOWN,427,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1086,427,CPPASTProblemDeclaration,,<empty>
605232,UNKNOWN,428,,++it;,9,<empty>,,1088,428,CPPASTProblemDeclaration,,<empty>
605233,UNKNOWN,429,,"expected = til::point{ 0, 2 };",9,<empty>,,1089,429,CPPASTProblemDeclaration,,<empty>
605234,UNKNOWN,430,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1090,430,CPPASTProblemDeclaration,,<empty>
605235,UNKNOWN,431,,"VERIFY_ARE_EQUAL(expected, *rc.end());",9,<empty>,,1091,431,CPPASTProblemDeclaration,,<empty>
605236,UNKNOWN,432,,++it;,9,<empty>,,1095,432,CPPASTProblemDeclaration,,<empty>
605237,UNKNOWN,433,,"expected = til::point{ 1, 2 };",9,<empty>,,1096,433,CPPASTProblemDeclaration,,<empty>
605238,UNKNOWN,434,,"VERIFY_ARE_EQUAL(expected, *it);",9,<empty>,,1097,434,CPPASTProblemDeclaration,,<empty>
605239,UNKNOWN,435,,},5,<empty>,,1098,435,CPPASTProblemDeclaration,,<empty>
605240,UNKNOWN,436,,"TEST_METHOD(ConstIteratorEquality)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1100,436,CPPASTProblemDeclaration,,<empty>
605241,UNKNOWN,437,,VERIFY_IS_TRUE(rc.begin() == rc.begin());,9,<empty>,,1104,437,CPPASTProblemDeclaration,,<empty>
605242,UNKNOWN,438,,VERIFY_IS_FALSE(rc.begin() == rc.end());,9,<empty>,,1105,438,CPPASTProblemDeclaration,,<empty>
605243,UNKNOWN,439,,},5,<empty>,,1106,439,CPPASTProblemDeclaration,,<empty>
605244,UNKNOWN,440,,"TEST_METHOD(ConstIteratorInequality)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1108,440,CPPASTProblemDeclaration,,<empty>
605245,UNKNOWN,441,,VERIFY_IS_FALSE(rc.begin() != rc.begin());,9,<empty>,,1112,441,CPPASTProblemDeclaration,,<empty>
605246,UNKNOWN,442,,VERIFY_IS_TRUE(rc.begin() != rc.end());,9,<empty>,,1113,442,CPPASTProblemDeclaration,,<empty>
605247,UNKNOWN,443,,},5,<empty>,,1114,443,CPPASTProblemDeclaration,,<empty>
605248,UNKNOWN,444,,"TEST_METHOD(ConstIteratorLessThan)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1116,444,CPPASTProblemDeclaration,,<empty>
605249,UNKNOWN,445,,VERIFY_IS_TRUE(rc.begin() < rc.end());,9,<empty>,,1120,445,CPPASTProblemDeclaration,,<empty>
605250,UNKNOWN,446,,VERIFY_IS_FALSE(rc.end() < rc.begin());,9,<empty>,,1121,446,CPPASTProblemDeclaration,,<empty>
605251,UNKNOWN,447,,},5,<empty>,,1122,447,CPPASTProblemDeclaration,,<empty>
605252,UNKNOWN,448,,"TEST_METHOD(ConstIteratorGreaterThan)
    {
        const til::rect rc{ 5, 10, 15, 20 };",5,<empty>,,1124,448,CPPASTProblemDeclaration,,<empty>
605253,UNKNOWN,449,,VERIFY_IS_TRUE(rc.end() > rc.begin());,9,<empty>,,1128,449,CPPASTProblemDeclaration,,<empty>
605254,UNKNOWN,450,,VERIFY_IS_FALSE(rc.begin() > rc.end());,9,<empty>,,1129,450,CPPASTProblemDeclaration,,<empty>
605255,UNKNOWN,451,,},5,<empty>,,1130,451,CPPASTProblemDeclaration,,<empty>
605256,UNKNOWN,452,,"TEST_METHOD(CastFromFloatWithMathTypes)
    {
        Log::Comment(L""Ceiling"");",5,<empty>,,1134,452,CPPASTProblemDeclaration,,<empty>
605257,UNKNOWN,453,,"{
            {
                til::rect converted{ til::math::ceiling, 1.f, 2.f, 3.f, 4.f };
                VERIFY_ARE_EQUAL((til::rect{ 1, 2, 3, 4 }), converted);
            }
            {
                til::rect converted{ til::math::ceiling, 1.6f, 2.4f, 3.2f, 4.8f };
                VERIFY_ARE_EQUAL((til::rect{ 2, 3, 4, 5 }), converted);
            }
            {
                til::rect converted{ til::math::ceiling, 3., 4., 5., 6. };
                VERIFY_ARE_EQUAL((til::rect{ 3, 4, 5, 6 }), converted);
            }
            {
                til::rect converted{ til::math::ceiling, 3.6, 4.4, 5.7, 6.3 };
                VERIFY_ARE_EQUAL((til::rect{ 4, 5, 6, 7 }), converted);
            }
        }",9,<empty>,,1137,453,CPPASTProblemDeclaration,,<empty>
605258,UNKNOWN,454,,"Log::Comment(L""Flooring"");",9,<empty>,,1156,454,CPPASTProblemDeclaration,,<empty>
605259,UNKNOWN,455,,"{
            {
                til::rect converted{ til::math::flooring, 1.f, 2.f, 3.f, 4.f };
                VERIFY_ARE_EQUAL((til::rect{ 1, 2, 3, 4 }), converted);
            }
            {
                til::rect converted{ til::math::flooring, 1.6f, 2.4f, 3.2f, 4.8f };
                VERIFY_ARE_EQUAL((til::rect{ 1, 2, 3, 4 }), converted);
            }
            {
                til::rect converted{ til::math::flooring, 3., 4., 5., 6. };
                VERIFY_ARE_EQUAL((til::rect{ 3, 4, 5, 6 }), converted);
            }
            {
                til::rect converted{ til::math::flooring, 3.6, 4.4, 5.7, 6.3 };
                VERIFY_ARE_EQUAL((til::rect{ 3, 4, 5, 6 }), converted);
            }
        }",9,<empty>,,1157,455,CPPASTProblemDeclaration,,<empty>
605260,UNKNOWN,456,,"Log::Comment(L""Rounding"");",9,<empty>,,1176,456,CPPASTProblemDeclaration,,<empty>
605261,UNKNOWN,457,,"{
            {
                til::rect converted{ til::math::rounding, 1.f, 2.f, 3.f, 4.f };
                VERIFY_ARE_EQUAL((til::rect{ 1, 2, 3, 4 }), converted);
            }
            {
                til::rect converted{ til::math::rounding, 1.6f, 2.4f, 3.2f, 4.8f };
                VERIFY_ARE_EQUAL((til::rect{ 2, 2, 3, 5 }), converted);
            }
            {
                til::rect converted{ til::math::rounding, 3., 4., 5., 6. };
                VERIFY_ARE_EQUAL((til::rect{ 3, 4, 5, 6 }), converted);
            }
            {
                til::rect converted{ til::math::rounding, 3.6, 4.4, 5.7, 6.3 };
                VERIFY_ARE_EQUAL((til::rect{ 4, 4, 6, 6 }), converted);
            }
        }",9,<empty>,,1177,457,CPPASTProblemDeclaration,,<empty>
605262,UNKNOWN,458,,},5,<empty>,,1195,458,CPPASTProblemDeclaration,,<empty>
605263,UNKNOWN,459,,};,1,<empty>,,1196,459,CPPASTProblemDeclaration,,<empty>
605818,UNKNOWN,3,,"TEST_METHOD(ConstructWithLengthAndValue)
    {
        rle_vector rle(5, 1);",5,<empty>,,204,3,CPPASTProblemDeclaration,,<empty>
605819,UNKNOWN,4,,"VERIFY_ARE_EQUAL(""1 1 1 1 1""sv, rle);",9,<empty>,,207,4,CPPASTProblemDeclaration,,<empty>
605820,UNKNOWN,5,,},5,<empty>,,208,5,CPPASTProblemDeclaration,,<empty>
605821,UNKNOWN,6,,"TEST_METHOD(CopyAndMove)
    {
        constexpr auto expected_full = ""1 1 1|2 2|1 1 1""sv;",5,<empty>,,210,6,CPPASTProblemDeclaration,,<empty>
605841,UNKNOWN,12,,"VERIFY_ARE_EQUAL(expected_full, rle1);",9,<empty>,,217,12,CPPASTProblemDeclaration,,<empty>
605842,UNKNOWN,13,,"VERIFY_ARE_EQUAL(expected_empty, rle2);",9,<empty>,,218,13,CPPASTProblemDeclaration,,<empty>
605843,UNKNOWN,14,,rle1.swap(rle2);,9,<empty>,,221,14,CPPASTProblemDeclaration,,<empty>
605844,UNKNOWN,15,,"VERIFY_ARE_EQUAL(expected_empty, rle1);",9,<empty>,,222,15,CPPASTProblemDeclaration,,<empty>
605845,UNKNOWN,16,,"VERIFY_ARE_EQUAL(expected_full, rle2);",9,<empty>,,223,16,CPPASTProblemDeclaration,,<empty>
605846,UNKNOWN,17,,rle1 = rle2;,9,<empty>,,226,17,CPPASTProblemDeclaration,,<empty>
605847,UNKNOWN,18,,"VERIFY_ARE_EQUAL(expected_full, rle1);",9,<empty>,,227,18,CPPASTProblemDeclaration,,<empty>
605848,UNKNOWN,19,,"VERIFY_ARE_EQUAL(expected_full, rle2);",9,<empty>,,228,19,CPPASTProblemDeclaration,,<empty>
605857,UNKNOWN,22,,rle1 = std::move(rle2);,9,<empty>,,234,22,CPPASTProblemDeclaration,,<empty>
605858,UNKNOWN,23,,"VERIFY_ARE_EQUAL(expected_full, rle1);",9,<empty>,,235,23,CPPASTProblemDeclaration,,<empty>
605859,UNKNOWN,24,,},5,<empty>,,236,24,CPPASTProblemDeclaration,,<empty>
605860,UNKNOWN,25,,"TEST_METHOD(At)
    {
        rle_vector rle{
            {
                { 1, 1 },
                { 3, 2 },
                { 2, 1 },
                { 1, 3 },
                { 5, 2 },
            }
        };",5,<empty>,,238,25,CPPASTProblemDeclaration,,<empty>
605861,UNKNOWN,26,,"VERIFY_ARE_EQUAL(1u, rle.at(0));",9,<empty>,,250,26,CPPASTProblemDeclaration,,<empty>
605862,UNKNOWN,27,,"VERIFY_ARE_EQUAL(3u, rle.at(1));",9,<empty>,,251,27,CPPASTProblemDeclaration,,<empty>
605863,UNKNOWN,28,,"VERIFY_ARE_EQUAL(3u, rle.at(2));",9,<empty>,,252,28,CPPASTProblemDeclaration,,<empty>
605864,UNKNOWN,29,,"VERIFY_ARE_EQUAL(2u, rle.at(3));",9,<empty>,,253,29,CPPASTProblemDeclaration,,<empty>
605865,UNKNOWN,30,,"VERIFY_ARE_EQUAL(1u, rle.at(4));",9,<empty>,,254,30,CPPASTProblemDeclaration,,<empty>
605866,UNKNOWN,31,,"VERIFY_ARE_EQUAL(1u, rle.at(5));",9,<empty>,,255,31,CPPASTProblemDeclaration,,<empty>
605867,UNKNOWN,32,,"VERIFY_ARE_EQUAL(1u, rle.at(6));",9,<empty>,,256,32,CPPASTProblemDeclaration,,<empty>
605868,UNKNOWN,33,,"VERIFY_ARE_EQUAL(5u, rle.at(7));",9,<empty>,,257,33,CPPASTProblemDeclaration,,<empty>
605869,UNKNOWN,34,,"VERIFY_ARE_EQUAL(5u, rle.at(8));",9,<empty>,,258,34,CPPASTProblemDeclaration,,<empty>
605870,UNKNOWN,35,,"VERIFY_THROWS(rle.at(9), std::out_of_range);",9,<empty>,,259,35,CPPASTProblemDeclaration,,<empty>
605871,UNKNOWN,36,,},5,<empty>,,260,36,CPPASTProblemDeclaration,,<empty>
605872,UNKNOWN,37,,"TEST_METHOD(Slice)
    {
        rle_vector rle{
            {
                { 1, 1 },
                { 3, 2 },
                { 2, 1 },
                { 1, 3 },
                { 5, 2 },
            }
        };",5,<empty>,,262,37,CPPASTProblemDeclaration,,<empty>
605873,UNKNOWN,38,,"VERIFY_ARE_EQUAL(""1|3 3|2|1 1 1|5 5""sv, rle);",9,<empty>,,274,38,CPPASTProblemDeclaration,,<empty>
605874,UNKNOWN,39,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(0, 0));",9,<empty>,,276,39,CPPASTProblemDeclaration,,<empty>
605875,UNKNOWN,40,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(1, 1));",9,<empty>,,277,40,CPPASTProblemDeclaration,,<empty>
605876,UNKNOWN,41,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(2, 2));",9,<empty>,,278,41,CPPASTProblemDeclaration,,<empty>
605877,UNKNOWN,42,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(rle.size(), rle.size()));",9,<empty>,,279,42,CPPASTProblemDeclaration,,<empty>
605878,UNKNOWN,43,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(5, 0));",9,<empty>,,280,43,CPPASTProblemDeclaration,,<empty>
605879,UNKNOWN,44,,"VERIFY_ARE_EQUAL(""""sv, rle.slice(1000, 900));",9,<empty>,,281,44,CPPASTProblemDeclaration,,<empty>
605880,UNKNOWN,45,,"VERIFY_ARE_EQUAL(""1|3 3|2|1 1 1|5 5""sv, rle.slice(0, rle.size()));",9,<empty>,,283,45,CPPASTProblemDeclaration,,<empty>
605881,UNKNOWN,46,,"VERIFY_ARE_EQUAL(""1|3 3|2|1 1 1""sv, rle.slice(0, 7));",9,<empty>,,285,46,CPPASTProblemDeclaration,,<empty>
605882,UNKNOWN,47,,"VERIFY_ARE_EQUAL(""2|1 1 1""sv, rle.slice(3, 7));",9,<empty>,,286,47,CPPASTProblemDeclaration,,<empty>
605883,UNKNOWN,48,,"VERIFY_ARE_EQUAL(""3 3|2|1""sv, rle.slice(1, 5));",9,<empty>,,288,48,CPPASTProblemDeclaration,,<empty>
605884,UNKNOWN,49,,"VERIFY_ARE_EQUAL(""3 3|2|1 1""sv, rle.slice(1, 6));",9,<empty>,,289,49,CPPASTProblemDeclaration,,<empty>
605885,UNKNOWN,50,,"VERIFY_ARE_EQUAL(""3|2|1 1 1|5 5""sv, rle.slice(2, rle.size()));",9,<empty>,,291,50,CPPASTProblemDeclaration,,<empty>
605886,UNKNOWN,51,,"VERIFY_ARE_EQUAL(""3|2|1 1 1""sv, rle.slice(2, 7));",9,<empty>,,292,51,CPPASTProblemDeclaration,,<empty>
605887,UNKNOWN,52,,"VERIFY_ARE_EQUAL(""3|2|1""sv, rle.slice(2, 5));",9,<empty>,,294,52,CPPASTProblemDeclaration,,<empty>
605888,UNKNOWN,53,,"VERIFY_ARE_EQUAL(""3|2|1 1""sv, rle.slice(2, 6));",9,<empty>,,295,53,CPPASTProblemDeclaration,,<empty>
605889,UNKNOWN,54,,},5,<empty>,,296,54,CPPASTProblemDeclaration,,<empty>
605890,UNKNOWN,55,,"TEST_METHOD(Replace)
    {
        struct TestCase
        {
            std::string_view source;

            size_type start_index;
            size_type end_index;
            std::string_view change;

            std::string_view expected;
        };",5,<empty>,,298,55,CPPASTProblemDeclaration,,<empty>
606068,UNKNOWN,60,,"for (const auto& test_case : test_cases)
        {
            rle_vector rle{ rle_encode(test_case.source) };
            const auto change = rle_encode(test_case.change);

            rle.replace(test_case.start_index, test_case.end_index, change);

            VERIFY_ARE_EQUAL(
                test_case.expected,
                rle,
                NoThrowString().Format(
                    L""test case:   %d\nsource:      %hs\nstart_index: %u\nend_index:   %u\nchange:      %hs\nexpected:    %hs\nactual:      %s"",
                    idx,
                    test_case.source.data(),
                    test_case.start_index,
                    test_case.end_index,
                    test_case.change.data(),
                    test_case.expected.data(),
                    rle.to_string().c_str()));

            ++idx;
        }",9,<empty>,,357,60,CPPASTProblemDeclaration,,<empty>
606069,UNKNOWN,61,,},5,<empty>,,379,61,CPPASTProblemDeclaration,,<empty>
606070,UNKNOWN,62,,"TEST_METHOD(ReplaceValues)
    {
        struct TestCase
        {
            std::string_view source;

            value_type old_value;
            value_type new_value;

            std::string_view expected;
        };",5,<empty>,,381,62,CPPASTProblemDeclaration,,<empty>
606110,UNKNOWN,67,,"for (const auto& test_case : test_cases)
        {
            rle_vector rle{ rle_encode(test_case.source) };
            rle.replace_values(test_case.old_value, test_case.new_value);

            VERIFY_ARE_EQUAL(
                test_case.expected,
                rle,
                NoThrowString().Format(
                    L""test case: %d\nsource:    %hs\nold_value: %u\nnew_value: %u\nexpected:  %hs\nactual:    %s"",
                    idx,
                    test_case.source.data(),
                    test_case.old_value,
                    test_case.new_value,
                    test_case.expected.data(),
                    rle.to_string().c_str()));
            ++idx;
        }",9,<empty>,,412,67,CPPASTProblemDeclaration,,<empty>
606111,UNKNOWN,68,,},5,<empty>,,430,68,CPPASTProblemDeclaration,,<empty>
606112,UNKNOWN,69,,"TEST_METHOD(ResizeTrailingExtent)
    {
        constexpr std::string_view data{ ""133211155"" };",5,<empty>,,432,69,CPPASTProblemDeclaration,,<empty>
606113,UNKNOWN,70,,for (size_type length = 0;,9,<empty>,,437,70,CPPASTProblemDeclaration,,<empty>
606114,UNKNOWN,71,,length <= data.size();,36,<empty>,,437,71,CPPASTProblemDeclaration,,<empty>
606115,UNKNOWN,72,,"length++)
        {
            rle_vector rle{ rle_encode(data) };
            rle.resize_trailing_extent(length);
            VERIFY_ARE_EQUAL(data.substr(0, length), rle);
        }",59,<empty>,,437,72,CPPASTProblemDeclaration,,<empty>
606116,UNKNOWN,73,,"{
            std::string expected{ data };
            expected.insert(expected.end(), 5, expected.back());

            rle_vector actual{ rle_encode(data) };
            actual.resize_trailing_extent(static_cast<size_type>(expected.size()));

            VERIFY_ARE_EQUAL(std::string_view{ expected }, actual);
        }",9,<empty>,,445,73,CPPASTProblemDeclaration,,<empty>
606117,UNKNOWN,74,,},5,<empty>,,454,74,CPPASTProblemDeclaration,,<empty>
606118,UNKNOWN,75,,"TEST_METHOD(Comparison)
    {
        rle_vector rle1{ { { 1, 1 }, { 3, 2 }, { 2, 1 } } };",5,<empty>,,456,75,CPPASTProblemDeclaration,,<empty>
606124,UNKNOWN,78,,VERIFY_IS_TRUE(rle1 == rle2);,9,<empty>,,461,78,CPPASTProblemDeclaration,,<empty>
606125,UNKNOWN,79,,VERIFY_IS_FALSE(rle1 != rle2);,9,<empty>,,462,79,CPPASTProblemDeclaration,,<empty>
606126,UNKNOWN,80,,"rle2.replace(0, 1, 2);",9,<empty>,,464,80,CPPASTProblemDeclaration,,<empty>
606127,UNKNOWN,81,,VERIFY_IS_FALSE(rle1 == rle2);,9,<empty>,,466,81,CPPASTProblemDeclaration,,<empty>
606128,UNKNOWN,82,,VERIFY_IS_TRUE(rle1 != rle2);,9,<empty>,,467,82,CPPASTProblemDeclaration,,<empty>
606129,UNKNOWN,83,,},5,<empty>,,468,83,CPPASTProblemDeclaration,,<empty>
606130,UNKNOWN,84,,"TEST_METHOD(Iterators)
    {
        using difference_type = rle_vector::const_iterator::difference_type;",5,<empty>,,470,84,CPPASTProblemDeclaration,,<empty>
606142,UNKNOWN,89,,"{
            std::string actual;
            actual.reserve(expected.size());

            for (auto v : rle)
            {
                actual.push_back(static_cast<char>(v + '0'));
            }

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,478,89,CPPASTProblemDeclaration,,<empty>
606143,UNKNOWN,90,,"{
            std::string reverse_expectation{ expected };
            std::ranges::reverse(reverse_expectation);

            std::string actual;
            actual.reserve(reverse_expectation.size());

            for (auto it = rle.rbegin(); it != rle.rend(); ++it)
            {
                actual.push_back(static_cast<char>(*it + '0'));
            }

            VERIFY_ARE_EQUAL(reverse_expectation, actual);
        }",9,<empty>,,491,90,CPPASTProblemDeclaration,,<empty>
606144,UNKNOWN,91,,"{
            auto it = rle.begin();
            const auto end = rle.end();

            // 133211155
            // ^
            it += 2;
            VERIFY_ARE_EQUAL(3u, *it);

            // 133211155
            //    ^
            it += 1;
            VERIFY_ARE_EQUAL(2u, *it);

            // 133211155
            //     ^
            it += 1;
            VERIFY_ARE_EQUAL(1u, *it);

            // 133211155
            //       ^
            it += 2;
            VERIFY_ARE_EQUAL(1u, *it);

            // 133211155
            //         ^
            it += 2;
            VERIFY_ARE_EQUAL(5u, *it);

            // 133211155
            //          ^
            ++it;
            VERIFY_ARE_EQUAL(end, it);
        }",9,<empty>,,507,91,CPPASTProblemDeclaration,,<empty>
606145,UNKNOWN,92,,"{
            auto it = rle.end();

            // 133211155
            //         ^
            --it;
            VERIFY_ARE_EQUAL(5u, *it);

            // 133211155
            //       ^
            it -= 2;
            VERIFY_ARE_EQUAL(1u, *it);

            // 133211155
            //     ^
            it -= 2;
            VERIFY_ARE_EQUAL(1u, *it);

            // 133211155
            //    ^
            it -= 1;
            VERIFY_ARE_EQUAL(2u, *it);

            // 133211155
            // ^
            it -= 1;
            VERIFY_ARE_EQUAL(3u, *it);
        }",9,<empty>,,543,92,CPPASTProblemDeclaration,,<empty>
606146,UNKNOWN,93,,"{
            const auto beg = rle.begin();
            auto it = beg;

            for (size_t i = 0; i < expected.size(); ++i, ++it)
            {
                VERIFY_ARE_EQUAL(static_cast<difference_type>(i), it - beg);
                VERIFY_ARE_EQUAL(-static_cast<difference_type>(i), beg - it);
            }
        }",9,<empty>,,573,93,CPPASTProblemDeclaration,,<empty>
606147,UNKNOWN,94,,"{
            const auto beg = rle.begin();
            const auto lower = beg + 2;
            const auto upper = beg + 5;

            VERIFY_ARE_EQUAL(static_cast<difference_type>(3), upper - lower);
            VERIFY_ARE_EQUAL(-static_cast<difference_type>(3), lower - upper);
        }",9,<empty>,,585,94,CPPASTProblemDeclaration,,<empty>
606148,UNKNOWN,95,,"{
            const auto beg = rle.begin();
            const auto lower = beg + 5;
            const auto upper = beg + 6;

            VERIFY_ARE_EQUAL(static_cast<difference_type>(1), upper - lower);
            VERIFY_ARE_EQUAL(-static_cast<difference_type>(1), lower - upper);
        }",9,<empty>,,595,95,CPPASTProblemDeclaration,,<empty>
606149,UNKNOWN,96,,},5,<empty>,,603,96,CPPASTProblemDeclaration,,<empty>
606150,UNKNOWN,97,,};,1,<empty>,,604,97,CPPASTProblemDeclaration,,<empty>
606307,UNKNOWN,-1,,),31,<empty>,,51,2,CPPASTProblemDeclaration,,<empty>
606308,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:10"") // 10s timeout
    END_TEST_CLASS()

    TEST_METHOD(SmokeTest);",9,<empty>,,52,3,CPPASTProblemDeclaration,,<empty>
606889,UNKNOWN,3,,"TEST_METHOD(RawFloatingConstruct)
    {
        const til::size sz{ til::math::rounding, 3.2f, 7.8f };",5,<empty>,,37,3,CPPASTProblemDeclaration,,<empty>
606890,UNKNOWN,4,,"VERIFY_ARE_EQUAL(3, sz.width);",9,<empty>,,40,4,CPPASTProblemDeclaration,,<empty>
606891,UNKNOWN,5,,"VERIFY_ARE_EQUAL(8, sz.height);",9,<empty>,,41,5,CPPASTProblemDeclaration,,<empty>
606892,UNKNOWN,6,,},5,<empty>,,42,6,CPPASTProblemDeclaration,,<empty>
606893,UNKNOWN,7,,"TEST_METHOD(SignedConstruct)
    {
        const auto width = -5;",5,<empty>,,44,7,CPPASTProblemDeclaration,,<empty>
606905,UNKNOWN,12,,"VERIFY_ARE_EQUAL(width, sz.width);",9,<empty>,,50,12,CPPASTProblemDeclaration,,<empty>
606906,UNKNOWN,13,,"VERIFY_ARE_EQUAL(height, sz.height);",9,<empty>,,51,13,CPPASTProblemDeclaration,,<empty>
606907,UNKNOWN,14,,},5,<empty>,,52,14,CPPASTProblemDeclaration,,<empty>
606908,UNKNOWN,15,,"TEST_METHOD(CoordConstruct)
    {
        COORD coord{ -5, 10 };",5,<empty>,,54,15,CPPASTProblemDeclaration,,<empty>
606917,UNKNOWN,18,,"VERIFY_ARE_EQUAL(coord.X, sz.width);",9,<empty>,,59,18,CPPASTProblemDeclaration,,<empty>
606918,UNKNOWN,19,,"VERIFY_ARE_EQUAL(coord.Y, sz.height);",9,<empty>,,60,19,CPPASTProblemDeclaration,,<empty>
606919,UNKNOWN,20,,},5,<empty>,,61,20,CPPASTProblemDeclaration,,<empty>
606920,UNKNOWN,21,,"TEST_METHOD(SizeConstruct)
    {
        SIZE size{ 5, -10 };",5,<empty>,,63,21,CPPASTProblemDeclaration,,<empty>
606926,UNKNOWN,24,,"VERIFY_ARE_EQUAL(size.cx, sz.width);",9,<empty>,,68,24,CPPASTProblemDeclaration,,<empty>
606927,UNKNOWN,25,,"VERIFY_ARE_EQUAL(size.cy, sz.height);",9,<empty>,,69,25,CPPASTProblemDeclaration,,<empty>
606928,UNKNOWN,26,,},5,<empty>,,70,26,CPPASTProblemDeclaration,,<empty>
606929,UNKNOWN,27,,"TEST_METHOD(Equality)
    {
        Log::Comment(L""0.) Equal."");",5,<empty>,,72,27,CPPASTProblemDeclaration,,<empty>
606930,UNKNOWN,28,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 == s2);
        }",9,<empty>,,75,28,CPPASTProblemDeclaration,,<empty>
606931,UNKNOWN,29,,"Log::Comment(L""1.) Left Width changed."");",9,<empty>,,81,29,CPPASTProblemDeclaration,,<empty>
606932,UNKNOWN,30,,"{
            const til::size s1{ 4, 10 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,82,30,CPPASTProblemDeclaration,,<empty>
606933,UNKNOWN,31,,"Log::Comment(L""2.) Right Width changed."");",9,<empty>,,88,31,CPPASTProblemDeclaration,,<empty>
606934,UNKNOWN,32,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 6, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,89,32,CPPASTProblemDeclaration,,<empty>
606935,UNKNOWN,33,,"Log::Comment(L""3.) Left Height changed."");",9,<empty>,,95,33,CPPASTProblemDeclaration,,<empty>
606936,UNKNOWN,34,,"{
            const til::size s1{ 5, 9 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,96,34,CPPASTProblemDeclaration,,<empty>
606937,UNKNOWN,35,,"Log::Comment(L""4.) Right Height changed."");",9,<empty>,,102,35,CPPASTProblemDeclaration,,<empty>
606938,UNKNOWN,36,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 5, 11 };
            VERIFY_IS_FALSE(s1 == s2);
        }",9,<empty>,,103,36,CPPASTProblemDeclaration,,<empty>
606939,UNKNOWN,37,,},5,<empty>,,108,37,CPPASTProblemDeclaration,,<empty>
606940,UNKNOWN,38,,"TEST_METHOD(Inequality)
    {
        Log::Comment(L""0.) Equal."");",5,<empty>,,110,38,CPPASTProblemDeclaration,,<empty>
606941,UNKNOWN,39,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_FALSE(s1 != s2);
        }",9,<empty>,,113,39,CPPASTProblemDeclaration,,<empty>
606942,UNKNOWN,40,,"Log::Comment(L""1.) Left Width changed."");",9,<empty>,,119,40,CPPASTProblemDeclaration,,<empty>
606943,UNKNOWN,41,,"{
            const til::size s1{ 4, 10 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,120,41,CPPASTProblemDeclaration,,<empty>
606944,UNKNOWN,42,,"Log::Comment(L""2.) Right Width changed."");",9,<empty>,,126,42,CPPASTProblemDeclaration,,<empty>
606945,UNKNOWN,43,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 6, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,127,43,CPPASTProblemDeclaration,,<empty>
606946,UNKNOWN,44,,"Log::Comment(L""3.) Left Height changed."");",9,<empty>,,133,44,CPPASTProblemDeclaration,,<empty>
606947,UNKNOWN,45,,"{
            const til::size s1{ 5, 9 };
            const til::size s2{ 5, 10 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,134,45,CPPASTProblemDeclaration,,<empty>
606948,UNKNOWN,46,,"Log::Comment(L""4.) Right Height changed."");",9,<empty>,,140,46,CPPASTProblemDeclaration,,<empty>
606949,UNKNOWN,47,,"{
            const til::size s1{ 5, 10 };
            const til::size s2{ 5, 11 };
            VERIFY_IS_TRUE(s1 != s2);
        }",9,<empty>,,141,47,CPPASTProblemDeclaration,,<empty>
606950,UNKNOWN,48,,},5,<empty>,,146,48,CPPASTProblemDeclaration,,<empty>
606951,UNKNOWN,49,,"TEST_METHOD(Boolean)
    {
        const til::size empty;",5,<empty>,,148,49,CPPASTProblemDeclaration,,<empty>
606952,UNKNOWN,50,,VERIFY_IS_FALSE(!!empty);,9,<empty>,,151,50,CPPASTProblemDeclaration,,<empty>
606959,UNKNOWN,53,,VERIFY_IS_FALSE(!!yOnly);,9,<empty>,,154,53,CPPASTProblemDeclaration,,<empty>
606966,UNKNOWN,56,,VERIFY_IS_FALSE(!!xOnly);,9,<empty>,,157,56,CPPASTProblemDeclaration,,<empty>
606973,UNKNOWN,59,,VERIFY_IS_TRUE(!!both);,9,<empty>,,160,59,CPPASTProblemDeclaration,,<empty>
606981,UNKNOWN,62,,VERIFY_IS_FALSE(!!yNegative);,9,<empty>,,163,62,CPPASTProblemDeclaration,,<empty>
606989,UNKNOWN,65,,VERIFY_IS_FALSE(!!xNegative);,9,<empty>,,166,65,CPPASTProblemDeclaration,,<empty>
606998,UNKNOWN,68,,VERIFY_IS_FALSE(!!bothNegative);,9,<empty>,,169,68,CPPASTProblemDeclaration,,<empty>
606999,UNKNOWN,69,,},5,<empty>,,170,69,CPPASTProblemDeclaration,,<empty>
607000,UNKNOWN,70,,"TEST_METHOD(Addition)
    {
        Log::Comment(L""0.) Addition of two things that should be in bounds."");",5,<empty>,,172,70,CPPASTProblemDeclaration,,<empty>
607001,UNKNOWN,71,,"{
            const til::size sz{ 5, 10 };
            const til::size sz2{ 23, 47 };

            const til::size expected{ sz.width + sz2.width, sz.height + sz2.height };

            VERIFY_ARE_EQUAL(expected, sz + sz2);
        }",9,<empty>,,175,71,CPPASTProblemDeclaration,,<empty>
607002,UNKNOWN,72,,"Log::Comment(L""1.) Addition results in value that is too large (width)."");",9,<empty>,,184,72,CPPASTProblemDeclaration,,<empty>
607003,UNKNOWN,73,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ bigSize, static_cast<til::CoordType>(0) };
            const til::size sz2{ 1, 1 };

            auto fn = [&]() {
                sz + sz2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,185,73,CPPASTProblemDeclaration,,<empty>
607004,UNKNOWN,74,,"Log::Comment(L""2.) Addition results in value that is too large (height)."");",9,<empty>,,197,74,CPPASTProblemDeclaration,,<empty>
607005,UNKNOWN,75,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ static_cast<til::CoordType>(0), bigSize };
            const til::size sz2{ 1, 1 };

            auto fn = [&]() {
                sz + sz2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,198,75,CPPASTProblemDeclaration,,<empty>
607006,UNKNOWN,76,,},5,<empty>,,209,76,CPPASTProblemDeclaration,,<empty>
607007,UNKNOWN,77,,"TEST_METHOD(Subtraction)
    {
        Log::Comment(L""0.) Subtraction of two things that should be in bounds."");",5,<empty>,,211,77,CPPASTProblemDeclaration,,<empty>
607008,UNKNOWN,78,,"{
            const til::size sz{ 5, 10 };
            const til::size sz2{ 23, 47 };

            const til::size expected{ sz.width - sz2.width, sz.height - sz2.height };

            VERIFY_ARE_EQUAL(expected, sz - sz2);
        }",9,<empty>,,214,78,CPPASTProblemDeclaration,,<empty>
607009,UNKNOWN,79,,"Log::Comment(L""1.) Subtraction results in value that is too small (width)."");",9,<empty>,,223,79,CPPASTProblemDeclaration,,<empty>
607010,UNKNOWN,80,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ bigSize, static_cast<til::CoordType>(0) };
            const til::size sz2{ -2, -2 };

            auto fn = [&]() {
                sz2 - sz;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,224,80,CPPASTProblemDeclaration,,<empty>
607011,UNKNOWN,81,,"Log::Comment(L""2.) Subtraction results in value that is too small (height)."");",9,<empty>,,236,81,CPPASTProblemDeclaration,,<empty>
607012,UNKNOWN,82,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ static_cast<til::CoordType>(0), bigSize };
            const til::size sz2{ -2, -2 };

            auto fn = [&]() {
                sz2 - sz;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,237,82,CPPASTProblemDeclaration,,<empty>
607013,UNKNOWN,83,,},5,<empty>,,248,83,CPPASTProblemDeclaration,,<empty>
607014,UNKNOWN,84,,"TEST_METHOD(Multiplication)
    {
        Log::Comment(L""0.) Multiplication of two things that should be in bounds."");",5,<empty>,,250,84,CPPASTProblemDeclaration,,<empty>
607015,UNKNOWN,85,,"{
            const til::size sz{ 5, 10 };
            const til::size sz2{ 23, 47 };

            const til::size expected{ sz.width * sz2.width, sz.height * sz2.height };

            VERIFY_ARE_EQUAL(expected, sz * sz2);
        }",9,<empty>,,253,85,CPPASTProblemDeclaration,,<empty>
607016,UNKNOWN,86,,"Log::Comment(L""1.) Multiplication results in value that is too large (width)."");",9,<empty>,,262,86,CPPASTProblemDeclaration,,<empty>
607017,UNKNOWN,87,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ bigSize, static_cast<til::CoordType>(0) };
            const til::size sz2{ 10, 10 };

            auto fn = [&]() {
                sz* sz2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,263,87,CPPASTProblemDeclaration,,<empty>
607018,UNKNOWN,88,,"Log::Comment(L""2.) Multiplication results in value that is too large (height)."");",9,<empty>,,275,88,CPPASTProblemDeclaration,,<empty>
607019,UNKNOWN,89,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ static_cast<til::CoordType>(0), bigSize };
            const til::size sz2{ 10, 10 };

            auto fn = [&]() {
                sz* sz2;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,276,89,CPPASTProblemDeclaration,,<empty>
607020,UNKNOWN,90,,},5,<empty>,,287,90,CPPASTProblemDeclaration,,<empty>
607021,UNKNOWN,91,,"TEST_METHOD(ScaleByFloat)
    {
        Log::Comment(L""0.) Scale that should be in bounds."");",5,<empty>,,289,91,CPPASTProblemDeclaration,,<empty>
607022,UNKNOWN,92,,"{
            const til::size sz{ 5, 10 };
            const auto scale = 1.783f;

            const til::size expected{ static_cast<til::CoordType>(ceil(5 * scale)), static_cast<til::CoordType>(ceil(10 * scale)) };

            const auto actual = sz.scale(til::math::ceiling, scale);

            VERIFY_ARE_EQUAL(expected, actual);
        }",9,<empty>,,292,92,CPPASTProblemDeclaration,,<empty>
607023,UNKNOWN,93,,"Log::Comment(L""1.) Scale results in value that is too large."");",9,<empty>,,303,93,CPPASTProblemDeclaration,,<empty>
607024,UNKNOWN,94,,"{
            const til::size sz{ 5, 10 };
            constexpr auto scale = 1e12f;

            auto fn = [&]() {
                std::ignore = sz.scale(til::math::ceiling, scale);
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,304,94,CPPASTProblemDeclaration,,<empty>
607025,UNKNOWN,95,,},5,<empty>,,314,95,CPPASTProblemDeclaration,,<empty>
607026,UNKNOWN,96,,"TEST_METHOD(Division)
    {
        Log::Comment(L""0.) Division of two things that should be in bounds."");",5,<empty>,,316,96,CPPASTProblemDeclaration,,<empty>
607027,UNKNOWN,97,,"{
            const til::size sz{ 555, 510 };
            const til::size sz2{ 23, 47 };

            const til::size expected{ sz.width / sz2.width, sz.height / sz2.height };

            VERIFY_ARE_EQUAL(expected, sz / sz2);
        }",9,<empty>,,319,97,CPPASTProblemDeclaration,,<empty>
607028,UNKNOWN,98,,"Log::Comment(L""1.) Division by zero"");",9,<empty>,,328,98,CPPASTProblemDeclaration,,<empty>
607029,UNKNOWN,99,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ bigSize, static_cast<til::CoordType>(0) };
            const til::size sz2{ 1, 1 };

            auto fn = [&]() {
                sz2 / sz;
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,329,99,CPPASTProblemDeclaration,,<empty>
607030,UNKNOWN,100,,},5,<empty>,,340,100,CPPASTProblemDeclaration,,<empty>
607031,UNKNOWN,101,,"TEST_METHOD(DivisionRoundingUp)
    {
        Log::Comment(L""1.) Division rounding up with positive result."");",5,<empty>,,342,101,CPPASTProblemDeclaration,,<empty>
607032,UNKNOWN,102,,"{
            const til::size sz{ 10, 5 };
            const til::size divisor{ 3, 2 };

            // 10 / 3 is 3.333, rounded up is 4.
            // 5 / 2 is 2.5, rounded up is 3.
            const til::size expected{ 4, 3 };

            VERIFY_ARE_EQUAL(expected, sz.divide_ceil(divisor));
        }",9,<empty>,,345,102,CPPASTProblemDeclaration,,<empty>
607033,UNKNOWN,103,,"Log::Comment(L""2.) Division rounding larger(up) with negative result."");",9,<empty>,,356,103,CPPASTProblemDeclaration,,<empty>
607034,UNKNOWN,104,,"{
            const til::size sz{ -10, -5 };
            const til::size divisor{ 3, 2 };

            auto fn = [&]() {
                std::ignore = sz.divide_ceil(divisor);
            };

            VERIFY_THROWS(fn(), std::invalid_argument);
        }",9,<empty>,,357,104,CPPASTProblemDeclaration,,<empty>
607035,UNKNOWN,105,,},5,<empty>,,367,105,CPPASTProblemDeclaration,,<empty>
607036,UNKNOWN,106,,"TEST_METHOD(WidthCast)
    {
        const til::size sz{ 5, 10 };",5,<empty>,,369,106,CPPASTProblemDeclaration,,<empty>
607037,UNKNOWN,107,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(sz.width), sz.narrow_width<SHORT>());",9,<empty>,,372,107,CPPASTProblemDeclaration,,<empty>
607038,UNKNOWN,108,,},5,<empty>,,373,108,CPPASTProblemDeclaration,,<empty>
607039,UNKNOWN,109,,"TEST_METHOD(HeightCast)
    {
        const til::size sz{ 5, 10 };",5,<empty>,,375,109,CPPASTProblemDeclaration,,<empty>
607040,UNKNOWN,110,,"VERIFY_ARE_EQUAL(static_cast<SHORT>(sz.height), sz.narrow_height<SHORT>());",9,<empty>,,378,110,CPPASTProblemDeclaration,,<empty>
607041,UNKNOWN,111,,},5,<empty>,,379,111,CPPASTProblemDeclaration,,<empty>
607042,UNKNOWN,112,,"TEST_METHOD(Area)
    {
        Log::Comment(L""0.) Area of two things that should be in bounds."");",5,<empty>,,381,112,CPPASTProblemDeclaration,,<empty>
607043,UNKNOWN,113,,"{
            const til::size sz{ 5, 10 };
            VERIFY_ARE_EQUAL(sz.width * sz.height, sz.area());
        }",9,<empty>,,384,113,CPPASTProblemDeclaration,,<empty>
607044,UNKNOWN,114,,"Log::Comment(L""1.) Area is out of bounds on multiplication."");",9,<empty>,,389,114,CPPASTProblemDeclaration,,<empty>
607045,UNKNOWN,115,,"{
            constexpr auto bigSize = std::numeric_limits<til::CoordType>().max();
            const til::size sz{ bigSize, bigSize };

            auto fn = [&]() {
                sz.area();
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,390,115,CPPASTProblemDeclaration,,<empty>
607046,UNKNOWN,116,,},5,<empty>,,400,116,CPPASTProblemDeclaration,,<empty>
607047,UNKNOWN,117,,"TEST_METHOD(AreaCast)
    {
        Log::Comment(L""0.) Area of two things that should be in bounds."");",5,<empty>,,401,117,CPPASTProblemDeclaration,,<empty>
607048,UNKNOWN,118,,"{
            const til::size sz{ 5, 10 };
            VERIFY_ARE_EQUAL(static_cast<SHORT>(sz.area()), sz.area<SHORT>());
        }",9,<empty>,,404,118,CPPASTProblemDeclaration,,<empty>
607049,UNKNOWN,119,,"Log::Comment(L""1.) Area is out of bounds on multiplication."");",9,<empty>,,409,119,CPPASTProblemDeclaration,,<empty>
607050,UNKNOWN,120,,"{
            constexpr til::CoordType bigSize = std::numeric_limits<SHORT>().max();
            const til::size sz{ bigSize, bigSize };

            auto fn = [&]() {
                sz.area<SHORT>();
            };

            VERIFY_THROWS(fn(), gsl::narrowing_error);
        }",9,<empty>,,410,120,CPPASTProblemDeclaration,,<empty>
607051,UNKNOWN,121,,},5,<empty>,,420,121,CPPASTProblemDeclaration,,<empty>
607052,UNKNOWN,122,,"TEST_METHOD(CastToSize)
    {
        Log::Comment(L""0.) Typical situation."");",5,<empty>,,422,122,CPPASTProblemDeclaration,,<empty>
607053,UNKNOWN,123,,"{
            const til::size sz{ 5, 10 };
            auto val = sz.to_win32_size();
            VERIFY_ARE_EQUAL(5, val.cx);
            VERIFY_ARE_EQUAL(10, val.cy);
        }",9,<empty>,,425,123,CPPASTProblemDeclaration,,<empty>
607054,UNKNOWN,124,,"Log::Comment(L""1.) Fit max width into SIZE (may overflow)."");",9,<empty>,,432,124,CPPASTProblemDeclaration,,<empty>
607055,UNKNOWN,125,,"{
            constexpr auto width = std::numeric_limits<til::CoordType>().max();
            const auto height = 10;
            const til::size sz{ width, height };

            // On some platforms, til::CoordType will fit inside cx/cy
            const auto overflowExpected = width > std::numeric_limits<decltype(SIZE::cx)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = sz.to_win32_size();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = sz.to_win32_size();
                VERIFY_ARE_EQUAL(width, val.cx);
            }
        }",9,<empty>,,433,125,CPPASTProblemDeclaration,,<empty>
607056,UNKNOWN,126,,"Log::Comment(L""2.) Fit max height into SIZE (may overflow)."");",9,<empty>,,456,126,CPPASTProblemDeclaration,,<empty>
607057,UNKNOWN,127,,"{
            constexpr auto height = std::numeric_limits<til::CoordType>().max();
            const auto width = 10;
            const til::size sz{ width, height };

            // On some platforms, til::CoordType will fit inside cx/cy
            const auto overflowExpected = height > std::numeric_limits<decltype(SIZE::cy)>().max();

            if (overflowExpected)
            {
                auto fn = [&]() {
                    auto val = sz.to_win32_size();
                };

                VERIFY_THROWS(fn(), gsl::narrowing_error);
            }
            else
            {
                auto val = sz.to_win32_size();
                VERIFY_ARE_EQUAL(height, val.cy);
            }
        }",9,<empty>,,457,127,CPPASTProblemDeclaration,,<empty>
607058,UNKNOWN,128,,},5,<empty>,,479,128,CPPASTProblemDeclaration,,<empty>
607059,UNKNOWN,129,,"TEST_METHOD(CastToD2D1SizeF)
    {
        Log::Comment(L""0.) Typical situation."");",5,<empty>,,481,129,CPPASTProblemDeclaration,,<empty>
607060,UNKNOWN,130,,"{
            const til::size sz{ 5, 10 };
            auto val = sz.to_d2d_size();
            VERIFY_ARE_EQUAL(5, val.width);
            VERIFY_ARE_EQUAL(10, val.height);
        }",9,<empty>,,484,130,CPPASTProblemDeclaration,,<empty>
607061,UNKNOWN,131,,},5,<empty>,,492,131,CPPASTProblemDeclaration,,<empty>
607062,UNKNOWN,132,,"TEST_METHOD(CastFromFloatWithMathTypes)
    {
        Log::Comment(L""0.) Ceiling"");",5,<empty>,,494,132,CPPASTProblemDeclaration,,<empty>
607063,UNKNOWN,133,,"{
            {
                til::size converted{ til::math::ceiling, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::size{ 1, 2 }), converted);
            }
            {
                til::size converted{ til::math::ceiling, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::size{ 2, 3 }), converted);
            }
            {
                til::size converted{ til::math::ceiling, 3., 4. };
                VERIFY_ARE_EQUAL((til::size{ 3, 4 }), converted);
            }
            {
                til::size converted{ til::math::ceiling, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::size{ 4, 5 }), converted);
            }
            {
                til::size converted{ til::math::ceiling, 5., 6. };
                VERIFY_ARE_EQUAL((til::size{ 5, 6 }), converted);
            }
            {
                til::size converted{ til::math::ceiling, 5.6, 6.4 };
                VERIFY_ARE_EQUAL((til::size{ 6, 7 }), converted);
            }
        }",9,<empty>,,497,133,CPPASTProblemDeclaration,,<empty>
607064,UNKNOWN,134,,"Log::Comment(L""1.) Flooring"");",9,<empty>,,524,134,CPPASTProblemDeclaration,,<empty>
607065,UNKNOWN,135,,"{
            {
                til::size converted{ til::math::flooring, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::size{ 1, 2 }), converted);
            }
            {
                til::size converted{ til::math::flooring, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::size{ 1, 2 }), converted);
            }
            {
                til::size converted{ til::math::flooring, 3., 4. };
                VERIFY_ARE_EQUAL((til::size{ 3, 4 }), converted);
            }
            {
                til::size converted{ til::math::flooring, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::size{ 3, 4 }), converted);
            }
            {
                til::size converted{ til::math::flooring, 5., 6. };
                VERIFY_ARE_EQUAL((til::size{ 5, 6 }), converted);
            }
            {
                til::size converted{ til::math::flooring, 5.6, 6.4 };
                VERIFY_ARE_EQUAL((til::size{ 5, 6 }), converted);
            }
        }",9,<empty>,,525,135,CPPASTProblemDeclaration,,<empty>
607066,UNKNOWN,136,,"Log::Comment(L""2.) Rounding"");",9,<empty>,,552,136,CPPASTProblemDeclaration,,<empty>
607067,UNKNOWN,137,,"{
            {
                til::size converted{ til::math::rounding, 1.f, 2.f };
                VERIFY_ARE_EQUAL((til::size{ 1, 2 }), converted);
            }
            {
                til::size converted{ til::math::rounding, 1.6f, 2.4f };
                VERIFY_ARE_EQUAL((til::size{ 2, 2 }), converted);
            }
            {
                til::size converted{ til::math::rounding, 3., 4. };
                VERIFY_ARE_EQUAL((til::size{ 3, 4 }), converted);
            }
            {
                til::size converted{ til::math::rounding, 3.6, 4.4 };
                VERIFY_ARE_EQUAL((til::size{ 4, 4 }), converted);
            }
            {
                til::size converted{ til::math::rounding, 5., 6. };
                VERIFY_ARE_EQUAL((til::size{ 5, 6 }), converted);
            }
            {
                til::size converted{ til::math::rounding, 5.6, 6.4 };
                VERIFY_ARE_EQUAL((til::size{ 6, 6 }), converted);
            }
        }",9,<empty>,,553,137,CPPASTProblemDeclaration,,<empty>
607068,UNKNOWN,138,,},5,<empty>,,579,138,CPPASTProblemDeclaration,,<empty>
607069,UNKNOWN,139,,};,1,<empty>,,580,139,CPPASTProblemDeclaration,,<empty>
607301,UNKNOWN,4,,"TEST_METHOD(CopyOntoItself)
    {
        til::small_vector<Copyable_int, 5> actual(3);",5,<empty>,,372,4,CPPASTProblemDeclaration,,<empty>
607302,UNKNOWN,5,,actual.operator=(actual);,9,<empty>,,375,5,CPPASTProblemDeclaration,,<empty>
607306,UNKNOWN,8,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,378,8,CPPASTProblemDeclaration,,<empty>
607307,UNKNOWN,9,,},5,<empty>,,379,9,CPPASTProblemDeclaration,,<empty>
607308,UNKNOWN,10,,"TEST_METHOD(MoveOntoItself)
    {
        til::small_vector<Movable_int, 5> actual;",5,<empty>,,381,10,CPPASTProblemDeclaration,,<empty>
607309,UNKNOWN,11,,actual.resize(3);,9,<empty>,,384,11,CPPASTProblemDeclaration,,<empty>
607310,UNKNOWN,12,,actual.operator=(std::move(actual));,9,<empty>,,385,12,CPPASTProblemDeclaration,,<empty>
607312,UNKNOWN,14,,expected.resize(3);,9,<empty>,,388,14,CPPASTProblemDeclaration,,<empty>
607313,UNKNOWN,15,,"VERIFY_ARE_EQUAL(expected, actual);",9,<empty>,,389,15,CPPASTProblemDeclaration,,<empty>
607314,UNKNOWN,16,,},5,<empty>,,390,16,CPPASTProblemDeclaration,,<empty>
607315,UNKNOWN,17,,};,1,<empty>,,391,17,CPPASTProblemDeclaration,,<empty>
607373,UNKNOWN,2,,"TEST_METHOD(Inequality)
    {
        til::some<int, 2> a{ 1, 2 };",5,<empty>,,47,2,CPPASTProblemDeclaration,,<empty>
607380,UNKNOWN,5,,VERIFY_IS_FALSE(a != b);,9,<empty>,,51,5,CPPASTProblemDeclaration,,<empty>
607387,UNKNOWN,8,,VERIFY_IS_TRUE(a != c);,9,<empty>,,54,8,CPPASTProblemDeclaration,,<empty>
607394,UNKNOWN,11,,VERIFY_IS_TRUE(a != d);,9,<empty>,,57,11,CPPASTProblemDeclaration,,<empty>
607400,UNKNOWN,14,,VERIFY_IS_TRUE(a != e);,9,<empty>,,60,14,CPPASTProblemDeclaration,,<empty>
607401,UNKNOWN,15,,},5,<empty>,,61,15,CPPASTProblemDeclaration,,<empty>
607402,UNKNOWN,16,,"TEST_METHOD(Fill)
    {
        til::some<int, 4> s;",5,<empty>,,63,16,CPPASTProblemDeclaration,,<empty>
607407,UNKNOWN,19,,s.fill(val);,9,<empty>,,68,19,CPPASTProblemDeclaration,,<empty>
607408,UNKNOWN,20,,"VERIFY_ARE_EQUAL(s.max_size(), s.size());",9,<empty>,,70,20,CPPASTProblemDeclaration,,<empty>
607409,UNKNOWN,21,,"for (const auto& i : s)
        {
            VERIFY_ARE_EQUAL(val, i);
        }",9,<empty>,,72,21,CPPASTProblemDeclaration,,<empty>
607410,UNKNOWN,22,,},5,<empty>,,76,22,CPPASTProblemDeclaration,,<empty>
607411,UNKNOWN,23,,"TEST_METHOD(Swap)
    {
        til::some<int, 4> a;",5,<empty>,,78,23,CPPASTProblemDeclaration,,<empty>
607417,UNKNOWN,27,,a.fill(900);,9,<empty>,,84,27,CPPASTProblemDeclaration,,<empty>
607422,UNKNOWN,30,,b.push_back(45);,9,<empty>,,87,30,CPPASTProblemDeclaration,,<empty>
607437,UNKNOWN,35,,a.swap(b);,9,<empty>,,92,35,CPPASTProblemDeclaration,,<empty>
607438,UNKNOWN,36,,"VERIFY_ARE_EQUAL(aSize, b.size());",9,<empty>,,94,36,CPPASTProblemDeclaration,,<empty>
607439,UNKNOWN,37,,"VERIFY_ARE_EQUAL(bSize, a.size());",9,<empty>,,95,37,CPPASTProblemDeclaration,,<empty>
607440,UNKNOWN,38,,"VERIFY_ARE_EQUAL(bVal, a[0]);",9,<empty>,,97,38,CPPASTProblemDeclaration,,<empty>
607441,UNKNOWN,39,,"for (const auto& i : b)
        {
            VERIFY_ARE_EQUAL(aVal, i);
        }",9,<empty>,,99,39,CPPASTProblemDeclaration,,<empty>
607442,UNKNOWN,40,,},5,<empty>,,103,40,CPPASTProblemDeclaration,,<empty>
607443,UNKNOWN,41,,"TEST_METHOD(Size)
    {
        til::some<int, 2> c;",5,<empty>,,105,41,CPPASTProblemDeclaration,,<empty>
607444,UNKNOWN,42,,"VERIFY_ARE_EQUAL(0u, c.size());",9,<empty>,,109,42,CPPASTProblemDeclaration,,<empty>
607445,UNKNOWN,43,,c.push_back(3);,9,<empty>,,111,43,CPPASTProblemDeclaration,,<empty>
607446,UNKNOWN,44,,"VERIFY_ARE_EQUAL(1u, c.size());",9,<empty>,,112,44,CPPASTProblemDeclaration,,<empty>
607447,UNKNOWN,45,,c.push_back(12);,9,<empty>,,114,45,CPPASTProblemDeclaration,,<empty>
607448,UNKNOWN,46,,"VERIFY_ARE_EQUAL(2u, c.size());",9,<empty>,,115,46,CPPASTProblemDeclaration,,<empty>
607449,UNKNOWN,47,,c.pop_back();,9,<empty>,,117,47,CPPASTProblemDeclaration,,<empty>
607450,UNKNOWN,48,,"VERIFY_ARE_EQUAL(1u, c.size());",9,<empty>,,118,48,CPPASTProblemDeclaration,,<empty>
607451,UNKNOWN,49,,c.pop_back();,9,<empty>,,120,49,CPPASTProblemDeclaration,,<empty>
607452,UNKNOWN,50,,"VERIFY_ARE_EQUAL(0u, c.size());",9,<empty>,,121,50,CPPASTProblemDeclaration,,<empty>
607453,UNKNOWN,51,,},5,<empty>,,122,51,CPPASTProblemDeclaration,,<empty>
607454,UNKNOWN,52,,"TEST_METHOD(MaxSize)
    {
        til::some<int, 2> c;",5,<empty>,,124,52,CPPASTProblemDeclaration,,<empty>
607455,UNKNOWN,53,,"VERIFY_ARE_EQUAL(2u, c.max_size());",9,<empty>,,128,53,CPPASTProblemDeclaration,,<empty>
607456,UNKNOWN,54,,c.push_back(3);,9,<empty>,,130,54,CPPASTProblemDeclaration,,<empty>
607457,UNKNOWN,55,,"VERIFY_ARE_EQUAL(2u, c.max_size());",9,<empty>,,131,55,CPPASTProblemDeclaration,,<empty>
607458,UNKNOWN,56,,c.push_back(12);,9,<empty>,,133,56,CPPASTProblemDeclaration,,<empty>
607459,UNKNOWN,57,,"VERIFY_ARE_EQUAL(2u, c.size());",9,<empty>,,134,57,CPPASTProblemDeclaration,,<empty>
607460,UNKNOWN,58,,c.pop_back();,9,<empty>,,136,58,CPPASTProblemDeclaration,,<empty>
607461,UNKNOWN,59,,"VERIFY_ARE_EQUAL(2u, c.max_size());",9,<empty>,,137,59,CPPASTProblemDeclaration,,<empty>
607462,UNKNOWN,60,,c.pop_back();,9,<empty>,,139,60,CPPASTProblemDeclaration,,<empty>
607463,UNKNOWN,61,,"VERIFY_ARE_EQUAL(2u, c.max_size());",9,<empty>,,140,61,CPPASTProblemDeclaration,,<empty>
607464,UNKNOWN,62,,},5,<empty>,,141,62,CPPASTProblemDeclaration,,<empty>
607465,UNKNOWN,63,,"TEST_METHOD(PushBack)
    {
        til::some<int, 1> s;",5,<empty>,,143,63,CPPASTProblemDeclaration,,<empty>
607466,UNKNOWN,64,,s.push_back(12);,9,<empty>,,146,64,CPPASTProblemDeclaration,,<empty>
607467,UNKNOWN,65,,"VERIFY_THROWS(s.push_back(12), std::out_of_range);",9,<empty>,,147,65,CPPASTProblemDeclaration,,<empty>
607468,UNKNOWN,66,,},5,<empty>,,148,66,CPPASTProblemDeclaration,,<empty>
607469,UNKNOWN,67,,"TEST_METHOD(PopBack)
    {
        til::some<int, 1> s;",5,<empty>,,150,67,CPPASTProblemDeclaration,,<empty>
607470,UNKNOWN,68,,"VERIFY_THROWS(s.pop_back(), std::out_of_range);",9,<empty>,,153,68,CPPASTProblemDeclaration,,<empty>
607471,UNKNOWN,69,,s.push_back(12);,9,<empty>,,155,69,CPPASTProblemDeclaration,,<empty>
607472,UNKNOWN,70,,"VERIFY_THROWS(s.push_back(12), std::out_of_range);",9,<empty>,,156,70,CPPASTProblemDeclaration,,<empty>
607473,UNKNOWN,71,,},5,<empty>,,157,71,CPPASTProblemDeclaration,,<empty>
607474,UNKNOWN,72,,"TEST_METHOD(Empty)
    {
        til::some<int, 2> s;",5,<empty>,,159,72,CPPASTProblemDeclaration,,<empty>
607475,UNKNOWN,73,,VERIFY_IS_TRUE(s.empty());,9,<empty>,,162,73,CPPASTProblemDeclaration,,<empty>
607476,UNKNOWN,74,,s.push_back(12);,9,<empty>,,163,74,CPPASTProblemDeclaration,,<empty>
607477,UNKNOWN,75,,VERIFY_IS_FALSE(s.empty());,9,<empty>,,164,75,CPPASTProblemDeclaration,,<empty>
607478,UNKNOWN,76,,s.pop_back();,9,<empty>,,165,76,CPPASTProblemDeclaration,,<empty>
607479,UNKNOWN,77,,VERIFY_IS_TRUE(s.empty());,9,<empty>,,166,77,CPPASTProblemDeclaration,,<empty>
607480,UNKNOWN,78,,},5,<empty>,,167,78,CPPASTProblemDeclaration,,<empty>
607481,UNKNOWN,79,,"TEST_METHOD(Clear)
    {
        til::some<int, 2> s;",5,<empty>,,169,79,CPPASTProblemDeclaration,,<empty>
607482,UNKNOWN,80,,VERIFY_IS_TRUE(s.empty());,9,<empty>,,172,80,CPPASTProblemDeclaration,,<empty>
607483,UNKNOWN,81,,s.push_back(12);,9,<empty>,,173,81,CPPASTProblemDeclaration,,<empty>
607484,UNKNOWN,82,,VERIFY_IS_FALSE(s.empty());,9,<empty>,,174,82,CPPASTProblemDeclaration,,<empty>
607485,UNKNOWN,83,,"VERIFY_ARE_EQUAL(1u, s.size());",9,<empty>,,175,83,CPPASTProblemDeclaration,,<empty>
607486,UNKNOWN,84,,s.clear();,9,<empty>,,176,84,CPPASTProblemDeclaration,,<empty>
607487,UNKNOWN,85,,VERIFY_IS_TRUE(s.empty());,9,<empty>,,177,85,CPPASTProblemDeclaration,,<empty>
607488,UNKNOWN,86,,"VERIFY_ARE_EQUAL(0u, s.size());",9,<empty>,,178,86,CPPASTProblemDeclaration,,<empty>
607489,UNKNOWN,87,,},5,<empty>,,179,87,CPPASTProblemDeclaration,,<empty>
607490,UNKNOWN,88,,"TEST_METHOD(ClearFreesMembers)
    {
        til::some<std::shared_ptr<int>, 2> s;",5,<empty>,,181,88,CPPASTProblemDeclaration,,<empty>
607523,UNKNOWN,97,,s.push_back(std::move(a));,9,<empty>,,191,97,CPPASTProblemDeclaration,,<empty>
607524,UNKNOWN,98,,s.push_back(std::move(b));,9,<empty>,,192,98,CPPASTProblemDeclaration,,<empty>
607525,UNKNOWN,99,,VERIFY_IS_FALSE(weakA.expired());,9,<empty>,,194,99,CPPASTProblemDeclaration,,<empty>
607526,UNKNOWN,100,,VERIFY_IS_FALSE(weakB.expired());,9,<empty>,,195,100,CPPASTProblemDeclaration,,<empty>
607527,UNKNOWN,101,,s.clear();,9,<empty>,,197,101,CPPASTProblemDeclaration,,<empty>
607528,UNKNOWN,102,,VERIFY_IS_TRUE(weakA.expired());,9,<empty>,,199,102,CPPASTProblemDeclaration,,<empty>
607529,UNKNOWN,103,,VERIFY_IS_TRUE(weakB.expired());,9,<empty>,,200,103,CPPASTProblemDeclaration,,<empty>
607530,UNKNOWN,104,,},5,<empty>,,201,104,CPPASTProblemDeclaration,,<empty>
607531,UNKNOWN,105,,"TEST_METHOD(Data)
    {
        til::some<int, 2> s;",5,<empty>,,203,105,CPPASTProblemDeclaration,,<empty>
607540,UNKNOWN,110,,s.push_back(one);,9,<empty>,,208,110,CPPASTProblemDeclaration,,<empty>
607541,UNKNOWN,111,,s.push_back(two);,9,<empty>,,209,111,CPPASTProblemDeclaration,,<empty>
607549,UNKNOWN,114,,"VERIFY_ARE_EQUAL(one, *data);",9,<empty>,,213,114,CPPASTProblemDeclaration,,<empty>
607550,UNKNOWN,115,,"VERIFY_ARE_EQUAL(two, *(data + 1));",9,<empty>,,214,115,CPPASTProblemDeclaration,,<empty>
607551,UNKNOWN,116,,},5,<empty>,,215,116,CPPASTProblemDeclaration,,<empty>
607552,UNKNOWN,117,,"TEST_METHOD(FrontBack)
    {
        til::some<int, 2> s;",5,<empty>,,217,117,CPPASTProblemDeclaration,,<empty>
607561,UNKNOWN,122,,s.push_back(one);,9,<empty>,,222,122,CPPASTProblemDeclaration,,<empty>
607562,UNKNOWN,123,,s.push_back(two);,9,<empty>,,223,123,CPPASTProblemDeclaration,,<empty>
607563,UNKNOWN,124,,"VERIFY_ARE_EQUAL(one, s.front());",9,<empty>,,225,124,CPPASTProblemDeclaration,,<empty>
607564,UNKNOWN,125,,"VERIFY_ARE_EQUAL(two, s.back());",9,<empty>,,226,125,CPPASTProblemDeclaration,,<empty>
607565,UNKNOWN,126,,},5,<empty>,,227,126,CPPASTProblemDeclaration,,<empty>
607566,UNKNOWN,127,,"TEST_METHOD(Indexing)
    {
        const auto one = 14;",5,<empty>,,229,127,CPPASTProblemDeclaration,,<empty>
607572,UNKNOWN,131,,"VERIFY_THROWS(s.at(0), std::out_of_range);",9,<empty>,,235,131,CPPASTProblemDeclaration,,<empty>
607573,UNKNOWN,132,,"VERIFY_THROWS(s.at(1), std::out_of_range);",9,<empty>,,236,132,CPPASTProblemDeclaration,,<empty>
607580,UNKNOWN,135,,a = s[1];,9,<empty>,,238,135,CPPASTProblemDeclaration,,<empty>
607581,UNKNOWN,136,,s.push_back(one);,9,<empty>,,240,136,CPPASTProblemDeclaration,,<empty>
607582,UNKNOWN,137,,"VERIFY_ARE_EQUAL(one, s.at(0));",9,<empty>,,241,137,CPPASTProblemDeclaration,,<empty>
607583,UNKNOWN,138,,"VERIFY_ARE_EQUAL(one, s[0]);",9,<empty>,,242,138,CPPASTProblemDeclaration,,<empty>
607584,UNKNOWN,139,,"VERIFY_THROWS(s.at(1), std::out_of_range);",9,<empty>,,243,139,CPPASTProblemDeclaration,,<empty>
607585,UNKNOWN,140,,a = s[1];,9,<empty>,,244,140,CPPASTProblemDeclaration,,<empty>
607586,UNKNOWN,141,,s.push_back(two);,9,<empty>,,246,141,CPPASTProblemDeclaration,,<empty>
607587,UNKNOWN,142,,"VERIFY_ARE_EQUAL(one, s.at(0));",9,<empty>,,247,142,CPPASTProblemDeclaration,,<empty>
607588,UNKNOWN,143,,"VERIFY_ARE_EQUAL(one, s[0]);",9,<empty>,,248,143,CPPASTProblemDeclaration,,<empty>
607589,UNKNOWN,144,,"VERIFY_ARE_EQUAL(two, s.at(1));",9,<empty>,,249,144,CPPASTProblemDeclaration,,<empty>
607590,UNKNOWN,145,,"VERIFY_ARE_EQUAL(two, s[1]);",9,<empty>,,250,145,CPPASTProblemDeclaration,,<empty>
607591,UNKNOWN,146,,s.pop_back();,9,<empty>,,252,146,CPPASTProblemDeclaration,,<empty>
607592,UNKNOWN,147,,"VERIFY_ARE_EQUAL(one, s.at(0));",9,<empty>,,253,147,CPPASTProblemDeclaration,,<empty>
607593,UNKNOWN,148,,"VERIFY_ARE_EQUAL(one, s[0]);",9,<empty>,,254,148,CPPASTProblemDeclaration,,<empty>
607594,UNKNOWN,149,,"VERIFY_THROWS(s.at(1), std::out_of_range);",9,<empty>,,255,149,CPPASTProblemDeclaration,,<empty>
607595,UNKNOWN,150,,a = s[1];,9,<empty>,,256,150,CPPASTProblemDeclaration,,<empty>
607596,UNKNOWN,151,,s.pop_back();,9,<empty>,,258,151,CPPASTProblemDeclaration,,<empty>
607597,UNKNOWN,152,,"VERIFY_THROWS(s.at(0), std::out_of_range);",9,<empty>,,259,152,CPPASTProblemDeclaration,,<empty>
607598,UNKNOWN,153,,"VERIFY_THROWS(s.at(1), std::out_of_range);",9,<empty>,,260,153,CPPASTProblemDeclaration,,<empty>
607599,UNKNOWN,154,,a = s[0];,9,<empty>,,261,154,CPPASTProblemDeclaration,,<empty>
607600,UNKNOWN,155,,a = s[1];,9,<empty>,,262,155,CPPASTProblemDeclaration,,<empty>
607601,UNKNOWN,156,,},5,<empty>,,263,156,CPPASTProblemDeclaration,,<empty>
607602,UNKNOWN,157,,"TEST_METHOD(ForwardIter)
    {
        const int vals[] = { 17, 99 };",5,<empty>,,265,157,CPPASTProblemDeclaration,,<empty>
607609,UNKNOWN,161,,"VERIFY_ARE_EQUAL(s.begin(), s.end());",9,<empty>,,271,161,CPPASTProblemDeclaration,,<empty>
607610,UNKNOWN,162,,"VERIFY_ARE_EQUAL(s.cbegin(), s.cend());",9,<empty>,,272,162,CPPASTProblemDeclaration,,<empty>
607611,UNKNOWN,163,,"VERIFY_ARE_EQUAL(s.begin(), s.cbegin());",9,<empty>,,273,163,CPPASTProblemDeclaration,,<empty>
607612,UNKNOWN,164,,"VERIFY_ARE_EQUAL(s.end(), s.cend());",9,<empty>,,274,164,CPPASTProblemDeclaration,,<empty>
607613,UNKNOWN,165,,s.push_back(vals[0]);,9,<empty>,,276,165,CPPASTProblemDeclaration,,<empty>
607614,UNKNOWN,166,,s.push_back(vals[1]);,9,<empty>,,277,166,CPPASTProblemDeclaration,,<empty>
607615,UNKNOWN,167,,"VERIFY_ARE_EQUAL(s.begin() + valLength, s.end());",9,<empty>,,279,167,CPPASTProblemDeclaration,,<empty>
607616,UNKNOWN,168,,"VERIFY_ARE_EQUAL(s.cbegin() + valLength, s.cend());",9,<empty>,,280,168,CPPASTProblemDeclaration,,<empty>
607621,UNKNOWN,171,,"for (const auto& i : s)
        {
            VERIFY_ARE_EQUAL(vals[count], i);
            ++count;
        }",9,<empty>,,283,171,CPPASTProblemDeclaration,,<empty>
607622,UNKNOWN,172,,"VERIFY_ARE_EQUAL(valLength, count);",9,<empty>,,288,172,CPPASTProblemDeclaration,,<empty>
607623,UNKNOWN,173,,count = 0;,9,<empty>,,290,173,CPPASTProblemDeclaration,,<empty>
607624,UNKNOWN,174,,for (auto i = s.cbegin();,9,<empty>,,291,174,CPPASTProblemDeclaration,,<empty>
607625,UNKNOWN,175,,i < s.cend();,35,<empty>,,291,175,CPPASTProblemDeclaration,,<empty>
607626,UNKNOWN,176,,"++i)
        {
            VERIFY_ARE_EQUAL(vals[count], *i);
            ++count;
        }",49,<empty>,,291,176,CPPASTProblemDeclaration,,<empty>
607627,UNKNOWN,177,,"VERIFY_ARE_EQUAL(valLength, count);",9,<empty>,,296,177,CPPASTProblemDeclaration,,<empty>
607628,UNKNOWN,178,,count = 0;,9,<empty>,,298,178,CPPASTProblemDeclaration,,<empty>
607629,UNKNOWN,179,,for (auto i = s.begin();,9,<empty>,,299,179,CPPASTProblemDeclaration,,<empty>
607630,UNKNOWN,180,,i < s.end();,34,<empty>,,299,180,CPPASTProblemDeclaration,,<empty>
607631,UNKNOWN,181,,"++i)
        {
            VERIFY_ARE_EQUAL(vals[count], *i);
            ++count;
        }",47,<empty>,,299,181,CPPASTProblemDeclaration,,<empty>
607632,UNKNOWN,182,,"VERIFY_ARE_EQUAL(valLength, count);",9,<empty>,,304,182,CPPASTProblemDeclaration,,<empty>
607633,UNKNOWN,183,,},5,<empty>,,305,183,CPPASTProblemDeclaration,,<empty>
607634,UNKNOWN,184,,"TEST_METHOD(ReverseIter)
    {
        const int vals[] = { 17, 99 };",5,<empty>,,307,184,CPPASTProblemDeclaration,,<empty>
607641,UNKNOWN,188,,"VERIFY_ARE_EQUAL(s.rbegin(), s.rend());",9,<empty>,,313,188,CPPASTProblemDeclaration,,<empty>
607642,UNKNOWN,189,,"VERIFY_ARE_EQUAL(s.crbegin(), s.crend());",9,<empty>,,314,189,CPPASTProblemDeclaration,,<empty>
607643,UNKNOWN,190,,"VERIFY_ARE_EQUAL(s.rbegin(), s.crbegin());",9,<empty>,,315,190,CPPASTProblemDeclaration,,<empty>
607644,UNKNOWN,191,,"VERIFY_ARE_EQUAL(s.rend(), s.crend());",9,<empty>,,316,191,CPPASTProblemDeclaration,,<empty>
607645,UNKNOWN,192,,s.push_back(vals[0]);,9,<empty>,,318,192,CPPASTProblemDeclaration,,<empty>
607646,UNKNOWN,193,,s.push_back(vals[1]);,9,<empty>,,319,193,CPPASTProblemDeclaration,,<empty>
607647,UNKNOWN,194,,"VERIFY_ARE_EQUAL(s.rbegin() + valLength, s.rend());",9,<empty>,,321,194,CPPASTProblemDeclaration,,<empty>
607648,UNKNOWN,195,,"VERIFY_ARE_EQUAL(s.crbegin() + valLength, s.crend());",9,<empty>,,322,195,CPPASTProblemDeclaration,,<empty>
607653,UNKNOWN,198,,for (auto i = s.crbegin();,9,<empty>,,325,198,CPPASTProblemDeclaration,,<empty>
607654,UNKNOWN,199,,i < s.crend();,36,<empty>,,325,199,CPPASTProblemDeclaration,,<empty>
607655,UNKNOWN,200,,"++i)
        {
            VERIFY_ARE_EQUAL(vals[valLength - count - 1], *i);
            ++count;
        }",51,<empty>,,325,200,CPPASTProblemDeclaration,,<empty>
607656,UNKNOWN,201,,"VERIFY_ARE_EQUAL(valLength, count);",9,<empty>,,330,201,CPPASTProblemDeclaration,,<empty>
607657,UNKNOWN,202,,count = 0;,9,<empty>,,332,202,CPPASTProblemDeclaration,,<empty>
607658,UNKNOWN,203,,for (auto i = s.rbegin();,9,<empty>,,333,203,CPPASTProblemDeclaration,,<empty>
607659,UNKNOWN,204,,i < s.rend();,35,<empty>,,333,204,CPPASTProblemDeclaration,,<empty>
607660,UNKNOWN,205,,"++i)
        {
            VERIFY_ARE_EQUAL(vals[valLength - count - 1], *i);
            ++count;
        }",49,<empty>,,333,205,CPPASTProblemDeclaration,,<empty>
607661,UNKNOWN,206,,"VERIFY_ARE_EQUAL(valLength, count);",9,<empty>,,338,206,CPPASTProblemDeclaration,,<empty>
607662,UNKNOWN,207,,},5,<empty>,,339,207,CPPASTProblemDeclaration,,<empty>
607663,UNKNOWN,208,,};,1,<empty>,,340,208,CPPASTProblemDeclaration,,<empty>
607741,UNKNOWN,2,,"TEST_METHOD(StringViewKeys)
    {
        // We have to use the string view literal type here, as leaving the strings unviewed
        // will result in a static_map<const char *, ...>
        // Deduction guides are only applied when *no* template arguments are specified,
        // which means we would need to specify them all, including the comparator and number of entries.
        til::static_map stringIntMap{
            std::pair{ ""xylophones""sv, 100 },
            std::pair{ ""apples""sv, 200 },
            std::pair{ ""grapes""sv, 300 },
            std::pair{ ""pears""sv, 400 },
        };",5,<empty>,,52,2,CPPASTProblemDeclaration,,<empty>
607742,UNKNOWN,3,,"VERIFY_ARE_EQUAL(100, stringIntMap.at(""xylophones""));",9,<empty>,,65,3,CPPASTProblemDeclaration,,<empty>
607743,UNKNOWN,4,,"VERIFY_ARE_EQUAL(300, stringIntMap.at(""grapes""));",9,<empty>,,66,4,CPPASTProblemDeclaration,,<empty>
607744,UNKNOWN,5,,"VERIFY_ARE_EQUAL(400, stringIntMap.at(""pears""));",9,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
607745,UNKNOWN,6,,"VERIFY_ARE_EQUAL(200, stringIntMap.at(""apples""));",9,<empty>,,68,6,CPPASTProblemDeclaration,,<empty>
607750,UNKNOWN,9,,"VERIFY_THROWS(unused = stringIntMap.at(""0_hello""), std::runtime_error);",9,<empty>,,71,9,CPPASTProblemDeclaration,,<empty>
607751,UNKNOWN,10,,"VERIFY_THROWS(unused = stringIntMap.at(""z_world""), std::runtime_error);",9,<empty>,,72,10,CPPASTProblemDeclaration,,<empty>
607752,UNKNOWN,11,,},5,<empty>,,73,11,CPPASTProblemDeclaration,,<empty>
607753,UNKNOWN,12,,"TEST_METHOD(Find)
    {
        til::static_map intIntMap{
            std::pair{ 5, 500 },
        };",5,<empty>,,75,12,CPPASTProblemDeclaration,,<empty>
607754,UNKNOWN,13,,"VERIFY_ARE_NOT_EQUAL(intIntMap.end(), intIntMap.find(5));",9,<empty>,,81,13,CPPASTProblemDeclaration,,<empty>
607755,UNKNOWN,14,,"VERIFY_ARE_EQUAL(intIntMap.end(), intIntMap.find(7));",9,<empty>,,82,14,CPPASTProblemDeclaration,,<empty>
607756,UNKNOWN,15,,},5,<empty>,,83,15,CPPASTProblemDeclaration,,<empty>
607757,UNKNOWN,16,,"TEST_METHOD(Subscript)
    {
        til::static_map intIntMap{
            std::pair{ 5, 500 },
        };",5,<empty>,,87,16,CPPASTProblemDeclaration,,<empty>
607758,UNKNOWN,17,,"VERIFY_ARE_EQUAL(500, intIntMap[5]);",9,<empty>,,93,17,CPPASTProblemDeclaration,,<empty>
607763,UNKNOWN,20,,"VERIFY_THROWS(unused = intIntMap[7], std::runtime_error);",9,<empty>,,95,20,CPPASTProblemDeclaration,,<empty>
607764,UNKNOWN,21,,},5,<empty>,,96,21,CPPASTProblemDeclaration,,<empty>
607765,UNKNOWN,22,,"TEST_METHOD(Presort)
    {
        static constexpr til::presorted_static_map intIntMap{
            std::pair{ 1, 100 },
            std::pair{ 3, 300 },
            std::pair{ 5, 500 },
        };",5,<empty>,,99,22,CPPASTProblemDeclaration,,<empty>
607766,UNKNOWN,23,,"VERIFY_ARE_EQUAL(100, intIntMap.at(1));",9,<empty>,,107,23,CPPASTProblemDeclaration,,<empty>
607767,UNKNOWN,24,,"VERIFY_ARE_EQUAL(300, intIntMap.at(3));",9,<empty>,,108,24,CPPASTProblemDeclaration,,<empty>
607768,UNKNOWN,25,,"VERIFY_ARE_EQUAL(500, intIntMap.at(5));",9,<empty>,,109,25,CPPASTProblemDeclaration,,<empty>
607773,UNKNOWN,28,,"VERIFY_THROWS(unused = intIntMap.at(0), std::runtime_error);",9,<empty>,,112,28,CPPASTProblemDeclaration,,<empty>
607774,UNKNOWN,29,,"VERIFY_THROWS(unused = intIntMap.at(4), std::runtime_error);",9,<empty>,,113,29,CPPASTProblemDeclaration,,<empty>
607775,UNKNOWN,30,,"VERIFY_THROWS(unused = intIntMap.at(7), std::runtime_error);",9,<empty>,,114,30,CPPASTProblemDeclaration,,<empty>
607776,UNKNOWN,31,,"VERIFY_ARE_EQUAL(500, intIntMap[5]);",9,<empty>,,118,31,CPPASTProblemDeclaration,,<empty>
607777,UNKNOWN,32,,"VERIFY_THROWS(unused = intIntMap[4], std::runtime_error);",9,<empty>,,119,32,CPPASTProblemDeclaration,,<empty>
607778,UNKNOWN,33,,"VERIFY_THROWS(unused = intIntMap[7], std::runtime_error);",9,<empty>,,120,33,CPPASTProblemDeclaration,,<empty>
607779,UNKNOWN,34,,},5,<empty>,,122,34,CPPASTProblemDeclaration,,<empty>
607780,UNKNOWN,35,,};,1,<empty>,,123,35,CPPASTProblemDeclaration,,<empty>
607922,UNKNOWN,2,,};,1,<empty>,,82,2,CPPASTProblemDeclaration,,<empty>
607934,UNKNOWN,-1,,),32,<empty>,,14,2,CPPASTProblemDeclaration,,<empty>
607935,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:10"") // 10s timeout
    END_TEST_CLASS()

    TEST_METHOD(Basic)
    {
        struct TestData
        {
            int foo;
            int bar;
        };

        const til::shared_mutex<TestData> mutex{ TestData{ 1, 2 } };

        {
            auto lock = mutex.lock();
            *lock = TestData{ 3, 4 };
            lock->foo = 5;
        }

        {
            auto lock1 = mutex.lock_shared();
            auto lock2 = mutex.lock_shared();

            VERIFY_ARE_EQUAL(5, lock1->foo);
            VERIFY_ARE_EQUAL(4, lock2->bar);
        }

        // This is here just to ensure that the prior
        // .lock_shared() properly unlocked the mutex.
        auto lock = mutex.lock();
    }",9,<empty>,,15,3,CPPASTProblemDeclaration,,<empty>
608025,UNKNOWN,2,,"TEST_METHOD(ends_with)
    {
        VERIFY_IS_TRUE(til::ends_with("""", """"));",5,<empty>,,39,2,CPPASTProblemDeclaration,,<empty>
608026,UNKNOWN,3,,"VERIFY_IS_TRUE(til::ends_with(""abc"", """"));",9,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
608027,UNKNOWN,4,,"VERIFY_IS_TRUE(til::ends_with(""abc"", ""c""));",9,<empty>,,44,4,CPPASTProblemDeclaration,,<empty>
608028,UNKNOWN,5,,"VERIFY_IS_TRUE(til::ends_with(""abc"", ""bc""));",9,<empty>,,45,5,CPPASTProblemDeclaration,,<empty>
608029,UNKNOWN,6,,"VERIFY_IS_TRUE(til::ends_with(""abc"", ""abc""));",9,<empty>,,46,6,CPPASTProblemDeclaration,,<empty>
608030,UNKNOWN,7,,"VERIFY_IS_FALSE(til::ends_with(""abc"", ""0abc""));",9,<empty>,,47,7,CPPASTProblemDeclaration,,<empty>
608031,UNKNOWN,8,,"VERIFY_IS_FALSE(til::ends_with("""", ""abc""));",9,<empty>,,49,8,CPPASTProblemDeclaration,,<empty>
608032,UNKNOWN,9,,"VERIFY_IS_FALSE(til::ends_with(""c"", ""abc""));",9,<empty>,,50,9,CPPASTProblemDeclaration,,<empty>
608033,UNKNOWN,10,,"VERIFY_IS_FALSE(til::ends_with(""bc"", ""abc""));",9,<empty>,,51,10,CPPASTProblemDeclaration,,<empty>
608034,UNKNOWN,11,,"VERIFY_IS_TRUE(til::ends_with(""abc"", ""abc""));",9,<empty>,,52,11,CPPASTProblemDeclaration,,<empty>
608035,UNKNOWN,12,,"VERIFY_IS_TRUE(til::ends_with(""0abc"", ""abc""));",9,<empty>,,53,12,CPPASTProblemDeclaration,,<empty>
608036,UNKNOWN,13,,},5,<empty>,,54,13,CPPASTProblemDeclaration,,<empty>
608037,UNKNOWN,14,,"TEST_METHOD(tolower_ascii)
    {
        for (wchar_t ch = 0;",5,<empty>,,106,14,CPPASTProblemDeclaration,,<empty>
608038,UNKNOWN,15,,ch < 128;,30,<empty>,,108,15,CPPASTProblemDeclaration,,<empty>
608039,UNKNOWN,16,,"++ch)
        {
            VERIFY_ARE_EQUAL(std::towlower(ch), til::tolower_ascii(ch));
        }",40,<empty>,,108,16,CPPASTProblemDeclaration,,<empty>
608040,UNKNOWN,17,,},5,<empty>,,112,17,CPPASTProblemDeclaration,,<empty>
608041,UNKNOWN,18,,"TEST_METHOD(toupper_ascii)
    {
        for (wchar_t ch = 0;",5,<empty>,,114,18,CPPASTProblemDeclaration,,<empty>
608042,UNKNOWN,19,,ch < 128;,30,<empty>,,116,19,CPPASTProblemDeclaration,,<empty>
608043,UNKNOWN,20,,"++ch)
        {
            VERIFY_ARE_EQUAL(std::towupper(ch), til::toupper_ascii(ch));
        }",40,<empty>,,116,20,CPPASTProblemDeclaration,,<empty>
608044,UNKNOWN,21,,},5,<empty>,,120,21,CPPASTProblemDeclaration,,<empty>
608045,UNKNOWN,22,,"TEST_METHOD(equals_insensitive_ascii)
    {
        VERIFY_IS_TRUE(til::equals_insensitive_ascii("""", """"));",5,<empty>,,122,22,CPPASTProblemDeclaration,,<empty>
608046,UNKNOWN,23,,"VERIFY_IS_FALSE(til::equals_insensitive_ascii("""", ""foo""));",9,<empty>,,125,23,CPPASTProblemDeclaration,,<empty>
608047,UNKNOWN,24,,"VERIFY_IS_FALSE(til::equals_insensitive_ascii(""foo"", ""fo""));",9,<empty>,,126,24,CPPASTProblemDeclaration,,<empty>
608048,UNKNOWN,25,,"VERIFY_IS_FALSE(til::equals_insensitive_ascii(""fooo"", ""foo""));",9,<empty>,,127,25,CPPASTProblemDeclaration,,<empty>
608049,UNKNOWN,26,,"VERIFY_IS_TRUE(til::equals_insensitive_ascii(""cOUnterStriKE"", ""COuntERStRike""));",9,<empty>,,128,26,CPPASTProblemDeclaration,,<empty>
608050,UNKNOWN,27,,},5,<empty>,,129,27,CPPASTProblemDeclaration,,<empty>
608051,UNKNOWN,28,,"TEST_METHOD(prefix_split)
    {
        {
            std::string_view s{ """" };",5,<empty>,,131,28,CPPASTProblemDeclaration,,<empty>
608052,UNKNOWN,29,,"VERIFY_ARE_EQUAL("""", til::prefix_split(s, """"));",13,<empty>,,135,29,CPPASTProblemDeclaration,,<empty>
608053,UNKNOWN,30,,"VERIFY_ARE_EQUAL("""", s);",13,<empty>,,136,30,CPPASTProblemDeclaration,,<empty>
608054,UNKNOWN,31,,},9,<empty>,,137,31,CPPASTProblemDeclaration,,<empty>
608055,UNKNOWN,32,,"{
            std::string_view s{ """" };
            VERIFY_ARE_EQUAL("""", til::prefix_split(s, "" ""));
            VERIFY_ARE_EQUAL("""", s);
        }",9,<empty>,,138,32,CPPASTProblemDeclaration,,<empty>
608056,UNKNOWN,33,,"{
            std::string_view s{ "" "" };
            VERIFY_ARE_EQUAL("" "", til::prefix_split(s, """"));
            VERIFY_ARE_EQUAL("""", s);
        }",9,<empty>,,143,33,CPPASTProblemDeclaration,,<empty>
608057,UNKNOWN,34,,"{
            std::string_view s{ ""foo"" };
            VERIFY_ARE_EQUAL(""foo"", til::prefix_split(s, """"));
            VERIFY_ARE_EQUAL("""", s);
        }",9,<empty>,,148,34,CPPASTProblemDeclaration,,<empty>
608058,UNKNOWN,35,,"{
            std::string_view s{ ""foo bar baz"" };
            VERIFY_ARE_EQUAL(""foo"", til::prefix_split(s, "" ""));
            VERIFY_ARE_EQUAL(""bar baz"", s);
            VERIFY_ARE_EQUAL(""bar"", til::prefix_split(s, "" ""));
            VERIFY_ARE_EQUAL(""baz"", s);
            VERIFY_ARE_EQUAL(""baz"", til::prefix_split(s, "" ""));
            VERIFY_ARE_EQUAL("""", s);
        }",9,<empty>,,153,35,CPPASTProblemDeclaration,,<empty>
608059,UNKNOWN,36,,"{
            std::string_view s{ ""foo123barbaz123"" };
            VERIFY_ARE_EQUAL(""foo"", til::prefix_split(s, ""123""));
            VERIFY_ARE_EQUAL(""barbaz123"", s);
            VERIFY_ARE_EQUAL(""barbaz"", til::prefix_split(s, ""123""));
            VERIFY_ARE_EQUAL("""", s);
            VERIFY_ARE_EQUAL("""", til::prefix_split(s, """"));
            VERIFY_ARE_EQUAL("""", s);
        }",9,<empty>,,162,36,CPPASTProblemDeclaration,,<empty>
608060,UNKNOWN,37,,},5,<empty>,,171,37,CPPASTProblemDeclaration,,<empty>
608061,UNKNOWN,38,,"TEST_METHOD(CleanPathAndFilename)
    {
        VERIFY_ARE_EQUAL(LR""(CUsersGeddyMusicAnalog Man)"", til::clean_filename(LR""(C:\Users\Geddy\Music\""Analog Man"")""));",5,<empty>,,173,38,CPPASTProblemDeclaration,,<empty>
608062,UNKNOWN,39,,"VERIFY_ARE_EQUAL(LR""(C:\Users\Geddy\Music\Analog Man)"", til::clean_path(LR""(C:\Users\Geddy\Music\""Analog Man"")""));",9,<empty>,,176,39,CPPASTProblemDeclaration,,<empty>
608063,UNKNOWN,40,,},5,<empty>,,177,40,CPPASTProblemDeclaration,,<empty>
608064,UNKNOWN,41,,"TEST_METHOD(LegalPath)
    {
        VERIFY_IS_TRUE(til::is_legal_path(LR""(C:\Users\Documents and Settings\Users\;\Why not)""));",5,<empty>,,179,41,CPPASTProblemDeclaration,,<empty>
608065,UNKNOWN,42,,"VERIFY_IS_FALSE(til::is_legal_path(LR""(C:\Users\Documents and Settings\""Quote-un-quote users"")""));",9,<empty>,,182,42,CPPASTProblemDeclaration,,<empty>
608066,UNKNOWN,43,,},5,<empty>,,183,43,CPPASTProblemDeclaration,,<empty>
608067,UNKNOWN,44,,};,1,<empty>,,184,44,CPPASTProblemDeclaration,,<empty>
608081,UNKNOWN,-1,,),40,<empty>,,15,2,CPPASTProblemDeclaration,,<empty>
608082,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:10"") // 10s timeout
    END_TEST_CLASS()

    TEST_METHOD(Basic)
    {
        using namespace std::chrono_literals;
        using throttled_func = til::throttled_func_trailing<bool>;

        til::latch latch{ 2 };

        std::unique_ptr<throttled_func> tf;
        tf = std::make_unique<throttled_func>(10ms, [&](bool reschedule) {
            latch.count_down();

            // This will ensure that the callback is called even if we
            // invoke the throttled_func from inside the callback itself.
            if (reschedule)
            {
                tf->operator()(false);
            }
        });
        // This will ensure that the throttled_func invokes the callback in general.
        tf->operator()(true);

        latch.wait();
    }",9,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
608571,UNKNOWN,3,,static CONSOLE_SCREEN_BUFFER_INFOEX g_info{ .cbSize = sizeof(g_info),1,<empty>,,16,3,CPPASTProblemDeclaration,,<empty>
608572,UNKNOWN,4,,};,70,<empty>,,16,4,CPPASTProblemDeclaration,,<empty>
608601,UNKNOWN,-1,,"const LOGFONTW lf{
        .lfHeight = -MulDiv(10, dpi, 72),
        .lfWeight = FW_REGULAR,
        .lfCharSet = DEFAULT_CHARSET,
        .lfQuality = PROOF_QUALITY,
        .lfPitchAndFamily = FIXED_PITCH | FF_MODERN,
        .lfFaceName = L""Consolas"",",5,<empty>,,35,1,CPPASTProblemStatement,,<empty>
608604,UNKNOWN,15,,g_font = wil::unique_hfont{ CreateFontIndirectW(&lf) };,5,<empty>,,43,15,CPPASTProblemDeclaration,,<empty>
608605,UNKNOWN,16,,g_dpi = dpi;,5,<empty>,,44,16,CPPASTProblemDeclaration,,<empty>
608629,UNKNOWN,21,,"GetTextExtentPoint32W(dc.get(), L""0"", 1, &g_cellSize);",5,<empty>,,48,21,CPPASTProblemDeclaration,,<empty>
608630,UNKNOWN,22,,},1,<empty>,,49,22,CPPASTProblemDeclaration,,<empty>
608740,UNKNOWN,1,,size_t,37,<empty>,,73,1,CPPASTTypeId,,<empty>
608748,UNKNOWN,-1,,T,14,<empty>,,76,8,CPPASTProblemStatement,,<empty>
609099,UNKNOWN,1,,UINT,94,<empty>,,148,1,CPPASTTypeId,,<empty>
609165,UNKNOWN,1,,HBRUSH,49,<empty>,,157,1,CPPASTTypeId,,<empty>
609220,UNKNOWN,27,,"static void winMainImpl(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nShowCmd)
{
    if (!AttachConsole(ATTACH_PARENT_PROCESS))
    {
        MessageBoxW(nullptr, L""This application needs to be spawned from within a console session."", L""Failure"", MB_ICONWARNING | MB_OK);
        return;
    }

    const WNDCLASSEXW wc{
        .cbSize = sizeof(wc),
        .style = CS_OWNDC,
        .lpfnWndProc = WndProc,
        .hInstance = hInstance,
        .hCursor = LoadCursor(nullptr, IDC_ARROW),
        .lpszClassName = L""ConsoleMonitor"",
    };
    THROW_LAST_ERROR_IF(!RegisterClassExW(&wc));

    const wil::unique_hwnd hwnd{
        THROW_LAST_ERROR_IF_NULL(CreateWindowExW(
            0,
            wc.lpszClassName,
            L""ConsoleMonitor"",
            windowStyle,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            0,
            0,
            nullptr,
            nullptr,
            wc.hInstance,
            nullptr)...",1,<empty>,,183,27,CPPASTProblemDeclaration,,<empty>
609221,UNKNOWN,28,,"int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nShowCmd)
{
    try
    {
        winMainImpl(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
    }
    catch (const wil::ResultException& e)
    {
        wchar_t message[2048];
        wil::GetFailureLogString(&message[0], 2048, e.GetFailureInfo());
        MessageBoxW(nullptr, &message[0], L""Exception"", MB_ICONERROR | MB_OK);
    }
    catch (...)
    {
        LOG_CAUGHT_EXCEPTION();
    }

    return 0;
}",1,<empty>,,233,28,CPPASTProblemDeclaration,,<empty>
609701,UNKNOWN,1,,DWORD,39,<empty>,,12,1,CPPASTTypeId,,<empty>
609823,UNKNOWN,1,,DWORD,85,<empty>,,63,1,CPPASTTypeId,,<empty>
610574,UNKNOWN,-1,,"TYPED_EVENT(WindowActivated, winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable);",9,<empty>,,19,7,CPPASTProblemDeclaration,,<empty>
611011,UNKNOWN,1,,DWORD,69,<empty>,,91,1,CPPASTTypeId,,<empty>
611018,UNKNOWN,4,,"static void printfUTF16(_In_z_ _Printf_format_string_ wchar_t const* const format, ...)
{
    std::array<wchar_t, 128> buffer;

    va_list args;
    va_start(args, format);
    const auto length = _vsnwprintf_s(buffer.data(), buffer.size(), _TRUNCATE, format, args);
    va_end(args);

    assert(length >= 0);
    WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), buffer.data(), length, nullptr, nullptr);
}",1,<empty>,,96,4,CPPASTProblemDeclaration,,<empty>
611080,UNKNOWN,-1,,"static constexpr AttributeTest consoleAttributeTests[]{
                { L""Console attributes:"", 0 },
#define MAKE_TEST_FOR_ATTRIBUTE(attr) { L## #attr, attr }
                MAKE_TEST_FOR_ATTRIBUTE(COMMON_LVB_GRID_HORIZONTAL)",13,<empty>,,152,1,CPPASTProblemStatement,,<empty>
611081,UNKNOWN,-1,,",
                MAKE_TEST_FOR_ATTRIBUTE(COMMON_LVB_GRID_LVERTICAL)",68,<empty>,,155,2,CPPASTProblemStatement,,<empty>
611082,UNKNOWN,-1,,",
                MAKE_TEST_FOR_ATTRIBUTE(COMMON_LVB_GRID_RVERTICAL)",67,<empty>,,156,3,CPPASTProblemStatement,,<empty>
611083,UNKNOWN,-1,,",
                MAKE_TEST_FOR_ATTRIBUTE(COMMON_LVB_REVERSE_VIDEO)",67,<empty>,,157,4,CPPASTProblemStatement,,<empty>
611084,UNKNOWN,-1,,",
                MAKE_TEST_FOR_ATTRIBUTE(COMMON_LVB_UNDERSCORE)",66,<empty>,,158,5,CPPASTProblemStatement,,<empty>
611085,UNKNOWN,-1,,",
#undef MAKE_TEST_FOR_ATTRIBUTE
                { L""all gridlines"", COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL | COMMON_LVB_UNDERSCORE }",63,<empty>,,159,6,CPPASTProblemStatement,,<empty>
611086,UNKNOWN,-1,,",
                { L""all attributes"", COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL | COMMON_LVB_REVERSE_VIDEO | COMMON_LVB_UNDERSCORE }",145,<empty>,,161,7,CPPASTProblemStatement,,<empty>
611087,UNKNOWN,-1,,",",173,<empty>,,162,8,CPPASTProblemStatement,,<empty>
611100,UNKNOWN,1,,DWORD,49,<empty>,,168,1,CPPASTTypeId,,<empty>
611124,UNKNOWN,1,,WORD,65,<empty>,,172,1,CPPASTTypeId,,<empty>
611149,UNKNOWN,8,,"{
            static constexpr AttributeTest basicSGR[]{
                { L""bold"", 1 },
                { L""faint"", 2 },
                { L""italic"", 3 },
                { L""underline"", 4 },
                { L""reverse"", 7 },
                { L""strikethrough"", 9 },
                { L""double underline"", 21 },
                { L""overlined"", 53 },
            };

            printfUTF16(L""\x1B[3;39HANSI escape SGR:"");

            int row = 5;
            for (const auto& t : basicSGR)
            {
                printfUTF16(L""\x1B[%d;39H\x1b[%dm%s\x1b[m"", row, t.attribute, t.text);
                row += 2;
            }

            printfUTF16(L""\x1B[%d;39H\x1b]8;;https://example.com\x1b\\hyperlink\x1b]8;;\x1b\\"", row);
        }",9,<empty>,,181,8,CPPASTProblemDeclaration,,<empty>
611150,UNKNOWN,9,,"{
            static constexpr AttributeTest styledUnderlines[]{
                { L""straight"", 1 },
                { L""double"", 2 },
                { L""curly"", 3 },
                { L""dotted"", 4 },
                { L""dashed"", 5 },
            };

            printfUTF16(L""\x1B[3;63HStyled Underlines:"");

            int row = 5;
            for (const auto& t : styledUnderlines)
            {
                printfUTF16(L""\x1B[%d;63H\x1b[4:%dm"", row, t.attribute);

                const auto len = wcslen(t.text);
                for (size_t i = 0; i < len; ++i)
                {
                    const auto color = colorbrewer::pastel1[i % std::size(colorbrewer::pastel1)];
                    printfUTF16(L""\x1B[58:2::%d:%d:%dm%c"", (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff, t.text[i]);
                }

                printfUTF16(L""\x1b[m"");
                row += 2;
            }
        }",9,<empty>,,205,9,CPPASTProblemDeclaration,,<empty>
611151,UNKNOWN,10,,wait();,9,<empty>,,233,10,CPPASTProblemDeclaration,,<empty>
611152,UNKNOWN,11,,clear();,9,<empty>,,234,11,CPPASTProblemDeclaration,,<empty>
611153,UNKNOWN,12,,},5,<empty>,,235,12,CPPASTProblemDeclaration,,<empty>
611154,UNKNOWN,13,,"{
        printUTF16(
            L""\x1B[3;5HDECDWL Double Width \U0001FAE0 \x1B[45;92mA\u0353\u0353\x1B[m B\u036F\u036F""
            L""\x1B[4;3H\x1b#6DECDWL Double Width         \U0001FAE0 \x1B[45;92mA\u0353\u0353\x1B[m B\u036F\u036F""
            L""\x1B[7;5HDECDHL Double Height \U0001F952\U0001F6C1 A\u0353\u0353 \x1B[45;92mB\u036F\u036F\x1B[m \x1B[45;92mX\u0353\u0353\x1B[m Y\u036F\u036F""
            L""\x1B[8;3H\x1b#3DECDHL Double Height Top    \U0001F952 A\u0353\u0353 \x1B[45;92mB\u036F\u036F\x1B[m""
            L""\x1B[9;3H\x1b#4DECDHL Double Height Bottom \U0001F6C1 \x1B[45;92mX\u0353\u0353\x1B[m Y\u036F\u036F""
            L""\x1B[13;5H\x1b]8;;https://example.com\x1b\\DECDxL\x1b]8;;\x1b\\ <\x1B[45;92m!\x1B[m-- \x1B[3mitalic\x1b[m        \x1b[4munderline\x1b[m        \x1b[7mreverse\x1b[m""
            L""\x1B[15;5H\x1b]8;;https://example.com\x1b\\DECDxL\x1b]8;;\x1b\\ <\x1B[45;92m!\x1B[m-- \x1b[9mstrikethrough\x1b[m \x1b[21mdouble underline\x1b[m \x1b[53moverlined\x1b[m""
            L""\...",5,<empty>,,237,13,CPPASTProblemDeclaration,,<empty>
611155,UNKNOWN,14,,"{
        defer
        {
            // Setting an empty DRCS gets us back to the regular font.
            printUTF16(L""\x1bP1;1;2{ @\x1b\\"");
        };

        constexpr auto width = 14;
        const auto glyph =
            ""W   W         ""
            ""W   W         ""
            ""W W W         ""
            ""W W W         ""
            ""W W W         ""
            ""W W W  TTTTTTT""
            "" W W      T   ""
            ""          T   ""
            ""          T   ""
            ""          T   ""
            ""          T   ""
            ""          T   "";

        // Convert the above visual glyph to sixels
        wchar_t rows[2][width];
        for (int r = 0; r < 2; ++r)
        {
            const auto glyphData = &glyph[r * width * 6];

            for (int x = 0; x < width; ++x)
            {
                unsigned int accumulator = 0;
                for (int y = 5; y >= 0; --y)
                {
                    const auto isSet = glyphData[y * width + x] != ' ';
...",5,<empty>,,281,14,CPPASTProblemDeclaration,,<empty>
611156,UNKNOWN,15,,return 0;,5,<empty>,,354,15,CPPASTProblemDeclaration,,<empty>
611157,UNKNOWN,16,,},1,<empty>,,355,16,CPPASTProblemDeclaration,,<empty>
611281,UNKNOWN,1,,size_t,69,<empty>,,52,1,CPPASTTypeId,,<empty>
611583,UNKNOWN,1,,uint8_t,29,<empty>,,196,1,CPPASTTypeId,,<empty>
611593,UNKNOWN,1,,wchar_t,43,<empty>,,198,1,CPPASTTypeId,,<empty>
611608,UNKNOWN,1,,uint8_t,33,<empty>,,206,1,CPPASTTypeId,,<empty>
611614,UNKNOWN,1,,uint8_t,72,<empty>,,206,1,CPPASTTypeId,,<empty>
611634,UNKNOWN,1,,uint8_t,57,<empty>,,209,1,CPPASTTypeId,,<empty>
611642,UNKNOWN,1,,uint8_t,106,<empty>,,209,1,CPPASTTypeId,,<empty>
611657,UNKNOWN,1,,uint8_t,51,<empty>,,212,1,CPPASTTypeId,,<empty>
611664,UNKNOWN,1,,uint8_t,50,<empty>,,213,1,CPPASTTypeId,,<empty>
611684,UNKNOWN,1,,uint8_t,38,<empty>,,227,1,CPPASTTypeId,,<empty>
611690,UNKNOWN,1,,uint8_t,77,<empty>,,227,1,CPPASTTypeId,,<empty>
611714,UNKNOWN,1,,uint8_t,42,<empty>,,232,1,CPPASTTypeId,,<empty>
611720,UNKNOWN,1,,uint8_t,42,<empty>,,233,1,CPPASTTypeId,,<empty>
611728,UNKNOWN,1,,uint8_t,87,<empty>,,233,1,CPPASTTypeId,,<empty>
611739,UNKNOWN,1,,uint8_t,42,<empty>,,235,1,CPPASTTypeId,,<empty>
611745,UNKNOWN,1,,uint8_t,81,<empty>,,235,1,CPPASTTypeId,,<empty>
611751,UNKNOWN,1,,uint8_t,42,<empty>,,236,1,CPPASTTypeId,,<empty>
611759,UNKNOWN,1,,uint8_t,91,<empty>,,236,1,CPPASTTypeId,,<empty>
611769,UNKNOWN,1,,uint8_t,42,<empty>,,238,1,CPPASTTypeId,,<empty>
611775,UNKNOWN,1,,uint8_t,42,<empty>,,239,1,CPPASTTypeId,,<empty>
611783,UNKNOWN,1,,uint8_t,91,<empty>,,239,1,CPPASTTypeId,,<empty>
611794,UNKNOWN,1,,uint8_t,42,<empty>,,241,1,CPPASTTypeId,,<empty>
611800,UNKNOWN,1,,uint8_t,81,<empty>,,241,1,CPPASTTypeId,,<empty>
611806,UNKNOWN,1,,uint8_t,42,<empty>,,242,1,CPPASTTypeId,,<empty>
611814,UNKNOWN,1,,uint8_t,91,<empty>,,242,1,CPPASTTypeId,,<empty>
611833,UNKNOWN,1,,uint8_t,61,<empty>,,245,1,CPPASTTypeId,,<empty>
611841,UNKNOWN,1,,uint8_t,110,<empty>,,245,1,CPPASTTypeId,,<empty>
611857,UNKNOWN,1,,uint8_t,55,<empty>,,248,1,CPPASTTypeId,,<empty>
611865,UNKNOWN,1,,uint8_t,55,<empty>,,249,1,CPPASTTypeId,,<empty>
611874,UNKNOWN,1,,uint8_t,54,<empty>,,250,1,CPPASTTypeId,,<empty>
611897,UNKNOWN,1,,uint8_t,38,<empty>,,264,1,CPPASTTypeId,,<empty>
611903,UNKNOWN,1,,uint8_t,77,<empty>,,264,1,CPPASTTypeId,,<empty>
611926,UNKNOWN,1,,uint8_t,42,<empty>,,269,1,CPPASTTypeId,,<empty>
611932,UNKNOWN,1,,uint8_t,42,<empty>,,270,1,CPPASTTypeId,,<empty>
611940,UNKNOWN,1,,uint8_t,87,<empty>,,270,1,CPPASTTypeId,,<empty>
611951,UNKNOWN,1,,uint8_t,42,<empty>,,272,1,CPPASTTypeId,,<empty>
611957,UNKNOWN,1,,uint8_t,81,<empty>,,272,1,CPPASTTypeId,,<empty>
611963,UNKNOWN,1,,uint8_t,42,<empty>,,273,1,CPPASTTypeId,,<empty>
611971,UNKNOWN,1,,uint8_t,91,<empty>,,273,1,CPPASTTypeId,,<empty>
611981,UNKNOWN,1,,uint8_t,42,<empty>,,275,1,CPPASTTypeId,,<empty>
611987,UNKNOWN,1,,uint8_t,42,<empty>,,276,1,CPPASTTypeId,,<empty>
611995,UNKNOWN,1,,uint8_t,91,<empty>,,276,1,CPPASTTypeId,,<empty>
612014,UNKNOWN,1,,uint8_t,61,<empty>,,279,1,CPPASTTypeId,,<empty>
612022,UNKNOWN,1,,uint8_t,110,<empty>,,279,1,CPPASTTypeId,,<empty>
612041,UNKNOWN,1,,uint8_t,65,<empty>,,282,1,CPPASTTypeId,,<empty>
612049,UNKNOWN,1,,uint8_t,114,<empty>,,282,1,CPPASTTypeId,,<empty>
612066,UNKNOWN,1,,uint8_t,59,<empty>,,285,1,CPPASTTypeId,,<empty>
612074,UNKNOWN,1,,uint8_t,59,<empty>,,286,1,CPPASTTypeId,,<empty>
612084,UNKNOWN,1,,uint8_t,59,<empty>,,287,1,CPPASTTypeId,,<empty>
612093,UNKNOWN,1,,uint8_t,58,<empty>,,288,1,CPPASTTypeId,,<empty>
612135,UNKNOWN,1,,wchar_t,51,<empty>,,310,1,CPPASTTypeId,,<empty>
612147,UNKNOWN,1,,wchar_t,51,<empty>,,315,1,CPPASTTypeId,,<empty>
612160,UNKNOWN,1,,wchar_t,51,<empty>,,316,1,CPPASTTypeId,,<empty>
612259,UNKNOWN,1,,uint8_t,29,<empty>,,364,1,CPPASTTypeId,,<empty>
612269,UNKNOWN,1,,wchar_t,40,<empty>,,366,1,CPPASTTypeId,,<empty>
612284,UNKNOWN,1,,uint8_t,33,<empty>,,374,1,CPPASTTypeId,,<empty>
612290,UNKNOWN,1,,uint8_t,72,<empty>,,374,1,CPPASTTypeId,,<empty>
612310,UNKNOWN,1,,uint8_t,57,<empty>,,377,1,CPPASTTypeId,,<empty>
612318,UNKNOWN,1,,uint8_t,106,<empty>,,377,1,CPPASTTypeId,,<empty>
612333,UNKNOWN,1,,uint8_t,51,<empty>,,380,1,CPPASTTypeId,,<empty>
612340,UNKNOWN,1,,uint8_t,50,<empty>,,381,1,CPPASTTypeId,,<empty>
612360,UNKNOWN,1,,uint8_t,38,<empty>,,395,1,CPPASTTypeId,,<empty>
612366,UNKNOWN,1,,uint8_t,77,<empty>,,395,1,CPPASTTypeId,,<empty>
612390,UNKNOWN,1,,uint8_t,42,<empty>,,400,1,CPPASTTypeId,,<empty>
612396,UNKNOWN,1,,uint8_t,42,<empty>,,401,1,CPPASTTypeId,,<empty>
612404,UNKNOWN,1,,uint8_t,87,<empty>,,401,1,CPPASTTypeId,,<empty>
612415,UNKNOWN,1,,uint8_t,42,<empty>,,403,1,CPPASTTypeId,,<empty>
612421,UNKNOWN,1,,uint8_t,81,<empty>,,403,1,CPPASTTypeId,,<empty>
612427,UNKNOWN,1,,uint8_t,42,<empty>,,404,1,CPPASTTypeId,,<empty>
612435,UNKNOWN,1,,uint8_t,91,<empty>,,404,1,CPPASTTypeId,,<empty>
612445,UNKNOWN,1,,uint8_t,42,<empty>,,406,1,CPPASTTypeId,,<empty>
612451,UNKNOWN,1,,uint8_t,42,<empty>,,407,1,CPPASTTypeId,,<empty>
612459,UNKNOWN,1,,uint8_t,91,<empty>,,407,1,CPPASTTypeId,,<empty>
612470,UNKNOWN,1,,uint8_t,42,<empty>,,409,1,CPPASTTypeId,,<empty>
612476,UNKNOWN,1,,uint8_t,81,<empty>,,409,1,CPPASTTypeId,,<empty>
612482,UNKNOWN,1,,uint8_t,42,<empty>,,410,1,CPPASTTypeId,,<empty>
612490,UNKNOWN,1,,uint8_t,91,<empty>,,410,1,CPPASTTypeId,,<empty>
612509,UNKNOWN,1,,uint8_t,61,<empty>,,413,1,CPPASTTypeId,,<empty>
612517,UNKNOWN,1,,uint8_t,110,<empty>,,413,1,CPPASTTypeId,,<empty>
612533,UNKNOWN,1,,uint8_t,55,<empty>,,416,1,CPPASTTypeId,,<empty>
612541,UNKNOWN,1,,uint8_t,55,<empty>,,417,1,CPPASTTypeId,,<empty>
612550,UNKNOWN,1,,uint8_t,54,<empty>,,418,1,CPPASTTypeId,,<empty>
612573,UNKNOWN,1,,uint8_t,38,<empty>,,432,1,CPPASTTypeId,,<empty>
612579,UNKNOWN,1,,uint8_t,77,<empty>,,432,1,CPPASTTypeId,,<empty>
612602,UNKNOWN,1,,uint8_t,42,<empty>,,437,1,CPPASTTypeId,,<empty>
612608,UNKNOWN,1,,uint8_t,42,<empty>,,438,1,CPPASTTypeId,,<empty>
612616,UNKNOWN,1,,uint8_t,87,<empty>,,438,1,CPPASTTypeId,,<empty>
612627,UNKNOWN,1,,uint8_t,42,<empty>,,440,1,CPPASTTypeId,,<empty>
612633,UNKNOWN,1,,uint8_t,81,<empty>,,440,1,CPPASTTypeId,,<empty>
612639,UNKNOWN,1,,uint8_t,42,<empty>,,441,1,CPPASTTypeId,,<empty>
612647,UNKNOWN,1,,uint8_t,91,<empty>,,441,1,CPPASTTypeId,,<empty>
612657,UNKNOWN,1,,uint8_t,42,<empty>,,443,1,CPPASTTypeId,,<empty>
612663,UNKNOWN,1,,uint8_t,42,<empty>,,444,1,CPPASTTypeId,,<empty>
612671,UNKNOWN,1,,uint8_t,91,<empty>,,444,1,CPPASTTypeId,,<empty>
612690,UNKNOWN,1,,uint8_t,61,<empty>,,447,1,CPPASTTypeId,,<empty>
612698,UNKNOWN,1,,uint8_t,110,<empty>,,447,1,CPPASTTypeId,,<empty>
612717,UNKNOWN,1,,uint8_t,65,<empty>,,450,1,CPPASTTypeId,,<empty>
612725,UNKNOWN,1,,uint8_t,114,<empty>,,450,1,CPPASTTypeId,,<empty>
612742,UNKNOWN,1,,uint8_t,59,<empty>,,453,1,CPPASTTypeId,,<empty>
612750,UNKNOWN,1,,uint8_t,59,<empty>,,454,1,CPPASTTypeId,,<empty>
612760,UNKNOWN,1,,uint8_t,59,<empty>,,455,1,CPPASTTypeId,,<empty>
612769,UNKNOWN,1,,uint8_t,58,<empty>,,456,1,CPPASTTypeId,,<empty>
612811,UNKNOWN,1,,wchar_t,48,<empty>,,478,1,CPPASTTypeId,,<empty>
612823,UNKNOWN,1,,wchar_t,48,<empty>,,483,1,CPPASTTypeId,,<empty>
612836,UNKNOWN,1,,wchar_t,48,<empty>,,484,1,CPPASTTypeId,,<empty>
612847,UNKNOWN,1,,size_t,32,<empty>,,490,1,CPPASTTypeId,,<empty>
612908,UNKNOWN,1,,size_t,55,<empty>,,522,1,CPPASTTypeId,,<empty>
612965,UNKNOWN,1,,char,43,<empty>,,535,1,CPPASTTypeId,,<empty>
613020,UNKNOWN,1,,uint32_t,75,<empty>,,547,1,CPPASTTypeId,,<empty>
613070,UNKNOWN,1,,char,51,<empty>,,571,1,CPPASTTypeId,,<empty>
613083,UNKNOWN,1,,char,51,<empty>,,572,1,CPPASTTypeId,,<empty>
613101,UNKNOWN,1,,char,51,<empty>,,576,1,CPPASTTypeId,,<empty>
613114,UNKNOWN,1,,char,51,<empty>,,577,1,CPPASTTypeId,,<empty>
613127,UNKNOWN,1,,char,51,<empty>,,578,1,CPPASTTypeId,,<empty>
613140,UNKNOWN,1,,char,51,<empty>,,582,1,CPPASTTypeId,,<empty>
613153,UNKNOWN,1,,char,51,<empty>,,583,1,CPPASTTypeId,,<empty>
613166,UNKNOWN,1,,char,51,<empty>,,584,1,CPPASTTypeId,,<empty>
613179,UNKNOWN,1,,char,51,<empty>,,585,1,CPPASTTypeId,,<empty>
613239,UNKNOWN,1,,size_t,55,<empty>,,623,1,CPPASTTypeId,,<empty>
613292,UNKNOWN,1,,char,39,<empty>,,637,1,CPPASTTypeId,,<empty>
613347,UNKNOWN,1,,uint32_t,75,<empty>,,649,1,CPPASTTypeId,,<empty>
613397,UNKNOWN,1,,char,47,<empty>,,673,1,CPPASTTypeId,,<empty>
613410,UNKNOWN,1,,char,47,<empty>,,674,1,CPPASTTypeId,,<empty>
613428,UNKNOWN,1,,char,47,<empty>,,678,1,CPPASTTypeId,,<empty>
613441,UNKNOWN,1,,char,47,<empty>,,679,1,CPPASTTypeId,,<empty>
613454,UNKNOWN,1,,char,47,<empty>,,680,1,CPPASTTypeId,,<empty>
613467,UNKNOWN,1,,char,47,<empty>,,684,1,CPPASTTypeId,,<empty>
613480,UNKNOWN,1,,char,47,<empty>,,685,1,CPPASTTypeId,,<empty>
613493,UNKNOWN,1,,char,47,<empty>,,686,1,CPPASTTypeId,,<empty>
613506,UNKNOWN,1,,char,47,<empty>,,687,1,CPPASTTypeId,,<empty>
613517,UNKNOWN,1,,size_t,32,<empty>,,693,1,CPPASTTypeId,,<empty>
613955,UNKNOWN,1,,"typedef NTSTATUS(WINAPI* t_RtlUTF8ToUnicodeN)(PWSTR, ULONG, PULONG, PCCH, ULONG);",1,<empty>,,16,1,CPPASTProblemDeclaration,,<empty>
613956,UNKNOWN,2,,"typedef NTSTATUS(WINAPI* t_RtlUnicodeToUTF8N)(PCHAR, ULONG, PULONG, PCWSTR, ULONG);",1,<empty>,,17,2,CPPASTProblemDeclaration,,<empty>
613957,UNKNOWN,3,,"NTSTATUS(WINAPI* p_RtlUTF8ToUnicodeN)
(
    _Out_ PWSTR UnicodeStringDestination,
    _In_ ULONG UnicodeStringMaxByteCount,
    _Out_opt_ PULONG UnicodeStringActualByteCount,
    _In_ PCCH UTF8StringSource,
    _In_ ULONG UTF8StringByteCount){};",1,<empty>,,18,3,CPPASTProblemDeclaration,,<empty>
613958,UNKNOWN,4,,"NTSTATUS(WINAPI* p_RtlUnicodeToUTF8N)
(
    _Out_ PCHAR UTF8StringDestination,
    _In_ ULONG UTF8StringMaxByteCount,
    _Out_opt_ PULONG UTF8StringActualByteCount,
    _In_ PCWSTR UnicodeStringSource,
    _In_ ULONG UnicodeStringWCharCount){};",1,<empty>,,25,4,CPPASTProblemDeclaration,,<empty>
614004,UNKNOWN,1,,int,82,<empty>,,44,1,CPPASTTypeId,,<empty>
614015,UNKNOWN,1,,int,134,<empty>,,44,1,CPPASTTypeId,,<empty>
614034,UNKNOWN,1,,ptrdiff_t,61,<empty>,,46,1,CPPASTTypeId,,<empty>
614052,UNKNOWN,1,,int,47,<empty>,,48,1,CPPASTTypeId,,<empty>
614054,UNKNOWN,1,,unsigned char,64,<empty>,,48,1,CPPASTTypeId,,<empty>
614099,UNKNOWN,1,,ULONG,77,<empty>,,58,1,CPPASTTypeId,,<empty>
614112,UNKNOWN,1,,ULONG,145,<empty>,,58,1,CPPASTTypeId,,<empty>
614130,UNKNOWN,1,,ptrdiff_t,61,<empty>,,60,1,CPPASTTypeId,,<empty>
614150,UNKNOWN,1,,int,47,<empty>,,62,1,CPPASTTypeId,,<empty>
614152,UNKNOWN,1,,unsigned char,64,<empty>,,62,1,CPPASTTypeId,,<empty>
614191,UNKNOWN,1,,ptrdiff_t,61,<empty>,,72,1,CPPASTTypeId,,<empty>
614210,UNKNOWN,1,,int,47,<empty>,,73,1,CPPASTTypeId,,<empty>
614212,UNKNOWN,1,,unsigned char,64,<empty>,,73,1,CPPASTTypeId,,<empty>
614254,UNKNOWN,1,,ptrdiff_t,61,<empty>,,83,1,CPPASTTypeId,,<empty>
614273,UNKNOWN,1,,int,47,<empty>,,84,1,CPPASTTypeId,,<empty>
614275,UNKNOWN,1,,unsigned char,64,<empty>,,84,1,CPPASTTypeId,,<empty>
614365,UNKNOWN,1,,int,72,<empty>,,102,1,CPPASTTypeId,,<empty>
614376,UNKNOWN,1,,int,119,<empty>,,102,1,CPPASTTypeId,,<empty>
614394,UNKNOWN,1,,ptrdiff_t,61,<empty>,,106,1,CPPASTTypeId,,<empty>
614414,UNKNOWN,1,,int,47,<empty>,,108,1,CPPASTTypeId,,<empty>
614416,UNKNOWN,1,,unsigned char,64,<empty>,,108,1,CPPASTTypeId,,<empty>
614508,UNKNOWN,1,,ULONG,66,<empty>,,128,1,CPPASTTypeId,,<empty>
614521,UNKNOWN,1,,ULONG,124,<empty>,,128,1,CPPASTTypeId,,<empty>
614541,UNKNOWN,1,,ptrdiff_t,61,<empty>,,133,1,CPPASTTypeId,,<empty>
614563,UNKNOWN,1,,int,47,<empty>,,135,1,CPPASTTypeId,,<empty>
614565,UNKNOWN,1,,unsigned char,64,<empty>,,135,1,CPPASTTypeId,,<empty>
614657,UNKNOWN,1,,ptrdiff_t,61,<empty>,,157,1,CPPASTTypeId,,<empty>
614676,UNKNOWN,1,,int,47,<empty>,,158,1,CPPASTTypeId,,<empty>
614678,UNKNOWN,1,,unsigned char,64,<empty>,,158,1,CPPASTTypeId,,<empty>
614770,UNKNOWN,1,,ptrdiff_t,61,<empty>,,180,1,CPPASTTypeId,,<empty>
614789,UNKNOWN,1,,int,47,<empty>,,181,1,CPPASTTypeId,,<empty>
614791,UNKNOWN,1,,unsigned char,64,<empty>,,181,1,CPPASTTypeId,,<empty>
614833,UNKNOWN,1,,int,80,<empty>,,190,1,CPPASTTypeId,,<empty>
614843,UNKNOWN,1,,int,131,<empty>,,190,1,CPPASTTypeId,,<empty>
614859,UNKNOWN,1,,ptrdiff_t,66,<empty>,,192,1,CPPASTTypeId,,<empty>
614877,UNKNOWN,1,,int,47,<empty>,,194,1,CPPASTTypeId,,<empty>
614919,UNKNOWN,1,,ULONG,78,<empty>,,204,1,CPPASTTypeId,,<empty>
614934,UNKNOWN,1,,ULONG,156,<empty>,,204,1,CPPASTTypeId,,<empty>
614950,UNKNOWN,1,,ptrdiff_t,66,<empty>,,206,1,CPPASTTypeId,,<empty>
614973,UNKNOWN,1,,int,47,<empty>,,208,1,CPPASTTypeId,,<empty>
615018,UNKNOWN,1,,ptrdiff_t,66,<empty>,,219,1,CPPASTTypeId,,<empty>
615037,UNKNOWN,1,,int,47,<empty>,,220,1,CPPASTTypeId,,<empty>
615082,UNKNOWN,1,,ptrdiff_t,66,<empty>,,231,1,CPPASTTypeId,,<empty>
615101,UNKNOWN,1,,int,47,<empty>,,232,1,CPPASTTypeId,,<empty>
615195,UNKNOWN,1,,int,72,<empty>,,250,1,CPPASTTypeId,,<empty>
615205,UNKNOWN,1,,int,120,<empty>,,250,1,CPPASTTypeId,,<empty>
615220,UNKNOWN,1,,ptrdiff_t,66,<empty>,,254,1,CPPASTTypeId,,<empty>
615238,UNKNOWN,1,,int,47,<empty>,,256,1,CPPASTTypeId,,<empty>
615333,UNKNOWN,1,,ULONG,67,<empty>,,276,1,CPPASTTypeId,,<empty>
615348,UNKNOWN,1,,ULONG,139,<empty>,,276,1,CPPASTTypeId,,<empty>
615366,UNKNOWN,1,,ptrdiff_t,66,<empty>,,281,1,CPPASTTypeId,,<empty>
615386,UNKNOWN,1,,int,47,<empty>,,283,1,CPPASTTypeId,,<empty>
615485,UNKNOWN,1,,ptrdiff_t,66,<empty>,,305,1,CPPASTTypeId,,<empty>
615504,UNKNOWN,1,,int,47,<empty>,,306,1,CPPASTTypeId,,<empty>
615600,UNKNOWN,1,,ptrdiff_t,66,<empty>,,328,1,CPPASTTypeId,,<empty>
615619,UNKNOWN,1,,int,47,<empty>,,329,1,CPPASTTypeId,,<empty>
615712,UNKNOWN,1,,int,74,<empty>,,346,1,CPPASTTypeId,,<empty>
615722,UNKNOWN,1,,int,125,<empty>,,346,1,CPPASTTypeId,,<empty>
615807,UNKNOWN,1,,int,71,<empty>,,359,1,CPPASTTypeId,,<empty>
615818,UNKNOWN,1,,int,122,<empty>,,359,1,CPPASTTypeId,,<empty>
616077,UNKNOWN,1,,int,84,<empty>,,421,1,CPPASTTypeId,,<empty>
616087,UNKNOWN,1,,int,137,<empty>,,421,1,CPPASTTypeId,,<empty>
616121,UNKNOWN,1,,int,85,<empty>,,430,1,CPPASTTypeId,,<empty>
616132,UNKNOWN,1,,int,138,<empty>,,430,1,CPPASTTypeId,,<empty>
616235,UNKNOWN,1,,wchar_t,55,<empty>,,457,1,CPPASTTypeId,,<empty>
616250,UNKNOWN,1,,t_RtlUTF8ToUnicodeN,48,<empty>,,462,1,CPPASTTypeId,,<empty>
616257,UNKNOWN,1,,t_RtlUnicodeToUTF8N,48,<empty>,,463,1,CPPASTTypeId,,<empty>
616471,UNKNOWN,1,,unsigned,36,<empty>,,543,1,CPPASTTypeId,,<empty>
616503,UNKNOWN,1,,ptrdiff_t,76,<empty>,,548,1,CPPASTTypeId,,<empty>
616512,UNKNOWN,1,,ptrdiff_t,24,<empty>,,551,1,CPPASTTypeId,,<empty>
617406,UNKNOWN,1,,char*,46,<empty>,,397,1,CPPASTTypeId,,<empty>
617425,UNKNOWN,1,,char*,42,<empty>,,403,1,CPPASTTypeId,,<empty>
617440,UNKNOWN,28,,"static BOOL WINAPI consoleCtrlHandler(DWORD)
{
    CancelIoEx(g_stdout, nullptr);
    return TRUE;
}",1,<empty>,,411,28,CPPASTProblemDeclaration,,<empty>
617658,UNKNOWN,-1,,"const auto RtlGenRandom = reinterpret_cast<BOOLEAN(APIENTRY*)(PVOID, ULONG)>(GetProcAddress(cryptbase, ""SystemFunction036""));",9,<empty>,,502,4,CPPASTProblemStatement,,<empty>
617758,UNKNOWN,1,,DWORD,32,<empty>,,552,1,CPPASTTypeId,,<empty>
617811,UNKNOWN,1,,DWORD,35,<empty>,,569,1,CPPASTTypeId,,<empty>
617847,UNKNOWN,1,,decltype(&utext_openUTF8),60,<empty>,,579,1,CPPASTTypeId,,<empty>
617855,UNKNOWN,1,,decltype(&ubrk_open),55,<empty>,,580,1,CPPASTTypeId,,<empty>
617863,UNKNOWN,1,,decltype(&ubrk_setUText),59,<empty>,,581,1,CPPASTTypeId,,<empty>
617871,UNKNOWN,1,,decltype(&ubrk_next),55,<empty>,,582,1,CPPASTTypeId,,<empty>
617950,UNKNOWN,1,,uint8_t,61,<empty>,,597,1,CPPASTTypeId,,<empty>
617975,UNKNOWN,1,,DWORD,39,<empty>,,604,1,CPPASTTypeId,,<empty>
618077,UNKNOWN,1,,DWORD,35,<empty>,,645,1,CPPASTTypeId,,<empty>
618121,UNKNOWN,1,,LONGLONG,39,<empty>,,657,1,CPPASTTypeId,,<empty>
618249,UNKNOWN,1,,size_t,73,<empty>,,687,1,CPPASTTypeId,,<empty>
618263,UNKNOWN,1,,DWORD,49,<empty>,,690,1,CPPASTTypeId,,<empty>
618575,UNKNOWN,1,,uintptr_t,44,<empty>,,430,1,CPPASTTypeId,,<empty>
618593,UNKNOWN,1,,uintptr_t,44,<empty>,,435,1,CPPASTTypeId,,<empty>
618807,UNKNOWN,1,,DWORD,59,<empty>,,258,1,CPPASTTypeId,,<empty>
618895,UNKNOWN,1,,DWORD,44,<empty>,,288,1,CPPASTTypeId,,<empty>
618930,UNKNOWN,1,,DWORD,58,<empty>,,298,1,CPPASTTypeId,,<empty>
618955,UNKNOWN,1,,DWORD,58,<empty>,,302,1,CPPASTTypeId,,<empty>
619143,UNKNOWN,1,,uintptr_t,37,<empty>,,361,1,CPPASTTypeId,,<empty>
619434,UNKNOWN,26,,"static BOOL WINAPI ctrlHandler(DWORD type)
{
    if (type == CTRL_CLOSE_EVENT)
    {
        TRACE(""child %d: CTRL_CLOSE_EVENT received, pausing..."", g_childNum);
        Sleep(250);
        TRACE(""child %d: CTRL_CLOSE_EVENT received, exiting..."", g_childNum);
        return TRUE;
    }
    return FALSE;
}",1,<empty>,,472,26,CPPASTProblemDeclaration,,<empty>
619532,UNKNOWN,1,,HLOCAL,16,<empty>,,515,1,CPPASTTypeId,,<empty>
619579,UNKNOWN,1,,HANDLE,13,<empty>,,535,1,CPPASTTypeId,,<empty>
619581,UNKNOWN,1,,uintptr_t,21,<empty>,,535,1,CPPASTTypeId,,<empty>
620144,UNKNOWN,1,,int,27,<empty>,,733,1,CPPASTTypeId,,<empty>
620769,UNKNOWN,1,,char,27,<empty>,,109,1,CPPASTTypeId,,<empty>
620979,UNKNOWN,1,,wchar_t,27,<empty>,,168,1,CPPASTTypeId,,<empty>
621223,UNKNOWN,27,,BOOL,1,<empty>,,265,27,CPPASTProblemDeclaration,,<empty>
621590,UNKNOWN,1,,"int CALLBACK FontEnumForV2Console(ENUMLOGFONT* pelf, NEWTEXTMETRIC* pntm, int nFontType, LPARAM lParam);",1,<empty>,,8,1,CPPASTProblemDeclaration,,<empty>
621632,UNKNOWN,1,,FONTENUMPROC,47,<empty>,,26,1,CPPASTTypeId,,<empty>
621635,UNKNOWN,1,,LPARAM,83,<empty>,,26,1,CPPASTTypeId,,<empty>
621663,UNKNOWN,6,,"int CALLBACK FontEnumForV2Console(ENUMLOGFONT* pelf, NEWTEXTMETRIC* pntm, int nFontType, LPARAM lParam)
{
    UINT i;
    LPCWSTR pwszFace = pelf->elfLogFont.lfFaceName;

    const auto fIsEastAsianCP = IsEastAsianCP(GetACP());

    LPCWSTR pwszCharSet;

    switch (pelf->elfLogFont.lfCharSet)
    {
    case ANSI_CHARSET:
        pwszCharSet = L""ANSI"";
        break;
    case CHINESEBIG5_CHARSET:
        pwszCharSet = L""Chinese Big5"";
        break;
    case EASTEUROPE_CHARSET:
        pwszCharSet = L""East Europe"";
        break;
    case GREEK_CHARSET:
        pwszCharSet = L""Greek"";
        break;
    case MAC_CHARSET:
        pwszCharSet = L""Mac"";
        break;
    case RUSSIAN_CHARSET:
        pwszCharSet = L""Russian"";
        break;
    case SYMBOL_CHARSET:
        pwszCharSet = L""Symbol"";
        break;
    case BALTIC_CHARSET:
        pwszCharSet = L""Baltic"";
        break;
    case DEFAULT_CHARSET:
        pwszCharSet = L""Default"";
        break;
    case GB2312_CHARSET:
  ...",1,<empty>,,72,6,CPPASTProblemDeclaration,,<empty>
621746,UNKNOWN,1,,"int __cdecl wmain(int /*argc*/, __in_ecount(argc) PCWSTR* /*argv*/)
{
    TestLibFunc();

    return 0;
}",1,<empty>,,15,1,CPPASTProblemDeclaration,,<empty>
621849,UNKNOWN,2,,"void WriteToConsole(_In_ PCWSTR pwszText)
{
    DWORD dwWritten = 0;
    WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE),
                  pwszText,
                  (DWORD)wcslen(pwszText),
                  &dwWritten,
                  nullptr);
}",1,<empty>,,38,2,CPPASTProblemDeclaration,,<empty>
621850,UNKNOWN,3,,"void FormatToConsole(_In_ PCWSTR pwszFunc, const BOOL bResult, const DWORD dwError)
{
    std::unique_ptr<wchar_t[]> pwszBuffer = std::make_unique<wchar_t[]>(MAX_PATH);
    THROW_IF_FAILED(StringCchPrintfW(pwszBuffer.get(), MAX_PATH, L""%s;%d;%d\r\n"", pwszFunc, bResult, dwError));
    WriteToConsole(pwszBuffer.get());
}",1,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
621851,UNKNOWN,4,,"PCWSTR TryReadConsoleOutputW(_Out_ BOOL* const pbResult,
                             _Out_ DWORD* const pdwError)
{
    DWORD cCharInfos = 1;
    std::unique_ptr<CHAR_INFO[]> rgCharInfos = std::make_unique<CHAR_INFO[]>(cCharInfos);
    COORD coordBuffer;
    coordBuffer.X = 1;
    coordBuffer.Y = 1;

    COORD coordRead = { 0 };
    SMALL_RECT srReadRegion = { 0 };

    SetLastError(0);
    *pbResult = ReadConsoleOutputW(GetStdHandle(STD_OUTPUT_HANDLE),
                                   rgCharInfos.get(),
                                   coordBuffer,
                                   coordRead,
                                   &srReadRegion);
    *pdwError = GetLastError();
    return L""RCOW"";
}",1,<empty>,,55,4,CPPASTProblemDeclaration,,<empty>
621852,UNKNOWN,5,,"PCWSTR TryReadConsoleOutputA(_Out_ BOOL* const pbResult,
                             _Out_ DWORD* const pdwError)
{
    DWORD cCharInfos = 1;
    std::unique_ptr<CHAR_INFO[]> rgCharInfos = std::make_unique<CHAR_INFO[]>(cCharInfos);
    COORD coordBuffer;
    coordBuffer.X = 1;
    coordBuffer.Y = 1;

    COORD coordRead = { 0 };
    SMALL_RECT srReadRegion = { 0 };

    SetLastError(0);
    *pbResult = ReadConsoleOutputA(GetStdHandle(STD_OUTPUT_HANDLE),
                                   rgCharInfos.get(),
                                   coordBuffer,
                                   coordRead,
                                   &srReadRegion);
    *pdwError = GetLastError();
    return L""RCOA"";
}",1,<empty>,,77,5,CPPASTProblemDeclaration,,<empty>
621853,UNKNOWN,6,,"PCWSTR TryReadConsoleOutputCharacterW(_Out_ BOOL* const pbResult,
                                      _Out_ DWORD* const pdwError)
{
    DWORD cchTest = 1;
    std::unique_ptr<wchar_t[]> pwszTest = std::make_unique<wchar_t[]>(cchTest);
    COORD coordRead = { 0 };
    DWORD dwRead = 0;

    SetLastError(0);
    *pbResult = ReadConsoleOutputCharacterW(GetStdHandle(STD_OUTPUT_HANDLE),
                                            pwszTest.get(),
                                            cchTest,
                                            coordRead,
                                            &dwRead);
    *pdwError = GetLastError();
    return L""RCOCW"";
}",1,<empty>,,99,6,CPPASTProblemDeclaration,,<empty>
621854,UNKNOWN,7,,"PCWSTR TryReadConsoleOutputCharacterA(_Out_ BOOL* const pbResult,
                                      _Out_ DWORD* const pdwError)
{
    DWORD cchTest = 1;
    std::unique_ptr<char[]> pszTest = std::make_unique<char[]>(cchTest);
    COORD coordRead = { 0 };
    DWORD dwRead = 0;

    SetLastError(0);
    *pbResult = ReadConsoleOutputCharacterA(GetStdHandle(STD_OUTPUT_HANDLE),
                                            pszTest.get(),
                                            cchTest,
                                            coordRead,
                                            &dwRead);
    *pdwError = GetLastError();
    return L""RCOCA"";
}",1,<empty>,,117,7,CPPASTProblemDeclaration,,<empty>
621855,UNKNOWN,8,,"PCWSTR TryReadConsoleOutputAttribute(_Out_ BOOL* const pbResult,
                                     _Out_ DWORD* const pdwError)
{
    DWORD cchTest = 1;
    std::unique_ptr<WORD[]> rgwTest = std::make_unique<WORD[]>(cchTest);
    COORD coordRead = { 0 };
    DWORD dwRead = 0;

    SetLastError(0);
    *pbResult = ReadConsoleOutputAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
                                           rgwTest.get(),
                                           cchTest,
                                           coordRead,
                                           &dwRead);
    *pdwError = GetLastError();
    return L""RCOAttr"";
}",1,<empty>,,135,8,CPPASTProblemDeclaration,,<empty>
621856,UNKNOWN,9,,"PCWSTR TryWriteConsoleInputW(_Out_ BOOL* const pbResult,
                             _Out_ DWORD* const pdwError)
{
    DWORD cInputRecords = 1;
    std::unique_ptr<INPUT_RECORD[]> rgInputRecords = std::make_unique<INPUT_RECORD[]>(cInputRecords);
    rgInputRecords[0].EventType = KEY_EVENT;
    rgInputRecords[0].Event.KeyEvent.bKeyDown = TRUE;
    rgInputRecords[0].Event.KeyEvent.dwControlKeyState = 0;
    rgInputRecords[0].Event.KeyEvent.uChar.UnicodeChar = L'A';
    rgInputRecords[0].Event.KeyEvent.wRepeatCount = 1;
    rgInputRecords[0].Event.KeyEvent.wVirtualKeyCode = L'A';
    rgInputRecords[0].Event.KeyEvent.wVirtualScanCode = L'A';

    DWORD dwWritten = 0;

    SetLastError(0);
    *pbResult = WriteConsoleInputW(GetStdHandle(STD_INPUT_HANDLE),
                                   rgInputRecords.get(),
                                   cInputRecords,
                                   &dwWritten);
    *pdwError = GetLastError();
    return L""WCIW"";
}",1,<empty>,,153,9,CPPASTProblemDeclaration,,<empty>
621857,UNKNOWN,10,,"PCWSTR TryWriteConsoleInputA(_Out_ BOOL* const pbResult,
                             _Out_ DWORD* const pdwError)
{
    DWORD cInputRecords = 1;
    std::unique_ptr<INPUT_RECORD[]> rgInputRecords = std::make_unique<INPUT_RECORD[]>(cInputRecords);
    rgInputRecords[0].EventType = KEY_EVENT;
    rgInputRecords[0].Event.KeyEvent.bKeyDown = TRUE;
    rgInputRecords[0].Event.KeyEvent.dwControlKeyState = 0;
    rgInputRecords[0].Event.KeyEvent.uChar.AsciiChar = 'A';
    rgInputRecords[0].Event.KeyEvent.wRepeatCount = 1;
    rgInputRecords[0].Event.KeyEvent.wVirtualKeyCode = L'A';
    rgInputRecords[0].Event.KeyEvent.wVirtualScanCode = L'A';

    DWORD dwWritten = 0;

    SetLastError(0);
    *pbResult = WriteConsoleInputA(GetStdHandle(STD_INPUT_HANDLE),
                                   rgInputRecords.get(),
                                   cInputRecords,
                                   &dwWritten);
    *pdwError = GetLastError();
    return L""WCIA"";
}",1,<empty>,,177,10,CPPASTProblemDeclaration,,<empty>
621970,UNKNOWN,2,,"HRESULT GetPropertyBoolValue(_In_ IPropertyStore* pPropStore, _In_ REFPROPERTYKEY refPropKey, _Out_ BOOL* pfValue)
{
    PROPVARIANT propvar;
    HRESULT hr = pPropStore->GetValue(refPropKey, &propvar);
    if (SUCCEEDED(hr))
    {
        hr = PropVariantToBoolean(propvar, pfValue);
    }

    return hr;
}",1,<empty>,,12,2,CPPASTProblemDeclaration,,<empty>
621971,UNKNOWN,3,,"HRESULT GetPropertyByteValue(_In_ IPropertyStore* pPropStore, _In_ REFPROPERTYKEY refPropKey, _Out_ BYTE* pbValue)
{
    PROPVARIANT propvar;
    HRESULT hr = pPropStore->GetValue(refPropKey, &propvar);
    if (SUCCEEDED(hr))
    {
        SHORT sValue;
        hr = PropVariantToInt16(propvar, &sValue);
        if (SUCCEEDED(hr))
        {
            hr = (sValue >= 0 && sValue <= BYTE_MAX) ? S_OK : E_INVALIDARG;
            if (SUCCEEDED(hr))
            {
                *pbValue = (BYTE)sValue;
            }
        }
    }

    return hr;
}",1,<empty>,,24,3,CPPASTProblemDeclaration,,<empty>
621972,UNKNOWN,4,,"void DumpV2Properties(_In_ IShellLink* pslConsole)
{
    IPropertyStore* pPropStoreLnk;
    HRESULT hr = pslConsole->QueryInterface(IID_PPV_ARGS(&pPropStoreLnk));
    if (SUCCEEDED(hr))
    {
        wprintf(L""V2 Properties:\n"");
        BOOL fForceV2;
        hr = GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_ForceV2, &fForceV2);
        if (SUCCEEDED(hr))
        {
            wprintf(L""\tPKEY_Console_ForceV2: %s\n"", (fForceV2) ? L""true"" : L""false"");
        }
        else
        {
            wprintf(L""ERROR: Unable to retrieve value of PKEY_Console_ForceV2. (HRESULT: 0x%08x)\n"", hr);
        }

        BOOL fWrapText;
        hr = GetPropertyBoolValue(pPropStoreLnk, PKEY_Console_WrapText, &fWrapText);
        if (SUCCEEDED(hr))
        {
            wprintf(L""\tPKEY_Console_WrapText: %s\n"", (fWrapText) ? L""true"" : L""false"");
        }
        else
        {
            wprintf(L""ERROR: Unable to retrieve value of PKEY_Console_WrapText. (HRESULT: 0x%08x)\n"", hr);
        }

 ...",1,<empty>,,45,4,CPPASTProblemDeclaration,,<empty>
621973,UNKNOWN,5,,"void DumpCoord(_In_ PCWSTR pszAttrName, const COORD coord)
{
    wprintf(L""\t%s: (%d, %d) (0x%x)\n"",
            pszAttrName,
            coord.X,
            coord.Y,
            coord);
}",1,<empty>,,122,5,CPPASTProblemDeclaration,,<empty>
621974,UNKNOWN,6,,"void DumpBool(_In_ PCWSTR pszAttrName, const BOOL fEnabled)
{
    wprintf(L""\t%s: %s\n"", pszAttrName, fEnabled ? L""true"" : L""false"");
}",1,<empty>,,131,6,CPPASTProblemDeclaration,,<empty>
621975,UNKNOWN,7,,"HRESULT DumpV1Properties(_In_ IShellLink* pslConsole)
{
    IShellLinkDataList* pConsoleLnkDataList;
    HRESULT hr = pslConsole->QueryInterface(IID_PPV_ARGS(&pConsoleLnkDataList));
    if (SUCCEEDED(hr))
    {
        NT_CONSOLE_PROPS* pNtConsoleProps = nullptr;
        hr = pConsoleLnkDataList->CopyDataBlock(NT_CONSOLE_PROPS_SIG, (void**)&pNtConsoleProps);
        if (SUCCEEDED(hr))
        {
            wprintf(L""V1 Properties:\n"");
            wprintf(L""\twFillAttribute: %x\n"", pNtConsoleProps->wFillAttribute);
            wprintf(L""\twPopupFillAttribute: %x\n"", pNtConsoleProps->wPopupFillAttribute);
            DumpCoord(L""dwScreenBufferSize"", pNtConsoleProps->dwScreenBufferSize);
            DumpCoord(L""dwWindowSize"", pNtConsoleProps->dwWindowSize);
            DumpCoord(L""dwWindowOrigin"", pNtConsoleProps->dwWindowOrigin);
            wprintf(L""\tnFont: %x\n"", pNtConsoleProps->nFont);
            wprintf(L""\tnInputBufferSize: %x\n"", pNtConsoleProps->nInputBufferSize);
        ...",1,<empty>,,136,7,CPPASTProblemDeclaration,,<empty>
621976,UNKNOWN,8,,"HRESULT DumpProperties(_In_ PCWSTR pszLnkFile)
{
    IShellLink* pslConsole;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC, IID_PPV_ARGS(&pslConsole));
    if (SUCCEEDED(hr))
    {
        IPersistFile* pPersistFileLnk;
        hr = pslConsole->QueryInterface(IID_PPV_ARGS(&pPersistFileLnk));
        if (SUCCEEDED(hr))
        {
            hr = pPersistFileLnk->Load(pszLnkFile, 0 /*grfMode*/);
            if (SUCCEEDED(hr))
            {
                hr = DumpV1Properties(pslConsole);
                if (SUCCEEDED(hr))
                {
                    wprintf(L""\n"");
                    DumpV2Properties(pslConsole);
                }
                else if (hr == E_FAIL)
                {
                    wprintf(L""ERROR: .lnk file does not contain console properties.\n"");
                }
            }
            else
            {
                wprintf(L""ERROR: Failed to load from lnk file (HRESULT: 0x%08x)\n"", hr);
            }

         ...",1,<empty>,,201,8,CPPASTProblemDeclaration,,<empty>
622329,UNKNOWN,1,,UINT*,65,<empty>,,67,1,CPPASTTypeId,,<empty>
622335,UNKNOWN,1,,UINT*,80,<empty>,,67,1,CPPASTTypeId,,<empty>
622347,UNKNOWN,6,,"BOOL CALLBACK MonitorEnumProc(
    _In_ HMONITOR hMonitor,
    _In_ HDC /*hdcMonitor*/,
    _In_ LPRECT /*lprcMonitor*/,
    _In_ LPARAM /*dwData*/
)
{
    PrintMonitorInfo(L""--- Monitor ---"", hMonitor);
    wcout << endl;
    return TRUE;
}",1,<empty>,,73,6,CPPASTProblemDeclaration,,<empty>
622348,UNKNOWN,7,,"BOOL s_AdjustWindowRectEx(_Inout_ LPRECT prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle)
{
    return AdjustWindowRectEx(prc, dwStyle, fMenu, dwExStyle);
}",1,<empty>,,85,7,CPPASTProblemDeclaration,,<empty>
622349,UNKNOWN,8,,"BOOL s_UnadjustWindowRectEx(_Inout_ LPRECT prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle)
{
    RECT rc;
    SetRectEmpty(&rc);
    BOOL fRc = s_AdjustWindowRectEx(&rc, dwStyle, fMenu, dwExStyle);
    if (fRc)
    {
        prc->left -= rc.left;
        prc->top -= rc.top;
        prc->right -= rc.right;
        prc->bottom -= rc.bottom;
    }
    return fRc;
}",1,<empty>,,90,8,CPPASTProblemDeclaration,,<empty>
622350,UNKNOWN,9,,"BOOL s_AdjustWindowRectExForDpi(_Inout_ LPRECT prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle, _In_ UINT dpi)
{
    return AdjustWindowRectExForDpi(prc, dwStyle, fMenu, dwExStyle, dpi);
}",1,<empty>,,105,9,CPPASTProblemDeclaration,,<empty>
622351,UNKNOWN,10,,"BOOL s_UnadjustWindowRectExForDpi(_Inout_ LPRECT prc, const DWORD dwStyle, const BOOL fMenu, const DWORD dwExStyle, _In_ UINT dpi)
{
    RECT rc;
    SetRectEmpty(&rc);
    BOOL fRc = s_AdjustWindowRectExForDpi(&rc, dwStyle, fMenu, dwExStyle, dpi);
    if (fRc)
    {
        prc->left -= rc.left;
        prc->top -= rc.top;
        prc->right -= rc.right;
        prc->bottom -= rc.bottom;
    }
    return fRc;
}",1,<empty>,,110,10,CPPASTProblemDeclaration,,<empty>
622540,UNKNOWN,1,,PfnGetDpiMetrics,16,<empty>,,184,1,CPPASTTypeId,,<empty>
622554,UNKNOWN,1,,SHORT,22,<empty>,,188,1,CPPASTTypeId,,<empty>
622563,UNKNOWN,1,,SHORT,22,<empty>,,189,1,CPPASTTypeId,,<empty>
622579,UNKNOWN,1,,SHORT,18,<empty>,,196,1,CPPASTTypeId,,<empty>
622587,UNKNOWN,1,,SHORT,18,<empty>,,197,1,CPPASTTypeId,,<empty>
623359,UNKNOWN,5,,"HRESULT CreatePseudoConsoleAndHandles(COORD size,
                                      _In_ DWORD dwFlags,
                                      _Out_ HANDLE* phInput,
                                      _Out_ HANDLE* phOutput,
                                      _Out_ HPCON* phPC)
{
    if (phPC == nullptr || phInput == nullptr || phOutput == nullptr)
    {
        return E_INVALIDARG;
    }

    HANDLE outPipeOurSide;
    HANDLE inPipeOurSide;
    HANDLE outPipePseudoConsoleSide;
    HANDLE inPipePseudoConsoleSide;

    auto hr = S_OK;
    if (!CreatePipe(&inPipePseudoConsoleSide, &inPipeOurSide, nullptr, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if (SUCCEEDED(hr))
    {
        if (!CreatePipe(&outPipeOurSide, &outPipePseudoConsoleSide, nullptr, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if (SUCCEEDED(hr))
        {
            hr = CreatePseudoConsole(size, inPipePseudoConsoleSide, outPipePseudoConsoleSide...",1,<empty>,,67,5,CPPASTProblemDeclaration,,<empty>
623448,UNKNOWN,1,,PPROC_THREAD_ATTRIBUTE_LIST,45,<empty>,,170,1,CPPASTTypeId,,<empty>
623821,UNKNOWN,1,,DWORD,39,<empty>,,318,1,CPPASTTypeId,,<empty>
623844,UNKNOWN,13,,DWORD,1,<empty>,,332,13,CPPASTProblemDeclaration,,<empty>
623852,UNKNOWN,1,,VtConsole*,35,<empty>,,334,1,CPPASTTypeId,,<empty>
623934,UNKNOWN,1,,SHORT,55,<empty>,,371,1,CPPASTTypeId,,<empty>
623937,UNKNOWN,1,,SHORT,68,<empty>,,371,1,CPPASTTypeId,,<empty>
623984,UNKNOWN,1,,DWORD,57,<empty>,,395,1,CPPASTTypeId,,<empty>
624068,UNKNOWN,-1,,static DWORD WINAPI StaticOutputThreadProc(LPVOID lpParameter);,5,<empty>,,46,13,CPPASTProblemDeclaration,,<empty>
624353,UNKNOWN,1,,char*,47,<empty>,,73,1,CPPASTTypeId,,<empty>
624736,UNKNOWN,1,,char,27,<empty>,,213,1,CPPASTTypeId,,<empty>
625368,UNKNOWN,61,,DWORD,1,<empty>,,463,61,CPPASTProblemDeclaration,,<empty>
625446,UNKNOWN,64,,BOOL,1,<empty>,,508,64,CPPASTProblemDeclaration,,<empty>
625469,UNKNOWN,1,,unsigned int,12,<empty>,,528,1,CPPASTTypeId,,<empty>
625776,UNKNOWN,1,,ITfContextOwnerCompositionSink*,55,<empty>,,53,1,CPPASTTypeId,,<empty>
625823,UNKNOWN,1,,ITfContextOwner*,63,<empty>,,63,1,CPPASTTypeId,,<empty>
625964,UNKNOWN,1,,ITfInputProcessorProfileActivationSink*,43,<empty>,,94,1,CPPASTTypeId,,<empty>
625985,UNKNOWN,1,,ITfUIElementSink*,65,<empty>,,98,1,CPPASTTypeId,,<empty>
626006,UNKNOWN,1,,ITfTextEditSink*,63,<empty>,,101,1,CPPASTTypeId,,<empty>
626028,UNKNOWN,1,,ITfCleanupContextSink*,82,<empty>,,104,1,CPPASTTypeId,,<empty>
626224,UNKNOWN,1,,ITfCleanupContextSink*,31,<empty>,,225,1,CPPASTTypeId,,<empty>
626237,UNKNOWN,1,,ITfContextOwnerCompositionSink*,31,<empty>,,229,1,CPPASTTypeId,,<empty>
626250,UNKNOWN,1,,ITfUIElementSink*,31,<empty>,,233,1,CPPASTTypeId,,<empty>
626263,UNKNOWN,1,,ITfContextOwner*,31,<empty>,,237,1,CPPASTTypeId,,<empty>
626276,UNKNOWN,1,,ITfInputProcessorProfileActivationSink*,31,<empty>,,241,1,CPPASTTypeId,,<empty>
626289,UNKNOWN,1,,ITfTextEditSink*,31,<empty>,,245,1,CPPASTTypeId,,<empty>
626316,UNKNOWN,7,,),14,<empty>,,258,7,CPPASTProblemDeclaration,,<empty>
626326,UNKNOWN,10,,),14,<empty>,,264,10,CPPASTProblemDeclaration,,<empty>
626603,UNKNOWN,-1,,"try
    {
        CreateConversionArea();
    }
    CATCH_RETURN();",5,<empty>,,411,3,CPPASTProblemStatement,,<empty>
626841,UNKNOWN,-1,,),24,<empty>,,53,7,CPPASTProblemDeclaration,,<empty>
626842,UNKNOWN,-1,,AddRef(void);,5,<empty>,,54,8,CPPASTProblemDeclaration,,<empty>
626844,UNKNOWN,-1,,),24,<empty>,,55,10,CPPASTProblemDeclaration,,<empty>
626845,UNKNOWN,-1,,Release(void);,5,<empty>,,56,11,CPPASTProblemDeclaration,,<empty>
627447,UNKNOWN,1,,BYTE,26,<empty>,,84,1,CPPASTTypeId,,<empty>
627580,UNKNOWN,-1,,"try
    {
        auto ulNumProp = static_cast<ULONG>(m_DispAttrProp.size());
        if (ulNumProp)
        {
            // TrackProperties wants an array of GUID *'s
            auto ppguidProp = std::make_unique<const GUID*[]>(ulNumProp);
            for (ULONG i = 0; i < ulNumProp; i++)
            {
                ppguidProp[i] = &m_DispAttrProp.at(i);
            }

            wil::com_ptr<ITfReadOnlyProperty> pProp;
            if (SUCCEEDED(hr = pic->TrackProperties(ppguidProp.get(), ulNumProp, nullptr, NULL, &pProp)))
            {
                hr = pProp->EnumRanges(ec, ppEnum, pRange);
                if (SUCCEEDED(hr))
                {
                    *ppProp = pProp.detach();
                }
            }

            if (SUCCEEDED(hr))
            {
                *pulNumProp = ulNumProp;
            }
        }
    }
    CATCH_RETURN();",5,<empty>,,50,3,CPPASTProblemStatement,,<empty>
627671,UNKNOWN,1,,TfGuidAtom,31,<empty>,,117,1,CPPASTTypeId,,<empty>
627768,UNKNOWN,-1,,"try
        {
            //
            // add System Display Attribute first.
            // so no other Display Attribute property overwrite it.
            //
            m_DispAttrProp.emplace_back(GUID_PROP_ATTRIBUTE);

            while (pEnumProp->Next(1, &guidProp, nullptr) == S_OK)
            {
                if (!IsEqualGUID(guidProp, GUID_PROP_ATTRIBUTE))
                {
                    m_DispAttrProp.emplace_back(guidProp);
                }
            }
        }
        CATCH_RETURN();",9,<empty>,,180,2,CPPASTProblemStatement,,<empty>
627856,UNKNOWN,1,,ITfEditSession*,31,<empty>,,42,1,CPPASTTypeId,,<empty>
627869,UNKNOWN,1,,IUnknown*,31,<empty>,,46,1,CPPASTTypeId,,<empty>
627883,UNKNOWN,3,,),14,<empty>,,58,3,CPPASTProblemDeclaration,,<empty>
627892,UNKNOWN,6,,),14,<empty>,,64,6,CPPASTProblemDeclaration,,<empty>
627989,UNKNOWN,9,,"[[nodiscard]] HRESULT CEditSessionObject::SetTextInRange(TfEditCookie ec,
                                                         ITfRange* range,
                                                         __in_ecount_opt(len) LPWSTR psz,
                                                         DWORD len)
{
    auto hr = E_FAIL;
    if (g_pConsoleTSF)
    {
        g_pConsoleTSF->SetModifyingDocFlag(TRUE);
        hr = range->SetText(ec, 0, psz, len);
        g_pConsoleTSF->SetModifyingDocFlag(FALSE);
    }
    return hr;
}",1,<empty>,,131,9,CPPASTProblemDeclaration,,<empty>
628639,UNKNOWN,-1,,"try
            {
                CompGuid.insert(CompGuid.end(), ulcch0, guidatom);
                CompStr.append(wstr0, ulcch0);
            }
            CATCH_RETURN();",13,<empty>,,413,9,CPPASTProblemStatement,,<empty>
628762,UNKNOWN,-1,,"try
        {
            if (result_comp <= 0)
            {
                CompGuid.insert(CompGuid.end(), ulcch0, guidatom);
                CompStr.append(wstr0, ulcch0);
            }
            else
            {
                ResultStr.append(wstr0, ulcch0);
                LOG_IF_FAILED(ClearTextInRange(ec, backup_range.get()));
            }
        }
        CATCH_RETURN();",9,<empty>,,484,5,CPPASTProblemStatement,,<empty>
628835,UNKNOWN,-1,,"try
        {
            // see if there is a valid disp attribute
            if (fCompExist == TRUE && result_comp <= 0)
            {
                if (guidatom == TF_INVALID_GUIDATOM)
                {
                    da.bAttr = TF_ATTR_INPUT;
                }
                CompGuid.insert(CompGuid.end(), ulcch0, guidatom);
                CompStr.append(wstr0, ulcch0);
            }
            else if (bInWriteSession)
            {
                // if there's no disp attribute attached, it probably means
                // the part of string is finalized.
                //
                ResultStr.append(wstr0, ulcch0);

                // it was a 'determined' string
                // so the doc has to shrink
                //
                LOG_IF_FAILED(ClearTextInRange(ec, backup_range.get()));
            }
            else
            {
                //
                // Prevent infinite loop
                //
                break;
            }
  ...",9,<empty>,,545,5,CPPASTProblemStatement,,<empty>
629160,UNKNOWN,-1,,"try
    {
        auto wstr = std::make_unique<WCHAR[]>(cch + 1);

        // Get the whole text, finalize it, and erase the whole text.
        if (SUCCEEDED(spRange->GetText(ec, TF_TF_IGNOREEND, wstr.get(), (ULONG)cch, (ULONG*)&cch)))
        {
            // Make Result String.
            hr = conv_area->DrawResult({ wstr.get(), static_cast<size_t>(cch) });
        }
    }
    CATCH_RETURN();",5,<empty>,,714,16,CPPASTProblemStatement,,<empty>
629645,UNKNOWN,-1,,"try
    {
        // Get conversion area service.
        auto conv_area = g_pConsoleTSF ? g_pConsoleTSF->GetConversionArea() : nullptr;
        RETURN_HR_IF_NULL(E_FAIL, conv_area);

        if (!ResultStr.empty() && !fIgnorePreviousCompositionResult)
        {
            return conv_area->DrawResult(ResultStr);
        }
        if (!CompStr.empty())
        {
            const auto cchDisplayAttribute = CompGuid.size();
            std::vector<TF_DISPLAYATTRIBUTE> DisplayAttributes;
            DisplayAttributes.reserve(cchDisplayAttribute);

            for (size_t i = 0; i < cchDisplayAttribute; i++)
            {
                TF_DISPLAYATTRIBUTE da;
                ZeroMemory(&da, sizeof(da));
                da.bAttr = TF_ATTR_OTHER;

                GUID guid;
                if (SUCCEEDED(cat->GetGUID(CompGuid.at(i), &guid)))
                {
                    CLSID clsid;
                    wil::com_ptr_nothrow<ITfDisplayAttributeInfo> dai;
                    if (...",5,<empty>,,952,16,CPPASTProblemStatement,,<empty>
629714,UNKNOWN,-1,,"try
            {
                auto wstr = std::make_unique<WCHAR[]>(lTextLength + 1);

                // Get the result text, finalize it, and erase the result text.
                if (SUCCEEDED(FullTextRange->GetText(ec, TF_TF_IGNOREEND, wstr.get(), (ULONG)lTextLength, (ULONG*)&lTextLength)))
                {
                    // Clear the TOM
                    LOG_IF_FAILED(ClearTextInRange(ec, FullTextRange));
                }
            }
            CATCH_RETURN();",13,<empty>,,1034,1,CPPASTProblemStatement,,<empty>
629754,UNKNOWN,-1,,"try
    {
        // Get conversion area service.
        auto conv_area = g_pConsoleTSF ? g_pConsoleTSF->GetConversionArea() : nullptr;
        RETURN_HR_IF_NULL(E_FAIL, conv_area);

        if (!CompStr.empty())
        {
            const auto cchDisplayAttribute = CompGuid.size();
            std::vector<TF_DISPLAYATTRIBUTE> DisplayAttributes;
            DisplayAttributes.reserve(cchDisplayAttribute);

            for (size_t i = 0; i < cchDisplayAttribute; i++)
            {
                TF_DISPLAYATTRIBUTE da;
                ZeroMemory(&da, sizeof(da));
                da.bAttr = TF_ATTR_OTHER;
                GUID guid;
                if (SUCCEEDED(cat->GetGUID(CompGuid.at(i), &guid)))
                {
                    CLSID clsid;
                    wil::com_ptr_nothrow<ITfDisplayAttributeInfo> dai;
                    if (SUCCEEDED(dam->GetDisplayAttributeInfo(guid, &dai, &clsid)))
                    {
                        dai->GetAttributeInfo(&da);
        ...",5,<empty>,,1072,18,CPPASTProblemStatement,,<empty>
629889,UNKNOWN,-1,,),24,<empty>,,53,5,CPPASTProblemDeclaration,,<empty>
629890,UNKNOWN,-1,,AddRef(void);,5,<empty>,,54,6,CPPASTProblemDeclaration,,<empty>
629892,UNKNOWN,-1,,),24,<empty>,,55,8,CPPASTProblemDeclaration,,<empty>
629893,UNKNOWN,-1,,Release(void);,5,<empty>,,56,9,CPPASTProblemDeclaration,,<empty>
629921,UNKNOWN,-1,,"[[nodiscard]] HRESULT SetTextInRange(TfEditCookie ec,
                                         ITfRange* range,
                                         __in_ecount_opt(len) LPWSTR psz,
                                         DWORD len);",5,<empty>,,85,13,CPPASTProblemDeclaration,,<empty>
632174,UNKNOWN,1,,CodepointWidth,24,<empty>,,363,1,CPPASTTypeId,,<empty>
632599,UNKNOWN,4,,__forceinline,1,<empty>,,58,4,CPPASTProblemDeclaration,,<empty>
632604,UNKNOWN,-1,,2,8,<empty>,,73,2,CPPASTProblemStatement,,<empty>
632653,UNKNOWN,-1,,__forceinline,5,<empty>,,104,3,CPPASTProblemDeclaration,,<empty>
632735,UNKNOWN,-1,,__forceinline,5,<empty>,,121,5,CPPASTProblemDeclaration,,<empty>
632820,UNKNOWN,7,,__forceinline,1,<empty>,,143,7,CPPASTProblemDeclaration,,<empty>
632857,UNKNOWN,9,,__forceinline,1,<empty>,,153,9,CPPASTProblemDeclaration,,<empty>
633358,UNKNOWN,1,,void*,59,<empty>,,20,1,CPPASTTypeId,,<empty>
633374,UNKNOWN,2,,"HRESULT ScreenInfoUiaProviderBase::RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ std::wstring_view wordDelimiters) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pData);
    _pData = pData;
    _wordDelimiters = wordDelimiters;

    UiaTracing::TextProvider::Constructor(*this);
    return S_OK;
}",1,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
633375,UNKNOWN,3,,CATCH_RETURN();,1,<empty>,,44,3,CPPASTProblemDeclaration,,<empty>
633376,UNKNOWN,4,,"[[nodiscard]] HRESULT ScreenInfoUiaProviderBase::Signal(_In_ EVENTID eventId)
{
    auto hr = S_OK;
    // check to see if we're already firing this particular event
    if (_signalFiringMapping.find(eventId) != _signalFiringMapping.end() &&
        _signalFiringMapping[eventId] == true)
    {
        return hr;
    }

    try
    {
        _signalFiringMapping[eventId] = true;
    }
    CATCH_RETURN();

    IRawElementProviderSimple* pProvider = this;
    hr = UiaRaiseAutomationEvent(pProvider, eventId);
    _signalFiringMapping[eventId] = false;

    return hr;
}",1,<empty>,,46,4,CPPASTProblemDeclaration,,<empty>
633377,UNKNOWN,5,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::get_ProviderOptions(_Out_ ProviderOptions* pOptions) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pOptions);

    *pOptions = ProviderOptions_ServerSideProvider;
    UiaTracing::TextProvider::get_ProviderOptions(*this, *pOptions);
    return S_OK;
}",1,<empty>,,73,5,CPPASTProblemDeclaration,,<empty>
633378,UNKNOWN,6,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetPatternProvider(_In_ PATTERNID patternId,
                                                             _COM_Outptr_result_maybenull_ IUnknown** ppInterface)
{
    RETURN_HR_IF(E_INVALIDARG, ppInterface == nullptr);
    *ppInterface = nullptr;

    auto hr = S_OK;
    if (patternId == UIA_TextPatternId)
    {
        hr = QueryInterface(IID_PPV_ARGS(ppInterface));
        if (FAILED(hr))
        {
            *ppInterface = nullptr;
        }
    }
    UiaTracing::TextProvider::GetPatternProvider(*this, patternId);
    return hr;
}",1,<empty>,,84,6,CPPASTProblemDeclaration,,<empty>
633379,UNKNOWN,7,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetPropertyValue(_In_ PROPERTYID propertyId,
                                                           _Out_ VARIANT* pVariant) noexcept
{
    pVariant->vt = VT_EMPTY;

    // Returning the default will leave the property as the default
    // so we only really need to touch it for the properties we want to implement
    if (propertyId == UIA_ControlTypePropertyId)
    {
        // This control is the Document control type, implying that it is
        // a complex document that supports text pattern
        pVariant->vt = VT_I4;
        pVariant->lVal = UIA_DocumentControlTypeId;
    }
    else if (propertyId == UIA_NamePropertyId)
    {
        // TODO: MSFT: 7960168 - These strings should be localized text in the final UIA work
        pVariant->bstrVal = SysAllocString(L""Text Area"");
        if (pVariant->bstrVal != nullptr)
        {
            pVariant->vt = VT_BSTR;
        }
    }
    else if (propertyId == UIA_AutomationIdPropertyI...",1,<empty>,,105,7,CPPASTProblemDeclaration,,<empty>
633380,UNKNOWN,8,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider) noexcept
{
    RETURN_HR_IF(E_INVALIDARG, ppProvider == nullptr);
    *ppProvider = nullptr;
    UiaTracing::TextProvider::get_HostRawElementProvider(*this);
    return S_OK;
}",1,<empty>,,174,8,CPPASTProblemDeclaration,,<empty>
633381,UNKNOWN,9,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetRuntimeId(_Outptr_result_maybenull_ SAFEARRAY** ppRuntimeId)
{
    // Root defers this to host, others must implement it...
    RETURN_HR_IF(E_INVALIDARG, ppRuntimeId == nullptr);
    *ppRuntimeId = nullptr;

    // AppendRuntimeId is a magic Number that tells UIAutomation to Append its own Runtime ID(From the HWND)
    const std::array<int, 2> rId{ UiaAppendRuntimeId, -1 };

    const std::span<const int> span{ rId.data(), rId.size() };
    // BuildIntSafeArray is a custom function to hide the SafeArray creation
    *ppRuntimeId = BuildIntSafeArray(span);
    RETURN_IF_NULL_ALLOC(*ppRuntimeId);

    UiaTracing::TextProvider::GetRuntimeId(*this);
    return S_OK;
}",1,<empty>,,185,9,CPPASTProblemDeclaration,,<empty>
633382,UNKNOWN,10,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetEmbeddedFragmentRoots(_Outptr_result_maybenull_ SAFEARRAY** ppRoots) noexcept
{
    RETURN_HR_IF(E_INVALIDARG, ppRoots == nullptr);
    *ppRoots = nullptr;
    UiaTracing::TextProvider::GetEmbeddedFragmentRoots(*this);
    return S_OK;
}",1,<empty>,,203,10,CPPASTProblemDeclaration,,<empty>
633398,UNKNOWN,12,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetSelection(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRetVal);
    *ppRetVal = nullptr;

    _LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // make a safe array
    auto hr = S_OK;
    *ppRetVal = SafeArrayCreateVector(VT_UNKNOWN, 0, 1);
    RETURN_HR_IF_NULL(E_OUTOFMEMORY, *ppRetVal);

    WRL::ComPtr<UiaTextRangeBase> range;
    if (!_pData->IsSelectionActive())
    {
        // return a degenerate range at the cursor position
        const auto& cursor = _getTextBuffer().GetCursor();
        hr = CreateTextRange(this, cursor, _wordDelimiters, &range);
    }
    else
    {
        // get the selection range
        hr = GetSelectionRange(this, _wordDelimiters, &range);
    }

    if (FAILED(hr))
    {
        SafeArrayDestroy(*ppRetVal);
        *ppRetVal = nullptr;
        ret...",1,<empty>,,221,12,CPPASTProblemDeclaration,,<empty>
633399,UNKNOWN,13,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::GetVisibleRanges(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRetVal);
    *ppRetVal = nullptr;

    _LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // make a safe array
    *ppRetVal = SafeArrayCreateVector(VT_UNKNOWN, 0, 1);
    RETURN_HR_IF_NULL(E_OUTOFMEMORY, *ppRetVal);

    WRL::ComPtr<UiaTextRangeBase> range;
    const auto bufferSize = _pData->GetTextBuffer().GetSize();
    const auto viewport = bufferSize.ConvertToOrigin(_getViewport());

    const til::point start{ viewport.Left(), viewport.Top() };
    const til::point end{ viewport.Left(), viewport.BottomExclusive() };

    auto hr = CreateTextRange(this, start, end, _wordDelimiters, &range);
    if (FAILED(hr))
    {
        SafeArrayDestroy(*ppRetVal);
        *ppRetVal = nullptr;
        return hr;
    }

    UiaTracing...",1,<empty>,,271,13,CPPASTProblemDeclaration,,<empty>
633400,UNKNOWN,14,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::RangeFromChild(_In_ IRawElementProviderSimple* /*childElement*/,
                                                         _COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRetVal);
    *ppRetVal = nullptr;

    WRL::ComPtr<UiaTextRangeBase> utr;
    RETURN_IF_FAILED(CreateTextRange(this, _wordDelimiters, &utr));
    RETURN_IF_FAILED(utr.CopyTo(ppRetVal));
    UiaTracing::TextProvider::RangeFromChild(*this, *utr.Get());
    return S_OK;
}",1,<empty>,,315,14,CPPASTProblemDeclaration,,<empty>
633401,UNKNOWN,15,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::RangeFromPoint(_In_ UiaPoint point,
                                                         _COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRetVal);
    *ppRetVal = nullptr;

    WRL::ComPtr<UiaTextRangeBase> utr;
    RETURN_IF_FAILED(CreateTextRange(this,
                                     point,
                                     _wordDelimiters,
                                     &utr));
    RETURN_IF_FAILED(utr.CopyTo(ppRetVal));
    UiaTracing::TextProvider::RangeFromPoint(*this, point, *utr.Get());
    return S_OK;
}",1,<empty>,,328,15,CPPASTProblemDeclaration,,<empty>
633402,UNKNOWN,16,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::get_DocumentRange(_COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppRetVal);
    *ppRetVal = nullptr;

    WRL::ComPtr<UiaTextRangeBase> utr;
    RETURN_IF_FAILED(CreateTextRange(this, _wordDelimiters, &utr));
    RETURN_IF_FAILED(utr->ExpandToEnclosingUnit(TextUnit::TextUnit_Document));
    RETURN_IF_FAILED(utr.CopyTo(ppRetVal));
    UiaTracing::TextProvider::get_DocumentRange(*this, *utr.Get());
    return S_OK;
}",1,<empty>,,344,16,CPPASTProblemDeclaration,,<empty>
633403,UNKNOWN,17,,"IFACEMETHODIMP ScreenInfoUiaProviderBase::get_SupportedTextSelection(_Out_ SupportedTextSelection* pRetVal) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pRetVal);

    *pRetVal = SupportedTextSelection::SupportedTextSelection_Single;
    UiaTracing::TextProvider::get_SupportedTextSelection(*this, *pRetVal);
    return S_OK;
}",1,<empty>,,357,17,CPPASTProblemDeclaration,,<empty>
633472,UNKNOWN,-1,,"virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ std::wstring_view wordDelimiters = UiaTextRangeBase::DefaultWordDelimiter) noexcept;",9,<empty>,,42,1,CPPASTProblemDeclaration,,<empty>
633497,UNKNOWN,-1,,[[nodiscard]] HRESULT Signal(_In_ EVENTID id);,9,<empty>,,50,7,CPPASTProblemDeclaration,,<empty>
633503,UNKNOWN,-1,,IFACEMETHODIMP get_ProviderOptions(_Out_ ProviderOptions* pOptions) noexcept override;,9,<empty>,,54,9,CPPASTProblemDeclaration,,<empty>
633504,UNKNOWN,-1,,"IFACEMETHODIMP GetPatternProvider(_In_ PATTERNID iid,
                                          _COM_Outptr_result_maybenull_ IUnknown** ppInterface) override;",9,<empty>,,55,10,CPPASTProblemDeclaration,,<empty>
633505,UNKNOWN,-1,,"IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) noexcept override;",9,<empty>,,57,11,CPPASTProblemDeclaration,,<empty>
633506,UNKNOWN,-1,,IFACEMETHODIMP get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider) noexcept override;,9,<empty>,,59,12,CPPASTProblemDeclaration,,<empty>
633507,UNKNOWN,-1,,"IFACEMETHODIMP Navigate(_In_ NavigateDirection direction, _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) override = 0;",9,<empty>,,62,13,CPPASTProblemDeclaration,,<empty>
633508,UNKNOWN,-1,,IFACEMETHODIMP GetRuntimeId(_Outptr_result_maybenull_ SAFEARRAY** ppRuntimeId) override;,9,<empty>,,63,14,CPPASTProblemDeclaration,,<empty>
633509,UNKNOWN,-1,,IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) override = 0;,9,<empty>,,64,15,CPPASTProblemDeclaration,,<empty>
633510,UNKNOWN,-1,,IFACEMETHODIMP GetEmbeddedFragmentRoots(_Outptr_result_maybenull_ SAFEARRAY** ppRoots) noexcept override;,9,<empty>,,65,16,CPPASTProblemDeclaration,,<empty>
633515,UNKNOWN,-1,,IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) override = 0;,9,<empty>,,67,18,CPPASTProblemDeclaration,,<empty>
633516,UNKNOWN,-1,,IFACEMETHODIMP GetSelection(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) override;,9,<empty>,,70,19,CPPASTProblemDeclaration,,<empty>
633517,UNKNOWN,-1,,IFACEMETHODIMP GetVisibleRanges(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) override;,9,<empty>,,71,20,CPPASTProblemDeclaration,,<empty>
633518,UNKNOWN,-1,,"IFACEMETHODIMP RangeFromChild(_In_ IRawElementProviderSimple* childElement,
                                      _COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override;",9,<empty>,,72,21,CPPASTProblemDeclaration,,<empty>
633519,UNKNOWN,-1,,"IFACEMETHODIMP RangeFromPoint(_In_ UiaPoint point,
                                      _COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override;",9,<empty>,,74,22,CPPASTProblemDeclaration,,<empty>
633520,UNKNOWN,-1,,IFACEMETHODIMP get_DocumentRange(_COM_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override;,9,<empty>,,76,23,CPPASTProblemDeclaration,,<empty>
633521,UNKNOWN,-1,,IFACEMETHODIMP get_SupportedTextSelection(_Out_ SupportedTextSelection* pRetVal) noexcept override;,9,<empty>,,77,24,CPPASTProblemDeclaration,,<empty>
633526,UNKNOWN,-1,,"virtual HRESULT GetSelectionRange(_In_ IRawElementProviderSimple* pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr) = 0;",9,<empty>,,82,26,CPPASTProblemDeclaration,,<empty>
633527,UNKNOWN,-1,,"virtual HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr) = 0;",9,<empty>,,85,27,CPPASTProblemDeclaration,,<empty>
633528,UNKNOWN,-1,,"virtual HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                        const Cursor& cursor,
                                        const std::wstring_view wordDelimiters,
                                        _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr) = 0;",9,<empty>,,88,28,CPPASTProblemDeclaration,,<empty>
633529,UNKNOWN,-1,,"virtual HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                        const til::point start,
                                        const til::point end,
                                        const std::wstring_view wordDelimiters,
                                        _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr) = 0;",9,<empty>,,94,29,CPPASTProblemDeclaration,,<empty>
633530,UNKNOWN,-1,,"virtual HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                        const UiaPoint point,
                                        const std::wstring_view wordDelimiters,
                                        _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr) = 0;",9,<empty>,,101,30,CPPASTProblemDeclaration,,<empty>
633577,UNKNOWN,1,,"HRESULT TermControlUiaProvider::RuntimeClassInitialize(_In_ Console::Render::IRenderData* const renderData,
                                                       _In_ ::Microsoft::Console::Types::IControlAccessibilityInfo* controlInfo) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, renderData);
    RETURN_IF_FAILED(ScreenInfoUiaProviderBase::RuntimeClassInitialize(renderData));

    _controlInfo = controlInfo;
    return S_OK;
}",1,<empty>,,12,1,CPPASTProblemDeclaration,,<empty>
633578,UNKNOWN,2,,"IFACEMETHODIMP TermControlUiaProvider::GetPropertyValue(_In_ PROPERTYID propertyId,
                                                        _Out_ VARIANT* pVariant) noexcept
{
    pVariant->vt = VT_EMPTY;

    // Returning the default will leave the property as the default
    // so we only really need to touch it for the properties we want to implement
    switch (propertyId)
    {
    case UIA_ClassNamePropertyId:
        pVariant->bstrVal = SysAllocString(L""TermControl"");
        if (pVariant->bstrVal != nullptr)
        {
            pVariant->vt = VT_BSTR;
        }
        break;
    case UIA_ControlTypePropertyId:
        pVariant->vt = VT_I4;
        pVariant->lVal = UIA_TextControlTypeId;
        break;
    case UIA_LocalizedControlTypePropertyId:
        // TODO: we should use RS_(L""TerminalControl_ControlType""),
        // but that's exposed/defined in the TermControl project
        pVariant->bstrVal = SysAllocString(L""terminal"");
        if (pVariant->bstrVal != nullptr...",1,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
633579,UNKNOWN,3,,"IFACEMETHODIMP TermControlUiaProvider::Navigate(_In_ NavigateDirection direction,
                                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppProvider);
    *ppProvider = nullptr;

    if (direction == NavigateDirection_Parent)
    {
        try
        {
            // TODO GitHub #2102: UIA Tree Navigation
            //_pUiaParent->QueryInterface(IID_PPV_ARGS(ppProvider));
        }
        catch (...)
        {
            *ppProvider = nullptr;
            return wil::ResultFromCaughtException();
        }
        RETURN_IF_NULL_ALLOC(*ppProvider);
    }

    // For the other directions the default of nullptr is correct
    return S_OK;
}",1,<empty>,,68,3,CPPASTProblemDeclaration,,<empty>
633580,UNKNOWN,4,,"IFACEMETHODIMP TermControlUiaProvider::get_BoundingRectangle(_Out_ UiaRect* pRect) noexcept
{
    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    //Tracing::s_TraceUia(this, ApiCall::GetBoundingRectangle, nullptr);

    const auto rc = _controlInfo->GetBounds();

    pRect->left = rc.left;
    pRect->top = rc.top;
    pRect->width = static_cast<double>(rc.right) - static_cast<double>(rc.left);
    pRect->height = static_cast<double>(rc.bottom) - static_cast<double>(rc.top);

    return S_OK;
}",1,<empty>,,93,4,CPPASTProblemDeclaration,,<empty>
633581,UNKNOWN,5,,"IFACEMETHODIMP TermControlUiaProvider::get_HostRawElementProvider(_COM_Outptr_result_maybenull_ IRawElementProviderSimple** ppProvider) noexcept
{
    try
    {
        return _controlInfo->GetHostUiaProvider(ppProvider);
    }
    CATCH_RETURN();
}",1,<empty>,,108,5,CPPASTProblemDeclaration,,<empty>
633582,UNKNOWN,6,,"IFACEMETHODIMP TermControlUiaProvider::get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) noexcept
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppProvider);

    // TODO GitHub #1914: Re-attach Tracing to UIA Tree
    //Tracing::s_TraceUia(this, ApiCall::GetFragmentRoot, nullptr);
    try
    {
        // TODO GitHub #2102: UIA Tree Navigation - the special fragments that knows about all of its descendants is called a fragment root
        //_pUiaParent->QueryInterface(IID_PPV_ARGS(ppProvider));
        *ppProvider = nullptr;
    }
    catch (...)
    {
        *ppProvider = nullptr;
        return wil::ResultFromCaughtException();
    }
    RETURN_IF_NULL_ALLOC(*ppProvider);
    return S_OK;
}",1,<empty>,,117,6,CPPASTProblemDeclaration,,<empty>
633620,UNKNOWN,11,,"HRESULT TermControlUiaProvider::GetSelectionRange(_In_ IRawElementProviderSimple* pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;

    const auto start = _pData->GetSelectionAnchor();

    // we need to make end exclusive
    auto end = _pData->GetSelectionEnd();
    _pData->GetTextBuffer().GetSize().IncrementInBounds(end, true);

    TermControlUiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<TermControlUiaTextRange>(&result, _pData, pProvider, start, end, _pData->IsBlockSelection(), wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,158,11,CPPASTProblemDeclaration,,<empty>
633621,UNKNOWN,12,,"HRESULT TermControlUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    TermControlUiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<TermControlUiaTextRange>(&result, _pData, pProvider, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,175,12,CPPASTProblemDeclaration,,<empty>
633622,UNKNOWN,13,,"HRESULT TermControlUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                                const Cursor& cursor,
                                                const std::wstring_view wordDelimiters,
                                                _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    TermControlUiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<TermControlUiaTextRange>(&result, _pData, pProvider, cursor, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,185,13,CPPASTProblemDeclaration,,<empty>
633623,UNKNOWN,14,,"HRESULT TermControlUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                                const til::point start,
                                                const til::point end,
                                                const std::wstring_view wordDelimiters,
                                                _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    TermControlUiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<TermControlUiaTextRange>(&result, _pData, pProvider, start, end, false, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,198,14,CPPASTProblemDeclaration,,<empty>
633624,UNKNOWN,15,,"HRESULT TermControlUiaProvider::CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                                const UiaPoint point,
                                                const std::wstring_view wordDelimiters,
                                                _COM_Outptr_result_maybenull_ UiaTextRangeBase** ppUtr)
{
    RETURN_HR_IF_NULL(E_INVALIDARG, ppUtr);
    *ppUtr = nullptr;
    TermControlUiaTextRange* result = nullptr;
    RETURN_IF_FAILED(MakeAndInitialize<TermControlUiaTextRange>(&result, _pData, pProvider, point, wordDelimiters));
    *ppUtr = result;
    return S_OK;
}",1,<empty>,,212,15,CPPASTProblemDeclaration,,<empty>
633645,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* const renderData,
                                       _In_ ::Microsoft::Console::Types::IControlAccessibilityInfo* controlInfo) noexcept;",9,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
633646,UNKNOWN,-1,,"IFACEMETHODIMP GetPropertyValue(_In_ PROPERTYID idProp,
                                        _Out_ VARIANT* pVariant) noexcept override;",9,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
633647,UNKNOWN,-1,,"IFACEMETHODIMP Navigate(_In_ NavigateDirection direction,
                                _COM_Outptr_result_maybenull_ IRawElementProviderFragment** ppProvider) noexcept override;",9,<empty>,,40,4,CPPASTProblemDeclaration,,<empty>
633653,UNKNOWN,-1,,IFACEMETHODIMP get_BoundingRectangle(_Out_ UiaRect* pRect) noexcept override;,9,<empty>,,43,6,CPPASTProblemDeclaration,,<empty>
633654,UNKNOWN,-1,,IFACEMETHODIMP get_FragmentRoot(_COM_Outptr_result_maybenull_ IRawElementProviderFragmentRoot** ppProvider) noexcept override;,9,<empty>,,44,7,CPPASTProblemDeclaration,,<empty>
633672,UNKNOWN,-1,,"HRESULT GetSelectionRange(_In_ IRawElementProviderSimple* pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,52,12,CPPASTProblemDeclaration,,<empty>
633673,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider, const std::wstring_view wordDelimiters, _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,55,13,CPPASTProblemDeclaration,,<empty>
633674,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const Cursor& cursor,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,58,14,CPPASTProblemDeclaration,,<empty>
633675,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const til::point start,
                                const til::point end,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,64,15,CPPASTProblemDeclaration,,<empty>
633676,UNKNOWN,-1,,"HRESULT CreateTextRange(_In_ IRawElementProviderSimple* const pProvider,
                                const UiaPoint point,
                                const std::wstring_view wordDelimiters,
                                _COM_Outptr_result_maybenull_ Microsoft::Console::Types::UiaTextRangeBase** ppUtr) override;",9,<empty>,,71,16,CPPASTProblemDeclaration,,<empty>
633753,UNKNOWN,1,,"HRESULT TermControlUiaTextRange::RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData, _In_ IRawElementProviderSimple* const pProvider, _In_ const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, wordDelimiters);
}",1,<empty>,,13,1,CPPASTProblemDeclaration,,<empty>
633754,UNKNOWN,2,,"HRESULT TermControlUiaTextRange::RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                                        _In_ IRawElementProviderSimple* const pProvider,
                                                        const Cursor& cursor,
                                                        const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, cursor, wordDelimiters);
}",1,<empty>,,18,2,CPPASTProblemDeclaration,,<empty>
633755,UNKNOWN,3,,"HRESULT TermControlUiaTextRange::RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                                        _In_ IRawElementProviderSimple* const pProvider,
                                                        const til::point start,
                                                        const til::point end,
                                                        bool blockRange,
                                                        const std::wstring_view wordDelimiters) noexcept
{
    return UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, start, end, blockRange, wordDelimiters);
}",1,<empty>,,26,3,CPPASTProblemDeclaration,,<empty>
633756,UNKNOWN,4,,"HRESULT TermControlUiaTextRange::RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                                        _In_ IRawElementProviderSimple* const pProvider,
                                                        const UiaPoint point,
                                                        const std::wstring_view wordDelimiters)
{
    RETURN_IF_FAILED(UiaTextRangeBase::RuntimeClassInitialize(pData, pProvider, wordDelimiters));
    Initialize(point);
    return S_OK;
}",1,<empty>,,38,4,CPPASTProblemDeclaration,,<empty>
633768,UNKNOWN,6,,"IFACEMETHODIMP TermControlUiaTextRange::Clone(_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal)
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;
    const auto hr = MakeAndInitialize<TermControlUiaTextRange>(ppRetVal, *this);

    if (hr != S_OK)
    {
        *ppRetVal = nullptr;
        return hr;
    }

    return S_OK;
}",1,<empty>,,54,6,CPPASTProblemDeclaration,,<empty>
633776,UNKNOWN,1,,TermControlUiaProvider*,73,<empty>,,78,1,CPPASTTypeId,,<empty>
633843,UNKNOWN,1,,TermControlUiaProvider*,73,<empty>,,112,1,CPPASTTypeId,,<empty>
633909,UNKNOWN,1,,TermControlUiaProvider*,79,<empty>,,142,1,CPPASTTypeId,,<empty>
633934,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       _In_ const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
633935,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const Cursor& cursor,
                                       const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
633936,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const til::point start,
                                       const til::point end,
                                       bool blockRange = false,
                                       const std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept override;",9,<empty>,,41,4,CPPASTProblemDeclaration,,<empty>
633937,UNKNOWN,-1,,"HRESULT RuntimeClassInitialize(_In_ Console::Render::IRenderData* pData,
                                       _In_ IRawElementProviderSimple* const pProvider,
                                       const UiaPoint point,
                                       const std::wstring_view wordDelimiters = DefaultWordDelimiter);",9,<empty>,,49,5,CPPASTProblemDeclaration,,<empty>
633943,UNKNOWN,-1,,IFACEMETHODIMP Clone(_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override;,9,<empty>,,56,7,CPPASTProblemDeclaration,,<empty>
633998,UNKNOWN,2,,"HRESULT UiaTextRangeBase::RuntimeClassInitialize(_In_ Render::IRenderData* pData, _In_ IRawElementProviderSimple* const pProvider, _In_ std::wstring_view wordDelimiters) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pProvider);
    RETURN_HR_IF_NULL(E_INVALIDARG, pData);

    _pProvider = pProvider;
    _pData = pData;
    _start = pData->GetViewport().Origin();
    _end = pData->GetViewport().Origin();
    _blockRange = false;
    _wordDelimiters = wordDelimiters;

    UiaTracing::TextRange::Constructor(*this);
    return S_OK;
}",1,<empty>,,19,2,CPPASTProblemDeclaration,,<empty>
633999,UNKNOWN,3,,CATCH_RETURN();,1,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
634000,UNKNOWN,4,,"HRESULT UiaTextRangeBase::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                                 _In_ IRawElementProviderSimple* const pProvider,
                                                 _In_ const Cursor& cursor,
                                                 _In_ std::wstring_view wordDelimiters) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pData);
    RETURN_IF_FAILED(RuntimeClassInitialize(pData, pProvider, wordDelimiters));

    // GH#8730: The cursor position may be in a delayed state, resulting in it being out of bounds.
    // If that's the case, clamp it to be within bounds.
    // TODO GH#12440: We should be able to just check some fields off of the Cursor object,
    // but Windows Terminal isn't updating those flags properly.
    _start = cursor.GetPosition();
    pData->GetTextBuffer().GetSize().Clamp(_start);
    _end = _start;

    UiaTracing::TextRange::Constructor(*this);
    return S_OK;
}",1,<empty>,,38,4,CPPASTProblemDeclaration,,<empty>
634001,UNKNOWN,5,,CATCH_RETURN();,1,<empty>,,58,5,CPPASTProblemDeclaration,,<empty>
634002,UNKNOWN,6,,"HRESULT UiaTextRangeBase::RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                                 _In_ IRawElementProviderSimple* const pProvider,
                                                 _In_ const til::point start,
                                                 _In_ const til::point end,
                                                 _In_ bool blockRange,
                                                 _In_ std::wstring_view wordDelimiters) noexcept
try
{
    RETURN_IF_FAILED(RuntimeClassInitialize(pData, pProvider, wordDelimiters));

    // start must be before or equal to end
    _start = std::min(start, end);
    _end = std::max(start, end);

    // This should be the only way to set if we are a blockRange
    // This is used for blockSelection
    _blockRange = blockRange;

    UiaTracing::TextRange::Constructor(*this);
    return S_OK;
}",1,<empty>,,61,6,CPPASTProblemDeclaration,,<empty>
634003,UNKNOWN,7,,CATCH_RETURN();,1,<empty>,,82,7,CPPASTProblemDeclaration,,<empty>
634004,UNKNOWN,8,,"void UiaTextRangeBase::Initialize(_In_ const UiaPoint point)
{
    til::point clientPoint;
    clientPoint.x = static_cast<LONG>(point.x);
    clientPoint.y = static_cast<LONG>(point.y);
    // get row that point resides in
    const auto windowRect = _getTerminalRect();
    const auto viewport = _pData->GetViewport().ToInclusive();
    til::CoordType row = 0;
    if (clientPoint.y <= windowRect.top)
    {
        row = viewport.top;
    }
    else if (clientPoint.y >= windowRect.bottom)
    {
        row = viewport.bottom;
    }
    else
    {
        // change point coords to pixels relative to window
        _TranslatePointFromScreen(&clientPoint);

        const auto currentFontSize = _getScreenFontSize();
        row = clientPoint.y / currentFontSize.height + viewport.top;
    }
    _start = { 0, row };
    _end = _start;
}",1,<empty>,,84,8,CPPASTProblemDeclaration,,<empty>
634005,UNKNOWN,9,,"HRESULT UiaTextRangeBase::RuntimeClassInitialize(const UiaTextRangeBase& a) noexcept
try
{
    _pProvider = a._pProvider;
    _start = a._start;
    _end = a._end;
    _pData = a._pData;
    _wordDelimiters = a._wordDelimiters;
    _blockRange = a._blockRange;

    UiaTracing::TextRange::Constructor(*this);
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,114,9,CPPASTProblemDeclaration,,<empty>
634082,UNKNOWN,13,,"IFACEMETHODIMP UiaTextRangeBase::Compare(_In_opt_ ITextRangeProvider* pRange, _Out_ BOOL* pRetVal) noexcept
{
    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });

    RETURN_HR_IF(E_INVALIDARG, pRetVal == nullptr);
    *pRetVal = FALSE;
    const UiaTextRangeBase* other = static_cast<UiaTextRangeBase*>(pRange);
    if (other)
    {
        *pRetVal = (_start == other->GetEndpoint(TextPatternRangeEndpoint_Start) &&
                    _end == other->GetEndpoint(TextPatternRangeEndpoint_End));
    }

    UiaTracing::TextRange::Compare(*this, *other, *pRetVal);
    return S_OK;
}",1,<empty>,,185,13,CPPASTProblemDeclaration,,<empty>
634083,UNKNOWN,14,,"IFACEMETHODIMP UiaTextRangeBase::CompareEndpoints(_In_ TextPatternRangeEndpoint endpoint,
                                                  _In_ ITextRangeProvider* pTargetRange,
                                                  _In_ TextPatternRangeEndpoint targetEndpoint,
                                                  _Out_ int* pRetVal) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pRetVal);
    *pRetVal = 0;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // get the text range that we're comparing to
    const UiaTextRangeBase* range = static_cast<UiaTextRangeBase*>(pTargetRange);
    RETURN_HR_IF_NULL(E_INVALIDARG, range);

    // get endpoint value that we're comparing to
    const auto other = range->GetEndpoint(targetEndpoint);

    // get the values of our endpoint
    const auto mine = GetEndpoint(endpoint);

    // TODO GH#5406: c...",1,<empty>,,205,14,CPPASTProblemDeclaration,,<empty>
634084,UNKNOWN,15,,CATCH_RETURN();,1,<empty>,,242,15,CPPASTProblemDeclaration,,<empty>
634085,UNKNOWN,16,,"IFACEMETHODIMP UiaTextRangeBase::ExpandToEnclosingUnit(_In_ TextUnit unit) noexcept
{
    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    try
    {
        _expandToEnclosingUnit(unit);
        UiaTracing::TextRange::ExpandToEnclosingUnit(unit, *this);
        return S_OK;
    }
    CATCH_RETURN();
}",1,<empty>,,244,16,CPPASTProblemDeclaration,,<empty>
634484,UNKNOWN,19,,"IFACEMETHODIMP UiaTextRangeBase::FindAttribute(_In_ TEXTATTRIBUTEID attributeId,
                                               _In_ VARIANT val,
                                               _In_ BOOL searchBackwards,
                                               _Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // AttributeIDs that require special handling
    switch (attributeId)
    {
    case UIA_FontNameAttributeId:
    {
        RETURN_HR_IF(E_INVALIDARG, val.vt != VT_BSTR);

        // Technically, we'll truncate early if there's an embedded null in the BSTR.
        // But we're probably fine in this circumstance.

        const std::wstring_view queryFontName{ val.bstrVal, SysStringLen(val.bs...",1,<empty>,,433,19,CPPASTProblemDeclaration,,<empty>
634485,UNKNOWN,20,,CATCH_RETURN();,1,<empty>,,599,20,CPPASTProblemDeclaration,,<empty>
634486,UNKNOWN,21,,"IFACEMETHODIMP UiaTextRangeBase::FindText(_In_ BSTR text,
                                          _In_ BOOL searchBackward,
                                          _In_ BOOL ignoreCase,
                                          _Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    const std::wstring_view queryText{ text, SysStringLen(text) };
    auto exclusiveBegin = _start;

    // MovePastPoint() moves *past* the given point.
    // -> We need to turn [_beg,_end) into (_beg,_end).
    exclusiveBegin.x--;

    _searcher.ResetIfStale(*_pData, queryText, searchBackward, ignoreCase);
    _searcher.MovePastPoint(searchBackward ? _end : exclusiveBegin);

    til::point hitBeg{ til::CoordTypeMax, til::CoordT...",1,<empty>,,601,21,CPPASTProblemDeclaration,,<empty>
634487,UNKNOWN,22,,CATCH_RETURN();,1,<empty>,,648,22,CPPASTProblemDeclaration,,<empty>
634712,UNKNOWN,24,,"IFACEMETHODIMP UiaTextRangeBase::GetAttributeValue(_In_ TEXTATTRIBUTEID attributeId,
                                                   _Out_ VARIANT* pRetVal) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, pRetVal == nullptr);
    VariantInit(pRetVal);

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // AttributeIDs that require special handling
    switch (attributeId)
    {
    case UIA_FontNameAttributeId:
    {
        pRetVal->vt = VT_BSTR;
        pRetVal->bstrVal = SysAllocString(_pData->GetFontInfo().GetFaceName().data());
        UiaTracing::TextRange::GetAttributeValue(*this, attributeId, *pRetVal);
        return S_OK;
    }
    case UIA_IsReadOnlyAttributeId:
    {
        pRetVal->vt = VT_BOOL;
        pRetVal->boolVal = VARIANT_FALSE;
        UiaTracing::TextRange::GetAttributeValue(*this, attributeId, *pRetVal);
        return S_OK;
  ...",1,<empty>,,738,24,CPPASTProblemDeclaration,,<empty>
634713,UNKNOWN,25,,CATCH_RETURN();,1,<empty>,,835,25,CPPASTProblemDeclaration,,<empty>
634714,UNKNOWN,26,,"IFACEMETHODIMP UiaTextRangeBase::GetBoundingRectangles(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) noexcept
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    try
    {
        // vector to put coords into. they go in as four doubles in the
        // order: left, top, width, height. each line will have its own
        // set of coords.
        std::vector<double> coords;

        // GH#6402: Get the actual buffer size here, instead of the one
        //          constrained by the virtual bottom.
        const auto& buffer = _pData->GetTextBuffer();
        const auto bufferSize = buffer.GetSize();

        // these viewport vars are converted to the buffer coordinate space
        const auto viewport = bufferSize.ConvertToOrigin(_pData->GetViewport());
        const a...",1,<empty>,,837,26,CPPASTProblemDeclaration,,<empty>
634715,UNKNOWN,27,,"IFACEMETHODIMP UiaTextRangeBase::GetEnclosingElement(_Outptr_result_maybenull_ IRawElementProviderSimple** ppRetVal) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);
    *ppRetVal = nullptr;

    const auto hr = _pProvider->QueryInterface(IID_PPV_ARGS(ppRetVal));
    UiaTracing::TextRange::GetEnclosingElement(*this);
    return hr;
}",1,<empty>,,924,27,CPPASTProblemDeclaration,,<empty>
634716,UNKNOWN,28,,CATCH_RETURN();,1,<empty>,,934,28,CPPASTProblemDeclaration,,<empty>
634717,UNKNOWN,29,,"IFACEMETHODIMP UiaTextRangeBase::GetText(_In_ int maxLength, _Out_ BSTR* pRetVal) noexcept
try
{
    RETURN_HR_IF_NULL(E_INVALIDARG, pRetVal);
    RETURN_HR_IF(E_INVALIDARG, maxLength < -1);
    *pRetVal = nullptr;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    const auto text = _getTextValue(maxLength);
    Unlock.reset();

    *pRetVal = SysAllocString(text.c_str());
    RETURN_HR_IF_NULL(E_OUTOFMEMORY, *pRetVal);

    UiaTracing::TextRange::GetText(*this, maxLength, text);
    return S_OK;
}",1,<empty>,,936,29,CPPASTProblemDeclaration,,<empty>
634718,UNKNOWN,30,,CATCH_RETURN();,1,<empty>,,958,30,CPPASTProblemDeclaration,,<empty>
634856,UNKNOWN,32,,"IFACEMETHODIMP UiaTextRangeBase::Move(_In_ TextUnit unit,
                                      _In_ int count,
                                      _Out_ int* pRetVal) noexcept
try
{
    RETURN_HR_IF(E_INVALIDARG, pRetVal == nullptr);
    *pRetVal = 0;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // We can abstract this movement by moving _start
    // GH#7342: check if we're past the documentEnd
    // If so, clamp each endpoint to the end of the document.
    constexpr auto endpoint = TextPatternRangeEndpoint::TextPatternRangeEndpoint_Start;
    const auto bufferSize{ _pData->GetTextBuffer().GetSize() };
    const auto documentEnd = _getDocumentEnd();
    _start = std::min(_start, documentEnd);
    _end = std::min(_end, documentEnd);

    const auto wasDegenerate = IsDegenerate();
    if (count != 0)
    {
        const auto preventBoundary =...",1,<empty>,,1017,32,CPPASTProblemDeclaration,,<empty>
634857,UNKNOWN,33,,CATCH_RETURN();,1,<empty>,,1077,33,CPPASTProblemDeclaration,,<empty>
634858,UNKNOWN,34,,"IFACEMETHODIMP UiaTextRangeBase::MoveEndpointByUnit(_In_ TextPatternRangeEndpoint endpoint,
                                                    _In_ TextUnit unit,
                                                    _In_ int count,
                                                    _Out_ int* pRetVal) noexcept
{
    RETURN_HR_IF(E_INVALIDARG, pRetVal == nullptr);
    *pRetVal = 0;

    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());
    RETURN_HR_IF(S_OK, count == 0);

    // GH#7342: check if we're past the documentEnd
    // If so, clamp each endpoint to the end of the document.
    const auto bufferSize{ _pData->GetTextBuffer().GetSize() };

    auto documentEnd = bufferSize.EndExclusive();
    try
    {
        documentEnd = _getDocumentEnd();
    }
    CATCH_LOG();

    _start = std::min(_start, documentEnd);
    _end = std::min(_end, documentEnd);

   ...",1,<empty>,,1079,34,CPPASTProblemDeclaration,,<empty>
634859,UNKNOWN,35,,"IFACEMETHODIMP UiaTextRangeBase::MoveEndpointByRange(_In_ TextPatternRangeEndpoint endpoint,
                                                     _In_ ITextRangeProvider* pTargetRange,
                                                     _In_ TextPatternRangeEndpoint targetEndpoint) noexcept
try
{
    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });

    const UiaTextRangeBase* range = static_cast<UiaTextRangeBase*>(pTargetRange);
    RETURN_HR_IF_NULL(E_INVALIDARG, range);
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    // TODO GH#5406: create a different UIA parent object for each TextBuffer
    //   This is a temporary solution to comparing two UTRs from different TextBuffers
    //   Ensure both endpoints fit in the current buffer.
    const auto bufferSize = _pData->GetTextBuffer().GetSize();
    const auto mine = GetEndpoint(endpoint);
    const auto other = range->GetEndpoint(targetEndpoint);
  ...",1,<empty>,,1133,35,CPPASTProblemDeclaration,,<empty>
634860,UNKNOWN,36,,CATCH_RETURN();,1,<empty>,,1160,36,CPPASTProblemDeclaration,,<empty>
634861,UNKNOWN,37,,"IFACEMETHODIMP UiaTextRangeBase::Select() noexcept
try
{
    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    if (IsDegenerate())
    {
        // calling Select on a degenerate range should clear any current selections
        _pData->ClearSelection();
    }
    else
    {
        const auto bufferSize = _pData->GetTextBuffer().GetSize();
        if (!bufferSize.IsInBounds(_start, true) || !bufferSize.IsInBounds(_end, true))
        {
            return E_FAIL;
        }
        auto inclusiveEnd = _end;
        bufferSize.DecrementInBounds(inclusiveEnd);
        _pData->SelectNewRegion(_start, inclusiveEnd);
    }

    UiaTracing::TextRange::Select(*this);
    return S_OK;
}
CATCH_RETURN();",1,<empty>,,1162,37,CPPASTProblemDeclaration,,<empty>
634890,UNKNOWN,40,,"IFACEMETHODIMP UiaTextRangeBase::ScrollIntoView(_In_ BOOL alignToTop) noexcept
try
{
    _pData->LockConsole();
    auto Unlock = wil::scope_exit([&]() noexcept {
        _pData->UnlockConsole();
    });
    RETURN_HR_IF(E_FAIL, !_pData->IsUiaDataInitialized());

    const auto oldViewport = _pData->GetViewport().ToInclusive();
    const auto viewportHeight = _getViewportHeight(oldViewport);
    // range rows
    const auto startScreenInfoRow = _start.y;
    const auto endScreenInfoRow = _end.y;
    // screen buffer rows
    constexpr til::CoordType topRow = 0;
    const auto bottomRow = _pData->GetTextBuffer().TotalRowCount() - 1;

    auto newViewport = oldViewport;

    // there's a bunch of +1/-1s here for setting the viewport. These
    // are to account for the inclusivity of the viewport boundaries.
    if (alignToTop)
    {
        // determine if we can align the start row to the top
        if (startScreenInfoRow + viewportHeight <= bottomRow)
        {
            // we c...",1,<empty>,,1207,40,CPPASTProblemDeclaration,,<empty>
634891,UNKNOWN,41,,CATCH_RETURN();,1,<empty>,,1281,41,CPPASTProblemDeclaration,,<empty>
634892,UNKNOWN,42,,"IFACEMETHODIMP UiaTextRangeBase::GetChildren(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) noexcept
{
    RETURN_HR_IF(E_INVALIDARG, ppRetVal == nullptr);

    // we don't have any children
    *ppRetVal = SafeArrayCreateVector(VT_UNKNOWN, 0, 0);
    if (*ppRetVal == nullptr)
    {
        return E_OUTOFMEMORY;
    }
    UiaTracing::TextRange::GetChildren(*this);
    return S_OK;
}",1,<empty>,,1283,42,CPPASTProblemDeclaration,,<empty>
635032,UNKNOWN,47,,"void UiaTextRangeBase::_getBoundingRect(const til::rect& textRect, _Inout_ std::vector<double>& coords) const
{
    const auto currentFontSize = _getScreenFontSize();

    til::point topLeft;
    til::point bottomRight;

    // we want to clamp to a long (output type), not a short (input type)
    // so we need to explicitly say <long,long>
    topLeft.x = textRect.left * currentFontSize.width;
    topLeft.y = textRect.top * currentFontSize.height;

    bottomRight.x = textRect.right * currentFontSize.width;
    bottomRight.y = textRect.bottom * currentFontSize.height;

    // convert the coords to be relative to the screen instead of
    // the client window
    _TranslatePointToScreen(&topLeft);
    _TranslatePointToScreen(&bottomRight);

    const long width = bottomRight.x - topLeft.x;
    const long height = bottomRight.y - topLeft.y;

    // insert the coords
    coords.push_back(topLeft.x);
    coords.push_back(topLeft.y);
    coords.push_back(width);
    coords.push_back(hei...",1,<empty>,,1367,47,CPPASTProblemDeclaration,,<empty>
635033,UNKNOWN,48,,"void UiaTextRangeBase::_moveEndpointByUnitCharacter(_In_ const int moveCount,
                                                    _In_ const TextPatternRangeEndpoint endpoint,
                                                    _Out_ const gsl::not_null<int*> pAmountMoved,
                                                    _In_ const bool preventBufferEnd)
{
    *pAmountMoved = 0;

    if (moveCount == 0)
    {
        return;
    }

    const auto allowBottomExclusive = !preventBufferEnd;
    const auto moveDirection = (moveCount > 0) ? MovementDirection::Forward : MovementDirection::Backward;
    const auto& buffer = _pData->GetTextBuffer();

    auto success = true;
    til::point target{ GetEndpoint(endpoint) };
    const auto documentEnd{ _getDocumentEnd() };
    while (std::abs(*pAmountMoved) < std::abs(moveCount) && success)
    {
        switch (moveDirection)
        {
        case MovementDirection::Forward:
            success = buffer.MoveToNextGlyph(target, allowBottom...",1,<empty>,,1409,48,CPPASTProblemDeclaration,,<empty>
635034,UNKNOWN,49,,"void UiaTextRangeBase::_moveEndpointByUnitWord(_In_ const int moveCount,
                                               _In_ const TextPatternRangeEndpoint endpoint,
                                               _Out_ const gsl::not_null<int*> pAmountMoved,
                                               _In_ const bool preventBufferEnd)
{
    *pAmountMoved = 0;

    if (moveCount == 0)
    {
        return;
    }

    const auto allowBottomExclusive = !preventBufferEnd;
    const auto moveDirection = (moveCount > 0) ? MovementDirection::Forward : MovementDirection::Backward;
    const auto& buffer = _pData->GetTextBuffer();
    const auto bufferSize = buffer.GetSize();
    const auto bufferOrigin = bufferSize.Origin();
    const auto documentEnd = _getDocumentEnd();

    auto resultPos = GetEndpoint(endpoint);
    auto nextPos = resultPos;

    auto success = true;
    while (std::abs(*pAmountMoved) < std::abs(moveCount) && success)
    {
        nextPos = resultPos;
        switch...",1,<empty>,,1466,49,CPPASTProblemDeclaration,,<empty>
635066,UNKNOWN,51,,"void UiaTextRangeBase::_moveEndpointByUnitLine(_In_ const int moveCount,
                                               _In_ const TextPatternRangeEndpoint endpoint,
                                               _Out_ const gsl::not_null<int*> pAmountMoved,
                                               _In_ const bool preventBoundary) noexcept
{
    *pAmountMoved = 0;

    if (moveCount == 0)
    {
        return;
    }

    const auto allowBottomExclusive = !preventBoundary;
    const auto moveDirection = (moveCount > 0) ? MovementDirection::Forward : MovementDirection::Backward;
    const auto bufferSize = _getOptimizedBufferSize();

    auto documentEnd{ bufferSize.EndExclusive() };
    try
    {
        documentEnd = _getDocumentEnd();
    }
    CATCH_LOG();

    auto success = true;
    auto resultPos = GetEndpoint(endpoint);

    while (std::abs(*pAmountMoved) < std::abs(moveCount) && success)
    {
        auto nextPos = resultPos;
        switch (moveDirection)
        {
 ...",1,<empty>,,1582,51,CPPASTProblemDeclaration,,<empty>
635067,UNKNOWN,52,,"void UiaTextRangeBase::_moveEndpointByUnitDocument(_In_ const int moveCount,
                                                   _In_ const TextPatternRangeEndpoint endpoint,
                                                   _Out_ const gsl::not_null<int*> pAmountMoved,
                                                   _In_ const bool preventBoundary) noexcept
{
    *pAmountMoved = 0;

    if (moveCount == 0)
    {
        return;
    }

    const auto moveDirection = (moveCount > 0) ? MovementDirection::Forward : MovementDirection::Backward;
    const auto bufferSize = _getOptimizedBufferSize();

    const auto target = GetEndpoint(endpoint);
    switch (moveDirection)
    {
    case MovementDirection::Forward:
    {
        auto documentEnd{ bufferSize.EndExclusive() };
        try
        {
            documentEnd = _getDocumentEnd();
        }
        CATCH_LOG();

        if (preventBoundary || target >= documentEnd)
        {
            return;
        }
        else
       ...",1,<empty>,,1690,52,CPPASTProblemDeclaration,,<empty>
635140,UNKNOWN,-1,,"virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;",9,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
635141,UNKNOWN,-1,,"virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ const Cursor& cursor,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;",9,<empty>,,54,4,CPPASTProblemDeclaration,,<empty>
635142,UNKNOWN,-1,,"virtual HRESULT RuntimeClassInitialize(_In_ Render::IRenderData* pData,
                                               _In_ IRawElementProviderSimple* const pProvider,
                                               _In_ const til::point start,
                                               _In_ const til::point end,
                                               _In_ bool blockRange = false,
                                               _In_ std::wstring_view wordDelimiters = DefaultWordDelimiter) noexcept;",9,<empty>,,60,5,CPPASTProblemDeclaration,,<empty>
635187,UNKNOWN,-1,,IFACEMETHODIMP Clone(_Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) override = 0;,9,<empty>,,80,15,CPPASTProblemDeclaration,,<empty>
635188,UNKNOWN,-1,,"IFACEMETHODIMP Compare(_In_opt_ ITextRangeProvider* pRange, _Out_ BOOL* pRetVal) noexcept override;",9,<empty>,,81,16,CPPASTProblemDeclaration,,<empty>
635189,UNKNOWN,-1,,"IFACEMETHODIMP CompareEndpoints(_In_ TextPatternRangeEndpoint endpoint,
                                        _In_ ITextRangeProvider* pTargetRange,
                                        _In_ TextPatternRangeEndpoint targetEndpoint,
                                        _Out_ int* pRetVal) noexcept override;",9,<empty>,,82,17,CPPASTProblemDeclaration,,<empty>
635190,UNKNOWN,-1,,IFACEMETHODIMP ExpandToEnclosingUnit(_In_ TextUnit unit) noexcept override;,9,<empty>,,86,18,CPPASTProblemDeclaration,,<empty>
635191,UNKNOWN,-1,,"IFACEMETHODIMP FindAttribute(_In_ TEXTATTRIBUTEID textAttributeId,
                                     _In_ VARIANT val,
                                     _In_ BOOL searchBackward,
                                     _Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) noexcept override;",9,<empty>,,87,19,CPPASTProblemDeclaration,,<empty>
635192,UNKNOWN,-1,,"IFACEMETHODIMP FindText(_In_ BSTR text,
                                _In_ BOOL searchBackward,
                                _In_ BOOL ignoreCase,
                                _Outptr_result_maybenull_ ITextRangeProvider** ppRetVal) noexcept override;",9,<empty>,,91,20,CPPASTProblemDeclaration,,<empty>
635193,UNKNOWN,-1,,"IFACEMETHODIMP GetAttributeValue(_In_ TEXTATTRIBUTEID textAttributeId,
                                         _Out_ VARIANT* pRetVal) noexcept override;",9,<empty>,,95,21,CPPASTProblemDeclaration,,<empty>
635194,UNKNOWN,-1,,IFACEMETHODIMP GetBoundingRectangles(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) noexcept override;,9,<empty>,,97,22,CPPASTProblemDeclaration,,<empty>
635195,UNKNOWN,-1,,IFACEMETHODIMP GetEnclosingElement(_Outptr_result_maybenull_ IRawElementProviderSimple** ppRetVal) noexcept override;,9,<empty>,,98,23,CPPASTProblemDeclaration,,<empty>
635196,UNKNOWN,-1,,"IFACEMETHODIMP GetText(_In_ int maxLength,
                               _Out_ BSTR* pRetVal) noexcept override;",9,<empty>,,99,24,CPPASTProblemDeclaration,,<empty>
635197,UNKNOWN,-1,,"IFACEMETHODIMP Move(_In_ TextUnit unit,
                            _In_ int count,
                            _Out_ int* pRetVal) noexcept override;",9,<empty>,,101,25,CPPASTProblemDeclaration,,<empty>
635198,UNKNOWN,-1,,"IFACEMETHODIMP MoveEndpointByUnit(_In_ TextPatternRangeEndpoint endpoint,
                                          _In_ TextUnit unit,
                                          _In_ int count,
                                          _Out_ int* pRetVal) noexcept override;",9,<empty>,,104,26,CPPASTProblemDeclaration,,<empty>
635199,UNKNOWN,-1,,"IFACEMETHODIMP MoveEndpointByRange(_In_ TextPatternRangeEndpoint endpoint,
                                           _In_ ITextRangeProvider* pTargetRange,
                                           _In_ TextPatternRangeEndpoint targetEndpoint) noexcept override;",9,<empty>,,108,27,CPPASTProblemDeclaration,,<empty>
635212,UNKNOWN,-1,,IFACEMETHODIMP ScrollIntoView(_In_ BOOL alignToTop) noexcept override;,9,<empty>,,114,31,CPPASTProblemDeclaration,,<empty>
635213,UNKNOWN,-1,,IFACEMETHODIMP GetChildren(_Outptr_result_maybenull_ SAFEARRAY** ppRetVal) noexcept override;,9,<empty>,,115,32,CPPASTProblemDeclaration,,<empty>
635232,UNKNOWN,-1,,void Initialize(_In_ const UiaPoint point);,9,<empty>,,129,40,CPPASTProblemDeclaration,,<empty>
635262,UNKNOWN,-1,,"void _getBoundingRect(const til::rect& textRect, _Inout_ std::vector<double>& coords) const;",9,<empty>,,151,50,CPPASTProblemDeclaration,,<empty>
635268,UNKNOWN,-1,,"void
        _moveEndpointByUnitCharacter(_In_ const int moveCount,
                                     _In_ const TextPatternRangeEndpoint endpoint,
                                     const gsl::not_null<int*> pAmountMoved,
                                     _In_ const bool preventBufferEnd = false);",9,<empty>,,155,52,CPPASTProblemDeclaration,,<empty>
635269,UNKNOWN,-1,,"void
        _moveEndpointByUnitWord(_In_ const int moveCount,
                                _In_ const TextPatternRangeEndpoint endpoint,
                                const gsl::not_null<int*> pAmountMoved,
                                _In_ const bool preventBufferEnd = false);",9,<empty>,,161,53,CPPASTProblemDeclaration,,<empty>
635270,UNKNOWN,-1,,"void
        _moveEndpointByUnitLine(_In_ const int moveCount,
                                _In_ const TextPatternRangeEndpoint endpoint,
                                const gsl::not_null<int*> pAmountMoved,
                                _In_ const bool preventBoundary = false) noexcept;",9,<empty>,,167,54,CPPASTProblemDeclaration,,<empty>
635271,UNKNOWN,-1,,"void
        _moveEndpointByUnitDocument(_In_ const int moveCount,
                                    _In_ const TextPatternRangeEndpoint endpoint,
                                    const gsl::not_null<int*> pAmountMoved,
                                    _In_ const bool preventBoundary = false) noexcept;",9,<empty>,,173,55,CPPASTProblemDeclaration,,<empty>
635461,UNKNOWN,1,,"TRACELOGGING_DEFINE_PROVIDER(g_UiaProviderTraceProvider,
                             ""Microsoft.Windows.Console.UIA"",
                             // tl:{e7ebce59-2161-572d-b263-2f16a6afb9e5}
                             (0xe7ebce59, 0x2161, 0x572d, 0xb2, 0x63, 0x2f, 0x16, 0xa6, 0xaf, 0xb9, 0xe5));",1,<empty>,,11,1,CPPASTProblemDeclaration,,<empty>
636075,UNKNOWN,1,,ULONG,57,<empty>,,275,1,CPPASTTypeId,,<empty>
636245,UNKNOWN,1,,ULONG,59,<empty>,,339,1,CPPASTTypeId,,<empty>
638751,UNKNOWN,3,,"static constinit til::presorted_static_map xorgAppVariantColorTable{
    std::pair{ ""antiquewhite""sv, std::array<til::color, 5>{ til::color{ 250, 235, 215 }, til::color{ 255, 239, 219 }, til::color{ 238, 223, 204 }, til::color{ 205, 192, 176 }, til::color{ 139, 131, 120 } } },
    std::pair{ ""aquamarine""sv, std::array<til::color, 5>{ til::color{ 127, 255, 212 }, til::color{ 127, 255, 212 }, til::color{ 118, 238, 198 }, til::color{ 102, 205, 170 }, til::color{ 69, 139, 116 } } },
    std::pair{ ""azure""sv, std::array<til::color, 5>{ til::color{ 240, 255, 255 }, til::color{ 240, 255, 255 }, til::color{ 224, 238, 238 }, til::color{ 193, 205, 205 }, til::color{ 131, 139, 139 } } },
    std::pair{ ""bisque""sv, std::array<til::color, 5>{ til::color{ 255, 228, 196 }, til::color{ 255, 228, 196 }, til::color{ 238, 213, 183 }, til::color{ 205, 183, 158 }, til::color{ 139, 125, 107 } } },
    std::pair{ ""blue""sv, std::array<til::color, 5>{ til::color{ 0, 0, 255 }, til::color{ 0, 0, 255 }, til::c...",1,<empty>,,270,3,CPPASTProblemDeclaration,,<empty>
638752,UNKNOWN,4,,"static constinit til::presorted_static_map xorgAppColorTable{
    std::pair{ ""aliceblue""sv, til::color{ 240, 248, 255 } },
    std::pair{ ""aqua""sv, til::color{ 0, 255, 255 } },
    std::pair{ ""beige""sv, til::color{ 245, 245, 220 } },
    std::pair{ ""black""sv, til::color{ 0, 0, 0 } },
    std::pair{ ""blanchedalmond""sv, til::color{ 255, 235, 205 } },
    std::pair{ ""blueviolet""sv, til::color{ 138, 43, 226 } },
    std::pair{ ""cornflowerblue""sv, til::color{ 100, 149, 237 } },
    std::pair{ ""crimson""sv, til::color{ 220, 20, 60 } },
    std::pair{ ""darkblue""sv, til::color{ 0, 0, 139 } },
    std::pair{ ""darkcyan""sv, til::color{ 0, 139, 139 } },
    std::pair{ ""darkgray""sv, til::color{ 169, 169, 169 } },
    std::pair{ ""darkgreen""sv, til::color{ 0, 100, 0 } },
    std::pair{ ""darkgrey""sv, til::color{ 169, 169, 169 } },
    std::pair{ ""darkkhaki""sv, til::color{ 189, 183, 107 } },
    std::pair{ ""darkmagenta""sv, til::color{ 139, 0, 139 } },
    std::pair{ ""darkred""sv, til::color{ 139, 0, 0...",1,<empty>,,351,4,CPPASTProblemDeclaration,,<empty>
639594,UNKNOWN,1,,LPWSTR,54,<empty>,,22,1,CPPASTTypeId,,<empty>
639758,UNKNOWN,1,,short,28,<empty>,,37,1,CPPASTTypeId,,<empty>
639765,UNKNOWN,1,,long,58,<empty>,,38,1,CPPASTTypeId,,<empty>
639768,UNKNOWN,1,,long,58,<empty>,,39,1,CPPASTTypeId,,<empty>
639777,UNKNOWN,-1,,GUID GuidFromString(_Null_terminated_ const wchar_t* str);,5,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
639856,UNKNOWN,-1,,),44,<empty>,,66,18,CPPASTProblemDeclaration,,<empty>
640187,UNKNOWN,-1,,bool TrimToViewport(_Inout_ til::rect* psr) const noexcept;,9,<empty>,,93,39,CPPASTProblemDeclaration,,<empty>
640188,UNKNOWN,-1,,void ConvertToOrigin(_Inout_ til::rect* psr) const noexcept;,9,<empty>,,94,40,CPPASTProblemDeclaration,,<empty>
640189,UNKNOWN,-1,,void ConvertToOrigin(_Inout_ til::inclusive_rect* const psr) const noexcept;,9,<empty>,,95,41,CPPASTProblemDeclaration,,<empty>
640190,UNKNOWN,-1,,void ConvertToOrigin(_Inout_ til::point* const pcoord) const noexcept;,9,<empty>,,96,42,CPPASTProblemDeclaration,,<empty>
640196,UNKNOWN,-1,,void ConvertFromOrigin(_Inout_ til::inclusive_rect* const psr) const noexcept;,9,<empty>,,98,44,CPPASTProblemDeclaration,,<empty>
640197,UNKNOWN,-1,,void ConvertFromOrigin(_Inout_ til::point* const pcoord) const noexcept;,9,<empty>,,99,45,CPPASTProblemDeclaration,,<empty>
640380,UNKNOWN,1,,SgrSaveRestoreStackOptions,49,<empty>,,37,1,CPPASTTypeId,,<empty>
641924,UNKNOWN,1,,COLORREF,46,<empty>,,336,1,CPPASTTypeId,,<empty>
642389,UNKNOWN,2,,};,1,<empty>,,43,2,CPPASTProblemDeclaration,,<empty>
642404,UNKNOWN,1,,wchar_t,57,<empty>,,184,1,CPPASTTypeId,,<empty>
642718,UNKNOWN,3,,"GUID Utils::GuidFromString(_Null_terminated_ const wchar_t* str)
{
    GUID result;
    THROW_IF_FAILED(IIDFromString(str, &result));
    return result;
}",1,<empty>,,45,3,CPPASTProblemDeclaration,,<empty>
642766,UNKNOWN,1,,int,39,<empty>,,75,1,CPPASTTypeId,,<empty>
642779,UNKNOWN,1,,int,39,<empty>,,76,1,CPPASTTypeId,,<empty>
642792,UNKNOWN,1,,int,39,<empty>,,77,1,CPPASTTypeId,,<empty>
644162,UNKNOWN,1,,PUCHAR,74,<empty>,,636,1,CPPASTTypeId,,<empty>
644175,UNKNOWN,1,,PUCHAR,74,<empty>,,638,1,CPPASTTypeId,,<empty>
644177,UNKNOWN,1,,std::byte*,93,<empty>,,638,1,CPPASTTypeId,,<empty>
645560,UNKNOWN,36,,"bool Viewport::TrimToViewport(_Inout_ til::rect* psr) const noexcept
{
    psr->left = std::max(psr->left, Left());
    psr->right = std::min(psr->right, RightExclusive());
    psr->top = std::max(psr->top, Top());
    psr->bottom = std::min(psr->bottom, BottomExclusive());

    return psr->left < psr->right && psr->top < psr->bottom;
}",1,<empty>,,696,36,CPPASTProblemDeclaration,,<empty>
645561,UNKNOWN,37,,"void Viewport::ConvertToOrigin(_Inout_ til::rect* psr) const noexcept
{
    const auto dx = Left();
    const auto dy = Top();
    psr->left -= dx;
    psr->right -= dx;
    psr->top -= dy;
    psr->bottom -= dy;
}",1,<empty>,,713,37,CPPASTProblemDeclaration,,<empty>
645562,UNKNOWN,38,,"void Viewport::ConvertToOrigin(_Inout_ til::inclusive_rect* const psr) const noexcept
{
    const auto dx = Left();
    const auto dy = Top();
    psr->left -= dx;
    psr->right -= dx;
    psr->top -= dy;
    psr->bottom -= dy;
}",1,<empty>,,730,38,CPPASTProblemDeclaration,,<empty>
645563,UNKNOWN,39,,"void Viewport::ConvertToOrigin(_Inout_ til::point* const pcoord) const noexcept
{
    pcoord->x -= Left();
    pcoord->y -= Top();
}",1,<empty>,,747,39,CPPASTProblemDeclaration,,<empty>
645564,UNKNOWN,40,,"void Viewport::ConvertFromOrigin(_Inout_ til::inclusive_rect* const psr) const noexcept
{
    const auto dx = Left();
    const auto dy = Top();
    psr->left += dx;
    psr->right += dx;
    psr->top += dy;
    psr->bottom += dy;
}",1,<empty>,,760,40,CPPASTProblemDeclaration,,<empty>
645565,UNKNOWN,41,,"void Viewport::ConvertFromOrigin(_Inout_ til::point* const pcoord) const noexcept
{
    pcoord->x += Left();
    pcoord->y += Top();
}",1,<empty>,,777,41,CPPASTProblemDeclaration,,<empty>
645891,UNKNOWN,50,,"[[nodiscard]] SomeViewports Viewport::Subtract(const Viewport& original, const Viewport& removeMe) noexcept
try
{
    SomeViewports result;

    // We could have up to four rectangles describing the area resulting when you take removeMe out of main.
    // Find the intersection of the two so we know which bits of removeMe are actually applicable
    // to the original rectangle for subtraction purposes.
    const auto intersection = Viewport::Intersect(original, removeMe);

    // If there's no intersection, there's nothing to remove.
    if (!intersection.IsValid())
    {
        // Just put the original rectangle into the results and return early.
        result.push_back(original);
    }
    // If the original rectangle matches the intersection, there is nothing to return.
    else if (original != intersection)
    {
        // Generate our potential four viewports that represent the region of the original that falls outside of the remove area.
        // We will bias toward gene...",1,<empty>,,956,50,CPPASTProblemDeclaration,,<empty>
646011,UNKNOWN,-1,,S,23,<empty>,,31,3,CPPASTProblemStatement,,<empty>
646129,UNKNOWN,-1,,"return {
        .hpcon = std::move(hpcon),
        .pipes = std::move(pipes.our),",5,<empty>,,55,5,CPPASTProblemStatement,,<empty>
646132,UNKNOWN,7,,},1,<empty>,,59,7,CPPASTProblemDeclaration,,<empty>
646194,UNKNOWN,-1,,),33,<empty>,,92,2,CPPASTProblemDeclaration,,<empty>
646195,UNKNOWN,-1,,"TEST_CLASS_PROPERTY(L""TestTimeout"", L""0:0:15"") // 15s timeout
    END_TEST_CLASS()

    const COORD defaultSize = { 80, 30 };",9,<empty>,,93,3,CPPASTProblemDeclaration,,<empty>
646203,UNKNOWN,10,,"static HRESULT _CreatePseudoConsole(const COORD size,
                                    const HANDLE hInput,
                                    const HANDLE hOutput,
                                    const DWORD dwFlags,
                                    _Inout_ PseudoConsole* pPty)
{
    return _CreatePseudoConsole(INVALID_HANDLE_VALUE, size, hInput, hOutput, dwFlags, pPty);
}",1,<empty>,,106,10,CPPASTProblemDeclaration,,<empty>
646253,UNKNOWN,1,,PPROC_THREAD_ATTRIBUTE_LIST,45,<empty>,,125,1,CPPASTTypeId,,<empty>
646319,UNKNOWN,1,,HANDLE,26,<empty>,,154,1,CPPASTTypeId,,<empty>
646325,UNKNOWN,1,,HANDLE,27,<empty>,,155,1,CPPASTTypeId,,<empty>
646401,UNKNOWN,1,,HANDLE,26,<empty>,,178,1,CPPASTTypeId,,<empty>
646407,UNKNOWN,1,,HANDLE,27,<empty>,,179,1,CPPASTTypeId,,<empty>
646750,UNKNOWN,1,,DWORD,31,<empty>,,286,1,CPPASTTypeId,,<empty>
646776,UNKNOWN,1,,DWORD,31,<empty>,,293,1,CPPASTTypeId,,<empty>
646791,UNKNOWN,1,,DWORD,70,<empty>,,298,1,CPPASTTypeId,,<empty>
646803,UNKNOWN,1,,DWORD,31,<empty>,,300,1,CPPASTTypeId,,<empty>
646810,UNKNOWN,-1,,),34,<empty>,,305,2,CPPASTProblemStatement,,<empty>
646814,UNKNOWN,-1,,),34,<empty>,,314,4,CPPASTProblemStatement,,<empty>
646925,UNKNOWN,1,,DWORD,31,<empty>,,345,1,CPPASTTypeId,,<empty>
646931,UNKNOWN,1,,const wchar_t*,47,<empty>,,348,1,CPPASTTypeId,,<empty>
646959,UNKNOWN,1,,DWORD,31,<empty>,,352,1,CPPASTTypeId,,<empty>
646990,UNKNOWN,1,,DWORD,31,<empty>,,359,1,CPPASTTypeId,,<empty>
647017,UNKNOWN,1,,DWORD,35,<empty>,,367,1,CPPASTTypeId,,<empty>
647318,UNKNOWN,4,,"HRESULT _CreatePseudoConsole(const HANDLE hToken,
                             const COORD size,
                             const HANDLE hInput,
                             const HANDLE hOutput,
                             const DWORD dwFlags,
                             _Inout_ PseudoConsole* pPty)
{
    if (pPty == nullptr)
    {
        return E_INVALIDARG;
    }
    if (size.X == 0 || size.Y == 0)
    {
        return E_INVALIDARG;
    }

    wil::unique_handle serverHandle;
    RETURN_IF_NTSTATUS_FAILED(CreateServerHandle(serverHandle.addressof(), TRUE));

    // The hPtyReference we create here is used when the PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE attribute is processed.
    // This ensures that conhost's client processes inherit the correct (= our) console handle.
    wil::unique_handle referenceHandle;
    RETURN_IF_NTSTATUS_FAILED(CreateClientHandle(referenceHandle.addressof(),
                                                 serverHandle.get(),
                        ...",1,<empty>,,96,4,CPPASTProblemDeclaration,,<empty>
647319,UNKNOWN,5,,"HRESULT _ResizePseudoConsole(_In_ const PseudoConsole* const pPty, _In_ const COORD size)
{
    if (pPty == nullptr || size.X < 0 || size.Y < 0)
    {
        return E_INVALIDARG;
    }

    unsigned short signalPacket[3];
    signalPacket[0] = PTY_SIGNAL_RESIZE_WINDOW;
    signalPacket[1] = size.X;
    signalPacket[2] = size.Y;

    const auto fSuccess = WriteFile(pPty->hSignal, signalPacket, sizeof(signalPacket), nullptr, nullptr);
    return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}",1,<empty>,,250,5,CPPASTProblemDeclaration,,<empty>
647320,UNKNOWN,6,,"HRESULT _ClearPseudoConsole(_In_ const PseudoConsole* const pPty)
{
    if (pPty == nullptr)
    {
        return E_INVALIDARG;
    }

    unsigned short signalPacket[1];
    signalPacket[0] = PTY_SIGNAL_CLEAR_WINDOW;

    const auto fSuccess = WriteFile(pPty->hSignal, signalPacket, sizeof(signalPacket), nullptr, nullptr);
    return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}",1,<empty>,,273,6,CPPASTProblemDeclaration,,<empty>
647321,UNKNOWN,7,,"HRESULT _ShowHidePseudoConsole(_In_ const PseudoConsole* const pPty, const bool show)
{
    if (pPty == nullptr)
    {
        return E_INVALIDARG;
    }
    unsigned short signalPacket[2];
    signalPacket[0] = PTY_SIGNAL_SHOWHIDE_WINDOW;
    signalPacket[1] = show;

    const BOOL fSuccess = WriteFile(pPty->hSignal, signalPacket, sizeof(signalPacket), nullptr, nullptr);
    return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}",1,<empty>,,296,7,CPPASTProblemDeclaration,,<empty>
647322,UNKNOWN,8,,"HRESULT _ReparentPseudoConsole(_In_ const PseudoConsole* const pPty, _In_ const HWND newParent)
{
    if (pPty == nullptr)
    {
        return E_INVALIDARG;
    }

    // sneaky way to pack a short and a uint64_t in a relatively literal way.
#pragma pack(push, 1)
    struct _signal
    {
        const unsigned short id;
        const uint64_t hwnd;
    };
#pragma pack(pop)

    const _signal data{
        PTY_SIGNAL_REPARENT_WINDOW,
        (uint64_t)(newParent),
    };
    const auto fSuccess = WriteFile(pPty->hSignal, &data, sizeof(data), nullptr, nullptr);

    return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}",1,<empty>,,322,8,CPPASTProblemDeclaration,,<empty>
647323,UNKNOWN,9,,"void _ClosePseudoConsoleMembers(_In_ PseudoConsole* pPty, _In_ DWORD dwMilliseconds)
{
    if (pPty != nullptr)
    {
        // See MSFT:19918626
        // First break the signal pipe - this will trigger conhost to tear itself down
        if (_HandleIsValid(pPty->hSignal))
        {
            CloseHandle(pPty->hSignal);
            pPty->hSignal = nullptr;
        }
        // The reference handle ensures that conhost keeps running unless ClosePseudoConsole is called.
        // We have to call it before calling WaitForSingleObject however in order to not deadlock,
        // Due to conhost waiting for all clients to disconnect, while we wait for conhost to exit.
        if (_HandleIsValid(pPty->hPtyReference))
        {
            CloseHandle(pPty->hPtyReference);
            pPty->hPtyReference = nullptr;
        }
        // Then, wait on the conhost process before killing it.
        // We do this to make sure the conhost finishes flushing any output it
        //      has...",1,<empty>,,357,9,CPPASTProblemDeclaration,,<empty>
647324,UNKNOWN,10,,"static void _ClosePseudoConsole(_In_ PseudoConsole* pPty, _In_ DWORD dwMilliseconds) noexcept
{
    if (pPty != nullptr)
    {
        _ClosePseudoConsoleMembers(pPty, dwMilliseconds);
        HeapFree(GetProcessHeap(), 0, pPty);
    }
}",1,<empty>,,401,10,CPPASTProblemDeclaration,,<empty>
647325,UNKNOWN,11,,"extern ""C"" HRESULT WINAPI ConptyCreatePseudoConsole(_In_ COORD size,
                                                    _In_ HANDLE hInput,
                                                    _In_ HANDLE hOutput,
                                                    _In_ DWORD dwFlags,
                                                    _Out_ HPCON* phPC)
{
    return ConptyCreatePseudoConsoleAsUser(INVALID_HANDLE_VALUE, size, hInput, hOutput, dwFlags, phPC);
}",1,<empty>,,437,11,CPPASTProblemDeclaration,,<empty>
647326,UNKNOWN,12,,"extern ""C"" HRESULT WINAPI ConptyCreatePseudoConsoleAsUser(_In_ HANDLE hToken,
                                                          _In_ COORD size,
                                                          _In_ HANDLE hInput,
                                                          _In_ HANDLE hOutput,
                                                          _In_ DWORD dwFlags,
                                                          _Out_ HPCON* phPC)
{
    if (phPC == nullptr)
    {
        return E_INVALIDARG;
    }
    *phPC = nullptr;
    if ((!_HandleIsValid(hInput)) && (!_HandleIsValid(hOutput)))
    {
        return E_INVALIDARG;
    }

    auto pPty = (PseudoConsole*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PseudoConsole));
    RETURN_IF_NULL_ALLOC(pPty);
    auto cleanupPty = wil::scope_exit([&]() noexcept {
        _ClosePseudoConsole(pPty, 0);
    });

    wil::unique_handle duplicatedInput;
    wil::unique_handle duplicatedOutput;
    RETURN_IF_WIN32...",1,<empty>,,446,12,CPPASTProblemDeclaration,,<empty>
647327,UNKNOWN,13,,"extern ""C"" HRESULT WINAPI ConptyResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size)
{
    const PseudoConsole* const pPty = (PseudoConsole*)hPC;
    auto hr = pPty == nullptr ? E_INVALIDARG : S_OK;
    if (SUCCEEDED(hr))
    {
        hr = _ResizePseudoConsole(pPty, size);
    }
    return hr;
}",1,<empty>,,484,13,CPPASTProblemDeclaration,,<empty>
647328,UNKNOWN,14,,"extern ""C"" HRESULT WINAPI ConptyClearPseudoConsole(_In_ HPCON hPC)
{
    const PseudoConsole* const pPty = (PseudoConsole*)hPC;
    auto hr = pPty == nullptr ? E_INVALIDARG : S_OK;
    if (SUCCEEDED(hr))
    {
        hr = _ClearPseudoConsole(pPty);
    }
    return hr;
}",1,<empty>,,501,14,CPPASTProblemDeclaration,,<empty>
647329,UNKNOWN,15,,"extern ""C"" HRESULT WINAPI ConptyShowHidePseudoConsole(_In_ HPCON hPC, bool show)
{
    // _ShowHidePseudoConsole will return E_INVALIDARG for us if the hPC is nullptr.
    return _ShowHidePseudoConsole((PseudoConsole*)hPC, show);
}",1,<empty>,,517,15,CPPASTProblemDeclaration,,<empty>
647330,UNKNOWN,16,,"extern ""C"" HRESULT WINAPI ConptyReparentPseudoConsole(_In_ HPCON hPC, HWND newParent)
{
    return _ReparentPseudoConsole((PseudoConsole*)hPC, newParent);
}",1,<empty>,,528,16,CPPASTProblemDeclaration,,<empty>
647331,UNKNOWN,17,,"extern ""C"" HRESULT WINAPI ConptyReleasePseudoConsole(_In_ HPCON hPC)
{
    const auto pPty = (PseudoConsole*)hPC;
    if (pPty == nullptr)
    {
        return E_INVALIDARG;
    }

    if (_HandleIsValid(pPty->hPtyReference))
    {
        CloseHandle(pPty->hPtyReference);
        pPty->hPtyReference = nullptr;
    }

    return S_OK;
}",1,<empty>,,537,17,CPPASTProblemDeclaration,,<empty>
647332,UNKNOWN,18,,"extern ""C"" VOID WINAPI ConptyClosePseudoConsole(_In_ HPCON hPC)
{
    _ClosePseudoConsole((PseudoConsole*)hPC, INFINITE);
}",1,<empty>,,561,18,CPPASTProblemDeclaration,,<empty>
647333,UNKNOWN,19,,"extern ""C"" VOID WINAPI ConptyClosePseudoConsoleTimeout(_In_ HPCON hPC, _In_ DWORD dwMilliseconds)
{
    _ClosePseudoConsole((PseudoConsole*)hPC, dwMilliseconds);
}",1,<empty>,,573,19,CPPASTProblemDeclaration,,<empty>
647334,UNKNOWN,20,,"extern ""C"" HRESULT WINAPI ConptyPackPseudoConsole(_In_ HANDLE hProcess,
                                                  _In_ HANDLE hRef,
                                                  _In_ HANDLE hSignal,
                                                  _Out_ HPCON* phPC)
{
    RETURN_HR_IF(E_INVALIDARG, nullptr == phPC);
    *phPC = nullptr;
    RETURN_HR_IF(E_INVALIDARG, !_HandleIsValid(hProcess));
    RETURN_HR_IF(E_INVALIDARG, !_HandleIsValid(hRef));
    RETURN_HR_IF(E_INVALIDARG, !_HandleIsValid(hSignal));

    auto pPty = (PseudoConsole*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PseudoConsole));
    RETURN_IF_NULL_ALLOC(pPty);

    pPty->hConPtyProcess = hProcess;
    pPty->hPtyReference = hRef;
    pPty->hSignal = hSignal;

    *phPC = (HPCON)pPty;
    return S_OK;
}",1,<empty>,,587,20,CPPASTProblemDeclaration,,<empty>
647347,UNKNOWN,3,,"HRESULT _CreatePseudoConsole(const HANDLE hToken,
                             const COORD size,
                             const HANDLE hInput,
                             const HANDLE hOutput,
                             const DWORD dwFlags,
                             _Inout_ PseudoConsole* pPty);",1,<empty>,,66,3,CPPASTProblemDeclaration,,<empty>
647348,UNKNOWN,4,,"HRESULT _ResizePseudoConsole(_In_ const PseudoConsole* const pPty, _In_ const COORD size);",1,<empty>,,73,4,CPPASTProblemDeclaration,,<empty>
647349,UNKNOWN,5,,HRESULT _ClearPseudoConsole(_In_ const PseudoConsole* const pPty);,1,<empty>,,74,5,CPPASTProblemDeclaration,,<empty>
647350,UNKNOWN,6,,"HRESULT _ShowHidePseudoConsole(_In_ const PseudoConsole* const pPty, const bool show);",1,<empty>,,75,6,CPPASTProblemDeclaration,,<empty>
647351,UNKNOWN,7,,"HRESULT _ReparentPseudoConsole(_In_ const PseudoConsole* const pPty, _In_ const HWND newParent);",1,<empty>,,76,7,CPPASTProblemDeclaration,,<empty>
647352,UNKNOWN,8,,"void _ClosePseudoConsoleMembers(_In_ PseudoConsole* pPty, _In_ DWORD dwMilliseconds);",1,<empty>,,77,8,CPPASTProblemDeclaration,,<empty>
647353,UNKNOWN,9,,"HRESULT WINAPI ConptyCreatePseudoConsoleAsUser(_In_ HANDLE hToken,
                                               _In_ COORD size,
                                               _In_ HANDLE hInput,
                                               _In_ HANDLE hOutput,
                                               _In_ DWORD dwFlags,
                                               _Out_ HPCON* phPC);",1,<empty>,,79,9,CPPASTProblemDeclaration,,<empty>
